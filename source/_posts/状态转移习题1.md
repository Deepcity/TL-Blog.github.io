---
title: 状态转移习题
date: 2024-08-14 19:30:37
tags: [算法, 状态转移]
categories: 
	- 算法
	- 状态转移
---
# 题意：

给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。

你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个**连续的子段**，然后从该子段中删除**所有**元素，**除**该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。

如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。

# 题解：

根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。

考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]<a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l_{a_i}$下标为j，则小于j且大于$l_{a_j}$的下标k的下标idx均无法转移至i，显然$l_{a_i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l_{a_x}$则无法转移到i。

总结状态转移为$f_i = \sum_{k={l_{a_i}+1}}^{i-1} f_k + \sum_{k=l^x(l_{a_i})}^{k>0}f_{k}$

前缀和处理即可。

```cpp
	void slove(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];

    s[top] = {-1,-1};
    for(int i = 1;i <= n;i++) {
        while(top && s[top].x > a[i]) top--;
        l[i] = s[top].y;
        s[++top] = {a[i],i};
    }

    // for(int i=1;i<=n;i++) cout<<l[i]<<' ';
    // cout<<endl;

    for(int i=0;i<=n;i++) pre1[i] = pre2[i] = 0;

    f[0] = 1;
    pre1[0] = 1;
    for(int i=1;i<=n;i++) {
        if(l[i]!=-1) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;
        int t = l[i] == -1 ? 0: pre1[l[i]];
        f[i] = (pre1[i-1] - t) % MOD ;
        // cout<<(pre1[i-1] - t)<<' ';
        f[i] += pre2[i];

        pre1[i] = pre1[i-1] + f[i] % MOD;
        // cout<<i<<' '<<pre1[i]<<' '<<pre2[i]<<' '<<f[i]<<nline;
    }

    int mi = 1e18,ans = 0;
    for(int i=n; i>=1; i--) {
        mi = min(mi,a[i]);
        if(mi==a[i]) {
            ans = (ans + f[i]) % MOD;
        }
    }
    cout<<ans<<endl;
}
```

