---
title: 状态转移习题3
date: 2024-08-14 19:38:14
tags: [算法, 状态转移, 异或问题]
categories: 
	- 算法
	- 状态转移
	- 状态转移中的异或问题
---
## 题意：

对一个数组的所有非空子区间，计算这个公式$$w = \sum_{i=l}^{i=r} \sum_{j=l}^{j=r}a_i \oplus a_j $$的和。

## 题解：

非常经典的题目，看见了就再巩固一下。

1. 拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\lceil log_2mx\rceil$个数组。计算每一位的贡献。

当拆位后原式子会变为这样的
$$
allW = \sum_{l=1}^{l=r}\sum_{r=l}^{r=n}\sum_{i=l}^{i=r}\sum_{x=0}^{x=\lceil log_2mx\rceil}cnt(a_{i-x} != a_{x})
$$
这个复杂度仍然是爆炸的，因此需要继续优化

很容易想到的一个优化就是，对于$$a_i \oplus a_j$$他是满足交换律的，即$$a_i \oplus a_j = a_j \oplus a_i$$因此我们仅需要计算单边值即可（然后乘2。

因此将原有的式子改写$$w =2 \times (\sum_{i=l}^{i=r} \sum_{j=l}^{j=i}a_i \oplus a_j) $$虽然对于$$a_i$$本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。

再转头考虑所有子区间的问题，一个数组的所有子区间显然是$$n^2$$级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为$$i\times (n-j+1)$$（下标从1开始），则对任意i,j，其贡献值为以下公式
$$
w(bt,{i,j}) = (i\times (n-j+1) * (1<<bt) * (bit(x,a_i)\not=bit(x,a_j))
$$
施展数学的神奇魔法！

提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算$$a_j$$ 与$$a_i|i<j$$的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。

最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。

```cpp
void slove(){
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];

    ll ans = 0;
    for(int bt = 0;bt <=29;bt++) {
        ll s1=0,s2 =0;
        for(int i=1;i<=n;i++) {
            if(a[i] >>bt&1) {
                ans = (ans + s2 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;
                s1 += i;
                s1 %= MOD;
            }
            else {
                ans = (ans + s1 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;
                s2 += i;
                s2 %= MOD;
            }
        }
    }
    cout<<(2ll * ans)%MOD<<endl;
}
```

不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。