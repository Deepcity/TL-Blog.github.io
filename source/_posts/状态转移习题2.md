---
title: 状态转移习题2
date: 2024-08-14 19:32:13
tags: [算法, 状态转移]
categories: 
	- 算法
	- 状态转移
---
# 题意：

给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。

首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。

然后，你必须使数组中的所有元素相等。一开始，你选择一个**正**整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。**注意， x 在所有操作中都是一样的**。

选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？

<!--more-->

# 题解：

容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。

可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。

```
void slove(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];

    int mx = -INF;
    for(int i=1;i<=n;i++) {
        mx = max(mx,a[i]);
    }

    for(int i=1;i<=n;i++) d[i] = mx - a[i];

    int gd = 0;
    for(int i=1;i<=n;i++) gd = __gcd(d[i],gd);

    if(!gd) {cout<<1<<endl;return ;}

    ll sum = 0;
    set<int> S;
    for(int i=1;i<=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);
    int t = 1;
    while(1) if(S.count(t)) t++;else break;
    cout<<sum + t<<endl;
}
```