---
title: 状态转移习题4
date: 2024-08-14 19:41:55
tags: [算法, 状态转移, 离散化]
categories: 
	- 算法
	- 状态转移
	- 复杂状态转移与优化
---
## 题意：

给定m条线段，求将1-n覆盖两次的所有方案数

<!--more-->

## 题解：

离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。

个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。

状态表示这样设计：$$dpi,j,k$$表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。

之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下

```cpp
void slove(){
    cin>>n>>m;
    for(int i=1;i<=m;i++) {
        cin>>segs[i].x>>segs[i].y;
        poss.push_back(segs[i].x);
        poss.push_back(segs[i].y);
    }
    poss.push_back(0);
    poss.push_back(n);
    sort(all(poss));
    poss.erase(unique(all(poss)),poss.end());

    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;

    sort(segs+1,segs+1+m);

    dp[0][0][0] = 1;
    for(int i=1;i<=m;i++) {
        for(int ii=0;ii<i;ii++) {
            for(int j=200;j;j--) {
                for(int k = 200;k;k--)
                    dp[i][j][k] = dp[ii][j][k];
            }
            for(int j=200;~j;j--) {
                for(int k = 200;~k;k--) {
                    if(mp[segs[i].x] <= j+1) {
                        if(mp[segs[i].x] > k+1) {
                            dp[i][max(mp[segs[i].y], j)][k] =
                                (dp[i][max(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;
                            // if(dp[i][max(mp[segs[i].y], j)][k]&&dp[ii][j][k]) {
                            //     cout<<ii<<' '<<j<<' '<<k<<endl;
                            //     cout<<"!"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<k<<' '<<dp[i][max(mp[segs[i].y], j)][k]<<nline;
                            // }
                        }
                        else {
                            dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] =
                                (dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;
                            // if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&&dp[ii][j][k]) {
                            //     cout<<ii<<' '<<j<<' '<<k<<endl;
                            //     cout<<"?"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<max(k,min(j,mp[segs[i].y]))<<' '<<
                            //         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]<<nline;
                            // }
                        }
                    }
                }
            }
        }
    }

    cout<<dp[m][mp[n]][mp[n]]<<endl;
}
```

这段代码中显然有一个很严重的问题：时间复杂度为$$1.6e^{9}$$略微有点超出复杂度

其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。

时间如何优化？

首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f\[i]\[j][k] += f\[i - 1]\[j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。

```cpp
void slove(){
    cin>>n>>m;
    for(int i=1;i<=m;i++) {
        cin>>segs[i].x>>segs[i].y;
        segs[i].x--;
        poss.push_back(segs[i].x);
        poss.push_back(segs[i].y);
    }
    poss.push_back(0);
    poss.push_back(n);
    sort(all(poss));
    poss.erase(unique(all(poss)),poss.end());

    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;

    sort(segs+1,segs+1+m);

    for(int i=1;i<=m;i++) {
        segs[i].x = mp[segs[i].x];
        segs[i].y = mp[segs[i].y];
    }

    f[0][0][0] = 1;
    for (int k = 1; k <= m; k++) {
        for (int i = 0; i <= mp[n]; i++) {
            for (int j = i; j <= mp[n]; j++) {
                if (f[k - 1][i][j] == 0) {
                    continue;
                }
                f[k][i][j] += f[k - 1][i][j];
                f[k][i][j] %=MOD;
                if (segs[k].x <= i) {
                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]+=f[k - 1][i][j];
                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]%=MOD;
                }
            }
        }
    }

    cout<<f[m][mp[n]][mp[n]]% MOD<<endl;
}
```
