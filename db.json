{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/beian.png","path":"images/beian.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/qq-contact.png","path":"images/qq-contact.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechat_channel.jpg","path":"images/wechat_channel.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/_data/languages.yml","hash":"f50fd6ebe8c97b9abe5b7ee3ac6f887383b93ccd","modified":1723628579090},{"_id":"source/404/404.md","hash":"8376757f89e049a3a5685b5fa9539c91713ae513","modified":1723613990887},{"_id":"source/_posts/Latex宏包pgfplots做矩形函数图像.md","hash":"2ae33665d3b6959a0cda695463a815240d90026d","modified":1723642724943},{"_id":"source/_posts/Miracl的配置ForCentos7.md","hash":"14615d5987afb985413cbf71dc7f01ce28ffe67d","modified":1723642728720},{"_id":"source/_posts/cf-edu165C.md","hash":"3a658423bfd445b6ed264884d2d8f7ef1ab96e85","modified":1723687027026},{"_id":"source/_posts/cf-edu165D.md","hash":"b8e5ae16b118e0c9ec1c17900bbe41f47db311cd","modified":1723642717760},{"_id":"source/_posts/RSA涉及算法与数论知识.md","hash":"7dff17cb7672c0377af29bea3d01a1475bc8670c","modified":1723642736431},{"_id":"source/_posts/三种操作系统模拟软件使用手册.md","hash":"55a62f88e91ba3c22a78219edc42b4806c0830cb","modified":1723642739744},{"_id":"source/_posts/为什么我用Typora——Typora与其他markdown的比较.md","hash":"e673ce8b6cec57ed2c9938b87275a33af259b54b","modified":1723642742327},{"_id":"source/_posts/思维题习题1.md","hash":"59e08f4ab9b2e15029969301e74228501388a190","modified":1723642748223},{"_id":"source/_posts/数学距离问题1.md","hash":"869e8e6da900e6cc0921f94c610c2ba77750ba72","modified":1723642751945},{"_id":"source/_posts/树上回文问题.md","hash":"dfd074c9f52e28e0ffe3b4cc206d952909d0261e","modified":1723642754786},{"_id":"source/_posts/状态转移习题1.md","hash":"0800a8b4b867afc04b64c70d5677977db61504e0","modified":1723642758757},{"_id":"source/_posts/状态转移习题3.md","hash":"27d66b4c473e9f7eb306276aa0048289589cb185","modified":1723642765704},{"_id":"source/_posts/状态转移习题4.md","hash":"6fcd363634ac1e626ced2477d2755d4c76eb1a89","modified":1723642769254},{"_id":"source/_posts/状态转移习题2.md","hash":"a92936db6b29a809a3aaeeec47e92221aa44e70a","modified":1723642761942},{"_id":"source/_posts/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估.md","hash":"eb8f820568ff46bebb98fe0a896280bf3475257e","modified":1723688777091},{"_id":"source/_posts/字符串习题1.md","hash":"c2ba5a4d92e4706d8b41cba1256b756709d55735","modified":1723642745118},{"_id":"source/about/index.md","hash":"7768e8a05c4eec51618ec4766fe01e964af83c15","modified":1723643469539},{"_id":"source/categories/index.md","hash":"60b226af341348b28c0b119ebdccc5e58c802085","modified":1723618837565},{"_id":"source/schedule/index.md","hash":"95b3ff5bf09f7e8fe31b55662d015636f60f8f5a","modified":1723637034657},{"_id":"source/tags/index.md","hash":"008e0978586bfc95819e8dbb86b9e75efcdf1a3c","modified":1723612488261},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1723449052458},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1723449052458},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1723449052464},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1723449052459},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1723449052464},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1723449052465},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1723449052463},{"_id":"themes/next/_config.yml","hash":"3d548c36b2fa9ba009482f5f0e00ecf483371118","modified":1723685929171},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1723449052465},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1723449052476},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1723449052509},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1723449052459},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1723449052460},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1723449052461},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1723449052461},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1723449052462},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1723449052462},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1723449052461},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1723449052462},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1723449052463},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1723449052463},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1723449052466},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1723449052463},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1723449052466},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1723449052467},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1723449052467},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1723449052469},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1723449052469},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1723449052469},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1723449052470},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1723449052470},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1723449052477},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1723449052477},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1723449052477},{"_id":"themes/next/img/custom-logo.jpg","hash":"d62188109038d7c4552b03b44edaee3c106dc86b","modified":1591248668000},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1723449052477},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1723449052478},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1723449052478},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1723449052479},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1723449052479},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1723449052479},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1723449052479},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1723449052480},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1723449052480},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1723449052481},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1723449052481},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1723449052482},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1723449052480},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1723449052482},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1723449052482},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1723449052483},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1723449052483},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1723449052484},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1723449052508},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1723449052484},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1723686435818},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1723449052507},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1723449052509},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1723449052508},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1723449052509},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1723449052484},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1723449052516},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1723449052460},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1723449052460},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1723449052460},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1723449052461},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1723449052471},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1723449052471},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1723449052472},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1723449052473},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1723449052473},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1723449052471},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1723449052474},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1723449052474},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1723449052475},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1723449052475},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1723449052474},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1723449052476},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1723449052476},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1723449052485},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1723449052486},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1723449052485},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5a6633e365bad3a291f6295d1c2dfced54bc9bf6","modified":1723686327948},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1723449052486},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1723449052489},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1723449052490},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1723449052493},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1723449052493},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1723449052494},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1723449052495},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1723449052496},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1723449052497},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1723449052499},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1723449052503},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1723449052504},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1723449052504},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1723449052510},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1723449052513},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1723449052513},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1723449052513},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1723449052514},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1723449052514},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1723449052514},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1723449052515},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1723449052515},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1723449052515},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1723449052516},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1723449052517},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1723449052517},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1723449052517},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1723449052517},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1723449052516},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1723449052518},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1723449052518},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1723449052518},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1723449052519},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1723449052519},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1723449052549},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1723449052541},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1723449052550},{"_id":"themes/next/source/images/apple-touch-icon.png","hash":"64a9ea04f5bb7fef316fa416a7bf9e5e9489c291","modified":1723611091895},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1723449052550},{"_id":"themes/next/source/images/beian.png","hash":"797721756b99b7841cee366f62ac52a1207cdcb7","modified":1723622021068},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1723449052550},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1723449052551},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1723449052551},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1723449052551},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1723449052552},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1723449052552},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1723449052552},{"_id":"themes/next/source/images/favicon-16x16.png","hash":"c3cc1168e2d338fbefc5f8da977a73a7b9a4975c","modified":1723611046112},{"_id":"themes/next/source/images/favicon-32x32.png","hash":"8be81b95697df7f526646702889ca5483f51ccad","modified":1723611046142},{"_id":"themes/next/source/images/logo.svg","hash":"d0ed8b5372385b71b533c985d0a3d84de851dfaf","modified":1723611161346},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1723449052554},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1723449052554},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1723449052554},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1723449052555},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1723449052555},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1723449052556},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1723449052557},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"4f907daa560d6c81087a6f13d2768918cc1ff6fb","modified":1723643922647},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1723449052487},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1723449052487},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1723449052487},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1723449052488},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1723449052488},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1723449052488},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1723449052489},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1723449052489},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1723449052490},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1723449052490},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1723449052490},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1723449052491},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1723449052491},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1723449052492},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1723449052491},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1723449052492},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1723449052492},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1723449052493},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1723449052494},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1723449052495},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1723449052495},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1723449052496},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1723449052496},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1723449052497},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1723449052498},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1723449052498},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1723449052498},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1723449052500},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"4cc27a45ef0a5b9278a7e404735e844e0291611e","modified":1723643963839},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1723449052502},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1723449052502},{"_id":"themes/next/layout/_third-party/comments/utterances.swig","hash":"30d87a130c5696e56375d47f6896dabacfd28df1","modified":1723686263652},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1723449052502},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1723449052502},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1723449052499},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1723449052500},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1723449052503},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1723449052503},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1723449052504},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1723449052504},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1723449052505},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1723449052505},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1723449052505},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1723449052506},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1723449052506},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1723449052507},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1723449052506},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1723449052507},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1723449052507},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1723449052510},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1723449052510},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1723449052510},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1723449052511},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1723449052511},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1723449052511},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1723449052511},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1723449052512},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1723449052512},{"_id":"themes/next/scripts/filters/comment/utterance.js","hash":"b6f7d2d039a69534a5f238fecdb9341361b03e54","modified":1723686313485},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1723449052513},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1723449052512},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1723449052548},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1723449052548},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1723449052548},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1723449052549},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1723449052549},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1723449052555},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1723449052556},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1723449052560},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1723449052520},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1723449052560},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1723449052520},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1723449052520},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1723449052526},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1723449052530},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1723449052531},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1723449052535},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1723449052535},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1723449052536},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1723449052537},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1723449052538},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1723449052538},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1723449052538},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1723449052541},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1723449052542},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1723449052543},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1723449052543},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1723449052543},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1723449052543},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1723449052542},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1723449052546},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1723449052546},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1723449052546},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1723449052547},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1723449052546},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1723449052544},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1723449052547},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1723449052544},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1723449052544},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1723449052545},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1723449052545},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1723449052545},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1723449052557},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1723449052559},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1723449052521},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1723449052521},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1723449052522},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1723449052522},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1723449052523},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1723449052522},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1723449052523},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1723449052524},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1723449052524},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1723449052524},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1723449052523},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1723449052524},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1723449052525},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1723449052525},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1723449052525},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1723449052525},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1723449052526},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1723449052526},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1723449052527},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1723449052527},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1723449052527},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1723449052528},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1723449052528},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1723449052529},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1723449052529},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1723449052529},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1723449052529},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1723449052530},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1723449052530},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1723449052530},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1723449052530},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1723449052532},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1723449052532},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1723449052533},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1723449052533},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1723449052534},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1723449052533},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1723449052534},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1723449052534},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1723449052535},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1723449052536},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1723449052534},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1723449052536},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1723449052537},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1723449052537},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1723449052539},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1723449052539},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1723449052539},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1723449052539},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1723449052540},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1723449052540},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1723449052540},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1723449052558},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1723449052559},{"_id":"themes/next/source/images/wechat_channel.jpg","hash":"25d7ebd0b18bb44a9013adbe2b6cd82919f4c291","modified":1723623826348},{"_id":"themes/next/source/images/alipay.jpg","hash":"1d531329226cfd0fde8e936f9019eec57169945b","modified":1723623544434},{"_id":"themes/next/source/images/qq-contact.png","hash":"255274d1b43901c2a5a14daaa540346dc62602c4","modified":1723620583638},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"28bab154ea159faf803c3c832cc7da5eb62c7396","modified":1723623544590},{"_id":"public/404/404.html","hash":"9e5cd083ab149d88607fc956414aeb4ebb3c21d1","modified":1723688812539},{"_id":"public/categories/index.html","hash":"5d8151664d4d750fe7da6d77012a68c10fa2eeeb","modified":1723688812539},{"_id":"public/tags/index.html","hash":"098147f03da20206179f8fa12b45d65f5e064e5d","modified":1723688812539},{"_id":"public/about/index.html","hash":"283a188cf389e28fc57a0d88b58ece761a37787d","modified":1723688812539},{"_id":"public/schedule/index.html","hash":"948cbb53696fb1464f80ad002538bbea67699b9e","modified":1723688812539},{"_id":"public/2024/08/14/Miracl的配置ForCentos7/index.html","hash":"7490512b65405901c2932cd7ac93e3d14a77b68c","modified":1723688812539},{"_id":"public/2024/08/14/RSA涉及算法与数论知识/index.html","hash":"89ce57bc95ffc5fc8df0209b3facfb6d1ae05775","modified":1723688812539},{"_id":"public/2024/08/14/Latex宏包pgfplots做矩形函数图像/index.html","hash":"0e587960b32cfbeff1ba934d901490487064039a","modified":1723688812539},{"_id":"public/2024/08/14/cf-edu165D/index.html","hash":"d352a79cb6a82eb89a362c5009ec14e20bd407be","modified":1723688812539},{"_id":"public/2024/08/14/cf-edu165C/index.html","hash":"b0245916897c2bcf9a7c8bcbe43cd120f95c17f9","modified":1723688812539},{"_id":"public/2024/08/14/数学距离问题1/index.html","hash":"99c7efb79b4e9f2ba94d9a0f2124e61ef075327c","modified":1723688812539},{"_id":"public/2024/08/14/状态转移习题4/index.html","hash":"8f7d1dc3be3840d3f44bb59e55a00d38a2b8b2b7","modified":1723688812539},{"_id":"public/2024/08/14/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/index.html","hash":"b7469cb6bc521ca5fbc1b694924a8e0927db3454","modified":1723688812539},{"_id":"public/2024/08/14/树上回文问题/index.html","hash":"43bae0a9ea2c4626353a2a072a3e0305a0d72c00","modified":1723688812539},{"_id":"public/2024/08/14/状态转移习题3/index.html","hash":"493b2c8ab1865056210e645d885bb130b0eea2e3","modified":1723688812539},{"_id":"public/2024/08/14/字符串习题1/index.html","hash":"cd4ce80cf8e78eca0d28d9d63ac75a0ffa2d8569","modified":1723688812539},{"_id":"public/2024/08/14/思维题习题1/index.html","hash":"1bdb2a7ba8e9779ddd36a0e181aa02a3cfb6f608","modified":1723688812539},{"_id":"public/2024/08/14/状态转移习题2/index.html","hash":"5341b6c7b14c74b782d5e7ffe1c105bf2029e824","modified":1723688812539},{"_id":"public/2024/08/14/状态转移习题1/index.html","hash":"3beffb8442c45bc0fc813d462418231e69cff08c","modified":1723688812539},{"_id":"public/2024/05/13/三种操作系统模拟软件使用手册/index.html","hash":"39f227460150f0b1bce3fe6f5f5992567ec10ced","modified":1723688812539},{"_id":"public/2023/08/13/为什么我用Typora——Typora与其他markdown的比较/index.html","hash":"be8e692f16cbcf449c1664bd489c9b273a4a4e92","modified":1723688812539},{"_id":"public/archives/index.html","hash":"1e55503f22a3d87b5781f5a04acaf0419657c32f","modified":1723688812539},{"_id":"public/archives/page/2/index.html","hash":"83417ac037128db9aa5b4812f8e08d24db05c7eb","modified":1723688812539},{"_id":"public/archives/2023/index.html","hash":"8bcbc78009cc3a2541bf056907a8c1ab33754f04","modified":1723688812539},{"_id":"public/archives/2023/08/index.html","hash":"6234f8b27a9164cc11b95279af602239f33fc878","modified":1723688812539},{"_id":"public/archives/2024/index.html","hash":"d22fef626c83c0ed09cfe6cfe29de2c0c944a3e3","modified":1723688812539},{"_id":"public/archives/2024/page/2/index.html","hash":"b34f2d2dd5b905b4689de6e524856488d39c3b13","modified":1723688812539},{"_id":"public/archives/2024/05/index.html","hash":"62b654d550534a1e7d98907e053b9c8252272c9e","modified":1723688812539},{"_id":"public/archives/2024/08/index.html","hash":"55e04eec86ecfa47fb2f45615ffcfbad7d24fcc8","modified":1723688812539},{"_id":"public/archives/2024/08/page/2/index.html","hash":"3ef0c1eacc79acb8c8eb4dba00956736aff16937","modified":1723688812539},{"_id":"public/index.html","hash":"8aeac5fb4c2abcf716d7aa03917ffc304ca5db9c","modified":1723688812539},{"_id":"public/page/2/index.html","hash":"8c7cf2e8425ba6551e98872fe01c7d2ff4011b7c","modified":1723688812539},{"_id":"public/categories/软件/index.html","hash":"7952a1a7818c3ebc7bbff10a578354d4978372fe","modified":1723688812539},{"_id":"public/categories/算法/index.html","hash":"eac6b66863962dec50389b348d20d54653bf61b3","modified":1723688812539},{"_id":"public/categories/信息安全/index.html","hash":"eae45894d41c7fcef6f01bfdc82dc20ed3e56bce","modified":1723688812539},{"_id":"public/categories/软件/工具类软件/index.html","hash":"68fe7ccf1747522dad51f28fb82ca9cb47287aa0","modified":1723688812539},{"_id":"public/categories/软件/手册/index.html","hash":"625af61485cf68c50d0853cd129942a26da4376b","modified":1723688812539},{"_id":"public/categories/软件/经典库/index.html","hash":"1e266b53b34623733b1cb6ed7083ba0f121780bc","modified":1723688812539},{"_id":"public/categories/软件/编辑器/index.html","hash":"17c40dd5c5997e4220ca4506b943ed5cdf9aff76","modified":1723688812539},{"_id":"public/categories/算法/思维题/index.html","hash":"15174375c4535623c8f0ab8d934cc1ea4806fa01","modified":1723688812539},{"_id":"public/categories/算法/图论/index.html","hash":"dd34c5d3ebd89f74299d7c8fbd42f714f4b8e48e","modified":1723688812539},{"_id":"public/categories/信息安全/加密算法/index.html","hash":"3fbd9d3f339195d1224041028541c6d4147a32bf","modified":1723688812539},{"_id":"public/categories/算法/状态转移/index.html","hash":"bfe5ab2db9136fe21b950e17c89a128317280df4","modified":1723688812539},{"_id":"public/categories/学术/index.html","hash":"fb19d78dcfe8320519e0fd4c862b267f586d5d18","modified":1723688812539},{"_id":"public/categories/算法/数学/index.html","hash":"cf4f13928566048f81b9abdd6d0bf0c3210f6bc6","modified":1723688812539},{"_id":"public/categories/软件/经典库/信息安全/index.html","hash":"a60526bd7c9a845d2b1de78f48cb6b5a766172fa","modified":1723688812539},{"_id":"public/categories/软件/编辑器/Markdown/index.html","hash":"ec3bf974c6c9f8b9eb42973b6391eaded3b356a0","modified":1723688812539},{"_id":"public/categories/算法/思维题/贪心/index.html","hash":"37e9999728b17183c58a3f266021cd26768768a7","modified":1723688812539},{"_id":"public/categories/算法/图论/图论中的回文问题/index.html","hash":"75a6abc5530825001f4e4b7847bc8eab3743b2ee","modified":1723688812539},{"_id":"public/categories/信息安全/加密算法/数学/index.html","hash":"9919cedd4c8bcf5baa7dc129329e75bcbcc80b0c","modified":1723688812539},{"_id":"public/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"b353b45ef538d117dbed4ca6fd8ae5e7dc0b3117","modified":1723688812539},{"_id":"public/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"714d1765b58a8df57b489a3eeb143611438a7bff","modified":1723688812539},{"_id":"public/categories/学术/综述/index.html","hash":"3b8ea2e30ce6d40e890d3fa61fcbd122af157dca","modified":1723688812539},{"_id":"public/categories/算法/数学/博弈论/index.html","hash":"6aefae88d0739209c4b1a48caac9e52879ae7762","modified":1723688812539},{"_id":"public/categories/算法/字符串/index.html","hash":"cb36e65d97afc4298302e00084b88aaf242c9fc1","modified":1723688812539},{"_id":"public/categories/算法/字符串/子序列自动机/index.html","hash":"1099b103873422a869f73d14090d93cd2d7e34d7","modified":1723688812539},{"_id":"public/en/404/404.html","hash":"d0cd917f4fd8812f5d6c6278b62cfced2f1f9fbc","modified":1723688812539},{"_id":"public/ja/404/404.html","hash":"8121cdc5efb041b3a3798ccc16a5afcb618458b6","modified":1723688812539},{"_id":"public/ru/404/404.html","hash":"732735cafe472febbb90636ae3579f02fe0467b7","modified":1723688812539},{"_id":"public/en/categories/index.html","hash":"d6b7c6092b4e83c5a6e2fa9f56ec1677c961a792","modified":1723688812539},{"_id":"public/ja/categories/index.html","hash":"24003ca69d3f8a8dd4ec2164525dc999fb6850e7","modified":1723688812539},{"_id":"public/ru/categories/index.html","hash":"167f9cadd1c69040861e6e4b8375b07dfadf4a22","modified":1723688812539},{"_id":"public/en/tags/index.html","hash":"afbe34b84c460f87e6793674d4edbbfb68e672f7","modified":1723688812539},{"_id":"public/ja/tags/index.html","hash":"83a1b3a505ad3117fa7a0496b03fcf13978cd02e","modified":1723688812539},{"_id":"public/ru/tags/index.html","hash":"3f3bbb52678122d6cfc8bef73b91ab4174660f2e","modified":1723688812539},{"_id":"public/en/about/index.html","hash":"c3f9ff78747e007da7c1b45f0cacf751a8427cb9","modified":1723688812539},{"_id":"public/ja/about/index.html","hash":"d9560252a5b68233ef6b9398baeb757c739149d8","modified":1723688812539},{"_id":"public/ru/about/index.html","hash":"b43a83aeb42e4b48435877582f8263bc4329e071","modified":1723688812539},{"_id":"public/en/schedule/index.html","hash":"451a909599824c31971c32410821833941a5660d","modified":1723688812539},{"_id":"public/ja/schedule/index.html","hash":"ff589f8f18a0a3c543c6bb1ab425b123d288d0a0","modified":1723688812539},{"_id":"public/ru/schedule/index.html","hash":"f7a929ab9532bc97589c9d370c94e9a5f665b4e4","modified":1723688812539},{"_id":"public/en/2024/08/14/Latex宏包pgfplots做矩形函数图像/index.html","hash":"7386cd9adef9b26cd947792e7bbe4c16d9a9c4c0","modified":1723688812539},{"_id":"public/ja/2024/08/14/Latex宏包pgfplots做矩形函数图像/index.html","hash":"c1bc9fb69f2cc182fb9b5b2f3d8d82a9e365a8b3","modified":1723688812539},{"_id":"public/ru/2024/08/14/Latex宏包pgfplots做矩形函数图像/index.html","hash":"a14d367aafb7b3cc031925beb4c12eff80cc60da","modified":1723688812539},{"_id":"public/en/2024/08/14/Miracl的配置ForCentos7/index.html","hash":"a4f8dc3a8fb87a28b2df15b595b579989fe2d464","modified":1723688812539},{"_id":"public/ja/2024/08/14/Miracl的配置ForCentos7/index.html","hash":"6fa59afa50e6f63aaaf15149c65723623670a18f","modified":1723688812539},{"_id":"public/ru/2024/08/14/Miracl的配置ForCentos7/index.html","hash":"5a2785c58b3b4e9af332b9b6f8820f1efe25b8a6","modified":1723688812539},{"_id":"public/en/2024/08/14/cf-edu165C/index.html","hash":"63826bee47b19c34c792a82ff62c5a2d945ac682","modified":1723688812539},{"_id":"public/ja/2024/08/14/cf-edu165C/index.html","hash":"ef379311f6f31a1d0010eae610377c05d21bf549","modified":1723688812539},{"_id":"public/ru/2024/08/14/cf-edu165C/index.html","hash":"c91eb9908ef8e7daaa63fdf8a84c461201534418","modified":1723688812539},{"_id":"public/en/2024/08/14/RSA涉及算法与数论知识/index.html","hash":"07b39163a046ccf635fae665bc6bc73d2d82aa24","modified":1723688812539},{"_id":"public/ja/2024/08/14/RSA涉及算法与数论知识/index.html","hash":"b756e2b2341ff39af38859f1243596aa677ef6c4","modified":1723688812539},{"_id":"public/ru/2024/08/14/RSA涉及算法与数论知识/index.html","hash":"f3b0ff7979fbd1164ab30405a3968bb254f0b4da","modified":1723688812539},{"_id":"public/en/2024/08/14/cf-edu165D/index.html","hash":"36cb334b46769b1c8d0cf5da78cbc896ec9e9aa3","modified":1723688812539},{"_id":"public/ja/2024/08/14/cf-edu165D/index.html","hash":"67cf428ab1aa3acf5d30b51463b3b6f65b88468e","modified":1723688812539},{"_id":"public/ru/2024/08/14/cf-edu165D/index.html","hash":"954ff518336a2d397858852e0f1729dc86d8bbe9","modified":1723688812539},{"_id":"public/en/2024/05/13/三种操作系统模拟软件使用手册/index.html","hash":"b2ea9c74b4f8b4a20a8f7c114e8e031f58bf1b38","modified":1723688812539},{"_id":"public/ja/2024/05/13/三种操作系统模拟软件使用手册/index.html","hash":"1162ea8221f67da36e1f691aaa8a962824d70057","modified":1723688812539},{"_id":"public/ru/2024/05/13/三种操作系统模拟软件使用手册/index.html","hash":"f126b8038826776819054bdd50a8d00439261082","modified":1723688812539},{"_id":"public/en/2023/08/13/为什么我用Typora——Typora与其他markdown的比较/index.html","hash":"2a170150cea843cca82d1fa076ce5d27281bb394","modified":1723688812539},{"_id":"public/ja/2023/08/13/为什么我用Typora——Typora与其他markdown的比较/index.html","hash":"9528f30c38cb7d90c7a1fc914411228a009170b6","modified":1723688812539},{"_id":"public/ru/2023/08/13/为什么我用Typora——Typora与其他markdown的比较/index.html","hash":"002bb8aab3f74498c75c7dbcad3e1015775a4947","modified":1723688812539},{"_id":"public/en/2024/08/14/思维题习题1/index.html","hash":"266793a4e1f74a5fee0e270f9bddd020ed8912bd","modified":1723688812539},{"_id":"public/ja/2024/08/14/思维题习题1/index.html","hash":"fa7a92c76b1f624d579642d39b6c3578b0bd150b","modified":1723688812539},{"_id":"public/ru/2024/08/14/思维题习题1/index.html","hash":"7625f6658c11a0b68301c77de97d2c7715565e9e","modified":1723688812539},{"_id":"public/en/2024/08/14/数学距离问题1/index.html","hash":"b7fb333d7ccd17517377374773b5b98256f9b72c","modified":1723688812539},{"_id":"public/ja/2024/08/14/数学距离问题1/index.html","hash":"11ad53c3e0cdd79e8d4ef99aae5741d2886540a5","modified":1723688812539},{"_id":"public/ru/2024/08/14/数学距离问题1/index.html","hash":"5b45632d591c8b48ee2b71bdf1fb30bea1df00f1","modified":1723688812539},{"_id":"public/en/2024/08/14/树上回文问题/index.html","hash":"3e9468bdedbeccb9106877dd23efb9e87b104066","modified":1723688812539},{"_id":"public/ja/2024/08/14/树上回文问题/index.html","hash":"75aa63b3ab3c99f3d6cd3c9122311994bbf73ce9","modified":1723688812539},{"_id":"public/ru/2024/08/14/树上回文问题/index.html","hash":"ac099f9719651d144854d703ababf808bf9ce30b","modified":1723688812539},{"_id":"public/en/2024/08/14/状态转移习题1/index.html","hash":"924873600e6c2b5c51969c77027d33aff79f7691","modified":1723688812539},{"_id":"public/ja/2024/08/14/状态转移习题1/index.html","hash":"c25d683050896453a968b7b0421f1e02b0ba1251","modified":1723688812539},{"_id":"public/ru/2024/08/14/状态转移习题1/index.html","hash":"6d1eafc93763a98a8744ad5cc1805c6af3196a3c","modified":1723688812539},{"_id":"public/en/2024/08/14/状态转移习题2/index.html","hash":"9f798e2461f53a993b1fb1aaabd9f4dad9c266e8","modified":1723688812539},{"_id":"public/ja/2024/08/14/状态转移习题2/index.html","hash":"9016e96cda4eb0a5aa8d1645a129dfcd5acf2fd0","modified":1723688812539},{"_id":"public/ru/2024/08/14/状态转移习题2/index.html","hash":"12d028549b80540b4f22ebbcab72efdeed4a4861","modified":1723688812539},{"_id":"public/en/2024/08/14/状态转移习题3/index.html","hash":"4e8b6f588cdeb3d08446a7b2714292d678ba2a0a","modified":1723688812539},{"_id":"public/ja/2024/08/14/状态转移习题3/index.html","hash":"d172b451fee317f16eca978e3725a8fcee613e18","modified":1723688812539},{"_id":"public/ru/2024/08/14/状态转移习题3/index.html","hash":"59ebe547b0b17b317c1f38c3b9c3f685339af9e8","modified":1723688812539},{"_id":"public/en/2024/08/14/状态转移习题4/index.html","hash":"b0cdb0257ba7b7106abbf31b341b2fc1ddde30fc","modified":1723688812539},{"_id":"public/ja/2024/08/14/状态转移习题4/index.html","hash":"5dc2514ac77bcc3301bef2b05af3a0b3c542aa6f","modified":1723688812539},{"_id":"public/ru/2024/08/14/状态转移习题4/index.html","hash":"d12763aafad8467313e950fc76063558cb6077b9","modified":1723688812539},{"_id":"public/en/2024/08/14/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/index.html","hash":"9ced918355dfe5161ed6c8f7ca9b956b199aa50a","modified":1723688812539},{"_id":"public/ja/2024/08/14/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/index.html","hash":"11df0c843eaacd379b0d2e6ca653169d5d095789","modified":1723688812539},{"_id":"public/ru/2024/08/14/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/index.html","hash":"8ca764025bd7460e2559ac97c3bed84b023f9841","modified":1723688812539},{"_id":"public/en/2024/08/14/字符串习题1/index.html","hash":"70c6a17c96e6b411fed2ffc8ea6f45f0e2bb4d31","modified":1723688812539},{"_id":"public/ja/2024/08/14/字符串习题1/index.html","hash":"b6d59131af6d4b58f2570fafe5afe2cf890feff9","modified":1723688812539},{"_id":"public/ru/2024/08/14/字符串习题1/index.html","hash":"568e2ce39ddac5dc8398bf84741ca74641055cdb","modified":1723688812539},{"_id":"public/en/index.html","hash":"0c0633c41ea57c44cc7d8c85db39682fc2ffeeff","modified":1723688812539},{"_id":"public/ja/index.html","hash":"23bcec23645873b78875675df4a73a716478c673","modified":1723688812539},{"_id":"public/ru/index.html","hash":"22bd5f28994a82b4cd8ac270ec846c9f6614e736","modified":1723688812539},{"_id":"public/en/page/2/index.html","hash":"393860e43f3550960b7d5ae4daf46492555b9b5e","modified":1723688812539},{"_id":"public/ja/page/2/index.html","hash":"241af59b4a8c6e9528691ab1ab4d67454bbc0e8d","modified":1723688812539},{"_id":"public/ru/page/2/index.html","hash":"b5cff9d577d51967345da84dcefc95bdb73f9006","modified":1723688812539},{"_id":"public/en/archives/index.html","hash":"f8baaf57599c3e9f8ed8ae215d5a07792db45826","modified":1723688812539},{"_id":"public/ja/archives/index.html","hash":"7194318b20253f1b6bb00b96f2bfb34a052b3a01","modified":1723688812539},{"_id":"public/ru/archives/index.html","hash":"b7c3375e99ede2ca54307cd670a9b8733ad18a59","modified":1723688812539},{"_id":"public/en/archives/page/2/index.html","hash":"fe4a5e19d3ec723ee8dd50246aa566ac89fb9f0e","modified":1723688812539},{"_id":"public/ja/archives/page/2/index.html","hash":"94530b882a27e4709bbf2ea136eaf3647058afe1","modified":1723688812539},{"_id":"public/ru/archives/page/2/index.html","hash":"ce8a961d7a202eb95f6299ba2bd6fa77076070dd","modified":1723688812539},{"_id":"public/en/archives/2023/index.html","hash":"08359c438a5dc9e05006347cbae8368933e0e1fa","modified":1723688812539},{"_id":"public/ja/archives/2023/index.html","hash":"d0dbaa292d88bbb85ffe0ccbe6062420b6c965fd","modified":1723688812539},{"_id":"public/ru/archives/2023/index.html","hash":"0277e1b8777ef4295b47540ce6504133564c2b25","modified":1723688812539},{"_id":"public/en/archives/2023/08/index.html","hash":"b4d0c3e11753cb123bcbcb060e086913f6dfefc6","modified":1723688812539},{"_id":"public/ja/archives/2023/08/index.html","hash":"7ccaaa39ab41bd36f449aa1cda223980e743fc31","modified":1723688812539},{"_id":"public/ru/archives/2023/08/index.html","hash":"633620b6d4ff8f6e256475ad473bf94f0c5deaa1","modified":1723688812539},{"_id":"public/en/archives/2024/index.html","hash":"44289a6432ff85cabef44a4d5fedc1594900f4e0","modified":1723688812539},{"_id":"public/ja/archives/2024/index.html","hash":"88be12dc6bfc7672f8f58288bcd7e83e9cc61a4a","modified":1723688812539},{"_id":"public/ru/archives/2024/index.html","hash":"8c8ff4ea2046368104249d3a4ef7939736945e15","modified":1723688812539},{"_id":"public/en/archives/2024/page/2/index.html","hash":"b892e78dd9e9629d4c44a1c36fd300d159c49852","modified":1723688812539},{"_id":"public/ja/archives/2024/page/2/index.html","hash":"f1092c7fb676ff7d8da5c8c69fa8968f8731da8e","modified":1723688812539},{"_id":"public/ru/archives/2024/page/2/index.html","hash":"d74df350ed01de642fbf2468f644986dc5b17d84","modified":1723688812539},{"_id":"public/en/archives/2024/05/index.html","hash":"7a1fed247a4b50f41982af68d7bf36845d5bbd07","modified":1723688812539},{"_id":"public/ja/archives/2024/05/index.html","hash":"8881e572c41eb0dc5c7ac70a7c320dd7d83baef5","modified":1723688812539},{"_id":"public/ru/archives/2024/05/index.html","hash":"35a7cac3baa4e32be3fc5269a5097de07c1b2c42","modified":1723688812539},{"_id":"public/en/archives/2024/08/index.html","hash":"1203ccfb826aabf3fc109c41fb2b1e2067c193ab","modified":1723688812539},{"_id":"public/ja/archives/2024/08/index.html","hash":"f6ea32fba5761a2afc37837b51549120b6b34a55","modified":1723688812539},{"_id":"public/ru/archives/2024/08/index.html","hash":"61ba592c5994d31db2a73f34b69c9ca470f568c2","modified":1723688812539},{"_id":"public/en/archives/2024/08/page/2/index.html","hash":"8c01af56d462ca134a73e6af597bfeb6642f69d4","modified":1723688812539},{"_id":"public/ja/archives/2024/08/page/2/index.html","hash":"abdb8b471c4b13502063b4401a79122b6fcdc806","modified":1723688812539},{"_id":"public/ru/archives/2024/08/page/2/index.html","hash":"e5ca45c46b08081e22b1c1b87ca764bc7b2d4071","modified":1723688812539},{"_id":"public/en/categories/软件/index.html","hash":"019455bc67bc2b4d4118ad7f1061f0eee177a946","modified":1723688812539},{"_id":"public/ja/categories/软件/index.html","hash":"078a19d3a241057341fef7ccc9fd092390846571","modified":1723688812539},{"_id":"public/ru/categories/软件/index.html","hash":"09e1587fad32713245cc5c0fc8f6ec6a539463f7","modified":1723688812539},{"_id":"public/en/categories/算法/index.html","hash":"3179954960c03cf417912f967ef30c514307eba7","modified":1723688812539},{"_id":"public/ja/categories/算法/index.html","hash":"65a384ebdef9588243e471d44d833319f2ce76be","modified":1723688812539},{"_id":"public/ru/categories/算法/index.html","hash":"ee00f8f3df4c984500252cdec63a45a478701d1d","modified":1723688812539},{"_id":"public/en/categories/信息安全/index.html","hash":"e91ba398466edd7377394fc2f4977e0b1e4d6c4e","modified":1723688812539},{"_id":"public/ja/categories/信息安全/index.html","hash":"55357b136df909f29029b37a2033867e56b15f72","modified":1723688812539},{"_id":"public/ru/categories/信息安全/index.html","hash":"6ae3088619e37f7a139c33598cd1172af546fc42","modified":1723688812539},{"_id":"public/en/categories/软件/工具类软件/index.html","hash":"43e6ef13ae43fc1ec7f06122ed6c6b6cbdb2f2fb","modified":1723688812539},{"_id":"public/ru/categories/软件/工具类软件/index.html","hash":"63e01c777fd154a3e6602e2ec6502336803a3d29","modified":1723688812539},{"_id":"public/ja/categories/软件/工具类软件/index.html","hash":"afe791d0cf8115114baadcbceae821f84e7792b1","modified":1723688812539},{"_id":"public/en/categories/软件/手册/index.html","hash":"fbe2f7a5378fdf08191e9dba32f1fc7fb04b8fab","modified":1723688812539},{"_id":"public/ja/categories/软件/手册/index.html","hash":"c434fbfc792dcca5fd88e0dec83be93192aeda47","modified":1723688812539},{"_id":"public/ru/categories/软件/手册/index.html","hash":"8a3d10440ac7ee6afb9f16b7177796dfbe81ffb1","modified":1723688812539},{"_id":"public/en/categories/软件/经典库/index.html","hash":"7f9a0d10164d1c73210c2492c7d87ec4a23de030","modified":1723688812539},{"_id":"public/ja/categories/软件/经典库/index.html","hash":"170436ea1da22210094c058ca202898faa69cb5b","modified":1723688812539},{"_id":"public/ru/categories/软件/经典库/index.html","hash":"fa85eb4050f6da48cab475fe96d80ab77d0185ec","modified":1723688812539},{"_id":"public/en/categories/软件/编辑器/index.html","hash":"c7d19d74adda1644960c3b53246b7ae04ff15078","modified":1723688812539},{"_id":"public/ja/categories/软件/编辑器/index.html","hash":"8c51ef49840f4113fce36700c36632997d800a8c","modified":1723688812539},{"_id":"public/ru/categories/软件/编辑器/index.html","hash":"779beb3b9e65033f30546923b18f969169245b21","modified":1723688812539},{"_id":"public/en/categories/算法/思维题/index.html","hash":"833e676b156f534479c766498e2d560578cae5ab","modified":1723688812539},{"_id":"public/ja/categories/算法/思维题/index.html","hash":"d7f8a1411c0b2e587f1733315c46125015aec417","modified":1723688812539},{"_id":"public/ru/categories/算法/思维题/index.html","hash":"fa01ebcaa76bdea7a271a7b038ef5ebe9688f542","modified":1723688812539},{"_id":"public/en/categories/算法/图论/index.html","hash":"292111fd2fd1f4dacdf3187c7aff7353f353a290","modified":1723688812539},{"_id":"public/ja/categories/算法/图论/index.html","hash":"a4139ccbbf3b3ad27752cbb4ccba738e6124fa4f","modified":1723688812539},{"_id":"public/ru/categories/算法/图论/index.html","hash":"339291a7b3e957e304b16a7ddad19e653889b7ac","modified":1723688812539},{"_id":"public/en/categories/信息安全/加密算法/index.html","hash":"966fbe4f474822c03a9ac09c98fe8fe28ed4139b","modified":1723688812539},{"_id":"public/ja/categories/信息安全/加密算法/index.html","hash":"f3fbcca7664dced3b813793aec4bbaebfc2cf0f7","modified":1723688812539},{"_id":"public/ru/categories/信息安全/加密算法/index.html","hash":"7a6eed4ab5b6a1f6d93c3c7dc90273f228ab7ce5","modified":1723688812539},{"_id":"public/en/categories/算法/状态转移/index.html","hash":"cf9780ae6daa55ba421189a8155a88d496212efa","modified":1723688812539},{"_id":"public/ja/categories/算法/状态转移/index.html","hash":"4b07b33e43a0d9fff43922617bc278f720af11b5","modified":1723688812539},{"_id":"public/ru/categories/算法/状态转移/index.html","hash":"583637b0933d1ace4edb0461c307dabd03e099d2","modified":1723688812539},{"_id":"public/en/categories/学术/index.html","hash":"01be233213959a835362808013194db33f670216","modified":1723688812539},{"_id":"public/ja/categories/学术/index.html","hash":"781a674f4e5692f99070adf042d1a308636aa756","modified":1723688812539},{"_id":"public/ru/categories/学术/index.html","hash":"9b2a91105cd029a91ca85e654ef42d8db16eea4e","modified":1723688812539},{"_id":"public/en/categories/算法/数学/index.html","hash":"f8e9fc1479a7d2b63bad3e5c596b5b775291634c","modified":1723688812539},{"_id":"public/ja/categories/算法/数学/index.html","hash":"b0c3819c9c67d7851745e208cdab29328c6f00d1","modified":1723688812539},{"_id":"public/ru/categories/算法/数学/index.html","hash":"87130d186a9191633e8ec941ffcc7e3d38f5d157","modified":1723688812539},{"_id":"public/en/categories/软件/经典库/信息安全/index.html","hash":"ec4f5d6daee79d1db9f68c8438f1d1033521708d","modified":1723688812539},{"_id":"public/ja/categories/软件/经典库/信息安全/index.html","hash":"884e8c6b555878dddbe42f8d33094d56de4459e8","modified":1723688812539},{"_id":"public/ru/categories/软件/经典库/信息安全/index.html","hash":"7ff9754f64cef705d5c6ef65a04a0a01fe9351ed","modified":1723688812539},{"_id":"public/en/categories/软件/编辑器/Markdown/index.html","hash":"4850d831d77d87f52eb06a5f39ea800b71015187","modified":1723688812539},{"_id":"public/ja/categories/软件/编辑器/Markdown/index.html","hash":"ab732b369f72044a5425bba592d49a4747fa6d0f","modified":1723688812539},{"_id":"public/ru/categories/软件/编辑器/Markdown/index.html","hash":"31a3cdadf418624dc969cf40271dbd310f0c38ee","modified":1723688812539},{"_id":"public/en/categories/算法/思维题/贪心/index.html","hash":"3c8c8f6c53817f8e7414159f5e83be928b27b976","modified":1723688812539},{"_id":"public/ja/categories/算法/思维题/贪心/index.html","hash":"095e4177b7b0613de8380b13d268fcc7972becc6","modified":1723688812539},{"_id":"public/ru/categories/算法/思维题/贪心/index.html","hash":"eceb270b11a47cfc0d69877401cfe333be1268d0","modified":1723688812539},{"_id":"public/en/categories/算法/图论/图论中的回文问题/index.html","hash":"7c270c83a271289668c3ad3d1c300769e29aebc2","modified":1723688812539},{"_id":"public/ja/categories/算法/图论/图论中的回文问题/index.html","hash":"2131f29d6d6a42254d969d3e076d9e72fa7a2627","modified":1723688812539},{"_id":"public/ru/categories/算法/图论/图论中的回文问题/index.html","hash":"1deae153f47b22d0d4fa1dcc56bdc79e45cdedbe","modified":1723688812539},{"_id":"public/en/categories/信息安全/加密算法/数学/index.html","hash":"c2f3d82c61cf75bd12de6afeb213d0d1fce1853b","modified":1723688812539},{"_id":"public/ja/categories/信息安全/加密算法/数学/index.html","hash":"f3754496b8e9cd3ce8103bda99feb2bfd082e2bc","modified":1723688812539},{"_id":"public/ru/categories/信息安全/加密算法/数学/index.html","hash":"fe8e68944fe00b1d7bf262b71d927d03c30579c5","modified":1723688812539},{"_id":"public/en/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"1fd948ff17a869c31d103fe4cc902aacf976a23b","modified":1723688812539},{"_id":"public/ja/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"3b2094b44432c70f2e488a8d69bfc379707039b5","modified":1723688812539},{"_id":"public/ru/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"3ee027eb1646d5f744c2372c5513cd3cb334c466","modified":1723688812539},{"_id":"public/en/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"222a9d69c6483a3759a2361bf2b68132ae0d3310","modified":1723688812539},{"_id":"public/ja/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"768b744e2b8558ec5cb2c60bfbac2dcd015cc5c2","modified":1723688812539},{"_id":"public/ru/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"a184d2690dfd3ab7f8f2a462ae6e6a27a65d0fb0","modified":1723688812539},{"_id":"public/en/categories/学术/综述/index.html","hash":"e4b9231968d8325b3e33c9dd92ff585b5797d276","modified":1723688812539},{"_id":"public/ja/categories/学术/综述/index.html","hash":"437b160ed5e59205ae03f604280bfbe0014b94cb","modified":1723688812539},{"_id":"public/ru/categories/学术/综述/index.html","hash":"62926a9756fb48490f293c2e74d162a5d5b1bf9e","modified":1723688812539},{"_id":"public/en/categories/算法/数学/博弈论/index.html","hash":"cb5eade32a61ff87f3da89c931661e317b958fc4","modified":1723688812539},{"_id":"public/ja/categories/算法/数学/博弈论/index.html","hash":"d887ff894f9650117475679dce0952c5aa478c6b","modified":1723688812539},{"_id":"public/ru/categories/算法/数学/博弈论/index.html","hash":"396790d0fdce4b701d7703d7377d5a8b1519e1a0","modified":1723688812539},{"_id":"public/en/categories/算法/字符串/index.html","hash":"240d06ee3f667f7df81479b97a7322c8659d7797","modified":1723688812539},{"_id":"public/ja/categories/算法/字符串/index.html","hash":"b77b95b00ff115ab58e83992ad5a12b5fe6195cc","modified":1723688812539},{"_id":"public/ru/categories/算法/字符串/index.html","hash":"c0b56402d57fd18837f302e04c929d5e2465b1ed","modified":1723688812539},{"_id":"public/en/categories/算法/字符串/子序列自动机/index.html","hash":"474514d41ac1ffc93cf2b3a0a4ecacd6645ac0c5","modified":1723688812539},{"_id":"public/ja/categories/算法/字符串/子序列自动机/index.html","hash":"a4b8322f65c738038598515a30c4b0569879b37e","modified":1723688812539},{"_id":"public/ru/categories/算法/字符串/子序列自动机/index.html","hash":"10939f495660efdedd9bdb3e9e96d7fd961ab25d","modified":1723688812539},{"_id":"public/tags/Latex/index.html","hash":"b26b2675613177494d42ba35ca3287cb7557d201","modified":1723688812539},{"_id":"public/tags/图像处理/index.html","hash":"751d5ccbcb2f06b2becca598cc94bdbf35d2ab4f","modified":1723688812539},{"_id":"public/tags/信息安全/index.html","hash":"3d1afede10c920dcdecfe8aaf28b78baaf124e15","modified":1723688812539},{"_id":"public/tags/软件/index.html","hash":"c4ca43d4245b2c26544d4c562fe104e903b1c2ea","modified":1723688812539},{"_id":"public/tags/Miracl/index.html","hash":"9b893c710861ea297cb7a0a9032216067595573d","modified":1723688812539},{"_id":"public/tags/算法/index.html","hash":"2bc37cc352cd2b2dc8db4f68d08ac77e942d5e3a","modified":1723688812539},{"_id":"public/tags/思维题/index.html","hash":"527dbeec48f56e5e7947e47f5c2f896f613a4b60","modified":1723688812539},{"_id":"public/tags/贪心，状态转移/index.html","hash":"ae69814412cec28e8f9c48e878b29c28251371c0","modified":1723688812539},{"_id":"public/tags/数学/index.html","hash":"cee7aca66e3d8c85612b1cace2cfe0ba8824b8a5","modified":1723688812539},{"_id":"public/tags/博弈论/index.html","hash":"67d7c76c66bdad97211146f2a372f3546c490928","modified":1723688812539},{"_id":"public/tags/不等式/index.html","hash":"083f65a30e5b9f202a493ceb653e15f1ecf1dabd","modified":1723688812539},{"_id":"public/tags/开发/index.html","hash":"7d0dfaef2f33b5e14f3b7b3a9805913f1c7d59d2","modified":1723688812539},{"_id":"public/tags/文档/index.html","hash":"e3ee4e60ac9f49da8457a295ea77af43a2702521","modified":1723688812539},{"_id":"public/tags/学校/index.html","hash":"755ccdcbb8c94e838885f7c6481fc04d273f5722","modified":1723688812539},{"_id":"public/tags/Typora/index.html","hash":"eea8eef72d72b0bf8f2573376f0ae6ecac76fc63","modified":1723688812539},{"_id":"public/tags/Markdown/index.html","hash":"32e44320996f45557eea1428d3206f262ae6b19e","modified":1723688812539},{"_id":"public/tags/随笔/index.html","hash":"44d1d24b747d94b0af4820f5bc1641dd8ad70a6f","modified":1723688812539},{"_id":"public/tags/坐标系转换/index.html","hash":"6808b1efb65e2fefd64d8dabaed6f4fc163ed0c7","modified":1723688812539},{"_id":"public/tags/几何问题/index.html","hash":"268039df7d7fbdedf51f6bd8cf31d7803bb6d51a","modified":1723688812539},{"_id":"public/tags/树问题，哈希算法/index.html","hash":"a3871376705452e266ef3ae02cb04dba74ea12ec","modified":1723688812539},{"_id":"public/tags/状态转移/index.html","hash":"5538c93a82713e16d71e3211d695c4da385b1414","modified":1723688812539},{"_id":"public/tags/异或问题/index.html","hash":"c46bb09d3b3a484d77ead523d716512de52209f5","modified":1723688812539},{"_id":"public/tags/离散化/index.html","hash":"b243cb4bd2e1081559449d644a436637091d3bdb","modified":1723688812539},{"_id":"public/tags/加密算法/index.html","hash":"2f61083ed875087b362fb9aacbd261dc0501b8cf","modified":1723688812539},{"_id":"public/tags/ECC/index.html","hash":"241713e2f786a6a430a46dc80e99c9ef7f8622d1","modified":1723688812539},{"_id":"public/tags/子序列自动机/index.html","hash":"95ffa1c29e7ce2b7894d49756ec2d7c5a12308dc","modified":1723688812539},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1723688812539},{"_id":"public/images/apple-touch-icon.png","hash":"64a9ea04f5bb7fef316fa416a7bf9e5e9489c291","modified":1723688812539},{"_id":"public/images/beian.png","hash":"797721756b99b7841cee366f62ac52a1207cdcb7","modified":1723688812539},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1723688812539},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1723688812539},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1723688812539},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1723688812539},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1723688812539},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1723688812539},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1723688812539},{"_id":"public/images/favicon-32x32.png","hash":"8be81b95697df7f526646702889ca5483f51ccad","modified":1723688812539},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1723688812539},{"_id":"public/images/favicon-16x16.png","hash":"c3cc1168e2d338fbefc5f8da977a73a7b9a4975c","modified":1723688812539},{"_id":"public/images/logo.svg","hash":"d0ed8b5372385b71b533c985d0a3d84de851dfaf","modified":1723688812539},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1723688812539},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1723688812539},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1723688812539},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1723688812539},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1723688812539},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1723688812539},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1723688812539},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1723688812539},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1723688812539},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1723688812539},{"_id":"public/css/main.css","hash":"d3043c8d278daa3c0f4d26232dd782a8a7929530","modified":1723688812539},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1723688812539},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1723688812539},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1723688812539},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1723688812539},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1723688812539},{"_id":"public/images/wechat_channel.jpg","hash":"25d7ebd0b18bb44a9013adbe2b6cd82919f4c291","modified":1723688812539},{"_id":"public/images/alipay.jpg","hash":"1d531329226cfd0fde8e936f9019eec57169945b","modified":1723688812539},{"_id":"public/images/wechatpay.jpg","hash":"28bab154ea159faf803c3c832cc7da5eb62c7396","modified":1723688812539},{"_id":"public/images/qq-contact.png","hash":"255274d1b43901c2a5a14daaa540346dc62602c4","modified":1723688812539}],"Category":[{"name":"软件","_id":"clzuntc6f0004cgwvguri9zbq"},{"name":"算法","_id":"clzuntc6l000gcgwv55w0h316"},{"name":"信息安全","_id":"clzuntc6n000mcgwv3m9s3mi7"},{"name":"工具类软件","parent":"clzuntc6f0004cgwvguri9zbq","_id":"clzuntc6o000qcgwv4lldcl0a"},{"name":"手册","parent":"clzuntc6f0004cgwvguri9zbq","_id":"clzuntc6r000zcgwvdm3mgpc8"},{"name":"经典库","parent":"clzuntc6f0004cgwvguri9zbq","_id":"clzuntc6r0015cgwv7q81gd2r"},{"name":"编辑器","parent":"clzuntc6f0004cgwvguri9zbq","_id":"clzuntc6s0018cgwv5g5ihuf4"},{"name":"思维题","parent":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc6t001ccgwv7rj2czgc"},{"name":"图论","parent":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc6u001ocgwvgbl961ma"},{"name":"加密算法","parent":"clzuntc6n000mcgwv3m9s3mi7","_id":"clzuntc6u001rcgwvay1iawy4"},{"name":"状态转移","parent":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc6v001vcgwv0gndfhny"},{"name":"学术","_id":"clzuntc6x002ccgwve7ey6f6e"},{"name":"数学","parent":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc6x002ecgwv9jetehwk"},{"name":"信息安全","parent":"clzuntc6r0015cgwv7q81gd2r","_id":"clzuntc6y002hcgwv9gncadl4"},{"name":"Markdown","parent":"clzuntc6s0018cgwv5g5ihuf4","_id":"clzuntc6y002lcgwv69h2h6mm"},{"name":"贪心","parent":"clzuntc6t001ccgwv7rj2czgc","_id":"clzuntc6z002pcgwvct9khw4h"},{"name":"图论中的回文问题","parent":"clzuntc6u001ocgwvgbl961ma","_id":"clzuntc6z002ucgwv5hez2p2q"},{"name":"数学","parent":"clzuntc6u001rcgwvay1iawy4","_id":"clzuntc70002ycgwv5gtkemg3"},{"name":"状态转移中的异或问题","parent":"clzuntc6v001vcgwv0gndfhny","_id":"clzuntc700032cgwv0br52y8p"},{"name":"复杂状态转移与优化","parent":"clzuntc6v001vcgwv0gndfhny","_id":"clzuntc710039cgwv6ydo12zy"},{"name":"综述","parent":"clzuntc6x002ccgwve7ey6f6e","_id":"clzuntc71003fcgwv71tw50d1"},{"name":"博弈论","parent":"clzuntc6x002ecgwv9jetehwk","_id":"clzuntc72003mcgwv253bfe2e"},{"name":"字符串","parent":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc79004pcgwv7ulea9fa"},{"name":"子序列自动机","parent":"clzuntc79004pcgwv7ulea9fa","_id":"clzuntc7a004rcgwvb6xw30d4"}],"Data":[{"_id":"languages","data":{"zh-CN":{"post":{"copyright":{"author":"本文博主"},"comments":{"disqus":"评论"}}},"en":{"menu":{"schedule":"Calendar"}}}}],"Page":[{"title":"404","date":"2014-12-22T04:39:04.000Z","comments":0,"_content":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","source":"404/404.md","raw":"---\ntitle: '404'\ndate: 2014-12-22 12:39:04\ncomments: false\n---\n<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","updated":"2024-08-14T05:39:50.887Z","path":"404/404.html","layout":"page","_id":"clzuntc680000cgwv1vk65lr7","content":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\r\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\r\n</script>\r\n","length":17,"excerpt":"","more":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\r\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\r\n</script>\r\n"},{"title":"categories","date":"2024-08-14T07:00:25.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2024-08-14 15:00:25\ntype: categories\n---\n","updated":"2024-08-14T07:00:37.565Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clzuntc6d0002cgwve6w8ebtd","content":"\r\n","length":0,"excerpt":"","more":"\r\n"},{"title":"标签","date":"2024-08-14T05:02:25.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2024-08-14 13:02:25\ntype: tags\n---","updated":"2024-08-14T05:14:48.261Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clzuntc6g0006cgwv3wh19z3h","content":"\r\n","length":0,"excerpt":"","more":"\r\n"},{"title":"关于","date":"2024-08-14T07:06:43.000Z","_content":"\n# 注意事项\n***网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主***\nps：我也将尽力保留数据\n\n这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链\n\n## **Little Resume**\n\n博主: Deepcity\n\n职业: 研究生\n\n电子邮箱: f1159472899@163.com\n\n## 友链\n\n{% linkgrid %}\nBraumAce | https://blog.braumace.cn/ByteLighting/ | 一个后端开发者 | https://blog.braumace.cn/ByteLighting/BraumAce.jpg\n{% endlinkgrid %}\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2024-08-14 15:06:43\n---\n\n# 注意事项\n***网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主***\nps：我也将尽力保留数据\n\n这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链\n\n## **Little Resume**\n\n博主: Deepcity\n\n职业: 研究生\n\n电子邮箱: f1159472899@163.com\n\n## 友链\n\n{% linkgrid %}\nBraumAce | https://blog.braumace.cn/ByteLighting/ | 一个后端开发者 | https://blog.braumace.cn/ByteLighting/BraumAce.jpg\n{% endlinkgrid %}\n","updated":"2024-08-14T13:51:09.539Z","path":"about/index.html","comments":1,"layout":"page","_id":"clzuntc6h0008cgwvfg72c43f","content":"<h1 id=\"注意事项\">注意事项</h1>\r\n<p><strong><em>网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主</em></strong>\r\nps：我也将尽力保留数据</p>\r\n<p>这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链</p>\r\n<h2 id=\"little-resume\"><strong>Little Resume</strong></h2>\r\n<p>博主: Deepcity</p>\r\n<p>职业: 研究生</p>\r\n<p>电子邮箱: f1159472899@163.com</p>\r\n<h2 id=\"友链\">友链</h2>\r\n<div class=\"link-grid\"><div>\n\t\t\t<img src=\"https://blog.braumace.cn/ByteLighting/BraumAce.jpg\" onerror=\"this.src='/images/avatar.gif';\">\n\t\t\t<p>BraumAce</p><p>一个后端开发者</p>\n\t\t\t<a href=\"https://blog.braumace.cn/ByteLighting/\"></a>\n\t\t</div></div>\r\n","length":143,"excerpt":"","more":"<h1 id=\"注意事项\">注意事项</h1>\r\n<p><strong><em>网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主</em></strong>\r\nps：我也将尽力保留数据</p>\r\n<p>这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链</p>\r\n<h2 id=\"little-resume\"><strong>Little Resume</strong></h2>\r\n<p>博主: Deepcity</p>\r\n<p>职业: 研究生</p>\r\n<p>电子邮箱: f1159472899@163.com</p>\r\n<h2 id=\"友链\">友链</h2>\r\n<div class=\"link-grid\"><div>\n\t\t\t<img src=\"https://blog.braumace.cn/ByteLighting/BraumAce.jpg\" onerror=\"this.src='/images/avatar.gif';\">\n\t\t\t<p>BraumAce</p><p>一个后端开发者</p>\n\t\t\t<a href=\"https://blog.braumace.cn/ByteLighting/\"></a>\n\t\t</div></div>\r\n"},{"title":"服务器日历","date":"2024-08-14T05:13:45.000Z","type":"schedule","_content":"","source":"schedule/index.md","raw":"---\ntitle: 服务器日历\ndate: 2024-08-14 13:13:45\ntype: schedule\n---\n","updated":"2024-08-14T12:03:54.657Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"clzuntc6i000acgwvam0rf59j","content":"\r\n","length":0,"excerpt":"","more":"\r\n"}],"Post":[{"title":"Latex宏包pgfplots做矩形函数图像","date":"2024-08-14T11:47:58.000Z","_content":"持续更新遇到的问题，完结或不再使用该包将删除这句话\n\n## pgfplots\n\nPgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。\n\n<!--more-->\n\n### 实例一、通过函数方程绘制函数图像\n\n```latex\n%Ex1:f(x)=exp(x)\n\\begin{tikzpicture}\n\\begin{axis}\n\\addplot[color=red]{exp(x)};\n\\end{axis}\n\\end{tikzpicture}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png)\n\n其中绘制图像的语法如下：\n\n```latex\n\\addplot[option] {expression of 2D function};\n```\n\n在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 **;** 结尾。\n\n### 实例二、坐标系的绘制以及3d函数图像\n\n```latex\n\\documentclass{ctexart}\n\\pagestyle{empty}\n\\usepackage{pgfplots}\n\\begin{document}\n%Ex2: put the 2D plot and the 3D plot together\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot[color=red]{exp(x)};\n\t\\end{axis}\n\\end{tikzpicture}\n%Here ends the furst 2D plot\n\n\\hskip 10pt\n\n%Here begins the 3d plot\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot3[\n\t\tsurf,\n\t\t]\n\t\t{exp(-x^2-y^2)*x};\n\t\\end{axis}\n\\end{tikzpicture}\n\\end{document}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png)\n\n```latex\n\\addplot3[\n    surf,\n]\n{exp(-x^2-y^2)*x};\n```\n\n注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。\n\n可以看到对多个图像只需要设定多个tikzpicture作用域即可\n\n#### 坐标系图像中的常用命令、参数与特性\n\n- xlabel、ylabel：设定x,y坐标轴上的标志。\n- 多个addplot可在同一个图中多次作图\n- $$\\tt{domian = a:b}$$设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；\n- $$\\tt{axis\\,\\, lines = left}$$这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；\n- \\addlegendentry{$function（x)$​} 添加函数标签 \n- \\legend 按顺序批量谭家函数标签\n- title在axis中为图像添加标题\n\n### 实例三、数据图\n\n```latex\n%Ex6:plot from data\n\\begin{tikzpicture}\n\t\\begin{axis}[\n\t\ttitle={Temperature dependence of CuSO$_4\\cdot$5H$_2$O solubility},\n\t\txlabel={Temperature [\\textcelsius]},\n\t\tylabel={Solubility [g per 100 g water]},\n\t\txmin=0, xmax=100,\n\t\tymin=0, ymax=120,\n\t\txtick={0,20,40,60,80,100},\n\t\tytick={0,20,40,60,80,100,120},\n\t\tlegend pos=north west,\n\t\tymajorgrids=true,\n\t\tgrid style=dashed,\n\t\t]\n\t\t\n\t\t\\addplot[\n\t\tcolor=blue,\n\t\tmark=square,\n\t\t]\n\t\tcoordinates {\n\t\t\t(0,23.1)\n\t\t\t(10,27.5)\n\t\t\t(20,32)\n\t\t\t(30,37.8)\n\t\t\t(40,44.6)\n\t\t\t(60,61.8)\n\t\t\t(80,83.8)\n\t\t\t(100,114)\n\t\t};\n\t\t\\legend{CuSO$_4\\cdot$5H$_2$O}\n\t\t\n\t\\end{axis}\n\\end{tikzpicture}\n```\n\n\n\n#### 数据图像中的常用命令、参数与特性![test-1-crop-1](https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png)\n\n- mark：设定图像点的形状；如square、triangle、x等\n- $$\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}$$​启用/禁用 𝑦,𝑥 轴上**刻度线位置上**的网格线；\n- $$\\tt{xmin=a, xmax=b, ymin=c, ymax=d}$$​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；\n- $$\\tt{coordinates \\{\\}}$$​设定坐标点画折线图\n- \\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图\n\n### 其他图像\n\npgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。\n\n### 导言区的一些设定\n\n```latex\n\\pgfplotsset{width=10cm}\n```\n\n这里指定了每一张图的宽度为10cm\n\n```tex\n\\usepgfplotslibrary{external}\n\\tikzexternalize \n```\n\n由于$$LATEX$$ 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。","source":"_posts/Latex宏包pgfplots做矩形函数图像.md","raw":"---\ntitle: Latex宏包pgfplots做矩形函数图像\ndate: 2024-08-14 19:47:58\ntags: [Latex, 图像处理]\ncategories: \n\t- 软件\n\t- 工具类软件\n---\n持续更新遇到的问题，完结或不再使用该包将删除这句话\n\n## pgfplots\n\nPgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。\n\n<!--more-->\n\n### 实例一、通过函数方程绘制函数图像\n\n```latex\n%Ex1:f(x)=exp(x)\n\\begin{tikzpicture}\n\\begin{axis}\n\\addplot[color=red]{exp(x)};\n\\end{axis}\n\\end{tikzpicture}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png)\n\n其中绘制图像的语法如下：\n\n```latex\n\\addplot[option] {expression of 2D function};\n```\n\n在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 **;** 结尾。\n\n### 实例二、坐标系的绘制以及3d函数图像\n\n```latex\n\\documentclass{ctexart}\n\\pagestyle{empty}\n\\usepackage{pgfplots}\n\\begin{document}\n%Ex2: put the 2D plot and the 3D plot together\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot[color=red]{exp(x)};\n\t\\end{axis}\n\\end{tikzpicture}\n%Here ends the furst 2D plot\n\n\\hskip 10pt\n\n%Here begins the 3d plot\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot3[\n\t\tsurf,\n\t\t]\n\t\t{exp(-x^2-y^2)*x};\n\t\\end{axis}\n\\end{tikzpicture}\n\\end{document}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png)\n\n```latex\n\\addplot3[\n    surf,\n]\n{exp(-x^2-y^2)*x};\n```\n\n注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。\n\n可以看到对多个图像只需要设定多个tikzpicture作用域即可\n\n#### 坐标系图像中的常用命令、参数与特性\n\n- xlabel、ylabel：设定x,y坐标轴上的标志。\n- 多个addplot可在同一个图中多次作图\n- $$\\tt{domian = a:b}$$设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；\n- $$\\tt{axis\\,\\, lines = left}$$这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；\n- \\addlegendentry{$function（x)$​} 添加函数标签 \n- \\legend 按顺序批量谭家函数标签\n- title在axis中为图像添加标题\n\n### 实例三、数据图\n\n```latex\n%Ex6:plot from data\n\\begin{tikzpicture}\n\t\\begin{axis}[\n\t\ttitle={Temperature dependence of CuSO$_4\\cdot$5H$_2$O solubility},\n\t\txlabel={Temperature [\\textcelsius]},\n\t\tylabel={Solubility [g per 100 g water]},\n\t\txmin=0, xmax=100,\n\t\tymin=0, ymax=120,\n\t\txtick={0,20,40,60,80,100},\n\t\tytick={0,20,40,60,80,100,120},\n\t\tlegend pos=north west,\n\t\tymajorgrids=true,\n\t\tgrid style=dashed,\n\t\t]\n\t\t\n\t\t\\addplot[\n\t\tcolor=blue,\n\t\tmark=square,\n\t\t]\n\t\tcoordinates {\n\t\t\t(0,23.1)\n\t\t\t(10,27.5)\n\t\t\t(20,32)\n\t\t\t(30,37.8)\n\t\t\t(40,44.6)\n\t\t\t(60,61.8)\n\t\t\t(80,83.8)\n\t\t\t(100,114)\n\t\t};\n\t\t\\legend{CuSO$_4\\cdot$5H$_2$O}\n\t\t\n\t\\end{axis}\n\\end{tikzpicture}\n```\n\n\n\n#### 数据图像中的常用命令、参数与特性![test-1-crop-1](https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png)\n\n- mark：设定图像点的形状；如square、triangle、x等\n- $$\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}$$​启用/禁用 𝑦,𝑥 轴上**刻度线位置上**的网格线；\n- $$\\tt{xmin=a, xmax=b, ymin=c, ymax=d}$$​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；\n- $$\\tt{coordinates \\{\\}}$$​设定坐标点画折线图\n- \\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图\n\n### 其他图像\n\npgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。\n\n### 导言区的一些设定\n\n```latex\n\\pgfplotsset{width=10cm}\n```\n\n这里指定了每一张图的宽度为10cm\n\n```tex\n\\usepgfplotslibrary{external}\n\\tikzexternalize \n```\n\n由于$$LATEX$$ 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。","slug":"Latex宏包pgfplots做矩形函数图像","published":1,"updated":"2024-08-14T13:38:44.943Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6b0001cgwv4dwtew8k","content":"<p>持续更新遇到的问题，完结或不再使用该包将删除这句话</p>\r\n<h2 id=\"pgfplots\">pgfplots</h2>\r\n<p>Pgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots\r\n宏包会帮助用户绘制响应的图像。</p>\r\n<span id=\"more\"></span>\r\n<h3\r\nid=\"实例一通过函数方程绘制函数图像\">实例一、通过函数方程绘制函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex1:f(x)=exp(x)</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<p>其中绘制图像的语法如下：</p>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>[option] &#123;expression of 2D function&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D\r\n函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥)\r\n。最后最重要的是该命令必须以分号 <strong>;</strong> 结尾。</p>\r\n<h3\r\nid=\"实例二坐标系的绘制以及3d函数图像\">实例二、坐标系的绘制以及3d函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\documentclass</span>&#123;ctexart&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\pagestyle</span>&#123;empty&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\usepackage</span>&#123;pgfplots&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;document&#125;</span><br><span class=\"line\"><span class=\"comment\">%Ex2: put the 2D plot and the 3D plot together</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"comment\">%Here ends the furst 2D plot</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">\\hskip</span> 10pt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%Here begins the 3d plot</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">\t\tsurf,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">    surf,</span><br><span class=\"line\">]</span><br><span class=\"line\">&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。</p>\r\n<p>可以看到对多个图像只需要设定多个tikzpicture作用域即可</p>\r\n<h4\r\nid=\"坐标系图像中的常用命令参数与特性\">坐标系图像中的常用命令、参数与特性</h4>\r\n<ul>\r\n<li>xlabel、ylabel：设定x,y坐标轴上的标志。</li>\r\n<li>多个addplot可在同一个图中多次作图</li>\r\n<li><span class=\"math display\">\\[\\tt{domian = a:b}\\]</span>设置 𝑥\r\n的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；</li>\r\n<li><span class=\"math display\">\\[\\tt{axis\\,\\, lines =\r\nleft}\\]</span>这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；</li>\r\n<li> 添加函数标签</li>\r\n<li>按顺序批量谭家函数标签</li>\r\n<li>title在axis中为图像添加标题</li>\r\n</ul>\r\n<h3 id=\"实例三数据图\">实例三、数据图</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex6:plot from data</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;[</span><br><span class=\"line\">\t\ttitle=&#123;Temperature dependence of CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O solubility&#125;,</span><br><span class=\"line\">\t\txlabel=&#123;Temperature [<span class=\"keyword\">\\textcelsius</span>]&#125;,</span><br><span class=\"line\">\t\tylabel=&#123;Solubility [g per 100 g water]&#125;,</span><br><span class=\"line\">\t\txmin=0, xmax=100,</span><br><span class=\"line\">\t\tymin=0, ymax=120,</span><br><span class=\"line\">\t\txtick=&#123;0,20,40,60,80,100&#125;,</span><br><span class=\"line\">\t\tytick=&#123;0,20,40,60,80,100,120&#125;,</span><br><span class=\"line\">\t\tlegend pos=north west,</span><br><span class=\"line\">\t\tymajorgrids=true,</span><br><span class=\"line\">\t\tgrid style=dashed,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[</span><br><span class=\"line\">\t\tcolor=blue,</span><br><span class=\"line\">\t\tmark=square,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\tcoordinates &#123;</span><br><span class=\"line\">\t\t\t(0,23.1)</span><br><span class=\"line\">\t\t\t(10,27.5)</span><br><span class=\"line\">\t\t\t(20,32)</span><br><span class=\"line\">\t\t\t(30,37.8)</span><br><span class=\"line\">\t\t\t(40,44.6)</span><br><span class=\"line\">\t\t\t(60,61.8)</span><br><span class=\"line\">\t\t\t(80,83.8)</span><br><span class=\"line\">\t\t\t(100,114)</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\legend</span>&#123;CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<h4\r\nid=\"数据图像中的常用命令参数与特性test-1-crop-1\">数据图像中的常用命令、参数与特性<img\r\nsrc=\"https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png\"\r\nalt=\"test-1-crop-1\" /></h4>\r\n<ul>\r\n<li>mark：设定图像点的形状；如square、triangle、x等</li>\r\n<li><span\r\nclass=\"math display\">\\[\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}\\]</span>​启用/禁用\r\n𝑦,𝑥 轴上<strong>刻度线位置上</strong>的网格线；</li>\r\n<li><span class=\"math display\">\\[\\tt{xmin=a, xmax=b, ymin=c,\r\nymax=d}\\]</span>​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐\r\n，最大值为 𝑑 ；</li>\r\n<li><span class=\"math display\">\\[\\tt{coordinates\r\n\\{\\}}\\]</span>​设定坐标点画折线图</li>\r\n<li>table {file_with_the_data.dat},使用该命令可直接通过dat数据画图</li>\r\n</ul>\r\n<h3 id=\"其他图像\">其他图像</h3>\r\n<p>pgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。</p>\r\n<h3 id=\"导言区的一些设定\">导言区的一些设定</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\pgfplotsset</span>&#123;width=10cm&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这里指定了每一张图的宽度为10cm</p>\r\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\usepgfplotslibrary</span>&#123;external&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\tikzexternalize</span> </span><br></pre></td></tr></table></figure>\r\n<p>由于<span class=\"math display\">\\[LATEX\\]</span>\r\n诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。</p>\r\n","length":929,"excerpt":"<p>持续更新遇到的问题，完结或不再使用该包将删除这句话</p>\r\n<h2 id=\"pgfplots\">pgfplots</h2>\r\n<p>Pgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots\r\n宏包会帮助用户绘制响应的图像。</p>","more":"<h3\r\nid=\"实例一通过函数方程绘制函数图像\">实例一、通过函数方程绘制函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex1:f(x)=exp(x)</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<p>其中绘制图像的语法如下：</p>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>[option] &#123;expression of 2D function&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D\r\n函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥)\r\n。最后最重要的是该命令必须以分号 <strong>;</strong> 结尾。</p>\r\n<h3\r\nid=\"实例二坐标系的绘制以及3d函数图像\">实例二、坐标系的绘制以及3d函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\documentclass</span>&#123;ctexart&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\pagestyle</span>&#123;empty&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\usepackage</span>&#123;pgfplots&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;document&#125;</span><br><span class=\"line\"><span class=\"comment\">%Ex2: put the 2D plot and the 3D plot together</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"comment\">%Here ends the furst 2D plot</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">\\hskip</span> 10pt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%Here begins the 3d plot</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">\t\tsurf,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">    surf,</span><br><span class=\"line\">]</span><br><span class=\"line\">&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。</p>\r\n<p>可以看到对多个图像只需要设定多个tikzpicture作用域即可</p>\r\n<h4\r\nid=\"坐标系图像中的常用命令参数与特性\">坐标系图像中的常用命令、参数与特性</h4>\r\n<ul>\r\n<li>xlabel、ylabel：设定x,y坐标轴上的标志。</li>\r\n<li>多个addplot可在同一个图中多次作图</li>\r\n<li><span class=\"math display\">\\[\\tt{domian = a:b}\\]</span>设置 𝑥\r\n的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；</li>\r\n<li><span class=\"math display\">\\[\\tt{axis\\,\\, lines =\r\nleft}\\]</span>这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；</li>\r\n<li> 添加函数标签</li>\r\n<li>按顺序批量谭家函数标签</li>\r\n<li>title在axis中为图像添加标题</li>\r\n</ul>\r\n<h3 id=\"实例三数据图\">实例三、数据图</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex6:plot from data</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;[</span><br><span class=\"line\">\t\ttitle=&#123;Temperature dependence of CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O solubility&#125;,</span><br><span class=\"line\">\t\txlabel=&#123;Temperature [<span class=\"keyword\">\\textcelsius</span>]&#125;,</span><br><span class=\"line\">\t\tylabel=&#123;Solubility [g per 100 g water]&#125;,</span><br><span class=\"line\">\t\txmin=0, xmax=100,</span><br><span class=\"line\">\t\tymin=0, ymax=120,</span><br><span class=\"line\">\t\txtick=&#123;0,20,40,60,80,100&#125;,</span><br><span class=\"line\">\t\tytick=&#123;0,20,40,60,80,100,120&#125;,</span><br><span class=\"line\">\t\tlegend pos=north west,</span><br><span class=\"line\">\t\tymajorgrids=true,</span><br><span class=\"line\">\t\tgrid style=dashed,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[</span><br><span class=\"line\">\t\tcolor=blue,</span><br><span class=\"line\">\t\tmark=square,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\tcoordinates &#123;</span><br><span class=\"line\">\t\t\t(0,23.1)</span><br><span class=\"line\">\t\t\t(10,27.5)</span><br><span class=\"line\">\t\t\t(20,32)</span><br><span class=\"line\">\t\t\t(30,37.8)</span><br><span class=\"line\">\t\t\t(40,44.6)</span><br><span class=\"line\">\t\t\t(60,61.8)</span><br><span class=\"line\">\t\t\t(80,83.8)</span><br><span class=\"line\">\t\t\t(100,114)</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\legend</span>&#123;CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<h4\r\nid=\"数据图像中的常用命令参数与特性test-1-crop-1\">数据图像中的常用命令、参数与特性<img\r\nsrc=\"https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png\"\r\nalt=\"test-1-crop-1\" /></h4>\r\n<ul>\r\n<li>mark：设定图像点的形状；如square、triangle、x等</li>\r\n<li><span\r\nclass=\"math display\">\\[\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}\\]</span>​启用/禁用\r\n𝑦,𝑥 轴上<strong>刻度线位置上</strong>的网格线；</li>\r\n<li><span class=\"math display\">\\[\\tt{xmin=a, xmax=b, ymin=c,\r\nymax=d}\\]</span>​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐\r\n，最大值为 𝑑 ；</li>\r\n<li><span class=\"math display\">\\[\\tt{coordinates\r\n\\{\\}}\\]</span>​设定坐标点画折线图</li>\r\n<li>table {file_with_the_data.dat},使用该命令可直接通过dat数据画图</li>\r\n</ul>\r\n<h3 id=\"其他图像\">其他图像</h3>\r\n<p>pgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。</p>\r\n<h3 id=\"导言区的一些设定\">导言区的一些设定</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\pgfplotsset</span>&#123;width=10cm&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这里指定了每一张图的宽度为10cm</p>\r\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\usepgfplotslibrary</span>&#123;external&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\tikzexternalize</span> </span><br></pre></td></tr></table></figure>\r\n<p>由于<span class=\"math display\">\\[LATEX\\]</span>\r\n诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。</p>"},{"title":"Miracl的配置ForCentos7","date":"2024-08-14T11:55:03.000Z","_content":"Miracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).\n\nMiracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的\n\n<!--more-->\n\n```cpp\nextern \"C\"\n{\n     #include \"miracl.h\"\n}\n```\n\n实现兼容。\n\n下面是对miracl在c++环境下部署的简单步骤\n\n第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输\n\n`````shell\nwget https://github.com/miracl/MIRACL/archive/master.zip\n`````\n\n第二步、创建一个文件夹用来存放解压文件\n\n```shell\nmkdir miracl\n```\n\n第三步、复制并解压\n\n```shell\ncp master.zip ./miracl\ncd miracl/\nunzip -j -aa -L master.zip\n```\n\n第四步、验证解压并运行linux64（若32位运行linux）\n\n```shell\nls\nbash linux64\nll | grep miracl.a\n```\n\n第五步、运行官方程序\n\n```shell\n./pk-demo\n```\n\n第六步、一般情况下、复制一下文件到你的源代码目录下\n\n````shell\ncp ../miracl/miracl.a miracl.a\ncp ../miracl/miracl.h miracl.h\ncp ../miracl/mirdef.h mirdef.h\n````\n\n完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：\n\n[静态库文件](https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ)","source":"_posts/Miracl的配置ForCentos7.md","raw":"---\ntitle: Miracl的配置ForCentos7\ndate: 2024-08-14 19:55:03\ntags: [信息安全, 软件, Miracl]\ncategories: \n\t- 软件\n\t- 经典库\n\t- 信息安全\n---\nMiracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).\n\nMiracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的\n\n<!--more-->\n\n```cpp\nextern \"C\"\n{\n     #include \"miracl.h\"\n}\n```\n\n实现兼容。\n\n下面是对miracl在c++环境下部署的简单步骤\n\n第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输\n\n`````shell\nwget https://github.com/miracl/MIRACL/archive/master.zip\n`````\n\n第二步、创建一个文件夹用来存放解压文件\n\n```shell\nmkdir miracl\n```\n\n第三步、复制并解压\n\n```shell\ncp master.zip ./miracl\ncd miracl/\nunzip -j -aa -L master.zip\n```\n\n第四步、验证解压并运行linux64（若32位运行linux）\n\n```shell\nls\nbash linux64\nll | grep miracl.a\n```\n\n第五步、运行官方程序\n\n```shell\n./pk-demo\n```\n\n第六步、一般情况下、复制一下文件到你的源代码目录下\n\n````shell\ncp ../miracl/miracl.a miracl.a\ncp ../miracl/miracl.h miracl.h\ncp ../miracl/mirdef.h mirdef.h\n````\n\n完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：\n\n[静态库文件](https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ)","slug":"Miracl的配置ForCentos7","published":1,"updated":"2024-08-14T13:38:48.720Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6e0003cgwvh0bh8wto","content":"<p>Miracl is Multiprecision Integer and Rational Arithmetic\r\nCryptographic Library – the MIRACL Crypto SDK – is a C software library\r\nthat is widely regarded by developers as the gold standard open source\r\nSDK for elliptic curve cryptography (ECC).</p>\r\n<p>Miracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C\r\n软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源\r\nSDK。也可在c++环境下通过对c库的</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;miracl.h&quot;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>实现兼容。</p>\r\n<p>下面是对miracl在c++环境下部署的简单步骤</p>\r\n<p>第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/miracl/MIRACL/archive/master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第二步、创建一个文件夹用来存放解压文件</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir miracl</span><br></pre></td></tr></table></figure>\r\n<p>第三步、复制并解压</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp master.zip ./miracl</span><br><span class=\"line\">cd miracl/</span><br><span class=\"line\">unzip -j -aa -L master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第四步、验证解压并运行linux64（若32位运行linux）</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">bash linux64</span><br><span class=\"line\">ll | grep miracl.a</span><br></pre></td></tr></table></figure>\r\n<p>第五步、运行官方程序</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./pk-demo</span><br></pre></td></tr></table></figure>\r\n<p>第六步、一般情况下、复制一下文件到你的源代码目录下</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ../miracl/miracl.a miracl.a</span><br><span class=\"line\">cp ../miracl/miracl.h miracl.h</span><br><span class=\"line\">cp ../miracl/mirdef.h mirdef.h</span><br></pre></td></tr></table></figure>\r\n<p>完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：</p>\r\n<p><a\r\nhref=\"https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ\">静态库文件</a></p>\r\n","length":411,"excerpt":"<p>Miracl is Multiprecision Integer and Rational Arithmetic\r\nCryptographic Library – the MIRACL Crypto SDK – is a C software library\r\nthat is widely regarded by developers as the gold standard open source\r\nSDK for elliptic curve cryptography (ECC).</p>\r\n<p>Miracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C\r\n软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源\r\nSDK。也可在c++环境下通过对c库的</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;miracl.h&quot;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>实现兼容。</p>\r\n<p>下面是对miracl在c++环境下部署的简单步骤</p>\r\n<p>第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/miracl/MIRACL/archive/master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第二步、创建一个文件夹用来存放解压文件</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir miracl</span><br></pre></td></tr></table></figure>\r\n<p>第三步、复制并解压</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp master.zip ./miracl</span><br><span class=\"line\">cd miracl/</span><br><span class=\"line\">unzip -j -aa -L master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第四步、验证解压并运行linux64（若32位运行linux）</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">bash linux64</span><br><span class=\"line\">ll | grep miracl.a</span><br></pre></td></tr></table></figure>\r\n<p>第五步、运行官方程序</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./pk-demo</span><br></pre></td></tr></table></figure>\r\n<p>第六步、一般情况下、复制一下文件到你的源代码目录下</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ../miracl/miracl.a miracl.a</span><br><span class=\"line\">cp ../miracl/miracl.h miracl.h</span><br><span class=\"line\">cp ../miracl/mirdef.h mirdef.h</span><br></pre></td></tr></table></figure>\r\n<p>完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：</p>\r\n<p><a\r\nhref=\"https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ\">静态库文件</a></p>"},{"title":"cf-edu165C","date":"2024-08-14T11:46:31.000Z","_content":"## 题意：\n\n有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。\n\n[Problem - C - Codeforces](https://codeforces.com/contest/1969/problem/C)\n\n<!--more-->\n\n## 题解：\n\n教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。\n\n但为什么不能采用别的解法呢？\n\n考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1\n\n> 2,1,1,2,5\n\n显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。\n\n注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。\n\n于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。\n\n考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。\n\n> [x,a,b,c,y] -> [x,x,x,x,y]->[x,x,y,y,y] 其中含有无意义的两步操作\n\n再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。\n\n下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。\n\n> 对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于$$a_k|k>ii \\&\\& k <= i$$，因此所需操作数为i-ii-1\n\n最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）\n\n```cpp\nvoid slove() {\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=m;j++)f[i][j] = LLINF;\n\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) pre[i] = a[i] + pre[i-1];\n    f[0][0] = 0;\n    for(int i=1;i<=n;i++) {\n        for(int ii=i-1;ii>=0 && i-ii-1 <= m;ii--) {\n            int t = i-ii-1;\n            for(int j=t;j<=m;j++) {\n                for(int k=ii+1;k<=i;k++) {\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    // cout<<i<<' '<<j<<' '<< f[i][j]<<nline;\n                }\n            }\n        }\n    }\n\n    int ans = LLINF;\n    for(int i=0;i<=m;i++) ans = min(ans,f[n][i]);\n    cout<<ans<<endl;\n}\n```\n","source":"_posts/cf-edu165C.md","raw":"---\ntitle: cf-edu165C\ndate: 2024-08-14 19:46:31\ntags: [算法, 思维题, 贪心，状态转移]\ncategories: \n\t- 算法\n\t- 思维题\n\t- 贪心\n---\n## 题意：\n\n有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。\n\n[Problem - C - Codeforces](https://codeforces.com/contest/1969/problem/C)\n\n<!--more-->\n\n## 题解：\n\n教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。\n\n但为什么不能采用别的解法呢？\n\n考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1\n\n> 2,1,1,2,5\n\n显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。\n\n注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。\n\n于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。\n\n考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。\n\n> [x,a,b,c,y] -> [x,x,x,x,y]->[x,x,y,y,y] 其中含有无意义的两步操作\n\n再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。\n\n下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。\n\n> 对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于$$a_k|k>ii \\&\\& k <= i$$，因此所需操作数为i-ii-1\n\n最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）\n\n```cpp\nvoid slove() {\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=m;j++)f[i][j] = LLINF;\n\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) pre[i] = a[i] + pre[i-1];\n    f[0][0] = 0;\n    for(int i=1;i<=n;i++) {\n        for(int ii=i-1;ii>=0 && i-ii-1 <= m;ii--) {\n            int t = i-ii-1;\n            for(int j=t;j<=m;j++) {\n                for(int k=ii+1;k<=i;k++) {\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    // cout<<i<<' '<<j<<' '<< f[i][j]<<nline;\n                }\n            }\n        }\n    }\n\n    int ans = LLINF;\n    for(int i=0;i<=m;i++) ans = min(ans,f[n][i]);\n    cout<<ans<<endl;\n}\n```\n","slug":"cf-edu165C","published":1,"updated":"2024-08-15T01:57:07.026Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6h0007cgwv7rpxa0d9","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9D\">Problem - C -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:)\r\n假的！），很容易想到用dp做法可以解。</p>\r\n<p>但为什么不能采用别的解法呢？</p>\r\n<p>考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1</p>\r\n<blockquote>\r\n<p>2,1,1,2,5</p>\r\n</blockquote>\r\n<p>显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。</p>\r\n<p>注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗?\r\n考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。</p>\r\n<p>于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。</p>\r\n<p>考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。</p>\r\n<blockquote>\r\n<p>[x,a,b,c,y] -&gt; [x,x,x,x,y]-&gt;[x,x,y,y,y]\r\n其中含有无意义的两步操作</p>\r\n</blockquote>\r\n<p>再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。</p>\r\n<p>下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。</p>\r\n<blockquote>\r\n<p>对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于<span\r\nclass=\"math display\">\\[a_k|k&gt;ii \\&amp;\\&amp; k &lt;=\r\ni\\]</span>，因此所需操作数为i-ii-1</p>\r\n</blockquote>\r\n<p>最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;j++)f[i][j] = LLINF;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = a[i] + pre[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=i<span class=\"number\">-1</span>;ii&gt;=<span class=\"number\">0</span> &amp;&amp; i-ii<span class=\"number\">-1</span> &lt;= m;ii--) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = i-ii<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=t;j&lt;=m;j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=ii<span class=\"number\">+1</span>;k&lt;=i;k++) &#123;</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt; f[i][j]&lt;&lt;nline;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans = LLINF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++) ans = <span class=\"built_in\">min</span>(ans,f[n][i]);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":875,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9D\">Problem - C -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:)\r\n假的！），很容易想到用dp做法可以解。</p>\r\n<p>但为什么不能采用别的解法呢？</p>\r\n<p>考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1</p>\r\n<blockquote>\r\n<p>2,1,1,2,5</p>\r\n</blockquote>\r\n<p>显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。</p>\r\n<p>注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗?\r\n考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。</p>\r\n<p>于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。</p>\r\n<p>考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。</p>\r\n<blockquote>\r\n<p>[x,a,b,c,y] -&gt; [x,x,x,x,y]-&gt;[x,x,y,y,y]\r\n其中含有无意义的两步操作</p>\r\n</blockquote>\r\n<p>再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。</p>\r\n<p>下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。</p>\r\n<blockquote>\r\n<p>对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于<span\r\nclass=\"math display\">\\[a_k|k&gt;ii \\&amp;\\&amp; k &lt;=\r\ni\\]</span>，因此所需操作数为i-ii-1</p>\r\n</blockquote>\r\n<p>最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;j++)f[i][j] = LLINF;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = a[i] + pre[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=i<span class=\"number\">-1</span>;ii&gt;=<span class=\"number\">0</span> &amp;&amp; i-ii<span class=\"number\">-1</span> &lt;= m;ii--) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = i-ii<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=t;j&lt;=m;j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=ii<span class=\"number\">+1</span>;k&lt;=i;k++) &#123;</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt; f[i][j]&lt;&lt;nline;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans = LLINF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++) ans = <span class=\"built_in\">min</span>(ans,f[n][i]);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"RSA涉及算法与数论知识","date":"2024-08-14T11:51:58.000Z","_content":"**RSA** (**Rivest–Shamir–Adleman**) is a [public-key cryptosystem](https://en.wikipedia.org/wiki/Public-key_cryptography), one of the oldest widely used for secure data transmission.\n\nRSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。\n\n<!--more-->\n\n## 基础数论知识纲要\n\n传送门：[MH3210 - NTU - Number Theory - Studocu](https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934)\n\n知乎blog：[基础数论学习笔记（1）- Divisibility 整除 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/635332658)\n\n讲义：[NanYang Technological University MH1300ANDMH3210](https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg) \n\n## 概念定义\n\n**费马小定理**：选一个**素数p**，再选一个和p不成倍数关系的整数β，必然满足**β的p次幂**和**β**对p同余。公式如下。\n$$\n\\beta^p \\equiv \\beta (modp)\n$$\n**二次剩余**： 取定 $$𝑎\\perp 𝑝$$, 假若存在着 $x$使得\n$$\nx^2 \\equiv a (modp)\n$$\n\n则称$$a$$是$$modp$$的特殊剩余，否则则是$$modp$$的二次非剩余\n\n**欧拉准则**：元素β是**模奇素数p**的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\n$$\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\n$$\n\n> 欧拉准则证明：\n> 设$$r^2 = \\beta$$则有 $$r^{p-1} \\equiv 1 (modp)$$,利用费马小定理即可得证。\n\n**勒让德符号**：$$(\\frac{a}{p})$$ 若$$a$$ 是$$modp$$的平方剩余 则 $$(\\frac{a}{p}) = 1$$ ，若不是，则$$(\\frac{a}{p})= -1$$ 若$$a$$和$$p$$是整除关系则$$(\\frac{a}{p})=0$$ ,如下列公式\n$$\n(\\frac{a}{p}) = \n\\begin{cases}\n1,\\quad x^2 \\equiv a(modp)\\\\\n0, \\quad a \\equiv 0 (modp) \\\\\n-1, \\quad x^2 \\not\\equiv a(modp)\n\\end{cases}\n\\tag{1}\n$$\nSolovay-Strassen算法：若n是一个素数，那么勒让德符号$$(\\frac{β}{n})\\equiv β^{(n-1)/2}mod n$$。\n\n> Strassen算法证明：根据欧拉准则**β的(n-1)/2次方和1对n不同余**，根据费马小定理，**β的n-1次方**和1对n同余，根据平方差公式，$$β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)$$ 。由于$（β^{(n-1)/2}-1）$ 无法被n整除，所以$$（β^{(n-1)/2}+1）$$ 必然能被n整除，进而得到$$β^{(n-1)/2}\\equiv-1  (mod n)$$。\n\n**该命题的逆命题是不成立的**\n\n**二次互反律**：$$\\mathbb Z_p^\\times\\to\\mathbb Z_2$$​ \n\n**Miller-Rabin算法**：\n\n输入待测试大数$$n$$，对$$n-1$$不断地进行除$$2$$操作，直到得到一个**奇数t**。\n\n于是这可以写成 $$n-1 = 2^s \\cdot t$$ 。显然的，待测试大数$n$肯定是个奇数（废话，是偶数还测个锤子了），那么$$n-1$$肯定是个偶数，故$$s\\not=0$$。\n\n选择**随机种子$$a$$**，$$a＜n$$且与$$n$$互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）\n\n先设$$m=t$$。计算 $$b \\equiv a^t(modn)$$ ：\n\n- 情况①：当 $$m=2^s \\cdot t = n -1$$时，停机，输出“n是一个合数”。\n\n- 情况②：当 $$b \\equiv -1 (modn)$$ 时，停机，换一个随机种子a再次进行测试。\n\n- 情况③：当$$b \\equiv -1(modn)$$不成立时，重新设$b$为$$b²(mod n)$$，$$m$$为$$2m$$​；继续循环，直到得到情况①或情况②为止。\n\n## 计算方法\n\n**快速幂**：通过二进制的快速幂优化\n\n**计算勒让德符号$$(\\frac{\\beta}{n})$$​** ：二次互反\n\n**大整数除法中对小除数的优化**：移位计算小除数的商\n\n**大整数除法中对大除数的优化**：二分查找对每次计算试商的优化","source":"_posts/RSA涉及算法与数论知识.md","raw":"---\ntitle: RSA涉及算法与数论知识\ndate: 2024-08-14 19:51:58\ntags: [信息安全, 数学]\ncategories:\n\t- 信息安全\n\t- 加密算法\n\t- 数学\n---\n**RSA** (**Rivest–Shamir–Adleman**) is a [public-key cryptosystem](https://en.wikipedia.org/wiki/Public-key_cryptography), one of the oldest widely used for secure data transmission.\n\nRSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。\n\n<!--more-->\n\n## 基础数论知识纲要\n\n传送门：[MH3210 - NTU - Number Theory - Studocu](https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934)\n\n知乎blog：[基础数论学习笔记（1）- Divisibility 整除 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/635332658)\n\n讲义：[NanYang Technological University MH1300ANDMH3210](https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg) \n\n## 概念定义\n\n**费马小定理**：选一个**素数p**，再选一个和p不成倍数关系的整数β，必然满足**β的p次幂**和**β**对p同余。公式如下。\n$$\n\\beta^p \\equiv \\beta (modp)\n$$\n**二次剩余**： 取定 $$𝑎\\perp 𝑝$$, 假若存在着 $x$使得\n$$\nx^2 \\equiv a (modp)\n$$\n\n则称$$a$$是$$modp$$的特殊剩余，否则则是$$modp$$的二次非剩余\n\n**欧拉准则**：元素β是**模奇素数p**的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\n$$\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\n$$\n\n> 欧拉准则证明：\n> 设$$r^2 = \\beta$$则有 $$r^{p-1} \\equiv 1 (modp)$$,利用费马小定理即可得证。\n\n**勒让德符号**：$$(\\frac{a}{p})$$ 若$$a$$ 是$$modp$$的平方剩余 则 $$(\\frac{a}{p}) = 1$$ ，若不是，则$$(\\frac{a}{p})= -1$$ 若$$a$$和$$p$$是整除关系则$$(\\frac{a}{p})=0$$ ,如下列公式\n$$\n(\\frac{a}{p}) = \n\\begin{cases}\n1,\\quad x^2 \\equiv a(modp)\\\\\n0, \\quad a \\equiv 0 (modp) \\\\\n-1, \\quad x^2 \\not\\equiv a(modp)\n\\end{cases}\n\\tag{1}\n$$\nSolovay-Strassen算法：若n是一个素数，那么勒让德符号$$(\\frac{β}{n})\\equiv β^{(n-1)/2}mod n$$。\n\n> Strassen算法证明：根据欧拉准则**β的(n-1)/2次方和1对n不同余**，根据费马小定理，**β的n-1次方**和1对n同余，根据平方差公式，$$β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)$$ 。由于$（β^{(n-1)/2}-1）$ 无法被n整除，所以$$（β^{(n-1)/2}+1）$$ 必然能被n整除，进而得到$$β^{(n-1)/2}\\equiv-1  (mod n)$$。\n\n**该命题的逆命题是不成立的**\n\n**二次互反律**：$$\\mathbb Z_p^\\times\\to\\mathbb Z_2$$​ \n\n**Miller-Rabin算法**：\n\n输入待测试大数$$n$$，对$$n-1$$不断地进行除$$2$$操作，直到得到一个**奇数t**。\n\n于是这可以写成 $$n-1 = 2^s \\cdot t$$ 。显然的，待测试大数$n$肯定是个奇数（废话，是偶数还测个锤子了），那么$$n-1$$肯定是个偶数，故$$s\\not=0$$。\n\n选择**随机种子$$a$$**，$$a＜n$$且与$$n$$互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）\n\n先设$$m=t$$。计算 $$b \\equiv a^t(modn)$$ ：\n\n- 情况①：当 $$m=2^s \\cdot t = n -1$$时，停机，输出“n是一个合数”。\n\n- 情况②：当 $$b \\equiv -1 (modn)$$ 时，停机，换一个随机种子a再次进行测试。\n\n- 情况③：当$$b \\equiv -1(modn)$$不成立时，重新设$b$为$$b²(mod n)$$，$$m$$为$$2m$$​；继续循环，直到得到情况①或情况②为止。\n\n## 计算方法\n\n**快速幂**：通过二进制的快速幂优化\n\n**计算勒让德符号$$(\\frac{\\beta}{n})$$​** ：二次互反\n\n**大整数除法中对小除数的优化**：移位计算小除数的商\n\n**大整数除法中对大除数的优化**：二分查找对每次计算试商的优化","slug":"RSA涉及算法与数论知识","published":1,"updated":"2024-08-14T13:38:56.431Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6i0009cgwvf32v1dus","content":"<p><strong>RSA</strong> (<strong>Rivest–Shamir–Adleman</strong>) is a <a\r\nhref=\"https://en.wikipedia.org/wiki/Public-key_cryptography\">public-key\r\ncryptosystem</a>, one of the oldest widely used for secure data\r\ntransmission.</p>\r\n<p>RSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"基础数论知识纲要\">基础数论知识纲要</h2>\r\n<p>传送门：<a\r\nhref=\"https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934\">MH3210\r\n- NTU - Number Theory - Studocu</a></p>\r\n<p>知乎blog：<a\r\nhref=\"https://zhuanlan.zhihu.com/p/635332658\">基础数论学习笔记（1）-\r\nDivisibility 整除 - 知乎 (zhihu.com)</a></p>\r\n<p>讲义：<a\r\nhref=\"https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg\">NanYang\r\nTechnological University MH1300ANDMH3210</a></p>\r\n<h2 id=\"概念定义\">概念定义</h2>\r\n<p><strong>费马小定理</strong>：选一个<strong>素数p</strong>，再选一个和p不成倍数关系的整数β，必然满足<strong>β的p次幂</strong>和<strong>β</strong>对p同余。公式如下。\r\n<span class=\"math display\">\\[\r\n\\beta^p \\equiv \\beta (modp)\r\n\\]</span> <strong>二次剩余</strong>： 取定 <span\r\nclass=\"math display\">\\[𝑎\\perp 𝑝\\]</span>, 假若存在着 <span\r\nclass=\"math inline\">\\(x\\)</span>使得 <span class=\"math display\">\\[\r\nx^2 \\equiv a (modp)\r\n\\]</span></p>\r\n<p>则称<span class=\"math display\">\\[a\\]</span>是<span\r\nclass=\"math display\">\\[modp\\]</span>的特殊剩余，否则则是<span\r\nclass=\"math display\">\\[modp\\]</span>的二次非剩余</p>\r\n<p><strong>欧拉准则</strong>：元素β是<strong>模奇素数p</strong>的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\r\n<span class=\"math display\">\\[\r\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\r\n\\]</span></p>\r\n<blockquote>\r\n<p>欧拉准则证明： 设<span class=\"math display\">\\[r^2 =\r\n\\beta\\]</span>则有 <span class=\"math display\">\\[r^{p-1} \\equiv 1\r\n(modp)\\]</span>,利用费马小定理即可得证。</p>\r\n</blockquote>\r\n<p><strong>勒让德符号</strong>：<span\r\nclass=\"math display\">\\[(\\frac{a}{p})\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span> 是<span\r\nclass=\"math display\">\\[modp\\]</span>的平方剩余 则 <span\r\nclass=\"math display\">\\[(\\frac{a}{p}) = 1\\]</span> ，若不是，则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})= -1\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span>和<span\r\nclass=\"math display\">\\[p\\]</span>是整除关系则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})=0\\]</span> ,如下列公式 <span\r\nclass=\"math display\">\\[\r\n(\\frac{a}{p}) =\r\n\\begin{cases}\r\n1,\\quad x^2 \\equiv a(modp)\\\\\r\n0, \\quad a \\equiv 0 (modp) \\\\\r\n-1, \\quad x^2 \\not\\equiv a(modp)\r\n\\end{cases}\r\n\\tag{1}\r\n\\]</span> Solovay-Strassen算法：若n是一个素数，那么勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{β}{n})\\equiv β^{(n-1)/2}mod\r\nn\\]</span>。</p>\r\n<blockquote>\r\n<p>Strassen算法证明：根据欧拉准则<strong>β的(n-1)/2次方和1对n不同余</strong>，根据费马小定理，<strong>β的n-1次方</strong>和1对n同余，根据平方差公式，<span\r\nclass=\"math display\">\\[β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)\\]</span>\r\n。由于<span class=\"math inline\">\\(（β^{(n-1)/2}-1）\\)</span>\r\n无法被n整除，所以<span class=\"math display\">\\[（β^{(n-1)/2}+1）\\]</span>\r\n必然能被n整除，进而得到<span\r\nclass=\"math display\">\\[β^{(n-1)/2}\\equiv-1  (mod n)\\]</span>。</p>\r\n</blockquote>\r\n<p><strong>该命题的逆命题是不成立的</strong></p>\r\n<p><strong>二次互反律</strong>：<span class=\"math display\">\\[\\mathbb\r\nZ_p^\\times\\to\\mathbb Z_2\\]</span>​</p>\r\n<p><strong>Miller-Rabin算法</strong>：</p>\r\n<p>输入待测试大数<span class=\"math display\">\\[n\\]</span>，对<span\r\nclass=\"math display\">\\[n-1\\]</span>不断地进行除<span\r\nclass=\"math display\">\\[2\\]</span>操作，直到得到一个<strong>奇数t</strong>。</p>\r\n<p>于是这可以写成 <span class=\"math display\">\\[n-1 = 2^s \\cdot\r\nt\\]</span> 。显然的，待测试大数<span\r\nclass=\"math inline\">\\(n\\)</span>肯定是个奇数（废话，是偶数还测个锤子了），那么<span\r\nclass=\"math display\">\\[n-1\\]</span>肯定是个偶数，故<span\r\nclass=\"math display\">\\[s\\not=0\\]</span>。</p>\r\n<p>选择<strong>随机种子<span\r\nclass=\"math display\">\\[a\\]</span></strong>，<span\r\nclass=\"math display\">\\[a＜n\\]</span>且与<span\r\nclass=\"math display\">\\[n\\]</span>互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）</p>\r\n<p>先设<span class=\"math display\">\\[m=t\\]</span>。计算 <span\r\nclass=\"math display\">\\[b \\equiv a^t(modn)\\]</span> ：</p>\r\n<ul>\r\n<li><p>情况①：当 <span class=\"math display\">\\[m=2^s \\cdot t = n\r\n-1\\]</span>时，停机，输出“n是一个合数”。</p></li>\r\n<li><p>情况②：当 <span class=\"math display\">\\[b \\equiv -1\r\n(modn)\\]</span> 时，停机，换一个随机种子a再次进行测试。</p></li>\r\n<li><p>情况③：当<span class=\"math display\">\\[b \\equiv\r\n-1(modn)\\]</span>不成立时，重新设<span\r\nclass=\"math inline\">\\(b\\)</span>为<span class=\"math display\">\\[b²(mod\r\nn)\\]</span>，<span class=\"math display\">\\[m\\]</span>为<span\r\nclass=\"math display\">\\[2m\\]</span>​；继续循环，直到得到情况①或情况②为止。</p></li>\r\n</ul>\r\n<h2 id=\"计算方法\">计算方法</h2>\r\n<p><strong>快速幂</strong>：通过二进制的快速幂优化</p>\r\n<p><strong>计算勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{\\beta}{n})\\]</span>​</strong>\r\n：二次互反</p>\r\n<p><strong>大整数除法中对小除数的优化</strong>：移位计算小除数的商</p>\r\n<p><strong>大整数除法中对大除数的优化</strong>：二分查找对每次计算试商的优化</p>\r\n","length":831,"excerpt":"<p><strong>RSA</strong> (<strong>Rivest–Shamir–Adleman</strong>) is a <a\r\nhref=\"https://en.wikipedia.org/wiki/Public-key_cryptography\">public-key\r\ncryptosystem</a>, one of the oldest widely used for secure data\r\ntransmission.</p>\r\n<p>RSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。</p>","more":"<h2 id=\"基础数论知识纲要\">基础数论知识纲要</h2>\r\n<p>传送门：<a\r\nhref=\"https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934\">MH3210\r\n- NTU - Number Theory - Studocu</a></p>\r\n<p>知乎blog：<a\r\nhref=\"https://zhuanlan.zhihu.com/p/635332658\">基础数论学习笔记（1）-\r\nDivisibility 整除 - 知乎 (zhihu.com)</a></p>\r\n<p>讲义：<a\r\nhref=\"https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg\">NanYang\r\nTechnological University MH1300ANDMH3210</a></p>\r\n<h2 id=\"概念定义\">概念定义</h2>\r\n<p><strong>费马小定理</strong>：选一个<strong>素数p</strong>，再选一个和p不成倍数关系的整数β，必然满足<strong>β的p次幂</strong>和<strong>β</strong>对p同余。公式如下。\r\n<span class=\"math display\">\\[\r\n\\beta^p \\equiv \\beta (modp)\r\n\\]</span> <strong>二次剩余</strong>： 取定 <span\r\nclass=\"math display\">\\[𝑎\\perp 𝑝\\]</span>, 假若存在着 <span\r\nclass=\"math inline\">\\(x\\)</span>使得 <span class=\"math display\">\\[\r\nx^2 \\equiv a (modp)\r\n\\]</span></p>\r\n<p>则称<span class=\"math display\">\\[a\\]</span>是<span\r\nclass=\"math display\">\\[modp\\]</span>的特殊剩余，否则则是<span\r\nclass=\"math display\">\\[modp\\]</span>的二次非剩余</p>\r\n<p><strong>欧拉准则</strong>：元素β是<strong>模奇素数p</strong>的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\r\n<span class=\"math display\">\\[\r\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\r\n\\]</span></p>\r\n<blockquote>\r\n<p>欧拉准则证明： 设<span class=\"math display\">\\[r^2 =\r\n\\beta\\]</span>则有 <span class=\"math display\">\\[r^{p-1} \\equiv 1\r\n(modp)\\]</span>,利用费马小定理即可得证。</p>\r\n</blockquote>\r\n<p><strong>勒让德符号</strong>：<span\r\nclass=\"math display\">\\[(\\frac{a}{p})\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span> 是<span\r\nclass=\"math display\">\\[modp\\]</span>的平方剩余 则 <span\r\nclass=\"math display\">\\[(\\frac{a}{p}) = 1\\]</span> ，若不是，则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})= -1\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span>和<span\r\nclass=\"math display\">\\[p\\]</span>是整除关系则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})=0\\]</span> ,如下列公式 <span\r\nclass=\"math display\">\\[\r\n(\\frac{a}{p}) =\r\n\\begin{cases}\r\n1,\\quad x^2 \\equiv a(modp)\\\\\r\n0, \\quad a \\equiv 0 (modp) \\\\\r\n-1, \\quad x^2 \\not\\equiv a(modp)\r\n\\end{cases}\r\n\\tag{1}\r\n\\]</span> Solovay-Strassen算法：若n是一个素数，那么勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{β}{n})\\equiv β^{(n-1)/2}mod\r\nn\\]</span>。</p>\r\n<blockquote>\r\n<p>Strassen算法证明：根据欧拉准则<strong>β的(n-1)/2次方和1对n不同余</strong>，根据费马小定理，<strong>β的n-1次方</strong>和1对n同余，根据平方差公式，<span\r\nclass=\"math display\">\\[β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)\\]</span>\r\n。由于<span class=\"math inline\">\\(（β^{(n-1)/2}-1）\\)</span>\r\n无法被n整除，所以<span class=\"math display\">\\[（β^{(n-1)/2}+1）\\]</span>\r\n必然能被n整除，进而得到<span\r\nclass=\"math display\">\\[β^{(n-1)/2}\\equiv-1  (mod n)\\]</span>。</p>\r\n</blockquote>\r\n<p><strong>该命题的逆命题是不成立的</strong></p>\r\n<p><strong>二次互反律</strong>：<span class=\"math display\">\\[\\mathbb\r\nZ_p^\\times\\to\\mathbb Z_2\\]</span>​</p>\r\n<p><strong>Miller-Rabin算法</strong>：</p>\r\n<p>输入待测试大数<span class=\"math display\">\\[n\\]</span>，对<span\r\nclass=\"math display\">\\[n-1\\]</span>不断地进行除<span\r\nclass=\"math display\">\\[2\\]</span>操作，直到得到一个<strong>奇数t</strong>。</p>\r\n<p>于是这可以写成 <span class=\"math display\">\\[n-1 = 2^s \\cdot\r\nt\\]</span> 。显然的，待测试大数<span\r\nclass=\"math inline\">\\(n\\)</span>肯定是个奇数（废话，是偶数还测个锤子了），那么<span\r\nclass=\"math display\">\\[n-1\\]</span>肯定是个偶数，故<span\r\nclass=\"math display\">\\[s\\not=0\\]</span>。</p>\r\n<p>选择<strong>随机种子<span\r\nclass=\"math display\">\\[a\\]</span></strong>，<span\r\nclass=\"math display\">\\[a＜n\\]</span>且与<span\r\nclass=\"math display\">\\[n\\]</span>互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）</p>\r\n<p>先设<span class=\"math display\">\\[m=t\\]</span>。计算 <span\r\nclass=\"math display\">\\[b \\equiv a^t(modn)\\]</span> ：</p>\r\n<ul>\r\n<li><p>情况①：当 <span class=\"math display\">\\[m=2^s \\cdot t = n\r\n-1\\]</span>时，停机，输出“n是一个合数”。</p></li>\r\n<li><p>情况②：当 <span class=\"math display\">\\[b \\equiv -1\r\n(modn)\\]</span> 时，停机，换一个随机种子a再次进行测试。</p></li>\r\n<li><p>情况③：当<span class=\"math display\">\\[b \\equiv\r\n-1(modn)\\]</span>不成立时，重新设<span\r\nclass=\"math inline\">\\(b\\)</span>为<span class=\"math display\">\\[b²(mod\r\nn)\\]</span>，<span class=\"math display\">\\[m\\]</span>为<span\r\nclass=\"math display\">\\[2m\\]</span>​；继续循环，直到得到情况①或情况②为止。</p></li>\r\n</ul>\r\n<h2 id=\"计算方法\">计算方法</h2>\r\n<p><strong>快速幂</strong>：通过二进制的快速幂优化</p>\r\n<p><strong>计算勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{\\beta}{n})\\]</span>​</strong>\r\n：二次互反</p>\r\n<p><strong>大整数除法中对小除数的优化</strong>：移位计算小除数的商</p>\r\n<p><strong>大整数除法中对大除数的优化</strong>：二分查找对每次计算试商的优化</p>"},{"title":"cf-edu165D","date":"2024-08-14T11:45:21.000Z","_content":"## 题意：\n\n爱丽丝和鲍勃正在商店里玩游戏。商店里有 $$n$$ 件商品；每件商品有两个参数： $$a_i$$ （爱丽丝的物品价格）和 $$b_i$$ （鲍勃的物品价格）。\n\n爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：\n\n- 如果爱丽丝购买的物品少于 $$k$$ ，则鲍勃可以免费拿走所有物品；\n- 否则，他会免费拿走爱丽丝购买的$$k$$ 个物品（由鲍勃选择是哪个 $$k$$ 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 $$b_i$$。\n\n爱丽丝的利润等于 $$\\sum\\limits_{i \\in S} b_i - \\sum\\limits_{j \\in T} a_j$$ ，其中$$S$$ 是鲍勃从爱丽丝处购买的物品集， $$T$$ 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。\n\n爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。\n\n[Problem - D - Codeforces](https://codeforces.com/contest/1969/problem/D)\n\n<!--more-->\n\n## 题解：\n\n注意到，Bob在选择免费的时候显然是直接免费最大的$$b_i$$，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的$$b_i - a_i$$尽可能的大。\n\n先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n>count($$a_i<b_i$$)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。\n\n对于一个物品$$i$$，我们可以证明在$$a_i < b_i$$时该物品是必选的吗？如果我们选了这个物品：\n\n1. 并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它\n\n2. 被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。\n\n综上，无法确定在$$a_i < b_i$$时该物品是必选，对这个不等式的反也成立的物品也成立。\n\n注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。\n\n```cpp\nvoid slove() {\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) cin >> b[i];\n    vector<int> id(n);\n    for(int i=0;i<n;i++) id[i] = i;\n    sort(id.begin(), id.end(), [&](int x, int y){\n        if (b[x] != b[y]) return b[x] > b[y];\n        return a[x] < a[y];\n    });\n\n    // for(int i=0;i<n;i++) cout<<a[id[i]]<<' '<<b[id[i]]<<endl;\n    // cout<<nline;\n\n    ll s1 = 0, s2 = 0, ans = 0;\n    set<int> s;\n    for(int i = 0; i < k; i++){\n        s.insert(a[id[i]]);\n        s1 += a[id[i]];\n    }\n    for(int i = k; i < n; i++){\n        if (b[id[i]] > a[id[i]]){\n            s2 += b[id[i]] - a[id[i]];\n        }\n    }\n    for(int i = k; i < n; i++){\n        ans = max(ans, s2 - s1);\n        if (b[id[i]] > a[id[i]]){\n            s2 -= b[id[i]] - a[id[i]];\n        }\n        s.insert({a[id[i]], id[i]});\n        s1 += a[id[i]];\n        s1 -= *(--s.end());\n        s.erase(--s.end());\n    }\n    cout << ans << '\\n';\n}\n```\n","source":"_posts/cf-edu165D.md","raw":"---\ntitle: cf-edu165D\ndate: 2024-08-14 19:45:21\ntags: [算法, 博弈论, 不等式]\ncategories: \n\t- 算法\n\t- 数学\n\t- 博弈论\n---\n## 题意：\n\n爱丽丝和鲍勃正在商店里玩游戏。商店里有 $$n$$ 件商品；每件商品有两个参数： $$a_i$$ （爱丽丝的物品价格）和 $$b_i$$ （鲍勃的物品价格）。\n\n爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：\n\n- 如果爱丽丝购买的物品少于 $$k$$ ，则鲍勃可以免费拿走所有物品；\n- 否则，他会免费拿走爱丽丝购买的$$k$$ 个物品（由鲍勃选择是哪个 $$k$$ 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 $$b_i$$。\n\n爱丽丝的利润等于 $$\\sum\\limits_{i \\in S} b_i - \\sum\\limits_{j \\in T} a_j$$ ，其中$$S$$ 是鲍勃从爱丽丝处购买的物品集， $$T$$ 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。\n\n爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。\n\n[Problem - D - Codeforces](https://codeforces.com/contest/1969/problem/D)\n\n<!--more-->\n\n## 题解：\n\n注意到，Bob在选择免费的时候显然是直接免费最大的$$b_i$$，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的$$b_i - a_i$$尽可能的大。\n\n先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n>count($$a_i<b_i$$)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。\n\n对于一个物品$$i$$，我们可以证明在$$a_i < b_i$$时该物品是必选的吗？如果我们选了这个物品：\n\n1. 并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它\n\n2. 被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。\n\n综上，无法确定在$$a_i < b_i$$时该物品是必选，对这个不等式的反也成立的物品也成立。\n\n注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。\n\n```cpp\nvoid slove() {\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) cin >> b[i];\n    vector<int> id(n);\n    for(int i=0;i<n;i++) id[i] = i;\n    sort(id.begin(), id.end(), [&](int x, int y){\n        if (b[x] != b[y]) return b[x] > b[y];\n        return a[x] < a[y];\n    });\n\n    // for(int i=0;i<n;i++) cout<<a[id[i]]<<' '<<b[id[i]]<<endl;\n    // cout<<nline;\n\n    ll s1 = 0, s2 = 0, ans = 0;\n    set<int> s;\n    for(int i = 0; i < k; i++){\n        s.insert(a[id[i]]);\n        s1 += a[id[i]];\n    }\n    for(int i = k; i < n; i++){\n        if (b[id[i]] > a[id[i]]){\n            s2 += b[id[i]] - a[id[i]];\n        }\n    }\n    for(int i = k; i < n; i++){\n        ans = max(ans, s2 - s1);\n        if (b[id[i]] > a[id[i]]){\n            s2 -= b[id[i]] - a[id[i]];\n        }\n        s.insert({a[id[i]], id[i]});\n        s1 += a[id[i]];\n        s1 -= *(--s.end());\n        s.erase(--s.end());\n    }\n    cout << ans << '\\n';\n}\n```\n","slug":"cf-edu165D","published":1,"updated":"2024-08-14T13:38:37.760Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6i000bcgwvd05r774v","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>爱丽丝和鲍勃正在商店里玩游戏。商店里有 <span\r\nclass=\"math display\">\\[n\\]</span> 件商品；每件商品有两个参数： <span\r\nclass=\"math display\">\\[a_i\\]</span> （爱丽丝的物品价格）和 <span\r\nclass=\"math display\">\\[b_i\\]</span> （鲍勃的物品价格）。</p>\r\n<p>爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob\r\n会执行以下操作：</p>\r\n<ul>\r\n<li>如果爱丽丝购买的物品少于 <span class=\"math display\">\\[k\\]</span>\r\n，则鲍勃可以免费拿走所有物品；</li>\r\n<li>否则，他会免费拿走爱丽丝购买的<span\r\nclass=\"math display\">\\[k\\]</span> 个物品（由鲍勃选择是哪个 <span\r\nclass=\"math display\">\\[k\\]</span>\r\n个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 <span\r\nclass=\"math inline\">\\(i\\)</span> -个物品支付 <span\r\nclass=\"math display\">\\[b_i\\]</span>。</li>\r\n</ul>\r\n<p>爱丽丝的利润等于 <span class=\"math display\">\\[\\sum\\limits_{i \\in S}\r\nb_i - \\sum\\limits_{j \\in T} a_j\\]</span> ，其中<span\r\nclass=\"math display\">\\[S\\]</span> 是鲍勃从爱丽丝处购买的物品集， <span\r\nclass=\"math display\">\\[T\\]</span>\r\n是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。</p>\r\n<p>爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9E\">Problem - D -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>注意到，Bob在选择免费的时候显然是直接免费最大的<span\r\nclass=\"math display\">\\[b_i\\]</span>，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的<span\r\nclass=\"math display\">\\[b_i - a_i\\]</span>尽可能的大。</p>\r\n<p>先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n&gt;count(<span\r\nclass=\"math display\">\\[a_i&lt;b_i\\]</span>)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。</p>\r\n<p>对于一个物品<span\r\nclass=\"math display\">\\[i\\]</span>，我们可以证明在<span\r\nclass=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选的吗？如果我们选了这个物品：</p>\r\n<ol type=\"1\">\r\n<li><p>并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它</p></li>\r\n<li><p>被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。</p></li>\r\n</ol>\r\n<p>综上，无法确定在<span class=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选，对这个不等式的反也成立的物品也成立。</p>\r\n<p>注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span>, <span class=\"title\">b</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">id</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) id[i] = i;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(id.<span class=\"built_in\">begin</span>(), id.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[x] != b[y]) <span class=\"keyword\">return</span> b[x] &gt; b[y];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[x] &lt; a[y];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=0;i&lt;n;i++) cout&lt;&lt;a[id[i]]&lt;&lt;&#x27; &#x27;&lt;&lt;b[id[i]]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ll s1 = <span class=\"number\">0</span>, s2 = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++)&#123;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(a[id[i]]);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 += b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, s2 - s1);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 -= b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(&#123;a[id[i]], id[i]&#125;);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">        s1 -= *(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        s.<span class=\"built_in\">erase</span>(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":959,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>爱丽丝和鲍勃正在商店里玩游戏。商店里有 <span\r\nclass=\"math display\">\\[n\\]</span> 件商品；每件商品有两个参数： <span\r\nclass=\"math display\">\\[a_i\\]</span> （爱丽丝的物品价格）和 <span\r\nclass=\"math display\">\\[b_i\\]</span> （鲍勃的物品价格）。</p>\r\n<p>爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob\r\n会执行以下操作：</p>\r\n<ul>\r\n<li>如果爱丽丝购买的物品少于 <span class=\"math display\">\\[k\\]</span>\r\n，则鲍勃可以免费拿走所有物品；</li>\r\n<li>否则，他会免费拿走爱丽丝购买的<span\r\nclass=\"math display\">\\[k\\]</span> 个物品（由鲍勃选择是哪个 <span\r\nclass=\"math display\">\\[k\\]</span>\r\n个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 <span\r\nclass=\"math inline\">\\(i\\)</span> -个物品支付 <span\r\nclass=\"math display\">\\[b_i\\]</span>。</li>\r\n</ul>\r\n<p>爱丽丝的利润等于 <span class=\"math display\">\\[\\sum\\limits_{i \\in S}\r\nb_i - \\sum\\limits_{j \\in T} a_j\\]</span> ，其中<span\r\nclass=\"math display\">\\[S\\]</span> 是鲍勃从爱丽丝处购买的物品集， <span\r\nclass=\"math display\">\\[T\\]</span>\r\n是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。</p>\r\n<p>爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9E\">Problem - D -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>注意到，Bob在选择免费的时候显然是直接免费最大的<span\r\nclass=\"math display\">\\[b_i\\]</span>，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的<span\r\nclass=\"math display\">\\[b_i - a_i\\]</span>尽可能的大。</p>\r\n<p>先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n&gt;count(<span\r\nclass=\"math display\">\\[a_i&lt;b_i\\]</span>)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。</p>\r\n<p>对于一个物品<span\r\nclass=\"math display\">\\[i\\]</span>，我们可以证明在<span\r\nclass=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选的吗？如果我们选了这个物品：</p>\r\n<ol type=\"1\">\r\n<li><p>并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它</p></li>\r\n<li><p>被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。</p></li>\r\n</ol>\r\n<p>综上，无法确定在<span class=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选，对这个不等式的反也成立的物品也成立。</p>\r\n<p>注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span>, <span class=\"title\">b</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">id</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) id[i] = i;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(id.<span class=\"built_in\">begin</span>(), id.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[x] != b[y]) <span class=\"keyword\">return</span> b[x] &gt; b[y];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[x] &lt; a[y];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=0;i&lt;n;i++) cout&lt;&lt;a[id[i]]&lt;&lt;&#x27; &#x27;&lt;&lt;b[id[i]]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ll s1 = <span class=\"number\">0</span>, s2 = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++)&#123;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(a[id[i]]);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 += b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, s2 - s1);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 -= b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(&#123;a[id[i]], id[i]&#125;);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">        s1 -= *(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        s.<span class=\"built_in\">erase</span>(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"三种操作系统模拟软件使用手册","date":"2024-05-13T09:07:09.000Z","_content":"\n# 三种操作系统简单模拟使用手册\n\n## 可运行程序图标\n\nhttps://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw\n\n![image-20240525143542993](https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png)\n\n<!--more-->\n\n## 安装\n\n程序提供了三种安装形式。\n\n### exe模式\n\n第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考[Java官网](https://www.java.com/zh-CN/download/manual.jsp)\n\n### JAR模式\n\n第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用\n\n<!--more-->\n\n### install安装包模式\n\n第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。\n\n## 卸载方式\n\n通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。\n\n## 程序使用指南\n\n### 开源协议窗口\n\n![image-20240525143707804](https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png)\n\n该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。\n\n\n\n### 导航菜单界面\n\n![image-20240525143849896](https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png)\n\n该界面为程序主题界面，可通过界面导航到三个算法界面\n\n### 生产者消费者\n\n![image-20240525144036276](https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png)\n\n该界面可实现生产者消费者业务功能\n\n使用方式为：\n\n1. 按照程序显示按钮进行操作，请勿输入未指定的，空数据。\n\n1.0.1 版本常见问题为：\n\n1. 该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。\n\n### 银行家算法\n\n   ![image-20240525144551258](https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png)\n\n该界面为银行家算法界面，可实现银行家算法的功能与设计\n\n使用方式为：\n\n1. 给定总进程与总资源数\n2. 设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵\n3. 是否继续请求\n\n1.0.1版本可能遇到的问题：\n\n1. 设定过多进程与资源数导致无法输入\n2. ![image-20240525145256829](https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png)\n\n### 调度算法模拟\n\n![image-20240525144538081](https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png)\n\n调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能\n\n![image-20240525144654678](https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png)\n\n六种调度算法全称分别是\n\n1. 先到先执行\n2. 非抢占式短作业优先\n3. 最短剩余时间优先（抢占式最短作业优先）\n4. 非抢占式优先级优先\n5. 抢占式优先级优先\n6. 时间片轮转算法\n\n使用方法为：\n\n1. 输入每个进程的前四列信息\n2. 选择算法\n3. 点击计算\n\n1.0.1版本可能遇到的问题：\n\n1. 请勿设置相同进程号\n2. 请勿设置小数时间片轮转或设置为0\n3. 给定的完成时间，周转时间，等待时间将被忽略","source":"_posts/三种操作系统模拟软件使用手册.md","raw":"---\ntitle: 三种操作系统模拟软件使用手册\ndate: 2024-05-13 17:07:09\ntags: [开发, 文档, 学校]\ncategories: \n   - 软件\n   - 手册\n---\n\n# 三种操作系统简单模拟使用手册\n\n## 可运行程序图标\n\nhttps://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw\n\n![image-20240525143542993](https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png)\n\n<!--more-->\n\n## 安装\n\n程序提供了三种安装形式。\n\n### exe模式\n\n第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考[Java官网](https://www.java.com/zh-CN/download/manual.jsp)\n\n### JAR模式\n\n第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用\n\n<!--more-->\n\n### install安装包模式\n\n第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。\n\n## 卸载方式\n\n通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。\n\n## 程序使用指南\n\n### 开源协议窗口\n\n![image-20240525143707804](https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png)\n\n该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。\n\n\n\n### 导航菜单界面\n\n![image-20240525143849896](https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png)\n\n该界面为程序主题界面，可通过界面导航到三个算法界面\n\n### 生产者消费者\n\n![image-20240525144036276](https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png)\n\n该界面可实现生产者消费者业务功能\n\n使用方式为：\n\n1. 按照程序显示按钮进行操作，请勿输入未指定的，空数据。\n\n1.0.1 版本常见问题为：\n\n1. 该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。\n\n### 银行家算法\n\n   ![image-20240525144551258](https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png)\n\n该界面为银行家算法界面，可实现银行家算法的功能与设计\n\n使用方式为：\n\n1. 给定总进程与总资源数\n2. 设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵\n3. 是否继续请求\n\n1.0.1版本可能遇到的问题：\n\n1. 设定过多进程与资源数导致无法输入\n2. ![image-20240525145256829](https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png)\n\n### 调度算法模拟\n\n![image-20240525144538081](https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png)\n\n调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能\n\n![image-20240525144654678](https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png)\n\n六种调度算法全称分别是\n\n1. 先到先执行\n2. 非抢占式短作业优先\n3. 最短剩余时间优先（抢占式最短作业优先）\n4. 非抢占式优先级优先\n5. 抢占式优先级优先\n6. 时间片轮转算法\n\n使用方法为：\n\n1. 输入每个进程的前四列信息\n2. 选择算法\n3. 点击计算\n\n1.0.1版本可能遇到的问题：\n\n1. 请勿设置相同进程号\n2. 请勿设置小数时间片轮转或设置为0\n3. 给定的完成时间，周转时间，等待时间将被忽略","slug":"三种操作系统模拟软件使用手册","published":1,"updated":"2024-08-14T13:38:59.744Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6k000ecgwvdtwy9luv","content":"<h1 id=\"三种操作系统简单模拟使用手册\">三种操作系统简单模拟使用手册</h1>\r\n<h2 id=\"可运行程序图标\">可运行程序图标</h2>\r\n<p>https://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png\"\r\nalt=\"image-20240525143542993\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143542993</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h2 id=\"安装\">安装</h2>\r\n<p>程序提供了三种安装形式。</p>\r\n<h3 id=\"exe模式\">exe模式</h3>\r\n<p>第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考<a\r\nhref=\"https://www.java.com/zh-CN/download/manual.jsp\">Java官网</a></p>\r\n<h3 id=\"jar模式\">JAR模式</h3>\r\n<p>第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java\r\n-jar直接调用，也可以通过ide导入为库调用</p>\r\n<!--more-->\r\n<h3 id=\"install安装包模式\">install安装包模式</h3>\r\n<p>第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。</p>\r\n<h2 id=\"卸载方式\">卸载方式</h2>\r\n<p>通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。</p>\r\n<h2 id=\"程序使用指南\">程序使用指南</h2>\r\n<h3 id=\"开源协议窗口\">开源协议窗口</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png\"\r\nalt=\"image-20240525143707804\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143707804</figcaption>\r\n</figure>\r\n<p>该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。</p>\r\n<h3 id=\"导航菜单界面\">导航菜单界面</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png\"\r\nalt=\"image-20240525143849896\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143849896</figcaption>\r\n</figure>\r\n<p>该界面为程序主题界面，可通过界面导航到三个算法界面</p>\r\n<h3 id=\"生产者消费者\">生产者消费者</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png\"\r\nalt=\"image-20240525144036276\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144036276</figcaption>\r\n</figure>\r\n<p>该界面可实现生产者消费者业务功能</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>按照程序显示按钮进行操作，请勿输入未指定的，空数据。</li>\r\n</ol>\r\n<p>1.0.1 版本常见问题为：</p>\r\n<ol type=\"1\">\r\n<li>该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。</li>\r\n</ol>\r\n<h3 id=\"银行家算法\">银行家算法</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png\"\r\nalt=\"image-20240525144551258\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144551258</figcaption>\r\n</figure>\r\n<p>该界面为银行家算法界面，可实现银行家算法的功能与设计</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>给定总进程与总资源数</li>\r\n<li>设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵</li>\r\n<li>是否继续请求</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>设定过多进程与资源数导致无法输入</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png\"\r\nalt=\"image-20240525145256829\" />\r\n<figcaption aria-hidden=\"true\">image-20240525145256829</figcaption>\r\n</figure></li>\r\n</ol>\r\n<h3 id=\"调度算法模拟\">调度算法模拟</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png\"\r\nalt=\"image-20240525144538081\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144538081</figcaption>\r\n</figure>\r\n<p>调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png\"\r\nalt=\"image-20240525144654678\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144654678</figcaption>\r\n</figure>\r\n<p>六种调度算法全称分别是</p>\r\n<ol type=\"1\">\r\n<li>先到先执行</li>\r\n<li>非抢占式短作业优先</li>\r\n<li>最短剩余时间优先（抢占式最短作业优先）</li>\r\n<li>非抢占式优先级优先</li>\r\n<li>抢占式优先级优先</li>\r\n<li>时间片轮转算法</li>\r\n</ol>\r\n<p>使用方法为：</p>\r\n<ol type=\"1\">\r\n<li>输入每个进程的前四列信息</li>\r\n<li>选择算法</li>\r\n<li>点击计算</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>请勿设置相同进程号</li>\r\n<li>请勿设置小数时间片轮转或设置为0</li>\r\n<li>给定的完成时间，周转时间，等待时间将被忽略</li>\r\n</ol>\r\n","length":830,"excerpt":"<h1 id=\"三种操作系统简单模拟使用手册\">三种操作系统简单模拟使用手册</h1>\r\n<h2 id=\"可运行程序图标\">可运行程序图标</h2>\r\n<p>https://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png\"\r\nalt=\"image-20240525143542993\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143542993</figcaption>\r\n</figure>","more":"<h2 id=\"安装\">安装</h2>\r\n<p>程序提供了三种安装形式。</p>\r\n<h3 id=\"exe模式\">exe模式</h3>\r\n<p>第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考<a\r\nhref=\"https://www.java.com/zh-CN/download/manual.jsp\">Java官网</a></p>\r\n<h3 id=\"jar模式\">JAR模式</h3>\r\n<p>第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java\r\n-jar直接调用，也可以通过ide导入为库调用</p>\r\n<!--more-->\r\n<h3 id=\"install安装包模式\">install安装包模式</h3>\r\n<p>第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。</p>\r\n<h2 id=\"卸载方式\">卸载方式</h2>\r\n<p>通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。</p>\r\n<h2 id=\"程序使用指南\">程序使用指南</h2>\r\n<h3 id=\"开源协议窗口\">开源协议窗口</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png\"\r\nalt=\"image-20240525143707804\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143707804</figcaption>\r\n</figure>\r\n<p>该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。</p>\r\n<h3 id=\"导航菜单界面\">导航菜单界面</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png\"\r\nalt=\"image-20240525143849896\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143849896</figcaption>\r\n</figure>\r\n<p>该界面为程序主题界面，可通过界面导航到三个算法界面</p>\r\n<h3 id=\"生产者消费者\">生产者消费者</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png\"\r\nalt=\"image-20240525144036276\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144036276</figcaption>\r\n</figure>\r\n<p>该界面可实现生产者消费者业务功能</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>按照程序显示按钮进行操作，请勿输入未指定的，空数据。</li>\r\n</ol>\r\n<p>1.0.1 版本常见问题为：</p>\r\n<ol type=\"1\">\r\n<li>该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。</li>\r\n</ol>\r\n<h3 id=\"银行家算法\">银行家算法</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png\"\r\nalt=\"image-20240525144551258\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144551258</figcaption>\r\n</figure>\r\n<p>该界面为银行家算法界面，可实现银行家算法的功能与设计</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>给定总进程与总资源数</li>\r\n<li>设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵</li>\r\n<li>是否继续请求</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>设定过多进程与资源数导致无法输入</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png\"\r\nalt=\"image-20240525145256829\" />\r\n<figcaption aria-hidden=\"true\">image-20240525145256829</figcaption>\r\n</figure></li>\r\n</ol>\r\n<h3 id=\"调度算法模拟\">调度算法模拟</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png\"\r\nalt=\"image-20240525144538081\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144538081</figcaption>\r\n</figure>\r\n<p>调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png\"\r\nalt=\"image-20240525144654678\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144654678</figcaption>\r\n</figure>\r\n<p>六种调度算法全称分别是</p>\r\n<ol type=\"1\">\r\n<li>先到先执行</li>\r\n<li>非抢占式短作业优先</li>\r\n<li>最短剩余时间优先（抢占式最短作业优先）</li>\r\n<li>非抢占式优先级优先</li>\r\n<li>抢占式优先级优先</li>\r\n<li>时间片轮转算法</li>\r\n</ol>\r\n<p>使用方法为：</p>\r\n<ol type=\"1\">\r\n<li>输入每个进程的前四列信息</li>\r\n<li>选择算法</li>\r\n<li>点击计算</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>请勿设置相同进程号</li>\r\n<li>请勿设置小数时间片轮转或设置为0</li>\r\n<li>给定的完成时间，周转时间，等待时间将被忽略</li>\r\n</ol>"},{"title":"为什么我用Typora——Typora与其他markdown的比较","date":"2023-08-13T07:20:34.000Z","_content":"## Typora\n\n​\tTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。\n\n<!--more-->\n\n## Typora的Markdown语法\n\n​\tTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。\n\n​\t但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在**Latex语法格式**。\n\n​\t因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。\n\n> ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化\n\n<!--more-->\n\n### 代码块语法\n\n​\t代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行\n\n### Html、js、css\n\n​\tTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。\n\n​\t通过html也可以实现索引官方的方式是 `[这样]()`\n\n## Typora中的Mermaid，Latex\n\n​\tMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。\n\n​\t但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此**Typora并未bundle Fontawesome**。因此无法使用fa: fa-xxx表示图标。\n\n## Typora中的媒体\n\n​\tTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：\n\n1. 以ssms图床为例[Image Upload - SM.MS - Simple Free Image Hosting](https://sm.ms/)\n2. 到ssms官网注册张航并拿到apikey\n3. 填入picgo插件的配置文件\n4. ![配置图](https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png)\n\n> ```\n> {\n>   \"picBed\": {\n>     \"current\": \"smms\",\n>     \"smms\": {\n>       \"token\": \"xxx\"\n>     }\n>   },\n>   \"picgoPlugins\": {}\n> }\n> ```\n\n5. 测试并运行\n\n## Typora的文档保存机制\n\n​\t当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失\n\n## Typora的个性化主题\n\n​\tTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。\n\n## 总结\n\n​\t对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。\n\n## 一些比较实用的不在Typora文档中的使用技巧\n\n1. 通过html标签扩展typora的显示格式\n\n   如`<details></details>`标签可以显示一个展开栏，做错题本时很好用\n\n2. 一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin\n\n   [obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)](https://github.com/obgnail/typora_plugin)\n\n---\n\n待更新","source":"_posts/为什么我用Typora——Typora与其他markdown的比较.md","raw":"---\ntitle: 为什么我用Typora——Typora与其他markdown的比较\ndate: 2023-08-13 15:20:34\ntags: [Typora, Markdown, 随笔]\ncategories:\n   - 软件\n   - 编辑器\n   - Markdown\n---\n## Typora\n\n​\tTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。\n\n<!--more-->\n\n## Typora的Markdown语法\n\n​\tTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。\n\n​\t但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在**Latex语法格式**。\n\n​\t因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。\n\n> ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化\n\n<!--more-->\n\n### 代码块语法\n\n​\t代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行\n\n### Html、js、css\n\n​\tTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。\n\n​\t通过html也可以实现索引官方的方式是 `[这样]()`\n\n## Typora中的Mermaid，Latex\n\n​\tMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。\n\n​\t但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此**Typora并未bundle Fontawesome**。因此无法使用fa: fa-xxx表示图标。\n\n## Typora中的媒体\n\n​\tTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：\n\n1. 以ssms图床为例[Image Upload - SM.MS - Simple Free Image Hosting](https://sm.ms/)\n2. 到ssms官网注册张航并拿到apikey\n3. 填入picgo插件的配置文件\n4. ![配置图](https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png)\n\n> ```\n> {\n>   \"picBed\": {\n>     \"current\": \"smms\",\n>     \"smms\": {\n>       \"token\": \"xxx\"\n>     }\n>   },\n>   \"picgoPlugins\": {}\n> }\n> ```\n\n5. 测试并运行\n\n## Typora的文档保存机制\n\n​\t当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失\n\n## Typora的个性化主题\n\n​\tTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。\n\n## 总结\n\n​\t对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。\n\n## 一些比较实用的不在Typora文档中的使用技巧\n\n1. 通过html标签扩展typora的显示格式\n\n   如`<details></details>`标签可以显示一个展开栏，做错题本时很好用\n\n2. 一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin\n\n   [obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)](https://github.com/obgnail/typora_plugin)\n\n---\n\n待更新","slug":"为什么我用Typora——Typora与其他markdown的比较","published":1,"updated":"2024-08-14T13:39:02.327Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6l000fcgwv3n2jdhwi","content":"<h2 id=\"typora\">Typora</h2>\r\n<p>​\r\nTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"typora的markdown语法\">Typora的Markdown语法</h2>\r\n<p>​\r\nTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。</p>\r\n<p>​\r\n但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在<strong>Latex语法格式</strong>。</p>\r\n<p>​\r\n因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。</p>\r\n<blockquote>\r\n<p>ps:\r\n根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化</p>\r\n</blockquote>\r\n<!--more-->\r\n<h3 id=\"代码块语法\">代码块语法</h3>\r\n<p>​ 代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行</p>\r\n<h3 id=\"htmljscss\">Html、js、css</h3>\r\n<p>​\r\nTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。</p>\r\n<p>​ 通过html也可以实现索引官方的方式是 <code>[这样]()</code></p>\r\n<h2 id=\"typora中的mermaidlatex\">Typora中的Mermaid，Latex</h2>\r\n<p>​\r\nMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。</p>\r\n<p>​ 但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest\r\nversion为v6，因此<strong>Typora并未bundle\r\nFontawesome</strong>。因此无法使用fa: fa-xxx表示图标。</p>\r\n<h2 id=\"typora中的媒体\">Typora中的媒体</h2>\r\n<p>​\r\nTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：</p>\r\n<ol type=\"1\">\r\n<li>以ssms图床为例<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zbS5tcy8=\">Image Upload - SM.MS - Simple\r\nFree Image Hosting<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n<li>到ssms官网注册张航并拿到apikey</li>\r\n<li>填入picgo插件的配置文件</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png\"\r\nalt=\"配置图\" />\r\n<figcaption aria-hidden=\"true\">配置图</figcaption>\r\n</figure></li>\r\n</ol>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;picBed&quot;: &#123;</span><br><span class=\"line\">    &quot;current&quot;: &quot;smms&quot;,</span><br><span class=\"line\">    &quot;smms&quot;: &#123;</span><br><span class=\"line\">      &quot;token&quot;: &quot;xxx&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;picgoPlugins&quot;: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<ol start=\"5\" type=\"1\">\r\n<li>测试并运行</li>\r\n</ol>\r\n<h2 id=\"typora的文档保存机制\">Typora的文档保存机制</h2>\r\n<p>​\r\n当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失</p>\r\n<h2 id=\"typora的个性化主题\">Typora的个性化主题</h2>\r\n<p>​\r\nTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。</p>\r\n<h2 id=\"总结\">总结</h2>\r\n<p>​\r\n对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。</p>\r\n<h2\r\nid=\"一些比较实用的不在typora文档中的使用技巧\">一些比较实用的不在Typora文档中的使用技巧</h2>\r\n<ol type=\"1\">\r\n<li><p>通过html标签扩展typora的显示格式</p>\r\n<p>如<code>&lt;details&gt;&lt;/details&gt;</code>标签可以显示一个展开栏，做错题本时很好用</p></li>\r\n<li><p>一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin</p>\r\n<p><a\r\nhref=\"https://github.com/obgnail/typora_plugin\">obgnail/typora_plugin:\r\nTypora plugin. Feature enhancement tool | Typora 插件，功能增强工具\r\n(github.com)</a></p></li>\r\n</ol>\r\n<hr />\r\n<p>待更新</p>\r\n","length":1122,"excerpt":"<h2 id=\"typora\">Typora</h2>\r\n<p>​\r\nTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。</p>","more":"<h2 id=\"typora的markdown语法\">Typora的Markdown语法</h2>\r\n<p>​\r\nTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。</p>\r\n<p>​\r\n但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在<strong>Latex语法格式</strong>。</p>\r\n<p>​\r\n因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。</p>\r\n<blockquote>\r\n<p>ps:\r\n根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化</p>\r\n</blockquote>\r\n<!--more-->\r\n<h3 id=\"代码块语法\">代码块语法</h3>\r\n<p>​ 代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行</p>\r\n<h3 id=\"htmljscss\">Html、js、css</h3>\r\n<p>​\r\nTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。</p>\r\n<p>​ 通过html也可以实现索引官方的方式是 <code>[这样]()</code></p>\r\n<h2 id=\"typora中的mermaidlatex\">Typora中的Mermaid，Latex</h2>\r\n<p>​\r\nMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。</p>\r\n<p>​ 但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest\r\nversion为v6，因此<strong>Typora并未bundle\r\nFontawesome</strong>。因此无法使用fa: fa-xxx表示图标。</p>\r\n<h2 id=\"typora中的媒体\">Typora中的媒体</h2>\r\n<p>​\r\nTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：</p>\r\n<ol type=\"1\">\r\n<li>以ssms图床为例<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zbS5tcy8=\">Image Upload - SM.MS - Simple\r\nFree Image Hosting<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n<li>到ssms官网注册张航并拿到apikey</li>\r\n<li>填入picgo插件的配置文件</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png\"\r\nalt=\"配置图\" />\r\n<figcaption aria-hidden=\"true\">配置图</figcaption>\r\n</figure></li>\r\n</ol>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;picBed&quot;: &#123;</span><br><span class=\"line\">    &quot;current&quot;: &quot;smms&quot;,</span><br><span class=\"line\">    &quot;smms&quot;: &#123;</span><br><span class=\"line\">      &quot;token&quot;: &quot;xxx&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;picgoPlugins&quot;: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<ol start=\"5\" type=\"1\">\r\n<li>测试并运行</li>\r\n</ol>\r\n<h2 id=\"typora的文档保存机制\">Typora的文档保存机制</h2>\r\n<p>​\r\n当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失</p>\r\n<h2 id=\"typora的个性化主题\">Typora的个性化主题</h2>\r\n<p>​\r\nTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。</p>\r\n<h2 id=\"总结\">总结</h2>\r\n<p>​\r\n对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。</p>\r\n<h2\r\nid=\"一些比较实用的不在typora文档中的使用技巧\">一些比较实用的不在Typora文档中的使用技巧</h2>\r\n<ol type=\"1\">\r\n<li><p>通过html标签扩展typora的显示格式</p>\r\n<p>如<code>&lt;details&gt;&lt;/details&gt;</code>标签可以显示一个展开栏，做错题本时很好用</p></li>\r\n<li><p>一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin</p>\r\n<p><a\r\nhref=\"https://github.com/obgnail/typora_plugin\">obgnail/typora_plugin:\r\nTypora plugin. Feature enhancement tool | Typora 插件，功能增强工具\r\n(github.com)</a></p></li>\r\n</ol>\r\n<hr />\r\n<p>待更新</p>"},{"title":"思维题1","date":"2024-08-14T11:35:22.000Z","_content":"# 题意\n题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小\n\n# 题解\n题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt->ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。\n\n<!--more-->\n\n```cpp\nvoid slove(){\n    cin>>n;\n    string s;\n    cin>>s;\n    int cnt = 0,ans = 0;\n\n    for(int i=0;i<n;i++){\n        if(s[i]=='0'){\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2)%MOD;\n        }else if(s[i]&1){\n            cnt=(cnt*2+1)%MOD;\n        }else{\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2+1)%MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。\n\n对于每一个偶数计算它的贡献值为$$2^{i-1}$$，对于每一个0计算它的贡献为$$-2^{n-i}$$，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。","source":"_posts/思维题习题1.md","raw":"---\ntitle: 思维题1\ndate: 2024-08-14 19:35:22\ntags: [算法, 思维题]\ncategories: \n\t- 算法\n\t- 思维题\n---\n# 题意\n题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小\n\n# 题解\n题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt->ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。\n\n<!--more-->\n\n```cpp\nvoid slove(){\n    cin>>n;\n    string s;\n    cin>>s;\n    int cnt = 0,ans = 0;\n\n    for(int i=0;i<n;i++){\n        if(s[i]=='0'){\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2)%MOD;\n        }else if(s[i]&1){\n            cnt=(cnt*2+1)%MOD;\n        }else{\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2+1)%MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。\n\n对于每一个偶数计算它的贡献值为$$2^{i-1}$$，对于每一个0计算它的贡献为$$-2^{n-i}$$，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。","slug":"思维题习题1","published":1,"updated":"2024-08-14T13:39:08.223Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6l000icgwv2t46c1on","content":"<h1 id=\"题意\">题意</h1>\r\n<p>题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小</p>\r\n<h1 id=\"题解\">题解</h1>\r\n<p>题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt-&gt;ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。</p>\r\n<p>对于每一个偶数计算它的贡献值为<span\r\nclass=\"math display\">\\[2^{i-1}\\]</span>，对于每一个0计算它的贡献为<span\r\nclass=\"math display\">\\[-2^{n-i}\\]</span>，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。</p>\r\n","length":345,"excerpt":"<h1 id=\"题意\">题意</h1>\r\n<p>题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小</p>\r\n<h1 id=\"题解\">题解</h1>\r\n<p>题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt-&gt;ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。</p>\r\n<p>对于每一个偶数计算它的贡献值为<span\r\nclass=\"math display\">\\[2^{i-1}\\]</span>，对于每一个0计算它的贡献为<span\r\nclass=\"math display\">\\[-2^{n-i}\\]</span>，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。</p>"},{"title":"数学距离问题1","date":"2024-08-14T11:43:20.000Z","_content":"## 题意：\n\n给一个国际象棋中的“象”，但每次只能走一格，给N个点\n\n计算总和 $\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N \\text{dist}(P_i, P_j)$​ 。\n\n<!--more-->\n\n## 题解：\n\n注意到实际上这样的走法将整个棋盘以$$x+y$$的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\n$$\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\n$$\n即两个点之间的切比雪夫距离。\n\n证明如下，对于任意两个$$x+y$$奇偶性相同的顶点而言，设起始点为$$(x,y)$$，目的点为$$(xx,yy)$$设dx<dy即$$dist(p_i,p_j) = |p_i.y-p_j.y|$$。\n\n$$xx=x+dx,yy=y+dy$$，则有$$dx = a-b，a+b=dy$$，根据定义可知$$dy=yy-y$$​。\n\n由以上公式,且x,y的奇偶性相同可知xx为在dx<dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。\n\n详细参考[距离 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/geometry/distance/)\n\n如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）\n\n上图(1,4) -> (1,3)\n\n于是题目变为了求n个点的哈密顿距离之和，很经典的题。\n\n由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。\n\n<img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" />\n\ncoding。。。\n\n```cpp\nvoid slove() {\n    cin>>n;\n\n    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;\n\n    for(int i=1;i<=n;i++) {\n        if((a[i].x+a[i].y) %2==1)\n            bx[1][++cn[1]] = a[i].x + a[i].y,by[1][cn[1]] = a[i].y - a[i].x;\n        else\n            bx[0][++cn[0]] = a[i].x + a[i].y,by[0][cn[0]] = a[i].y - a[i].x;\n    }\n\n    sort(bx[0]+1,bx[0]+1+cn[0]);\n    sort(bx[1]+1,bx[1]+1+cn[1]);\n    sort(by[0]+1,by[0]+1+cn[0]);\n    sort(by[1]+1,by[1]+1+cn[1]);\n    int ans = 0;\n    for(int k =0;k<=1;k++) {\n        int sum1 =0 ,sum2=0;\n        for(int i=1;i<=cn[k];i++) {\n            // cout<<k<<' '<<bx[k][i]<<' '<<by[k][i]<<endl;\n            ans += (i-1) * (bx[k][i]+by[k][i]) - sum1-sum2;\n            sum1 += bx[k][i];\n            sum2 += by[k][i];\n        }\n    }\n    cout<<ans/2<<endl;\n}\n```\n\n","source":"_posts/数学距离问题1.md","raw":"---\ntitle: 数学距离问题1\ndate: 2024-08-14 19:43:20\ntags: [算法, 思维题, 坐标系转换, 几何问题]\ncategories: \n\t- 算法\n\t- 思维题\n---\n## 题意：\n\n给一个国际象棋中的“象”，但每次只能走一格，给N个点\n\n计算总和 $\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N \\text{dist}(P_i, P_j)$​ 。\n\n<!--more-->\n\n## 题解：\n\n注意到实际上这样的走法将整个棋盘以$$x+y$$的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\n$$\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\n$$\n即两个点之间的切比雪夫距离。\n\n证明如下，对于任意两个$$x+y$$奇偶性相同的顶点而言，设起始点为$$(x,y)$$，目的点为$$(xx,yy)$$设dx<dy即$$dist(p_i,p_j) = |p_i.y-p_j.y|$$。\n\n$$xx=x+dx,yy=y+dy$$，则有$$dx = a-b，a+b=dy$$，根据定义可知$$dy=yy-y$$​。\n\n由以上公式,且x,y的奇偶性相同可知xx为在dx<dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。\n\n详细参考[距离 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/geometry/distance/)\n\n如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）\n\n上图(1,4) -> (1,3)\n\n于是题目变为了求n个点的哈密顿距离之和，很经典的题。\n\n由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。\n\n<img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" />\n\ncoding。。。\n\n```cpp\nvoid slove() {\n    cin>>n;\n\n    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;\n\n    for(int i=1;i<=n;i++) {\n        if((a[i].x+a[i].y) %2==1)\n            bx[1][++cn[1]] = a[i].x + a[i].y,by[1][cn[1]] = a[i].y - a[i].x;\n        else\n            bx[0][++cn[0]] = a[i].x + a[i].y,by[0][cn[0]] = a[i].y - a[i].x;\n    }\n\n    sort(bx[0]+1,bx[0]+1+cn[0]);\n    sort(bx[1]+1,bx[1]+1+cn[1]);\n    sort(by[0]+1,by[0]+1+cn[0]);\n    sort(by[1]+1,by[1]+1+cn[1]);\n    int ans = 0;\n    for(int k =0;k<=1;k++) {\n        int sum1 =0 ,sum2=0;\n        for(int i=1;i<=cn[k];i++) {\n            // cout<<k<<' '<<bx[k][i]<<' '<<by[k][i]<<endl;\n            ans += (i-1) * (bx[k][i]+by[k][i]) - sum1-sum2;\n            sum1 += bx[k][i];\n            sum2 += by[k][i];\n        }\n    }\n    cout<<ans/2<<endl;\n}\n```\n\n","slug":"数学距离问题1","published":1,"updated":"2024-08-14T13:39:11.945Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6m000kcgwv3s148zsh","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>给一个国际象棋中的“象”，但每次只能走一格，给N个点</p>\r\n<p>计算总和 <span\r\nclass=\"math inline\">\\(\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N\r\n\\text{dist}(P_i, P_j)\\)</span>​ 。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>注意到实际上这样的走法将整个棋盘以<span\r\nclass=\"math display\">\\[x+y\\]</span>的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\r\n<span class=\"math display\">\\[\r\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\r\n\\]</span> 即两个点之间的切比雪夫距离。</p>\r\n<p>证明如下，对于任意两个<span\r\nclass=\"math display\">\\[x+y\\]</span>奇偶性相同的顶点而言，设起始点为<span\r\nclass=\"math display\">\\[(x,y)\\]</span>，目的点为<span\r\nclass=\"math display\">\\[(xx,yy)\\]</span>设dx&lt;dy即<span\r\nclass=\"math display\">\\[dist(p_i,p_j) = |p_i.y-p_j.y|\\]</span>。</p>\r\n<p><span class=\"math display\">\\[xx=x+dx,yy=y+dy\\]</span>，则有<span\r\nclass=\"math display\">\\[dx = a-b，a+b=dy\\]</span>，根据定义可知<span\r\nclass=\"math display\">\\[dy=yy-y\\]</span>​。</p>\r\n<p>由以上公式,且x,y的奇偶性相同可知xx为在dx&lt;dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。</p>\r\n<p>详细参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaS13aWtpLm9yZy9nZW9tZXRyeS9kaXN0YW5jZS8=\">距离 - OI\r\nWiki (oi-wiki.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）</p>\r\n<p>上图(1,4) -&gt; (1,3)</p>\r\n<p>于是题目变为了求n个点的哈密顿距离之和，很经典的题。</p>\r\n<p>由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。</p>\r\n<p><img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" /></p>\r\n<p>coding。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((a[i].x+a[i].y) %<span class=\"number\">2</span>==<span class=\"number\">1</span>)</span><br><span class=\"line\">            bx[<span class=\"number\">1</span>][++cn[<span class=\"number\">1</span>]] = a[i].x + a[i].y,by[<span class=\"number\">1</span>][cn[<span class=\"number\">1</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            bx[<span class=\"number\">0</span>][++cn[<span class=\"number\">0</span>]] = a[i].x + a[i].y,by[<span class=\"number\">0</span>][cn[<span class=\"number\">0</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k =<span class=\"number\">0</span>;k&lt;=<span class=\"number\">1</span>;k++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum1 =<span class=\"number\">0</span> ,sum2=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cn[k];i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;bx[k][i]&lt;&lt;&#x27; &#x27;&lt;&lt;by[k][i]&lt;&lt;endl;</span></span><br><span class=\"line\">            ans += (i<span class=\"number\">-1</span>) * (bx[k][i]+by[k][i]) - sum1-sum2;</span><br><span class=\"line\">            sum1 += bx[k][i];</span><br><span class=\"line\">            sum2 += by[k][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":638,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>给一个国际象棋中的“象”，但每次只能走一格，给N个点</p>\r\n<p>计算总和 <span\r\nclass=\"math inline\">\\(\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N\r\n\\text{dist}(P_i, P_j)\\)</span>​ 。</p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>注意到实际上这样的走法将整个棋盘以<span\r\nclass=\"math display\">\\[x+y\\]</span>的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\r\n<span class=\"math display\">\\[\r\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\r\n\\]</span> 即两个点之间的切比雪夫距离。</p>\r\n<p>证明如下，对于任意两个<span\r\nclass=\"math display\">\\[x+y\\]</span>奇偶性相同的顶点而言，设起始点为<span\r\nclass=\"math display\">\\[(x,y)\\]</span>，目的点为<span\r\nclass=\"math display\">\\[(xx,yy)\\]</span>设dx&lt;dy即<span\r\nclass=\"math display\">\\[dist(p_i,p_j) = |p_i.y-p_j.y|\\]</span>。</p>\r\n<p><span class=\"math display\">\\[xx=x+dx,yy=y+dy\\]</span>，则有<span\r\nclass=\"math display\">\\[dx = a-b，a+b=dy\\]</span>，根据定义可知<span\r\nclass=\"math display\">\\[dy=yy-y\\]</span>​。</p>\r\n<p>由以上公式,且x,y的奇偶性相同可知xx为在dx&lt;dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。</p>\r\n<p>详细参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaS13aWtpLm9yZy9nZW9tZXRyeS9kaXN0YW5jZS8=\">距离 - OI\r\nWiki (oi-wiki.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）</p>\r\n<p>上图(1,4) -&gt; (1,3)</p>\r\n<p>于是题目变为了求n个点的哈密顿距离之和，很经典的题。</p>\r\n<p>由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。</p>\r\n<p><img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" /></p>\r\n<p>coding。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((a[i].x+a[i].y) %<span class=\"number\">2</span>==<span class=\"number\">1</span>)</span><br><span class=\"line\">            bx[<span class=\"number\">1</span>][++cn[<span class=\"number\">1</span>]] = a[i].x + a[i].y,by[<span class=\"number\">1</span>][cn[<span class=\"number\">1</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            bx[<span class=\"number\">0</span>][++cn[<span class=\"number\">0</span>]] = a[i].x + a[i].y,by[<span class=\"number\">0</span>][cn[<span class=\"number\">0</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k =<span class=\"number\">0</span>;k&lt;=<span class=\"number\">1</span>;k++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum1 =<span class=\"number\">0</span> ,sum2=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cn[k];i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;bx[k][i]&lt;&lt;&#x27; &#x27;&lt;&lt;by[k][i]&lt;&lt;endl;</span></span><br><span class=\"line\">            ans += (i<span class=\"number\">-1</span>) * (bx[k][i]+by[k][i]) - sum1-sum2;</span><br><span class=\"line\">            sum1 += bx[k][i];</span><br><span class=\"line\">            sum2 += by[k][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"树上最短回文问题","date":"2024-08-14T11:39:46.000Z","_content":"## 题意\n\n给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？\n\n<!--more-->\n\n## 题解\n\n不想看回文的读者请跳转到“真的题解”\n\n看到回文，回顾回文！下面以数组为例子，求最长回文字符串。\n\n回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度\n\n回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。\n\n回文哈希二分：对于i，从前从后hax，二分回文长度。\n\n二分如下：\n\n```cpp\null get(ull h[], ull l, ull r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = p[i-1] * P;\n    int t =0;\n    while(cin>>s,s!=\"END\") {\n        n = s.size();\n\n        n *= 2;\n        s.resize(n);\n        for (int i = n; i; i -= 2)\n        {\n            s[i] = s[i / 2];\n            s[i - 1] = '#';\n        }\n        s = '#' + s;\n        n++;\n        // cout<<n<<endl;\n        // cout<<s<<nline;\n\n        for(int i=0;i<n;i++)if(!i) ph[i] = s[i];else ph[i] = ph[i-1] * P + s[i];\n        for(int i=n-1;~i;i--)if(i==n-1) rh[i] = s[i];else rh[i] = rh[i+1] * P + s[i];\n\n        int ans = 1;\n        for (int i = 1; i <= n; i ++ )\n        {\n            ull r = min(i - 1, n - i);\n            if (ans >= r || get(ph, i - ans, i - 1) != get(rh, n - (i + ans) + 1, n - i)) continue;\n            while (ans <= r && get(ph, i - ans, i - 1) == get(rh, n - (i + ans) + 1, n - i)) ans ++ ;\n            ans -- ;\n        }\n        cout<<\"Case \" << ++t<<\": \"<<ans<<endl;\n    }\n}\n```\n\n题解要开始加速了！\n\n首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化$$log_2n$$的解法！\n\n注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！\n\n```cpp\null ans = 1;\nfor (int i = 1; i <= n; i ++ )\n{\n  ull r = min(i - 1, n - i);\n  if (ans >= r || get(h1, i - ans, i - 1) != get(h2, n - (i + ans) + 1, n - i)) continue;\n  while (ans <= r && get(h1, i - ans, i - 1) == get(h2, n - (i + ans) + 1, n - i)) ans ++ ;\n  ans -- ;\n}\n```\n\n最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。\n\n简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R 回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）\n\n整个该算法的重点在于：“回文对称”！\n\n![img](https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg)\n\n即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。\n\n若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。\n\n若i-w[i_mirror]>=0即i_mirror的回文子串碰到了边界，则中心扩展i\n\n```cpp\n// 马拉车算法\npublic String longestPalindrome2(String s) {\n    String T = preProcess(s);\n    int n = T.length();\n    int[] P = new int[n];\n    int C = 0, R = 0;\n    for (int i = 1; i < n - 1; i++) {\n        int i_mirror = 2 * C - i;\n        if (R > i) {\n            P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R\n        } else {\n            P[i] = 0;// 等于 R 的情况\n        }\n\n        // 碰到之前讲的三种情况时候，需要利用中心扩展法\n        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\n            P[i]++;\n        }\n\n        // 判断是否需要更新 R\n        if (i + P[i] > R) {\n            C = i;\n            R = i + P[i];\n        }\n\n    }\n   \\\\代码source :https://zhuanlan.zhihu.com/p/70532099\n```\n\n## 真的题解\n\n上面讲了一串，最后还得是哈！希！，字符串，哈！希！\n\n最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。\n\n注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大$$n^2$$）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！\n\n但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。\n\n但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。\n\n```cpp\nvoid add(int a,int b) {\n    e[a].pb(b);\n    e[b].pb(a);\n}\n\nint qmi(int a,int b,int mod){\n    int res=1%mod;\n    while(b){\n        if(b&1) res=res*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return res;\n}\n\nvoid dfs1(int u = 1) {\n    siz[u] = 1;\n    int mx = 0;\n    for(int& v: e[u]) {\n        if(v==fa[u])continue;\n\n        depth[v] = depth[u] + 1;\n        ph[v]=(ph[u]*P%MOD+(s[v]-'a'+1))%MOD;\n        rh[v]=(rh[u]+p[depth[v]-1]*(s[v]-'a'+1)% MOD)%MOD;\n\n        f[v][0] = u;\n        for(int i=1;i<=20;i++)\n            f[v][i] = f[f[v][i-1]][i-1];\n        dfs1(v);\n        siz[u] += siz[v];\n        if(siz[v] > mx) {\n            mx = siz[v];hs[u] = v;\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int t = 1) {\n    len[t] ++;\n    top[u] = t;\n    if(siz[u] == 1) return ;\n    dfs2(hs[u],t);\n\n    for(int v: e[u]) {\n        if(v!=hs[u]&&v!=fa[u]) {\n            dfs2(v,v);\n        }\n    }\n}\n\nint lca(int a,int b) {\n    while(top[a] != top[b]) {\n        if(depth[top[a]] < depth[top[b]])swap(a,b);\n        a = fa[top[a]];\n    }\n    if(depth[a] < depth[b]) swap(a,b);\n    return b;\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = (p[i-1] * P) % MOD;\n    cin>>n;\n    cin>>s;\n    s = ' ' + s;\n    depth[1] = 1;\n    for(int i=1;i<=n;i++) {\n        cin>>fa[i];\n        if(fa[i]) add(i,fa[i]);\n        else fa[i] = -1;\n    }\n\n\n    ph[1]=s[1]-'a'+1,rh[1]=s[1]-'a'+1;\n    dfs1();dfs2();\n\n    cin>>m;\n    while(m--) {\n        int a,b;cin>>a>>b;\n        if(depth[a] < depth[b]) swap(a,b);\n        lc = lca(a,b);\n\n        int f=lca(a,b);\n        int p1=((rh[a]-rh[fa[f]]*qmi(p[depth[f]-1],MOD-2,MOD)%MOD)+MOD) %MOD;\n        int p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;\n        int ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;\n        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*qmi(p[depth[f]-1],MOD-2,MOD)%MOD;\n        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;\n        int ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;\n        cout<<(ans1==ans2?\"YES\\n\":\"NO\\n\");\n        cout<<f<<endl;\n        cout<<ans1<<' '<<ans2<<nline;\n    }\n}\n```\n\n","source":"_posts/树上回文问题.md","raw":"---\ntitle: 树上最短回文问题\ndate: 2024-08-14 19:39:46\ntags: [算法, 树问题，哈希算法]\ncategories: \n\t- 算法\n\t- 图论\n\t- 图论中的回文问题\n---\n## 题意\n\n给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？\n\n<!--more-->\n\n## 题解\n\n不想看回文的读者请跳转到“真的题解”\n\n看到回文，回顾回文！下面以数组为例子，求最长回文字符串。\n\n回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度\n\n回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。\n\n回文哈希二分：对于i，从前从后hax，二分回文长度。\n\n二分如下：\n\n```cpp\null get(ull h[], ull l, ull r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = p[i-1] * P;\n    int t =0;\n    while(cin>>s,s!=\"END\") {\n        n = s.size();\n\n        n *= 2;\n        s.resize(n);\n        for (int i = n; i; i -= 2)\n        {\n            s[i] = s[i / 2];\n            s[i - 1] = '#';\n        }\n        s = '#' + s;\n        n++;\n        // cout<<n<<endl;\n        // cout<<s<<nline;\n\n        for(int i=0;i<n;i++)if(!i) ph[i] = s[i];else ph[i] = ph[i-1] * P + s[i];\n        for(int i=n-1;~i;i--)if(i==n-1) rh[i] = s[i];else rh[i] = rh[i+1] * P + s[i];\n\n        int ans = 1;\n        for (int i = 1; i <= n; i ++ )\n        {\n            ull r = min(i - 1, n - i);\n            if (ans >= r || get(ph, i - ans, i - 1) != get(rh, n - (i + ans) + 1, n - i)) continue;\n            while (ans <= r && get(ph, i - ans, i - 1) == get(rh, n - (i + ans) + 1, n - i)) ans ++ ;\n            ans -- ;\n        }\n        cout<<\"Case \" << ++t<<\": \"<<ans<<endl;\n    }\n}\n```\n\n题解要开始加速了！\n\n首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化$$log_2n$$的解法！\n\n注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！\n\n```cpp\null ans = 1;\nfor (int i = 1; i <= n; i ++ )\n{\n  ull r = min(i - 1, n - i);\n  if (ans >= r || get(h1, i - ans, i - 1) != get(h2, n - (i + ans) + 1, n - i)) continue;\n  while (ans <= r && get(h1, i - ans, i - 1) == get(h2, n - (i + ans) + 1, n - i)) ans ++ ;\n  ans -- ;\n}\n```\n\n最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。\n\n简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R 回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）\n\n整个该算法的重点在于：“回文对称”！\n\n![img](https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg)\n\n即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。\n\n若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。\n\n若i-w[i_mirror]>=0即i_mirror的回文子串碰到了边界，则中心扩展i\n\n```cpp\n// 马拉车算法\npublic String longestPalindrome2(String s) {\n    String T = preProcess(s);\n    int n = T.length();\n    int[] P = new int[n];\n    int C = 0, R = 0;\n    for (int i = 1; i < n - 1; i++) {\n        int i_mirror = 2 * C - i;\n        if (R > i) {\n            P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R\n        } else {\n            P[i] = 0;// 等于 R 的情况\n        }\n\n        // 碰到之前讲的三种情况时候，需要利用中心扩展法\n        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\n            P[i]++;\n        }\n\n        // 判断是否需要更新 R\n        if (i + P[i] > R) {\n            C = i;\n            R = i + P[i];\n        }\n\n    }\n   \\\\代码source :https://zhuanlan.zhihu.com/p/70532099\n```\n\n## 真的题解\n\n上面讲了一串，最后还得是哈！希！，字符串，哈！希！\n\n最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。\n\n注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大$$n^2$$）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！\n\n但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。\n\n但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。\n\n```cpp\nvoid add(int a,int b) {\n    e[a].pb(b);\n    e[b].pb(a);\n}\n\nint qmi(int a,int b,int mod){\n    int res=1%mod;\n    while(b){\n        if(b&1) res=res*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return res;\n}\n\nvoid dfs1(int u = 1) {\n    siz[u] = 1;\n    int mx = 0;\n    for(int& v: e[u]) {\n        if(v==fa[u])continue;\n\n        depth[v] = depth[u] + 1;\n        ph[v]=(ph[u]*P%MOD+(s[v]-'a'+1))%MOD;\n        rh[v]=(rh[u]+p[depth[v]-1]*(s[v]-'a'+1)% MOD)%MOD;\n\n        f[v][0] = u;\n        for(int i=1;i<=20;i++)\n            f[v][i] = f[f[v][i-1]][i-1];\n        dfs1(v);\n        siz[u] += siz[v];\n        if(siz[v] > mx) {\n            mx = siz[v];hs[u] = v;\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int t = 1) {\n    len[t] ++;\n    top[u] = t;\n    if(siz[u] == 1) return ;\n    dfs2(hs[u],t);\n\n    for(int v: e[u]) {\n        if(v!=hs[u]&&v!=fa[u]) {\n            dfs2(v,v);\n        }\n    }\n}\n\nint lca(int a,int b) {\n    while(top[a] != top[b]) {\n        if(depth[top[a]] < depth[top[b]])swap(a,b);\n        a = fa[top[a]];\n    }\n    if(depth[a] < depth[b]) swap(a,b);\n    return b;\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = (p[i-1] * P) % MOD;\n    cin>>n;\n    cin>>s;\n    s = ' ' + s;\n    depth[1] = 1;\n    for(int i=1;i<=n;i++) {\n        cin>>fa[i];\n        if(fa[i]) add(i,fa[i]);\n        else fa[i] = -1;\n    }\n\n\n    ph[1]=s[1]-'a'+1,rh[1]=s[1]-'a'+1;\n    dfs1();dfs2();\n\n    cin>>m;\n    while(m--) {\n        int a,b;cin>>a>>b;\n        if(depth[a] < depth[b]) swap(a,b);\n        lc = lca(a,b);\n\n        int f=lca(a,b);\n        int p1=((rh[a]-rh[fa[f]]*qmi(p[depth[f]-1],MOD-2,MOD)%MOD)+MOD) %MOD;\n        int p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;\n        int ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;\n        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*qmi(p[depth[f]-1],MOD-2,MOD)%MOD;\n        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;\n        int ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;\n        cout<<(ans1==ans2?\"YES\\n\":\"NO\\n\");\n        cout<<f<<endl;\n        cout<<ans1<<' '<<ans2<<nline;\n    }\n}\n```\n\n","slug":"树上回文问题","published":1,"updated":"2024-08-14T13:39:14.786Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6n000ocgwv3guqfg4w","content":"<h2 id=\"题意\">题意</h2>\r\n<p>给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>不想看回文的读者请跳转到“真的题解”</p>\r\n<p>看到回文，回顾回文！下面以数组为例子，求最长回文字符串。</p>\r\n<p>回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度</p>\r\n<p>回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。</p>\r\n<p>回文哈希二分：对于i，从前从后hax，二分回文长度。</p>\r\n<p>二分如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ull <span class=\"title\">get</span><span class=\"params\">(ull h[], ull l, ull r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h[r] - h[l - <span class=\"number\">1</span>] * p[r - l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = p[i<span class=\"number\">-1</span>] * P;</span><br><span class=\"line\">    <span class=\"type\">int</span> t =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;s,s!=<span class=\"string\">&quot;END&quot;</span>) &#123;</span><br><span class=\"line\">        n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i; i -= <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s[i] = s[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">            s[i - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s = <span class=\"string\">&#x27;#&#x27;</span> + s;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;s&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"keyword\">if</span>(!i) ph[i] = s[i];<span class=\"keyword\">else</span> ph[i] = ph[i<span class=\"number\">-1</span>] * P + s[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n<span class=\"number\">-1</span>;~i;i--)<span class=\"keyword\">if</span>(i==n<span class=\"number\">-1</span>) rh[i] = s[i];<span class=\"keyword\">else</span> rh[i] = rh[i<span class=\"number\">+1</span>] * P + s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">            ans -- ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case &quot;</span> &lt;&lt; ++t&lt;&lt;<span class=\"string\">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>题解要开始加速了！</p>\r\n<p>首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化<span\r\nclass=\"math display\">\\[log_2n\\]</span>的解法！</p>\r\n<p>注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ull ans = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">  ans -- ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。</p>\r\n<p>简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R\r\n回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）</p>\r\n<p>整个该算法的重点在于：“回文对称”！</p>\r\n<figure>\r\n<img\r\nsrc=\"https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。</p>\r\n<p>若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。</p>\r\n<p>若i-w[i_mirror]&gt;=0即i_mirror的回文子串碰到了边界，则中心扩展i</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 马拉车算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome2</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    String T = <span class=\"built_in\">preProcess</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = T.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] P = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n];</span><br><span class=\"line\">    <span class=\"type\">int</span> C = <span class=\"number\">0</span>, R = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i_mirror = <span class=\"number\">2</span> * C - i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (R &gt; i) &#123;</span><br><span class=\"line\">            P[i] = Math.<span class=\"built_in\">min</span>(R - i, P[i_mirror]);<span class=\"comment\">// 防止超出 R</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            P[i] = <span class=\"number\">0</span>;<span class=\"comment\">// 等于 R 的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T.<span class=\"built_in\">charAt</span>(i + <span class=\"number\">1</span> + P[i]) == T.<span class=\"built_in\">charAt</span>(i - <span class=\"number\">1</span> - P[i])) &#123;</span><br><span class=\"line\">            P[i]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否需要更新 R</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + P[i] &gt; R) &#123;</span><br><span class=\"line\">            C = i;</span><br><span class=\"line\">            R = i + P[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \\\\代码source :https:<span class=\"comment\">//zhuanlan.zhihu.com/p/70532099</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"真的题解\">真的题解</h2>\r\n<p>上面讲了一串，最后还得是哈！希！，字符串，哈！希！</p>\r\n<p>最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。</p>\r\n<p>注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大<span\r\nclass=\"math display\">\\[n^2\\]</span>）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！</p>\r\n<p>但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。</p>\r\n<p>但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">    e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">qmi</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> mod)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">1</span>%mod;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res=res*a%mod;</span><br><span class=\"line\">        a=a*a%mod;</span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    siz[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span>&amp; v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==fa[u])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        depth[v] = depth[u] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        ph[v]=(ph[u]*P%MOD+(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>))%MOD;</span><br><span class=\"line\">        rh[v]=(rh[u]+p[depth[v]<span class=\"number\">-1</span>]*(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>)% MOD)%MOD;</span><br><span class=\"line\"></span><br><span class=\"line\">        f[v][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">20</span>;i++)</span><br><span class=\"line\">            f[v][i] = f[f[v][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">dfs1</span>(v);</span><br><span class=\"line\">        siz[u] += siz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[v] &gt; mx) &#123;</span><br><span class=\"line\">            mx = siz[v];hs[u] = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>, <span class=\"type\">int</span> t = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    len[t] ++;</span><br><span class=\"line\">    top[u] = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(siz[u] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(hs[u],t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v!=hs[u]&amp;&amp;v!=fa[u]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs2</span>(v,v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[a] != top[b]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[top[a]] &lt; depth[top[b]])<span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        a = fa[top[a]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = (p[i<span class=\"number\">-1</span>] * P) % MOD;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    s = <span class=\"string\">&#x27; &#x27;</span> + s;</span><br><span class=\"line\">    depth[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;fa[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fa[i]) <span class=\"built_in\">add</span>(i,fa[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> fa[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    ph[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>,rh[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dfs1</span>();<span class=\"built_in\">dfs2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        lc = <span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> f=<span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\">        <span class=\"type\">int</span> p1=((rh[a]-rh[fa[f]]*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD)+MOD) %MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD;</span><br><span class=\"line\">        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        cout&lt;&lt;(ans1==ans2?<span class=\"string\">&quot;YES\\n&quot;</span>:<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        cout&lt;&lt;f&lt;&lt;endl;</span><br><span class=\"line\">        cout&lt;&lt;ans1&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;nline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1668,"excerpt":"<h2 id=\"题意\">题意</h2>\r\n<p>给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？</p>","more":"<h2 id=\"题解\">题解</h2>\r\n<p>不想看回文的读者请跳转到“真的题解”</p>\r\n<p>看到回文，回顾回文！下面以数组为例子，求最长回文字符串。</p>\r\n<p>回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度</p>\r\n<p>回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。</p>\r\n<p>回文哈希二分：对于i，从前从后hax，二分回文长度。</p>\r\n<p>二分如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ull <span class=\"title\">get</span><span class=\"params\">(ull h[], ull l, ull r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h[r] - h[l - <span class=\"number\">1</span>] * p[r - l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = p[i<span class=\"number\">-1</span>] * P;</span><br><span class=\"line\">    <span class=\"type\">int</span> t =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;s,s!=<span class=\"string\">&quot;END&quot;</span>) &#123;</span><br><span class=\"line\">        n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i; i -= <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s[i] = s[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">            s[i - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s = <span class=\"string\">&#x27;#&#x27;</span> + s;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;s&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"keyword\">if</span>(!i) ph[i] = s[i];<span class=\"keyword\">else</span> ph[i] = ph[i<span class=\"number\">-1</span>] * P + s[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n<span class=\"number\">-1</span>;~i;i--)<span class=\"keyword\">if</span>(i==n<span class=\"number\">-1</span>) rh[i] = s[i];<span class=\"keyword\">else</span> rh[i] = rh[i<span class=\"number\">+1</span>] * P + s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">            ans -- ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case &quot;</span> &lt;&lt; ++t&lt;&lt;<span class=\"string\">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>题解要开始加速了！</p>\r\n<p>首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化<span\r\nclass=\"math display\">\\[log_2n\\]</span>的解法！</p>\r\n<p>注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ull ans = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">  ans -- ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。</p>\r\n<p>简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R\r\n回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）</p>\r\n<p>整个该算法的重点在于：“回文对称”！</p>\r\n<figure>\r\n<img\r\nsrc=\"https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。</p>\r\n<p>若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。</p>\r\n<p>若i-w[i_mirror]&gt;=0即i_mirror的回文子串碰到了边界，则中心扩展i</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 马拉车算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome2</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    String T = <span class=\"built_in\">preProcess</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = T.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] P = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n];</span><br><span class=\"line\">    <span class=\"type\">int</span> C = <span class=\"number\">0</span>, R = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i_mirror = <span class=\"number\">2</span> * C - i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (R &gt; i) &#123;</span><br><span class=\"line\">            P[i] = Math.<span class=\"built_in\">min</span>(R - i, P[i_mirror]);<span class=\"comment\">// 防止超出 R</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            P[i] = <span class=\"number\">0</span>;<span class=\"comment\">// 等于 R 的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T.<span class=\"built_in\">charAt</span>(i + <span class=\"number\">1</span> + P[i]) == T.<span class=\"built_in\">charAt</span>(i - <span class=\"number\">1</span> - P[i])) &#123;</span><br><span class=\"line\">            P[i]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否需要更新 R</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + P[i] &gt; R) &#123;</span><br><span class=\"line\">            C = i;</span><br><span class=\"line\">            R = i + P[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \\\\代码source :https:<span class=\"comment\">//zhuanlan.zhihu.com/p/70532099</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"真的题解\">真的题解</h2>\r\n<p>上面讲了一串，最后还得是哈！希！，字符串，哈！希！</p>\r\n<p>最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。</p>\r\n<p>注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大<span\r\nclass=\"math display\">\\[n^2\\]</span>）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！</p>\r\n<p>但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。</p>\r\n<p>但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">    e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">qmi</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> mod)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">1</span>%mod;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res=res*a%mod;</span><br><span class=\"line\">        a=a*a%mod;</span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    siz[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span>&amp; v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==fa[u])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        depth[v] = depth[u] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        ph[v]=(ph[u]*P%MOD+(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>))%MOD;</span><br><span class=\"line\">        rh[v]=(rh[u]+p[depth[v]<span class=\"number\">-1</span>]*(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>)% MOD)%MOD;</span><br><span class=\"line\"></span><br><span class=\"line\">        f[v][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">20</span>;i++)</span><br><span class=\"line\">            f[v][i] = f[f[v][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">dfs1</span>(v);</span><br><span class=\"line\">        siz[u] += siz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[v] &gt; mx) &#123;</span><br><span class=\"line\">            mx = siz[v];hs[u] = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>, <span class=\"type\">int</span> t = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    len[t] ++;</span><br><span class=\"line\">    top[u] = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(siz[u] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(hs[u],t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v!=hs[u]&amp;&amp;v!=fa[u]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs2</span>(v,v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[a] != top[b]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[top[a]] &lt; depth[top[b]])<span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        a = fa[top[a]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = (p[i<span class=\"number\">-1</span>] * P) % MOD;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    s = <span class=\"string\">&#x27; &#x27;</span> + s;</span><br><span class=\"line\">    depth[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;fa[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fa[i]) <span class=\"built_in\">add</span>(i,fa[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> fa[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    ph[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>,rh[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dfs1</span>();<span class=\"built_in\">dfs2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        lc = <span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> f=<span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\">        <span class=\"type\">int</span> p1=((rh[a]-rh[fa[f]]*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD)+MOD) %MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD;</span><br><span class=\"line\">        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        cout&lt;&lt;(ans1==ans2?<span class=\"string\">&quot;YES\\n&quot;</span>:<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        cout&lt;&lt;f&lt;&lt;endl;</span><br><span class=\"line\">        cout&lt;&lt;ans1&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;nline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题","date":"2024-08-14T11:30:37.000Z","_content":"# 题意：\n\n给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。\n\n你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个**连续的子段**，然后从该子段中删除**所有**元素，**除**该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。\n\n如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。\n\n<!--more-->\n\n# 题解：\n\n根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。\n\n考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]<a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l_{a_i}$下标为j，则小于j且大于$l_{a_j}$的下标k的下标idx均无法转移至i，显然$l_{a_i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l_{a_x}$则无法转移到i。\n\n总结状态转移为$f_i = \\sum_{k={l_{a_i}+1}}^{i-1} f_k + \\sum_{k=l^x(l_{a_i})}^{k>0}f_{k}$\n\n前缀和处理即可。\n\n```cpp\n\tvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n\n    s[top] = {-1,-1};\n    for(int i = 1;i <= n;i++) {\n        while(top && s[top].x > a[i]) top--;\n        l[i] = s[top].y;\n        s[++top] = {a[i],i};\n    }\n\n    // for(int i=1;i<=n;i++) cout<<l[i]<<' ';\n    // cout<<endl;\n\n    for(int i=0;i<=n;i++) pre1[i] = pre2[i] = 0;\n\n    f[0] = 1;\n    pre1[0] = 1;\n    for(int i=1;i<=n;i++) {\n        if(l[i]!=-1) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;\n        int t = l[i] == -1 ? 0: pre1[l[i]];\n        f[i] = (pre1[i-1] - t) % MOD ;\n        // cout<<(pre1[i-1] - t)<<' ';\n        f[i] += pre2[i];\n\n        pre1[i] = pre1[i-1] + f[i] % MOD;\n        // cout<<i<<' '<<pre1[i]<<' '<<pre2[i]<<' '<<f[i]<<nline;\n    }\n\n    int mi = 1e18,ans = 0;\n    for(int i=n; i>=1; i--) {\n        mi = min(mi,a[i]);\n        if(mi==a[i]) {\n            ans = (ans + f[i]) % MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n","source":"_posts/状态转移习题1.md","raw":"---\ntitle: 状态转移习题\ndate: 2024-08-14 19:30:37\ntags: [算法, 状态转移]\ncategories: \n\t- 算法\n\t- 状态转移\n---\n# 题意：\n\n给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。\n\n你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个**连续的子段**，然后从该子段中删除**所有**元素，**除**该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。\n\n如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。\n\n<!--more-->\n\n# 题解：\n\n根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。\n\n考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]<a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l_{a_i}$下标为j，则小于j且大于$l_{a_j}$的下标k的下标idx均无法转移至i，显然$l_{a_i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l_{a_x}$则无法转移到i。\n\n总结状态转移为$f_i = \\sum_{k={l_{a_i}+1}}^{i-1} f_k + \\sum_{k=l^x(l_{a_i})}^{k>0}f_{k}$\n\n前缀和处理即可。\n\n```cpp\n\tvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n\n    s[top] = {-1,-1};\n    for(int i = 1;i <= n;i++) {\n        while(top && s[top].x > a[i]) top--;\n        l[i] = s[top].y;\n        s[++top] = {a[i],i};\n    }\n\n    // for(int i=1;i<=n;i++) cout<<l[i]<<' ';\n    // cout<<endl;\n\n    for(int i=0;i<=n;i++) pre1[i] = pre2[i] = 0;\n\n    f[0] = 1;\n    pre1[0] = 1;\n    for(int i=1;i<=n;i++) {\n        if(l[i]!=-1) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;\n        int t = l[i] == -1 ? 0: pre1[l[i]];\n        f[i] = (pre1[i-1] - t) % MOD ;\n        // cout<<(pre1[i-1] - t)<<' ';\n        f[i] += pre2[i];\n\n        pre1[i] = pre1[i-1] + f[i] % MOD;\n        // cout<<i<<' '<<pre1[i]<<' '<<pre2[i]<<' '<<f[i]<<nline;\n    }\n\n    int mi = 1e18,ans = 0;\n    for(int i=n; i>=1; i--) {\n        mi = min(mi,a[i]);\n        if(mi==a[i]) {\n            ans = (ans + f[i]) % MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n","slug":"状态转移习题1","published":1,"updated":"2024-08-14T13:39:18.757Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6o000pcgwv2o3o09xf","content":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。</p>\r\n<p>你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p\r\n中选择一个<strong>连续的子段</strong>，然后从该子段中删除<strong>所有</strong>元素，<strong>除</strong>该子段中最小的元素。例如，如果选择p\r\n= [3, 1, 4, 7, 5, 2,\r\n6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3,\r\n1, 2, 6]。</p>\r\n<p>如果数组\r\na可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a\r\n就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留\r\n𝑎𝑖 的情况下的贡献值。</p>\r\n<p>考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖\r\n是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为<span\r\nclass=\"math inline\">\\(dp(i) +=\r\ndp(j)(其中a[j]&lt;a[i])\\)</span>另外一种情况则是，不对i进行操作。考虑上一个比<span\r\nclass=\"math inline\">\\(a[i]\\)</span>小的数为<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>下标为j，则小于j且大于<span\r\nclass=\"math inline\">\\(l_{a_j}\\)</span>的下标k的下标idx均无法转移至i，显然<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于<span\r\nclass=\"math inline\">\\(l_{a_x}\\)</span>则无法转移到i。</p>\r\n<p>总结状态转移为<span class=\"math inline\">\\(f_i =\r\n\\sum_{k={l_{a_i}+1}}^{i-1} f_k +\r\n\\sum_{k=l^x(l_{a_i})}^{k&gt;0}f_{k}\\)</span></p>\r\n<p>前缀和处理即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    s[top] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(top &amp;&amp; s[top].x &gt; a[i]) top--;</span><br><span class=\"line\">        l[i] = s[top].y;</span><br><span class=\"line\">        s[++top] = &#123;a[i],i&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;l[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++) pre1[i] = pre2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    pre1[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l[i]!=<span class=\"number\">-1</span>) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = l[i] == <span class=\"number\">-1</span> ? <span class=\"number\">0</span>: pre1[l[i]];</span><br><span class=\"line\">        f[i] = (pre1[i<span class=\"number\">-1</span>] - t) % MOD ;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;(pre1[i-1] - t)&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">        f[i] += pre2[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        pre1[i] = pre1[i<span class=\"number\">-1</span>] + f[i] % MOD;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;pre1[i]&lt;&lt;&#x27; &#x27;&lt;&lt;pre2[i]&lt;&lt;&#x27; &#x27;&lt;&lt;f[i]&lt;&lt;nline;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mi = <span class=\"number\">1e18</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n; i&gt;=<span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        mi = <span class=\"built_in\">min</span>(mi,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mi==a[i]) &#123;</span><br><span class=\"line\">            ans = (ans + f[i]) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":708,"excerpt":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。</p>\r\n<p>你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p\r\n中选择一个<strong>连续的子段</strong>，然后从该子段中删除<strong>所有</strong>元素，<strong>除</strong>该子段中最小的元素。例如，如果选择p\r\n= [3, 1, 4, 7, 5, 2,\r\n6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3,\r\n1, 2, 6]。</p>\r\n<p>如果数组\r\na可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a\r\n就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。</p>","more":"<h1 id=\"题解\">题解：</h1>\r\n<p>根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留\r\n𝑎𝑖 的情况下的贡献值。</p>\r\n<p>考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖\r\n是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为<span\r\nclass=\"math inline\">\\(dp(i) +=\r\ndp(j)(其中a[j]&lt;a[i])\\)</span>另外一种情况则是，不对i进行操作。考虑上一个比<span\r\nclass=\"math inline\">\\(a[i]\\)</span>小的数为<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>下标为j，则小于j且大于<span\r\nclass=\"math inline\">\\(l_{a_j}\\)</span>的下标k的下标idx均无法转移至i，显然<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于<span\r\nclass=\"math inline\">\\(l_{a_x}\\)</span>则无法转移到i。</p>\r\n<p>总结状态转移为<span class=\"math inline\">\\(f_i =\r\n\\sum_{k={l_{a_i}+1}}^{i-1} f_k +\r\n\\sum_{k=l^x(l_{a_i})}^{k&gt;0}f_{k}\\)</span></p>\r\n<p>前缀和处理即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    s[top] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(top &amp;&amp; s[top].x &gt; a[i]) top--;</span><br><span class=\"line\">        l[i] = s[top].y;</span><br><span class=\"line\">        s[++top] = &#123;a[i],i&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;l[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++) pre1[i] = pre2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    pre1[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l[i]!=<span class=\"number\">-1</span>) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = l[i] == <span class=\"number\">-1</span> ? <span class=\"number\">0</span>: pre1[l[i]];</span><br><span class=\"line\">        f[i] = (pre1[i<span class=\"number\">-1</span>] - t) % MOD ;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;(pre1[i-1] - t)&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">        f[i] += pre2[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        pre1[i] = pre1[i<span class=\"number\">-1</span>] + f[i] % MOD;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;pre1[i]&lt;&lt;&#x27; &#x27;&lt;&lt;pre2[i]&lt;&lt;&#x27; &#x27;&lt;&lt;f[i]&lt;&lt;nline;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mi = <span class=\"number\">1e18</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n; i&gt;=<span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        mi = <span class=\"built_in\">min</span>(mi,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mi==a[i]) &#123;</span><br><span class=\"line\">            ans = (ans + f[i]) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题2","date":"2024-08-14T11:32:13.000Z","_content":"# 题意：\n\n给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。\n\n首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。\n\n然后，你必须使数组中的所有元素相等。一开始，你选择一个**正**整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。**注意， x 在所有操作中都是一样的**。\n\n选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？\n\n<!--more-->\n\n# 题解：\n\n容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。\n\n可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。\n\n```\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int mx = -INF;\n    for(int i=1;i<=n;i++) {\n        mx = max(mx,a[i]);\n    }\n\n    for(int i=1;i<=n;i++) d[i] = mx - a[i];\n\n    int gd = 0;\n    for(int i=1;i<=n;i++) gd = __gcd(d[i],gd);\n\n    if(!gd) {cout<<1<<endl;return ;}\n\n    ll sum = 0;\n    set<int> S;\n    for(int i=1;i<=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);\n    int t = 1;\n    while(1) if(S.count(t)) t++;else break;\n    cout<<sum + t<<endl;\n}\n```","source":"_posts/状态转移习题2.md","raw":"---\ntitle: 状态转移习题2\ndate: 2024-08-14 19:32:13\ntags: [算法, 状态转移]\ncategories: \n\t- 算法\n\t- 状态转移\n---\n# 题意：\n\n给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。\n\n首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。\n\n然后，你必须使数组中的所有元素相等。一开始，你选择一个**正**整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。**注意， x 在所有操作中都是一样的**。\n\n选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？\n\n<!--more-->\n\n# 题解：\n\n容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。\n\n可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。\n\n```\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int mx = -INF;\n    for(int i=1;i<=n;i++) {\n        mx = max(mx,a[i]);\n    }\n\n    for(int i=1;i<=n;i++) d[i] = mx - a[i];\n\n    int gd = 0;\n    for(int i=1;i<=n;i++) gd = __gcd(d[i],gd);\n\n    if(!gd) {cout<<1<<endl;return ;}\n\n    ll sum = 0;\n    set<int> S;\n    for(int i=1;i<=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);\n    int t = 1;\n    while(1) if(S.count(t)) t++;else break;\n    cout<<sum + t<<endl;\n}\n```","slug":"状态转移习题2","published":1,"updated":"2024-08-14T13:39:21.942Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6p000scgwv1jndchhx","content":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个整数数组 1, 2,…, ，它的所有元素都是不同的。</p>\r\n<p>首先，要求你在数组中再插入一个整数 an+1 。 an +1 不应等于 a1, a2,…,\r\nan中的任何一个。</p>\r\n<p>然后，你必须使数组中的所有元素相等。一开始，你选择一个<strong>正</strong>整数\r\nx。在一次操作中，你将 x 恰好加到数组的一个元素上。<strong>注意， x\r\n在所有操作中都是一样的</strong>。</p>\r\n<p>选择 +1 和 x 后，使所有元素相等的最小操作次数是多少？</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于\r\n∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖)\r\n（mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。</p>\r\n<p>可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void slove()&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int mx = -INF;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        mx = max(mx,a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) d[i] = mx - a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int gd = 0;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) gd = __gcd(d[i],gd);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!gd) &#123;cout&lt;&lt;1&lt;&lt;endl;return ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll sum = 0;</span><br><span class=\"line\">    set&lt;int&gt; S;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);</span><br><span class=\"line\">    int t = 1;</span><br><span class=\"line\">    while(1) if(S.count(t)) t++;else break;</span><br><span class=\"line\">    cout&lt;&lt;sum + t&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":355,"excerpt":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个整数数组 1, 2,…, ，它的所有元素都是不同的。</p>\r\n<p>首先，要求你在数组中再插入一个整数 an+1 。 an +1 不应等于 a1, a2,…,\r\nan中的任何一个。</p>\r\n<p>然后，你必须使数组中的所有元素相等。一开始，你选择一个<strong>正</strong>整数\r\nx。在一次操作中，你将 x 恰好加到数组的一个元素上。<strong>注意， x\r\n在所有操作中都是一样的</strong>。</p>\r\n<p>选择 +1 和 x 后，使所有元素相等的最小操作次数是多少？</p>","more":"<h1 id=\"题解\">题解：</h1>\r\n<p>容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于\r\n∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖)\r\n（mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。</p>\r\n<p>可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void slove()&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int mx = -INF;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        mx = max(mx,a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) d[i] = mx - a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int gd = 0;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) gd = __gcd(d[i],gd);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!gd) &#123;cout&lt;&lt;1&lt;&lt;endl;return ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll sum = 0;</span><br><span class=\"line\">    set&lt;int&gt; S;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);</span><br><span class=\"line\">    int t = 1;</span><br><span class=\"line\">    while(1) if(S.count(t)) t++;else break;</span><br><span class=\"line\">    cout&lt;&lt;sum + t&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题3","date":"2024-08-14T11:38:14.000Z","_content":"## 题意：\n\n对一个数组的所有非空子区间，计算这个公式$$w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus a_j $$的和。\n\n<!--more-->\n\n## 题解：\n\n非常经典的题目，看见了就再巩固一下。\n\n1. 拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\\lceil log_2mx\\rceil$个数组。计算每一位的贡献。\n\n当拆位后原式子会变为这样的\n$$\nallW = \\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil log_2mx\\rceil}cnt(a_{i-x} != a_{x})\n$$\n这个复杂度仍然是爆炸的，因此需要继续优化\n\n很容易想到的一个优化就是，对于$$a_i \\oplus a_j$$他是满足交换律的，即$$a_i \\oplus a_j = a_j \\oplus a_i$$因此我们仅需要计算单边值即可（然后乘2。\n\n因此将原有的式子改写$$w =2 \\times (\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) $$虽然对于$$a_i$$本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。\n\n再转头考虑所有子区间的问题，一个数组的所有子区间显然是$$n^2$$级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为$$i\\times (n-j+1)$$（下标从1开始），则对任意i,j，其贡献值为以下公式\n$$\nw(bt,{i,j}) = (i\\times (n-j+1) * (1<<bt) * (bit(x,a_i)\\not=bit(x,a_j))\n$$\n施展数学的神奇魔法！\n\n提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算$$a_j$$ 与$$a_i|i<j$$的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。\n\n最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。\n\n```cpp\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n\n    ll ans = 0;\n    for(int bt = 0;bt <=29;bt++) {\n        ll s1=0,s2 =0;\n        for(int i=1;i<=n;i++) {\n            if(a[i] >>bt&1) {\n                ans = (ans + s2 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s1 += i;\n                s1 %= MOD;\n            }\n            else {\n                ans = (ans + s1 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s2 += i;\n                s2 %= MOD;\n            }\n        }\n    }\n    cout<<(2ll * ans)%MOD<<endl;\n}\n```\n\n不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。","source":"_posts/状态转移习题3.md","raw":"---\ntitle: 状态转移习题3\ndate: 2024-08-14 19:38:14\ntags: [算法, 状态转移, 异或问题]\ncategories: \n\t- 算法\n\t- 状态转移\n\t- 状态转移中的异或问题\n---\n## 题意：\n\n对一个数组的所有非空子区间，计算这个公式$$w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus a_j $$的和。\n\n<!--more-->\n\n## 题解：\n\n非常经典的题目，看见了就再巩固一下。\n\n1. 拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\\lceil log_2mx\\rceil$个数组。计算每一位的贡献。\n\n当拆位后原式子会变为这样的\n$$\nallW = \\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil log_2mx\\rceil}cnt(a_{i-x} != a_{x})\n$$\n这个复杂度仍然是爆炸的，因此需要继续优化\n\n很容易想到的一个优化就是，对于$$a_i \\oplus a_j$$他是满足交换律的，即$$a_i \\oplus a_j = a_j \\oplus a_i$$因此我们仅需要计算单边值即可（然后乘2。\n\n因此将原有的式子改写$$w =2 \\times (\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) $$虽然对于$$a_i$$本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。\n\n再转头考虑所有子区间的问题，一个数组的所有子区间显然是$$n^2$$级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为$$i\\times (n-j+1)$$（下标从1开始），则对任意i,j，其贡献值为以下公式\n$$\nw(bt,{i,j}) = (i\\times (n-j+1) * (1<<bt) * (bit(x,a_i)\\not=bit(x,a_j))\n$$\n施展数学的神奇魔法！\n\n提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算$$a_j$$ 与$$a_i|i<j$$的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。\n\n最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。\n\n```cpp\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n\n    ll ans = 0;\n    for(int bt = 0;bt <=29;bt++) {\n        ll s1=0,s2 =0;\n        for(int i=1;i<=n;i++) {\n            if(a[i] >>bt&1) {\n                ans = (ans + s2 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s1 += i;\n                s1 %= MOD;\n            }\n            else {\n                ans = (ans + s1 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s2 += i;\n                s2 %= MOD;\n            }\n        }\n    }\n    cout<<(2ll * ans)%MOD<<endl;\n}\n```\n\n不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。","slug":"状态转移习题3","published":1,"updated":"2024-08-14T13:39:25.704Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6p000tcgwv6ze03nfr","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>对一个数组的所有非空子区间，计算这个公式<span\r\nclass=\"math display\">\\[w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus\r\na_j \\]</span>的和。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>非常经典的题目，看见了就再巩固一下。</p>\r\n<ol type=\"1\">\r\n<li>拆位，\r\n对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。\r\n即将整个数组拆分为<span class=\"math inline\">\\(\\lceil\r\nlog_2mx\\rceil\\)</span>个数组。计算每一位的贡献。</li>\r\n</ol>\r\n<p>当拆位后原式子会变为这样的 <span class=\"math display\">\\[\r\nallW =\r\n\\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil\r\nlog_2mx\\rceil}cnt(a_{i-x} != a_{x})\r\n\\]</span> 这个复杂度仍然是爆炸的，因此需要继续优化</p>\r\n<p>很容易想到的一个优化就是，对于<span class=\"math display\">\\[a_i \\oplus\r\na_j\\]</span>他是满足交换律的，即<span class=\"math display\">\\[a_i \\oplus\r\na_j = a_j \\oplus a_i\\]</span>因此我们仅需要计算单边值即可（然后乘2。</p>\r\n<p>因此将原有的式子改写<span class=\"math display\">\\[w =2 \\times\r\n(\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) \\]</span>虽然对于<span\r\nclass=\"math display\">\\[a_i\\]</span>本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。</p>\r\n<p>再转头考虑所有子区间的问题，一个数组的所有子区间显然是<span\r\nclass=\"math display\">\\[n^2\\]</span>级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为<span\r\nclass=\"math display\">\\[i\\times\r\n(n-j+1)\\]</span>（下标从1开始），则对任意i,j，其贡献值为以下公式 <span\r\nclass=\"math display\">\\[\r\nw(bt,{i,j}) = (i\\times (n-j+1) * (1&lt;&lt;bt) *\r\n(bit(x,a_i)\\not=bit(x,a_j))\r\n\\]</span> 施展数学的神奇魔法！</p>\r\n<p>提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算<span\r\nclass=\"math display\">\\[a_j\\]</span> 与<span\r\nclass=\"math display\">\\[a_i|i&lt;j\\]</span>的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。</p>\r\n<p>最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> bt = <span class=\"number\">0</span>;bt &lt;=<span class=\"number\">29</span>;bt++) &#123;</span><br><span class=\"line\">        ll s1=<span class=\"number\">0</span>,s2 =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt;&gt;bt&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = (ans + s2 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s1 += i;</span><br><span class=\"line\">                s1 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = (ans + s1 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s2 += i;</span><br><span class=\"line\">                s2 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"number\">2ll</span> * ans)%MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。</p>\r\n","length":705,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>对一个数组的所有非空子区间，计算这个公式<span\r\nclass=\"math display\">\\[w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus\r\na_j \\]</span>的和。</p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>非常经典的题目，看见了就再巩固一下。</p>\r\n<ol type=\"1\">\r\n<li>拆位，\r\n对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。\r\n即将整个数组拆分为<span class=\"math inline\">\\(\\lceil\r\nlog_2mx\\rceil\\)</span>个数组。计算每一位的贡献。</li>\r\n</ol>\r\n<p>当拆位后原式子会变为这样的 <span class=\"math display\">\\[\r\nallW =\r\n\\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil\r\nlog_2mx\\rceil}cnt(a_{i-x} != a_{x})\r\n\\]</span> 这个复杂度仍然是爆炸的，因此需要继续优化</p>\r\n<p>很容易想到的一个优化就是，对于<span class=\"math display\">\\[a_i \\oplus\r\na_j\\]</span>他是满足交换律的，即<span class=\"math display\">\\[a_i \\oplus\r\na_j = a_j \\oplus a_i\\]</span>因此我们仅需要计算单边值即可（然后乘2。</p>\r\n<p>因此将原有的式子改写<span class=\"math display\">\\[w =2 \\times\r\n(\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) \\]</span>虽然对于<span\r\nclass=\"math display\">\\[a_i\\]</span>本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。</p>\r\n<p>再转头考虑所有子区间的问题，一个数组的所有子区间显然是<span\r\nclass=\"math display\">\\[n^2\\]</span>级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为<span\r\nclass=\"math display\">\\[i\\times\r\n(n-j+1)\\]</span>（下标从1开始），则对任意i,j，其贡献值为以下公式 <span\r\nclass=\"math display\">\\[\r\nw(bt,{i,j}) = (i\\times (n-j+1) * (1&lt;&lt;bt) *\r\n(bit(x,a_i)\\not=bit(x,a_j))\r\n\\]</span> 施展数学的神奇魔法！</p>\r\n<p>提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算<span\r\nclass=\"math display\">\\[a_j\\]</span> 与<span\r\nclass=\"math display\">\\[a_i|i&lt;j\\]</span>的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。</p>\r\n<p>最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> bt = <span class=\"number\">0</span>;bt &lt;=<span class=\"number\">29</span>;bt++) &#123;</span><br><span class=\"line\">        ll s1=<span class=\"number\">0</span>,s2 =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt;&gt;bt&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = (ans + s2 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s1 += i;</span><br><span class=\"line\">                s1 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = (ans + s1 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s2 += i;</span><br><span class=\"line\">                s2 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"number\">2ll</span> * ans)%MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。</p>"},{"title":"状态转移习题4","date":"2024-08-14T11:41:55.000Z","_content":"## 题意：\n\n给定m条线段，求将1-n覆盖两次的所有方案数\n\n<!--more-->\n\n## 题解：\n\n离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。\n\n个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。\n\n状态表示这样设计：$$dpi,j,k$$表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。\n\n之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    dp[0][0][0] = 1;\n    for(int i=1;i<=m;i++) {\n        for(int ii=0;ii<i;ii++) {\n            for(int j=200;j;j--) {\n                for(int k = 200;k;k--)\n                    dp[i][j][k] = dp[ii][j][k];\n            }\n            for(int j=200;~j;j--) {\n                for(int k = 200;~k;k--) {\n                    if(mp[segs[i].x] <= j+1) {\n                        if(mp[segs[i].x] > k+1) {\n                            dp[i][max(mp[segs[i].y], j)][k] =\n                                (dp[i][max(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][k]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"!\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<k<<' '<<dp[i][max(mp[segs[i].y], j)][k]<<nline;\n                            // }\n                        }\n                        else {\n                            dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] =\n                                (dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"?\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<max(k,min(j,mp[segs[i].y]))<<' '<<\n                            //         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]<<nline;\n                            // }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<dp[m][mp[n]][mp[n]]<<endl;\n}\n```\n\n这段代码中显然有一个很严重的问题：时间复杂度为$$1.6e^{9}$$略微有点超出复杂度\n\n其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。\n\n时间如何优化？\n\n首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f\\[i]\\[j][k] += f\\[i - 1]\\[j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        segs[i].x--;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    for(int i=1;i<=m;i++) {\n        segs[i].x = mp[segs[i].x];\n        segs[i].y = mp[segs[i].y];\n    }\n\n    f[0][0][0] = 1;\n    for (int k = 1; k <= m; k++) {\n        for (int i = 0; i <= mp[n]; i++) {\n            for (int j = i; j <= mp[n]; j++) {\n                if (f[k - 1][i][j] == 0) {\n                    continue;\n                }\n                f[k][i][j] += f[k - 1][i][j];\n                f[k][i][j] %=MOD;\n                if (segs[k].x <= i) {\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]+=f[k - 1][i][j];\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]%=MOD;\n                }\n            }\n        }\n    }\n\n    cout<<f[m][mp[n]][mp[n]]% MOD<<endl;\n}\n```\n","source":"_posts/状态转移习题4.md","raw":"---\ntitle: 状态转移习题4\ndate: 2024-08-14 19:41:55\ntags: [算法, 状态转移, 离散化]\ncategories: \n\t- 算法\n\t- 状态转移\n\t- 复杂状态转移与优化\n---\n## 题意：\n\n给定m条线段，求将1-n覆盖两次的所有方案数\n\n<!--more-->\n\n## 题解：\n\n离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。\n\n个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。\n\n状态表示这样设计：$$dpi,j,k$$表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。\n\n之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    dp[0][0][0] = 1;\n    for(int i=1;i<=m;i++) {\n        for(int ii=0;ii<i;ii++) {\n            for(int j=200;j;j--) {\n                for(int k = 200;k;k--)\n                    dp[i][j][k] = dp[ii][j][k];\n            }\n            for(int j=200;~j;j--) {\n                for(int k = 200;~k;k--) {\n                    if(mp[segs[i].x] <= j+1) {\n                        if(mp[segs[i].x] > k+1) {\n                            dp[i][max(mp[segs[i].y], j)][k] =\n                                (dp[i][max(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][k]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"!\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<k<<' '<<dp[i][max(mp[segs[i].y], j)][k]<<nline;\n                            // }\n                        }\n                        else {\n                            dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] =\n                                (dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"?\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<max(k,min(j,mp[segs[i].y]))<<' '<<\n                            //         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]<<nline;\n                            // }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<dp[m][mp[n]][mp[n]]<<endl;\n}\n```\n\n这段代码中显然有一个很严重的问题：时间复杂度为$$1.6e^{9}$$略微有点超出复杂度\n\n其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。\n\n时间如何优化？\n\n首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f\\[i]\\[j][k] += f\\[i - 1]\\[j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        segs[i].x--;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    for(int i=1;i<=m;i++) {\n        segs[i].x = mp[segs[i].x];\n        segs[i].y = mp[segs[i].y];\n    }\n\n    f[0][0][0] = 1;\n    for (int k = 1; k <= m; k++) {\n        for (int i = 0; i <= mp[n]; i++) {\n            for (int j = i; j <= mp[n]; j++) {\n                if (f[k - 1][i][j] == 0) {\n                    continue;\n                }\n                f[k][i][j] += f[k - 1][i][j];\n                f[k][i][j] %=MOD;\n                if (segs[k].x <= i) {\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]+=f[k - 1][i][j];\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]%=MOD;\n                }\n            }\n        }\n    }\n\n    cout<<f[m][mp[n]][mp[n]]% MOD<<endl;\n}\n```\n","slug":"状态转移习题4","published":1,"updated":"2024-08-14T13:39:29.254Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6p000vcgwv2nlhcl7z","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>给定m条线段，求将1-n覆盖两次的所有方案数</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。</p>\r\n<p>个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。</p>\r\n<p>状态表示这样设计：<span\r\nclass=\"math display\">\\[dpi,j,k\\]</span>表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。</p>\r\n<p>之后可以根据segs[i].x\r\n是否小于两个前缀长度做转移了。暴力转移code如下</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=<span class=\"number\">0</span>;ii&lt;i;ii++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;k;k--)</span><br><span class=\"line\">                    dp[i][j][k] = dp[ii][j][k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;~j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;~k;k--) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(mp[segs[i].x] &lt;= j<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(mp[segs[i].x] &gt; k<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][k] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][k]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;!&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][max(mp[segs[i].y], j)][k]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;?&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;max(k,min(j,mp[segs[i].y]))&lt;&lt;&#x27; &#x27;&lt;&lt;</span></span><br><span class=\"line\">                            <span class=\"comment\">//         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;dp[m][mp[n]][mp[n]]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这段代码中显然有一个很严重的问题：时间复杂度为<span\r\nclass=\"math display\">\\[1.6e^{9}\\]</span>略微有点超出复杂度</p>\r\n<p>其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。</p>\r\n<p>时间如何优化？</p>\r\n<p>首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f[i][j][k]\r\n+= f[i -\r\n1][j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        segs[i].x--;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        segs[i].x = mp[segs[i].x];</span><br><span class=\"line\">        segs[i].y = mp[segs[i].y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= m; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= mp[n]; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= mp[n]; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f[k - <span class=\"number\">1</span>][i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                f[k][i][j] += f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                f[k][i][j] %=MOD;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (segs[k].x &lt;= i) &#123;</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]+=f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]%=MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;f[m][mp[n]][mp[n]]% MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1004,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>给定m条线段，求将1-n覆盖两次的所有方案数</p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。</p>\r\n<p>个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。</p>\r\n<p>状态表示这样设计：<span\r\nclass=\"math display\">\\[dpi,j,k\\]</span>表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。</p>\r\n<p>之后可以根据segs[i].x\r\n是否小于两个前缀长度做转移了。暴力转移code如下</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=<span class=\"number\">0</span>;ii&lt;i;ii++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;k;k--)</span><br><span class=\"line\">                    dp[i][j][k] = dp[ii][j][k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;~j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;~k;k--) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(mp[segs[i].x] &lt;= j<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(mp[segs[i].x] &gt; k<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][k] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][k]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;!&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][max(mp[segs[i].y], j)][k]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;?&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;max(k,min(j,mp[segs[i].y]))&lt;&lt;&#x27; &#x27;&lt;&lt;</span></span><br><span class=\"line\">                            <span class=\"comment\">//         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;dp[m][mp[n]][mp[n]]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这段代码中显然有一个很严重的问题：时间复杂度为<span\r\nclass=\"math display\">\\[1.6e^{9}\\]</span>略微有点超出复杂度</p>\r\n<p>其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。</p>\r\n<p>时间如何优化？</p>\r\n<p>首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f[i][j][k]\r\n+= f[i -\r\n1][j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        segs[i].x--;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        segs[i].x = mp[segs[i].x];</span><br><span class=\"line\">        segs[i].y = mp[segs[i].y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= m; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= mp[n]; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= mp[n]; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f[k - <span class=\"number\">1</span>][i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                f[k][i][j] += f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                f[k][i][j] %=MOD;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (segs[k].x &lt;= i) &#123;</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]+=f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]%=MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;f[m][mp[n]][mp[n]]% MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估","date":"2024-08-14T11:41:55.000Z","_content":"\n{% pdf http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf 3000px}","source":"_posts/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估.md","raw":"---\ntitle: 由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估\ndate: 2024-08-14 19:41:55\ntags: [信息安全, 加密算法, Miracl, ECC]\ncategories: \n\t- 学术\n\t- 综述\n---\n\n{% pdf http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf 3000px}","slug":"由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估","published":1,"updated":"2024-08-15T02:26:17.091Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc6q000ycgwvhb9l04fa","content":"<p><div class=\"pdfobject-container\" data-target=\"http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\" data-height=\"3000px}</p>\"></div>","length":40,"excerpt":"","more":"<p><div class=\"pdfobject-container\" data-target=\"http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\" data-height=\"3000px}</p>\"></div>"},{"title":"字符串","date":"2024-08-14T11:37:01.000Z","_content":"# 题意：\n\n给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。\n\n# 题解：\n\n子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。\n\n子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt\\[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。\n\n这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。\n\n<!--more-->\n\n```cpp\nvoid get_next(){\n    for(int i=n;i>=0;i--){\n        for(int j=0;j<26;j++){\n            if(i==n) nxt[i][j]=n;\n            else nxt[i][j]=nxt[i+1][j];\n        }\n        if(i!=n) nxt[i][s[i]-'A']=i;\n    }\n}\n\nint get_pos(int st,string s){\n    int first=1;\n    for(auto ch:s){\n        if(first) st=nxt[st][ch-'A'];\n        else st=nxt[st+1][ch-'A'];\n        first=0;\n        if(st==n) return st;\n    }\n    return st;\n}\n\nvoid slove(){\n    cin>>n>>k>>s;\n    get_next();\n    string ac=\"ACCEPT\",wa=\"WA\";\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        int r1=get_pos(i,ac),r2=get_pos(i,wa);\n        r1=max(r1,i+k-1);\n        ans=ans+max(r2-r1,0ll);\n    }\n    cout<<ans<<endl;\n}\n```\n\n","source":"_posts/字符串习题1.md","raw":"---\ntitle: 字符串\ndate: 2024-08-14 19:37:01\ntags: [算法, 子序列自动机]\ncategories: \n\t- 算法\n\t- 字符串\n\t- 子序列自动机\n---\n# 题意：\n\n给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。\n\n# 题解：\n\n子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。\n\n子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt\\[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。\n\n这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。\n\n<!--more-->\n\n```cpp\nvoid get_next(){\n    for(int i=n;i>=0;i--){\n        for(int j=0;j<26;j++){\n            if(i==n) nxt[i][j]=n;\n            else nxt[i][j]=nxt[i+1][j];\n        }\n        if(i!=n) nxt[i][s[i]-'A']=i;\n    }\n}\n\nint get_pos(int st,string s){\n    int first=1;\n    for(auto ch:s){\n        if(first) st=nxt[st][ch-'A'];\n        else st=nxt[st+1][ch-'A'];\n        first=0;\n        if(st==n) return st;\n    }\n    return st;\n}\n\nvoid slove(){\n    cin>>n>>k>>s;\n    get_next();\n    string ac=\"ACCEPT\",wa=\"WA\";\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        int r1=get_pos(i,ac),r2=get_pos(i,wa);\n        r1=max(r1,i+k-1);\n        ans=ans+max(r2-r1,0ll);\n    }\n    cout<<ans<<endl;\n}\n```\n\n","slug":"字符串习题1","published":1,"updated":"2024-08-14T13:39:05.118Z","comments":1,"layout":"post","photos":[],"_id":"clzuntc79004ncgwvfvw8eqf9","content":"<h1 id=\"题意\">题意：</h1>\r\n<p>给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。</p>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。</p>\r\n<p>子序列自动机的基本概念是用二维数组保存对于i位置\r\nj字符第一次出现的位置为nxt[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。</p>\r\n<p>这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">26</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==n) nxt[i][j]=n;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nxt[i][j]=nxt[i<span class=\"number\">+1</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=n) nxt[i][s[i]-<span class=\"string\">&#x27;A&#x27;</span>]=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pos</span><span class=\"params\">(<span class=\"type\">int</span> st,string s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> first=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> ch:s)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first) st=nxt[st][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> st=nxt[st<span class=\"number\">+1</span>][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        first=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st==n) <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">get_next</span>();</span><br><span class=\"line\">    string ac=<span class=\"string\">&quot;ACCEPT&quot;</span>,wa=<span class=\"string\">&quot;WA&quot;</span>;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> r1=<span class=\"built_in\">get_pos</span>(i,ac),r2=<span class=\"built_in\">get_pos</span>(i,wa);</span><br><span class=\"line\">        r1=<span class=\"built_in\">max</span>(r1,i+k<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ans=ans+<span class=\"built_in\">max</span>(r2-r1,<span class=\"number\">0ll</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":310,"excerpt":"<h1 id=\"题意\">题意：</h1>\r\n<p>给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。</p>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。</p>\r\n<p>子序列自动机的基本概念是用二维数组保存对于i位置\r\nj字符第一次出现的位置为nxt[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。</p>\r\n<p>这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">26</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==n) nxt[i][j]=n;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nxt[i][j]=nxt[i<span class=\"number\">+1</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=n) nxt[i][s[i]-<span class=\"string\">&#x27;A&#x27;</span>]=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pos</span><span class=\"params\">(<span class=\"type\">int</span> st,string s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> first=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> ch:s)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first) st=nxt[st][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> st=nxt[st<span class=\"number\">+1</span>][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        first=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st==n) <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">get_next</span>();</span><br><span class=\"line\">    string ac=<span class=\"string\">&quot;ACCEPT&quot;</span>,wa=<span class=\"string\">&quot;WA&quot;</span>;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> r1=<span class=\"built_in\">get_pos</span>(i,ac),r2=<span class=\"built_in\">get_pos</span>(i,wa);</span><br><span class=\"line\">        r1=<span class=\"built_in\">max</span>(r1,i+k<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ans=ans+<span class=\"built_in\">max</span>(r2-r1,<span class=\"number\">0ll</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"clzuntc6b0001cgwv4dwtew8k","category_id":"clzuntc6f0004cgwvguri9zbq","_id":"clzuntc6r0010cgwvbym0dhj6"},{"post_id":"clzuntc6b0001cgwv4dwtew8k","category_id":"clzuntc6o000qcgwv4lldcl0a","_id":"clzuntc6r0013cgwv39235qq8"},{"post_id":"clzuntc6k000ecgwvdtwy9luv","category_id":"clzuntc6f0004cgwvguri9zbq","_id":"clzuntc6s0017cgwvgae74g7b"},{"post_id":"clzuntc6k000ecgwvdtwy9luv","category_id":"clzuntc6r000zcgwvdm3mgpc8","_id":"clzuntc6s001acgwvequecins"},{"post_id":"clzuntc6l000icgwv2t46c1on","category_id":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc6u001kcgwved2d8044"},{"post_id":"clzuntc6l000icgwv2t46c1on","category_id":"clzuntc6t001ccgwv7rj2czgc","_id":"clzuntc6u001ncgwvh8msekba"},{"post_id":"clzuntc6m000kcgwv3s148zsh","category_id":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc6u001qcgwvcs6tebhg"},{"post_id":"clzuntc6m000kcgwv3s148zsh","category_id":"clzuntc6t001ccgwv7rj2czgc","_id":"clzuntc6v001tcgwv5glxacl0"},{"post_id":"clzuntc6o000pcgwv2o3o09xf","category_id":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc6w0022cgwv55lhgxjj"},{"post_id":"clzuntc6o000pcgwv2o3o09xf","category_id":"clzuntc6v001vcgwv0gndfhny","_id":"clzuntc6w0024cgwv7n3bg7fh"},{"post_id":"clzuntc6p000scgwv1jndchhx","category_id":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc6w0027cgwv87h3cmlj"},{"post_id":"clzuntc6p000scgwv1jndchhx","category_id":"clzuntc6v001vcgwv0gndfhny","_id":"clzuntc6w0029cgwva26xfrpf"},{"post_id":"clzuntc6e0003cgwvh0bh8wto","category_id":"clzuntc6f0004cgwvguri9zbq","_id":"clzuntc6z002ocgwv2ksagmnq"},{"post_id":"clzuntc6e0003cgwvh0bh8wto","category_id":"clzuntc6r0015cgwv7q81gd2r","_id":"clzuntc6z002scgwv3290bkcw"},{"post_id":"clzuntc6e0003cgwvh0bh8wto","category_id":"clzuntc6y002hcgwv9gncadl4","_id":"clzuntc6z002tcgwve6gi1o72"},{"post_id":"clzuntc6l000fcgwv3n2jdhwi","category_id":"clzuntc6f0004cgwvguri9zbq","_id":"clzuntc6z002wcgwvck8gfcrg"},{"post_id":"clzuntc6l000fcgwv3n2jdhwi","category_id":"clzuntc6s0018cgwv5g5ihuf4","_id":"clzuntc70002xcgwv1z5rh6rr"},{"post_id":"clzuntc6l000fcgwv3n2jdhwi","category_id":"clzuntc6y002lcgwv69h2h6mm","_id":"clzuntc70002zcgwv8qcpf5tr"},{"post_id":"clzuntc6h0007cgwv7rpxa0d9","category_id":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc700031cgwvc7vnaalg"},{"post_id":"clzuntc6h0007cgwv7rpxa0d9","category_id":"clzuntc6t001ccgwv7rj2czgc","_id":"clzuntc700033cgwv86tickum"},{"post_id":"clzuntc6h0007cgwv7rpxa0d9","category_id":"clzuntc6z002pcgwvct9khw4h","_id":"clzuntc710035cgwv58ht69rb"},{"post_id":"clzuntc6n000ocgwv3guqfg4w","category_id":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc710037cgwv5uotddck"},{"post_id":"clzuntc6n000ocgwv3guqfg4w","category_id":"clzuntc6u001ocgwvgbl961ma","_id":"clzuntc71003bcgwv3qlsgfmk"},{"post_id":"clzuntc6n000ocgwv3guqfg4w","category_id":"clzuntc6z002ucgwv5hez2p2q","_id":"clzuntc71003dcgwv8j69fdb8"},{"post_id":"clzuntc6i0009cgwvf32v1dus","category_id":"clzuntc6n000mcgwv3m9s3mi7","_id":"clzuntc72003hcgwvbmnj6oao"},{"post_id":"clzuntc6i0009cgwvf32v1dus","category_id":"clzuntc6u001rcgwvay1iawy4","_id":"clzuntc72003jcgwv3kfg0pmh"},{"post_id":"clzuntc6i0009cgwvf32v1dus","category_id":"clzuntc70002ycgwv5gtkemg3","_id":"clzuntc72003ncgwv6ax2f84k"},{"post_id":"clzuntc6p000tcgwv6ze03nfr","category_id":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc72003ocgwvecon881o"},{"post_id":"clzuntc6p000tcgwv6ze03nfr","category_id":"clzuntc6v001vcgwv0gndfhny","_id":"clzuntc72003qcgwvb4522dcn"},{"post_id":"clzuntc6p000tcgwv6ze03nfr","category_id":"clzuntc700032cgwv0br52y8p","_id":"clzuntc72003scgwvglyw9kc3"},{"post_id":"clzuntc6p000vcgwv2nlhcl7z","category_id":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc73003vcgwv0jf15cwn"},{"post_id":"clzuntc6p000vcgwv2nlhcl7z","category_id":"clzuntc6v001vcgwv0gndfhny","_id":"clzuntc73003wcgwvdm4n1gg0"},{"post_id":"clzuntc6p000vcgwv2nlhcl7z","category_id":"clzuntc710039cgwv6ydo12zy","_id":"clzuntc73003ycgwve2noegq1"},{"post_id":"clzuntc6q000ycgwvhb9l04fa","category_id":"clzuntc6x002ccgwve7ey6f6e","_id":"clzuntc730040cgwvfqsag3h7"},{"post_id":"clzuntc6q000ycgwvhb9l04fa","category_id":"clzuntc71003fcgwv71tw50d1","_id":"clzuntc730043cgwv7ewj30k9"},{"post_id":"clzuntc6i000bcgwvd05r774v","category_id":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc730044cgwv7geh86x8"},{"post_id":"clzuntc6i000bcgwvd05r774v","category_id":"clzuntc6x002ecgwv9jetehwk","_id":"clzuntc740046cgwvg26bauuo"},{"post_id":"clzuntc6i000bcgwvd05r774v","category_id":"clzuntc72003mcgwv253bfe2e","_id":"clzuntc740047cgwv1z3v3m4l"},{"post_id":"clzuntc79004ncgwvfvw8eqf9","category_id":"clzuntc6l000gcgwv55w0h316","_id":"clzuntc7a004tcgwv8j1zdzf6"},{"post_id":"clzuntc79004ncgwvfvw8eqf9","category_id":"clzuntc79004pcgwv7ulea9fa","_id":"clzuntc7a004ucgwvfrv40k7d"},{"post_id":"clzuntc79004ncgwvfvw8eqf9","category_id":"clzuntc7a004rcgwvb6xw30d4","_id":"clzuntc7a004vcgwvbeey9jte"}],"PostTag":[{"post_id":"clzuntc6b0001cgwv4dwtew8k","tag_id":"clzuntc6g0005cgwv7fb0cq7o","_id":"clzuntc6m000jcgwv40dddmp8"},{"post_id":"clzuntc6b0001cgwv4dwtew8k","tag_id":"clzuntc6j000dcgwvfte736o3","_id":"clzuntc6m000lcgwv53xqep6z"},{"post_id":"clzuntc6e0003cgwvh0bh8wto","tag_id":"clzuntc6l000hcgwv44zngl5d","_id":"clzuntc6q000xcgwv8zudd6rw"},{"post_id":"clzuntc6e0003cgwvh0bh8wto","tag_id":"clzuntc6n000ncgwv969nhsfb","_id":"clzuntc6r0011cgwva75r32gk"},{"post_id":"clzuntc6e0003cgwvh0bh8wto","tag_id":"clzuntc6o000rcgwv99hz4b0m","_id":"clzuntc6r0014cgwvb6ycgf7n"},{"post_id":"clzuntc6h0007cgwv7rpxa0d9","tag_id":"clzuntc6q000wcgwvgdab2qye","_id":"clzuntc6t001bcgwv5l7ndqlj"},{"post_id":"clzuntc6h0007cgwv7rpxa0d9","tag_id":"clzuntc6r0012cgwvezzxdaby","_id":"clzuntc6t001dcgwv7sp6fndr"},{"post_id":"clzuntc6h0007cgwv7rpxa0d9","tag_id":"clzuntc6s0016cgwv5kn3c2wc","_id":"clzuntc6t001fcgwvanvzecrv"},{"post_id":"clzuntc6i0009cgwvf32v1dus","tag_id":"clzuntc6l000hcgwv44zngl5d","_id":"clzuntc6t001icgwvcpq2ecam"},{"post_id":"clzuntc6i0009cgwvf32v1dus","tag_id":"clzuntc6t001ecgwv07rd6wpt","_id":"clzuntc6u001lcgwvfuq55mgv"},{"post_id":"clzuntc6i000bcgwvd05r774v","tag_id":"clzuntc6q000wcgwvgdab2qye","_id":"clzuntc6v001ucgwv1r78bfgr"},{"post_id":"clzuntc6i000bcgwvd05r774v","tag_id":"clzuntc6u001mcgwv3kdh9gh4","_id":"clzuntc6v001wcgwv2tmyc5wx"},{"post_id":"clzuntc6i000bcgwvd05r774v","tag_id":"clzuntc6u001pcgwvdmp37ncv","_id":"clzuntc6v001ycgwv2ehh2ctn"},{"post_id":"clzuntc6k000ecgwvdtwy9luv","tag_id":"clzuntc6v001scgwvhm8hek0g","_id":"clzuntc6w0025cgwvhwp40gy4"},{"post_id":"clzuntc6k000ecgwvdtwy9luv","tag_id":"clzuntc6v001xcgwv70o8f7zn","_id":"clzuntc6w0028cgwv2h4m0636"},{"post_id":"clzuntc6k000ecgwvdtwy9luv","tag_id":"clzuntc6v0020cgwvbh7p9fe0","_id":"clzuntc6x002bcgwv18teck2l"},{"post_id":"clzuntc6l000fcgwv3n2jdhwi","tag_id":"clzuntc6w0023cgwv8hxge6zg","_id":"clzuntc6y002gcgwv1brlgdso"},{"post_id":"clzuntc6l000fcgwv3n2jdhwi","tag_id":"clzuntc6w002acgwv8hsla5wg","_id":"clzuntc6y002icgwvenvr9r96"},{"post_id":"clzuntc6l000fcgwv3n2jdhwi","tag_id":"clzuntc6x002dcgwv38510p4w","_id":"clzuntc6y002kcgwv1xjnbfse"},{"post_id":"clzuntc6l000icgwv2t46c1on","tag_id":"clzuntc6q000wcgwvgdab2qye","_id":"clzuntc6z002ncgwv06uq947t"},{"post_id":"clzuntc6l000icgwv2t46c1on","tag_id":"clzuntc6r0012cgwvezzxdaby","_id":"clzuntc6z002qcgwvfgwleot8"},{"post_id":"clzuntc6m000kcgwv3s148zsh","tag_id":"clzuntc6q000wcgwvgdab2qye","_id":"clzuntc710036cgwvgs5f3mjo"},{"post_id":"clzuntc6m000kcgwv3s148zsh","tag_id":"clzuntc6r0012cgwvezzxdaby","_id":"clzuntc710038cgwv51dzcldr"},{"post_id":"clzuntc6m000kcgwv3s148zsh","tag_id":"clzuntc6z002vcgwvbymk09tp","_id":"clzuntc71003ccgwvdoah17la"},{"post_id":"clzuntc6m000kcgwv3s148zsh","tag_id":"clzuntc700030cgwv1ab9bqsp","_id":"clzuntc71003ecgwvf7z04tof"},{"post_id":"clzuntc6n000ocgwv3guqfg4w","tag_id":"clzuntc6q000wcgwvgdab2qye","_id":"clzuntc72003icgwveil3aitd"},{"post_id":"clzuntc6n000ocgwv3guqfg4w","tag_id":"clzuntc71003acgwvhc3c7n6e","_id":"clzuntc72003kcgwv6mbg35xf"},{"post_id":"clzuntc6o000pcgwv2o3o09xf","tag_id":"clzuntc6q000wcgwvgdab2qye","_id":"clzuntc72003rcgwvb54s9gmz"},{"post_id":"clzuntc6o000pcgwv2o3o09xf","tag_id":"clzuntc72003lcgwv68qxai5s","_id":"clzuntc72003tcgwvct880gkx"},{"post_id":"clzuntc6p000scgwv1jndchhx","tag_id":"clzuntc6q000wcgwvgdab2qye","_id":"clzuntc73003zcgwvdbh532v5"},{"post_id":"clzuntc6p000scgwv1jndchhx","tag_id":"clzuntc72003lcgwv68qxai5s","_id":"clzuntc730041cgwv5y0v00bz"},{"post_id":"clzuntc6p000tcgwv6ze03nfr","tag_id":"clzuntc6q000wcgwvgdab2qye","_id":"clzuntc740049cgwv4eehgmc9"},{"post_id":"clzuntc6p000tcgwv6ze03nfr","tag_id":"clzuntc72003lcgwv68qxai5s","_id":"clzuntc74004acgwvbmj19skv"},{"post_id":"clzuntc6p000tcgwv6ze03nfr","tag_id":"clzuntc740045cgwv28uzbc1t","_id":"clzuntc74004ccgwv27h217xx"},{"post_id":"clzuntc6p000vcgwv2nlhcl7z","tag_id":"clzuntc6q000wcgwvgdab2qye","_id":"clzuntc75004fcgwvfwekclg1"},{"post_id":"clzuntc6p000vcgwv2nlhcl7z","tag_id":"clzuntc72003lcgwv68qxai5s","_id":"clzuntc75004gcgwv6fbifyq2"},{"post_id":"clzuntc6p000vcgwv2nlhcl7z","tag_id":"clzuntc74004dcgwvcd1094su","_id":"clzuntc75004icgwv2efu5y1s"},{"post_id":"clzuntc6q000ycgwvhb9l04fa","tag_id":"clzuntc6l000hcgwv44zngl5d","_id":"clzuntc75004jcgwvg4yja3bw"},{"post_id":"clzuntc6q000ycgwvhb9l04fa","tag_id":"clzuntc74004ecgwvdkxl7pqh","_id":"clzuntc75004kcgwv3tc26yku"},{"post_id":"clzuntc6q000ycgwvhb9l04fa","tag_id":"clzuntc6o000rcgwv99hz4b0m","_id":"clzuntc75004lcgwv6l9h4jc7"},{"post_id":"clzuntc6q000ycgwvhb9l04fa","tag_id":"clzuntc75004hcgwv8j557ttz","_id":"clzuntc75004mcgwvdiztamp9"},{"post_id":"clzuntc79004ncgwvfvw8eqf9","tag_id":"clzuntc6q000wcgwvgdab2qye","_id":"clzuntc7a004qcgwvhw97bz7k"},{"post_id":"clzuntc79004ncgwvfvw8eqf9","tag_id":"clzuntc79004ocgwv759yfzk9","_id":"clzuntc7a004scgwv83j36lug"}],"Tag":[{"name":"Latex","_id":"clzuntc6g0005cgwv7fb0cq7o"},{"name":"图像处理","_id":"clzuntc6j000dcgwvfte736o3"},{"name":"信息安全","_id":"clzuntc6l000hcgwv44zngl5d"},{"name":"软件","_id":"clzuntc6n000ncgwv969nhsfb"},{"name":"Miracl","_id":"clzuntc6o000rcgwv99hz4b0m"},{"name":"算法","_id":"clzuntc6q000wcgwvgdab2qye"},{"name":"思维题","_id":"clzuntc6r0012cgwvezzxdaby"},{"name":"贪心，状态转移","_id":"clzuntc6s0016cgwv5kn3c2wc"},{"name":"数学","_id":"clzuntc6t001ecgwv07rd6wpt"},{"name":"博弈论","_id":"clzuntc6u001mcgwv3kdh9gh4"},{"name":"不等式","_id":"clzuntc6u001pcgwvdmp37ncv"},{"name":"开发","_id":"clzuntc6v001scgwvhm8hek0g"},{"name":"文档","_id":"clzuntc6v001xcgwv70o8f7zn"},{"name":"学校","_id":"clzuntc6v0020cgwvbh7p9fe0"},{"name":"Typora","_id":"clzuntc6w0023cgwv8hxge6zg"},{"name":"Markdown","_id":"clzuntc6w002acgwv8hsla5wg"},{"name":"随笔","_id":"clzuntc6x002dcgwv38510p4w"},{"name":"坐标系转换","_id":"clzuntc6z002vcgwvbymk09tp"},{"name":"几何问题","_id":"clzuntc700030cgwv1ab9bqsp"},{"name":"树问题，哈希算法","_id":"clzuntc71003acgwvhc3c7n6e"},{"name":"状态转移","_id":"clzuntc72003lcgwv68qxai5s"},{"name":"异或问题","_id":"clzuntc740045cgwv28uzbc1t"},{"name":"离散化","_id":"clzuntc74004dcgwvcd1094su"},{"name":"加密算法","_id":"clzuntc74004ecgwvdkxl7pqh"},{"name":"ECC","_id":"clzuntc75004hcgwv8j557ttz"},{"name":"子序列自动机","_id":"clzuntc79004ocgwv759yfzk9"}]}}