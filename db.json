{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/addtoany.js","path":"js/third-party/addtoany.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/wavedrom.js","path":"js/third-party/tags/wavedrom.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":0},{"_id":"source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":0},{"_id":"source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":0},{"_id":"source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":0},{"_id":"source/images/beian.png","path":"images/beian.png","modified":0,"renderable":0},{"_id":"source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":0},{"_id":"source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":0},{"_id":"source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":0},{"_id":"source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":0},{"_id":"source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":0},{"_id":"source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":0},{"_id":"source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":0},{"_id":"source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":0,"renderable":0},{"_id":"source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":0},{"_id":"source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":0},{"_id":"source/images/qq-contact.png","path":"images/qq-contact.png","modified":0,"renderable":0},{"_id":"source/images/wechat_channel.jpg","path":"images/wechat_channel.jpg","modified":0,"renderable":0},{"_id":"source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":0},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","path":"uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","modified":0,"renderable":0},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","path":"uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/2024武汉ICPC邀请赛VP.md","hash":"05d1161108685b793b9afd548040720da5e95a91","modified":1723697478015},{"_id":"source/404/404.md","hash":"8376757f89e049a3a5685b5fa9539c91713ae513","modified":1723613990887},{"_id":"source/runtime.js","hash":"44cffdad9d8ddd8509a7169356cce35aa141c095","modified":1723798429937},{"_id":"source/about/index.md","hash":"7768e8a05c4eec51618ec4766fe01e964af83c15","modified":1723643469539},{"_id":"source/_posts/2024湖北省赛VP.md","hash":"54eaa6a99357594dc5311f2abde64f2e6fd50562","modified":1723697466767},{"_id":"source/_posts/Latex宏包pgfplots做矩形函数图像.md","hash":"2ae33665d3b6959a0cda695463a815240d90026d","modified":1723642724943},{"_id":"source/_posts/2024江苏CCPC邀请赛-VP.md","hash":"dea64ae3eaa6dc852f2cbe909a8e55f3cb1baf75","modified":1723697474761},{"_id":"source/_posts/2024河南CCPC邀请赛-VP.md","hash":"f7e8d5123052eb19b2bd67d3abcbc00444d42e76","modified":1723697471832},{"_id":"source/_posts/Miracl的配置ForCentos7.md","hash":"14615d5987afb985413cbf71dc7f01ce28ffe67d","modified":1723642728720},{"_id":"source/_posts/Nodejs安装简要建议.md","hash":"3304dfbc52bba040d869ed0a11166f21479c4b53","modified":1723689685517},{"_id":"source/_posts/Xiaobai94.md","hash":"e5ee2b33b2eee25b03f2eda5dc7f2f1a938d0ffd","modified":1723697524681},{"_id":"source/_posts/Xiaobai93D-E.md","hash":"d429c2e43c4142ec1b81e283e442a474d04c79a8","modified":1723697522258},{"_id":"source/_posts/abc353.md","hash":"bc00383714e3875a36ed2158a856571bd78dbc6a","modified":1723697486275},{"_id":"source/_posts/2024黑龙江省赛-VP.md","hash":"5108e8c0afb53f82c8baef6ea7226f93eba7caee","modified":1723697482977},{"_id":"source/_posts/RSA涉及算法与数论知识.md","hash":"7dff17cb7672c0377af29bea3d01a1475bc8670c","modified":1723642736431},{"_id":"source/_posts/abc354.md","hash":"31b463a84461cd23e507e6d1fe0749709e60b3cf","modified":1723697490384},{"_id":"source/_posts/cf-edu165C.md","hash":"227033639ab02e8d6617672a688e199ade9f3579","modified":1723697878784},{"_id":"source/_posts/cf-edu165D.md","hash":"b8e5ae16b118e0c9ec1c17900bbe41f47db311cd","modified":1723642717760},{"_id":"source/_posts/为什么我用Typora——Typora与其他markdown的比较.md","hash":"e673ce8b6cec57ed2c9938b87275a33af259b54b","modified":1723642742327},{"_id":"source/_posts/三种操作系统模拟软件使用手册.md","hash":"55a62f88e91ba3c22a78219edc42b4806c0830cb","modified":1723642739744},{"_id":"source/_posts/luogu蓝桥5_19.md","hash":"c5b46458918c26cd8d7bc570fa836ef276d5789f","modified":1723697515211},{"_id":"source/_posts/数学距离问题1.md","hash":"869e8e6da900e6cc0921f94c610c2ba77750ba72","modified":1723642751945},{"_id":"source/_posts/状态转移习题1.md","hash":"0800a8b4b867afc04b64c70d5677977db61504e0","modified":1723642758757},{"_id":"source/_posts/思维题习题1.md","hash":"59e08f4ab9b2e15029969301e74228501388a190","modified":1723642748223},{"_id":"source/_posts/字符串习题1.md","hash":"c2ba5a4d92e4706d8b41cba1256b756709d55735","modified":1723642745118},{"_id":"source/_posts/状态转移习题3.md","hash":"27d66b4c473e9f7eb306276aa0048289589cb185","modified":1723642765704},{"_id":"source/_posts/树上回文问题.md","hash":"dfd074c9f52e28e0ffe3b4cc206d952909d0261e","modified":1723642754786},{"_id":"source/_posts/状态转移习题4.md","hash":"6fcd363634ac1e626ced2477d2755d4c76eb1a89","modified":1723642769254},{"_id":"source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1723449052550},{"_id":"source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1723449052550},{"_id":"source/images/beian.png","hash":"797721756b99b7841cee366f62ac52a1207cdcb7","modified":1723622021068},{"_id":"source/images/apple-touch-icon.png","hash":"64a9ea04f5bb7fef316fa416a7bf9e5e9489c291","modified":1723611091895},{"_id":"source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1723449052550},{"_id":"source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1723449052551},{"_id":"source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1723449052551},{"_id":"source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1723449052552},{"_id":"source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1723449052551},{"_id":"source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1723449052552},{"_id":"source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1723449052552},{"_id":"source/images/favicon-32x32.png","hash":"8be81b95697df7f526646702889ca5483f51ccad","modified":1723611046142},{"_id":"source/images/logo.svg","hash":"d0ed8b5372385b71b533c985d0a3d84de851dfaf","modified":1723611161346},{"_id":"source/images/favicon-16x16.png","hash":"c3cc1168e2d338fbefc5f8da977a73a7b9a4975c","modified":1723611046112},{"_id":"source/_posts/状态转移习题2.md","hash":"a92936db6b29a809a3aaeeec47e92221aa44e70a","modified":1723642761942},{"_id":"source/_data/languages.yml","hash":"1667bb2fe8dd3a555918496bb9d6ab002b3a7fde","modified":1723799825465},{"_id":"source/_posts/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估.md","hash":"ecd50b1924c7280964f592c34665a4d9c1456d91","modified":1723690718900},{"_id":"source/categories/index.md","hash":"f3f0fd6fd49a65815de30a63f1a2675e6d270469","modified":1723799777808},{"_id":"source/tags/index.md","hash":"008e0978586bfc95819e8dbb86b9e75efcdf1a3c","modified":1723612488261},{"_id":"source/schedule/index.md","hash":"95b3ff5bf09f7e8fe31b55662d015636f60f8f5a","modified":1723637034657},{"_id":"source/_posts/special_subject/MindSpore/MindSpore学习目录.md","hash":"081729a98de192b07988c7c3999d18be9b1fe423","modified":1723881494334},{"_id":"source/_posts/special_subject/MindSpore/Chapters/First_Install.md","hash":"934e50c6c21ab424c3090d47f4b83f04d94162f2","modified":1723798729871},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Concept.md","hash":"e17c77bd55bd02570409be5b139dc37b16ba27ba","modified":1723798726139},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Fourth_DataSet.md","hash":"da46fa6b331fe09dbc5ecbd8da6d04ccdafe47ec","modified":1723798737218},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork.md","hash":"f16149f1a6af77aaf854cfa817d571bf869828d1","modified":1723798733357},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Second_TryMindSpore.md","hash":"23362970948bb8816798fabf2b88965bc5d2bab9","modified":1723798740222},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc.md","hash":"c03644646d64dafbfe5afc6c9e30cde543b046bc","modified":1723798751713},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Seven_ModelTrain.md","hash":"dee4ac57539bbf45e4f70077d1770f26b35af562","modified":1723798742737},{"_id":"source/_posts/special_subject/MindSpore/Chapters/TransformerStructure.md","hash":"d4cd9be5e17970f8197bae4114508212e70eaefb","modified":1723798756882},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Third_Tensor.md","hash":"517f4fe5ef3325aad46f00dd46b2af87e36de77a","modified":1723798754447},{"_id":"source/_posts/special_subject/MindSpore/img/img_workflow.svg","hash":"72228a0fef6f4bcf1a2b7465c54eb9d981999bc8","modified":1717643990000},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"8cfc97916efdc7cb9acfbe3a653e943a97e54de0","modified":1723775696267},{"_id":"node_modules/hexo-theme-next/package.json","hash":"655accf88e80dfdd525042da1d65114b47dcb52a","modified":1723775696042},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"82dc85404bb716360c136059f8b4ead67f46549c","modified":1723775696267},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1723775696044},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1723775696148},{"_id":"node_modules/hexo-theme-next/README.md","hash":"20d3aab17b7d9b7ab537800a5ee932af8438664a","modified":1723775696149},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"7d0f39e8684284a04bb9808521c87fecda8bd131","modified":1723775696269},{"_id":"node_modules/hexo-theme-next/languages/bn.yml","hash":"564bed75da6e05b11dce6164508f97a15e2fb6c2","modified":1723775696269},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"79b37df731c29665dee6cd7c90d278e1edfb6e24","modified":1723775696271},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"ba0fd79a2b1d8db01a034180556061745965ff05","modified":1723775696271},{"_id":"node_modules/hexo-theme-next/languages/eo.yml","hash":"e34bb33ae827bf2f0727088599a73bc64bdad1b0","modified":1723775696272},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"dffc63ef42e1266b88e0acf08994fd17a9908d53","modified":1723775696273},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"f3ffc444599f4ac92d62e9ed00a1490ebc277d70","modified":1723775696274},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"8ac44e58f71a38b7697a2f7f98a6971ed818cb5b","modified":1723775696274},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"929df147f4f17d638b07de5fe52ca13e2549ab1c","modified":1723775696275},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"16d716ecfd748def2f6486ef5a82d0ab7ceb4890","modified":1723775696275},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"543222bfc516aab6c33e8534f807972ecb8943a9","modified":1723775696276},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"d345a303310c8a5f4836c3683f3580f861ebd1b4","modified":1723775696277},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1723775696146},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"3cb3687696635ec71b4ca40c5fc43b56acc8843e","modified":1723775696277},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"c6d8de0ff7d8148d09993257cfd3b7aca755696c","modified":1723775696279},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"70de366e10ea584ba039d40d6b35ac97f93454ad","modified":1723775696278},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"76b8576ce228d540a16b1f0af5af2cce20923194","modified":1723775696278},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"2d712eedf3f60d04d36c3108cf5a12e2a52e875c","modified":1723775696280},{"_id":"node_modules/hexo-theme-next/languages/th.yml","hash":"6829e998b39f8f143e20b276bb1f62d95a29de58","modified":1723775696280},{"_id":"node_modules/hexo-theme-next/languages/tk.yml","hash":"511726054873f6f8d7ce0d2e803f6731de0ddbe7","modified":1723775696281},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"a57e4ed089b893a95f5e1ecff17ce625165f4d46","modified":1723775696281},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"ff537047b4b4c3ca9a7b64fa7f428a9942751eeb","modified":1723775696282},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"7ebcba5e1128784195e4681dffc9d34c4e873fec","modified":1723775696283},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"741d7efe0262c9cdc2c648014b55599665d90f6b","modified":1723775696283},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"4695c87d6b81b3a23d16ad6513d9eaa925f8d8ad","modified":1723775696284},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"88ea50eeb9097ab4a87a44981a102d8594feb064","modified":1723775696284},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"fc0a45112f2dcfc2642404e8934ea32a793c3bd7","modified":1723775696150},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1723775696159},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1723775696153},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1723775696173},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"af6d7570621be760536c216a56d74e40a1cceae2","modified":1723775696183},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1723775696195},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1723775696192},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"12a6631617695504d5cf2a94b57d87bd331bef6f","modified":1723775696045},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1723775696045},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"952449064fcb6a5cefc281b585f9149809f857f1","modified":1723775696191},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"547c62ab14d9e05d2d9116db9048a677fbe1fb6d","modified":1723775696193},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"313637fe3569f98fd926e8cd0fcc75d098eb6e6e","modified":1723775696186},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1723775696162},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1723775696266},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"fbf8232cacf0df87e88e74860be66c9f86018302","modified":1723775696165},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1723775696183},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"d83fb59f02c5e6630a7770401a05c02f6f07358b","modified":1723775696201},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1723775696175},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"7ed1fa981bf4765af092d7b178acbdeeb95d5b20","modified":1723775696170},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1723775696199},{"_id":"node_modules/hexo-theme-next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1723775696164},{"_id":"node_modules/hexo-theme-next/layout/_third-party/addtoany.njk","hash":"ef64c6bfb8540cd874701236b9be47db2496e98e","modified":1723775696151},{"_id":"node_modules/hexo-theme-next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1723775696181},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"dfd7cdd6ba89f8c3deabc27726c7a350cadafd11","modified":1723775696171},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1723775696013},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1723775696192},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1723775696021},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1723775695997},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"2063aaa1db448ebcf7b0fdbbc54d3991a368bbd3","modified":1723775696024},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1723775696032},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1723775696003},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"049b1a0b66563e39f68710bb576a8c7342ae749c","modified":1723775696000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1723775696027},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"ce6bd4054653a4066b19869819a17b568eeee915","modified":1723775696028},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"af3946a595f997eb43d9af87428e4898c9acbc82","modified":1723775696029},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"6281d47c1de98eb38f3aa0f6df29bbb19d412173","modified":1723775696029},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1723775696028},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1723775695987},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1723775695986},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1723775695987},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"1f6aba7820f1fb58b61969485148db21846e1aa9","modified":1723775696014},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1723775696017},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"8d205b7ffdaa9a89bb8f75410507ee1bab230f55","modified":1723775696005},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1723775696023},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1723775696019},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1723775696029},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1723775696031},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1723775696035},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1723775696041},{"_id":"node_modules/hexo-theme-next/scripts/tags/wavedrom.js","hash":"b44dfeeb58b41945d469141787f3dbce4b117d08","modified":1723775696041},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1723775696204},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"bbeae369eaba9a2565fc359a5b79184d21bdd167","modified":1723775696211},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"921a58577f411cf4eb5cfd66db0a241f8f88578c","modified":1723775696239},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1723775696145},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1723775695980},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1723775696202},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"0be2d7a75ffc3d9a963cf89a13bd1b50579f8304","modified":1723775696147},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1723775696244},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1723775696203},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1723775696265},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1723775695993},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1723775695985},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1723775695993},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1723775695995},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1723775696201},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"8e587c086e3cf8687108fbb3241fe1534c3df463","modified":1723775696025},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"adc751f9b63b7a6b4d381506d35a1b3ff4de891f","modified":1723775696032},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"8e2d589585f5270ee90285d3e65b69923c7629d8","modified":1723775696027},{"_id":"node_modules/hexo-theme-next/source/js/sidebar.js","hash":"b3289010a0cb52c525b1395db72bd463424f2f48","modified":1723775696035},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1723775696168},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"f92420649b150703469bba41cbd5c72768beed88","modified":1723775696037},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1723775696169},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1723775696154},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1723775696169},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1723775696179},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1723775696195},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1723775696155},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1723775696159},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1723775696182},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1723775696179},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1723775696192},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1723775696196},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1723775696187},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1723775696189},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"bfff923526d6800218f08dba6ce0bbf5c17755fd","modified":1723775696187},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1723775696189},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1723775696190},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-share.njk","hash":"16696990e4ce65fc8db18c4635082a5d5d06ff07","modified":1723775696190},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1723775696169},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1723775696152},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1723775696177},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"bc5708e38b6070dff0cab6bf9480971017ce4dda","modified":1723775696194},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1723775696154},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1723775696166},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1723775696167},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1723775696161},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1723775696170},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1723775696034},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1723775696179},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"287f57dbdfd23341800a0ff310f3474272b9dcc8","modified":1723775696147},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1723775696181},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1723775696185},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1723775696160},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/umami.njk","hash":"3343750682fbd8535e50f8129be3003ad26015b4","modified":1723775696198},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1723775696197},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1723775696160},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1723775696163},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1723775696163},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1723775696174},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1723775696165},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1723775696176},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1723775696172},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1723775696198},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1723775696174},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1723775696177},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1723775696177},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1723775696152},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1723775696184},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1723775696180},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/wavedrom.njk","hash":"02202bf563fb5eedde2ccad4d6c5b9109d30a703","modified":1723775696199},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"9ec51eb61f7fee612ffc5252f489003a0fa301fc","modified":1723775695995},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1723775696015},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"8300553bf2a1c4bfaec76f2da56465016e9d8058","modified":1723775696007},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"5942feb3f31ed3480bf50b0f5a4a305b5bdca3d6","modified":1723775696037},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"e2b4a9d6b08155735ec336eedc506763d5671821","modified":1723775696040},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1723775695989},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1723775695994},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1723775696025},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1723775695997},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1723775695999},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1723775696003},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1723775696039},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1723775696020},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1723775696015},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1723775696156},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1723775696164},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1723775696173},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1723775696226},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1723775696175},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1723775695996},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"20d5c6aa136bbb55e03906d98ee90ad3fbaa80a7","modified":1723775696247},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","hash":"819f382c561fe5ec23c67cc5fabd63dd1cc22dc1","modified":1723775696001},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"8b4100f316e9924f2410802615107130588d721e","modified":1723775696218},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"879b49f693af0c04c285b2dd0c9cccaf77347b7c","modified":1723775696243},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1723775696265},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"2c800eaab6c613e5d091be2111aaa786641aa0c2","modified":1723775696242},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"7664491542046df9a3887cf40a06e00c0b4086a9","modified":1723775696216},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1723775696253},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1723775696228},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1723775696221},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1723775696217},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1723775696234},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1723775696244},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1723775696222},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1723775696245},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"37be10c413438060fc76ed31ae74d4300c38c5eb","modified":1723775696263},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1723775696261},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1723775696031},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1723775696232},{"_id":"node_modules/hexo-theme-next/source/js/third-party/addtoany.js","hash":"5276c8f78ee562a8965216dc67d762e59cb4a9f2","modified":1723775695982},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"1dbf2c339adcd27026c3a2ded32ee91ce08cea26","modified":1723775696243},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1723775696236},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"9dfe853c901bdc52fc950bacdf15484dbb9bf140","modified":1723775696236},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1723775696208},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"dafc6d23c80d6fe3e55a7711e94210d2479b629a","modified":1723775696205},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"3fbfab591f280e2e7f3b0265901c93bc4bd137ed","modified":1723775696206},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1723775696212},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"e31f6adbb22a451f07e4661cff9a2f12e4e99a36","modified":1723775696209},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1723775696033},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1723775696237},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1723775696214},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"c29a827e82d2820ed8977c92994da73721200fac","modified":1723775696213},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"dc03835e42d82eaf2633cf3b627990ad3e1f5967","modified":1723775696207},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"a92c4eb16bdb7806079467eb022ccf193bb0f794","modified":1723775696208},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1723775696215},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"7ba406f560e3a6646b9254bb670fda696889e1e6","modified":1723775696213},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"f23c53e32d140091b819be2603d1afbbb5d66933","modified":1723775696209},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1723775696237},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"d537c748914ad395319f9cfc91cd5ba96db57e8c","modified":1723775696210},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"6569a6640f79d247a8235b3914772c0e2f99ead2","modified":1723775696208},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1723775696022},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1723775695992},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1723775695984},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1723775696005},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1723775696017},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1723775696022},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1723775695990},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1723775695999},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1723775696036},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1723775696016},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"def07bcc7c17d8a0caad177fb1dd2f3a5e5b3536","modified":1723775696004},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1723775696020},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1723775696040},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1723775696021},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"6bf821310342c5b87a631873e7650a475a0765f1","modified":1723775696024},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1723775695983},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/wavedrom.js","hash":"40dcd10df6edf124088c329346e0cc0bdac74ef1","modified":1723775696042},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1723775696031},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1723775696221},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1723775696002},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"51a97a33879289904cb523ddc2d88b5b0c60fa72","modified":1723775696222},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1723775696262},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1723775696254},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1723775696228},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1723775696225},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"54d12e2c5d9982f7b9e5b23be5133954a8514e9d","modified":1723775696230},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1723775696226},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1723775696255},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1723775696240},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1723775696263},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1723775696229},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"809bab3414b1eb1ae44444eb821126868f764414","modified":1723775696249},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"56d5b7ff73f466c9ae54f7204ae899281295d749","modified":1723775696247},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"1ecfd64507954810b07a9d21fb5305b5378feda0","modified":1723775696249},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"11497388f124bfbb4001495a67d3629a9f618405","modified":1723775696250},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"1191f1bfa5c43e54be8e5b3cc0d802984e161747","modified":1723775696251},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1723775696251},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1723775696250},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"04cf4a69537fc14d3b8904f965d283356853847f","modified":1723775696252},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1723775695998},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1723775696017},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"138f78147bc6bd6005f329ada34dc79b7625542d","modified":1723775696234},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"ebfba158a0a4af3d1dabcacbc58986664de52140","modified":1723775696252},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1723775696219},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1723775696227},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"22cd37bd5df9972d5074710896aba4424ad5161c","modified":1723775696235},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1723775696237},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1723775696239},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1723775696241},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"98d4c20aff0f0fcfe1824017fb06ab21ef0d218e","modified":1723775696245},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1723775696246},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"33dd6ad015dde65fd46f34961655442e8e82b52e","modified":1723775696261},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/wavedrom.styl","hash":"af113411ad9cca7674177be36af8dd399680834d","modified":1723775696264},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"4e967702cf4c637132346bc74ec8854426f1a68c","modified":1723775696231},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1723775696004},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1723775696220},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1723775696231},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1723775696227},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"a3dd3edea9c01b66b28a8367185269b9dcc3bdee","modified":1723775696240},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1723775696259},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1723775696253},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1723775696260},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"7c203ec68c0f54429caf35803dbac85b18540278","modified":1723775696233},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"0847400d8579b0a2dd1bf662c78954c10adf2680","modified":1723775696255},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1723775696256},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"c6a27beb3f741211a14576026f3b4cfc44cc6407","modified":1723775696256},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"46eece42510c2c89bb9209afb0262ad76a4b0b36","modified":1723775696257},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"24752d145c6fb8f5344dca9c7b9640839c02e009","modified":1723775696257},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"c2e354a565c8c1b32bd0ceacc972b17982758b67","modified":1723775696258},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"741566d6ac5f852b5c8dee6a8996b65e48e7c97f","modified":1723775696259},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1723775696260},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f634f94828620e88c3f5a8db56f7944f6ba232b0","modified":1723775696223},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/fold.styl","hash":"42a0b65491ad85438596b3fe0b7f23973e4cef34","modified":1723775696225},{"_id":"source/images/wechat_channel.jpg","hash":"25d7ebd0b18bb44a9013adbe2b6cd82919f4c291","modified":1723623826348},{"_id":"source/images/alipay.jpg","hash":"1d531329226cfd0fde8e936f9019eec57169945b","modified":1723623544434},{"_id":"source/images/wechatpay.jpg","hash":"28bab154ea159faf803c3c832cc7da5eb62c7396","modified":1723623544590},{"_id":"source/images/qq-contact.png","hash":"255274d1b43901c2a5a14daaa540346dc62602c4","modified":1723620583638},{"_id":"source/_posts/special_subject/MindSpore/img/R.jpg","hash":"14958ff3d91f7e600ce92f23424ebc59c7f7e766","modified":1717740026000},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","hash":"ea8a10b275222aa4fe6004ea90dfb8b7619893ca","modified":1723645068416},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","hash":"85ea4d5ef41451cc6d78520f9b8e9c934f3c45f6","modified":1723644997204},{"_id":"public/runtime.js","hash":"ca5276b144e4a246a8ebd3db6202bce69fe937ad","modified":1723811152830},{"_id":"public/baidusitemap.xml","hash":"f9af39a6d1ece46a2e66b7edad5b2db319254062","modified":1723901147971},{"_id":"public/atom.xml","hash":"248a125c19e092398ea05421fbed2f628560081e","modified":1723901147971},{"_id":"public/en/runtime.js","hash":"ca5276b144e4a246a8ebd3db6202bce69fe937ad","modified":1723811152830},{"_id":"public/ja/runtime.js","hash":"ca5276b144e4a246a8ebd3db6202bce69fe937ad","modified":1723811152830},{"_id":"public/ru/runtime.js","hash":"ca5276b144e4a246a8ebd3db6202bce69fe937ad","modified":1723811152830},{"_id":"public/search.xml","hash":"95ebf3a0522c59cf91f80338f09277a0b631ca6d","modified":1723901147971},{"_id":"public/sitemap.xml","hash":"2e417468a193a613c7d367d3e2408508a193bfb2","modified":1723901147971},{"_id":"public/sitemap.txt","hash":"c4d202e574e3791e96d880e4dcc572e52b9f34e8","modified":1723901147971},{"_id":"public/about/index.html","hash":"7ee7219122e346541d4e698af3fa596f704e8900","modified":1723901147971},{"_id":"public/schedule/index.html","hash":"dfa497b1de501b604c3a994c53155f214c8e762f","modified":1723901147971},{"_id":"public/categories/index.html","hash":"dfd4163103edb2336ef96fda90f10cba28398ad6","modified":1723901147971},{"_id":"public/tags/index.html","hash":"41d01658ca44f4ed5a447a97b1995316264ce739","modified":1723901147971},{"_id":"public/404/404.html","hash":"a51ba1adfdfb473dd74002f7212df395e7522353","modified":1723901147971},{"_id":"public/2024/Nodejs安装简要建议/article.html","hash":"ca4b556136263074d45d6a7f30669613080b0228","modified":1723901147971},{"_id":"public/2024/Miracl的配置ForCentos7/article.html","hash":"7a10455128b06d532ef50dc4f3067fb36984b325","modified":1723901147971},{"_id":"public/2024/RSA涉及算法与数论知识/article.html","hash":"65f01261bbdc9033f30d584060b8b34fb6f90e01","modified":1723901147971},{"_id":"public/2024/Latex宏包pgfplots做矩形函数图像/article.html","hash":"eacd3f25beb6cb177f0659117198018cea82c71b","modified":1723901147971},{"_id":"public/2024/special_subject/MindSpore/MindSpore学习目录/article.html","hash":"b643b7f674715bdb950b7dee9f1b3601a8075207","modified":1723901147971},{"_id":"public/2024/special_subject/MindSpore/Chapters/Concept/article.html","hash":"f8ed820609ea234bd9a0bf7b424bfe4a087594d4","modified":1723901147971},{"_id":"public/2024/special_subject/MindSpore/Chapters/First_Install/article.html","hash":"fa7d253c7b5f2e83355a319ad7ee90a85110de1a","modified":1723901147971},{"_id":"public/2024/special_subject/MindSpore/Chapters/Fourth_DataSet/article.html","hash":"e44e87872979b1fba33010317c567e0382ee1ea7","modified":1723901147971},{"_id":"public/2024/special_subject/MindSpore/Chapters/Second_TryMindSpore/article.html","hash":"e12f115647fcab0626c19ea02fd1e097aa35f42a","modified":1723901147971},{"_id":"public/2024/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork/article.html","hash":"7100142e97d3a9784ce85d25c183199da5640e81","modified":1723901147971},{"_id":"public/2024/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc/article.html","hash":"925456a3c3b4990ea2ae47d78dc918d33dd977af","modified":1723901147971},{"_id":"public/2024/special_subject/MindSpore/Chapters/Seven_ModelTrain/article.html","hash":"743ad5cbb1918cf6591826994568d531e99397d3","modified":1723901147971},{"_id":"public/2024/special_subject/MindSpore/Chapters/TransformerStructure/article.html","hash":"4b23535c7ef5a15bc734ebd1ea4a68a362ab94df","modified":1723901147971},{"_id":"public/2024/special_subject/MindSpore/Chapters/Third_Tensor/article.html","hash":"31a2846e7bdb6143261e583bbfa7de6d913d9245","modified":1723901147971},{"_id":"public/2024/2024武汉ICPC邀请赛VP/article.html","hash":"972cd320922a0116b0793ca9ba9ee3575e171386","modified":1723901147971},{"_id":"public/2024/2024江苏CCPC邀请赛-VP/article.html","hash":"631f2fa3b3fbac93a3337c962bbec839204aeef4","modified":1723901147971},{"_id":"public/2024/2024湖北省赛VP/article.html","hash":"0893fdd8856a3eacbfaa849d8423a81a9ed76825","modified":1723901147971},{"_id":"public/2024/2024河南CCPC邀请赛-VP/article.html","hash":"f7a7272f2c35be41d2c1f5c73adc18ca8f4dda3c","modified":1723901147971},{"_id":"public/2024/2024黑龙江省赛-VP/article.html","hash":"c8f48d4631b978e2318d341ffacf12a0ae5a49e0","modified":1723901147971},{"_id":"public/2024/Xiaobai93D-E/article.html","hash":"bad008c5eb7140ce98a2d19c00c5cb4436884203","modified":1723901147971},{"_id":"public/2024/Xiaobai94/article.html","hash":"e7d804d796a028b496bcd01a9170df991dd12e3c","modified":1723901147971},{"_id":"public/2024/abc353/article.html","hash":"8c742392a748d9e191cb22a3cc4f374dcca867ab","modified":1723901147971},{"_id":"public/2024/abc354/article.html","hash":"d4695b9709fbb7e691b7d7b5700d5279a101da5d","modified":1723901147971},{"_id":"public/2024/cf-edu165C/article.html","hash":"668096da69780d7bfa43e57a590d0d9b48f88222","modified":1723901147971},{"_id":"public/2024/luogu蓝桥5_19/article.html","hash":"fdff099345bfe4e5f0674ed558ffa8af2ec0a37c","modified":1723901147971},{"_id":"public/2024/cf-edu165D/article.html","hash":"8121eebc12fcd0f64c951bd5b5a6ff3a88175d24","modified":1723901147971},{"_id":"public/2024/数学距离问题1/article.html","hash":"9e3e7cd65a761e585d913ce6950f8cc63dfa50f2","modified":1723901147971},{"_id":"public/2024/状态转移习题4/article.html","hash":"ec7a7165a85e4dafa7d70ec8623f9ba7ae0dfcaa","modified":1723901147971},{"_id":"public/2024/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/article.html","hash":"c90239ed12b2b6c4677c44a03c2cc9be590083de","modified":1723901147971},{"_id":"public/2024/树上回文问题/article.html","hash":"9646ce02e6ee01798b5a08c1e25138469003f363","modified":1723901147971},{"_id":"public/2024/状态转移习题3/article.html","hash":"22fdb2293a9005354b54905e6cf2c79f47191663","modified":1723901147971},{"_id":"public/2024/字符串习题1/article.html","hash":"dae0584558c1e04dab1f6589f7b22ab6e6b7bb39","modified":1723901147971},{"_id":"public/2024/思维题习题1/article.html","hash":"fe11de3c4fb7b1fae1eebbfe4eb0c8704e04b22f","modified":1723901147971},{"_id":"public/2024/状态转移习题2/article.html","hash":"7ba7ed5c648f3ebcc841032df8d760df427550c3","modified":1723901147971},{"_id":"public/2024/状态转移习题1/article.html","hash":"6f57c29883c36849a3d5f7082171522217c4d4ca","modified":1723901147971},{"_id":"public/2024/三种操作系统模拟软件使用手册/article.html","hash":"ef391d5e31273eefceb5fa78bf11d4f99f4e0c0a","modified":1723901147971},{"_id":"public/2023/为什么我用Typora——Typora与其他markdown的比较/article.html","hash":"8e59cf01eef09795fcde8a2389e3a8cf54844e0d","modified":1723901147971},{"_id":"public/archives/index.html","hash":"37dffd10b9b289e065b8ccd27906e7b5f7bcc49d","modified":1723901147971},{"_id":"public/archives/page/2/index.html","hash":"b18c4b88b79b45a45b8852f3f6b398c6cbf83018","modified":1723901147971},{"_id":"public/archives/page/3/index.html","hash":"a969eb0a9de9ba88d8b7e8b123030f50646c29ad","modified":1723901147971},{"_id":"public/archives/page/4/index.html","hash":"3fd650826c33e436a95fb89f2d89aa30d00c0214","modified":1723901147971},{"_id":"public/archives/2023/index.html","hash":"6488487cc0fba0fdd37623a9d5f1d72195b666d2","modified":1723901147971},{"_id":"public/archives/2023/08/index.html","hash":"a7e3a9e24cfb297fd96423410b2058aac84ac699","modified":1723901147971},{"_id":"public/archives/2024/index.html","hash":"c935b39cd0ee86052f43ff95a9836186a6226b94","modified":1723901147971},{"_id":"public/archives/2024/page/2/index.html","hash":"dec8e37e1b258d8ad7feeee9e922736a8d3c2255","modified":1723901147971},{"_id":"public/archives/2024/page/3/index.html","hash":"823f5a5899d14f8c080270567b9aaadcb9f41a23","modified":1723901147971},{"_id":"public/archives/2024/page/4/index.html","hash":"aa29c93d745eb293906faa666e8d1c0d573d5132","modified":1723901147971},{"_id":"public/archives/2024/05/index.html","hash":"c2b53dc2def97acdef3a7f8a30e1d8c8720c9879","modified":1723901147971},{"_id":"public/archives/2024/08/index.html","hash":"91e661bd9f36c717ef4ebb8467408add2c067f2f","modified":1723901147971},{"_id":"public/archives/2024/08/page/2/index.html","hash":"aa4e22192672b5795fd33da1629d9eb157257d4b","modified":1723901147971},{"_id":"public/archives/2024/08/page/3/index.html","hash":"8e6a621fdf580c2784288df2e065240b7cf57d4a","modified":1723901147971},{"_id":"public/archives/2024/08/page/4/index.html","hash":"1b6a59df05f51a7560ac2dc086ee05841b544203","modified":1723901147971},{"_id":"public/categories/比赛/index.html","hash":"e59b063265fde8ac38ec37ca4b750fc08aa3a22f","modified":1723901147971},{"_id":"public/categories/比赛/模拟赛/index.html","hash":"9dc1c7a335bb547dd092a4a64e09e7bb39606a6c","modified":1723901147971},{"_id":"public/categories/软件/index.html","hash":"c543ca45ceeecd1fbdc69f203062287f91fba53b","modified":1723901147971},{"_id":"public/categories/信息安全/index.html","hash":"cfe8cdaec0db6459b95088ce7a419db574b3d9fc","modified":1723901147971},{"_id":"public/categories/比赛/日常赛/index.html","hash":"a0ab501408b3ffade4dea8bd1a84e29ac350f25a","modified":1723901147971},{"_id":"public/categories/比赛/模拟赛/ccpc邀请赛/index.html","hash":"6e8dcf60a5aa16ce2b59d197516f57799aed8bd3","modified":1723901147971},{"_id":"public/categories/算法/index.html","hash":"bc88b5461088eb60d8752b16a7c5f53f2a2181e6","modified":1723901147971},{"_id":"public/categories/算法/page/2/index.html","hash":"52a4306a75a8992e80c30588b9963cd5c06c2a3e","modified":1723901147971},{"_id":"public/categories/比赛/模拟赛/icpc邀请赛/index.html","hash":"d2119603387bfd32e4488ffc0f2bcd00c77cf6bc","modified":1723901147971},{"_id":"public/categories/比赛/模拟赛/icpc省赛/index.html","hash":"c253478234dd90cae669262e5ad07a80e6db5376","modified":1723901147971},{"_id":"public/categories/比赛/模拟赛/蓝桥模拟/index.html","hash":"29fda5ba138506fc410ca44cf111c7a4ab81e800","modified":1723901147971},{"_id":"public/categories/软件/工具类软件/index.html","hash":"00e087aee6c0fce90b7c6aab6cb6f7e35ee50a09","modified":1723901147971},{"_id":"public/categories/软件/手册/index.html","hash":"bc24a6dca22b64245553424f31a8e2362dea34d8","modified":1723901147971},{"_id":"public/categories/软件/编辑器/index.html","hash":"37121d4a8caeea1b8e7024eed69e0a25ca15874e","modified":1723901147971},{"_id":"public/categories/软件/经典库/index.html","hash":"7b8256f7ea3227beff89b4b3e5354aa9fcf5a3c6","modified":1723901147971},{"_id":"public/categories/专题/index.html","hash":"7352da7622b8378e3ce560235e3b74176258c953","modified":1723901147971},{"_id":"public/categories/信息安全/加密算法/index.html","hash":"77a1ef350129128b74308a166bd428ce1e27d227","modified":1723901147971},{"_id":"public/categories/学术/index.html","hash":"abd5a8001e25b8c522f069a71c8a87d18f34ac97","modified":1723901147971},{"_id":"public/categories/比赛/日常赛/newcoder/index.html","hash":"e45340fbca8cdfb9793055aaa53992b30b207778","modified":1723901147971},{"_id":"public/categories/算法/思维题/index.html","hash":"dd06e369ffdb00187df41774c3bc355dabf8a558","modified":1723901147971},{"_id":"public/categories/比赛/日常赛/atcoder/index.html","hash":"9219201a9e6c950782975360557fc8256596584f","modified":1723901147971},{"_id":"public/categories/算法/数学/index.html","hash":"8e8690a1b3723b6b868684b68d017c0c1059b94c","modified":1723901147971},{"_id":"public/categories/软件/编辑器/Markdown/index.html","hash":"b6216b3ad0eea1a017d1916664e897c11bdfd7d5","modified":1723901147971},{"_id":"public/categories/算法/字符串/index.html","hash":"a40ac469b33505575a64747987b0db5063acdf74","modified":1723901147971},{"_id":"public/categories/软件/经典库/信息安全/index.html","hash":"b8caea8bede5234badf370b2323815e951035bdd","modified":1723901147971},{"_id":"public/categories/算法/图论/index.html","hash":"27a0efe9425ec49bbb352f0f1d1bc8e97249c71b","modified":1723901147971},{"_id":"public/categories/软件/经典库/前端/index.html","hash":"9e4aa7a3695648cf837a257c1a33ab1bd2ad6f9a","modified":1723901147971},{"_id":"public/categories/算法/状态转移/index.html","hash":"7e6cdb5a637ff45b688feb0e0e64c4b9569ef991","modified":1723901147971},{"_id":"public/categories/专题/机器学习/index.html","hash":"fdfe61b57404bbee782b1553608a99ebb86cf4c7","modified":1723901147971},{"_id":"public/categories/信息安全/加密算法/数学/index.html","hash":"1b065a5302892e87a66fa48de0bb376537ebff4e","modified":1723901147971},{"_id":"public/categories/学术/综述/index.html","hash":"58021a46ec8b232bebfbcad74db6c0a00518388c","modified":1723901147971},{"_id":"public/categories/算法/思维题/模运算/index.html","hash":"a12c185633ba7bdd52737afd071e2e16b2f7abc5","modified":1723901147971},{"_id":"public/categories/算法/数学/博弈论/index.html","hash":"6884e636e3614685fa47ec31c68a75b05f5097af","modified":1723901147971},{"_id":"public/categories/算法/思维题/贪心/index.html","hash":"e0c0d561726b8bc2b4bef9a02b6334c897382519","modified":1723901147971},{"_id":"public/categories/算法/字符串/子序列自动机/index.html","hash":"20b1cec35b6b1fd3d71f5217e297ac46a16835d2","modified":1723901147971},{"_id":"public/categories/算法/图论/图论中的回文问题/index.html","hash":"434127bc26013623e1019e48b7c0cfeac7861de5","modified":1723901147971},{"_id":"public/categories/软件/经典库/前端/node/index.html","hash":"60bad5571d8c0ca7443630031f8333a9706bac06","modified":1723901147971},{"_id":"public/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"427cf581b1e773681e26eeff5b35a3563950aae1","modified":1723901147971},{"_id":"public/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"0561e94403c077607d9ac5cbe5ac20a2f4b7e01f","modified":1723901147971},{"_id":"public/categories/专题/机器学习/Mindspore/index.html","hash":"a7ebcb319aecd5266886d6a4106de484d8079e1b","modified":1723901147971},{"_id":"public/categories/专题/机器学习/Mindspore/基本概念/index.html","hash":"bce5eeeb344724ec16d1fea85f9c378aec3854e6","modified":1723901147971},{"_id":"public/index.html","hash":"ba7b8caeaf08300398984958921724563a71a376","modified":1723901147971},{"_id":"public/page/2/index.html","hash":"fc60f1da381ffb94241c01c594f960c65d993fe5","modified":1723901147971},{"_id":"public/page/3/index.html","hash":"371c83c1f366bc3d5d5ba899a72357bfcf0c2347","modified":1723901147971},{"_id":"public/page/4/index.html","hash":"4aa7dd39acecb90339ee90ae47c497dba6e2bca2","modified":1723901147971},{"_id":"public/en/about/index.html","hash":"c399c1b4e7789b0ba940e78c1e4f550a6b8c583e","modified":1723901147971},{"_id":"public/ja/about/index.html","hash":"559549fded8c1a8d732128961398bb335c9c2389","modified":1723901147971},{"_id":"public/ru/about/index.html","hash":"173a9ca947295cbe783ce7a973951106167a0c9e","modified":1723901147971},{"_id":"public/en/schedule/index.html","hash":"793509e609e0b9f0578cec1ba8a21ea2c72c8e14","modified":1723901147971},{"_id":"public/ja/schedule/index.html","hash":"afc9799e91c6b398c70ab0a5528f73566a824f88","modified":1723901147971},{"_id":"public/ru/schedule/index.html","hash":"7e6f3fe48bffe6bef1fee8c9d9d5684cb3b3d1ee","modified":1723901147971},{"_id":"public/en/categories/index.html","hash":"2db792258d827d3b5731986f6e32160f81804814","modified":1723901147971},{"_id":"public/ja/categories/index.html","hash":"542ebe943b1bd3b2a5a4958b9f1f210ee0309ca9","modified":1723901147971},{"_id":"public/ru/categories/index.html","hash":"a72d3ac4bbb8b982f365cdcb56b35fe76b9ee7fc","modified":1723901147971},{"_id":"public/en/tags/index.html","hash":"a4937ea84f2a2573722cec0d2ab8ecc499a050ca","modified":1723901147971},{"_id":"public/ja/tags/index.html","hash":"fc93652ed757359a3a7448709f0734fbabae9a36","modified":1723901147971},{"_id":"public/ru/tags/index.html","hash":"0c162d303e551819221127ca5b3493f6f6195429","modified":1723901147971},{"_id":"public/en/404/404.html","hash":"04a396374bb3acea8aebe25d512b981c9e1b7666","modified":1723901147971},{"_id":"public/ja/404/404.html","hash":"baaf06e539fd9cd92a64a02e6a8abae232aeb052","modified":1723901147971},{"_id":"public/ru/404/404.html","hash":"b1a62679bd4726f981012888b7156eaef12e4d36","modified":1723901147971},{"_id":"public/en/2024/2024武汉ICPC邀请赛VP/article.html","hash":"9099795ac9c94bc9f5ba328a35696c8f506c16a0","modified":1723901147971},{"_id":"public/ja/2024/2024武汉ICPC邀请赛VP/article.html","hash":"45792f3aefab0042b964fb01d0e2efd14b3bc2c8","modified":1723901147971},{"_id":"public/ru/2024/2024武汉ICPC邀请赛VP/article.html","hash":"1db4d9d1b68ed36d976797ae4cd58bd1aef01c85","modified":1723901147971},{"_id":"public/en/2024/2024江苏CCPC邀请赛-VP/article.html","hash":"eb716e4b0242aac0ca6083b45f704804bd0866cb","modified":1723901147971},{"_id":"public/ja/2024/2024江苏CCPC邀请赛-VP/article.html","hash":"0a12ee025f9116a9c6c87effe8d9dfa83296238e","modified":1723901147971},{"_id":"public/ru/2024/2024江苏CCPC邀请赛-VP/article.html","hash":"24296f48b879ac1ad732c7836ccb3255ef607d1d","modified":1723901147971},{"_id":"public/en/2024/2024湖北省赛VP/article.html","hash":"c2b1f26cac38f93f447decd6104ce79a827266f5","modified":1723901147971},{"_id":"public/ja/2024/2024湖北省赛VP/article.html","hash":"505efa814789ed8c6cefe6dfe7d686410fccefee","modified":1723901147971},{"_id":"public/ru/2024/2024湖北省赛VP/article.html","hash":"4e13833f192be7e2e069c3f51f76d12e6402640c","modified":1723901147971},{"_id":"public/en/2024/2024河南CCPC邀请赛-VP/article.html","hash":"8c7d357d1bc42d30d6376739fe77d518aa51c22f","modified":1723901147971},{"_id":"public/ja/2024/2024河南CCPC邀请赛-VP/article.html","hash":"5e7b034956c49c427d5420536904012aab3ca8ad","modified":1723901147971},{"_id":"public/ru/2024/2024河南CCPC邀请赛-VP/article.html","hash":"422d48b8b1d827965dbdd701aeda861cf5ff963d","modified":1723901147971},{"_id":"public/en/2024/2024黑龙江省赛-VP/article.html","hash":"953d111e8eb3e9e0ebfb68253cf151083afa4422","modified":1723901147971},{"_id":"public/ja/2024/2024黑龙江省赛-VP/article.html","hash":"2006341afecdde14848e30db02469b90064cbab4","modified":1723901147971},{"_id":"public/ru/2024/2024黑龙江省赛-VP/article.html","hash":"de3c0047dd93191c6ffdf760b9a244c05cd944cd","modified":1723901147971},{"_id":"public/en/2024/Latex宏包pgfplots做矩形函数图像/article.html","hash":"8555d395078c7f01f7d60eec307d79aaece6995e","modified":1723901147971},{"_id":"public/ja/2024/Latex宏包pgfplots做矩形函数图像/article.html","hash":"5fdb6098e9d689dcd61cf3f7f8ae9b37cd0a0fb4","modified":1723901147971},{"_id":"public/ru/2024/Latex宏包pgfplots做矩形函数图像/article.html","hash":"309cd14635a8472dabdf0a92dbcaaa60ae07f40f","modified":1723901147971},{"_id":"public/en/2024/Miracl的配置ForCentos7/article.html","hash":"1d20996b58ff86a6bf5c8548ac44e82b8a533e48","modified":1723901147971},{"_id":"public/ja/2024/Miracl的配置ForCentos7/article.html","hash":"f24bc77214c3c8657cb4d49108ddc8272ba146c5","modified":1723901147971},{"_id":"public/ru/2024/Miracl的配置ForCentos7/article.html","hash":"096e662ce788d29ef8c8f2abce27ad9dc15bcfaf","modified":1723901147971},{"_id":"public/en/2024/Nodejs安装简要建议/article.html","hash":"6b16c99626698f7ec5a655ceab5668e32d1f00b1","modified":1723901147971},{"_id":"public/ja/2024/Nodejs安装简要建议/article.html","hash":"06ff22427f4976c0029eb99edc1d77ffd5c0a061","modified":1723901147971},{"_id":"public/ru/2024/Nodejs安装简要建议/article.html","hash":"19bf81a5ca5fa4618b78821c4d4f89b1c9fd12cd","modified":1723901147971},{"_id":"public/en/2024/RSA涉及算法与数论知识/article.html","hash":"00de64893863e14149cf8c5b67c1c5d77202c290","modified":1723901147971},{"_id":"public/ja/2024/RSA涉及算法与数论知识/article.html","hash":"205dd98e035a321b674cc6485c58346215b631a8","modified":1723901147971},{"_id":"public/ru/2024/RSA涉及算法与数论知识/article.html","hash":"ef1cf71e067edff45e5213b47b2ce8db26bcc97f","modified":1723901147971},{"_id":"public/en/2024/Xiaobai93D-E/article.html","hash":"a49a8c65a5f7c1865b4e1e4ac963b549f839391c","modified":1723901147971},{"_id":"public/ja/2024/Xiaobai93D-E/article.html","hash":"56d4079dc186cfcd8375ecc949dee554b7d884ef","modified":1723901147971},{"_id":"public/ru/2024/Xiaobai93D-E/article.html","hash":"c19ae78273b58d1632e8734cad15361331ba7f45","modified":1723901147971},{"_id":"public/en/2024/Xiaobai94/article.html","hash":"28049bdcd5689645d1f01901ac5998af6ce3dfa4","modified":1723901147971},{"_id":"public/ja/2024/Xiaobai94/article.html","hash":"66db036e5ab62469d76f916484ffba3c047059a1","modified":1723901147971},{"_id":"public/ru/2024/Xiaobai94/article.html","hash":"40c9fdc70d967754daf66814c994669868a39f9c","modified":1723901147971},{"_id":"public/en/2024/abc353/article.html","hash":"a14d6d6e9e55062ea1eb75423c283dc825ffb442","modified":1723901147971},{"_id":"public/ja/2024/abc353/article.html","hash":"f0ac4f682d4a0f7d838ab6194a9da19af77a8866","modified":1723901147971},{"_id":"public/ru/2024/abc353/article.html","hash":"8e4210ebec64ac97d8ea2bf97fd02ce895757831","modified":1723901147971},{"_id":"public/en/2024/abc354/article.html","hash":"fe142d4b8348bdd4c7b499141fd7fbdbd881366f","modified":1723901147971},{"_id":"public/ja/2024/abc354/article.html","hash":"7e8f4459676b46fd7dc277066e3226ff8115f9b6","modified":1723901147971},{"_id":"public/ru/2024/abc354/article.html","hash":"7b99f91d29ef94a1c2828474f5f9a5f993fd6834","modified":1723901147971},{"_id":"public/en/2024/cf-edu165D/article.html","hash":"7a4268f6eddcc59e1dd4357934cc47cb817d5567","modified":1723901147971},{"_id":"public/ja/2024/cf-edu165D/article.html","hash":"5a3e91069ac8ec68d35b27f36eb4d042d9e56079","modified":1723901147971},{"_id":"public/ru/2024/cf-edu165D/article.html","hash":"b7dc0c20cec35a18f8dc4ce70d974f619983f837","modified":1723901147971},{"_id":"public/en/2024/cf-edu165C/article.html","hash":"a4fb466add2d95090c5412b85d20d6fe225afcb9","modified":1723901147971},{"_id":"public/ja/2024/cf-edu165C/article.html","hash":"de09e42eae985b837de35afb0517663e7b9ca322","modified":1723901147971},{"_id":"public/ru/2024/cf-edu165C/article.html","hash":"eea20899c30116d167208bc16151f28ea2b7cc71","modified":1723901147971},{"_id":"public/en/2024/luogu蓝桥5_19/article.html","hash":"f4d5d82a1f336dace71e5e0908a7ad053294b66b","modified":1723901147971},{"_id":"public/ja/2024/luogu蓝桥5_19/article.html","hash":"dd5ba610c1c7f0b0e69ce4ef49d2af47c8f525e5","modified":1723901147971},{"_id":"public/ru/2024/luogu蓝桥5_19/article.html","hash":"f34317bdbceb858ed6a572496019200f07bf18da","modified":1723901147971},{"_id":"public/en/2024/三种操作系统模拟软件使用手册/article.html","hash":"0764227304d333c7fd94c8d8eb840e8783d23158","modified":1723901147971},{"_id":"public/ja/2024/三种操作系统模拟软件使用手册/article.html","hash":"68a9f7aa57999dfd15e1fb6eb1c105a547bd30b9","modified":1723901147971},{"_id":"public/ru/2024/三种操作系统模拟软件使用手册/article.html","hash":"4405428b3a4105e9dc9a8ff3de2544f2a2f4e14b","modified":1723901147971},{"_id":"public/en/2023/为什么我用Typora——Typora与其他markdown的比较/article.html","hash":"7a45af1942f6cb4d4051ab15ee18dd18d1f52554","modified":1723901147971},{"_id":"public/ja/2023/为什么我用Typora——Typora与其他markdown的比较/article.html","hash":"6b6a6e2f3985cd14adca964608f009d8a93ed723","modified":1723901147971},{"_id":"public/ru/2023/为什么我用Typora——Typora与其他markdown的比较/article.html","hash":"40a4b24da75bccef43aedc525cebdb4e872beca5","modified":1723901147971},{"_id":"public/en/2024/字符串习题1/article.html","hash":"e33c5fda44e31c23f825d90857b685022d77094e","modified":1723901147971},{"_id":"public/ja/2024/字符串习题1/article.html","hash":"3565b56a2d26ca666a530d4990d59436815e1e5f","modified":1723901147971},{"_id":"public/ru/2024/字符串习题1/article.html","hash":"56f2b340ada44ddb2d574a8d29217cc74a25535e","modified":1723901147971},{"_id":"public/en/2024/思维题习题1/article.html","hash":"ba077e48513b12e0de9622ff9f4a791c2bd1c826","modified":1723901147971},{"_id":"public/ja/2024/思维题习题1/article.html","hash":"989631b0c173c67895f13b3db7d5150c90a1bfb2","modified":1723901147971},{"_id":"public/ru/2024/思维题习题1/article.html","hash":"f58bbeb373c4c1872edc0d8ac60779e29ff4d726","modified":1723901147971},{"_id":"public/en/2024/数学距离问题1/article.html","hash":"ddf9e0002153e47ce71767def55b926cac84757f","modified":1723901147971},{"_id":"public/ja/2024/数学距离问题1/article.html","hash":"d028c4a7ebeb5decfaa14374170cdf83ea349bd2","modified":1723901147971},{"_id":"public/ru/2024/数学距离问题1/article.html","hash":"bb9427b1c9a956e6b25b36855ff46db565e585eb","modified":1723901147971},{"_id":"public/en/2024/树上回文问题/article.html","hash":"faa16d1dca1fd555fad9d44209f920abdddc34c2","modified":1723901147971},{"_id":"public/ja/2024/树上回文问题/article.html","hash":"4555f14c3c23187a5367b224bb8caa26d68e36b9","modified":1723901147971},{"_id":"public/ru/2024/树上回文问题/article.html","hash":"ca22afcb58ddaba84d057f5abfa4a61caa528455","modified":1723901147971},{"_id":"public/en/2024/状态转移习题1/article.html","hash":"79c4b03e9b5b0c2f4af0c2821ccb412764e0e634","modified":1723901147971},{"_id":"public/ja/2024/状态转移习题1/article.html","hash":"301366b6d53d7b0cf9d3221054f25d914aaf3dfa","modified":1723901147971},{"_id":"public/ru/2024/状态转移习题1/article.html","hash":"a08860d9fba39e3fb353509fc5b3c87bdc31ce4d","modified":1723901147971},{"_id":"public/en/2024/状态转移习题2/article.html","hash":"903800c02e45f51a6c10cc5898962288b45a1694","modified":1723901147971},{"_id":"public/ja/2024/状态转移习题2/article.html","hash":"82b0b75362ae0dccbe42b090df920831085cbfa6","modified":1723901147971},{"_id":"public/ru/2024/状态转移习题2/article.html","hash":"69b837e3b26ae209b60d263e31b6b21a5364f044","modified":1723901147971},{"_id":"public/en/2024/状态转移习题3/article.html","hash":"49ec1a4778f5ad3e3e9f794ff2b25b3f1cb35bb1","modified":1723901147971},{"_id":"public/ja/2024/状态转移习题3/article.html","hash":"fd2041ee9f2697b49ba6c00147a0532caf1deb67","modified":1723901147971},{"_id":"public/ru/2024/状态转移习题3/article.html","hash":"bbe534bab554e47306db4f01884e29694548709b","modified":1723901147971},{"_id":"public/en/2024/状态转移习题4/article.html","hash":"77eb1377b266b924723af8bae75cac050afa48c8","modified":1723901147971},{"_id":"public/ja/2024/状态转移习题4/article.html","hash":"054883fd5205e8c44b19a9994b7ff70f1188c5fb","modified":1723901147971},{"_id":"public/ru/2024/状态转移习题4/article.html","hash":"1e6c8a9b1161eda98ff2c52a92e0ff7d8de506a3","modified":1723901147971},{"_id":"public/en/2024/special_subject/MindSpore/MindSpore学习目录/article.html","hash":"03574560ee40eba219aad269532b4b978ae7d349","modified":1723901147971},{"_id":"public/ja/2024/special_subject/MindSpore/MindSpore学习目录/article.html","hash":"27ba2d406439dbf8bb94be7539f3c0685d39f296","modified":1723901147971},{"_id":"public/ru/2024/special_subject/MindSpore/MindSpore学习目录/article.html","hash":"fbc02673196e354a3ae51688d9ee3c85e69b63c0","modified":1723901147971},{"_id":"public/en/2024/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/article.html","hash":"494115c58d8dc76fb021fb63c1fb4e7884b83cdf","modified":1723901147971},{"_id":"public/ja/2024/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/article.html","hash":"7e6ea01073b61c6dabb828f6d4fc8abb13fbd63c","modified":1723901147971},{"_id":"public/ru/2024/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/article.html","hash":"3f3e6489a4da3ecba04f06cc58f60228d55ba777","modified":1723901147971},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Concept/article.html","hash":"09cfc7d25c528823b30e702c343a30e76ac22fb5","modified":1723901147971},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Concept/article.html","hash":"5435fe5045794695514c5aa20f6d623896979f81","modified":1723901147971},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Concept/article.html","hash":"cd81c5395d5cbe394ae204c2f6b9e81c1c940dc5","modified":1723901147971},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/First_Install/article.html","hash":"8ae5a11b4a6767d6dc55daba14d9677f53795ea3","modified":1723901147971},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/First_Install/article.html","hash":"1d72e71e195893467c810523b041d09a358cbab9","modified":1723901147971},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/First_Install/article.html","hash":"aafa9a43b8b97974671d0a942cc939b9d14ce29f","modified":1723901147971},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Second_TryMindSpore/article.html","hash":"e56793ad63b858398052b6e2a62d6516079738e3","modified":1723901147971},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Second_TryMindSpore/article.html","hash":"c7136cfdfe3e6bde3412af8cee1f50bc71e5b684","modified":1723901147971},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Second_TryMindSpore/article.html","hash":"ebcf5be8245df9fc419f5c6163b187cff9ac17a5","modified":1723901147971},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Fourth_DataSet/article.html","hash":"96210f2c373af961759422c148021f487cfdafd0","modified":1723901147971},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Fourth_DataSet/article.html","hash":"1b0ed1b82d51d27b56eac287d4c6c3c3829a2b51","modified":1723901147971},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Fourth_DataSet/article.html","hash":"237fe28bd902113aa608d28a15ccbef8aede8e94","modified":1723901147971},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork/article.html","hash":"b3704d0fdee62cc26691d0ddda5fc5ebe9a09fdf","modified":1723901147971},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork/article.html","hash":"299997e79dc9a0235b1cb136adde23cbdf7d00e2","modified":1723901147971},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork/article.html","hash":"591e24b07232c288ddb12e99799ffa67cd412703","modified":1723901147971},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc/article.html","hash":"2e1d980c8b1f9e2d190c07fad0136eaa4ba8a674","modified":1723901147971},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc/article.html","hash":"4114190a9848775265e418e6098f4a461b3a338f","modified":1723901147971},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc/article.html","hash":"ba086d74856d403ddc33c436defaa9a84bfc96b1","modified":1723901147971},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Seven_ModelTrain/article.html","hash":"15c06968b5c8cb782854a28be822f78b5a7e74f3","modified":1723901147971},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Seven_ModelTrain/article.html","hash":"5d49665a763b916607ca307a2727dad23fc2be97","modified":1723901147971},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Seven_ModelTrain/article.html","hash":"d1130f7d5de2c7a01c5c0354f3c79d4eaef105a4","modified":1723901147971},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/TransformerStructure/article.html","hash":"7979f2c9631194732a2bcd25add494e1a85200e0","modified":1723901147971},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/TransformerStructure/article.html","hash":"615278a1e6bcfb585c08851bfcaf4f222783b4c4","modified":1723901147971},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/TransformerStructure/article.html","hash":"5e223774199aa14f8c39c904764e0f7e2cf3413a","modified":1723901147971},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Third_Tensor/article.html","hash":"d71d22a827952fb8ded06e8f0937be1779b6e9a1","modified":1723901147971},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Third_Tensor/article.html","hash":"991c2aa58f2d6d8922daa24f0f6e9d8c39e22bf1","modified":1723901147971},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Third_Tensor/article.html","hash":"0d18ac2c3b70f2a67e6f6d916584d9e78f0d05b1","modified":1723901147971},{"_id":"public/en/index.html","hash":"d2183ab8d4568e17fd5233c108486ffc8ce59411","modified":1723901147971},{"_id":"public/ja/index.html","hash":"b138f8abfc7cda97f13dbb96822fe0daca52540d","modified":1723901147971},{"_id":"public/ru/index.html","hash":"1c96d9e9b39f044ae158a2a48f1b42ab5c3454f7","modified":1723901147971},{"_id":"public/en/page/2/index.html","hash":"e7ab0efb56f69e76f97ab377819ee54d23aec0c4","modified":1723901147971},{"_id":"public/ja/page/2/index.html","hash":"9ad3260a0d3520e35f769766ebb2d6093025a73a","modified":1723901147971},{"_id":"public/ru/page/2/index.html","hash":"9c407dc27c7761f6bdab7e4e085bc0bda2069c74","modified":1723901147971},{"_id":"public/en/page/3/index.html","hash":"51ca80a93b6e859c636625f28a0b133f6d18f9d9","modified":1723901147971},{"_id":"public/ja/page/3/index.html","hash":"222d2a3dcee840c01fd701a1cceafec08eb03c94","modified":1723901147971},{"_id":"public/ru/page/3/index.html","hash":"f96097417d2032516d0788fb7a0d222b9fd7bc3f","modified":1723901147971},{"_id":"public/en/page/4/index.html","hash":"520c4dc2500641a1c05e3239af681598e24133ce","modified":1723901147971},{"_id":"public/ja/page/4/index.html","hash":"22e23ff0fea7d78f78cefd240ee79035fed74f92","modified":1723901147971},{"_id":"public/ru/page/4/index.html","hash":"76546a283593ba5724f69caa065f715b405c6e7c","modified":1723901147971},{"_id":"public/en/archives/index.html","hash":"c17744da4ea79c4aae6f6aac7e01f380ef5edcce","modified":1723901147971},{"_id":"public/ja/archives/index.html","hash":"38ec256cf83076777f89d7b22deec659f6c59353","modified":1723901147971},{"_id":"public/ru/archives/index.html","hash":"3427c43321bf707ec6552e99eab36d0a10174eca","modified":1723901147971},{"_id":"public/en/archives/page/2/index.html","hash":"efe4b974d45d3c40aba8215d51f681aed0f1a32d","modified":1723901147971},{"_id":"public/ja/archives/page/2/index.html","hash":"133a230e9e0627e2db37f05a1e581e0f3ce228c3","modified":1723901147971},{"_id":"public/ru/archives/page/2/index.html","hash":"6f867d1cac2a4ef15c9f8cc947f04373d286f7f2","modified":1723901147971},{"_id":"public/en/archives/page/3/index.html","hash":"81c9cda674375ccbed74b343bcdbae3938584b7a","modified":1723901147971},{"_id":"public/ja/archives/page/3/index.html","hash":"5153199a6ebbbe321f6ee6e67d0954c33a213e7e","modified":1723901147971},{"_id":"public/ru/archives/page/3/index.html","hash":"500f6da7f47fbe6979b948f40d9f9efdc0381fef","modified":1723901147971},{"_id":"public/en/archives/page/4/index.html","hash":"0d8af9a3336a08ddbe7784c9b0354285037ed5bb","modified":1723901147971},{"_id":"public/ja/archives/page/4/index.html","hash":"e80e1da7769244c68b5551accfb9546bfde4d229","modified":1723901147971},{"_id":"public/ru/archives/page/4/index.html","hash":"ca2a7dd3bf92653ea29870cbe5431c87c2a90d76","modified":1723901147971},{"_id":"public/en/archives/2023/index.html","hash":"aacc0a7d950474f510735031469eb5bd2dc82217","modified":1723901147971},{"_id":"public/ja/archives/2023/index.html","hash":"6bcc4067bda698738dd576508eea9fdc1583fc92","modified":1723901147971},{"_id":"public/ru/archives/2023/index.html","hash":"ba4254ae31b99a9c250f648c426d20ba4b15cc84","modified":1723901147971},{"_id":"public/en/archives/2023/08/index.html","hash":"0b908b9035d48265ad977def08863924952e4b16","modified":1723901147971},{"_id":"public/ja/archives/2023/08/index.html","hash":"013cd6754e9a2731cccfec7b59fc0d9ecea34bfd","modified":1723901147971},{"_id":"public/ru/archives/2023/08/index.html","hash":"a96a5c8294d4ba7ca9f77c8ef4b324f446e7eb87","modified":1723901147971},{"_id":"public/en/archives/2024/index.html","hash":"8c2e20e0050e985e07a1883d0be62c5abdd21cd0","modified":1723901147971},{"_id":"public/ja/archives/2024/index.html","hash":"fbcb01a43010a06710f6193a3551527cb4466ca4","modified":1723901147971},{"_id":"public/ru/archives/2024/index.html","hash":"a57a159973ff5d1f26bee9567b58aef6ff0c5d64","modified":1723901147971},{"_id":"public/en/archives/2024/page/2/index.html","hash":"a839fa4e7c2a0826fedc9c771983f3f0b6bc7530","modified":1723901147971},{"_id":"public/ja/archives/2024/page/2/index.html","hash":"4de041312d5ee2f8667f1deeea5125de51688b46","modified":1723901147971},{"_id":"public/ru/archives/2024/page/2/index.html","hash":"37a1da11ce7142d4d0bcc7e9b94df9d01443f5a2","modified":1723901147971},{"_id":"public/en/archives/2024/page/3/index.html","hash":"9d057348d765fb165b367b6bbbab71b2f864a03f","modified":1723901147971},{"_id":"public/ja/archives/2024/page/3/index.html","hash":"101759babc01c6e2b7bec7dd42ca64ac4aa33177","modified":1723901147971},{"_id":"public/ru/archives/2024/page/3/index.html","hash":"5806d0ebd17aed251ac6646fa99ef1788f7a24eb","modified":1723901147971},{"_id":"public/en/archives/2024/page/4/index.html","hash":"8ef9aa82053ed0b9deedefed50672c0566d56ebd","modified":1723901147971},{"_id":"public/ja/archives/2024/page/4/index.html","hash":"36a8baee2563638b56b2535fccaea298e1fac8b1","modified":1723901147971},{"_id":"public/ru/archives/2024/page/4/index.html","hash":"5c3613504728babdc16acd87306b3589384ea81d","modified":1723901147971},{"_id":"public/en/archives/2024/05/index.html","hash":"3c5b646721cb838b77a93af20d98bc4bc98cbf1b","modified":1723901147971},{"_id":"public/ja/archives/2024/05/index.html","hash":"6848fc7ef3c4f3767450e9f7201063ffe9550dd0","modified":1723901147971},{"_id":"public/ru/archives/2024/05/index.html","hash":"7229116e1cf5e5bda8dff971f65cd74a801f8ae7","modified":1723901147971},{"_id":"public/en/archives/2024/08/index.html","hash":"8f3ca97a3f8abfbe9603847ed076a245e0b57488","modified":1723901147971},{"_id":"public/ja/archives/2024/08/index.html","hash":"774d369b79fb4cdb18dd09829abd9b643c635e6a","modified":1723901147971},{"_id":"public/ru/archives/2024/08/index.html","hash":"7bfb7b63bcdc62597dced91f9a6f37a4342c26ff","modified":1723901147971},{"_id":"public/en/archives/2024/08/page/2/index.html","hash":"90e87c96269dac28af797893e6ca781a6fd61d57","modified":1723901147971},{"_id":"public/ja/archives/2024/08/page/2/index.html","hash":"4a90d1256574d68ffa489debf94cf5b4e8a341fe","modified":1723901147971},{"_id":"public/ru/archives/2024/08/page/2/index.html","hash":"9481a741bfe53818c8b6b9414f5e7648189cf920","modified":1723901147971},{"_id":"public/en/archives/2024/08/page/3/index.html","hash":"23ad8a74d49347d564d150ff6d94be11fe5b5167","modified":1723901147971},{"_id":"public/ja/archives/2024/08/page/3/index.html","hash":"b0d3315d598ed2fc53dc2758e018a0b0d953567d","modified":1723901147971},{"_id":"public/ru/archives/2024/08/page/3/index.html","hash":"d7514932fd29600c29050242e2e74b67a0ea9139","modified":1723901147971},{"_id":"public/en/archives/2024/08/page/4/index.html","hash":"16063059e6fff7c5288aa10dd268e7527be7e28c","modified":1723901147971},{"_id":"public/ja/archives/2024/08/page/4/index.html","hash":"6f30e5c96945e321abb7a9e5375fb57dfa955c38","modified":1723901147971},{"_id":"public/ru/archives/2024/08/page/4/index.html","hash":"fd26d462b20c6111522756d9494071b2a6f24d82","modified":1723901147971},{"_id":"public/en/categories/比赛/index.html","hash":"8a871782ae7336f354b7508eaceaf30b9a967b83","modified":1723901147971},{"_id":"public/ja/categories/比赛/index.html","hash":"8e3cffd84dfcd1949683514ba19cb95db9850081","modified":1723901147971},{"_id":"public/ru/categories/比赛/index.html","hash":"c5e2fa7292887327a9a110e4953b64512a7962b7","modified":1723901147971},{"_id":"public/en/categories/比赛/模拟赛/index.html","hash":"4eb68b9bb9f6bbb7c2e5e1bd9008d0a1465ba0ac","modified":1723901147971},{"_id":"public/ja/categories/比赛/模拟赛/index.html","hash":"d82565ea1153e06b8ba32fd8f4e78961955dc0e9","modified":1723901147971},{"_id":"public/ru/categories/比赛/模拟赛/index.html","hash":"c558e813d7f4a20459ea61056e364e44eeda22b3","modified":1723901147971},{"_id":"public/en/categories/软件/index.html","hash":"01c60f1e3725f80381d7018cd9a805e403ab6e3a","modified":1723901147971},{"_id":"public/ja/categories/软件/index.html","hash":"e1bd561ff1401dd903b728cc0d59c54d1facf07e","modified":1723901147971},{"_id":"public/ru/categories/软件/index.html","hash":"e0a4b6b273e002003f66fbdaccd4c2894a27d19f","modified":1723901147971},{"_id":"public/en/categories/信息安全/index.html","hash":"9fcdc43b20bac8b4f17a71b14054c355a697b428","modified":1723901147971},{"_id":"public/ja/categories/信息安全/index.html","hash":"0b848b59e827c7e92fb301084467d8be504327f1","modified":1723901147971},{"_id":"public/ru/categories/信息安全/index.html","hash":"8c1fef4646e0c09c27878c8bfbc235ed68a65652","modified":1723901147971},{"_id":"public/en/categories/比赛/日常赛/index.html","hash":"ceea50ae0f27675bca91737c38aa03afaed1ad88","modified":1723901147971},{"_id":"public/ja/categories/比赛/日常赛/index.html","hash":"7e0435ea5aea32a1acfbc2895a1525531db516d9","modified":1723901147971},{"_id":"public/ru/categories/比赛/日常赛/index.html","hash":"e2a420cf2e1fadd35c866fc122d7f5b612574865","modified":1723901147971},{"_id":"public/en/categories/比赛/模拟赛/ccpc邀请赛/index.html","hash":"686c55b70ee50cc307d531e90f5d2f82709aaa18","modified":1723901147971},{"_id":"public/ja/categories/比赛/模拟赛/ccpc邀请赛/index.html","hash":"31911a11d4c1397c71c3f4e6a886919ae09b2bdd","modified":1723901147971},{"_id":"public/ru/categories/比赛/模拟赛/ccpc邀请赛/index.html","hash":"f65dd4a3dfd978d8c7f6cd74324e780e8dccff73","modified":1723901147971},{"_id":"public/en/categories/算法/index.html","hash":"1157b164728308519f95f6255364eb60c090b598","modified":1723901147971},{"_id":"public/ja/categories/算法/index.html","hash":"eb6565624548772c426ea68ff5f5e2c0e22964f5","modified":1723901147971},{"_id":"public/ru/categories/算法/index.html","hash":"9e74d1b666a1ad2b804a1c38a11c341eff2f548c","modified":1723901147971},{"_id":"public/en/categories/算法/page/2/index.html","hash":"300ff97962e07be002c7effba15a8f8c7118322d","modified":1723901147971},{"_id":"public/ja/categories/算法/page/2/index.html","hash":"893abb5a1b8df24ef0d42c63e8ab7bfa41768ff6","modified":1723901147971},{"_id":"public/ru/categories/算法/page/2/index.html","hash":"f90d5ba4de8764bc917073c36205dd17266a09bd","modified":1723901147971},{"_id":"public/en/categories/比赛/模拟赛/icpc邀请赛/index.html","hash":"64b59dec8b26a0b28f463ac4ad69265e41865183","modified":1723901147971},{"_id":"public/ja/categories/比赛/模拟赛/icpc邀请赛/index.html","hash":"d864611fa2aa0592cad6c831b9e5a7547b4c04d9","modified":1723901147971},{"_id":"public/ru/categories/比赛/模拟赛/icpc邀请赛/index.html","hash":"dbd4c5080ff4b17aa91b33789703afc5695920af","modified":1723901147971},{"_id":"public/en/categories/比赛/模拟赛/icpc省赛/index.html","hash":"e605a64392229a271e1e4fb50ca03da81feae0fb","modified":1723901147971},{"_id":"public/ja/categories/比赛/模拟赛/icpc省赛/index.html","hash":"4825f93ee6fb935288393ba71cf1f93ab1d94e62","modified":1723901147971},{"_id":"public/ru/categories/比赛/模拟赛/icpc省赛/index.html","hash":"6b70eabf72b414f382114e2ab59c49782e96ecaf","modified":1723901147971},{"_id":"public/en/categories/比赛/模拟赛/蓝桥模拟/index.html","hash":"1861e3be0f4cdcd77b48a6a711c40421178d11f9","modified":1723901147971},{"_id":"public/ja/categories/比赛/模拟赛/蓝桥模拟/index.html","hash":"ae912900b5f13ab4a274517eef17648252b6c142","modified":1723901147971},{"_id":"public/ru/categories/比赛/模拟赛/蓝桥模拟/index.html","hash":"6b6832209c6159497d2f97b35a3934c8494d7457","modified":1723901147971},{"_id":"public/en/categories/软件/工具类软件/index.html","hash":"b7158709b8821acd17b31da8bf34c5b16178834a","modified":1723901147971},{"_id":"public/ja/categories/软件/工具类软件/index.html","hash":"8cce28cc7efda146f2391b7a50836589b73bd0ce","modified":1723901147971},{"_id":"public/ru/categories/软件/工具类软件/index.html","hash":"6dff68b1efc0530a95b62b680ad026c8b48f2bb3","modified":1723901147971},{"_id":"public/en/categories/软件/手册/index.html","hash":"bfc68894007ad8db8a1fc2f3fcb9eb165ed2f699","modified":1723901147971},{"_id":"public/ja/categories/软件/手册/index.html","hash":"afdd9bbdaa8e6552bc642063cd37c880b3a5cee1","modified":1723901147971},{"_id":"public/ru/categories/软件/手册/index.html","hash":"650c66279e72f411881adac2903911441f46eaca","modified":1723901147971},{"_id":"public/en/categories/软件/编辑器/index.html","hash":"d6dfc708b4c803ddd42ea25a9f1f964ecdfd7af4","modified":1723901147971},{"_id":"public/ja/categories/软件/编辑器/index.html","hash":"d67562c5d10a8ac399d6fd3603c6a2c094847ff8","modified":1723901147971},{"_id":"public/ru/categories/软件/编辑器/index.html","hash":"550fc539a583e2c9a0774e498f948ce0487e8d73","modified":1723901147971},{"_id":"public/en/categories/软件/经典库/index.html","hash":"1960be7e346dfb3384d9f054a4303bc459103bab","modified":1723901147971},{"_id":"public/ja/categories/软件/经典库/index.html","hash":"c9b5789db6730154f4787745bd38270ec4152531","modified":1723901147971},{"_id":"public/ru/categories/软件/经典库/index.html","hash":"c34ccd1f943d57b8c013c967689feed47165d4b1","modified":1723901147971},{"_id":"public/en/categories/专题/index.html","hash":"c15fa0471074c5b1a8dc74fe2c8a221bbbe6aba1","modified":1723901147971},{"_id":"public/ja/categories/专题/index.html","hash":"cdf7c776fde3dc6bbd76775c485e1041d59a7f8d","modified":1723901147971},{"_id":"public/ru/categories/专题/index.html","hash":"f83a7c3689e2c03a2da916fabe50931d16d86810","modified":1723901147971},{"_id":"public/en/categories/信息安全/加密算法/index.html","hash":"f8bd435b23f4251c9797b96755c1543978c5278c","modified":1723901147971},{"_id":"public/ja/categories/信息安全/加密算法/index.html","hash":"9c00a56b4b499c10d8b75452109fdb00413d4bc4","modified":1723901147971},{"_id":"public/ru/categories/信息安全/加密算法/index.html","hash":"4288fa375167c73122a6cde87d51baf981fb37d6","modified":1723901147971},{"_id":"public/en/categories/学术/index.html","hash":"e199b55d8bec316fec1d9bb58e7ede49abe4f479","modified":1723901147971},{"_id":"public/ja/categories/学术/index.html","hash":"3bf8e26944fdf50333b6355c112bbe66a9c3baca","modified":1723901147971},{"_id":"public/ru/categories/学术/index.html","hash":"7ec69d8a178c7047b99ba8fc6fe60ea5f40e6996","modified":1723901147971},{"_id":"public/en/categories/比赛/日常赛/newcoder/index.html","hash":"3aba544c7c916c5b481fd2a49158c77635089800","modified":1723901147971},{"_id":"public/ja/categories/比赛/日常赛/newcoder/index.html","hash":"b5c869f8e710598274b01fa9c0e410b277fa3190","modified":1723901147971},{"_id":"public/ru/categories/比赛/日常赛/newcoder/index.html","hash":"44dfb96d54773ccefd0eb2d0c19ccb570d45ccde","modified":1723901147971},{"_id":"public/en/categories/算法/思维题/index.html","hash":"ac2f7ad413e2280469b225de22d23f2496006978","modified":1723901147971},{"_id":"public/ja/categories/算法/思维题/index.html","hash":"eba898131a5da9a5bca91a5ab2ab37db0d70e0b9","modified":1723901147971},{"_id":"public/ru/categories/算法/思维题/index.html","hash":"f3c686912be9b10202932f35cd1fe7ae330cf5d4","modified":1723901147971},{"_id":"public/en/categories/比赛/日常赛/atcoder/index.html","hash":"b32b2bb875a3c91aedc284bb592c23768114354c","modified":1723901147971},{"_id":"public/ja/categories/比赛/日常赛/atcoder/index.html","hash":"6af2137c2118670bb86ddf50a3358b5a02306c39","modified":1723901147971},{"_id":"public/ru/categories/比赛/日常赛/atcoder/index.html","hash":"2e6b10ff33d0de1a817e5341df7ce7ac0becb806","modified":1723901147971},{"_id":"public/en/categories/算法/数学/index.html","hash":"24256e520a658dc420717b364ec9b108cefb63dd","modified":1723901147971},{"_id":"public/ja/categories/算法/数学/index.html","hash":"99e3b03fa64b893d018b8b2802168fcfca161b68","modified":1723901147971},{"_id":"public/ru/categories/算法/数学/index.html","hash":"1750b727ea021f1252bc9f0bd320de10cf22c894","modified":1723901147971},{"_id":"public/en/categories/软件/编辑器/Markdown/index.html","hash":"944d0949dd89b5ac4668385e598b5d4ab1fee74c","modified":1723901147971},{"_id":"public/ja/categories/软件/编辑器/Markdown/index.html","hash":"64487aff5c0b8993e904b284cdf636f3c81650c6","modified":1723901147971},{"_id":"public/ru/categories/软件/编辑器/Markdown/index.html","hash":"a522021b9434c03fc2a229a1345dd4380b91e916","modified":1723901147971},{"_id":"public/en/categories/算法/字符串/index.html","hash":"dfeb599646fcf4e3e926abe97f8c59b8ebc379f2","modified":1723901147971},{"_id":"public/ja/categories/算法/字符串/index.html","hash":"6e5f262ed89b9ca380b46945b47c5ff3ff41c69b","modified":1723901147971},{"_id":"public/ru/categories/算法/字符串/index.html","hash":"290bc65c53e3b74875a362dba6a3a006b0ee395b","modified":1723901147971},{"_id":"public/en/categories/软件/经典库/信息安全/index.html","hash":"8901fa2d053a98af806e639bb9df7d66c9040397","modified":1723901147971},{"_id":"public/ja/categories/软件/经典库/信息安全/index.html","hash":"6c3a4ade67f15293615a35e7e9eccc3090cf85e3","modified":1723901147971},{"_id":"public/ru/categories/软件/经典库/信息安全/index.html","hash":"641ba63718d2be56f9048e8cdbc9d14b94153aa8","modified":1723901147971},{"_id":"public/en/categories/算法/图论/index.html","hash":"0e36369e03f0c2e02f741eca10f381f18f3dea37","modified":1723901147971},{"_id":"public/ja/categories/算法/图论/index.html","hash":"4c4224624e02c7a3732ddc74e05c633f5d3a4f43","modified":1723901147971},{"_id":"public/ru/categories/算法/图论/index.html","hash":"433be9b50dd280772f54db04612fbb936a421253","modified":1723901147971},{"_id":"public/en/categories/软件/经典库/前端/index.html","hash":"17f679f2f5db7378ee1947084c96bda0bdb916ae","modified":1723901147971},{"_id":"public/ja/categories/软件/经典库/前端/index.html","hash":"9899f48097cc5b129c62837a59a179e0ba541a2d","modified":1723901147971},{"_id":"public/ru/categories/软件/经典库/前端/index.html","hash":"5dcc601ab687c9ef33d982bfb29d787f8201ff37","modified":1723901147971},{"_id":"public/en/categories/算法/状态转移/index.html","hash":"a1cb450aef1912e593aea0a4a0697a45b5cdd206","modified":1723901147971},{"_id":"public/ja/categories/算法/状态转移/index.html","hash":"f049e09f6a4f34946bc583777c86b6c727d91bd8","modified":1723901147971},{"_id":"public/ru/categories/算法/状态转移/index.html","hash":"032f489f76122dea37b734cdb0e85a5fa9726eab","modified":1723901147971},{"_id":"public/en/categories/专题/机器学习/index.html","hash":"efa0128dc78f9fe217a4efa0f6d0ee62cef28529","modified":1723901147971},{"_id":"public/ja/categories/专题/机器学习/index.html","hash":"9ad1b31b8cbb7f9e00471d7c4b33b9b67832952f","modified":1723901147971},{"_id":"public/ru/categories/专题/机器学习/index.html","hash":"ca64297dc56131b0914da6a28388ae73ae8ee651","modified":1723901147971},{"_id":"public/en/categories/信息安全/加密算法/数学/index.html","hash":"ab44aea075b45e6998a279652488f120c8195c74","modified":1723901147971},{"_id":"public/ja/categories/信息安全/加密算法/数学/index.html","hash":"a52ba975b1f0852bfccb00c5cabac97ce3bf20c1","modified":1723901147971},{"_id":"public/ru/categories/信息安全/加密算法/数学/index.html","hash":"c05108103e2916a9e2c327161347e023b3661d14","modified":1723901147971},{"_id":"public/en/categories/学术/综述/index.html","hash":"fda73186c38b4d1d4bdf72258f89cc26249cf1ac","modified":1723901147971},{"_id":"public/ja/categories/学术/综述/index.html","hash":"45b570bbf5e0b3079fc77b56606ebb4dda75de02","modified":1723901147971},{"_id":"public/ru/categories/学术/综述/index.html","hash":"3cbca659bdee047f51fc77c990140ad81a6dba61","modified":1723901147971},{"_id":"public/en/categories/算法/思维题/模运算/index.html","hash":"54ecfe281117923de81c975e333d6fb391923250","modified":1723901147971},{"_id":"public/ja/categories/算法/思维题/模运算/index.html","hash":"0e2b591954cfda4a36aaaf8f473d3712921b946c","modified":1723901147971},{"_id":"public/ru/categories/算法/思维题/模运算/index.html","hash":"73dd72326056c3e1a461fa7ddffe66f60854a3dd","modified":1723901147971},{"_id":"public/en/categories/算法/数学/博弈论/index.html","hash":"21ac47588fbbbb4aac0061b8dfec8ec3d6ce7473","modified":1723901147971},{"_id":"public/ja/categories/算法/数学/博弈论/index.html","hash":"622f159322664ee7d462cc6e1c459c0e6ab96c3b","modified":1723901147971},{"_id":"public/ru/categories/算法/数学/博弈论/index.html","hash":"589faad3c86a8b9bc269c08a3f3b1e90deca8fde","modified":1723901147971},{"_id":"public/en/categories/算法/思维题/贪心/index.html","hash":"f5d59fb02d3fe9095eed6c6f4d18b6be307018e4","modified":1723901147971},{"_id":"public/ja/categories/算法/思维题/贪心/index.html","hash":"ddc3f155eb1c2fc777de7afdb2bb85fb9a9e8614","modified":1723901147971},{"_id":"public/ru/categories/算法/思维题/贪心/index.html","hash":"00749f45e9bef1af1d914f155feb48769e240e1c","modified":1723901147971},{"_id":"public/en/categories/算法/字符串/子序列自动机/index.html","hash":"3c6b38e40ad55f1ee77b50e84087f77f4b6e48c6","modified":1723901147971},{"_id":"public/ja/categories/算法/字符串/子序列自动机/index.html","hash":"3597e017821068c2bae37bca7c6a08e3be026433","modified":1723901147971},{"_id":"public/ru/categories/算法/字符串/子序列自动机/index.html","hash":"13b9eef44217579f2bc45833e52d4aba7a8b435b","modified":1723901147971},{"_id":"public/en/categories/算法/图论/图论中的回文问题/index.html","hash":"8a44416f39db0d9229cd665fcaefd36e4dcc7317","modified":1723901147971},{"_id":"public/ja/categories/算法/图论/图论中的回文问题/index.html","hash":"958ef40bfd3fc1b326b0a5f092b3e9e24032d66e","modified":1723901147971},{"_id":"public/ru/categories/算法/图论/图论中的回文问题/index.html","hash":"bab5923cf3b89ac7619da5d0cf9bc55a0b8f33f2","modified":1723901147971},{"_id":"public/en/categories/软件/经典库/前端/node/index.html","hash":"816dbdf9775da70afb90cbe3c9e28f70f2e64aee","modified":1723901147971},{"_id":"public/ja/categories/软件/经典库/前端/node/index.html","hash":"955dc12312e7ca6bf7b43a82e95ed857a3ae9795","modified":1723901147971},{"_id":"public/ru/categories/软件/经典库/前端/node/index.html","hash":"fb73362f5dabe7919d635ea2032f6323719b45e0","modified":1723901147971},{"_id":"public/en/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"5f8fec5569ef3d024a1d255dcf83f82ac91b2961","modified":1723901147971},{"_id":"public/ja/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"cbac37000152bf279459e06b1ca1be5368b700d7","modified":1723901147971},{"_id":"public/ru/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"abd1517b48dd9845cb68e42daaf6fa5f0ebfa5e2","modified":1723901147971},{"_id":"public/en/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"3cc41978fabf4e325ad7ff879ecab6f16fb39093","modified":1723901147971},{"_id":"public/ja/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"3f4e6d1a1db7985976718cad9652c25de5194258","modified":1723901147971},{"_id":"public/ru/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"1b09c6a045eda6de607865ddb94b7682bf54b2d2","modified":1723901147971},{"_id":"public/en/categories/专题/机器学习/Mindspore/index.html","hash":"c12eb9e8342538196fc4ad268e373e876ac6ad74","modified":1723901147971},{"_id":"public/ja/categories/专题/机器学习/Mindspore/index.html","hash":"28a93be4a0edea853326f43e9e136695b6c94069","modified":1723901147971},{"_id":"public/ru/categories/专题/机器学习/Mindspore/index.html","hash":"1fb43eafd99fc0985fa304ef91aaf6986a2dec85","modified":1723901147971},{"_id":"public/en/categories/专题/机器学习/Mindspore/基本概念/index.html","hash":"64df435385f4f36db1a901f92f56b66d57b3041a","modified":1723901147971},{"_id":"public/ja/categories/专题/机器学习/Mindspore/基本概念/index.html","hash":"401cec0d0e3b05b97a98e31f4da04e23a9cfe1ac","modified":1723901147971},{"_id":"public/ru/categories/专题/机器学习/Mindspore/基本概念/index.html","hash":"15d66b4ec6ca319afcc09edebd1159e9f01793b2","modified":1723901147971},{"_id":"public/tags/icpc/index.html","hash":"f904aecf81b92db4e8559cc5294fa0c2bcd40904","modified":1723901147971},{"_id":"public/tags/ccpc/index.html","hash":"3400fc63db104aa33051483218650fe760737f91","modified":1723901147971},{"_id":"public/tags/Latex/index.html","hash":"695e5bda46f67b3bb4b0f6bd3a0c0f4bfaadc41b","modified":1723901147971},{"_id":"public/tags/图像处理/index.html","hash":"c42938118c0627f952df60586fcdd4aa6585441b","modified":1723901147971},{"_id":"public/tags/信息安全/index.html","hash":"128cc11211b5dd74ddb3a3eba8850690b8f4009e","modified":1723901147971},{"_id":"public/tags/软件/index.html","hash":"b221ea11d13e58ceaec766993f237ce52346a967","modified":1723901147971},{"_id":"public/tags/Miracl/index.html","hash":"07e41d69eea4cb17123ca0756398e0a7ffd52b4a","modified":1723901147971},{"_id":"public/tags/nodejs/index.html","hash":"765e6214bef70191f22318bc7344b41059522c2e","modified":1723901147971},{"_id":"public/tags/gcc/index.html","hash":"581e7d7f04cd47d45b859a06018ded441153ac58","modified":1723901147971},{"_id":"public/tags/linux/index.html","hash":"73e0234f1b9e9e49921d48fa4f50534c8def5a00","modified":1723901147971},{"_id":"public/tags/数学/index.html","hash":"29ceb5feaa26fcb41606bfa32e4c19a7457d4463","modified":1723901147971},{"_id":"public/tags/newcoder/index.html","hash":"a41b889385b8dd3e9d8df7a89de6f08274b2f898","modified":1723901147971},{"_id":"public/tags/算法/index.html","hash":"9377f07d346b65d59c5efdcf0c50739d7fc40f75","modified":1723901147971},{"_id":"public/tags/算法/page/2/index.html","hash":"41ef424337737b04ec394d7c7602e269e40b5855","modified":1723901147971},{"_id":"public/tags/思维题/index.html","hash":"ced44924dd4df8d83724478fb416655e17dd1e9e","modified":1723901147971},{"_id":"public/tags/模运算/index.html","hash":"5f267f1942c7fe2a2f11726a873aaba1abeed826","modified":1723901147971},{"_id":"public/tags/atcoder/index.html","hash":"605a2e8126b3ed6f94f336fe1c011a02e15ee0f8","modified":1723901147971},{"_id":"public/tags/博弈论/index.html","hash":"3d4621a4637349f3e2c004cf553bba6d5acd8ac6","modified":1723901147971},{"_id":"public/tags/不等式/index.html","hash":"02171560d7972ac73523f5168f1d0cf56c4d2a76","modified":1723901147971},{"_id":"public/tags/贪心/index.html","hash":"15244fdc7648f4289e809e5dbc14f44efc8ccd50","modified":1723901147971},{"_id":"public/tags/状态转移/index.html","hash":"4b101a4dbd9d83c10a4a2c1b00edea8101c294e0","modified":1723901147971},{"_id":"public/tags/luogu/index.html","hash":"63dd10f3393b577492011b26901b0a68c3494da0","modified":1723901147971},{"_id":"public/tags/开发/index.html","hash":"d4bc74a9abb2043e2803cf938d207403062d8e53","modified":1723901147971},{"_id":"public/tags/文档/index.html","hash":"11a4b46719ef6c4ee801b50afba38ed0ccb26e35","modified":1723901147971},{"_id":"public/tags/学校/index.html","hash":"a5110a8da2e09cd731d4f29fd07d4ff3281428b9","modified":1723901147971},{"_id":"public/tags/Typora/index.html","hash":"01a391d2351733ee177fdc0312736b347953b095","modified":1723901147971},{"_id":"public/tags/Markdown/index.html","hash":"89c9e4cf23fd873f72dd327a22a21d735163ab4a","modified":1723901147971},{"_id":"public/tags/随笔/index.html","hash":"49118c72e7c5569cdcc184fee8c27828b39d93de","modified":1723901147971},{"_id":"public/tags/子序列自动机/index.html","hash":"cc5bfb384e67c301d790fd9ca6afeead78876483","modified":1723901147971},{"_id":"public/tags/坐标系转换/index.html","hash":"35fa2dfc676b54ee2bd44fd9814e632f95890606","modified":1723901147971},{"_id":"public/tags/几何问题/index.html","hash":"cebbd4068078fe7965a86e6f527b2107767b6653","modified":1723901147971},{"_id":"public/tags/树问题，哈希算法/index.html","hash":"f82b3df166de151b45b9290dd2549c78c1a3858a","modified":1723901147971},{"_id":"public/tags/异或问题/index.html","hash":"d6255e186cfdc13d2693d22af228722cb4ff0dba","modified":1723901147971},{"_id":"public/tags/离散化/index.html","hash":"aa6a01b807cdd7a547448545a0324dc6f1dc4d89","modified":1723901147971},{"_id":"public/tags/机器学习/index.html","hash":"76cdc6d46ff89177bc6702ca2755745cb19852e9","modified":1723901147971},{"_id":"public/tags/MindSpore/index.html","hash":"b3b959a6eb2cdcc97ba1d2ad15f2d94ff3d08c2a","modified":1723901147971},{"_id":"public/tags/目录/index.html","hash":"fc506261ddad1771dca58839b6ffa4d3b22e771b","modified":1723901147971},{"_id":"public/tags/加密算法/index.html","hash":"c21cb0265f260ca5549f5ec7d25d802be85d2381","modified":1723901147971},{"_id":"public/tags/ECC/index.html","hash":"0de5f8b4466af08e958b6fcdd03b576a9b54daa3","modified":1723901147971},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1723811152830},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1723811152830},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1723811152830},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1723811152830},{"_id":"public/images/logo.svg","hash":"d0ed8b5372385b71b533c985d0a3d84de851dfaf","modified":1723811152830},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1723811152830},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1723811152830},{"_id":"public/images/beian.png","hash":"797721756b99b7841cee366f62ac52a1207cdcb7","modified":1723811152830},{"_id":"public/images/apple-touch-icon.png","hash":"64a9ea04f5bb7fef316fa416a7bf9e5e9489c291","modified":1723811152830},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1723811152830},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1723811152830},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1723811152830},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1723811152830},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1723811152830},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1723811152830},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1723811152830},{"_id":"public/images/favicon-16x16.png","hash":"c3cc1168e2d338fbefc5f8da977a73a7b9a4975c","modified":1723811152830},{"_id":"public/images/favicon-32x32.png","hash":"8be81b95697df7f526646702889ca5483f51ccad","modified":1723811152830},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1723811152830},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1723811152830},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1723811152830},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1723811152830},{"_id":"public/css/noscript.css","hash":"4cd5301e478e0e0d4b176740ec314087ec5cb707","modified":1723811152830},{"_id":"public/js/next-boot.js","hash":"8e2d589585f5270ee90285d3e65b69923c7629d8","modified":1723811152830},{"_id":"public/js/motion.js","hash":"8e587c086e3cf8687108fbb3241fe1534c3df463","modified":1723811152830},{"_id":"public/js/pjax.js","hash":"adc751f9b63b7a6b4d381506d35a1b3ff4de891f","modified":1723811152830},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1723811152830},{"_id":"public/js/sidebar.js","hash":"b3289010a0cb52c525b1395db72bd463424f2f48","modified":1723811152830},{"_id":"public/js/third-party/addtoany.js","hash":"5276c8f78ee562a8965216dc67d762e59cb4a9f2","modified":1723811152830},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1723811152830},{"_id":"public/js/third-party/fancybox.js","hash":"819f382c561fe5ec23c67cc5fabd63dd1cc22dc1","modified":1723811152830},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1723811152830},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"def07bcc7c17d8a0caad177fb1dd2f3a5e5b3536","modified":1723811152830},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1723811152830},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1723811152830},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1723811152830},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1723811152830},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1723811152830},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1723811152830},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1723811152830},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1723811152830},{"_id":"public/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1723811152830},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1723811152830},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1723811152830},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1723811152830},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1723811152830},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1723811152830},{"_id":"public/js/third-party/tags/mermaid.js","hash":"6bf821310342c5b87a631873e7650a475a0765f1","modified":1723811152830},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1723811152830},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1723811152830},{"_id":"public/js/third-party/tags/wavedrom.js","hash":"40dcd10df6edf124088c329346e0cc0bdac74ef1","modified":1723811152830},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1723811152830},{"_id":"public/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1723811152830},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1723811152830},{"_id":"public/css/main.css","hash":"8ca728d20a3c8aee3d477d034fa4bfd38cad9d4a","modified":1723811152830},{"_id":"public/js/utils.js","hash":"f92420649b150703469bba41cbd5c72768beed88","modified":1723811152830},{"_id":"public/images/wechat_channel.jpg","hash":"25d7ebd0b18bb44a9013adbe2b6cd82919f4c291","modified":1723811152830},{"_id":"public/images/alipay.jpg","hash":"1d531329226cfd0fde8e936f9019eec57169945b","modified":1723811152830},{"_id":"public/images/wechatpay.jpg","hash":"28bab154ea159faf803c3c832cc7da5eb62c7396","modified":1723811152830},{"_id":"public/images/qq-contact.png","hash":"255274d1b43901c2a5a14daaa540346dc62602c4","modified":1723811152830},{"_id":"public/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","hash":"ea8a10b275222aa4fe6004ea90dfb8b7619893ca","modified":1723811152830},{"_id":"public/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","hash":"85ea4d5ef41451cc6d78520f9b8e9c934f3c45f6","modified":1723811152830},{"_id":"source/_posts/special_subject/NationalPGExamination/Politics/NoteForMY.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1720434185283},{"_id":"source/_posts/special_subject/NationalPGExamination/catelogue.md","hash":"53eddddb4fc5ef7413ac4ba86b4886e16aabc49b","modified":1723900511323},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/RecordNote.md","hash":"2d925b5ea80d1bf15fcbaf61cfa63a0674db8be9","modified":1721707480000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-数构篇.md","hash":"91e10d3f7f791d66755170e292db7353f7b842a4","modified":1723900757073},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-系统篇.md","hash":"57822b917e7d03f1d181ac6d8124088d604db2b1","modified":1723900715858},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-计组篇.md","hash":"69aee6f511e10cef87c4e5e7bfbe6b883b08ffc7","modified":1723900718779},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-计网篇.md","hash":"7f4f7c096fc29c11ad3fc71019281b52ef11e3a4","modified":1723900723531},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/config","hash":"80de82dfd57795eed1fcbc83b7a9a318eb9e3b20","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/IO.md","hash":"ce6394776abfb087446a17af5539d0dabd4a9ba0","modified":1723900897125},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/各个硬件及其相关工作原理.md","hash":"5b595ac55a8a5c408627b677e32fe33d5f0aca12","modified":1723900908999},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第三章.md","hash":"72fca4a3277a2fe2b2b99022643afe601910f420","modified":1723900944464},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/补充.md","hash":"04df6f51f136f18192bfc999ed6404af7667c82f","modified":1723900973907},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第一章.md","hash":"c9ecfeff0ad9ffefcb0851ff104118f8a5c73cc9","modified":1723900932197},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/数据链路层.md","hash":"c003e74ca5b382889c0d6a4397e542cb9e3e590b","modified":1723901045623},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/三种可靠传输协议.md","hash":"a984c1abe0ae7ed3bc189e121727a2af6f42aaf2","modified":1723901024574},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/奈氏定理与香农法则.md","hash":"ebda3a02b95ca9f3e4a8a1f38bf34395f829c53f","modified":1723901034192},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/概要以及杂项.md","hash":"78f2ddd3427e64f079375b353bd39112810a261e","modified":1723901067182},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/三种交换方式.md","hash":"8d87bf4620f0629253318e2c4786d4420f68d5e8","modified":1723901000086},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/物理层.md","hash":"e7b3761afef99e820280061d19405de83d9c1a60","modified":1723901080068},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/网络层.md","hash":"eb9dee1620d68fc74c1eae11e0363040c55db75f","modified":1723901091481},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/补充.md","hash":"5445919c38168007cd966477304ed8813d724c3a","modified":1723901109188},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/计算机网络的分层结构.md","hash":"452e0ff7510b256ae1243566c9a19875386c02fe","modified":1723901123820},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/运输层.md","hash":"8ed68ae05a40a903d97593a0a135f7c1afa5adc6","modified":1723901137159},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第二章.md","hash":"57bfa0ec13fe24a0c5e68cc56a613270d6f6ff01","modified":1723900958164},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/DataStructure/补充.md","hash":"e3c810905d05216e7c3c0d34c0cf852313ac23fa","modified":1723900842470},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/DataStructure/FirstRoundReview.md","hash":"f3ff30d834c5238bc4a8f0c8a346268675d18273","modified":1723900860471},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/OperationSystem/补充.md","hash":"08a8db9ea54add92459523764c1317c646bf36fd","modified":1723900831349},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/fsmonitor-watchman.sample","hash":"0ec0ec9ac11111433d17ea79e0ae8cec650dcfa4","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/pre-commit.sample","hash":"8093d68e142db52dcab2215e770ba0bbe4cfbf24","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/sendemail-validate.sample","hash":"74cf1d5415a5c03c110240f749491297d65c4c98","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1722495084000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/2025王道计算机网络【公众号：有岸上】免费分享.pdf","hash":"5b1e33cab000c02ad142c169fce134c34ab7d55a","modified":1721523467000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/2025王道计算机组成原理【公众号：有岸上】免费分享.pdf","hash":"b5fa47d0376700ff32a8419c53e5910999e464bc","modified":1721523469000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/2025王道操作系统（带书签）.pdf","hash":"4c2f2cb8b8ce124a7fd2a4411d6cb1fe7721de88","modified":1721523468000},{"_id":"source/_posts/special_subject/NationalPGExamination/ProfessionalCources/2025王道数据结构【公众号：有岸上】免费分享.pdf","hash":"3d83631c61143c84ff7e9995caf953262038d23b","modified":1721523469000},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/RecordNote/article.html","hash":"373074354fab2eeab63c80f63653da2e1a534dd7","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/Politics/NoteForMY/article.html","hash":"ff52b8d259c46062099560c231ea61cb7b5576c6","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/catelogue/article.html","hash":"9630d60f24eaa334fe99c3fab71d375828edcf98","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-计网篇/article.html","hash":"e0e10f660c8caa15ed56779f17e5e1737235db12","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-系统篇/article.html","hash":"19007dc4c4d5e2f86d837f6c940cc2dea6fcb118","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-计组篇/article.html","hash":"4949b1d6bfe1f7aa028236512595f94356db0a72","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-数构篇/article.html","hash":"442dc4b5f146b109409b058531b4ab29fbf8952e","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/IO/article.html","hash":"52461f74b2b5469cbbd83f2ce4c2309c1aeefbc5","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/各个硬件及其相关工作原理/article.html","hash":"eae68652232519be5704b44de6a99429ac1926b7","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第三章/article.html","hash":"44c27a20d9b9d2347f117821e6c12a1dfc64be51","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第一章/article.html","hash":"ef15cec3dc848b43f46d7ea31a580c8305548729","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/三种交换方式/article.html","hash":"7b068ad412c842c8499df908cc003970ced53797","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/补充/article.html","hash":"a8539bcb753311ed2e55905e6f170e4bd04fac5d","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/三种可靠传输协议/article.html","hash":"ea346f01c0d49913705addcdc40c158903733690","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第二章/article.html","hash":"f142f7cfbd98b62f297bf185ba15d9d48c60528c","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/奈氏定理与香农法则/article.html","hash":"e1f5419974ef1e3df8e207fc465fa45bab9133be","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/数据链路层/article.html","hash":"9080c35f7a2beae1d314fafa19fefd0cf368feb9","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/概要以及杂项/article.html","hash":"cc8277fad44593e2d7f697e99af47d3c01548026","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/物理层/article.html","hash":"eddcd1662f27b2764d73cb0b0db1d2e0648423da","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/运输层/article.html","hash":"b5d4c54ce1c3c0f992bc1d47b83e2922cc3fd780","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/网络层/article.html","hash":"020fd066f4e1f47a7c1fa16794d9ce480ff102ff","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/计算机网络的分层结构/article.html","hash":"59dbe0fdc9c19786257d5fdd1770f61a514b075c","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/DataStructure/FirstRoundReview/article.html","hash":"8b132f7d380db148c7db3366681839aa51ec14a0","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/补充/article.html","hash":"cd6e3e561d066e231238b45738a37a98c14f849b","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/OperationSystem/补充/article.html","hash":"ea2ed5f8c4606e33cbe72e2a9914efa3dd93db43","modified":1723901147971},{"_id":"public/2024/special_subject/NationalPGExamination/ProfessionalCources/DataStructure/补充/article.html","hash":"0a7fcfe770fdb84b2c483cfbaa3533e4ca259b91","modified":1723901147971},{"_id":"public/categories/专题/page/2/index.html","hash":"92472cddebe284087f9b5e7f8f33921fb4165a46","modified":1723901147971},{"_id":"public/categories/专题/考研科目复习/index.html","hash":"661d935b269f9902c631d864ad02a2bbc3e465b7","modified":1723901147971},{"_id":"public/categories/专题/考研科目复习/目录/index.html","hash":"5029b881b42c095f9e2735ff360f45af7746546e","modified":1723901147971},{"_id":"public/en/2024/special_subject/NationalPGExamination/catelogue/article.html","hash":"0ef6855e4c03e9c0397c65898a240b10ccafb8dc","modified":1723901147971},{"_id":"public/ja/2024/special_subject/NationalPGExamination/catelogue/article.html","hash":"d039512822c2afbdab6dcd4c4abd00996fe70a53","modified":1723901147971},{"_id":"public/ru/2024/special_subject/NationalPGExamination/catelogue/article.html","hash":"af1162a8fc183cdaf37859514137d0407a4f6ae8","modified":1723901147971},{"_id":"public/ja/2024/special_subject/NationalPGExamination/ProfessionalCources/RecordNote/article.html","hash":"63cf502793eb87ac550e7f3b8a2a0b9ea52102d7","modified":1723901147971},{"_id":"public/en/2024/special_subject/NationalPGExamination/ProfessionalCources/RecordNote/article.html","hash":"12160600335b7fde9bc2c00dc438079278a9714e","modified":1723901147971},{"_id":"public/ru/2024/special_subject/NationalPGExamination/ProfessionalCources/RecordNote/article.html","hash":"96bfab21a4f49d4ff2e658e8a7863254e2eee2c6","modified":1723901147971},{"_id":"public/ja/2024/special_subject/NationalPGExamination/Politics/NoteForMY/article.html","hash":"888aada60c95d7fc4d9523683494b086b147b87c","modified":1723901147971},{"_id":"public/ru/2024/special_subject/NationalPGExamination/Politics/NoteForMY/article.html","hash":"3781717cb01f626e4f0139f24f095974515858e4","modified":1723901147971},{"_id":"public/en/2024/special_subject/NationalPGExamination/Politics/NoteForMY/article.html","hash":"ec8b0454952dfe078eee34f72fb4a93530355b36","modified":1723901147971},{"_id":"public/en/categories/专题/page/2/index.html","hash":"10177bf3cbc4075c63aa920232bf2e780c5143e0","modified":1723901147971},{"_id":"public/ru/categories/专题/page/2/index.html","hash":"f5e1518eff9a1d794f25a7d16cc2d044a7a2cfff","modified":1723901147971},{"_id":"public/ja/categories/专题/page/2/index.html","hash":"b7df5da77744bbcfcad0484d82e6791e4dadc8bb","modified":1723901147971},{"_id":"public/en/categories/专题/考研科目复习/index.html","hash":"2aeb8f6806827b1c289098155c0ddb0ad0322c71","modified":1723901147971},{"_id":"public/ja/categories/专题/考研科目复习/index.html","hash":"b5512df317a36a5c7119aa9c677ec9783c5e95f3","modified":1723901147971},{"_id":"public/ru/categories/专题/考研科目复习/index.html","hash":"a07ae301a3b15ed5c052774a8dfa8f98a85c3a53","modified":1723901147971},{"_id":"public/en/categories/专题/考研科目复习/目录/index.html","hash":"3468cfb9d42940b972ddbd3d36494033cd56eb1b","modified":1723901147971},{"_id":"public/ja/categories/专题/考研科目复习/目录/index.html","hash":"0258484f17b444a2360d5f6a041d2855e132ec1e","modified":1723901147971},{"_id":"public/ru/categories/专题/考研科目复习/目录/index.html","hash":"3a8027170581df57fd99c7263fc4fcfa59f26e4d","modified":1723901147971},{"_id":"public/tags/目录/page/2/index.html","hash":"62de8bcaf26123f5622b38d3f1095caf44401ee3","modified":1723901147971},{"_id":"public/tags/英语/index.html","hash":"4d5729abecb3d571d1e58c93f6c1a043521676eb","modified":1723901147971},{"_id":"public/tags/计算机网络/index.html","hash":"a9975985934e560355db3bddb31fed9d7c25c81e","modified":1723901147971},{"_id":"public/tags/计算机组成原理/index.html","hash":"e7ee0b6d2b13c17818f99ef1f5975bbc5d7170ca","modified":1723901147971},{"_id":"public/tags/操作系统/index.html","hash":"3d4660891c4dd397d2693aab7504a53d45412d60","modified":1723901147971},{"_id":"public/tags/考研/index.html","hash":"3d0e8b741705aa434581b238c06db29b7b1cbeaa","modified":1723901147971}],"Category":[{"name":"比赛","_id":"clzwonja30004lowv1e3t6mrq"},{"name":"模拟赛","parent":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjab000olowvayn3cxrt"},{"name":"软件","_id":"clzwonjae0012lowv7vxfgpd0"},{"name":"信息安全","_id":"clzwonjaj001rlowv3qql2zjb"},{"name":"日常赛","parent":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjal001vlowv0c0g60d8"},{"name":"ccpc邀请赛","parent":"clzwonjab000olowvayn3cxrt","_id":"clzwonjam0020lowv3flmdjix"},{"name":"算法","_id":"clzwonjao0029lowv45plfo8p"},{"name":"icpc邀请赛","parent":"clzwonjab000olowvayn3cxrt","_id":"clzwonjao002glowvb92oh9wa"},{"name":"icpc省赛","parent":"clzwonjab000olowvayn3cxrt","_id":"clzwonjap002qlowvg0hj2szx"},{"name":"蓝桥模拟","parent":"clzwonjab000olowvayn3cxrt","_id":"clzwonjaq002xlowvc6pu8ggz"},{"name":"工具类软件","parent":"clzwonjae0012lowv7vxfgpd0","_id":"clzwonjar0034lowv7l7b0jif"},{"name":"手册","parent":"clzwonjae0012lowv7vxfgpd0","_id":"clzwonjar0037lowvd4672z7z"},{"name":"编辑器","parent":"clzwonjae0012lowv7vxfgpd0","_id":"clzwonjas003blowveonufgwf"},{"name":"经典库","parent":"clzwonjae0012lowv7vxfgpd0","_id":"clzwonjat003slowvasqqfkoa"},{"name":"专题","_id":"clzwonjaw004mlowv3noo7a89"},{"name":"加密算法","parent":"clzwonjaj001rlowv3qql2zjb","_id":"clzwonjax004qlowvb6i375xh"},{"name":"学术","_id":"clzwonjax004ulowvdb310zjs"},{"name":"newcoder","parent":"clzwonjal001vlowv0c0g60d8","_id":"clzwonjay0050lowvfatk41y7"},{"name":"思维题","parent":"clzwonjao0029lowv45plfo8p","_id":"clzwonjb0005hlowv5dgq56nm"},{"name":"atcoder","parent":"clzwonjal001vlowv0c0g60d8","_id":"clzwonjb2005mlowvaqz5521c"},{"name":"数学","parent":"clzwonjao0029lowv45plfo8p","_id":"clzwonjb3005rlowvdrp02pht"},{"name":"Markdown","parent":"clzwonjas003blowveonufgwf","_id":"clzwonjb40060lowv51qccr9g"},{"name":"字符串","parent":"clzwonjao0029lowv45plfo8p","_id":"clzwonjb50063lowvf4kje1uc"},{"name":"信息安全","parent":"clzwonjat003slowvasqqfkoa","_id":"clzwonjb6006blowv4my1d22r"},{"name":"图论","parent":"clzwonjao0029lowv45plfo8p","_id":"clzwonjb6006jlowv9szw0e31"},{"name":"前端","parent":"clzwonjat003slowvasqqfkoa","_id":"clzwonjb7006qlowvb9md2fzb"},{"name":"状态转移","parent":"clzwonjao0029lowv45plfo8p","_id":"clzwonjb7006vlowvd0aq20fw"},{"name":"机器学习","parent":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjb8007blowva138bibb"},{"name":"数学","parent":"clzwonjax004qlowvb6i375xh","_id":"clzwonjb9007flowv00zcatng"},{"name":"综述","parent":"clzwonjax004ulowvdb310zjs","_id":"clzwonjb9007ilowve8127rg3"},{"name":"模运算","parent":"clzwonjb0005hlowv5dgq56nm","_id":"clzwonjbb0083lowvgifs708v"},{"name":"博弈论","parent":"clzwonjb3005rlowvdrp02pht","_id":"clzwonjbc0086lowvg0nl4dxd"},{"name":"贪心","parent":"clzwonjb0005hlowv5dgq56nm","_id":"clzwonjbc008blowv2p5ify94"},{"name":"子序列自动机","parent":"clzwonjb50063lowvf4kje1uc","_id":"clzwonjbd008glowvcvz30pdf"},{"name":"图论中的回文问题","parent":"clzwonjb6006jlowv9szw0e31","_id":"clzwonjbd008klowvgbq279uy"},{"name":"node","parent":"clzwonjb7006qlowvb9md2fzb","_id":"clzwonjbe008plowvb9f4e4v2"},{"name":"状态转移中的异或问题","parent":"clzwonjb7006vlowvd0aq20fw","_id":"clzwonjbe008tlowvcm0lgzcv"},{"name":"复杂状态转移与优化","parent":"clzwonjb7006vlowvd0aq20fw","_id":"clzwonjbe008wlowvbqo5hz6e"},{"name":"Mindspore","parent":"clzwonjb8007blowva138bibb","_id":"clzwonjbe008zlowv54lq6yk3"},{"name":"基本概念","parent":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbg009elowv4fo36rn2"},{"name":"考研科目复习","parent":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qq00004m8wve1rscwwj"},{"name":"错题本","parent":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qq6000bm8wvcrouf33u"},{"name":"目录","parent":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qq8000fm8wvgulr6zj1"},{"name":"专业课","parent":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqg0015m8wvh4rxfhww"}],"Data":[{"_id":"languages","data":{"zh-CN":{"post":{"copyright":{"author":"本文博主"},"comments":{"comments":"评论","write":"编写","preview":"预览"}},"menu":{"monitor":"监控器","categories":"分类"}},"en":{"menu":{"schedule":"Calendar"}}}}],"Page":[{"_content":"!(function() {\n  /** 计时起始时间，自行修改 **/\n  var start = new Date(\"2021/11/17 15:28:57\");\n\n  function update() {\n    var now = new Date();\n    now.setTime(now.getTime()+250);\n    days = (now - start) / 1000 / 60 / 60 / 24;\n    dnum = Math.floor(days);\n    hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n    hnum = Math.floor(hours);\n    if(String(hnum).length === 1 ){\n      hnum = \"0\" + hnum;\n    }\n    minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n    mnum = Math.floor(minutes);\n    if(String(mnum).length === 1 ){\n      mnum = \"0\" + mnum;\n    }\n    seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n    snum = Math.round(seconds);\n    if(String(snum).length === 1 ){\n      snum = \"0\" + snum;\n    }\n    document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行&nbsp\"+dnum+\"&nbsp天\";\n    document.getElementById(\"times\").innerHTML = hnum + \"&nbsp小时&nbsp\" + mnum + \"&nbsp分&nbsp\" + snum + \"&nbsp秒\";\n  }\n\n  update();\n  setInterval(update, 1000);\n})();","source":"runtime.js","raw":"!(function() {\n  /** 计时起始时间，自行修改 **/\n  var start = new Date(\"2021/11/17 15:28:57\");\n\n  function update() {\n    var now = new Date();\n    now.setTime(now.getTime()+250);\n    days = (now - start) / 1000 / 60 / 60 / 24;\n    dnum = Math.floor(days);\n    hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n    hnum = Math.floor(hours);\n    if(String(hnum).length === 1 ){\n      hnum = \"0\" + hnum;\n    }\n    minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n    mnum = Math.floor(minutes);\n    if(String(mnum).length === 1 ){\n      mnum = \"0\" + mnum;\n    }\n    seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n    snum = Math.round(seconds);\n    if(String(snum).length === 1 ){\n      snum = \"0\" + snum;\n    }\n    document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行&nbsp\"+dnum+\"&nbsp天\";\n    document.getElementById(\"times\").innerHTML = hnum + \"&nbsp小时&nbsp\" + mnum + \"&nbsp分&nbsp\" + snum + \"&nbsp秒\";\n  }\n\n  update();\n  setInterval(update, 1000);\n})();","date":"2024-08-16T11:53:54.785Z","updated":"2024-08-16T08:53:49.937Z","path":"runtime.js","layout":"false","title":"","comments":1,"_id":"clzwonj9x0000lowv9tnabgbm","content":"!(function() {\n  /** 计时起始时间，自行修改 **/\n  var start = new Date(\"2021/11/17 15:28:57\");\n\n  function update() {\n    var now = new Date();\n    now.setTime(now.getTime()+250);\n    days = (now - start) / 1000 / 60 / 60 / 24;\n    dnum = Math.floor(days);\n    hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n    hnum = Math.floor(hours);\n    if(String(hnum).length === 1 ){\n      hnum = \"0\" + hnum;\n    }\n    minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n    mnum = Math.floor(minutes);\n    if(String(mnum).length === 1 ){\n      mnum = \"0\" + mnum;\n    }\n    seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n    snum = Math.round(seconds);\n    if(String(snum).length === 1 ){\n      snum = \"0\" + snum;\n    }\n    document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行&nbsp\"+dnum+\"&nbsp天\";\n    document.getElementById(\"times\").innerHTML = hnum + \"&nbsp小时&nbsp\" + mnum + \"&nbsp分&nbsp\" + snum + \"&nbsp秒\";\n  }\n\n  update();\n  setInterval(update, 1000);\n})();"},{"title":"关于","date":"2024-08-14T07:06:43.000Z","_content":"\n# 注意事项\n***网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主***\nps：我也将尽力保留数据\n\n这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链\n\n## **Little Resume**\n\n博主: Deepcity\n\n职业: 研究生\n\n电子邮箱: f1159472899@163.com\n\n## 友链\n\n{% linkgrid %}\nBraumAce | https://blog.braumace.cn/ByteLighting/ | 一个后端开发者 | https://blog.braumace.cn/ByteLighting/BraumAce.jpg\n{% endlinkgrid %}\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2024-08-14 15:06:43\n---\n\n# 注意事项\n***网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主***\nps：我也将尽力保留数据\n\n这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链\n\n## **Little Resume**\n\n博主: Deepcity\n\n职业: 研究生\n\n电子邮箱: f1159472899@163.com\n\n## 友链\n\n{% linkgrid %}\nBraumAce | https://blog.braumace.cn/ByteLighting/ | 一个后端开发者 | https://blog.braumace.cn/ByteLighting/BraumAce.jpg\n{% endlinkgrid %}\n","updated":"2024-08-14T13:51:09.539Z","path":"about/index.html","comments":1,"layout":"page","_id":"clzwonja10002lowv7gva7lz4","content":"<h1 id=\"注意事项\">注意事项</h1>\r\n<p><strong><em>网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主</em></strong>\r\nps：我也将尽力保留数据</p>\r\n<p>这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链</p>\r\n<h2 id=\"little-resume\"><strong>Little Resume</strong></h2>\r\n<p>博主: Deepcity</p>\r\n<p>职业: 研究生</p>\r\n<p>电子邮箱: f1159472899@163.com</p>\r\n<h2 id=\"友链\">友链</h2>\r\n<div class=\"link-grid\"><div class=\"link-grid-container\">\n<object class=\"link-grid-image\" data=\"https://blog.braumace.cn/ByteLighting/BraumAce.jpg\"></object>\n<p>BraumAce</p><p>一个后端开发者</p>\n<a href=\"https://blog.braumace.cn/ByteLighting/\"></a>\n</div></div>\r\n","length":143,"excerpt":"","more":"<h1 id=\"注意事项\">注意事项</h1>\r\n<p><strong><em>网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主</em></strong>\r\nps：我也将尽力保留数据</p>\r\n<p>这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链</p>\r\n<h2 id=\"little-resume\"><strong>Little Resume</strong></h2>\r\n<p>博主: Deepcity</p>\r\n<p>职业: 研究生</p>\r\n<p>电子邮箱: f1159472899@163.com</p>\r\n<h2 id=\"友链\">友链</h2>\r\n<div class=\"link-grid\"><div class=\"link-grid-container\">\n<object class=\"link-grid-image\" data=\"https://blog.braumace.cn/ByteLighting/BraumAce.jpg\"></object>\n<p>BraumAce</p><p>一个后端开发者</p>\n<a href=\"https://blog.braumace.cn/ByteLighting/\"></a>\n</div></div>\r\n"},{"title":"服务器日历","date":"2024-08-14T05:13:45.000Z","type":"schedule","_content":"","source":"schedule/index.md","raw":"---\ntitle: 服务器日历\ndate: 2024-08-14 13:13:45\ntype: schedule\n---\n","updated":"2024-08-14T12:03:54.657Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"clzwonja40006lowvcg09htix","content":"\r\n","length":0,"excerpt":"","more":"\r\n"},{"title":"分类","date":"2024-08-14T07:00:25.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2024-08-14 15:00:25\ntype: categories\n---\n","updated":"2024-08-16T09:16:17.808Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clzwonja50008lowv5x415mm9","content":"\r\n","length":0,"excerpt":"","more":"\r\n"},{"title":"标签","date":"2024-08-14T05:02:25.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2024-08-14 13:02:25\ntype: tags\n---","updated":"2024-08-14T05:14:48.261Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clzwonja6000alowv3rmt8qub","content":"\r\n","length":0,"excerpt":"","more":"\r\n"},{"title":"404","date":"2014-12-22T04:39:04.000Z","comments":0,"_content":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","source":"404/404.md","raw":"---\ntitle: '404'\ndate: 2014-12-22 12:39:04\ncomments: false\n---\n<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","updated":"2024-08-14T05:39:50.887Z","path":"404/404.html","layout":"page","_id":"clzwonja8000flowv3ngx0781","content":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\r\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\r\n</script>\r\n","length":17,"excerpt":"","more":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\r\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\r\n</script>\r\n"}],"Post":[{"title":"2024武汉ICPC邀请赛VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 武汉邀请赛VP\n\n### I.[Cyclic Apple Strings](https://codeforces.com/gym/105143/problem/I)\n\n<!--more-->\n\n计算第一个1后的0的段数\n\n```cpp\nvoid slove() {\n\tstring s;cin>>s;\n\tint f =0,cnt = 0;\n\tfor(int i = 0;i < s.size(); i ++)\n\t{\n\t\tf|=(s[i] == '1');\n\t\tif(s[i]=='0')\n\t\twhile(i+1 < s.size() && s[i+1] == '0')\n\t\t\ti++;\n\t\tif(f && s[i] =='0') cnt++;\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\nK.[Party Games](https://codeforces.com/gym/105143/problem/K)\n\n打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tint r = n % 4;\n\tif(r==0 || r==1) cout<<\"Fluttershy\\n\";\n\telse if(r==2 || r==3) cout<<\"Pinkie Pie\\n\";\n}\n```\n\nF. [Custom-Made Clothes](https://codeforces.com/gym/105143/problem/F)\n\n简单二分或者二分套二分(另一个二分二分第一次的下标)\n\n注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到$$n \\le 1000$$。\n\n考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。\n\n```cpp\nint query(int x,int y,int v){\n\tif(g[x][y]) return g[x][y] <= v;\n\tcout<<\"?\"<<x<<' '<<y<<' '<<v<<endl;\n\tcout.flush();\n\tint res ;cin>>res;\n\treturn res;\n}\n\nint get(int x,int y,int l=1,int r=mx){\n\tif(!g[x][y]) return g[x][y];\n\twhile(l<r){\n\t\tint mid=  l+r>>1;\n\t\tif(query(x,y,mid)) r=mid;\n\t\telse l = mid+1;\n\t}\n\treturn g[x][y] = l;\n}\n\nvoid slove() {\n\tcin>>n>>k;\n\tmx = n * n;\n\tint l=1,r=mx;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\tint now = n;\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\twhile(now && !query(now,i,mid))now--;\n\t\t\tcnt += now;\n\t\t\tif(!now) break;\n\t\t}\n\t\tif(cnt < k) r=mid;\n\t\telse l=mid+1; \n\t}\n\tcout<<r<<endl;\n}\n```\n\n\n\nB. [Countless Me](https://codeforces.com/gym/105143/problem/B)\n\n很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：\n\n取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。\n\n维护sum值，将高位的1拆分给低位。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tint ans =0;\n  for (ll i = 30; i >= 0; i--) {\n      if (((1ll << i) - 1) * n >= sum) continue;\n      ll num = min(n, sum / (1ll << i));\n      if (num == 0) continue;\n      sum -= num * (1ll << i);\n      ans |= 1ll <<  i;\n  }\n\tcout<<ans<<endl;\n}\n```\n\n下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。\n\nhack数据\n\n```txt\n2\n3 0\n-------\n2\n7 3\n```\n\n```cpp\nvoid slove() {\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int sum = 0;\n    for(int i=1;i<=n;i++) sum += a[i];\n\n    int ans =0,cnt = 0;\n    for(int i=31;~i;i--){\n        cnt = (cnt<<1) + (sum >>i &1);\n        if(cnt >= n) ans += (sum >> i &1) <<i;\n    }\n    cout<<ans<<endl;\n}\n```\n\nD.[ICPC](https://codeforces.com/gym/105143/problem/D)\n\nICPC!!!，估计很多人一看到这个名字和答案求法就跑了。\n\n但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。\n\n思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。\n\ndp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++) pre[i] = pre[i-1] + a[i];\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(pre[i] - pre[max(i-j-1,0)]\n\t\t\t\t,pre[min(n,i+j)]- pre[i-1]);\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(f1[i][j],f1[i-1][j-1]);\n\t\t}\n\t}\n\n\tfor(int i=n;i;i--) {\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf2[i][j] = max(f1[i][j],f2[i+1][j-1]);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tll t = 0;\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tt ^= j*max(f1[i][j],f2[i][j]);\n\t\t}\n\t\tans ^= (i+ t);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n","source":"_posts/2024武汉ICPC邀请赛VP.md","raw":"---\ntitle: 2024武汉ICPC邀请赛VP\ndate: 2024-08-14 19:46:31\ntags: [icpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- icpc邀请赛\n---\n\n## 武汉邀请赛VP\n\n### I.[Cyclic Apple Strings](https://codeforces.com/gym/105143/problem/I)\n\n<!--more-->\n\n计算第一个1后的0的段数\n\n```cpp\nvoid slove() {\n\tstring s;cin>>s;\n\tint f =0,cnt = 0;\n\tfor(int i = 0;i < s.size(); i ++)\n\t{\n\t\tf|=(s[i] == '1');\n\t\tif(s[i]=='0')\n\t\twhile(i+1 < s.size() && s[i+1] == '0')\n\t\t\ti++;\n\t\tif(f && s[i] =='0') cnt++;\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\nK.[Party Games](https://codeforces.com/gym/105143/problem/K)\n\n打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tint r = n % 4;\n\tif(r==0 || r==1) cout<<\"Fluttershy\\n\";\n\telse if(r==2 || r==3) cout<<\"Pinkie Pie\\n\";\n}\n```\n\nF. [Custom-Made Clothes](https://codeforces.com/gym/105143/problem/F)\n\n简单二分或者二分套二分(另一个二分二分第一次的下标)\n\n注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到$$n \\le 1000$$。\n\n考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。\n\n```cpp\nint query(int x,int y,int v){\n\tif(g[x][y]) return g[x][y] <= v;\n\tcout<<\"?\"<<x<<' '<<y<<' '<<v<<endl;\n\tcout.flush();\n\tint res ;cin>>res;\n\treturn res;\n}\n\nint get(int x,int y,int l=1,int r=mx){\n\tif(!g[x][y]) return g[x][y];\n\twhile(l<r){\n\t\tint mid=  l+r>>1;\n\t\tif(query(x,y,mid)) r=mid;\n\t\telse l = mid+1;\n\t}\n\treturn g[x][y] = l;\n}\n\nvoid slove() {\n\tcin>>n>>k;\n\tmx = n * n;\n\tint l=1,r=mx;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\tint now = n;\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\twhile(now && !query(now,i,mid))now--;\n\t\t\tcnt += now;\n\t\t\tif(!now) break;\n\t\t}\n\t\tif(cnt < k) r=mid;\n\t\telse l=mid+1; \n\t}\n\tcout<<r<<endl;\n}\n```\n\n\n\nB. [Countless Me](https://codeforces.com/gym/105143/problem/B)\n\n很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：\n\n取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。\n\n维护sum值，将高位的1拆分给低位。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tint ans =0;\n  for (ll i = 30; i >= 0; i--) {\n      if (((1ll << i) - 1) * n >= sum) continue;\n      ll num = min(n, sum / (1ll << i));\n      if (num == 0) continue;\n      sum -= num * (1ll << i);\n      ans |= 1ll <<  i;\n  }\n\tcout<<ans<<endl;\n}\n```\n\n下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。\n\nhack数据\n\n```txt\n2\n3 0\n-------\n2\n7 3\n```\n\n```cpp\nvoid slove() {\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int sum = 0;\n    for(int i=1;i<=n;i++) sum += a[i];\n\n    int ans =0,cnt = 0;\n    for(int i=31;~i;i--){\n        cnt = (cnt<<1) + (sum >>i &1);\n        if(cnt >= n) ans += (sum >> i &1) <<i;\n    }\n    cout<<ans<<endl;\n}\n```\n\nD.[ICPC](https://codeforces.com/gym/105143/problem/D)\n\nICPC!!!，估计很多人一看到这个名字和答案求法就跑了。\n\n但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。\n\n思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。\n\ndp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++) pre[i] = pre[i-1] + a[i];\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(pre[i] - pre[max(i-j-1,0)]\n\t\t\t\t,pre[min(n,i+j)]- pre[i-1]);\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(f1[i][j],f1[i-1][j-1]);\n\t\t}\n\t}\n\n\tfor(int i=n;i;i--) {\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf2[i][j] = max(f1[i][j],f2[i+1][j-1]);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tll t = 0;\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tt ^= j*max(f1[i][j],f2[i][j]);\n\t\t}\n\t\tans ^= (i+ t);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n","slug":"2024武汉ICPC邀请赛VP","published":1,"updated":"2024-08-15T04:51:18.015Z","comments":1,"layout":"post","photos":[],"_id":"clzwonj9z0001lowv8i5jbuer","content":"<h2 id=\"武汉邀请赛vp\">武汉邀请赛VP</h2>\r\n<h3 id=\"i.cyclic-apple-strings\">I.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSQ==\">Cyclic Apple\r\nStrings<i class=\"fa fa-external-link-alt\"></i></span></h3>\r\n<span id=\"more\"></span>\r\n<p>计算第一个1后的0的段数</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"type\">int</span> f =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i &lt; s.<span class=\"built_in\">size</span>(); i ++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tf|=(s[i] == <span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i<span class=\"number\">+1</span> &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; s[i<span class=\"number\">+1</span>] == <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f &amp;&amp; s[i] ==<span class=\"string\">&#x27;0&#x27;</span>) cnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>K.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSw==\">Party\r\nGames<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r = n % <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(r==<span class=\"number\">0</span> || r==<span class=\"number\">1</span>) cout&lt;&lt;<span class=\"string\">&quot;Fluttershy\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(r==<span class=\"number\">2</span> || r==<span class=\"number\">3</span>) cout&lt;&lt;<span class=\"string\">&quot;Pinkie Pie\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>F. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRg==\">Custom-Made\r\nClothes<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>简单二分或者二分套二分(另一个二分二分第一次的下标)</p>\r\n<p>注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到<span\r\nclass=\"math display\">\\[n \\le 1000\\]</span>。</p>\r\n<p>考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(g[x][y]) <span class=\"keyword\">return</span> g[x][y] &lt;= v;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;?&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;v&lt;&lt;endl;</span><br><span class=\"line\">\tcout.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> res ;cin&gt;&gt;res;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> l=<span class=\"number\">1</span>,<span class=\"type\">int</span> r=mx)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!g[x][y]) <span class=\"keyword\">return</span> g[x][y];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid=  l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">query</span>(x,y,mid)) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g[x][y] = l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\tmx = n * n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l=<span class=\"number\">1</span>,r=mx;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = n;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(now &amp;&amp; !<span class=\"built_in\">query</span>(now,i,mid))now--;</span><br><span class=\"line\">\t\t\tcnt += now;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!now) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &lt; k) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l=mid<span class=\"number\">+1</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>B. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vQg==\">Countless\r\nMe<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：</p>\r\n<p>取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。</p>\r\n<p>维护sum值，将高位的1拆分给低位。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans =<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (ll i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((<span class=\"number\">1ll</span> &lt;&lt; i) - <span class=\"number\">1</span>) * n &gt;= sum) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      ll num = <span class=\"built_in\">min</span>(n, sum / (<span class=\"number\">1ll</span> &lt;&lt; i));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      sum -= num * (<span class=\"number\">1ll</span> &lt;&lt; i);</span><br><span class=\"line\">      ans |= <span class=\"number\">1ll</span> &lt;&lt;  i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。</p>\r\n<p>hack数据</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">3 0</span><br><span class=\"line\">-------</span><br><span class=\"line\">2</span><br><span class=\"line\">7 3</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">31</span>;~i;i--)&#123;</span><br><span class=\"line\">        cnt = (cnt&lt;&lt;<span class=\"number\">1</span>) + (sum &gt;&gt;i &amp;<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt;= n) ans += (sum &gt;&gt; i &amp;<span class=\"number\">1</span>) &lt;&lt;i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>D.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRA==\">ICPC<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>ICPC!!!，估计很多人一看到这个名字和答案求法就跑了。</p>\r\n<p>但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。</p>\r\n<p>思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。</p>\r\n<p>dp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(pre[i] - pre[<span class=\"built_in\">max</span>(i-j<span class=\"number\">-1</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">\t\t\t\t,pre[<span class=\"built_in\">min</span>(n,i+j)]- pre[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f1[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf2[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f2[i<span class=\"number\">+1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tll t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tt ^= j*<span class=\"built_in\">max</span>(f1[i][j],f2[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans ^= (i+ t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1150,"excerpt":"<h2 id=\"武汉邀请赛vp\">武汉邀请赛VP</h2>\r\n<h3 id=\"i.cyclic-apple-strings\">I.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSQ==\">Cyclic Apple\r\nStrings<i class=\"fa fa-external-link-alt\"></i></span></h3>","more":"<p>计算第一个1后的0的段数</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"type\">int</span> f =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i &lt; s.<span class=\"built_in\">size</span>(); i ++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tf|=(s[i] == <span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i<span class=\"number\">+1</span> &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; s[i<span class=\"number\">+1</span>] == <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f &amp;&amp; s[i] ==<span class=\"string\">&#x27;0&#x27;</span>) cnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>K.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSw==\">Party\r\nGames<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r = n % <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(r==<span class=\"number\">0</span> || r==<span class=\"number\">1</span>) cout&lt;&lt;<span class=\"string\">&quot;Fluttershy\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(r==<span class=\"number\">2</span> || r==<span class=\"number\">3</span>) cout&lt;&lt;<span class=\"string\">&quot;Pinkie Pie\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>F. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRg==\">Custom-Made\r\nClothes<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>简单二分或者二分套二分(另一个二分二分第一次的下标)</p>\r\n<p>注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到<span\r\nclass=\"math display\">\\[n \\le 1000\\]</span>。</p>\r\n<p>考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(g[x][y]) <span class=\"keyword\">return</span> g[x][y] &lt;= v;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;?&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;v&lt;&lt;endl;</span><br><span class=\"line\">\tcout.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> res ;cin&gt;&gt;res;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> l=<span class=\"number\">1</span>,<span class=\"type\">int</span> r=mx)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!g[x][y]) <span class=\"keyword\">return</span> g[x][y];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid=  l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">query</span>(x,y,mid)) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g[x][y] = l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\tmx = n * n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l=<span class=\"number\">1</span>,r=mx;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = n;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(now &amp;&amp; !<span class=\"built_in\">query</span>(now,i,mid))now--;</span><br><span class=\"line\">\t\t\tcnt += now;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!now) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &lt; k) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l=mid<span class=\"number\">+1</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>B. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vQg==\">Countless\r\nMe<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：</p>\r\n<p>取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。</p>\r\n<p>维护sum值，将高位的1拆分给低位。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans =<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (ll i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((<span class=\"number\">1ll</span> &lt;&lt; i) - <span class=\"number\">1</span>) * n &gt;= sum) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      ll num = <span class=\"built_in\">min</span>(n, sum / (<span class=\"number\">1ll</span> &lt;&lt; i));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      sum -= num * (<span class=\"number\">1ll</span> &lt;&lt; i);</span><br><span class=\"line\">      ans |= <span class=\"number\">1ll</span> &lt;&lt;  i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。</p>\r\n<p>hack数据</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">3 0</span><br><span class=\"line\">-------</span><br><span class=\"line\">2</span><br><span class=\"line\">7 3</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">31</span>;~i;i--)&#123;</span><br><span class=\"line\">        cnt = (cnt&lt;&lt;<span class=\"number\">1</span>) + (sum &gt;&gt;i &amp;<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt;= n) ans += (sum &gt;&gt; i &amp;<span class=\"number\">1</span>) &lt;&lt;i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>D.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRA==\">ICPC<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>ICPC!!!，估计很多人一看到这个名字和答案求法就跑了。</p>\r\n<p>但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。</p>\r\n<p>思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。</p>\r\n<p>dp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(pre[i] - pre[<span class=\"built_in\">max</span>(i-j<span class=\"number\">-1</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">\t\t\t\t,pre[<span class=\"built_in\">min</span>(n,i+j)]- pre[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f1[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf2[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f2[i<span class=\"number\">+1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tll t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tt ^= j*<span class=\"built_in\">max</span>(f1[i][j],f2[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans ^= (i+ t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"2024江苏CCPC邀请赛-VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 江苏CCPC-VP\n\n## F. Download Speed Monitor\n\n[Problem - F - Codeforces](https://codeforces.com/gym/105161/problem/F)\n\n<!--more-->\n\n### 题意：\n\n您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。\n\n下载速度监视器的工作原理如下：从 $$(k-1)$$$ (秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 $$$k$$ (秒)开始，监视器将显示从 $$(i-k+1)$$$$ (秒)到 $$$$i$$(秒)再到 $$i$$ (秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于 $$1024$$ KiBps 时，下载速度监视器将以 MiBps 为单位显示结果。\n\n您的下载任务将持续 $$n$$ 秒。考虑到平均速度的计算间隔为 $$k$$ ，您想知道从 $k$$$ (秒)到 $$$$n$$ (秒)，监控器上将显示什么。\n\nNote: $$1$$$ MiBps $$$=1024$$$$ KiBps$$​.\n\n### 题解：\n\n签到题，双指针扫一下即可\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tll sum  = 0;\n\tfor(int i=1,j=1;i<=n;i++)\n\t{\n\t\tsum += a[i];\n\t\tif(i - j >= k) sum -= a[j ++];\n\t\tif(i - j + 1 < k) continue;\n\t\t// cout<<i<< ' '<<j<< ' ' <<sum<<endl;\n\t\tdouble spd = double(1.0 * sum / k);\n\t\tstring ad = \"KiBps\";\n\t\tif(spd >= 1024) spd /= 1024, ad = \"MiBps\";\n\t\tprintf(\"%.6lf\", spd);\n\t\tcout<<' '<<ad<<endl;\n\t}\n}\n```\n\n## G. Download Time Monitor\n\n[Problem - G - Codeforces](https://codeforces.com/gym/105161/problem/G)\n\n### 题意：\n\n您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。\n\n您使用的网络带宽为 $$B$$ MiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 $t_1$ 秒，大小为 $$a_1$$ MiB，而第二个文件开始下载的时间为 $$t_2$$ 秒，大小为 $$a_2$$ MiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在 $$B$$ MiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 $$\\frac{B}{2}$$ MiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。\n\n现在，您想知道两个文件完成下载各需要多长时间。\n\n### 题解：\n\n出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）\n\n这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。\n\n注意是下载花费时间而不是总时间\n\n这题浮点运算常数较大，开O2和解同步会比较好\n\n```cpp\n#pragma GCC optimize(2)\n#define FIO std::ios::sync_with_stdio(false);std::cin.tie(0);\n```\n\n```cpp\nvoid slove() {\n\tint B,t1,t2,a1,a2;\n\tcin>>B>>t1>>a1>>t2>>a2;\n\n\tint f = 0;\n\n\tif(t1 > t2){\n\t\tswap(t1,t2);swap(a1,a2);\n\t\tf=1;\n\t}\n\n\tdouble d = t2-t1;\n\tdouble a,b;\n\n\tif(d * B > a1){\n\t\ta = 1.0 *a1 / B;\n\t\tb = 1.0 *a2 / B;\n\t\td=0;\n\t}else {\n\t\ta1 -= d * B;\n\t\tif(a1 > a2) f^= 1,swap(a1,a2);\n\t\t// cout<<a1<< ' '<<a2<<endl;\n\t\ta = 1.0 *a1 / (1.0 *B/2);\n\t\tb = 1.0 *a1 / (1.0 *B/2) + 1.0 *(a2 - a1) /B;\n\t}\n\n\tif(!f) printf(\"%.9lf %.9lf\\n\",a + d, b);\n\telse printf(\"%.9lf %.9lf\\n\",b + d,a);\n}\n```\n\n## K. Number Deletion Game\n\n[Problem - K - Codeforces](https://codeforces.com/gym/105161/problem/K)\n\n### 题意：\n\n爱丽丝和鲍勃正在玩一个数字删除游戏。\n\n一开始，有 $$n$$$ 个整数 $$$a_ 1,a _ 2, \\ldots ,a _n$$ 。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除**大的数字**$$x$$$ ，并选择一个比 $$$x$$**小的非负整数 $$y$$$ ，然后在数字 $$$1,2,\\ldots, y$$$ 中各加一个。特别是可以选择 $$$y=0$$ ，在这种情况下不会添加任何数字。也就是说，删除 $$1$$ 时，不能添加任何数字。删除最后一个数字的人获胜。\n\n双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。\n\n### 题解：\n\n注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。\n\n另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。\n\n​\t那么对于最大值取$$1 \\to k$$成立，试证明对k+1成立，分类讨论\n\n\t1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\n\t1. k+1为偶数个，同理，Bob胜\n\ncoding\n\n```CPP\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tsort(a+1,a+1+n);\n\tint num = -1;\n\tfor(int i=n;i;i--)\n\t\tif(a[i] != a[n]) {\n\t\t\tnum = n-i;\n\t\t\tbreak;\n\t\t}\n\tif(num == -1) num = n;\n\t// cout<<num<<endl;\n\tif(num&1) puts(\"Alice\");\n\telse puts(\"Bob\");\n}\n```\n\n## I. Integer Reaction\n\n[Problem - I - Codeforces](https://codeforces.com/gym/105161/problem/I)\n\n###　题意：\n\n有一个由 $$n$$ 个整数组成的序列，从左到右编号为 $$1$$ 到 $$n$$ 。这些整数有两种颜色，分别是 $$0$$ 和 $$1$$ ，每个整数正好有一种颜色。这些整数按照从 $$1$$到 $$n$$ 的编号顺序进入多集合 $$S_1$$ 。\n\n每当一个新的整数 $$x$$ 进入 $$S_1$$ 时，你必须在 $$S_1$$ 中选择一个颜色与 $$x$$ 不同的整数 $$y$$ 与 $$x$$ 发生反应，使得 $$x$$ 和 $$y$$ 消失，反应产物 $$x+y$$ 插入另一个集合 $$S_2$$ 中。如果不存在这样的 $$y$$ ，则不会发生反应，只有 $$x$$ 会插入 $$S_1$$ 。\n\n给定整数序列和每个整数的颜色，求处理最后一个元素后 $$S_2$$​ 中最小元素的最大可能值。\n\n### 题解\n\n很简单，二分答案贪心维护$$S_1$$即可\n\n```cpp\nint ck(int x){\n\t// cout<<x<<endl;\n\tmultiset<int> ms;\n\tint c = -1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(c==-1){\n\t\t\tms.insert(a[i].x);\n\t\t\tc = a[i].y;\n\t\t}else {\n\t\t\tif(c == a[i].y){\n\t\t\t\tms.insert(a[i].x);\n\t\t\t}else if(ms.size()){\n\t\t\t\t// cout<<x-a[i].y<<endl;\n\t\t\t\tauto it = lower_bound(all(ms), x - a[i].x);\n\t\t\t\tif(it == ms.end()) return 0;\n\t\t\t\t// if(x==7)cout<<*it<<endl;\n\t\t\t\tms.erase(it);\n\t\t\t}else {\n\t\t\t\tms.insert(a[i].x);\n\t\t\t\tc = a[i].y;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n};\n\nvoid slove() {\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].x);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].y);\n\n\tint l = 1,r = INF;\n\twhile(l<r){\n\t\tint mid = l+r+1 >> 1;\n\t\tif(ck(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\n\tprintf(\"%d\\n\",l);\n}\n```\n\n","source":"_posts/2024江苏CCPC邀请赛-VP.md","raw":"---\ntitle: 2024江苏CCPC邀请赛-VP\ndate: 2024-08-14 19:46:31\ntags: [ccpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- ccpc邀请赛\n---\n\n## 江苏CCPC-VP\n\n## F. Download Speed Monitor\n\n[Problem - F - Codeforces](https://codeforces.com/gym/105161/problem/F)\n\n<!--more-->\n\n### 题意：\n\n您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。\n\n下载速度监视器的工作原理如下：从 $$(k-1)$$$ (秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 $$$k$$ (秒)开始，监视器将显示从 $$(i-k+1)$$$$ (秒)到 $$$$i$$(秒)再到 $$i$$ (秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于 $$1024$$ KiBps 时，下载速度监视器将以 MiBps 为单位显示结果。\n\n您的下载任务将持续 $$n$$ 秒。考虑到平均速度的计算间隔为 $$k$$ ，您想知道从 $k$$$ (秒)到 $$$$n$$ (秒)，监控器上将显示什么。\n\nNote: $$1$$$ MiBps $$$=1024$$$$ KiBps$$​.\n\n### 题解：\n\n签到题，双指针扫一下即可\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tll sum  = 0;\n\tfor(int i=1,j=1;i<=n;i++)\n\t{\n\t\tsum += a[i];\n\t\tif(i - j >= k) sum -= a[j ++];\n\t\tif(i - j + 1 < k) continue;\n\t\t// cout<<i<< ' '<<j<< ' ' <<sum<<endl;\n\t\tdouble spd = double(1.0 * sum / k);\n\t\tstring ad = \"KiBps\";\n\t\tif(spd >= 1024) spd /= 1024, ad = \"MiBps\";\n\t\tprintf(\"%.6lf\", spd);\n\t\tcout<<' '<<ad<<endl;\n\t}\n}\n```\n\n## G. Download Time Monitor\n\n[Problem - G - Codeforces](https://codeforces.com/gym/105161/problem/G)\n\n### 题意：\n\n您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。\n\n您使用的网络带宽为 $$B$$ MiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 $t_1$ 秒，大小为 $$a_1$$ MiB，而第二个文件开始下载的时间为 $$t_2$$ 秒，大小为 $$a_2$$ MiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在 $$B$$ MiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 $$\\frac{B}{2}$$ MiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。\n\n现在，您想知道两个文件完成下载各需要多长时间。\n\n### 题解：\n\n出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）\n\n这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。\n\n注意是下载花费时间而不是总时间\n\n这题浮点运算常数较大，开O2和解同步会比较好\n\n```cpp\n#pragma GCC optimize(2)\n#define FIO std::ios::sync_with_stdio(false);std::cin.tie(0);\n```\n\n```cpp\nvoid slove() {\n\tint B,t1,t2,a1,a2;\n\tcin>>B>>t1>>a1>>t2>>a2;\n\n\tint f = 0;\n\n\tif(t1 > t2){\n\t\tswap(t1,t2);swap(a1,a2);\n\t\tf=1;\n\t}\n\n\tdouble d = t2-t1;\n\tdouble a,b;\n\n\tif(d * B > a1){\n\t\ta = 1.0 *a1 / B;\n\t\tb = 1.0 *a2 / B;\n\t\td=0;\n\t}else {\n\t\ta1 -= d * B;\n\t\tif(a1 > a2) f^= 1,swap(a1,a2);\n\t\t// cout<<a1<< ' '<<a2<<endl;\n\t\ta = 1.0 *a1 / (1.0 *B/2);\n\t\tb = 1.0 *a1 / (1.0 *B/2) + 1.0 *(a2 - a1) /B;\n\t}\n\n\tif(!f) printf(\"%.9lf %.9lf\\n\",a + d, b);\n\telse printf(\"%.9lf %.9lf\\n\",b + d,a);\n}\n```\n\n## K. Number Deletion Game\n\n[Problem - K - Codeforces](https://codeforces.com/gym/105161/problem/K)\n\n### 题意：\n\n爱丽丝和鲍勃正在玩一个数字删除游戏。\n\n一开始，有 $$n$$$ 个整数 $$$a_ 1,a _ 2, \\ldots ,a _n$$ 。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除**大的数字**$$x$$$ ，并选择一个比 $$$x$$**小的非负整数 $$y$$$ ，然后在数字 $$$1,2,\\ldots, y$$$ 中各加一个。特别是可以选择 $$$y=0$$ ，在这种情况下不会添加任何数字。也就是说，删除 $$1$$ 时，不能添加任何数字。删除最后一个数字的人获胜。\n\n双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。\n\n### 题解：\n\n注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。\n\n另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。\n\n​\t那么对于最大值取$$1 \\to k$$成立，试证明对k+1成立，分类讨论\n\n\t1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\n\t1. k+1为偶数个，同理，Bob胜\n\ncoding\n\n```CPP\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tsort(a+1,a+1+n);\n\tint num = -1;\n\tfor(int i=n;i;i--)\n\t\tif(a[i] != a[n]) {\n\t\t\tnum = n-i;\n\t\t\tbreak;\n\t\t}\n\tif(num == -1) num = n;\n\t// cout<<num<<endl;\n\tif(num&1) puts(\"Alice\");\n\telse puts(\"Bob\");\n}\n```\n\n## I. Integer Reaction\n\n[Problem - I - Codeforces](https://codeforces.com/gym/105161/problem/I)\n\n###　题意：\n\n有一个由 $$n$$ 个整数组成的序列，从左到右编号为 $$1$$ 到 $$n$$ 。这些整数有两种颜色，分别是 $$0$$ 和 $$1$$ ，每个整数正好有一种颜色。这些整数按照从 $$1$$到 $$n$$ 的编号顺序进入多集合 $$S_1$$ 。\n\n每当一个新的整数 $$x$$ 进入 $$S_1$$ 时，你必须在 $$S_1$$ 中选择一个颜色与 $$x$$ 不同的整数 $$y$$ 与 $$x$$ 发生反应，使得 $$x$$ 和 $$y$$ 消失，反应产物 $$x+y$$ 插入另一个集合 $$S_2$$ 中。如果不存在这样的 $$y$$ ，则不会发生反应，只有 $$x$$ 会插入 $$S_1$$ 。\n\n给定整数序列和每个整数的颜色，求处理最后一个元素后 $$S_2$$​ 中最小元素的最大可能值。\n\n### 题解\n\n很简单，二分答案贪心维护$$S_1$$即可\n\n```cpp\nint ck(int x){\n\t// cout<<x<<endl;\n\tmultiset<int> ms;\n\tint c = -1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(c==-1){\n\t\t\tms.insert(a[i].x);\n\t\t\tc = a[i].y;\n\t\t}else {\n\t\t\tif(c == a[i].y){\n\t\t\t\tms.insert(a[i].x);\n\t\t\t}else if(ms.size()){\n\t\t\t\t// cout<<x-a[i].y<<endl;\n\t\t\t\tauto it = lower_bound(all(ms), x - a[i].x);\n\t\t\t\tif(it == ms.end()) return 0;\n\t\t\t\t// if(x==7)cout<<*it<<endl;\n\t\t\t\tms.erase(it);\n\t\t\t}else {\n\t\t\t\tms.insert(a[i].x);\n\t\t\t\tc = a[i].y;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n};\n\nvoid slove() {\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].x);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].y);\n\n\tint l = 1,r = INF;\n\twhile(l<r){\n\t\tint mid = l+r+1 >> 1;\n\t\tif(ck(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\n\tprintf(\"%d\\n\",l);\n}\n```\n\n","slug":"2024江苏CCPC邀请赛-VP","published":1,"updated":"2024-08-15T04:51:14.761Z","comments":1,"layout":"post","photos":[],"_id":"clzwonja20003lowv07qw214u","content":"<h2 id=\"江苏ccpc-vp\">江苏CCPC-VP</h2>\r\n<h2 id=\"f.-download-speed-monitor\">F. Download Speed Monitor</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRg==\">Problem - F -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"题意\">题意：</h3>\r\n<p>您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。</p>\r\n<p>下载速度监视器的工作原理如下：从 <span\r\nclass=\"math display\">\\[(k-1)\\]</span>$\r\n(秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 <span\r\nclass=\"math display\">\\[$k\\]</span> (秒)开始，监视器将显示从 <span\r\nclass=\"math display\">\\[(i-k+1)\\]</span><span class=\"math display\">\\[\r\n(秒)到 \\]</span><span class=\"math display\">\\[i\\]</span>(秒)再到 <span\r\nclass=\"math display\">\\[i\\]</span>\r\n(秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于\r\n<span class=\"math display\">\\[1024\\]</span> KiBps 时，下载速度监视器将以\r\nMiBps 为单位显示结果。</p>\r\n<p>您的下载任务将持续 <span class=\"math display\">\\[n\\]</span>\r\n秒。考虑到平均速度的计算间隔为 <span class=\"math display\">\\[k\\]</span>\r\n，您想知道从 <span class=\"math inline\">\\(k\\)</span><span\r\nclass=\"math display\">\\[ (秒)到 \\]</span><span\r\nclass=\"math display\">\\[n\\]</span> (秒)，监控器上将显示什么。</p>\r\n<p>Note: <span class=\"math display\">\\[1\\]</span>$ MiBps <span\r\nclass=\"math display\">\\[$=1024\\]</span><span class=\"math display\">\\[\r\nKiBps\\]</span>​.</p>\r\n<h3 id=\"题解\">题解：</h3>\r\n<p>签到题，双指针扫一下即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum  = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum += a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j &gt;= k) sum -= a[j ++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j + <span class=\"number\">1</span> &lt; k) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt; &#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">double</span> spd = <span class=\"built_in\">double</span>(<span class=\"number\">1.0</span> * sum / k);</span><br><span class=\"line\">\t\tstring ad = <span class=\"string\">&quot;KiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(spd &gt;= <span class=\"number\">1024</span>) spd /= <span class=\"number\">1024</span>, ad = <span class=\"string\">&quot;MiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.6lf&quot;</span>, spd);</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ad&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g.-download-time-monitor\">G. Download Time Monitor</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRw==\">Problem - G -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-1\">题意：</h3>\r\n<p>您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。</p>\r\n<p>您使用的网络带宽为 <span class=\"math display\">\\[B\\]</span>\r\nMiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 <span\r\nclass=\"math inline\">\\(t_1\\)</span> 秒，大小为 <span\r\nclass=\"math display\">\\[a_1\\]</span> MiB，而第二个文件开始下载的时间为\r\n<span class=\"math display\">\\[t_2\\]</span> 秒，大小为 <span\r\nclass=\"math display\">\\[a_2\\]</span>\r\nMiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在\r\n<span class=\"math display\">\\[B\\]</span>\r\nMiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 <span\r\nclass=\"math display\">\\[\\frac{B}{2}\\]</span>\r\nMiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。</p>\r\n<p>现在，您想知道两个文件完成下载各需要多长时间。</p>\r\n<h3 id=\"题解-1\">题解：</h3>\r\n<p>出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）</p>\r\n<p>这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。</p>\r\n<p>注意是下载花费时间而不是总时间</p>\r\n<p>这题浮点运算常数较大，开O2和解同步会比较好</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> GCC optimize(2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIO std::ios::sync_with_stdio(false);std::cin.tie(0);</span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> B,t1,t2,a1,a2;</span><br><span class=\"line\">\tcin&gt;&gt;B&gt;&gt;t1&gt;&gt;a1&gt;&gt;t2&gt;&gt;a2;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t1 &gt; t2)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(t1,t2);<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\tf=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">double</span> d = t2-t1;</span><br><span class=\"line\">\t<span class=\"type\">double</span> a,b;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(d * B &gt; a1)&#123;</span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / B;</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a2 / B;</span><br><span class=\"line\">\t\td=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\ta1 -= d * B;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a1 &gt; a2) f^= <span class=\"number\">1</span>,<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;a1&lt;&lt; &#x27; &#x27;&lt;&lt;a2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>) + <span class=\"number\">1.0</span> *(a2 - a1) /B;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,a + d, b);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,b + d,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-number-deletion-game\">K. Number Deletion Game</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSw==\">Problem - K -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-2\">题意：</h3>\r\n<p>爱丽丝和鲍勃正在玩一个数字删除游戏。</p>\r\n<p>一开始，有 <span class=\"math display\">\\[n\\]</span>$ 个整数 <span\r\nclass=\"math display\">\\[$a_ 1,a _ 2, \\ldots ,a _n\\]</span>\r\n。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除<strong>大的数字</strong><span\r\nclass=\"math display\">\\[x\\]</span>$ ，并选择一个比 <span\r\nclass=\"math display\">\\[$x\\]</span>**小的非负整数 <span\r\nclass=\"math display\">\\[y\\]</span>$ ，然后在数字 <span\r\nclass=\"math display\">\\[$1,2,\\ldots, y\\]</span>$\r\n中各加一个。特别是可以选择 <span class=\"math display\">\\[$y=0\\]</span>\r\n，在这种情况下不会添加任何数字。也就是说，删除 <span\r\nclass=\"math display\">\\[1\\]</span>\r\n时，不能添加任何数字。删除最后一个数字的人获胜。</p>\r\n<p>双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。</p>\r\n<h3 id=\"题解-2\">题解：</h3>\r\n<p>注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。</p>\r\n<p>另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。</p>\r\n<p>​ 那么对于最大值取<span class=\"math display\">\\[1 \\to\r\nk\\]</span>成立，试证明对k+1成立，分类讨论</p>\r\n<pre><code>1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\r\n1. k+1为偶数个，同理，Bob胜</code></pre>\r\n<p>coding</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> num = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i] != a[n]) &#123;</span><br><span class=\"line\">\t\t\tnum = n-i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num == <span class=\"number\">-1</span>) num = n;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;num&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num&amp;<span class=\"number\">1</span>) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"i.-integer-reaction\">I. Integer Reaction</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSQ==\">Problem - I -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>###　题意：</p>\r\n<p>有一个由 <span class=\"math display\">\\[n\\]</span>\r\n个整数组成的序列，从左到右编号为 <span class=\"math display\">\\[1\\]</span>\r\n到 <span class=\"math display\">\\[n\\]</span> 。这些整数有两种颜色，分别是\r\n<span class=\"math display\">\\[0\\]</span> 和 <span\r\nclass=\"math display\">\\[1\\]</span>\r\n，每个整数正好有一种颜色。这些整数按照从 <span\r\nclass=\"math display\">\\[1\\]</span>到 <span\r\nclass=\"math display\">\\[n\\]</span> 的编号顺序进入多集合 <span\r\nclass=\"math display\">\\[S_1\\]</span> 。</p>\r\n<p>每当一个新的整数 <span class=\"math display\">\\[x\\]</span> 进入 <span\r\nclass=\"math display\">\\[S_1\\]</span> 时，你必须在 <span\r\nclass=\"math display\">\\[S_1\\]</span> 中选择一个颜色与 <span\r\nclass=\"math display\">\\[x\\]</span> 不同的整数 <span\r\nclass=\"math display\">\\[y\\]</span> 与 <span\r\nclass=\"math display\">\\[x\\]</span> 发生反应，使得 <span\r\nclass=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> 消失，反应产物 <span\r\nclass=\"math display\">\\[x+y\\]</span> 插入另一个集合 <span\r\nclass=\"math display\">\\[S_2\\]</span> 中。如果不存在这样的 <span\r\nclass=\"math display\">\\[y\\]</span> ，则不会发生反应，只有 <span\r\nclass=\"math display\">\\[x\\]</span> 会插入 <span\r\nclass=\"math display\">\\[S_1\\]</span> 。</p>\r\n<p>给定整数序列和每个整数的颜色，求处理最后一个元素后 <span\r\nclass=\"math display\">\\[S_2\\]</span>​ 中最小元素的最大可能值。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>很简单，二分答案贪心维护<span\r\nclass=\"math display\">\\[S_1\\]</span>即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ck</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class=\"line\">\tmultiset&lt;<span class=\"type\">int</span>&gt; ms;</span><br><span class=\"line\">\t<span class=\"type\">int</span> c = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(c == a[i].y)&#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ms.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// cout&lt;&lt;x-a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">auto</span> it = <span class=\"built_in\">lower_bound</span>(<span class=\"built_in\">all</span>(ms), x - a[i].x);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(it == ms.<span class=\"built_in\">end</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// if(x==7)cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].x);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].y);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">1</span>,r = INF;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r<span class=\"number\">+1</span> &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">ck</span>(mid)) l = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1556,"excerpt":"<h2 id=\"江苏ccpc-vp\">江苏CCPC-VP</h2>\r\n<h2 id=\"f.-download-speed-monitor\">F. Download Speed Monitor</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRg==\">Problem - F -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h3 id=\"题意\">题意：</h3>\r\n<p>您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。</p>\r\n<p>下载速度监视器的工作原理如下：从 <span\r\nclass=\"math display\">\\[(k-1)\\]</span>$\r\n(秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 <span\r\nclass=\"math display\">\\[$k\\]</span> (秒)开始，监视器将显示从 <span\r\nclass=\"math display\">\\[(i-k+1)\\]</span><span class=\"math display\">\\[\r\n(秒)到 \\]</span><span class=\"math display\">\\[i\\]</span>(秒)再到 <span\r\nclass=\"math display\">\\[i\\]</span>\r\n(秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于\r\n<span class=\"math display\">\\[1024\\]</span> KiBps 时，下载速度监视器将以\r\nMiBps 为单位显示结果。</p>\r\n<p>您的下载任务将持续 <span class=\"math display\">\\[n\\]</span>\r\n秒。考虑到平均速度的计算间隔为 <span class=\"math display\">\\[k\\]</span>\r\n，您想知道从 <span class=\"math inline\">\\(k\\)</span><span\r\nclass=\"math display\">\\[ (秒)到 \\]</span><span\r\nclass=\"math display\">\\[n\\]</span> (秒)，监控器上将显示什么。</p>\r\n<p>Note: <span class=\"math display\">\\[1\\]</span>$ MiBps <span\r\nclass=\"math display\">\\[$=1024\\]</span><span class=\"math display\">\\[\r\nKiBps\\]</span>​.</p>\r\n<h3 id=\"题解\">题解：</h3>\r\n<p>签到题，双指针扫一下即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum  = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum += a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j &gt;= k) sum -= a[j ++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j + <span class=\"number\">1</span> &lt; k) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt; &#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">double</span> spd = <span class=\"built_in\">double</span>(<span class=\"number\">1.0</span> * sum / k);</span><br><span class=\"line\">\t\tstring ad = <span class=\"string\">&quot;KiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(spd &gt;= <span class=\"number\">1024</span>) spd /= <span class=\"number\">1024</span>, ad = <span class=\"string\">&quot;MiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.6lf&quot;</span>, spd);</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ad&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g.-download-time-monitor\">G. Download Time Monitor</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRw==\">Problem - G -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-1\">题意：</h3>\r\n<p>您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。</p>\r\n<p>您使用的网络带宽为 <span class=\"math display\">\\[B\\]</span>\r\nMiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 <span\r\nclass=\"math inline\">\\(t_1\\)</span> 秒，大小为 <span\r\nclass=\"math display\">\\[a_1\\]</span> MiB，而第二个文件开始下载的时间为\r\n<span class=\"math display\">\\[t_2\\]</span> 秒，大小为 <span\r\nclass=\"math display\">\\[a_2\\]</span>\r\nMiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在\r\n<span class=\"math display\">\\[B\\]</span>\r\nMiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 <span\r\nclass=\"math display\">\\[\\frac{B}{2}\\]</span>\r\nMiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。</p>\r\n<p>现在，您想知道两个文件完成下载各需要多长时间。</p>\r\n<h3 id=\"题解-1\">题解：</h3>\r\n<p>出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）</p>\r\n<p>这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。</p>\r\n<p>注意是下载花费时间而不是总时间</p>\r\n<p>这题浮点运算常数较大，开O2和解同步会比较好</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> GCC optimize(2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIO std::ios::sync_with_stdio(false);std::cin.tie(0);</span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> B,t1,t2,a1,a2;</span><br><span class=\"line\">\tcin&gt;&gt;B&gt;&gt;t1&gt;&gt;a1&gt;&gt;t2&gt;&gt;a2;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t1 &gt; t2)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(t1,t2);<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\tf=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">double</span> d = t2-t1;</span><br><span class=\"line\">\t<span class=\"type\">double</span> a,b;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(d * B &gt; a1)&#123;</span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / B;</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a2 / B;</span><br><span class=\"line\">\t\td=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\ta1 -= d * B;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a1 &gt; a2) f^= <span class=\"number\">1</span>,<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;a1&lt;&lt; &#x27; &#x27;&lt;&lt;a2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>) + <span class=\"number\">1.0</span> *(a2 - a1) /B;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,a + d, b);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,b + d,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-number-deletion-game\">K. Number Deletion Game</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSw==\">Problem - K -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-2\">题意：</h3>\r\n<p>爱丽丝和鲍勃正在玩一个数字删除游戏。</p>\r\n<p>一开始，有 <span class=\"math display\">\\[n\\]</span>$ 个整数 <span\r\nclass=\"math display\">\\[$a_ 1,a _ 2, \\ldots ,a _n\\]</span>\r\n。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除<strong>大的数字</strong><span\r\nclass=\"math display\">\\[x\\]</span>$ ，并选择一个比 <span\r\nclass=\"math display\">\\[$x\\]</span>**小的非负整数 <span\r\nclass=\"math display\">\\[y\\]</span>$ ，然后在数字 <span\r\nclass=\"math display\">\\[$1,2,\\ldots, y\\]</span>$\r\n中各加一个。特别是可以选择 <span class=\"math display\">\\[$y=0\\]</span>\r\n，在这种情况下不会添加任何数字。也就是说，删除 <span\r\nclass=\"math display\">\\[1\\]</span>\r\n时，不能添加任何数字。删除最后一个数字的人获胜。</p>\r\n<p>双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。</p>\r\n<h3 id=\"题解-2\">题解：</h3>\r\n<p>注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。</p>\r\n<p>另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。</p>\r\n<p>​ 那么对于最大值取<span class=\"math display\">\\[1 \\to\r\nk\\]</span>成立，试证明对k+1成立，分类讨论</p>\r\n<pre><code>1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\r\n1. k+1为偶数个，同理，Bob胜</code></pre>\r\n<p>coding</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> num = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i] != a[n]) &#123;</span><br><span class=\"line\">\t\t\tnum = n-i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num == <span class=\"number\">-1</span>) num = n;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;num&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num&amp;<span class=\"number\">1</span>) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"i.-integer-reaction\">I. Integer Reaction</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSQ==\">Problem - I -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>###　题意：</p>\r\n<p>有一个由 <span class=\"math display\">\\[n\\]</span>\r\n个整数组成的序列，从左到右编号为 <span class=\"math display\">\\[1\\]</span>\r\n到 <span class=\"math display\">\\[n\\]</span> 。这些整数有两种颜色，分别是\r\n<span class=\"math display\">\\[0\\]</span> 和 <span\r\nclass=\"math display\">\\[1\\]</span>\r\n，每个整数正好有一种颜色。这些整数按照从 <span\r\nclass=\"math display\">\\[1\\]</span>到 <span\r\nclass=\"math display\">\\[n\\]</span> 的编号顺序进入多集合 <span\r\nclass=\"math display\">\\[S_1\\]</span> 。</p>\r\n<p>每当一个新的整数 <span class=\"math display\">\\[x\\]</span> 进入 <span\r\nclass=\"math display\">\\[S_1\\]</span> 时，你必须在 <span\r\nclass=\"math display\">\\[S_1\\]</span> 中选择一个颜色与 <span\r\nclass=\"math display\">\\[x\\]</span> 不同的整数 <span\r\nclass=\"math display\">\\[y\\]</span> 与 <span\r\nclass=\"math display\">\\[x\\]</span> 发生反应，使得 <span\r\nclass=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> 消失，反应产物 <span\r\nclass=\"math display\">\\[x+y\\]</span> 插入另一个集合 <span\r\nclass=\"math display\">\\[S_2\\]</span> 中。如果不存在这样的 <span\r\nclass=\"math display\">\\[y\\]</span> ，则不会发生反应，只有 <span\r\nclass=\"math display\">\\[x\\]</span> 会插入 <span\r\nclass=\"math display\">\\[S_1\\]</span> 。</p>\r\n<p>给定整数序列和每个整数的颜色，求处理最后一个元素后 <span\r\nclass=\"math display\">\\[S_2\\]</span>​ 中最小元素的最大可能值。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>很简单，二分答案贪心维护<span\r\nclass=\"math display\">\\[S_1\\]</span>即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ck</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class=\"line\">\tmultiset&lt;<span class=\"type\">int</span>&gt; ms;</span><br><span class=\"line\">\t<span class=\"type\">int</span> c = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(c == a[i].y)&#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ms.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// cout&lt;&lt;x-a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">auto</span> it = <span class=\"built_in\">lower_bound</span>(<span class=\"built_in\">all</span>(ms), x - a[i].x);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(it == ms.<span class=\"built_in\">end</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// if(x==7)cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].x);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].y);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">1</span>,r = INF;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r<span class=\"number\">+1</span> &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">ck</span>(mid)) l = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"2024湖北省赛VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 湖北省赛VP\n\nhttps://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf\n\n## E. Spicy or Grilled?\n\n### 题意\n\n<!--more-->\n\n由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。\n\n![2aceebec00a61b0864fce9d24f11213aab3fc731](https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png)\n\n在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 $n$ 名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是 $a$ 元。但由于有些人像 Walk Alone 一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 $b$ 美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 $x$ 。\n\n但是，\"独行侠 \"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。\n\n### 题解\n\n我觉得麦当劳不素之霸更好吃，谁赞成，谁反对\n\n```cpp\nvoid slove() {\n\tint n,a,b,x;\n\tcin>>n>>x>>a>>b;\n\n\tcout<<1ll * (n-x) * a + x * b<<endl;\n}\n```\n\n## J. Points on the Number Axis A\n\n### 题意\n\n爱丽丝正在数轴上玩单人游戏。\n\n数轴上有 $n$ 个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是 $x_i$ 和 $x_j$，那么操作后将添加 $\\dfrac{x_i+x_j}{2}$ 。\n\n为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。\n\n现在爱丽丝有一个问题：最后一个点的预期位置在哪里？\n\n可以证明答案可以用 $\\dfrac{p}{q}$ 的形式表示，只需输出 $p\\cdot q^{-1} \\bmod 998,244,353$ 的值即可。\n\n### 题意\n\n其实就是所有点的平均值位置\n\n下面是证明：\n\n现在，假设我们有n个点，它们的坐标是$x_1, x_2, …, x_n$，并且我们已经证明了对于任意的$i$和$j$，点 $x_i$和$x_j$的中点的期望坐标是$\\frac{x_i + x_j}{2}$。那么，对于这$n$个点，我们可以计算它们所有可能中点的平均值：\n$$\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n$$\n\n以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的$x_i$它出现在了中点计算公式中出现了$n-1$次，因此后面的二重求和可以变为:\n$$\n \\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i\n$$\n剩下的就很好理解了。\n\n数学推导对这样的“显然解”证明，有着更好的一套方法：\n\n没能够看懂题解上得公式。。。。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tcout<<sum %MOD * qmi(n,MOD-2) % MOD<<endl;\n}\n```\n\n## A. Long Live\n\n### 题意\n\n在《我的世界》中，简单的世界有三个维度，其中一个维度被称为 \"终结\"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。\n\n![](https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png)\n\n现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下\n\n给定两个正整数 $x$ 和 $y$ ，请找出两个整数 $a$ 和 $b$ ，使得\n\n$$\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}\n$$\n\n并使 $a \\cdot b$ 最大。\n\n这里， $\\gcd(a,b)$ 表示 $a,b$ 的最大公约数，而 $\\rm lcm(a,b)$ 表示 $a,b$ 的最小公倍数。\n\n### 题意\n\n如果你的数学功底很好肯定可以极快的打出这一场的签到\n\n简单的数学带入推到公式得到\n\n$$\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}\n$$\n\n```cpp\nvoid slove() {\n\tint x,y;cin>>x>>y;\n\n\tint gc = gcd(x,y);\n\tint lc = lcm(x,y);\n\tcout<<1<<' '<<lc/gc<<endl;\n}\n```","source":"_posts/2024湖北省赛VP.md","raw":"---\ntitle: 2024湖北省赛VP\ndate: 2024-08-14 19:46:31\ntags: [icpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- icpc省赛\n---\n\n## 湖北省赛VP\n\nhttps://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf\n\n## E. Spicy or Grilled?\n\n### 题意\n\n<!--more-->\n\n由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。\n\n![2aceebec00a61b0864fce9d24f11213aab3fc731](https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png)\n\n在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 $n$ 名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是 $a$ 元。但由于有些人像 Walk Alone 一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 $b$ 美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 $x$ 。\n\n但是，\"独行侠 \"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。\n\n### 题解\n\n我觉得麦当劳不素之霸更好吃，谁赞成，谁反对\n\n```cpp\nvoid slove() {\n\tint n,a,b,x;\n\tcin>>n>>x>>a>>b;\n\n\tcout<<1ll * (n-x) * a + x * b<<endl;\n}\n```\n\n## J. Points on the Number Axis A\n\n### 题意\n\n爱丽丝正在数轴上玩单人游戏。\n\n数轴上有 $n$ 个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是 $x_i$ 和 $x_j$，那么操作后将添加 $\\dfrac{x_i+x_j}{2}$ 。\n\n为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。\n\n现在爱丽丝有一个问题：最后一个点的预期位置在哪里？\n\n可以证明答案可以用 $\\dfrac{p}{q}$ 的形式表示，只需输出 $p\\cdot q^{-1} \\bmod 998,244,353$ 的值即可。\n\n### 题意\n\n其实就是所有点的平均值位置\n\n下面是证明：\n\n现在，假设我们有n个点，它们的坐标是$x_1, x_2, …, x_n$，并且我们已经证明了对于任意的$i$和$j$，点 $x_i$和$x_j$的中点的期望坐标是$\\frac{x_i + x_j}{2}$。那么，对于这$n$个点，我们可以计算它们所有可能中点的平均值：\n$$\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n$$\n\n以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的$x_i$它出现在了中点计算公式中出现了$n-1$次，因此后面的二重求和可以变为:\n$$\n \\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i\n$$\n剩下的就很好理解了。\n\n数学推导对这样的“显然解”证明，有着更好的一套方法：\n\n没能够看懂题解上得公式。。。。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tcout<<sum %MOD * qmi(n,MOD-2) % MOD<<endl;\n}\n```\n\n## A. Long Live\n\n### 题意\n\n在《我的世界》中，简单的世界有三个维度，其中一个维度被称为 \"终结\"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。\n\n![](https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png)\n\n现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下\n\n给定两个正整数 $x$ 和 $y$ ，请找出两个整数 $a$ 和 $b$ ，使得\n\n$$\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}\n$$\n\n并使 $a \\cdot b$ 最大。\n\n这里， $\\gcd(a,b)$ 表示 $a,b$ 的最大公约数，而 $\\rm lcm(a,b)$ 表示 $a,b$ 的最小公倍数。\n\n### 题意\n\n如果你的数学功底很好肯定可以极快的打出这一场的签到\n\n简单的数学带入推到公式得到\n\n$$\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}\n$$\n\n```cpp\nvoid slove() {\n\tint x,y;cin>>x>>y;\n\n\tint gc = gcd(x,y);\n\tint lc = lcm(x,y);\n\tcout<<1<<' '<<lc/gc<<endl;\n}\n```","slug":"2024湖北省赛VP","published":1,"updated":"2024-08-15T04:51:06.767Z","comments":1,"layout":"post","photos":[],"_id":"clzwonja40007lowv8akhfn6r","content":"<h2 id=\"湖北省赛vp\">湖北省赛VP</h2>\r\n<p>https://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf</p>\r\n<h2 id=\"e.-spicy-or-grilled\">E. Spicy or Grilled?</h2>\r\n<h3 id=\"题意\">题意</h3>\r\n<span id=\"more\"></span>\r\n<p>由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png\"\r\nalt=\"2aceebec00a61b0864fce9d24f11213aab3fc731\" />\r\n<figcaption\r\naria-hidden=\"true\">2aceebec00a61b0864fce9d24f11213aab3fc731</figcaption>\r\n</figure>\r\n<p>在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 <span\r\nclass=\"math inline\">\\(n\\)</span>\r\n名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是\r\n<span class=\"math inline\">\\(a\\)</span> 元。但由于有些人像 Walk Alone\r\n一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 <span\r\nclass=\"math inline\">\\(b\\)</span>\r\n美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 <span\r\nclass=\"math inline\">\\(x\\)</span> 。</p>\r\n<p>但是，\"独行侠\r\n\"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>我觉得麦当劳不素之霸更好吃，谁赞成，谁反对</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n,a,b,x;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1ll</span> * (n-x) * a + x * b&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"j.-points-on-the-number-axis-a\">J. Points on the Number Axis\r\nA</h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>爱丽丝正在数轴上玩单人游戏。</p>\r\n<p>数轴上有 <span class=\"math inline\">\\(n\\)</span>\r\n个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是\r\n<span class=\"math inline\">\\(x_i\\)</span> 和 <span\r\nclass=\"math inline\">\\(x_j\\)</span>，那么操作后将添加 <span\r\nclass=\"math inline\">\\(\\dfrac{x_i+x_j}{2}\\)</span> 。</p>\r\n<p>为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。</p>\r\n<p>现在爱丽丝有一个问题：最后一个点的预期位置在哪里？</p>\r\n<p>可以证明答案可以用 <span class=\"math inline\">\\(\\dfrac{p}{q}\\)</span>\r\n的形式表示，只需输出 <span class=\"math inline\">\\(p\\cdot q^{-1} \\bmod\r\n998,244,353\\)</span> 的值即可。</p>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>其实就是所有点的平均值位置</p>\r\n<p>下面是证明：</p>\r\n<p>现在，假设我们有n个点，它们的坐标是<span class=\"math inline\">\\(x_1,\r\nx_2, …, x_n\\)</span>，并且我们已经证明了对于任意的<span\r\nclass=\"math inline\">\\(i\\)</span>和<span\r\nclass=\"math inline\">\\(j\\)</span>，点 <span\r\nclass=\"math inline\">\\(x_i\\)</span>和<span\r\nclass=\"math inline\">\\(x_j\\)</span>的中点的期望坐标是<span\r\nclass=\"math inline\">\\(\\frac{x_i + x_j}{2}\\)</span>。那么，对于这<span\r\nclass=\"math inline\">\\(n\\)</span>个点，我们可以计算它们所有可能中点的平均值：\r\n<span class=\"math display\">\\[\r\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i +\r\nx_j}{2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i +\r\nx_j}{2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i\r\n\\]</span></p>\r\n<p>以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的<span\r\nclass=\"math inline\">\\(x_i\\)</span>它出现在了中点计算公式中出现了<span\r\nclass=\"math inline\">\\(n-1\\)</span>次，因此后面的二重求和可以变为: <span\r\nclass=\"math display\">\\[\r\n\\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i\r\n\\]</span> 剩下的就很好理解了。</p>\r\n<p>数学推导对这样的“显然解”证明，有着更好的一套方法：</p>\r\n<p>没能够看懂题解上得公式。。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum %<span class=\"function\">MOD * <span class=\"title\">qmi</span><span class=\"params\">(n,MOD<span class=\"number\">-2</span>)</span> % MOD&lt;&lt;endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"a.-long-live\">A. Long Live</h2>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p>在《我的世界》中，简单的世界有三个维度，其中一个维度被称为\r\n\"终结\"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png\" /></p>\r\n<p>现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下</p>\r\n<p>给定两个正整数 <span class=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(y\\)</span> ，请找出两个整数 <span\r\nclass=\"math inline\">\\(a\\)</span> 和 <span\r\nclass=\"math inline\">\\(b\\)</span> ，使得</p>\r\n<p><span class=\"math display\">\\[\r\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}\r\n\\]</span></p>\r\n<p>并使 <span class=\"math inline\">\\(a \\cdot b\\)</span> 最大。</p>\r\n<p>这里， <span class=\"math inline\">\\(\\gcd(a,b)\\)</span> 表示 <span\r\nclass=\"math inline\">\\(a,b\\)</span> 的最大公约数，而 <span\r\nclass=\"math inline\">\\(\\rm lcm(a,b)\\)</span> 表示 <span\r\nclass=\"math inline\">\\(a,b\\)</span> 的最小公倍数。</p>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>如果你的数学功底很好肯定可以极快的打出这一场的签到</p>\r\n<p>简单的数学带入推到公式得到</p>\r\n<p><span class=\"math display\">\\[\r\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}\r\n\\]</span></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> gc = <span class=\"built_in\">gcd</span>(x,y);</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = <span class=\"built_in\">lcm</span>(x,y);</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;lc/gc&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":995,"excerpt":"<h2 id=\"湖北省赛vp\">湖北省赛VP</h2>\r\n<p>https://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf</p>\r\n<h2 id=\"e.-spicy-or-grilled\">E. Spicy or Grilled?</h2>\r\n<h3 id=\"题意\">题意</h3>","more":"<p>由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png\"\r\nalt=\"2aceebec00a61b0864fce9d24f11213aab3fc731\" />\r\n<figcaption\r\naria-hidden=\"true\">2aceebec00a61b0864fce9d24f11213aab3fc731</figcaption>\r\n</figure>\r\n<p>在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 <span\r\nclass=\"math inline\">\\(n\\)</span>\r\n名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是\r\n<span class=\"math inline\">\\(a\\)</span> 元。但由于有些人像 Walk Alone\r\n一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 <span\r\nclass=\"math inline\">\\(b\\)</span>\r\n美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 <span\r\nclass=\"math inline\">\\(x\\)</span> 。</p>\r\n<p>但是，\"独行侠\r\n\"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>我觉得麦当劳不素之霸更好吃，谁赞成，谁反对</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n,a,b,x;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1ll</span> * (n-x) * a + x * b&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"j.-points-on-the-number-axis-a\">J. Points on the Number Axis\r\nA</h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>爱丽丝正在数轴上玩单人游戏。</p>\r\n<p>数轴上有 <span class=\"math inline\">\\(n\\)</span>\r\n个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是\r\n<span class=\"math inline\">\\(x_i\\)</span> 和 <span\r\nclass=\"math inline\">\\(x_j\\)</span>，那么操作后将添加 <span\r\nclass=\"math inline\">\\(\\dfrac{x_i+x_j}{2}\\)</span> 。</p>\r\n<p>为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。</p>\r\n<p>现在爱丽丝有一个问题：最后一个点的预期位置在哪里？</p>\r\n<p>可以证明答案可以用 <span class=\"math inline\">\\(\\dfrac{p}{q}\\)</span>\r\n的形式表示，只需输出 <span class=\"math inline\">\\(p\\cdot q^{-1} \\bmod\r\n998,244,353\\)</span> 的值即可。</p>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>其实就是所有点的平均值位置</p>\r\n<p>下面是证明：</p>\r\n<p>现在，假设我们有n个点，它们的坐标是<span class=\"math inline\">\\(x_1,\r\nx_2, …, x_n\\)</span>，并且我们已经证明了对于任意的<span\r\nclass=\"math inline\">\\(i\\)</span>和<span\r\nclass=\"math inline\">\\(j\\)</span>，点 <span\r\nclass=\"math inline\">\\(x_i\\)</span>和<span\r\nclass=\"math inline\">\\(x_j\\)</span>的中点的期望坐标是<span\r\nclass=\"math inline\">\\(\\frac{x_i + x_j}{2}\\)</span>。那么，对于这<span\r\nclass=\"math inline\">\\(n\\)</span>个点，我们可以计算它们所有可能中点的平均值：\r\n<span class=\"math display\">\\[\r\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i +\r\nx_j}{2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i +\r\nx_j}{2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i\r\n\\]</span></p>\r\n<p>以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的<span\r\nclass=\"math inline\">\\(x_i\\)</span>它出现在了中点计算公式中出现了<span\r\nclass=\"math inline\">\\(n-1\\)</span>次，因此后面的二重求和可以变为: <span\r\nclass=\"math display\">\\[\r\n\\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i\r\n\\]</span> 剩下的就很好理解了。</p>\r\n<p>数学推导对这样的“显然解”证明，有着更好的一套方法：</p>\r\n<p>没能够看懂题解上得公式。。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum %<span class=\"function\">MOD * <span class=\"title\">qmi</span><span class=\"params\">(n,MOD<span class=\"number\">-2</span>)</span> % MOD&lt;&lt;endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"a.-long-live\">A. Long Live</h2>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p>在《我的世界》中，简单的世界有三个维度，其中一个维度被称为\r\n\"终结\"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png\" /></p>\r\n<p>现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下</p>\r\n<p>给定两个正整数 <span class=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(y\\)</span> ，请找出两个整数 <span\r\nclass=\"math inline\">\\(a\\)</span> 和 <span\r\nclass=\"math inline\">\\(b\\)</span> ，使得</p>\r\n<p><span class=\"math display\">\\[\r\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}\r\n\\]</span></p>\r\n<p>并使 <span class=\"math inline\">\\(a \\cdot b\\)</span> 最大。</p>\r\n<p>这里， <span class=\"math inline\">\\(\\gcd(a,b)\\)</span> 表示 <span\r\nclass=\"math inline\">\\(a,b\\)</span> 的最大公约数，而 <span\r\nclass=\"math inline\">\\(\\rm lcm(a,b)\\)</span> 表示 <span\r\nclass=\"math inline\">\\(a,b\\)</span> 的最小公倍数。</p>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>如果你的数学功底很好肯定可以极快的打出这一场的签到</p>\r\n<p>简单的数学带入推到公式得到</p>\r\n<p><span class=\"math display\">\\[\r\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}\r\n\\]</span></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> gc = <span class=\"built_in\">gcd</span>(x,y);</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = <span class=\"built_in\">lcm</span>(x,y);</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;lc/gc&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"2024河南CCPC邀请赛-VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 河南CCPC-VP\n\n[Dashboard - 2024 National Invitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate Programming Contest - Codeforces](https://codeforces.com/gym/105158)\n\n## J. [排列与合数](https://codeforces.com/gym/105158/problem/J)\n\n<!--more-->\n\n### 题意：\n\n​\t小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。 与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关 的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的： 给定一个有且仅有5 位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位， 但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′ 能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345 时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以 重新排列数位得到合数n′=97531=7×13933。 一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。 现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？\n\n### 题解：\n\n​\t签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tstring s;cin>>s;\n\t\tsort(all(s));\n\t\tbool flag= 0;\n\t\tdo{\n\t\t\tint t = 0;\n\t\t\tfor(int i=0;i<5;i++)\n\t\t\t\tt = t * 10 + (s[i] - '0');\n\t\t\tif(t <=10000) continue;\n\t\t\tint f = 1;\n\t\t\tfor(int i=2;i*i<=t;i++)\n\t\t\t\tif(t % i == 0){\n\t\t\t\t\tf=0;break;\n\t\t\t\t}\n\t\t\tif(!f) {cout<<t<<endl;flag =1;break;}\n\t\t}while(next_permutation(all(s)));\n\t\tif(!flag) cout<<-1<<endl;\n\t}\n}\n```\n\n## B.[扫雷 1](https://codeforces.com/gym/105158/problem/B)\n\n### 题意：\n\n​\t T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。 具体来说，T0xel 会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫 雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci 枚扫 雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。 现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？\n\n### 题解\n\n注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tc[i] = a[i].x;\n\t\ta[i].y = i;\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint flag = 0;\n\tint now = 0, ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tnow ++;\n\t\twhile(a[flag].y < i) flag++;\n\t\tif(a[flag].y == i){\n\t\t\tans += now / c[i];\n\t\t\tnow = now % c[i];\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F.[优秀字符串](https://codeforces.com/gym/105158/problem/F)\n\n### 题意：\n\n小A认为，一个字符串S是优秀字符串，当且仅当：\n\n- S 的长度|S|恰好为5\n- S 的第三个字符与第五个字符相同\n- S 的前四个字符互不相同。 \n\n例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query 的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue 的前四个字符中u出现了两次。 现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中 优秀字符串的数量\n\n### 题解\n\n签到，不做阐述\n\n```cpp\nvoid slove() {\n\tcin>>n;int cnt = 0;\n\tfor(int i=1;i<=n;i++){\n\tstring s;cin>>s;\n\t\tif(s.size()!=5){\n\t\t\tcontinue;\n\t\t}else {\n\t\t\tset<char> S;\n\t\t\tfor(int i=0;i<4;i++)S.insert(s[i]);\n\n\t\t\tif(S.size()!=4){\n\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\tif(s[2] != s[4]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tcnt ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\n## M. [有效算法](https://codeforces.com/gym/105158/problem/M)\n\n### 题意：\n\n给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：\n\n- 将ai 变成满足|ai−x|≤k×bi 的任意整数x。 \n\n请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。\n\n### 题解：\n\n分情况讨论绝对值，即可得出以下两个不等式组\n$$\na_i \\le x \\le a_i + k * b_i\\\\\na_i - k * b_i \\le x \\le a_i\n$$\n考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数\n\n考虑暴力一下，枚举的mn到mx为x，发现\n$$\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}\n$$\n但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。\n\n转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。\n\n如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。\n\n我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。\n\n注意可能有极端情况$$a_i$$​均相等\n\n神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。\n\n下面是code\n\n```cpp\nint check(int x){\n\tL.clear(),R.clear(),ves.clear();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tL.push_back(a[i].x - x * a[i].y);\n\t\tR.push_back(a[i].x + x * a[i].y);\n\t}\n\t// cout<<mx<<' '<<mn<<endl;\n\tint l = mn, r = mx;\n\tfor(int i =0; i < n; i++){\n\t\t// cout<< L[i]<<endl;\n\t\tl = max(L[i],l);\n\t\tr = min(r,R[i]);\n\t}\n\t// cout<<x<< ' ' <<l<< ' ' <<r<<endl;\n\tif(l<=r) return 1;\n\telse return 0;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tmx=max(a[i].x,mx);\n\t\tmn=min(a[i].x,mn);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].y;\n\t}\n\n\t// for(int i=1;i<=n;i++) cout<<a[i].x<<'-'<<a[i].y<<endl;\n\n\tll l = 0, r = mx-mn;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\t// cout<<mid<<endl;\n\t\tif(check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tcout<<r<<endl;\n}\n\n```\n\n## H.[随机栈](https://codeforces.com/gym/105158/problem/H)\n\n### 题意：\n\n​\tToxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集 S，从一个非空的随机栈 S 中取出一个 元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会 从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有 2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel 正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插 入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合 非空。Toxel 想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增 的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。 由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。\n\n### 题解：\n\n题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。\n\ncode\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nll inv(ll x){return qmi(x,MOD-2);}\n\nvoid init(){}\n\nvoid slove() {\n\tcin>>n;\n\tvector<int> a,ords;\n\tfor(int i=1;i<=(n<<1);i++){\n\t\tint op;\n\t\tcin>>op;\n\t\tif(~op) a.pb(op);\n\t\tords.pb(op);\n\t}\n\tsort(all(a));\n\n\tint flag= 0;\n\tint ans = 1;\n\tfor(auto op : ords){\n\t\tif(op==-1){\n\t\t\t// cout<<cnt[a[flag]]<< ' '<<sum<<endl;\n\t\t\tans *= cnt[a[flag]] * inv(sum) % MOD;\n\t\t\tans %= MOD;\n\t\t\tcnt[a[flag]]--;\n\t\t\tflag++;\n\t\t\tsum--;\n\t\t}else {\n\t\t\tcnt[op] ++;sum ++;\n\t\t}\n\t}\n\n\tcout<<ans % MOD<<endl;\n}\n```\n\n待续。。。。笔者吃饭去了\n\n## L. [Toxel 与 PCPC II](https://codeforces.com/gym/105158/problem/L)\n\n### 题面：\n\n​\t Toxel 正在参加 PCPC（Pokémon Center Programming Contest）比赛。它写的一段代码中有不少 bug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁 定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。 Toxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1 行开始，顺序运行完 第i行后退出。Toxel 可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i 秒。接下来，Toxel 会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修 复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4 秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC 的赛场争分夺秒。请你帮Toxel 计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？\n\n### 题解：\n\n考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d = j - i，则花费差为\n$$\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\ \n\\Delta = (x+1)^4 - x^4 - i - 1\n$$\n注意到$$i+1$$是常数，但对$$(x+1) ^4- x^4$$ 这个值可能随着我们前面先debug一段而减少。\n\n让我们贪心的考虑，存在前缀，如果我们有$$(x+1)^4 - x^4 \\le i+1$$ ，则我们一定会向后拓展吗？如果不扩展，我们首先损失了$$\\Delta$$，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。\n\n实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展\n\n```cpp\nfor(int i=1;i<=m;i++){\n\t\tint s = 1;\n\t\twhile(i < m && a[i] + 1 >= qmi((s+1),4) - qmi(s,4) ){\n\t\t\ts ++;\n\t\t\ti ++;\n\t\t}\n\n\t\tans += (a[i] + qmi(s,4));\n\t\tcout<<i<<' ' <<ans<<nline;\n\t}\n}\n```\n\n该代码在样例\n\n```cpp\n20 20\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n```\n\n计算答案为\n\n```cpp\n224\n```\n\n但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用$$(x+1)^4 - x^4$$去换$$i+1$$的成本量，相同情况下当然希望后面的扩展越多越好，此时$$i$$更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。\n\n但还是wa， 考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp\n\n根据上面的公式，状态表示为\n$$\nf_i 前i个bug修改所需最小代价\n$$\n状态转移表示为\n$$\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) <= a[i-j] + 1 \\&\\& i-j+1 > 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}\n$$\n暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。\n\ncoding。。。\n\n```cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i =1;i<=m;i++) cin>>a[i];\n\n\tmemset(f,0x3f,sizeof f);\n\tf[0] = 0;\n\n\tint ans = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tf[i] = f[i-1] + a[i] + 1;\n\t\t// cout<<\"#\"<<i<< ' ' <<f[i]<<endl; \n\t\tfor(int j=2;qmi(j,4)- qmi(j-1,4) <= a[i-j+1] + 1 && i-j+1 > 0; j++)\n\t\t{\n\n\t\t\tf[i] = min(f[i-j] + qmi(j,4) + a[i],f[i]);\n\t\t\t// cout<<i<<' '<<j<< ' ' << f[i] <<endl;\n\t\t}\n\t}\n\tcout<<f[m]<<endl;\n}\n```\n\n## K. [树上问题](https://codeforces.com/gym/105158/problem/K)\n\n### 题意:\n\n​\t378QAQ 有一棵由 n 个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ 认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其 点权都.不 .小 .于其父亲节点的点权的 1 2。 请你计算出有多少个节点是美丽节点。\n\n### 题解：\n\n​\t若：\n$$\na >= b/2\n$$\n​\t则：\n$$\n2*a >= b \\rightarrow \\{a/2<=b<=2*a\\}\n$$\n​\t即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。\n\n​\t考虑更换顶点对点关系的影响：\n\n1. 原根节点与新的根节点之间一定是父子关系\n2. 更换根节点仅更改了原根到新根路径上的节点的父子关系。\n\n​\t于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。\n\n​\t显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。\n\n​\t一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。\n\ncoding\n\n```cpp\nint tarjan(int u){\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u, istk[u] = 1;\n    for(int v: e[u]){\n        if(!dfn[v]){\n            tarjan(v);\n            low[u] = min(low[u],low[v]);\n        }else if(istk[v]){\n            low[u] = min(low[u],dfn[v]);\n        }\n    }\n\n    if(low[u] == dfn[u]){\n        int p;\n        scou++;\n        do{\n            p = stk[top--];\n            istk[p] = 0;\n            scnt[scou]++;\n            id[p] = scou;\n        }while(p!=u);\n    }\n}\n\nvoid slove() {\n\tcin>>n;\n\n    scou = top = timestamp = 0;\n    for(int i=1;i<=n;i++) e[i].clear(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = 0;\n\n    for(int i=1;i<=n;i++) cin>>w[i];\n\n    for(int i=1;i<=n-1;i++)\n    {\n        int a,b;cin>>a>>b;\n        // cout<<a<<' '<<b<<endl;\n        if(ceil(1.0*w[a]/2) <= w[b] && w[b] <= (w[a] * 2)){\n            // cout<<a<< ' '<<b<<endl;\n            e[a].pb(b);\n            e[b].pb(a);\n        }else {\n            if(w[a] > w[b]) swap(a,b);\n            e[a].pb(b);\n            // cout<<\"###\"<<a<< ' '<< b<<endl;\n        }\n    }\n    // cout<<nline;\n\n    for(int i=1;i<=n;i++) {\n        if(!dfn[i]){\n            tarjan(i);\n        }\n    }\n\n    for(int i=1;i<=scou;i++) din[i] = 0;\n\n    multiset<ull> rcd;\n    for(int i=1;i<=n;i++) {\n        // cout<<\"---\"<<i<< ' ' <<e[i].size()<<endl;\n        for(auto j: e[i]){\n            int a = id[i], b = id[j];\n            // cout<<i<<' ' << a<<endl;\n            // cout<<j<<' ' << b<<endl;\n            if(a != b && !rcd.count(a * 100000 + b)){\n                rcd.insert(a * 100000+b);\n                din[b] ++;\n            }\n        }\n    }\n\n    // for(int i=1;i<=n;i++){\n    //     cout<<id[i]<<' ';\n    // }\n    // cout<<nline;\n\n    // for(int i=1;i<=scou;i++){\n    //     cout<<scnt[i]<<' '<<din[i]<<endl;\n    // }\n    // cout<<endl;\n\n    int cnt =0,ans=0;\n    for(int i=1;i<=scou;i++){\n        if(!din[i] && !ans) ans = scnt[i];\n        else if(!din[i] && ans){\n            cout<<0<<endl;\n            return ;\n        }\n    }\n    cout<<ans<<endl;\n    return ;\n}\n```\n\n\n\n​\t\n","source":"_posts/2024河南CCPC邀请赛-VP.md","raw":"---\ntitle: 2024河南CCPC邀请赛-VP\ndate: 2024-08-14 19:46:31\ntags: [ccpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- ccpc邀请赛\n---\n\n## 河南CCPC-VP\n\n[Dashboard - 2024 National Invitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate Programming Contest - Codeforces](https://codeforces.com/gym/105158)\n\n## J. [排列与合数](https://codeforces.com/gym/105158/problem/J)\n\n<!--more-->\n\n### 题意：\n\n​\t小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。 与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关 的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的： 给定一个有且仅有5 位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位， 但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′ 能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345 时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以 重新排列数位得到合数n′=97531=7×13933。 一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。 现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？\n\n### 题解：\n\n​\t签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tstring s;cin>>s;\n\t\tsort(all(s));\n\t\tbool flag= 0;\n\t\tdo{\n\t\t\tint t = 0;\n\t\t\tfor(int i=0;i<5;i++)\n\t\t\t\tt = t * 10 + (s[i] - '0');\n\t\t\tif(t <=10000) continue;\n\t\t\tint f = 1;\n\t\t\tfor(int i=2;i*i<=t;i++)\n\t\t\t\tif(t % i == 0){\n\t\t\t\t\tf=0;break;\n\t\t\t\t}\n\t\t\tif(!f) {cout<<t<<endl;flag =1;break;}\n\t\t}while(next_permutation(all(s)));\n\t\tif(!flag) cout<<-1<<endl;\n\t}\n}\n```\n\n## B.[扫雷 1](https://codeforces.com/gym/105158/problem/B)\n\n### 题意：\n\n​\t T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。 具体来说，T0xel 会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫 雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci 枚扫 雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。 现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？\n\n### 题解\n\n注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tc[i] = a[i].x;\n\t\ta[i].y = i;\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint flag = 0;\n\tint now = 0, ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tnow ++;\n\t\twhile(a[flag].y < i) flag++;\n\t\tif(a[flag].y == i){\n\t\t\tans += now / c[i];\n\t\t\tnow = now % c[i];\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F.[优秀字符串](https://codeforces.com/gym/105158/problem/F)\n\n### 题意：\n\n小A认为，一个字符串S是优秀字符串，当且仅当：\n\n- S 的长度|S|恰好为5\n- S 的第三个字符与第五个字符相同\n- S 的前四个字符互不相同。 \n\n例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query 的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue 的前四个字符中u出现了两次。 现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中 优秀字符串的数量\n\n### 题解\n\n签到，不做阐述\n\n```cpp\nvoid slove() {\n\tcin>>n;int cnt = 0;\n\tfor(int i=1;i<=n;i++){\n\tstring s;cin>>s;\n\t\tif(s.size()!=5){\n\t\t\tcontinue;\n\t\t}else {\n\t\t\tset<char> S;\n\t\t\tfor(int i=0;i<4;i++)S.insert(s[i]);\n\n\t\t\tif(S.size()!=4){\n\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\tif(s[2] != s[4]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tcnt ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\n## M. [有效算法](https://codeforces.com/gym/105158/problem/M)\n\n### 题意：\n\n给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：\n\n- 将ai 变成满足|ai−x|≤k×bi 的任意整数x。 \n\n请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。\n\n### 题解：\n\n分情况讨论绝对值，即可得出以下两个不等式组\n$$\na_i \\le x \\le a_i + k * b_i\\\\\na_i - k * b_i \\le x \\le a_i\n$$\n考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数\n\n考虑暴力一下，枚举的mn到mx为x，发现\n$$\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}\n$$\n但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。\n\n转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。\n\n如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。\n\n我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。\n\n注意可能有极端情况$$a_i$$​均相等\n\n神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。\n\n下面是code\n\n```cpp\nint check(int x){\n\tL.clear(),R.clear(),ves.clear();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tL.push_back(a[i].x - x * a[i].y);\n\t\tR.push_back(a[i].x + x * a[i].y);\n\t}\n\t// cout<<mx<<' '<<mn<<endl;\n\tint l = mn, r = mx;\n\tfor(int i =0; i < n; i++){\n\t\t// cout<< L[i]<<endl;\n\t\tl = max(L[i],l);\n\t\tr = min(r,R[i]);\n\t}\n\t// cout<<x<< ' ' <<l<< ' ' <<r<<endl;\n\tif(l<=r) return 1;\n\telse return 0;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tmx=max(a[i].x,mx);\n\t\tmn=min(a[i].x,mn);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].y;\n\t}\n\n\t// for(int i=1;i<=n;i++) cout<<a[i].x<<'-'<<a[i].y<<endl;\n\n\tll l = 0, r = mx-mn;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\t// cout<<mid<<endl;\n\t\tif(check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tcout<<r<<endl;\n}\n\n```\n\n## H.[随机栈](https://codeforces.com/gym/105158/problem/H)\n\n### 题意：\n\n​\tToxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集 S，从一个非空的随机栈 S 中取出一个 元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会 从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有 2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel 正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插 入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合 非空。Toxel 想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增 的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。 由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。\n\n### 题解：\n\n题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。\n\ncode\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nll inv(ll x){return qmi(x,MOD-2);}\n\nvoid init(){}\n\nvoid slove() {\n\tcin>>n;\n\tvector<int> a,ords;\n\tfor(int i=1;i<=(n<<1);i++){\n\t\tint op;\n\t\tcin>>op;\n\t\tif(~op) a.pb(op);\n\t\tords.pb(op);\n\t}\n\tsort(all(a));\n\n\tint flag= 0;\n\tint ans = 1;\n\tfor(auto op : ords){\n\t\tif(op==-1){\n\t\t\t// cout<<cnt[a[flag]]<< ' '<<sum<<endl;\n\t\t\tans *= cnt[a[flag]] * inv(sum) % MOD;\n\t\t\tans %= MOD;\n\t\t\tcnt[a[flag]]--;\n\t\t\tflag++;\n\t\t\tsum--;\n\t\t}else {\n\t\t\tcnt[op] ++;sum ++;\n\t\t}\n\t}\n\n\tcout<<ans % MOD<<endl;\n}\n```\n\n待续。。。。笔者吃饭去了\n\n## L. [Toxel 与 PCPC II](https://codeforces.com/gym/105158/problem/L)\n\n### 题面：\n\n​\t Toxel 正在参加 PCPC（Pokémon Center Programming Contest）比赛。它写的一段代码中有不少 bug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁 定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。 Toxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1 行开始，顺序运行完 第i行后退出。Toxel 可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i 秒。接下来，Toxel 会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修 复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4 秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC 的赛场争分夺秒。请你帮Toxel 计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？\n\n### 题解：\n\n考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d = j - i，则花费差为\n$$\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\ \n\\Delta = (x+1)^4 - x^4 - i - 1\n$$\n注意到$$i+1$$是常数，但对$$(x+1) ^4- x^4$$ 这个值可能随着我们前面先debug一段而减少。\n\n让我们贪心的考虑，存在前缀，如果我们有$$(x+1)^4 - x^4 \\le i+1$$ ，则我们一定会向后拓展吗？如果不扩展，我们首先损失了$$\\Delta$$，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。\n\n实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展\n\n```cpp\nfor(int i=1;i<=m;i++){\n\t\tint s = 1;\n\t\twhile(i < m && a[i] + 1 >= qmi((s+1),4) - qmi(s,4) ){\n\t\t\ts ++;\n\t\t\ti ++;\n\t\t}\n\n\t\tans += (a[i] + qmi(s,4));\n\t\tcout<<i<<' ' <<ans<<nline;\n\t}\n}\n```\n\n该代码在样例\n\n```cpp\n20 20\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n```\n\n计算答案为\n\n```cpp\n224\n```\n\n但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用$$(x+1)^4 - x^4$$去换$$i+1$$的成本量，相同情况下当然希望后面的扩展越多越好，此时$$i$$更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。\n\n但还是wa， 考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp\n\n根据上面的公式，状态表示为\n$$\nf_i 前i个bug修改所需最小代价\n$$\n状态转移表示为\n$$\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) <= a[i-j] + 1 \\&\\& i-j+1 > 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}\n$$\n暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。\n\ncoding。。。\n\n```cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i =1;i<=m;i++) cin>>a[i];\n\n\tmemset(f,0x3f,sizeof f);\n\tf[0] = 0;\n\n\tint ans = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tf[i] = f[i-1] + a[i] + 1;\n\t\t// cout<<\"#\"<<i<< ' ' <<f[i]<<endl; \n\t\tfor(int j=2;qmi(j,4)- qmi(j-1,4) <= a[i-j+1] + 1 && i-j+1 > 0; j++)\n\t\t{\n\n\t\t\tf[i] = min(f[i-j] + qmi(j,4) + a[i],f[i]);\n\t\t\t// cout<<i<<' '<<j<< ' ' << f[i] <<endl;\n\t\t}\n\t}\n\tcout<<f[m]<<endl;\n}\n```\n\n## K. [树上问题](https://codeforces.com/gym/105158/problem/K)\n\n### 题意:\n\n​\t378QAQ 有一棵由 n 个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ 认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其 点权都.不 .小 .于其父亲节点的点权的 1 2。 请你计算出有多少个节点是美丽节点。\n\n### 题解：\n\n​\t若：\n$$\na >= b/2\n$$\n​\t则：\n$$\n2*a >= b \\rightarrow \\{a/2<=b<=2*a\\}\n$$\n​\t即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。\n\n​\t考虑更换顶点对点关系的影响：\n\n1. 原根节点与新的根节点之间一定是父子关系\n2. 更换根节点仅更改了原根到新根路径上的节点的父子关系。\n\n​\t于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。\n\n​\t显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。\n\n​\t一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。\n\ncoding\n\n```cpp\nint tarjan(int u){\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u, istk[u] = 1;\n    for(int v: e[u]){\n        if(!dfn[v]){\n            tarjan(v);\n            low[u] = min(low[u],low[v]);\n        }else if(istk[v]){\n            low[u] = min(low[u],dfn[v]);\n        }\n    }\n\n    if(low[u] == dfn[u]){\n        int p;\n        scou++;\n        do{\n            p = stk[top--];\n            istk[p] = 0;\n            scnt[scou]++;\n            id[p] = scou;\n        }while(p!=u);\n    }\n}\n\nvoid slove() {\n\tcin>>n;\n\n    scou = top = timestamp = 0;\n    for(int i=1;i<=n;i++) e[i].clear(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = 0;\n\n    for(int i=1;i<=n;i++) cin>>w[i];\n\n    for(int i=1;i<=n-1;i++)\n    {\n        int a,b;cin>>a>>b;\n        // cout<<a<<' '<<b<<endl;\n        if(ceil(1.0*w[a]/2) <= w[b] && w[b] <= (w[a] * 2)){\n            // cout<<a<< ' '<<b<<endl;\n            e[a].pb(b);\n            e[b].pb(a);\n        }else {\n            if(w[a] > w[b]) swap(a,b);\n            e[a].pb(b);\n            // cout<<\"###\"<<a<< ' '<< b<<endl;\n        }\n    }\n    // cout<<nline;\n\n    for(int i=1;i<=n;i++) {\n        if(!dfn[i]){\n            tarjan(i);\n        }\n    }\n\n    for(int i=1;i<=scou;i++) din[i] = 0;\n\n    multiset<ull> rcd;\n    for(int i=1;i<=n;i++) {\n        // cout<<\"---\"<<i<< ' ' <<e[i].size()<<endl;\n        for(auto j: e[i]){\n            int a = id[i], b = id[j];\n            // cout<<i<<' ' << a<<endl;\n            // cout<<j<<' ' << b<<endl;\n            if(a != b && !rcd.count(a * 100000 + b)){\n                rcd.insert(a * 100000+b);\n                din[b] ++;\n            }\n        }\n    }\n\n    // for(int i=1;i<=n;i++){\n    //     cout<<id[i]<<' ';\n    // }\n    // cout<<nline;\n\n    // for(int i=1;i<=scou;i++){\n    //     cout<<scnt[i]<<' '<<din[i]<<endl;\n    // }\n    // cout<<endl;\n\n    int cnt =0,ans=0;\n    for(int i=1;i<=scou;i++){\n        if(!din[i] && !ans) ans = scnt[i];\n        else if(!din[i] && ans){\n            cout<<0<<endl;\n            return ;\n        }\n    }\n    cout<<ans<<endl;\n    return ;\n}\n```\n\n\n\n​\t\n","slug":"2024河南CCPC邀请赛-VP","published":1,"updated":"2024-08-15T04:51:11.832Z","comments":1,"layout":"post","photos":[],"_id":"clzwonja50009lowvceutdo2r","content":"<h2 id=\"河南ccpc-vp\">河南CCPC-VP</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4\">Dashboard - 2024 National\r\nInvitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate\r\nProgramming Contest - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h2 id=\"j.-排列与合数\">J. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSg==\">排列与合数<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<span id=\"more\"></span>\r\n<h3 id=\"题意\">题意：</h3>\r\n<p>​\r\n小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。\r\n与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关\r\n的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的：\r\n给定一个有且仅有5\r\n位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位，\r\n但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′\r\n能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345\r\n时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以\r\n重新排列数位得到合数n′=97531=7×13933。\r\n一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。\r\n现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？</p>\r\n<h3 id=\"题解\">题解：</h3>\r\n<p>​\r\n签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(s));</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)</span><br><span class=\"line\">\t\t\t\tt = t * <span class=\"number\">10</span> + (s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &lt;=<span class=\"number\">10000</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i*i&lt;=t;i++)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(t % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf=<span class=\"number\">0</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;t&lt;&lt;endl;flag =<span class=\"number\">1</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(<span class=\"built_in\">all</span>(s)));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!flag) cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"b.扫雷-1\">B.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vQg==\">扫雷 1<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-1\">题意：</h3>\r\n<p>​ T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。\r\n具体来说，T0xel\r\n会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫\r\n雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci\r\n枚扫\r\n雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。\r\n现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tc[i] = a[i].x;</span><br><span class=\"line\">\t\ta[i].y = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tnow ++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(a[flag].y &lt; i) flag++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[flag].y == i)&#123;</span><br><span class=\"line\">\t\t\tans += now / c[i];</span><br><span class=\"line\">\t\t\tnow = now % c[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f.优秀字符串\">F.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vRg==\">优秀字符串<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-2\">题意：</h3>\r\n<p>小A认为，一个字符串S是优秀字符串，当且仅当：</p>\r\n<ul>\r\n<li>S 的长度|S|恰好为5</li>\r\n<li>S 的第三个字符与第五个字符相同</li>\r\n<li>S 的前四个字符互不相同。</li>\r\n</ul>\r\n<p>例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query\r\n的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue\r\n的前四个字符中u出现了两次。\r\n现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中\r\n优秀字符串的数量</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>签到，不做阐述</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>()!=<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tset&lt;<span class=\"type\">char</span>&gt; S;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)S.<span class=\"built_in\">insert</span>(s[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(S.<span class=\"built_in\">size</span>()!=<span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(s[<span class=\"number\">2</span>] != s[<span class=\"number\">4</span>])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tcnt ++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"m.-有效算法\">M. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vTQ==\">有效算法<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-3\">题意：</h3>\r\n<p>给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：</p>\r\n<ul>\r\n<li>将ai 变成满足|ai−x|≤k×bi 的任意整数x。</li>\r\n</ul>\r\n<p>请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。</p>\r\n<h3 id=\"题解-3\">题解：</h3>\r\n<p>分情况讨论绝对值，即可得出以下两个不等式组 <span\r\nclass=\"math display\">\\[\r\na_i \\le x \\le a_i + k * b_i\\\\\r\na_i - k * b_i \\le x \\le a_i\r\n\\]</span>\r\n考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数</p>\r\n<p>考虑暴力一下，枚举的mn到mx为x，发现 <span class=\"math display\">\\[\r\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}\r\n\\]</span>\r\n但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。</p>\r\n<p>转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。</p>\r\n<p>如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。</p>\r\n<p>我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。</p>\r\n<p>注意可能有极端情况<span class=\"math display\">\\[a_i\\]</span>​均相等</p>\r\n<p>神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。</p>\r\n<p>下面是code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tL.<span class=\"built_in\">clear</span>(),R.<span class=\"built_in\">clear</span>(),ves.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tL.<span class=\"built_in\">push_back</span>(a[i].x - x * a[i].y);</span><br><span class=\"line\">\t\tR.<span class=\"built_in\">push_back</span>(a[i].x + x * a[i].y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;mn&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = mn, r = mx;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt; L[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tl = <span class=\"built_in\">max</span>(L[i],l);</span><br><span class=\"line\">\t\tr = <span class=\"built_in\">min</span>(r,R[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt; &#x27; &#x27; &lt;&lt;l&lt;&lt; &#x27; &#x27; &lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;=r) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tmx=<span class=\"built_in\">max</span>(a[i].x,mx);</span><br><span class=\"line\">\t\tmn=<span class=\"built_in\">min</span>(a[i].x,mn);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].x&lt;&lt;&#x27;-&#x27;&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tll l = <span class=\"number\">0</span>, r = mx-mn;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(mid)) r = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"h.随机栈\">H.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSA==\">随机栈<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-4\">题意：</h3>\r\n<p>​ Toxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集\r\nS，从一个非空的随机栈 S 中取出一个\r\n元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会\r\n从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有\r\n2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel\r\n正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插\r\n入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合\r\n非空。Toxel\r\n想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增\r\n的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。\r\n由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。</p>\r\n<h3 id=\"题解-4\">题解：</h3>\r\n<p>题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。</p>\r\n<p>code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">inv</span><span class=\"params\">(ll x)</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">qmi</span>(x,MOD<span class=\"number\">-2</span>);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; a,ords;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=(n&lt;&lt;<span class=\"number\">1</span>);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op;</span><br><span class=\"line\">\t\tcin&gt;&gt;op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(~op) a.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t\tords.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(a));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> op : ords)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt[a[flag]]&lt;&lt; &#x27; &#x27;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tans *= cnt[a[flag]] * <span class=\"built_in\">inv</span>(sum) % MOD;</span><br><span class=\"line\">\t\t\tans %= MOD;</span><br><span class=\"line\">\t\t\tcnt[a[flag]]--;</span><br><span class=\"line\">\t\t\tflag++;</span><br><span class=\"line\">\t\t\tsum--;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcnt[op] ++;sum ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>待续。。。。笔者吃饭去了</p>\r\n<h2 id=\"l.-toxel-与-pcpc-ii\">L. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vTA==\">Toxel 与 PCPC\r\nII<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题面\">题面：</h3>\r\n<p>​ Toxel 正在参加 PCPC（Pokémon Center Programming\r\nContest）比赛。它写的一段代码中有不少\r\nbug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁\r\n定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。\r\nToxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1\r\n行开始，顺序运行完 第i行后退出。Toxel\r\n可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i\r\n秒。接下来，Toxel\r\n会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修\r\n复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4\r\n秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC\r\n的赛场争分夺秒。请你帮Toxel\r\n计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？</p>\r\n<h3 id=\"题解-5\">题解：</h3>\r\n<p>考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d\r\n= j - i，则花费差为 <span class=\"math display\">\\[\r\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\\r\n\\Delta = (x+1)^4 - x^4 - i - 1\r\n\\]</span> 注意到<span\r\nclass=\"math display\">\\[i+1\\]</span>是常数，但对<span\r\nclass=\"math display\">\\[(x+1) ^4- x^4\\]</span>\r\n这个值可能随着我们前面先debug一段而减少。</p>\r\n<p>让我们贪心的考虑，存在前缀，如果我们有<span\r\nclass=\"math display\">\\[(x+1)^4 - x^4 \\le i+1\\]</span>\r\n，则我们一定会向后拓展吗？如果不扩展，我们首先损失了<span\r\nclass=\"math display\">\\[\\Delta\\]</span>，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。</p>\r\n<p>实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> s = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; m &amp;&amp; a[i] + <span class=\"number\">1</span> &gt;= <span class=\"built_in\">qmi</span>((s<span class=\"number\">+1</span>),<span class=\"number\">4</span>) - <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>) )&#123;</span><br><span class=\"line\">\t\t\ts ++;</span><br><span class=\"line\">\t\t\ti ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tans += (a[i] + <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>));</span><br><span class=\"line\">\t\tcout&lt;&lt;i&lt;&lt;<span class=\"string\">&#x27; &#x27;</span> &lt;&lt;ans&lt;&lt;nline;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>该代码在样例</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span> <span class=\"number\">20</span></span><br><span class=\"line\"> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">10</span> <span class=\"number\">11</span> <span class=\"number\">12</span> <span class=\"number\">13</span> <span class=\"number\">14</span> <span class=\"number\">15</span> <span class=\"number\">16</span> <span class=\"number\">17</span> <span class=\"number\">18</span> <span class=\"number\">19</span> <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\r\n<p>计算答案为</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">224</span></span><br></pre></td></tr></table></figure>\r\n<p>但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用<span\r\nclass=\"math display\">\\[(x+1)^4 - x^4\\]</span>去换<span\r\nclass=\"math display\">\\[i+1\\]</span>的成本量，相同情况下当然希望后面的扩展越多越好，此时<span\r\nclass=\"math display\">\\[i\\]</span>更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。</p>\r\n<p>但还是wa，\r\n考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp</p>\r\n<p>根据上面的公式，状态表示为 <span class=\"math display\">\\[\r\nf_i 前i个bug修改所需最小代价\r\n\\]</span> 状态转移表示为 <span class=\"math display\">\\[\r\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) &lt;= a[i-j] + 1\r\n\\&amp;\\&amp; i-j+1 &gt; 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}\r\n\\]</span>\r\n暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。</p>\r\n<p>coding。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tf[i] = f[i<span class=\"number\">-1</span>] + a[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;f[i]&lt;&lt;endl; </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">2</span>;<span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>)- <span class=\"built_in\">qmi</span>(j<span class=\"number\">-1</span>,<span class=\"number\">4</span>) &lt;= a[i-j<span class=\"number\">+1</span>] + <span class=\"number\">1</span> &amp;&amp; i-j<span class=\"number\">+1</span> &gt; <span class=\"number\">0</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tf[i] = <span class=\"built_in\">min</span>(f[i-j] + <span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>) + a[i],f[i]);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt; f[i] &lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-树上问题\">K. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSw==\">树上问题<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-5\">题意:</h3>\r\n<p>​ 378QAQ 有一棵由 n\r\n个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ\r\n认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其\r\n点权都.不 .小 .于其父亲节点的点权的 1 2。\r\n请你计算出有多少个节点是美丽节点。</p>\r\n<h3 id=\"题解-6\">题解：</h3>\r\n<p>​ 若： <span class=\"math display\">\\[\r\na &gt;= b/2\r\n\\]</span> ​ 则： <span class=\"math display\">\\[\r\n2*a &gt;= b \\rightarrow \\{a/2&lt;=b&lt;=2*a\\}\r\n\\]</span> ​\r\n即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。</p>\r\n<p>​ 考虑更换顶点对点关系的影响：</p>\r\n<ol type=\"1\">\r\n<li>原根节点与新的根节点之间一定是父子关系</li>\r\n<li>更换根节点仅更改了原根到新根路径上的节点的父子关系。</li>\r\n</ol>\r\n<p>​\r\n于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。</p>\r\n<p>​\r\n显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。</p>\r\n<p>​\r\n一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。</p>\r\n<p>coding</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    dfn[u] = low[u] = ++timestamp;</span><br><span class=\"line\">    stk[++top] = u, istk[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[v])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(v);</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(istk[v])&#123;</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low[u] == dfn[u])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p;</span><br><span class=\"line\">        scou++;</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            p = stk[top--];</span><br><span class=\"line\">            istk[p] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            scnt[scou]++;</span><br><span class=\"line\">            id[p] = scou;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(p!=u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    scou = top = timestamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) e[i].<span class=\"built_in\">clear</span>(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;a&lt;&lt;&#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">ceil</span>(<span class=\"number\">1.0</span>*w[a]/<span class=\"number\">2</span>) &lt;= w[b] &amp;&amp; w[b] &lt;= (w[a] * <span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w[a] &gt; w[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[i])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++) din[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    multiset&lt;ull&gt; rcd;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;e[i].size()&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j: e[i])&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = id[i], b = id[j];</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27; &lt;&lt; a&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;j&lt;&lt;&#x27; &#x27; &lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a != b &amp;&amp; !rcd.<span class=\"built_in\">count</span>(a * <span class=\"number\">100000</span> + b))&#123;</span><br><span class=\"line\">                rcd.<span class=\"built_in\">insert</span>(a * <span class=\"number\">100000</span>+b);</span><br><span class=\"line\">                din[b] ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;id[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=scou;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;scnt[i]&lt;&lt;&#x27; &#x27;&lt;&lt;din[i]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> cnt =<span class=\"number\">0</span>,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!din[i] &amp;&amp; !ans) ans = scnt[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!din[i] &amp;&amp; ans)&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>​</p>\r\n","length":3746,"excerpt":"<h2 id=\"河南ccpc-vp\">河南CCPC-VP</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4\">Dashboard - 2024 National\r\nInvitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate\r\nProgramming Contest - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h2 id=\"j.-排列与合数\">J. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSg==\">排列与合数<i class=\"fa fa-external-link-alt\"></i></span></h2>","more":"<h3 id=\"题意\">题意：</h3>\r\n<p>​\r\n小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。\r\n与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关\r\n的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的：\r\n给定一个有且仅有5\r\n位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位，\r\n但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′\r\n能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345\r\n时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以\r\n重新排列数位得到合数n′=97531=7×13933。\r\n一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。\r\n现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？</p>\r\n<h3 id=\"题解\">题解：</h3>\r\n<p>​\r\n签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(s));</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)</span><br><span class=\"line\">\t\t\t\tt = t * <span class=\"number\">10</span> + (s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &lt;=<span class=\"number\">10000</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i*i&lt;=t;i++)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(t % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf=<span class=\"number\">0</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;t&lt;&lt;endl;flag =<span class=\"number\">1</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(<span class=\"built_in\">all</span>(s)));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!flag) cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"b.扫雷-1\">B.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vQg==\">扫雷 1<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-1\">题意：</h3>\r\n<p>​ T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。\r\n具体来说，T0xel\r\n会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫\r\n雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci\r\n枚扫\r\n雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。\r\n现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tc[i] = a[i].x;</span><br><span class=\"line\">\t\ta[i].y = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tnow ++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(a[flag].y &lt; i) flag++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[flag].y == i)&#123;</span><br><span class=\"line\">\t\t\tans += now / c[i];</span><br><span class=\"line\">\t\t\tnow = now % c[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f.优秀字符串\">F.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vRg==\">优秀字符串<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-2\">题意：</h3>\r\n<p>小A认为，一个字符串S是优秀字符串，当且仅当：</p>\r\n<ul>\r\n<li>S 的长度|S|恰好为5</li>\r\n<li>S 的第三个字符与第五个字符相同</li>\r\n<li>S 的前四个字符互不相同。</li>\r\n</ul>\r\n<p>例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query\r\n的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue\r\n的前四个字符中u出现了两次。\r\n现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中\r\n优秀字符串的数量</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>签到，不做阐述</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>()!=<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tset&lt;<span class=\"type\">char</span>&gt; S;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)S.<span class=\"built_in\">insert</span>(s[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(S.<span class=\"built_in\">size</span>()!=<span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(s[<span class=\"number\">2</span>] != s[<span class=\"number\">4</span>])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tcnt ++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"m.-有效算法\">M. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vTQ==\">有效算法<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-3\">题意：</h3>\r\n<p>给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：</p>\r\n<ul>\r\n<li>将ai 变成满足|ai−x|≤k×bi 的任意整数x。</li>\r\n</ul>\r\n<p>请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。</p>\r\n<h3 id=\"题解-3\">题解：</h3>\r\n<p>分情况讨论绝对值，即可得出以下两个不等式组 <span\r\nclass=\"math display\">\\[\r\na_i \\le x \\le a_i + k * b_i\\\\\r\na_i - k * b_i \\le x \\le a_i\r\n\\]</span>\r\n考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数</p>\r\n<p>考虑暴力一下，枚举的mn到mx为x，发现 <span class=\"math display\">\\[\r\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}\r\n\\]</span>\r\n但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。</p>\r\n<p>转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。</p>\r\n<p>如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。</p>\r\n<p>我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。</p>\r\n<p>注意可能有极端情况<span class=\"math display\">\\[a_i\\]</span>​均相等</p>\r\n<p>神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。</p>\r\n<p>下面是code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tL.<span class=\"built_in\">clear</span>(),R.<span class=\"built_in\">clear</span>(),ves.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tL.<span class=\"built_in\">push_back</span>(a[i].x - x * a[i].y);</span><br><span class=\"line\">\t\tR.<span class=\"built_in\">push_back</span>(a[i].x + x * a[i].y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;mn&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = mn, r = mx;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt; L[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tl = <span class=\"built_in\">max</span>(L[i],l);</span><br><span class=\"line\">\t\tr = <span class=\"built_in\">min</span>(r,R[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt; &#x27; &#x27; &lt;&lt;l&lt;&lt; &#x27; &#x27; &lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;=r) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tmx=<span class=\"built_in\">max</span>(a[i].x,mx);</span><br><span class=\"line\">\t\tmn=<span class=\"built_in\">min</span>(a[i].x,mn);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].x&lt;&lt;&#x27;-&#x27;&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tll l = <span class=\"number\">0</span>, r = mx-mn;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(mid)) r = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"h.随机栈\">H.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSA==\">随机栈<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-4\">题意：</h3>\r\n<p>​ Toxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集\r\nS，从一个非空的随机栈 S 中取出一个\r\n元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会\r\n从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有\r\n2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel\r\n正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插\r\n入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合\r\n非空。Toxel\r\n想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增\r\n的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。\r\n由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。</p>\r\n<h3 id=\"题解-4\">题解：</h3>\r\n<p>题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。</p>\r\n<p>code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">inv</span><span class=\"params\">(ll x)</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">qmi</span>(x,MOD<span class=\"number\">-2</span>);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; a,ords;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=(n&lt;&lt;<span class=\"number\">1</span>);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op;</span><br><span class=\"line\">\t\tcin&gt;&gt;op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(~op) a.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t\tords.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(a));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> op : ords)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt[a[flag]]&lt;&lt; &#x27; &#x27;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tans *= cnt[a[flag]] * <span class=\"built_in\">inv</span>(sum) % MOD;</span><br><span class=\"line\">\t\t\tans %= MOD;</span><br><span class=\"line\">\t\t\tcnt[a[flag]]--;</span><br><span class=\"line\">\t\t\tflag++;</span><br><span class=\"line\">\t\t\tsum--;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcnt[op] ++;sum ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>待续。。。。笔者吃饭去了</p>\r\n<h2 id=\"l.-toxel-与-pcpc-ii\">L. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vTA==\">Toxel 与 PCPC\r\nII<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题面\">题面：</h3>\r\n<p>​ Toxel 正在参加 PCPC（Pokémon Center Programming\r\nContest）比赛。它写的一段代码中有不少\r\nbug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁\r\n定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。\r\nToxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1\r\n行开始，顺序运行完 第i行后退出。Toxel\r\n可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i\r\n秒。接下来，Toxel\r\n会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修\r\n复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4\r\n秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC\r\n的赛场争分夺秒。请你帮Toxel\r\n计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？</p>\r\n<h3 id=\"题解-5\">题解：</h3>\r\n<p>考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d\r\n= j - i，则花费差为 <span class=\"math display\">\\[\r\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\\r\n\\Delta = (x+1)^4 - x^4 - i - 1\r\n\\]</span> 注意到<span\r\nclass=\"math display\">\\[i+1\\]</span>是常数，但对<span\r\nclass=\"math display\">\\[(x+1) ^4- x^4\\]</span>\r\n这个值可能随着我们前面先debug一段而减少。</p>\r\n<p>让我们贪心的考虑，存在前缀，如果我们有<span\r\nclass=\"math display\">\\[(x+1)^4 - x^4 \\le i+1\\]</span>\r\n，则我们一定会向后拓展吗？如果不扩展，我们首先损失了<span\r\nclass=\"math display\">\\[\\Delta\\]</span>，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。</p>\r\n<p>实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> s = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; m &amp;&amp; a[i] + <span class=\"number\">1</span> &gt;= <span class=\"built_in\">qmi</span>((s<span class=\"number\">+1</span>),<span class=\"number\">4</span>) - <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>) )&#123;</span><br><span class=\"line\">\t\t\ts ++;</span><br><span class=\"line\">\t\t\ti ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tans += (a[i] + <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>));</span><br><span class=\"line\">\t\tcout&lt;&lt;i&lt;&lt;<span class=\"string\">&#x27; &#x27;</span> &lt;&lt;ans&lt;&lt;nline;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>该代码在样例</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span> <span class=\"number\">20</span></span><br><span class=\"line\"> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">10</span> <span class=\"number\">11</span> <span class=\"number\">12</span> <span class=\"number\">13</span> <span class=\"number\">14</span> <span class=\"number\">15</span> <span class=\"number\">16</span> <span class=\"number\">17</span> <span class=\"number\">18</span> <span class=\"number\">19</span> <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\r\n<p>计算答案为</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">224</span></span><br></pre></td></tr></table></figure>\r\n<p>但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用<span\r\nclass=\"math display\">\\[(x+1)^4 - x^4\\]</span>去换<span\r\nclass=\"math display\">\\[i+1\\]</span>的成本量，相同情况下当然希望后面的扩展越多越好，此时<span\r\nclass=\"math display\">\\[i\\]</span>更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。</p>\r\n<p>但还是wa，\r\n考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp</p>\r\n<p>根据上面的公式，状态表示为 <span class=\"math display\">\\[\r\nf_i 前i个bug修改所需最小代价\r\n\\]</span> 状态转移表示为 <span class=\"math display\">\\[\r\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) &lt;= a[i-j] + 1\r\n\\&amp;\\&amp; i-j+1 &gt; 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}\r\n\\]</span>\r\n暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。</p>\r\n<p>coding。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tf[i] = f[i<span class=\"number\">-1</span>] + a[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;f[i]&lt;&lt;endl; </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">2</span>;<span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>)- <span class=\"built_in\">qmi</span>(j<span class=\"number\">-1</span>,<span class=\"number\">4</span>) &lt;= a[i-j<span class=\"number\">+1</span>] + <span class=\"number\">1</span> &amp;&amp; i-j<span class=\"number\">+1</span> &gt; <span class=\"number\">0</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tf[i] = <span class=\"built_in\">min</span>(f[i-j] + <span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>) + a[i],f[i]);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt; f[i] &lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-树上问题\">K. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSw==\">树上问题<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-5\">题意:</h3>\r\n<p>​ 378QAQ 有一棵由 n\r\n个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ\r\n认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其\r\n点权都.不 .小 .于其父亲节点的点权的 1 2。\r\n请你计算出有多少个节点是美丽节点。</p>\r\n<h3 id=\"题解-6\">题解：</h3>\r\n<p>​ 若： <span class=\"math display\">\\[\r\na &gt;= b/2\r\n\\]</span> ​ 则： <span class=\"math display\">\\[\r\n2*a &gt;= b \\rightarrow \\{a/2&lt;=b&lt;=2*a\\}\r\n\\]</span> ​\r\n即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。</p>\r\n<p>​ 考虑更换顶点对点关系的影响：</p>\r\n<ol type=\"1\">\r\n<li>原根节点与新的根节点之间一定是父子关系</li>\r\n<li>更换根节点仅更改了原根到新根路径上的节点的父子关系。</li>\r\n</ol>\r\n<p>​\r\n于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。</p>\r\n<p>​\r\n显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。</p>\r\n<p>​\r\n一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。</p>\r\n<p>coding</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    dfn[u] = low[u] = ++timestamp;</span><br><span class=\"line\">    stk[++top] = u, istk[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[v])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(v);</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(istk[v])&#123;</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low[u] == dfn[u])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p;</span><br><span class=\"line\">        scou++;</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            p = stk[top--];</span><br><span class=\"line\">            istk[p] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            scnt[scou]++;</span><br><span class=\"line\">            id[p] = scou;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(p!=u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    scou = top = timestamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) e[i].<span class=\"built_in\">clear</span>(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;a&lt;&lt;&#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">ceil</span>(<span class=\"number\">1.0</span>*w[a]/<span class=\"number\">2</span>) &lt;= w[b] &amp;&amp; w[b] &lt;= (w[a] * <span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w[a] &gt; w[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[i])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++) din[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    multiset&lt;ull&gt; rcd;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;e[i].size()&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j: e[i])&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = id[i], b = id[j];</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27; &lt;&lt; a&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;j&lt;&lt;&#x27; &#x27; &lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a != b &amp;&amp; !rcd.<span class=\"built_in\">count</span>(a * <span class=\"number\">100000</span> + b))&#123;</span><br><span class=\"line\">                rcd.<span class=\"built_in\">insert</span>(a * <span class=\"number\">100000</span>+b);</span><br><span class=\"line\">                din[b] ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;id[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=scou;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;scnt[i]&lt;&lt;&#x27; &#x27;&lt;&lt;din[i]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> cnt =<span class=\"number\">0</span>,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!din[i] &amp;&amp; !ans) ans = scnt[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!din[i] &amp;&amp; ans)&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>​</p>"},{"title":"2024黑龙江省赛-VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## I.[This is an easy problem](https://codeforces.com/gym/105163/problem/I)\n\n超级无敌简单的签到\n\n<!--more-->\n\n```cpp\nvoid slove() {\n\tint x;\n\tcin>>x;\n\tint s = 0;\n\twhile(x) x-=x&-x, s++;\n\tcout<<s<<endl;\n}\n```\n\n##B.[String](https://codeforces.com/gym/105163/problem/B)\n\n### 题意\n\n斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。\n\n### 题解\n\n可以注意到一种典型的\n\n```cpp\naabcccbba\n```\n\n这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列\n\n```cpp\nvoid slove() {\n\tstring s;\n\tcin>>s;\n\tn = s.size();\n\tfor(int i=0;i<n;++i){\n\t\tstk[++top] = s[i];\n\n\t\t// for(int i=1;i<=top;i++) cout<<stk[i];\n\t\t// \tcout<<endl;\n\n\t\tint cc = 0;\n\t\tfor(int j = top;j>=top-2&& j > 0; --j){\n\t\t\tcc++;\n\t\t\tif(stk[j-1] != stk[j]) break;\n\t\t}\n\n\t\tif(cc == 3){\n\t\t\ttop-=3;\n\t\t}\n\t}\n\n\tif(!top) cout<<\"NAN\"<<endl;\n\tfor(int i=1;i<=top;i++) cout<<stk[i];\n\treturn;\n}\n```\n\n## J.[Trade](https://codeforces.com/gym/105163/problem/J)\n\n在一个繁荣的国家，金斯诺决定从事贸易。\n\n这个国家由 $$n*m$$ 座城市组成。每个城市由一对整数 $$(x, y)$$ 表示，其中 $$1\\leq x\\leq n$$ 和 $$1\\leq y\\leq m$$ 表示其在网格中的位置。在城市 $$(x,y)$$ 中，物品的价格用 $$a[x][y]$$ 表示，到达该城市的旅行费用用 $b[x][y]$ 表示。\n\n在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：\n\n- 路线的起点必须是位于第一行第一列的城市，即 $$(1, 1)$$ 。\n- 路线的终点必须是位于最后一行（ $$x = n$$ ）或最后一列（ $y = m$ ）的城市。\n- 金斯诺只能从城市 $$(x_i, y_i)$$ 移动到 $$(x_i+1, y_i)$$ 或 $$(x_i, y_i+1)$$ 。因此，对于路线中的每一步 $i$ （路线中的最后一步除外）， $$(x_{i+1}, y_{i+1})$$ 必须选择在 $$(x_i, y_i)$$ 的正下方或正右方。\n\n进入路线后，Kingsnow 将在路线的第一个城市 $$(1, 1)$$ 购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。\n\n也就是说，对于任何给定的路线 $$(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)$$ ，Kingsnow 都会从区间 $$[2, k]$$ 中任意选择一个整数 $t$ 。他在城市 $(x_t, y_t)$ 出售商品的利润计算公式为 $$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。\n\n### 题解\n\n然我们重新看一看这个式子\n\n$$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n我们把它简单变换一下\n$$\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]\n$$\n简单思考一下，我们似乎并不关心$$a[x_t][y_t]$$每一个的值，只关心他是否大于右边这个值\n\n再看一看$$n,m \\le 1000$$这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。\n\n```cpp\nint dfs(int x,int y){\n\tif(x==n && y == m) return 1;\n\tif(x >n || y> m || (!st[x][y])) return 0;\n\tst[x][y] = 0;\n\n\tif(dfs(x+1,y)) return 1;\n\tif(dfs(x,y+1)) return 1;\n\n\treturn 0;\n}\n\nvoid slove() {\n\tmemset(f,0x3f,sizeof f);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>a[i][j];\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>b[i][j];\n\n\tf[1][0] = f[0] [1] = 0; \n\tfor(int i = 1;i<=n;i++) for(int j=1;j<=m;j++){\n\t\tf[i][j] = min(f[i-1][j] + b[i][j], f[i][j-1] + b[i][j]);\n\t}\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<f[i][j]<<'\\t';\n\t// \tcout<<endl;\n\t// }\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;++j){\n\t\tif(f[i][j] + a[1][1] <= a[i][j]){\n\t\t\tst[i][j]  = 1;\n\t\t}\n\t}\n\n\tst[1][1] = st[n][m] = 1;\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<st[i][j];\n\t// \tcout<<endl;\n\t// }\n\n\tif(dfs(1,1)) puts(\"YES\");\n\telse puts(\"NO\");\n}\n```\n\n## K. [Puzzle](https://codeforces.com/gym/105163/problem/K)\n\n### 题意\n\n24 字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为 24。\n\nNerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。\n\nNerifish 有四张扑克牌，每张牌上的数字都是 $$a,b,c,d(1\\leq a,b,c,d\\leq 13)$$ 。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含 4 个整数和 3 个运算符。\n\nNerifish 想知道他能得到多少结果。\n\n### 题解\n\n简单的计算可得$$2^8 = 256$$\n\n暴力！\n\n```cpp\nvoid dfs(int u,stack<int> s,set<int>& S){\n\tif(u==3) {\n\t\tint ans = 0;\n\t\twhile(s.size()) ans += s.top(),s.pop();\n\t\t// cout<<ans<<endl;\n\t\tS.insert(ans);\n\t\treturn ;\n\t}\n\tif(u==0) s.push(a[u]);\n\tfor(int i=0;i<3;++i){\n\t\tif(i==0) {\n\t\t\ts.push(a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse if(i == 1) {\n\t\t\ts.push(-a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse {\n\t\t\tint t = s.top();s.pop();\n\t\t\ts.push(t * a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t}\n\treturn ;\n}\n\nvoid slove() {\n\tfor(int i=0;i<4;i++) cin>>a[i];\n\n\tsort(a,a+4);\n\n\tset<int> S;\n\tdo{\n\t\t// for(int i=0;i<4;++i) cout<<a[i] << ' ';\n\t\t// \tcout<<endl;\n\t\tstack<int> t;\n\t\tdfs(0,t, S);\n\t}while(next_permutation(a,a+4));\n\n\tcout<<S.size();\n\treturn ;\n}\n```\n\n## D.[Card Game](https://codeforces.com/gym/105163/problem/D)\n\n### 题意\n\n甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做 *hpa* 和 *hpb* 。每个玩家开始时都有 *n* 张牌，分别叫做 $$a_1, a_2... a_n $$和 *b*1, $$b_1,b_2...b_n$$ ，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。\n\n回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。\n\n我们称 A 打出的牌序列为 $$p_1, p_2... p_n $$，称 B 打出的牌序列为 $$q_1, q_2... q_n$$ ，它们是从 1 到 *n* 的排列。如果在 *i* - *th* 回合之前游戏还没有结束，那么在 *i* - *th* 回合，甲会下 *a**p**i* ，乙会下 *b**q**i* 。\n\n现在你知道了 A 和 B 的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。\n\n### 题解\n\n","source":"_posts/2024黑龙江省赛-VP.md","raw":"---\ntitle: 2024黑龙江省赛-VP\ndate: 2024-08-14 19:46:31\ntags: [icpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- icpc省赛\n---\n\n## I.[This is an easy problem](https://codeforces.com/gym/105163/problem/I)\n\n超级无敌简单的签到\n\n<!--more-->\n\n```cpp\nvoid slove() {\n\tint x;\n\tcin>>x;\n\tint s = 0;\n\twhile(x) x-=x&-x, s++;\n\tcout<<s<<endl;\n}\n```\n\n##B.[String](https://codeforces.com/gym/105163/problem/B)\n\n### 题意\n\n斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。\n\n### 题解\n\n可以注意到一种典型的\n\n```cpp\naabcccbba\n```\n\n这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列\n\n```cpp\nvoid slove() {\n\tstring s;\n\tcin>>s;\n\tn = s.size();\n\tfor(int i=0;i<n;++i){\n\t\tstk[++top] = s[i];\n\n\t\t// for(int i=1;i<=top;i++) cout<<stk[i];\n\t\t// \tcout<<endl;\n\n\t\tint cc = 0;\n\t\tfor(int j = top;j>=top-2&& j > 0; --j){\n\t\t\tcc++;\n\t\t\tif(stk[j-1] != stk[j]) break;\n\t\t}\n\n\t\tif(cc == 3){\n\t\t\ttop-=3;\n\t\t}\n\t}\n\n\tif(!top) cout<<\"NAN\"<<endl;\n\tfor(int i=1;i<=top;i++) cout<<stk[i];\n\treturn;\n}\n```\n\n## J.[Trade](https://codeforces.com/gym/105163/problem/J)\n\n在一个繁荣的国家，金斯诺决定从事贸易。\n\n这个国家由 $$n*m$$ 座城市组成。每个城市由一对整数 $$(x, y)$$ 表示，其中 $$1\\leq x\\leq n$$ 和 $$1\\leq y\\leq m$$ 表示其在网格中的位置。在城市 $$(x,y)$$ 中，物品的价格用 $$a[x][y]$$ 表示，到达该城市的旅行费用用 $b[x][y]$ 表示。\n\n在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：\n\n- 路线的起点必须是位于第一行第一列的城市，即 $$(1, 1)$$ 。\n- 路线的终点必须是位于最后一行（ $$x = n$$ ）或最后一列（ $y = m$ ）的城市。\n- 金斯诺只能从城市 $$(x_i, y_i)$$ 移动到 $$(x_i+1, y_i)$$ 或 $$(x_i, y_i+1)$$ 。因此，对于路线中的每一步 $i$ （路线中的最后一步除外）， $$(x_{i+1}, y_{i+1})$$ 必须选择在 $$(x_i, y_i)$$ 的正下方或正右方。\n\n进入路线后，Kingsnow 将在路线的第一个城市 $$(1, 1)$$ 购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。\n\n也就是说，对于任何给定的路线 $$(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)$$ ，Kingsnow 都会从区间 $$[2, k]$$ 中任意选择一个整数 $t$ 。他在城市 $(x_t, y_t)$ 出售商品的利润计算公式为 $$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。\n\n### 题解\n\n然我们重新看一看这个式子\n\n$$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n我们把它简单变换一下\n$$\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]\n$$\n简单思考一下，我们似乎并不关心$$a[x_t][y_t]$$每一个的值，只关心他是否大于右边这个值\n\n再看一看$$n,m \\le 1000$$这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。\n\n```cpp\nint dfs(int x,int y){\n\tif(x==n && y == m) return 1;\n\tif(x >n || y> m || (!st[x][y])) return 0;\n\tst[x][y] = 0;\n\n\tif(dfs(x+1,y)) return 1;\n\tif(dfs(x,y+1)) return 1;\n\n\treturn 0;\n}\n\nvoid slove() {\n\tmemset(f,0x3f,sizeof f);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>a[i][j];\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>b[i][j];\n\n\tf[1][0] = f[0] [1] = 0; \n\tfor(int i = 1;i<=n;i++) for(int j=1;j<=m;j++){\n\t\tf[i][j] = min(f[i-1][j] + b[i][j], f[i][j-1] + b[i][j]);\n\t}\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<f[i][j]<<'\\t';\n\t// \tcout<<endl;\n\t// }\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;++j){\n\t\tif(f[i][j] + a[1][1] <= a[i][j]){\n\t\t\tst[i][j]  = 1;\n\t\t}\n\t}\n\n\tst[1][1] = st[n][m] = 1;\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<st[i][j];\n\t// \tcout<<endl;\n\t// }\n\n\tif(dfs(1,1)) puts(\"YES\");\n\telse puts(\"NO\");\n}\n```\n\n## K. [Puzzle](https://codeforces.com/gym/105163/problem/K)\n\n### 题意\n\n24 字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为 24。\n\nNerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。\n\nNerifish 有四张扑克牌，每张牌上的数字都是 $$a,b,c,d(1\\leq a,b,c,d\\leq 13)$$ 。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含 4 个整数和 3 个运算符。\n\nNerifish 想知道他能得到多少结果。\n\n### 题解\n\n简单的计算可得$$2^8 = 256$$\n\n暴力！\n\n```cpp\nvoid dfs(int u,stack<int> s,set<int>& S){\n\tif(u==3) {\n\t\tint ans = 0;\n\t\twhile(s.size()) ans += s.top(),s.pop();\n\t\t// cout<<ans<<endl;\n\t\tS.insert(ans);\n\t\treturn ;\n\t}\n\tif(u==0) s.push(a[u]);\n\tfor(int i=0;i<3;++i){\n\t\tif(i==0) {\n\t\t\ts.push(a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse if(i == 1) {\n\t\t\ts.push(-a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse {\n\t\t\tint t = s.top();s.pop();\n\t\t\ts.push(t * a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t}\n\treturn ;\n}\n\nvoid slove() {\n\tfor(int i=0;i<4;i++) cin>>a[i];\n\n\tsort(a,a+4);\n\n\tset<int> S;\n\tdo{\n\t\t// for(int i=0;i<4;++i) cout<<a[i] << ' ';\n\t\t// \tcout<<endl;\n\t\tstack<int> t;\n\t\tdfs(0,t, S);\n\t}while(next_permutation(a,a+4));\n\n\tcout<<S.size();\n\treturn ;\n}\n```\n\n## D.[Card Game](https://codeforces.com/gym/105163/problem/D)\n\n### 题意\n\n甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做 *hpa* 和 *hpb* 。每个玩家开始时都有 *n* 张牌，分别叫做 $$a_1, a_2... a_n $$和 *b*1, $$b_1,b_2...b_n$$ ，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。\n\n回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。\n\n我们称 A 打出的牌序列为 $$p_1, p_2... p_n $$，称 B 打出的牌序列为 $$q_1, q_2... q_n$$ ，它们是从 1 到 *n* 的排列。如果在 *i* - *th* 回合之前游戏还没有结束，那么在 *i* - *th* 回合，甲会下 *a**p**i* ，乙会下 *b**q**i* 。\n\n现在你知道了 A 和 B 的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。\n\n### 题解\n\n","slug":"2024黑龙江省赛-VP","published":1,"updated":"2024-08-15T04:51:22.977Z","comments":1,"layout":"post","photos":[],"_id":"clzwonja6000blowvhnjr5ed1","content":"<h2 id=\"i.this-is-an-easy-problem\">I.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSQ==\">This is an easy\r\nproblem<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<p>超级无敌简单的签到</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\tcin&gt;&gt;x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(x) x-=x&amp;-x, s++;</span><br><span class=\"line\">\tcout&lt;&lt;s&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>##B.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vQg==\">String<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>可以注意到一种典型的</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aabcccbba</span><br></pre></td></tr></table></figure>\r\n<p>这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;</span><br><span class=\"line\">\tcin&gt;&gt;s;</span><br><span class=\"line\">\tn = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">\t\tstk[++top] = s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=1;i&lt;=top;i++) cout&lt;&lt;stk[i];</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cc = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = top;j&gt;=top<span class=\"number\">-2</span>&amp;&amp; j &gt; <span class=\"number\">0</span>; --j)&#123;</span><br><span class=\"line\">\t\t\tcc++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stk[j<span class=\"number\">-1</span>] != stk[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cc == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\ttop-=<span class=\"number\">3</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!top) cout&lt;&lt;<span class=\"string\">&quot;NAN&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=top;i++) cout&lt;&lt;stk[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"j.trade\">J.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSg==\">Trade<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<p>在一个繁荣的国家，金斯诺决定从事贸易。</p>\r\n<p>这个国家由 <span class=\"math display\">\\[n*m\\]</span>\r\n座城市组成。每个城市由一对整数 <span class=\"math display\">\\[(x,\r\ny)\\]</span> 表示，其中 <span class=\"math display\">\\[1\\leq x\\leq\r\nn\\]</span> 和 <span class=\"math display\">\\[1\\leq y\\leq m\\]</span>\r\n表示其在网格中的位置。在城市 <span class=\"math display\">\\[(x,y)\\]</span>\r\n中，物品的价格用 <span class=\"math display\">\\[a[x][y]\\]</span>\r\n表示，到达该城市的旅行费用用 <span\r\nclass=\"math inline\">\\(b[x][y]\\)</span> 表示。</p>\r\n<p>在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：</p>\r\n<ul>\r\n<li>路线的起点必须是位于第一行第一列的城市，即 <span\r\nclass=\"math display\">\\[(1, 1)\\]</span> 。</li>\r\n<li>路线的终点必须是位于最后一行（ <span class=\"math display\">\\[x =\r\nn\\]</span> ）或最后一列（ <span class=\"math inline\">\\(y = m\\)</span>\r\n）的城市。</li>\r\n<li>金斯诺只能从城市 <span class=\"math display\">\\[(x_i, y_i)\\]</span>\r\n移动到 <span class=\"math display\">\\[(x_i+1, y_i)\\]</span> 或 <span\r\nclass=\"math display\">\\[(x_i, y_i+1)\\]</span> 。因此，对于路线中的每一步\r\n<span class=\"math inline\">\\(i\\)</span> （路线中的最后一步除外）， <span\r\nclass=\"math display\">\\[(x_{i+1}, y_{i+1})\\]</span> 必须选择在 <span\r\nclass=\"math display\">\\[(x_i, y_i)\\]</span> 的正下方或正右方。</li>\r\n</ul>\r\n<p>进入路线后，Kingsnow 将在路线的第一个城市 <span\r\nclass=\"math display\">\\[(1, 1)\\]</span>\r\n购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。</p>\r\n<p>也就是说，对于任何给定的路线 <span class=\"math display\">\\[(x_1, y_1),\r\n(x_2, y_2), ..., (x_k, y_k)\\]</span> ，Kingsnow 都会从区间 <span\r\nclass=\"math display\">\\[[2, k]\\]</span> 中任意选择一个整数 <span\r\nclass=\"math inline\">\\(t\\)</span> 。他在城市 <span\r\nclass=\"math inline\">\\((x_t, y_t)\\)</span> 出售商品的利润计算公式为 <span\r\nclass=\"math display\">\\[ \\text{Profit} = a[x_t][y_t] - a[1][1] -\r\n\\sum_{i=1}^t b[x_i][y_i]\\]</span></p>\r\n<p>金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>然我们重新看一看这个式子</p>\r\n<p><span class=\"math display\">\\[ \\text{Profit} = a[x_t][y_t] - a[1][1] -\r\n\\sum_{i=1}^t b[x_i][y_i]\\]</span></p>\r\n<p>我们把它简单变换一下 <span class=\"math display\">\\[\r\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\r\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\r\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]\r\n\\]</span> 简单思考一下，我们似乎并不关心<span\r\nclass=\"math display\">\\[a[x_t][y_t]\\]</span>每一个的值，只关心他是否大于右边这个值</p>\r\n<p>再看一看<span class=\"math display\">\\[n,m \\le\r\n1000\\]</span>这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x==n &amp;&amp; y == m) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt;n || y&gt; m || (!st[x][y])) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tst[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>,y)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x,y<span class=\"number\">+1</span>)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;b[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\tf[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = f[<span class=\"number\">0</span>] [<span class=\"number\">1</span>] = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\tf[i][j] = <span class=\"built_in\">min</span>(f[i<span class=\"number\">-1</span>][j] + b[i][j], f[i][j<span class=\"number\">-1</span>] + b[i][j]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;f[i][j]&lt;&lt;&#x27;\\t&#x27;;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i][j] + a[<span class=\"number\">1</span>][<span class=\"number\">1</span>] &lt;= a[i][j])&#123;</span><br><span class=\"line\">\t\t\tst[i][j]  = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tst[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = st[n][m] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;st[i][j];</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>)) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-puzzle\">K. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSw==\">Puzzle<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>24\r\n字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为\r\n24。</p>\r\n<p>Nerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。</p>\r\n<p>Nerifish 有四张扑克牌，每张牌上的数字都是 <span\r\nclass=\"math display\">\\[a,b,c,d(1\\leq a,b,c,d\\leq 13)\\]</span>\r\n。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含\r\n4 个整数和 3 个运算符。</p>\r\n<p>Nerifish 想知道他能得到多少结果。</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>简单的计算可得<span class=\"math display\">\\[2^8 = 256\\]</span></p>\r\n<p>暴力！</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,stack&lt;<span class=\"type\">int</span>&gt; s,set&lt;<span class=\"type\">int</span>&gt;&amp; S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(s.<span class=\"built_in\">size</span>()) ans += s.<span class=\"built_in\">top</span>(),s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tS.<span class=\"built_in\">insert</span>(ans);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">0</span>) s.<span class=\"built_in\">push</span>(a[u]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(-a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = s.<span class=\"built_in\">top</span>();s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(t * a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a,a<span class=\"number\">+4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tset&lt;<span class=\"type\">int</span>&gt; S;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=0;i&lt;4;++i) cout&lt;&lt;a[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tstack&lt;<span class=\"type\">int</span>&gt; t;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,t, S);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(a,a<span class=\"number\">+4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;S.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d.card-game\">D.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vRA==\">Card Game<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做\r\n<em>hpa</em> 和 <em>hpb</em> 。每个玩家开始时都有 <em>n</em>\r\n张牌，分别叫做 <span class=\"math display\">\\[a_1, a_2... a_n \\]</span>和\r\n<em>b</em>1, <span class=\"math display\">\\[b_1,b_2...b_n\\]</span>\r\n，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。</p>\r\n<p>回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。</p>\r\n<p>我们称 A 打出的牌序列为 <span class=\"math display\">\\[p_1, p_2... p_n\r\n\\]</span>，称 B 打出的牌序列为 <span class=\"math display\">\\[q_1, q_2...\r\nq_n\\]</span> ，它们是从 1 到 <em>n</em> 的排列。如果在\r\n<em>i</em> - <em>th</em> 回合之前游戏还没有结束，那么在\r\n<em>i</em> - <em>th</em> 回合，甲会下 <em>a<strong>p</strong>i</em>\r\n，乙会下 <em>b<strong>q</strong>i</em> 。</p>\r\n<p>现在你知道了 A 和 B\r\n的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n","length":1796,"excerpt":"<h2 id=\"i.this-is-an-easy-problem\">I.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSQ==\">This is an easy\r\nproblem<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<p>超级无敌简单的签到</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\tcin&gt;&gt;x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(x) x-=x&amp;-x, s++;</span><br><span class=\"line\">\tcout&lt;&lt;s&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>##B.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vQg==\">String<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>可以注意到一种典型的</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aabcccbba</span><br></pre></td></tr></table></figure>\r\n<p>这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;</span><br><span class=\"line\">\tcin&gt;&gt;s;</span><br><span class=\"line\">\tn = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">\t\tstk[++top] = s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=1;i&lt;=top;i++) cout&lt;&lt;stk[i];</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cc = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = top;j&gt;=top<span class=\"number\">-2</span>&amp;&amp; j &gt; <span class=\"number\">0</span>; --j)&#123;</span><br><span class=\"line\">\t\t\tcc++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stk[j<span class=\"number\">-1</span>] != stk[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cc == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\ttop-=<span class=\"number\">3</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!top) cout&lt;&lt;<span class=\"string\">&quot;NAN&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=top;i++) cout&lt;&lt;stk[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"j.trade\">J.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSg==\">Trade<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<p>在一个繁荣的国家，金斯诺决定从事贸易。</p>\r\n<p>这个国家由 <span class=\"math display\">\\[n*m\\]</span>\r\n座城市组成。每个城市由一对整数 <span class=\"math display\">\\[(x,\r\ny)\\]</span> 表示，其中 <span class=\"math display\">\\[1\\leq x\\leq\r\nn\\]</span> 和 <span class=\"math display\">\\[1\\leq y\\leq m\\]</span>\r\n表示其在网格中的位置。在城市 <span class=\"math display\">\\[(x,y)\\]</span>\r\n中，物品的价格用 <span class=\"math display\">\\[a[x][y]\\]</span>\r\n表示，到达该城市的旅行费用用 <span\r\nclass=\"math inline\">\\(b[x][y]\\)</span> 表示。</p>\r\n<p>在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：</p>\r\n<ul>\r\n<li>路线的起点必须是位于第一行第一列的城市，即 <span\r\nclass=\"math display\">\\[(1, 1)\\]</span> 。</li>\r\n<li>路线的终点必须是位于最后一行（ <span class=\"math display\">\\[x =\r\nn\\]</span> ）或最后一列（ <span class=\"math inline\">\\(y = m\\)</span>\r\n）的城市。</li>\r\n<li>金斯诺只能从城市 <span class=\"math display\">\\[(x_i, y_i)\\]</span>\r\n移动到 <span class=\"math display\">\\[(x_i+1, y_i)\\]</span> 或 <span\r\nclass=\"math display\">\\[(x_i, y_i+1)\\]</span> 。因此，对于路线中的每一步\r\n<span class=\"math inline\">\\(i\\)</span> （路线中的最后一步除外）， <span\r\nclass=\"math display\">\\[(x_{i+1}, y_{i+1})\\]</span> 必须选择在 <span\r\nclass=\"math display\">\\[(x_i, y_i)\\]</span> 的正下方或正右方。</li>\r\n</ul>\r\n<p>进入路线后，Kingsnow 将在路线的第一个城市 <span\r\nclass=\"math display\">\\[(1, 1)\\]</span>\r\n购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。</p>\r\n<p>也就是说，对于任何给定的路线 <span class=\"math display\">\\[(x_1, y_1),\r\n(x_2, y_2), ..., (x_k, y_k)\\]</span> ，Kingsnow 都会从区间 <span\r\nclass=\"math display\">\\[[2, k]\\]</span> 中任意选择一个整数 <span\r\nclass=\"math inline\">\\(t\\)</span> 。他在城市 <span\r\nclass=\"math inline\">\\((x_t, y_t)\\)</span> 出售商品的利润计算公式为 <span\r\nclass=\"math display\">\\[ \\text{Profit} = a[x_t][y_t] - a[1][1] -\r\n\\sum_{i=1}^t b[x_i][y_i]\\]</span></p>\r\n<p>金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>然我们重新看一看这个式子</p>\r\n<p><span class=\"math display\">\\[ \\text{Profit} = a[x_t][y_t] - a[1][1] -\r\n\\sum_{i=1}^t b[x_i][y_i]\\]</span></p>\r\n<p>我们把它简单变换一下 <span class=\"math display\">\\[\r\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\r\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\r\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]\r\n\\]</span> 简单思考一下，我们似乎并不关心<span\r\nclass=\"math display\">\\[a[x_t][y_t]\\]</span>每一个的值，只关心他是否大于右边这个值</p>\r\n<p>再看一看<span class=\"math display\">\\[n,m \\le\r\n1000\\]</span>这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x==n &amp;&amp; y == m) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt;n || y&gt; m || (!st[x][y])) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tst[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>,y)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x,y<span class=\"number\">+1</span>)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;b[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\tf[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = f[<span class=\"number\">0</span>] [<span class=\"number\">1</span>] = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\tf[i][j] = <span class=\"built_in\">min</span>(f[i<span class=\"number\">-1</span>][j] + b[i][j], f[i][j<span class=\"number\">-1</span>] + b[i][j]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;f[i][j]&lt;&lt;&#x27;\\t&#x27;;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i][j] + a[<span class=\"number\">1</span>][<span class=\"number\">1</span>] &lt;= a[i][j])&#123;</span><br><span class=\"line\">\t\t\tst[i][j]  = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tst[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = st[n][m] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;st[i][j];</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>)) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-puzzle\">K. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSw==\">Puzzle<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>24\r\n字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为\r\n24。</p>\r\n<p>Nerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。</p>\r\n<p>Nerifish 有四张扑克牌，每张牌上的数字都是 <span\r\nclass=\"math display\">\\[a,b,c,d(1\\leq a,b,c,d\\leq 13)\\]</span>\r\n。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含\r\n4 个整数和 3 个运算符。</p>\r\n<p>Nerifish 想知道他能得到多少结果。</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>简单的计算可得<span class=\"math display\">\\[2^8 = 256\\]</span></p>\r\n<p>暴力！</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,stack&lt;<span class=\"type\">int</span>&gt; s,set&lt;<span class=\"type\">int</span>&gt;&amp; S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(s.<span class=\"built_in\">size</span>()) ans += s.<span class=\"built_in\">top</span>(),s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tS.<span class=\"built_in\">insert</span>(ans);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">0</span>) s.<span class=\"built_in\">push</span>(a[u]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(-a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = s.<span class=\"built_in\">top</span>();s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(t * a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a,a<span class=\"number\">+4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tset&lt;<span class=\"type\">int</span>&gt; S;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=0;i&lt;4;++i) cout&lt;&lt;a[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tstack&lt;<span class=\"type\">int</span>&gt; t;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,t, S);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(a,a<span class=\"number\">+4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;S.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d.card-game\">D.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vRA==\">Card Game<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做\r\n<em>hpa</em> 和 <em>hpb</em> 。每个玩家开始时都有 <em>n</em>\r\n张牌，分别叫做 <span class=\"math display\">\\[a_1, a_2... a_n \\]</span>和\r\n<em>b</em>1, <span class=\"math display\">\\[b_1,b_2...b_n\\]</span>\r\n，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。</p>\r\n<p>回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。</p>\r\n<p>我们称 A 打出的牌序列为 <span class=\"math display\">\\[p_1, p_2... p_n\r\n\\]</span>，称 B 打出的牌序列为 <span class=\"math display\">\\[q_1, q_2...\r\nq_n\\]</span> ，它们是从 1 到 <em>n</em> 的排列。如果在\r\n<em>i</em> - <em>th</em> 回合之前游戏还没有结束，那么在\r\n<em>i</em> - <em>th</em> 回合，甲会下 <em>a<strong>p</strong>i</em>\r\n，乙会下 <em>b<strong>q</strong>i</em> 。</p>\r\n<p>现在你知道了 A 和 B\r\n的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。</p>\r\n<h3 id=\"题解-3\">题解</h3>"},{"title":"Latex宏包pgfplots做矩形函数图像","date":"2024-08-14T11:47:58.000Z","_content":"持续更新遇到的问题，完结或不再使用该包将删除这句话\n\n## pgfplots\n\nPgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。\n\n<!--more-->\n\n### 实例一、通过函数方程绘制函数图像\n\n```latex\n%Ex1:f(x)=exp(x)\n\\begin{tikzpicture}\n\\begin{axis}\n\\addplot[color=red]{exp(x)};\n\\end{axis}\n\\end{tikzpicture}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png)\n\n其中绘制图像的语法如下：\n\n```latex\n\\addplot[option] {expression of 2D function};\n```\n\n在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 **;** 结尾。\n\n### 实例二、坐标系的绘制以及3d函数图像\n\n```latex\n\\documentclass{ctexart}\n\\pagestyle{empty}\n\\usepackage{pgfplots}\n\\begin{document}\n%Ex2: put the 2D plot and the 3D plot together\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot[color=red]{exp(x)};\n\t\\end{axis}\n\\end{tikzpicture}\n%Here ends the furst 2D plot\n\n\\hskip 10pt\n\n%Here begins the 3d plot\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot3[\n\t\tsurf,\n\t\t]\n\t\t{exp(-x^2-y^2)*x};\n\t\\end{axis}\n\\end{tikzpicture}\n\\end{document}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png)\n\n```latex\n\\addplot3[\n    surf,\n]\n{exp(-x^2-y^2)*x};\n```\n\n注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。\n\n可以看到对多个图像只需要设定多个tikzpicture作用域即可\n\n#### 坐标系图像中的常用命令、参数与特性\n\n- xlabel、ylabel：设定x,y坐标轴上的标志。\n- 多个addplot可在同一个图中多次作图\n- $$\\tt{domian = a:b}$$设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；\n- $$\\tt{axis\\,\\, lines = left}$$这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；\n- \\addlegendentry{$function（x)$​} 添加函数标签 \n- \\legend 按顺序批量谭家函数标签\n- title在axis中为图像添加标题\n\n### 实例三、数据图\n\n```latex\n%Ex6:plot from data\n\\begin{tikzpicture}\n\t\\begin{axis}[\n\t\ttitle={Temperature dependence of CuSO$_4\\cdot$5H$_2$O solubility},\n\t\txlabel={Temperature [\\textcelsius]},\n\t\tylabel={Solubility [g per 100 g water]},\n\t\txmin=0, xmax=100,\n\t\tymin=0, ymax=120,\n\t\txtick={0,20,40,60,80,100},\n\t\tytick={0,20,40,60,80,100,120},\n\t\tlegend pos=north west,\n\t\tymajorgrids=true,\n\t\tgrid style=dashed,\n\t\t]\n\t\t\n\t\t\\addplot[\n\t\tcolor=blue,\n\t\tmark=square,\n\t\t]\n\t\tcoordinates {\n\t\t\t(0,23.1)\n\t\t\t(10,27.5)\n\t\t\t(20,32)\n\t\t\t(30,37.8)\n\t\t\t(40,44.6)\n\t\t\t(60,61.8)\n\t\t\t(80,83.8)\n\t\t\t(100,114)\n\t\t};\n\t\t\\legend{CuSO$_4\\cdot$5H$_2$O}\n\t\t\n\t\\end{axis}\n\\end{tikzpicture}\n```\n\n\n\n#### 数据图像中的常用命令、参数与特性![test-1-crop-1](https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png)\n\n- mark：设定图像点的形状；如square、triangle、x等\n- $$\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}$$​启用/禁用 𝑦,𝑥 轴上**刻度线位置上**的网格线；\n- $$\\tt{xmin=a, xmax=b, ymin=c, ymax=d}$$​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；\n- $$\\tt{coordinates \\{\\}}$$​设定坐标点画折线图\n- \\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图\n\n### 其他图像\n\npgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。\n\n### 导言区的一些设定\n\n```latex\n\\pgfplotsset{width=10cm}\n```\n\n这里指定了每一张图的宽度为10cm\n\n```tex\n\\usepgfplotslibrary{external}\n\\tikzexternalize \n```\n\n由于$$LATEX$$ 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。","source":"_posts/Latex宏包pgfplots做矩形函数图像.md","raw":"---\ntitle: Latex宏包pgfplots做矩形函数图像\ndate: 2024-08-14 19:47:58\ntags: [Latex, 图像处理]\ncategories: \n\t- 软件\n\t- 工具类软件\n---\n持续更新遇到的问题，完结或不再使用该包将删除这句话\n\n## pgfplots\n\nPgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。\n\n<!--more-->\n\n### 实例一、通过函数方程绘制函数图像\n\n```latex\n%Ex1:f(x)=exp(x)\n\\begin{tikzpicture}\n\\begin{axis}\n\\addplot[color=red]{exp(x)};\n\\end{axis}\n\\end{tikzpicture}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png)\n\n其中绘制图像的语法如下：\n\n```latex\n\\addplot[option] {expression of 2D function};\n```\n\n在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 **;** 结尾。\n\n### 实例二、坐标系的绘制以及3d函数图像\n\n```latex\n\\documentclass{ctexart}\n\\pagestyle{empty}\n\\usepackage{pgfplots}\n\\begin{document}\n%Ex2: put the 2D plot and the 3D plot together\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot[color=red]{exp(x)};\n\t\\end{axis}\n\\end{tikzpicture}\n%Here ends the furst 2D plot\n\n\\hskip 10pt\n\n%Here begins the 3d plot\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot3[\n\t\tsurf,\n\t\t]\n\t\t{exp(-x^2-y^2)*x};\n\t\\end{axis}\n\\end{tikzpicture}\n\\end{document}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png)\n\n```latex\n\\addplot3[\n    surf,\n]\n{exp(-x^2-y^2)*x};\n```\n\n注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。\n\n可以看到对多个图像只需要设定多个tikzpicture作用域即可\n\n#### 坐标系图像中的常用命令、参数与特性\n\n- xlabel、ylabel：设定x,y坐标轴上的标志。\n- 多个addplot可在同一个图中多次作图\n- $$\\tt{domian = a:b}$$设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；\n- $$\\tt{axis\\,\\, lines = left}$$这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；\n- \\addlegendentry{$function（x)$​} 添加函数标签 \n- \\legend 按顺序批量谭家函数标签\n- title在axis中为图像添加标题\n\n### 实例三、数据图\n\n```latex\n%Ex6:plot from data\n\\begin{tikzpicture}\n\t\\begin{axis}[\n\t\ttitle={Temperature dependence of CuSO$_4\\cdot$5H$_2$O solubility},\n\t\txlabel={Temperature [\\textcelsius]},\n\t\tylabel={Solubility [g per 100 g water]},\n\t\txmin=0, xmax=100,\n\t\tymin=0, ymax=120,\n\t\txtick={0,20,40,60,80,100},\n\t\tytick={0,20,40,60,80,100,120},\n\t\tlegend pos=north west,\n\t\tymajorgrids=true,\n\t\tgrid style=dashed,\n\t\t]\n\t\t\n\t\t\\addplot[\n\t\tcolor=blue,\n\t\tmark=square,\n\t\t]\n\t\tcoordinates {\n\t\t\t(0,23.1)\n\t\t\t(10,27.5)\n\t\t\t(20,32)\n\t\t\t(30,37.8)\n\t\t\t(40,44.6)\n\t\t\t(60,61.8)\n\t\t\t(80,83.8)\n\t\t\t(100,114)\n\t\t};\n\t\t\\legend{CuSO$_4\\cdot$5H$_2$O}\n\t\t\n\t\\end{axis}\n\\end{tikzpicture}\n```\n\n\n\n#### 数据图像中的常用命令、参数与特性![test-1-crop-1](https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png)\n\n- mark：设定图像点的形状；如square、triangle、x等\n- $$\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}$$​启用/禁用 𝑦,𝑥 轴上**刻度线位置上**的网格线；\n- $$\\tt{xmin=a, xmax=b, ymin=c, ymax=d}$$​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；\n- $$\\tt{coordinates \\{\\}}$$​设定坐标点画折线图\n- \\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图\n\n### 其他图像\n\npgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。\n\n### 导言区的一些设定\n\n```latex\n\\pgfplotsset{width=10cm}\n```\n\n这里指定了每一张图的宽度为10cm\n\n```tex\n\\usepgfplotslibrary{external}\n\\tikzexternalize \n```\n\n由于$$LATEX$$ 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。","slug":"Latex宏包pgfplots做矩形函数图像","published":1,"updated":"2024-08-14T13:38:44.943Z","comments":1,"layout":"post","photos":[],"_id":"clzwonja8000glowv9824892s","content":"<p>持续更新遇到的问题，完结或不再使用该包将删除这句话</p>\r\n<h2 id=\"pgfplots\">pgfplots</h2>\r\n<p>Pgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots\r\n宏包会帮助用户绘制响应的图像。</p>\r\n<span id=\"more\"></span>\r\n<h3\r\nid=\"实例一通过函数方程绘制函数图像\">实例一、通过函数方程绘制函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex1:f(x)=exp(x)</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<p>其中绘制图像的语法如下：</p>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>[option] &#123;expression of 2D function&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D\r\n函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥)\r\n。最后最重要的是该命令必须以分号 <strong>;</strong> 结尾。</p>\r\n<h3\r\nid=\"实例二坐标系的绘制以及3d函数图像\">实例二、坐标系的绘制以及3d函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\documentclass</span>&#123;ctexart&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\pagestyle</span>&#123;empty&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\usepackage</span>&#123;pgfplots&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;document&#125;</span><br><span class=\"line\"><span class=\"comment\">%Ex2: put the 2D plot and the 3D plot together</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"comment\">%Here ends the furst 2D plot</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">\\hskip</span> 10pt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%Here begins the 3d plot</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">\t\tsurf,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">    surf,</span><br><span class=\"line\">]</span><br><span class=\"line\">&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。</p>\r\n<p>可以看到对多个图像只需要设定多个tikzpicture作用域即可</p>\r\n<h4\r\nid=\"坐标系图像中的常用命令参数与特性\">坐标系图像中的常用命令、参数与特性</h4>\r\n<ul>\r\n<li>xlabel、ylabel：设定x,y坐标轴上的标志。</li>\r\n<li>多个addplot可在同一个图中多次作图</li>\r\n<li><span class=\"math display\">\\[\\tt{domian = a:b}\\]</span>设置 𝑥\r\n的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；</li>\r\n<li><span class=\"math display\">\\[\\tt{axis\\,\\, lines =\r\nleft}\\]</span>这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；</li>\r\n<li> 添加函数标签</li>\r\n<li>按顺序批量谭家函数标签</li>\r\n<li>title在axis中为图像添加标题</li>\r\n</ul>\r\n<h3 id=\"实例三数据图\">实例三、数据图</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex6:plot from data</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;[</span><br><span class=\"line\">\t\ttitle=&#123;Temperature dependence of CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O solubility&#125;,</span><br><span class=\"line\">\t\txlabel=&#123;Temperature [<span class=\"keyword\">\\textcelsius</span>]&#125;,</span><br><span class=\"line\">\t\tylabel=&#123;Solubility [g per 100 g water]&#125;,</span><br><span class=\"line\">\t\txmin=0, xmax=100,</span><br><span class=\"line\">\t\tymin=0, ymax=120,</span><br><span class=\"line\">\t\txtick=&#123;0,20,40,60,80,100&#125;,</span><br><span class=\"line\">\t\tytick=&#123;0,20,40,60,80,100,120&#125;,</span><br><span class=\"line\">\t\tlegend pos=north west,</span><br><span class=\"line\">\t\tymajorgrids=true,</span><br><span class=\"line\">\t\tgrid style=dashed,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[</span><br><span class=\"line\">\t\tcolor=blue,</span><br><span class=\"line\">\t\tmark=square,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\tcoordinates &#123;</span><br><span class=\"line\">\t\t\t(0,23.1)</span><br><span class=\"line\">\t\t\t(10,27.5)</span><br><span class=\"line\">\t\t\t(20,32)</span><br><span class=\"line\">\t\t\t(30,37.8)</span><br><span class=\"line\">\t\t\t(40,44.6)</span><br><span class=\"line\">\t\t\t(60,61.8)</span><br><span class=\"line\">\t\t\t(80,83.8)</span><br><span class=\"line\">\t\t\t(100,114)</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\legend</span>&#123;CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<h4\r\nid=\"数据图像中的常用命令参数与特性test-1-crop-1\">数据图像中的常用命令、参数与特性<img\r\nsrc=\"https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png\"\r\nalt=\"test-1-crop-1\" /></h4>\r\n<ul>\r\n<li>mark：设定图像点的形状；如square、triangle、x等</li>\r\n<li><span\r\nclass=\"math display\">\\[\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}\\]</span>​启用/禁用\r\n𝑦,𝑥 轴上<strong>刻度线位置上</strong>的网格线；</li>\r\n<li><span class=\"math display\">\\[\\tt{xmin=a, xmax=b, ymin=c,\r\nymax=d}\\]</span>​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐\r\n，最大值为 𝑑 ；</li>\r\n<li><span class=\"math display\">\\[\\tt{coordinates\r\n\\{\\}}\\]</span>​设定坐标点画折线图</li>\r\n<li>table {file_with_the_data.dat},使用该命令可直接通过dat数据画图</li>\r\n</ul>\r\n<h3 id=\"其他图像\">其他图像</h3>\r\n<p>pgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。</p>\r\n<h3 id=\"导言区的一些设定\">导言区的一些设定</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\pgfplotsset</span>&#123;width=10cm&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这里指定了每一张图的宽度为10cm</p>\r\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\usepgfplotslibrary</span>&#123;external&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\tikzexternalize</span> </span><br></pre></td></tr></table></figure>\r\n<p>由于<span class=\"math display\">\\[LATEX\\]</span>\r\n诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。</p>\r\n","length":929,"excerpt":"<p>持续更新遇到的问题，完结或不再使用该包将删除这句话</p>\r\n<h2 id=\"pgfplots\">pgfplots</h2>\r\n<p>Pgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots\r\n宏包会帮助用户绘制响应的图像。</p>","more":"<h3\r\nid=\"实例一通过函数方程绘制函数图像\">实例一、通过函数方程绘制函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex1:f(x)=exp(x)</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<p>其中绘制图像的语法如下：</p>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>[option] &#123;expression of 2D function&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D\r\n函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥)\r\n。最后最重要的是该命令必须以分号 <strong>;</strong> 结尾。</p>\r\n<h3\r\nid=\"实例二坐标系的绘制以及3d函数图像\">实例二、坐标系的绘制以及3d函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\documentclass</span>&#123;ctexart&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\pagestyle</span>&#123;empty&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\usepackage</span>&#123;pgfplots&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;document&#125;</span><br><span class=\"line\"><span class=\"comment\">%Ex2: put the 2D plot and the 3D plot together</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"comment\">%Here ends the furst 2D plot</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">\\hskip</span> 10pt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%Here begins the 3d plot</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">\t\tsurf,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">    surf,</span><br><span class=\"line\">]</span><br><span class=\"line\">&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。</p>\r\n<p>可以看到对多个图像只需要设定多个tikzpicture作用域即可</p>\r\n<h4\r\nid=\"坐标系图像中的常用命令参数与特性\">坐标系图像中的常用命令、参数与特性</h4>\r\n<ul>\r\n<li>xlabel、ylabel：设定x,y坐标轴上的标志。</li>\r\n<li>多个addplot可在同一个图中多次作图</li>\r\n<li><span class=\"math display\">\\[\\tt{domian = a:b}\\]</span>设置 𝑥\r\n的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；</li>\r\n<li><span class=\"math display\">\\[\\tt{axis\\,\\, lines =\r\nleft}\\]</span>这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；</li>\r\n<li> 添加函数标签</li>\r\n<li>按顺序批量谭家函数标签</li>\r\n<li>title在axis中为图像添加标题</li>\r\n</ul>\r\n<h3 id=\"实例三数据图\">实例三、数据图</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex6:plot from data</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;[</span><br><span class=\"line\">\t\ttitle=&#123;Temperature dependence of CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O solubility&#125;,</span><br><span class=\"line\">\t\txlabel=&#123;Temperature [<span class=\"keyword\">\\textcelsius</span>]&#125;,</span><br><span class=\"line\">\t\tylabel=&#123;Solubility [g per 100 g water]&#125;,</span><br><span class=\"line\">\t\txmin=0, xmax=100,</span><br><span class=\"line\">\t\tymin=0, ymax=120,</span><br><span class=\"line\">\t\txtick=&#123;0,20,40,60,80,100&#125;,</span><br><span class=\"line\">\t\tytick=&#123;0,20,40,60,80,100,120&#125;,</span><br><span class=\"line\">\t\tlegend pos=north west,</span><br><span class=\"line\">\t\tymajorgrids=true,</span><br><span class=\"line\">\t\tgrid style=dashed,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[</span><br><span class=\"line\">\t\tcolor=blue,</span><br><span class=\"line\">\t\tmark=square,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\tcoordinates &#123;</span><br><span class=\"line\">\t\t\t(0,23.1)</span><br><span class=\"line\">\t\t\t(10,27.5)</span><br><span class=\"line\">\t\t\t(20,32)</span><br><span class=\"line\">\t\t\t(30,37.8)</span><br><span class=\"line\">\t\t\t(40,44.6)</span><br><span class=\"line\">\t\t\t(60,61.8)</span><br><span class=\"line\">\t\t\t(80,83.8)</span><br><span class=\"line\">\t\t\t(100,114)</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\legend</span>&#123;CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<h4\r\nid=\"数据图像中的常用命令参数与特性test-1-crop-1\">数据图像中的常用命令、参数与特性<img\r\nsrc=\"https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png\"\r\nalt=\"test-1-crop-1\" /></h4>\r\n<ul>\r\n<li>mark：设定图像点的形状；如square、triangle、x等</li>\r\n<li><span\r\nclass=\"math display\">\\[\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}\\]</span>​启用/禁用\r\n𝑦,𝑥 轴上<strong>刻度线位置上</strong>的网格线；</li>\r\n<li><span class=\"math display\">\\[\\tt{xmin=a, xmax=b, ymin=c,\r\nymax=d}\\]</span>​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐\r\n，最大值为 𝑑 ；</li>\r\n<li><span class=\"math display\">\\[\\tt{coordinates\r\n\\{\\}}\\]</span>​设定坐标点画折线图</li>\r\n<li>table {file_with_the_data.dat},使用该命令可直接通过dat数据画图</li>\r\n</ul>\r\n<h3 id=\"其他图像\">其他图像</h3>\r\n<p>pgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。</p>\r\n<h3 id=\"导言区的一些设定\">导言区的一些设定</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\pgfplotsset</span>&#123;width=10cm&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这里指定了每一张图的宽度为10cm</p>\r\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\usepgfplotslibrary</span>&#123;external&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\tikzexternalize</span> </span><br></pre></td></tr></table></figure>\r\n<p>由于<span class=\"math display\">\\[LATEX\\]</span>\r\n诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。</p>"},{"title":"Miracl的配置ForCentos7","date":"2024-08-14T11:55:03.000Z","_content":"Miracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).\n\nMiracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的\n\n<!--more-->\n\n```cpp\nextern \"C\"\n{\n     #include \"miracl.h\"\n}\n```\n\n实现兼容。\n\n下面是对miracl在c++环境下部署的简单步骤\n\n第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输\n\n`````shell\nwget https://github.com/miracl/MIRACL/archive/master.zip\n`````\n\n第二步、创建一个文件夹用来存放解压文件\n\n```shell\nmkdir miracl\n```\n\n第三步、复制并解压\n\n```shell\ncp master.zip ./miracl\ncd miracl/\nunzip -j -aa -L master.zip\n```\n\n第四步、验证解压并运行linux64（若32位运行linux）\n\n```shell\nls\nbash linux64\nll | grep miracl.a\n```\n\n第五步、运行官方程序\n\n```shell\n./pk-demo\n```\n\n第六步、一般情况下、复制一下文件到你的源代码目录下\n\n````shell\ncp ../miracl/miracl.a miracl.a\ncp ../miracl/miracl.h miracl.h\ncp ../miracl/mirdef.h mirdef.h\n````\n\n完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：\n\n[静态库文件](https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ)","source":"_posts/Miracl的配置ForCentos7.md","raw":"---\ntitle: Miracl的配置ForCentos7\ndate: 2024-08-14 19:55:03\ntags: [信息安全, 软件, Miracl]\ncategories: \n\t- 软件\n\t- 经典库\n\t- 信息安全\n---\nMiracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).\n\nMiracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的\n\n<!--more-->\n\n```cpp\nextern \"C\"\n{\n     #include \"miracl.h\"\n}\n```\n\n实现兼容。\n\n下面是对miracl在c++环境下部署的简单步骤\n\n第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输\n\n`````shell\nwget https://github.com/miracl/MIRACL/archive/master.zip\n`````\n\n第二步、创建一个文件夹用来存放解压文件\n\n```shell\nmkdir miracl\n```\n\n第三步、复制并解压\n\n```shell\ncp master.zip ./miracl\ncd miracl/\nunzip -j -aa -L master.zip\n```\n\n第四步、验证解压并运行linux64（若32位运行linux）\n\n```shell\nls\nbash linux64\nll | grep miracl.a\n```\n\n第五步、运行官方程序\n\n```shell\n./pk-demo\n```\n\n第六步、一般情况下、复制一下文件到你的源代码目录下\n\n````shell\ncp ../miracl/miracl.a miracl.a\ncp ../miracl/miracl.h miracl.h\ncp ../miracl/mirdef.h mirdef.h\n````\n\n完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：\n\n[静态库文件](https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ)","slug":"Miracl的配置ForCentos7","published":1,"updated":"2024-08-14T13:38:48.720Z","comments":1,"layout":"post","photos":[],"_id":"clzwonja9000ilowv22p652my","content":"<p>Miracl is Multiprecision Integer and Rational Arithmetic\r\nCryptographic Library – the MIRACL Crypto SDK – is a C software library\r\nthat is widely regarded by developers as the gold standard open source\r\nSDK for elliptic curve cryptography (ECC).</p>\r\n<p>Miracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C\r\n软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源\r\nSDK。也可在c++环境下通过对c库的</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;miracl.h&quot;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>实现兼容。</p>\r\n<p>下面是对miracl在c++环境下部署的简单步骤</p>\r\n<p>第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/miracl/MIRACL/archive/master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第二步、创建一个文件夹用来存放解压文件</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir miracl</span><br></pre></td></tr></table></figure>\r\n<p>第三步、复制并解压</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp master.zip ./miracl</span><br><span class=\"line\">cd miracl/</span><br><span class=\"line\">unzip -j -aa -L master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第四步、验证解压并运行linux64（若32位运行linux）</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">bash linux64</span><br><span class=\"line\">ll | grep miracl.a</span><br></pre></td></tr></table></figure>\r\n<p>第五步、运行官方程序</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./pk-demo</span><br></pre></td></tr></table></figure>\r\n<p>第六步、一般情况下、复制一下文件到你的源代码目录下</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ../miracl/miracl.a miracl.a</span><br><span class=\"line\">cp ../miracl/miracl.h miracl.h</span><br><span class=\"line\">cp ../miracl/mirdef.h mirdef.h</span><br></pre></td></tr></table></figure>\r\n<p>完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly8xZHJ2Lm1zL2YvcyFBcC1lblk3Y2tMQU5nb05NSVF5c1hSVlM4TGRHeVE=\">静态库文件<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n","length":411,"excerpt":"<p>Miracl is Multiprecision Integer and Rational Arithmetic\r\nCryptographic Library – the MIRACL Crypto SDK – is a C software library\r\nthat is widely regarded by developers as the gold standard open source\r\nSDK for elliptic curve cryptography (ECC).</p>\r\n<p>Miracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C\r\n软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源\r\nSDK。也可在c++环境下通过对c库的</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;miracl.h&quot;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>实现兼容。</p>\r\n<p>下面是对miracl在c++环境下部署的简单步骤</p>\r\n<p>第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/miracl/MIRACL/archive/master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第二步、创建一个文件夹用来存放解压文件</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir miracl</span><br></pre></td></tr></table></figure>\r\n<p>第三步、复制并解压</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp master.zip ./miracl</span><br><span class=\"line\">cd miracl/</span><br><span class=\"line\">unzip -j -aa -L master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第四步、验证解压并运行linux64（若32位运行linux）</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">bash linux64</span><br><span class=\"line\">ll | grep miracl.a</span><br></pre></td></tr></table></figure>\r\n<p>第五步、运行官方程序</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./pk-demo</span><br></pre></td></tr></table></figure>\r\n<p>第六步、一般情况下、复制一下文件到你的源代码目录下</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ../miracl/miracl.a miracl.a</span><br><span class=\"line\">cp ../miracl/miracl.h miracl.h</span><br><span class=\"line\">cp ../miracl/mirdef.h mirdef.h</span><br></pre></td></tr></table></figure>\r\n<p>完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly8xZHJ2Lm1zL2YvcyFBcC1lblk3Y2tMQU5nb05NSVF5c1hSVlM4TGRHeVE=\">静态库文件<i class=\"fa fa-external-link-alt\"></i></span></p>"},{"title":"Nodejs安装简要建议","date":"2024-08-15T02:28:48.000Z","_content":"## NodeJS\n\n### 什么是Nodejs\n\n[Node.js — Run JavaScript Everywhere](https://nodejs.org/)这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。\n\n具体的讲，如下。。\n\n>  Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n\n<!--more-->\n\n### 下载时一步步涉及到的包管理\n\nnvm——Node Version Manager\n\nfnm——Fast Node Manager\n\nnvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm 就没这个问题。并且 Windows 上的 [nvm](https://github.com/nvm-sh/nvm) 与 macOS 上的 [nvm](https://github.com/coreybutler/nvm-windows) 实际上并不是同一个，Windows 的只是借了 nvm 的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm 在三大系统上都是同一个，这保证了 API 的一致性。\n\n下面以fnm为例\n\n### fnm 下载\n\n```\ncurl -fsSL https://fnm.vercel.app/install | bash\n```\n\n如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：\n\n[fnm.zip](https://objects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-streamobjects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-stream)\n\n### NodeJS18版本以上的gcc&make版本要求\n\n要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make install即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。\n\n以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog\n\n[OSError: /lib64/libm.so.6: version `GLIBC_2.27' not found (required by xxx.so) ——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n在make过程中通常涉及\n\n```\nld-linux-x86-64.so.2\\libc.so.6\n```\n\n两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n最后记得设置环境变量，切勿随意删除系统gcc文件。\n\n>  许多blog在configure中设置--profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）\n\n安装NodeJS详细步骤建议参考官方：[Node.js — Download Node.js® (nodejs.org)](https://nodejs.org/en/download/package-manager)\n\n注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素\n\n### NodeJS验证\n\n```\nnode -v\nnpm -v\n```\n\n两条指令均正常即说明程序成功安装\n","source":"_posts/Nodejs安装简要建议.md","raw":"---\ntitle: Nodejs安装简要建议\ndate: 2024-08-15 10:28:48\ntags: [nodejs, gcc, linux]\ncategories: \n\t- 软件\n\t- 经典库\n\t- 前端\n\t- node\n---\n## NodeJS\n\n### 什么是Nodejs\n\n[Node.js — Run JavaScript Everywhere](https://nodejs.org/)这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。\n\n具体的讲，如下。。\n\n>  Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n\n<!--more-->\n\n### 下载时一步步涉及到的包管理\n\nnvm——Node Version Manager\n\nfnm——Fast Node Manager\n\nnvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm 就没这个问题。并且 Windows 上的 [nvm](https://github.com/nvm-sh/nvm) 与 macOS 上的 [nvm](https://github.com/coreybutler/nvm-windows) 实际上并不是同一个，Windows 的只是借了 nvm 的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm 在三大系统上都是同一个，这保证了 API 的一致性。\n\n下面以fnm为例\n\n### fnm 下载\n\n```\ncurl -fsSL https://fnm.vercel.app/install | bash\n```\n\n如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：\n\n[fnm.zip](https://objects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-streamobjects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-stream)\n\n### NodeJS18版本以上的gcc&make版本要求\n\n要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make install即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。\n\n以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog\n\n[OSError: /lib64/libm.so.6: version `GLIBC_2.27' not found (required by xxx.so) ——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n在make过程中通常涉及\n\n```\nld-linux-x86-64.so.2\\libc.so.6\n```\n\n两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n最后记得设置环境变量，切勿随意删除系统gcc文件。\n\n>  许多blog在configure中设置--profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）\n\n安装NodeJS详细步骤建议参考官方：[Node.js — Download Node.js® (nodejs.org)](https://nodejs.org/en/download/package-manager)\n\n注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素\n\n### NodeJS验证\n\n```\nnode -v\nnpm -v\n```\n\n两条指令均正常即说明程序成功安装\n","slug":"Nodejs安装简要建议","published":1,"updated":"2024-08-15T02:41:25.517Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjaa000llowv8nisgbt6","content":"<h2 id=\"nodejs\">NodeJS</h2>\r\n<h3 id=\"什么是nodejs\">什么是Nodejs</h3>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnLw==\">Node.js — Run JavaScript\r\nEverywhere<i class=\"fa fa-external-link-alt\"></i></span>这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。</p>\r\n<p>具体的讲，如下。。</p>\r\n<blockquote>\r\n<p>Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome\r\nJavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端\r\nJavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript\r\n的速度非常快，性能非常好。</p>\r\n</blockquote>\r\n<span id=\"more\"></span>\r\n<h3 id=\"下载时一步步涉及到的包管理\">下载时一步步涉及到的包管理</h3>\r\n<p>nvm——Node Version Manager</p>\r\n<p>fnm——Fast Node Manager</p>\r\n<p>nvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm\r\n就没这个问题。并且 Windows 上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=\">nvm<i class=\"fa fa-external-link-alt\"></i></span> 与 macOS 上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NvcmV5YnV0bGVyL252bS13aW5kb3dz\">nvm<i class=\"fa fa-external-link-alt\"></i></span>\r\n实际上并不是同一个，Windows 的只是借了 nvm\r\n的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm\r\n在三大系统上都是同一个，这保证了 API 的一致性。</p>\r\n<p>下面以fnm为例</p>\r\n<h3 id=\"fnm-下载\">fnm 下载</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://fnm.vercel.app/install | bash</span><br></pre></td></tr></table></figure>\r\n<p>如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vYmplY3RzLmdpdGh1YnVzZXJjb250ZW50LmNvbS9naXRodWItcHJvZHVjdGlvbi1yZWxlYXNlLWFzc2V0LTJlNjViZS8xNjYwNDU0MjQvNGMwYTllMmEtOWIyMi00ZWJlLWIwMjYtZGU1ZTc4ZGU5MzUxP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9cmVsZWFzZWFzc2V0cHJvZHVjdGlvbiUyRjIwMjQwNTI5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDUyOVQwODMzMjRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1kNWUxMzc2M2I5NzUwNzI3YmQ0NWIwMTRkMTJhYTdlM2E4OTNmZmUyNzU4MTg5NzEwZDhjMTFkODc0ZWI5ZTY2JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD05MTI3MzE2MSZrZXlfaWQ9MCZyZXBvX2lkPTE2NjA0NTQyNCZyZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0IlMjBmaWxlbmFtZSUzRGZubS1saW51eC56aXAmcmVzcG9uc2UtY29udGVudC10eXBlPWFwcGxpY2F0aW9uJTJGb2N0ZXQtc3RyZWFtb2JqZWN0cy5naXRodWJ1c2VyY29udGVudC5jb20vZ2l0aHViLXByb2R1Y3Rpb24tcmVsZWFzZS1hc3NldC0yZTY1YmUvMTY2MDQ1NDI0LzRjMGE5ZTJhLTliMjItNGViZS1iMDI2LWRlNWU3OGRlOTM1MT9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPXJlbGVhc2Vhc3NldHByb2R1Y3Rpb24lMkYyMDI0MDUyOSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA1MjlUMDgzMzI0WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZDVlMTM3NjNiOTc1MDcyN2JkNDViMDE0ZDEyYWE3ZTNhODkzZmZlMjc1ODE4OTcxMGQ4YzExZDg3NGViOWU2NiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9OTEyNzMxNjEma2V5X2lkPTAmcmVwb19pZD0xNjYwNDU0MjQmcmVzcG9uc2UtY29udGVudC1kaXNwb3NpdGlvbj1hdHRhY2htZW50JTNCJTIwZmlsZW5hbWUlM0Rmbm0tbGludXguemlwJnJlc3BvbnNlLWNvbnRlbnQtdHlwZT1hcHBsaWNhdGlvbiUyRm9jdGV0LXN0cmVhbQ==\">fnm.zip<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3\r\nid=\"nodejs18版本以上的gccmake版本要求\">NodeJS18版本以上的gcc&amp;make版本要求</h3>\r\n<p>要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make\r\ninstall即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。</p>\r\n<p>以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTk3OTE0NTA/c3BtPWEyYzZoLjEyODczNjM5LmFydGljbGUtZGV0YWlsLjcuNzEzNzY1ZmFadXZTd2g=\">OSError:\r\n/lib64/libm.so.6: version `GLIBC_2.27' not found (required by xxx.so)\r\n——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>在make过程中通常涉及</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld-linux-x86-64.so.2\\libc.so.6</span><br></pre></td></tr></table></figure>\r\n<p>两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)</p>\r\n<p>最后记得设置环境变量，切勿随意删除系统gcc文件。</p>\r\n<blockquote>\r\n<p>许多blog在configure中设置--profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）</p>\r\n</blockquote>\r\n<p>安装NodeJS详细步骤建议参考官方：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL3BhY2thZ2UtbWFuYWdlcg==\">Node.js — Download\r\nNode.js® (nodejs.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素</p>\r\n<h3 id=\"nodejs验证\">NodeJS验证</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\r\n<p>两条指令均正常即说明程序成功安装</p>\r\n","length":731,"excerpt":"<h2 id=\"nodejs\">NodeJS</h2>\r\n<h3 id=\"什么是nodejs\">什么是Nodejs</h3>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnLw==\">Node.js — Run JavaScript\r\nEverywhere<i class=\"fa fa-external-link-alt\"></i></span>这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。</p>\r\n<p>具体的讲，如下。。</p>\r\n<blockquote>\r\n<p>Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome\r\nJavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端\r\nJavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript\r\n的速度非常快，性能非常好。</p>\r\n</blockquote>","more":"<h3 id=\"下载时一步步涉及到的包管理\">下载时一步步涉及到的包管理</h3>\r\n<p>nvm——Node Version Manager</p>\r\n<p>fnm——Fast Node Manager</p>\r\n<p>nvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm\r\n就没这个问题。并且 Windows 上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=\">nvm<i class=\"fa fa-external-link-alt\"></i></span> 与 macOS 上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NvcmV5YnV0bGVyL252bS13aW5kb3dz\">nvm<i class=\"fa fa-external-link-alt\"></i></span>\r\n实际上并不是同一个，Windows 的只是借了 nvm\r\n的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm\r\n在三大系统上都是同一个，这保证了 API 的一致性。</p>\r\n<p>下面以fnm为例</p>\r\n<h3 id=\"fnm-下载\">fnm 下载</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://fnm.vercel.app/install | bash</span><br></pre></td></tr></table></figure>\r\n<p>如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vYmplY3RzLmdpdGh1YnVzZXJjb250ZW50LmNvbS9naXRodWItcHJvZHVjdGlvbi1yZWxlYXNlLWFzc2V0LTJlNjViZS8xNjYwNDU0MjQvNGMwYTllMmEtOWIyMi00ZWJlLWIwMjYtZGU1ZTc4ZGU5MzUxP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9cmVsZWFzZWFzc2V0cHJvZHVjdGlvbiUyRjIwMjQwNTI5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDUyOVQwODMzMjRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1kNWUxMzc2M2I5NzUwNzI3YmQ0NWIwMTRkMTJhYTdlM2E4OTNmZmUyNzU4MTg5NzEwZDhjMTFkODc0ZWI5ZTY2JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD05MTI3MzE2MSZrZXlfaWQ9MCZyZXBvX2lkPTE2NjA0NTQyNCZyZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0IlMjBmaWxlbmFtZSUzRGZubS1saW51eC56aXAmcmVzcG9uc2UtY29udGVudC10eXBlPWFwcGxpY2F0aW9uJTJGb2N0ZXQtc3RyZWFtb2JqZWN0cy5naXRodWJ1c2VyY29udGVudC5jb20vZ2l0aHViLXByb2R1Y3Rpb24tcmVsZWFzZS1hc3NldC0yZTY1YmUvMTY2MDQ1NDI0LzRjMGE5ZTJhLTliMjItNGViZS1iMDI2LWRlNWU3OGRlOTM1MT9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPXJlbGVhc2Vhc3NldHByb2R1Y3Rpb24lMkYyMDI0MDUyOSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA1MjlUMDgzMzI0WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZDVlMTM3NjNiOTc1MDcyN2JkNDViMDE0ZDEyYWE3ZTNhODkzZmZlMjc1ODE4OTcxMGQ4YzExZDg3NGViOWU2NiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9OTEyNzMxNjEma2V5X2lkPTAmcmVwb19pZD0xNjYwNDU0MjQmcmVzcG9uc2UtY29udGVudC1kaXNwb3NpdGlvbj1hdHRhY2htZW50JTNCJTIwZmlsZW5hbWUlM0Rmbm0tbGludXguemlwJnJlc3BvbnNlLWNvbnRlbnQtdHlwZT1hcHBsaWNhdGlvbiUyRm9jdGV0LXN0cmVhbQ==\">fnm.zip<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3\r\nid=\"nodejs18版本以上的gccmake版本要求\">NodeJS18版本以上的gcc&amp;make版本要求</h3>\r\n<p>要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make\r\ninstall即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。</p>\r\n<p>以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTk3OTE0NTA/c3BtPWEyYzZoLjEyODczNjM5LmFydGljbGUtZGV0YWlsLjcuNzEzNzY1ZmFadXZTd2g=\">OSError:\r\n/lib64/libm.so.6: version `GLIBC_2.27' not found (required by xxx.so)\r\n——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>在make过程中通常涉及</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld-linux-x86-64.so.2\\libc.so.6</span><br></pre></td></tr></table></figure>\r\n<p>两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)</p>\r\n<p>最后记得设置环境变量，切勿随意删除系统gcc文件。</p>\r\n<blockquote>\r\n<p>许多blog在configure中设置--profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）</p>\r\n</blockquote>\r\n<p>安装NodeJS详细步骤建议参考官方：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL3BhY2thZ2UtbWFuYWdlcg==\">Node.js — Download\r\nNode.js® (nodejs.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素</p>\r\n<h3 id=\"nodejs验证\">NodeJS验证</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\r\n<p>两条指令均正常即说明程序成功安装</p>"},{"title":"RSA涉及算法与数论知识","date":"2024-08-14T11:51:58.000Z","_content":"**RSA** (**Rivest–Shamir–Adleman**) is a [public-key cryptosystem](https://en.wikipedia.org/wiki/Public-key_cryptography), one of the oldest widely used for secure data transmission.\n\nRSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。\n\n<!--more-->\n\n## 基础数论知识纲要\n\n传送门：[MH3210 - NTU - Number Theory - Studocu](https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934)\n\n知乎blog：[基础数论学习笔记（1）- Divisibility 整除 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/635332658)\n\n讲义：[NanYang Technological University MH1300ANDMH3210](https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg) \n\n## 概念定义\n\n**费马小定理**：选一个**素数p**，再选一个和p不成倍数关系的整数β，必然满足**β的p次幂**和**β**对p同余。公式如下。\n$$\n\\beta^p \\equiv \\beta (modp)\n$$\n**二次剩余**： 取定 $$𝑎\\perp 𝑝$$, 假若存在着 $x$使得\n$$\nx^2 \\equiv a (modp)\n$$\n\n则称$$a$$是$$modp$$的特殊剩余，否则则是$$modp$$的二次非剩余\n\n**欧拉准则**：元素β是**模奇素数p**的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\n$$\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\n$$\n\n> 欧拉准则证明：\n> 设$$r^2 = \\beta$$则有 $$r^{p-1} \\equiv 1 (modp)$$,利用费马小定理即可得证。\n\n**勒让德符号**：$$(\\frac{a}{p})$$ 若$$a$$ 是$$modp$$的平方剩余 则 $$(\\frac{a}{p}) = 1$$ ，若不是，则$$(\\frac{a}{p})= -1$$ 若$$a$$和$$p$$是整除关系则$$(\\frac{a}{p})=0$$ ,如下列公式\n$$\n(\\frac{a}{p}) = \n\\begin{cases}\n1,\\quad x^2 \\equiv a(modp)\\\\\n0, \\quad a \\equiv 0 (modp) \\\\\n-1, \\quad x^2 \\not\\equiv a(modp)\n\\end{cases}\n\\tag{1}\n$$\nSolovay-Strassen算法：若n是一个素数，那么勒让德符号$$(\\frac{β}{n})\\equiv β^{(n-1)/2}mod n$$。\n\n> Strassen算法证明：根据欧拉准则**β的(n-1)/2次方和1对n不同余**，根据费马小定理，**β的n-1次方**和1对n同余，根据平方差公式，$$β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)$$ 。由于$（β^{(n-1)/2}-1）$ 无法被n整除，所以$$（β^{(n-1)/2}+1）$$ 必然能被n整除，进而得到$$β^{(n-1)/2}\\equiv-1  (mod n)$$。\n\n**该命题的逆命题是不成立的**\n\n**二次互反律**：$$\\mathbb Z_p^\\times\\to\\mathbb Z_2$$​ \n\n**Miller-Rabin算法**：\n\n输入待测试大数$$n$$，对$$n-1$$不断地进行除$$2$$操作，直到得到一个**奇数t**。\n\n于是这可以写成 $$n-1 = 2^s \\cdot t$$ 。显然的，待测试大数$n$肯定是个奇数（废话，是偶数还测个锤子了），那么$$n-1$$肯定是个偶数，故$$s\\not=0$$。\n\n选择**随机种子$$a$$**，$$a＜n$$且与$$n$$互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）\n\n先设$$m=t$$。计算 $$b \\equiv a^t(modn)$$ ：\n\n- 情况①：当 $$m=2^s \\cdot t = n -1$$时，停机，输出“n是一个合数”。\n\n- 情况②：当 $$b \\equiv -1 (modn)$$ 时，停机，换一个随机种子a再次进行测试。\n\n- 情况③：当$$b \\equiv -1(modn)$$不成立时，重新设$b$为$$b²(mod n)$$，$$m$$为$$2m$$​；继续循环，直到得到情况①或情况②为止。\n\n## 计算方法\n\n**快速幂**：通过二进制的快速幂优化\n\n**计算勒让德符号$$(\\frac{\\beta}{n})$$​** ：二次互反\n\n**大整数除法中对小除数的优化**：移位计算小除数的商\n\n**大整数除法中对大除数的优化**：二分查找对每次计算试商的优化","source":"_posts/RSA涉及算法与数论知识.md","raw":"---\ntitle: RSA涉及算法与数论知识\ndate: 2024-08-14 19:51:58\ntags: [信息安全, 数学]\ncategories:\n\t- 信息安全\n\t- 加密算法\n\t- 数学\n---\n**RSA** (**Rivest–Shamir–Adleman**) is a [public-key cryptosystem](https://en.wikipedia.org/wiki/Public-key_cryptography), one of the oldest widely used for secure data transmission.\n\nRSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。\n\n<!--more-->\n\n## 基础数论知识纲要\n\n传送门：[MH3210 - NTU - Number Theory - Studocu](https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934)\n\n知乎blog：[基础数论学习笔记（1）- Divisibility 整除 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/635332658)\n\n讲义：[NanYang Technological University MH1300ANDMH3210](https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg) \n\n## 概念定义\n\n**费马小定理**：选一个**素数p**，再选一个和p不成倍数关系的整数β，必然满足**β的p次幂**和**β**对p同余。公式如下。\n$$\n\\beta^p \\equiv \\beta (modp)\n$$\n**二次剩余**： 取定 $$𝑎\\perp 𝑝$$, 假若存在着 $x$使得\n$$\nx^2 \\equiv a (modp)\n$$\n\n则称$$a$$是$$modp$$的特殊剩余，否则则是$$modp$$的二次非剩余\n\n**欧拉准则**：元素β是**模奇素数p**的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\n$$\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\n$$\n\n> 欧拉准则证明：\n> 设$$r^2 = \\beta$$则有 $$r^{p-1} \\equiv 1 (modp)$$,利用费马小定理即可得证。\n\n**勒让德符号**：$$(\\frac{a}{p})$$ 若$$a$$ 是$$modp$$的平方剩余 则 $$(\\frac{a}{p}) = 1$$ ，若不是，则$$(\\frac{a}{p})= -1$$ 若$$a$$和$$p$$是整除关系则$$(\\frac{a}{p})=0$$ ,如下列公式\n$$\n(\\frac{a}{p}) = \n\\begin{cases}\n1,\\quad x^2 \\equiv a(modp)\\\\\n0, \\quad a \\equiv 0 (modp) \\\\\n-1, \\quad x^2 \\not\\equiv a(modp)\n\\end{cases}\n\\tag{1}\n$$\nSolovay-Strassen算法：若n是一个素数，那么勒让德符号$$(\\frac{β}{n})\\equiv β^{(n-1)/2}mod n$$。\n\n> Strassen算法证明：根据欧拉准则**β的(n-1)/2次方和1对n不同余**，根据费马小定理，**β的n-1次方**和1对n同余，根据平方差公式，$$β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)$$ 。由于$（β^{(n-1)/2}-1）$ 无法被n整除，所以$$（β^{(n-1)/2}+1）$$ 必然能被n整除，进而得到$$β^{(n-1)/2}\\equiv-1  (mod n)$$。\n\n**该命题的逆命题是不成立的**\n\n**二次互反律**：$$\\mathbb Z_p^\\times\\to\\mathbb Z_2$$​ \n\n**Miller-Rabin算法**：\n\n输入待测试大数$$n$$，对$$n-1$$不断地进行除$$2$$操作，直到得到一个**奇数t**。\n\n于是这可以写成 $$n-1 = 2^s \\cdot t$$ 。显然的，待测试大数$n$肯定是个奇数（废话，是偶数还测个锤子了），那么$$n-1$$肯定是个偶数，故$$s\\not=0$$。\n\n选择**随机种子$$a$$**，$$a＜n$$且与$$n$$互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）\n\n先设$$m=t$$。计算 $$b \\equiv a^t(modn)$$ ：\n\n- 情况①：当 $$m=2^s \\cdot t = n -1$$时，停机，输出“n是一个合数”。\n\n- 情况②：当 $$b \\equiv -1 (modn)$$ 时，停机，换一个随机种子a再次进行测试。\n\n- 情况③：当$$b \\equiv -1(modn)$$不成立时，重新设$b$为$$b²(mod n)$$，$$m$$为$$2m$$​；继续循环，直到得到情况①或情况②为止。\n\n## 计算方法\n\n**快速幂**：通过二进制的快速幂优化\n\n**计算勒让德符号$$(\\frac{\\beta}{n})$$​** ：二次互反\n\n**大整数除法中对小除数的优化**：移位计算小除数的商\n\n**大整数除法中对大除数的优化**：二分查找对每次计算试商的优化","slug":"RSA涉及算法与数论知识","published":1,"updated":"2024-08-14T13:38:56.431Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjaa000nlowvad5agj9c","content":"<p><strong>RSA</strong> (<strong>Rivest–Shamir–Adleman</strong>) is a <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHVibGljLWtleV9jcnlwdG9ncmFwaHk=\">public-key\r\ncryptosystem<i class=\"fa fa-external-link-alt\"></i></span>, one of the oldest widely used for secure data\r\ntransmission.</p>\r\n<p>RSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"基础数论知识纲要\">基础数论知识纲要</h2>\r\n<p>传送门：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3R1ZG9jdS5jb20vc2cvY291cnNlL25hbnlhbmctdGVjaG5vbG9naWNhbC11bml2ZXJzaXR5L251bWJlci10aGVvcnkvMzAzMTkzNA==\">MH3210\r\n- NTU - Number Theory - Studocu<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>知乎blog：<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MzUzMzI2NTg=\">基础数论学习笔记（1）-\r\nDivisibility 整除 - 知乎 (zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>讲义：<span class=\"exturl\" data-url=\"aHR0cHM6Ly8xZHJ2Lm1zL2YvcyFBcC1lblk3Y2tMQU5nb05Ib3R6cTNTUlRhZnA0cGc=\">NanYang\r\nTechnological University MH1300ANDMH3210<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h2 id=\"概念定义\">概念定义</h2>\r\n<p><strong>费马小定理</strong>：选一个<strong>素数p</strong>，再选一个和p不成倍数关系的整数β，必然满足<strong>β的p次幂</strong>和<strong>β</strong>对p同余。公式如下。\r\n<span class=\"math display\">\\[\r\n\\beta^p \\equiv \\beta (modp)\r\n\\]</span> <strong>二次剩余</strong>： 取定 <span\r\nclass=\"math display\">\\[𝑎\\perp 𝑝\\]</span>, 假若存在着 <span\r\nclass=\"math inline\">\\(x\\)</span>使得 <span class=\"math display\">\\[\r\nx^2 \\equiv a (modp)\r\n\\]</span></p>\r\n<p>则称<span class=\"math display\">\\[a\\]</span>是<span\r\nclass=\"math display\">\\[modp\\]</span>的特殊剩余，否则则是<span\r\nclass=\"math display\">\\[modp\\]</span>的二次非剩余</p>\r\n<p><strong>欧拉准则</strong>：元素β是<strong>模奇素数p</strong>的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\r\n<span class=\"math display\">\\[\r\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\r\n\\]</span></p>\r\n<blockquote>\r\n<p>欧拉准则证明： 设<span class=\"math display\">\\[r^2 =\r\n\\beta\\]</span>则有 <span class=\"math display\">\\[r^{p-1} \\equiv 1\r\n(modp)\\]</span>,利用费马小定理即可得证。</p>\r\n</blockquote>\r\n<p><strong>勒让德符号</strong>：<span\r\nclass=\"math display\">\\[(\\frac{a}{p})\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span> 是<span\r\nclass=\"math display\">\\[modp\\]</span>的平方剩余 则 <span\r\nclass=\"math display\">\\[(\\frac{a}{p}) = 1\\]</span> ，若不是，则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})= -1\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span>和<span\r\nclass=\"math display\">\\[p\\]</span>是整除关系则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})=0\\]</span> ,如下列公式 <span\r\nclass=\"math display\">\\[\r\n(\\frac{a}{p}) =\r\n\\begin{cases}\r\n1,\\quad x^2 \\equiv a(modp)\\\\\r\n0, \\quad a \\equiv 0 (modp) \\\\\r\n-1, \\quad x^2 \\not\\equiv a(modp)\r\n\\end{cases}\r\n\\tag{1}\r\n\\]</span> Solovay-Strassen算法：若n是一个素数，那么勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{β}{n})\\equiv β^{(n-1)/2}mod\r\nn\\]</span>。</p>\r\n<blockquote>\r\n<p>Strassen算法证明：根据欧拉准则<strong>β的(n-1)/2次方和1对n不同余</strong>，根据费马小定理，<strong>β的n-1次方</strong>和1对n同余，根据平方差公式，<span\r\nclass=\"math display\">\\[β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)\\]</span>\r\n。由于<span class=\"math inline\">\\(（β^{(n-1)/2}-1）\\)</span>\r\n无法被n整除，所以<span class=\"math display\">\\[（β^{(n-1)/2}+1）\\]</span>\r\n必然能被n整除，进而得到<span\r\nclass=\"math display\">\\[β^{(n-1)/2}\\equiv-1  (mod n)\\]</span>。</p>\r\n</blockquote>\r\n<p><strong>该命题的逆命题是不成立的</strong></p>\r\n<p><strong>二次互反律</strong>：<span class=\"math display\">\\[\\mathbb\r\nZ_p^\\times\\to\\mathbb Z_2\\]</span>​</p>\r\n<p><strong>Miller-Rabin算法</strong>：</p>\r\n<p>输入待测试大数<span class=\"math display\">\\[n\\]</span>，对<span\r\nclass=\"math display\">\\[n-1\\]</span>不断地进行除<span\r\nclass=\"math display\">\\[2\\]</span>操作，直到得到一个<strong>奇数t</strong>。</p>\r\n<p>于是这可以写成 <span class=\"math display\">\\[n-1 = 2^s \\cdot\r\nt\\]</span> 。显然的，待测试大数<span\r\nclass=\"math inline\">\\(n\\)</span>肯定是个奇数（废话，是偶数还测个锤子了），那么<span\r\nclass=\"math display\">\\[n-1\\]</span>肯定是个偶数，故<span\r\nclass=\"math display\">\\[s\\not=0\\]</span>。</p>\r\n<p>选择<strong>随机种子<span\r\nclass=\"math display\">\\[a\\]</span></strong>，<span\r\nclass=\"math display\">\\[a＜n\\]</span>且与<span\r\nclass=\"math display\">\\[n\\]</span>互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）</p>\r\n<p>先设<span class=\"math display\">\\[m=t\\]</span>。计算 <span\r\nclass=\"math display\">\\[b \\equiv a^t(modn)\\]</span> ：</p>\r\n<ul>\r\n<li><p>情况①：当 <span class=\"math display\">\\[m=2^s \\cdot t = n\r\n-1\\]</span>时，停机，输出“n是一个合数”。</p></li>\r\n<li><p>情况②：当 <span class=\"math display\">\\[b \\equiv -1\r\n(modn)\\]</span> 时，停机，换一个随机种子a再次进行测试。</p></li>\r\n<li><p>情况③：当<span class=\"math display\">\\[b \\equiv\r\n-1(modn)\\]</span>不成立时，重新设<span\r\nclass=\"math inline\">\\(b\\)</span>为<span class=\"math display\">\\[b²(mod\r\nn)\\]</span>，<span class=\"math display\">\\[m\\]</span>为<span\r\nclass=\"math display\">\\[2m\\]</span>​；继续循环，直到得到情况①或情况②为止。</p></li>\r\n</ul>\r\n<h2 id=\"计算方法\">计算方法</h2>\r\n<p><strong>快速幂</strong>：通过二进制的快速幂优化</p>\r\n<p><strong>计算勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{\\beta}{n})\\]</span>​</strong>\r\n：二次互反</p>\r\n<p><strong>大整数除法中对小除数的优化</strong>：移位计算小除数的商</p>\r\n<p><strong>大整数除法中对大除数的优化</strong>：二分查找对每次计算试商的优化</p>\r\n","length":831,"excerpt":"<p><strong>RSA</strong> (<strong>Rivest–Shamir–Adleman</strong>) is a <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHVibGljLWtleV9jcnlwdG9ncmFwaHk=\">public-key\r\ncryptosystem<i class=\"fa fa-external-link-alt\"></i></span>, one of the oldest widely used for secure data\r\ntransmission.</p>\r\n<p>RSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。</p>","more":"<h2 id=\"基础数论知识纲要\">基础数论知识纲要</h2>\r\n<p>传送门：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3R1ZG9jdS5jb20vc2cvY291cnNlL25hbnlhbmctdGVjaG5vbG9naWNhbC11bml2ZXJzaXR5L251bWJlci10aGVvcnkvMzAzMTkzNA==\">MH3210\r\n- NTU - Number Theory - Studocu<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>知乎blog：<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MzUzMzI2NTg=\">基础数论学习笔记（1）-\r\nDivisibility 整除 - 知乎 (zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>讲义：<span class=\"exturl\" data-url=\"aHR0cHM6Ly8xZHJ2Lm1zL2YvcyFBcC1lblk3Y2tMQU5nb05Ib3R6cTNTUlRhZnA0cGc=\">NanYang\r\nTechnological University MH1300ANDMH3210<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h2 id=\"概念定义\">概念定义</h2>\r\n<p><strong>费马小定理</strong>：选一个<strong>素数p</strong>，再选一个和p不成倍数关系的整数β，必然满足<strong>β的p次幂</strong>和<strong>β</strong>对p同余。公式如下。\r\n<span class=\"math display\">\\[\r\n\\beta^p \\equiv \\beta (modp)\r\n\\]</span> <strong>二次剩余</strong>： 取定 <span\r\nclass=\"math display\">\\[𝑎\\perp 𝑝\\]</span>, 假若存在着 <span\r\nclass=\"math inline\">\\(x\\)</span>使得 <span class=\"math display\">\\[\r\nx^2 \\equiv a (modp)\r\n\\]</span></p>\r\n<p>则称<span class=\"math display\">\\[a\\]</span>是<span\r\nclass=\"math display\">\\[modp\\]</span>的特殊剩余，否则则是<span\r\nclass=\"math display\">\\[modp\\]</span>的二次非剩余</p>\r\n<p><strong>欧拉准则</strong>：元素β是<strong>模奇素数p</strong>的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\r\n<span class=\"math display\">\\[\r\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\r\n\\]</span></p>\r\n<blockquote>\r\n<p>欧拉准则证明： 设<span class=\"math display\">\\[r^2 =\r\n\\beta\\]</span>则有 <span class=\"math display\">\\[r^{p-1} \\equiv 1\r\n(modp)\\]</span>,利用费马小定理即可得证。</p>\r\n</blockquote>\r\n<p><strong>勒让德符号</strong>：<span\r\nclass=\"math display\">\\[(\\frac{a}{p})\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span> 是<span\r\nclass=\"math display\">\\[modp\\]</span>的平方剩余 则 <span\r\nclass=\"math display\">\\[(\\frac{a}{p}) = 1\\]</span> ，若不是，则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})= -1\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span>和<span\r\nclass=\"math display\">\\[p\\]</span>是整除关系则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})=0\\]</span> ,如下列公式 <span\r\nclass=\"math display\">\\[\r\n(\\frac{a}{p}) =\r\n\\begin{cases}\r\n1,\\quad x^2 \\equiv a(modp)\\\\\r\n0, \\quad a \\equiv 0 (modp) \\\\\r\n-1, \\quad x^2 \\not\\equiv a(modp)\r\n\\end{cases}\r\n\\tag{1}\r\n\\]</span> Solovay-Strassen算法：若n是一个素数，那么勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{β}{n})\\equiv β^{(n-1)/2}mod\r\nn\\]</span>。</p>\r\n<blockquote>\r\n<p>Strassen算法证明：根据欧拉准则<strong>β的(n-1)/2次方和1对n不同余</strong>，根据费马小定理，<strong>β的n-1次方</strong>和1对n同余，根据平方差公式，<span\r\nclass=\"math display\">\\[β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)\\]</span>\r\n。由于<span class=\"math inline\">\\(（β^{(n-1)/2}-1）\\)</span>\r\n无法被n整除，所以<span class=\"math display\">\\[（β^{(n-1)/2}+1）\\]</span>\r\n必然能被n整除，进而得到<span\r\nclass=\"math display\">\\[β^{(n-1)/2}\\equiv-1  (mod n)\\]</span>。</p>\r\n</blockquote>\r\n<p><strong>该命题的逆命题是不成立的</strong></p>\r\n<p><strong>二次互反律</strong>：<span class=\"math display\">\\[\\mathbb\r\nZ_p^\\times\\to\\mathbb Z_2\\]</span>​</p>\r\n<p><strong>Miller-Rabin算法</strong>：</p>\r\n<p>输入待测试大数<span class=\"math display\">\\[n\\]</span>，对<span\r\nclass=\"math display\">\\[n-1\\]</span>不断地进行除<span\r\nclass=\"math display\">\\[2\\]</span>操作，直到得到一个<strong>奇数t</strong>。</p>\r\n<p>于是这可以写成 <span class=\"math display\">\\[n-1 = 2^s \\cdot\r\nt\\]</span> 。显然的，待测试大数<span\r\nclass=\"math inline\">\\(n\\)</span>肯定是个奇数（废话，是偶数还测个锤子了），那么<span\r\nclass=\"math display\">\\[n-1\\]</span>肯定是个偶数，故<span\r\nclass=\"math display\">\\[s\\not=0\\]</span>。</p>\r\n<p>选择<strong>随机种子<span\r\nclass=\"math display\">\\[a\\]</span></strong>，<span\r\nclass=\"math display\">\\[a＜n\\]</span>且与<span\r\nclass=\"math display\">\\[n\\]</span>互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）</p>\r\n<p>先设<span class=\"math display\">\\[m=t\\]</span>。计算 <span\r\nclass=\"math display\">\\[b \\equiv a^t(modn)\\]</span> ：</p>\r\n<ul>\r\n<li><p>情况①：当 <span class=\"math display\">\\[m=2^s \\cdot t = n\r\n-1\\]</span>时，停机，输出“n是一个合数”。</p></li>\r\n<li><p>情况②：当 <span class=\"math display\">\\[b \\equiv -1\r\n(modn)\\]</span> 时，停机，换一个随机种子a再次进行测试。</p></li>\r\n<li><p>情况③：当<span class=\"math display\">\\[b \\equiv\r\n-1(modn)\\]</span>不成立时，重新设<span\r\nclass=\"math inline\">\\(b\\)</span>为<span class=\"math display\">\\[b²(mod\r\nn)\\]</span>，<span class=\"math display\">\\[m\\]</span>为<span\r\nclass=\"math display\">\\[2m\\]</span>​；继续循环，直到得到情况①或情况②为止。</p></li>\r\n</ul>\r\n<h2 id=\"计算方法\">计算方法</h2>\r\n<p><strong>快速幂</strong>：通过二进制的快速幂优化</p>\r\n<p><strong>计算勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{\\beta}{n})\\]</span>​</strong>\r\n：二次互反</p>\r\n<p><strong>大整数除法中对小除数的优化</strong>：移位计算小除数的商</p>\r\n<p><strong>大整数除法中对大除数的优化</strong>：二分查找对每次计算试商的优化</p>"},{"title":"Xiaobai93D-E","date":"2024-08-14T11:46:31.000Z","_content":"\n## [D-幻兽帕鲁_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/D)\n\n<!--more-->\n\n### 题意\n\n在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。  \n\n你有 $$2^n$$ 只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 $$[0,2^n-1]$$ 工号的顺序排成一队。  \n\n当我们对区间 $$[l,r]$$ 的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 $$[0,r-l]$$ ，记 $$mid = \\lfloor\\frac{l + r}{2}\\rfloor$$，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间 $$[l,mid]$$ 和 $$[mid + 1,r]$$ ，并递归对这两个区间进行上述操作，直到区间长度为 $1$ 。  \n\n现在我们对 $$[0,2^n-1]$$ 的幻兽进行一次操作，然后给你 $m$ 次询问，每次询问 $x$​ 位置的帕鲁工号是多少？\n\n### 题解\n\n简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。\n\n于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1<<(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。\n\n````cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tll x;\n\t\tcin>>x;\n\t\tll ans = 0;\n\t\twhile(x){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(x < (1ll<<(n-i-1))) continue;\n\t\t\t\tx-= (1ll<<(n-i-1));\n\t\t\t\tans += (1ll<<i);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n````\n\n\n\n## [E-奏绝_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/E)\n\n### **题意：**\n\n你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。  \n\n对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为 0。  \n\n区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。  \n\n对于 m 次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对  998244353 取模。\n\n[E-奏绝_牛客小白月赛93（重现赛）](https://ac.nowcoder.com/acm/contest/82821/E)\n\n### **题解**\n\n**不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积**\n\n奏绝，我直接肘击！\n\n题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。\n\n```cpp\nstruct Node\n{\n\tint x, y, id;\n};\n\nbool cmp(const Node& x,const Node& y){\n\tif(x.x/ blk != y.x /blk) return x.x/blk < y.x/blk;\n\telse {\n\t\tif(x.x != y.x) return x.x < y.x;\n\t\telse {\n\t\t\treturn x.y < y.y;\n\t\t}\n\t}\n}\n\nvoid move(int x,int c)\n{\n\tsum1 += (s[x] == '1'? x: 0) * c;\n\tcnt1 += (s[x] == '1') * c;\n\tsum2 += (s[x] == '0'? x: 0) * c;\n\tcnt2 += (s[x] == '0') * c;\n}\n\nvoid updateL(int x,int c){\n\tif(s[x]=='1'){\n\t\tans += (sum2 - x * cnt2) * c% MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x]=='0'){\n\t\tans += (sum1 - x * cnt1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"!\"<<x<<' '<<ans<<endl;\n}\nvoid updateR(int x,int c){\n\tif(s[x] == '0'){\n\t\tans += (x * cnt1 - sum1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x] == '1'){\n\t\tans += (x * cnt2 - sum2) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"#\"<<x<<' '<<ans<<endl;\n}\n```","source":"_posts/Xiaobai93D-E.md","raw":"title: Xiaobai93D-E\ndate: 2024-08-14 19:46:31\ntags: [newcoder]\ncategories: \n\t- 比赛\n\t- 日常赛\n\t- newcoder\n---\n\n## [D-幻兽帕鲁_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/D)\n\n<!--more-->\n\n### 题意\n\n在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。  \n\n你有 $$2^n$$ 只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 $$[0,2^n-1]$$ 工号的顺序排成一队。  \n\n当我们对区间 $$[l,r]$$ 的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 $$[0,r-l]$$ ，记 $$mid = \\lfloor\\frac{l + r}{2}\\rfloor$$，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间 $$[l,mid]$$ 和 $$[mid + 1,r]$$ ，并递归对这两个区间进行上述操作，直到区间长度为 $1$ 。  \n\n现在我们对 $$[0,2^n-1]$$ 的幻兽进行一次操作，然后给你 $m$ 次询问，每次询问 $x$​ 位置的帕鲁工号是多少？\n\n### 题解\n\n简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。\n\n于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1<<(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。\n\n````cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tll x;\n\t\tcin>>x;\n\t\tll ans = 0;\n\t\twhile(x){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(x < (1ll<<(n-i-1))) continue;\n\t\t\t\tx-= (1ll<<(n-i-1));\n\t\t\t\tans += (1ll<<i);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n````\n\n\n\n## [E-奏绝_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/E)\n\n### **题意：**\n\n你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。  \n\n对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为 0。  \n\n区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。  \n\n对于 m 次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对  998244353 取模。\n\n[E-奏绝_牛客小白月赛93（重现赛）](https://ac.nowcoder.com/acm/contest/82821/E)\n\n### **题解**\n\n**不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积**\n\n奏绝，我直接肘击！\n\n题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。\n\n```cpp\nstruct Node\n{\n\tint x, y, id;\n};\n\nbool cmp(const Node& x,const Node& y){\n\tif(x.x/ blk != y.x /blk) return x.x/blk < y.x/blk;\n\telse {\n\t\tif(x.x != y.x) return x.x < y.x;\n\t\telse {\n\t\t\treturn x.y < y.y;\n\t\t}\n\t}\n}\n\nvoid move(int x,int c)\n{\n\tsum1 += (s[x] == '1'? x: 0) * c;\n\tcnt1 += (s[x] == '1') * c;\n\tsum2 += (s[x] == '0'? x: 0) * c;\n\tcnt2 += (s[x] == '0') * c;\n}\n\nvoid updateL(int x,int c){\n\tif(s[x]=='1'){\n\t\tans += (sum2 - x * cnt2) * c% MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x]=='0'){\n\t\tans += (sum1 - x * cnt1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"!\"<<x<<' '<<ans<<endl;\n}\nvoid updateR(int x,int c){\n\tif(s[x] == '0'){\n\t\tans += (x * cnt1 - sum1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x] == '1'){\n\t\tans += (x * cnt2 - sum2) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"#\"<<x<<' '<<ans<<endl;\n}\n```","slug":"Xiaobai93D-E","published":1,"updated":"2024-08-15T04:52:02.258Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjab000qlowv6v3n1p5b","content":"<h2 id=\"d-幻兽帕鲁_牛客小白月赛93-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI0MDEvRA==\">D-幻兽帕鲁_牛客小白月赛93\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<span id=\"more\"></span>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。</p>\r\n<p>你有 <span class=\"math display\">\\[2^n\\]</span>\r\n只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 <span\r\nclass=\"math display\">\\[[0,2^n-1]\\]</span> 工号的顺序排成一队。</p>\r\n<p>当我们对区间 <span class=\"math display\">\\[[l,r]\\]</span>\r\n的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 <span\r\nclass=\"math display\">\\[[0,r-l]\\]</span> ，记 <span\r\nclass=\"math display\">\\[mid = \\lfloor\\frac{l +\r\nr}{2}\\rfloor\\]</span>，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间\r\n<span class=\"math display\">\\[[l,mid]\\]</span> 和 <span\r\nclass=\"math display\">\\[[mid + 1,r]\\]</span>\r\n，并递归对这两个区间进行上述操作，直到区间长度为 <span\r\nclass=\"math inline\">\\(1\\)</span> 。</p>\r\n<p>现在我们对 <span class=\"math display\">\\[[0,2^n-1]\\]</span>\r\n的幻兽进行一次操作，然后给你 <span class=\"math inline\">\\(m\\)</span>\r\n次询问，每次询问 <span class=\"math inline\">\\(x\\)</span>​\r\n位置的帕鲁工号是多少？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。</p>\r\n<p>于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1&lt;&lt;(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tll x;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(x)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(x &lt; (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>))) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\tx-= (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t\t\t\tans += (<span class=\"number\">1ll</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e-奏绝_牛客小白月赛93-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI0MDEvRQ==\">E-奏绝_牛客小白月赛93\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-1\"><strong>题意：</strong></h3>\r\n<p>你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。</p>\r\n<p>对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为\r\n0。</p>\r\n<p>区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。</p>\r\n<p>对于 m\r\n次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对\r\n998244353 取模。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI4MjEvRQ==\">E-奏绝_牛客小白月赛93（重现赛）<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题解-1\"><strong>题解</strong></h3>\r\n<p><strong>不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积</strong></p>\r\n<p>奏绝，我直接肘击！</p>\r\n<p>题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y, id;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> Node&amp; x,<span class=\"type\">const</span> Node&amp; y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x.x/ blk != y.x /blk) <span class=\"keyword\">return</span> x.x/blk &lt; y.x/blk;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x.x != y.x) <span class=\"keyword\">return</span> x.x &lt; y.x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x.y &lt; y.y;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tsum1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>) * c;</span><br><span class=\"line\">\tsum2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>) * c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateL</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum2 - x * cnt2) * c% MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum1 - x * cnt1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;!&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateR</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt1 - sum1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt2 - sum2) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":916,"excerpt":"<h2 id=\"d-幻兽帕鲁_牛客小白月赛93-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI0MDEvRA==\">D-幻兽帕鲁_牛客小白月赛93\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>","more":"<h3 id=\"题意\">题意</h3>\r\n<p>在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。</p>\r\n<p>你有 <span class=\"math display\">\\[2^n\\]</span>\r\n只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 <span\r\nclass=\"math display\">\\[[0,2^n-1]\\]</span> 工号的顺序排成一队。</p>\r\n<p>当我们对区间 <span class=\"math display\">\\[[l,r]\\]</span>\r\n的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 <span\r\nclass=\"math display\">\\[[0,r-l]\\]</span> ，记 <span\r\nclass=\"math display\">\\[mid = \\lfloor\\frac{l +\r\nr}{2}\\rfloor\\]</span>，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间\r\n<span class=\"math display\">\\[[l,mid]\\]</span> 和 <span\r\nclass=\"math display\">\\[[mid + 1,r]\\]</span>\r\n，并递归对这两个区间进行上述操作，直到区间长度为 <span\r\nclass=\"math inline\">\\(1\\)</span> 。</p>\r\n<p>现在我们对 <span class=\"math display\">\\[[0,2^n-1]\\]</span>\r\n的幻兽进行一次操作，然后给你 <span class=\"math inline\">\\(m\\)</span>\r\n次询问，每次询问 <span class=\"math inline\">\\(x\\)</span>​\r\n位置的帕鲁工号是多少？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。</p>\r\n<p>于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1&lt;&lt;(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tll x;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(x)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(x &lt; (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>))) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\tx-= (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t\t\t\tans += (<span class=\"number\">1ll</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e-奏绝_牛客小白月赛93-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI0MDEvRQ==\">E-奏绝_牛客小白月赛93\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-1\"><strong>题意：</strong></h3>\r\n<p>你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。</p>\r\n<p>对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为\r\n0。</p>\r\n<p>区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。</p>\r\n<p>对于 m\r\n次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对\r\n998244353 取模。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI4MjEvRQ==\">E-奏绝_牛客小白月赛93（重现赛）<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题解-1\"><strong>题解</strong></h3>\r\n<p><strong>不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积</strong></p>\r\n<p>奏绝，我直接肘击！</p>\r\n<p>题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y, id;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> Node&amp; x,<span class=\"type\">const</span> Node&amp; y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x.x/ blk != y.x /blk) <span class=\"keyword\">return</span> x.x/blk &lt; y.x/blk;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x.x != y.x) <span class=\"keyword\">return</span> x.x &lt; y.x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x.y &lt; y.y;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tsum1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>) * c;</span><br><span class=\"line\">\tsum2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>) * c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateL</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum2 - x * cnt2) * c% MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum1 - x * cnt1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;!&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateR</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt1 - sum1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt2 - sum2) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Xiaobai94","date":"2024-08-14T11:46:31.000Z","_content":"\n## [B-小苯的好数组_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/B)\n\n<!--more-->\n\n### 题意\n\n大白熊给了小苯一个长度为 $n$ 的数组 $a$，这次他希望小苯从数组中选择一个**子序列**（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。  \n\n大白熊定义好数组是：如果一个数组按升序排序后和原来**不完全相同**，则其是一个好数组。例如 $[3,2,2]$ 升序排序后是 $[2, 2, 3]$，和原来不完全相同，因此**是**一个好数组，而 $[1,2,2]$ **不是**一个好数组。\n\n  \n\n小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？\n\n### 题解\n\n误入签到，答案只有0和n两种，很好判断\n\n```cpp\nvoid slove() {\n\tvector<int> ve;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tint x;cin>>x;\n\t\tve.pb(x);\n\t}\n\tint ls = 0,flag = 0;\n\tfor(int v:ve){\n\t\tif(v < ls)flag = 1;\n\t\tls = max(v,ls);\n\t}\n\tif(flag) cout<<n<<endl;\n\telse cout<<0<<endl;\n}\n```\n\n## [C-小苯的数字合并_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/C)\n\n### 题意\n\n大白熊给了小苯一个长度为 $$n$$ 的数组 $$a$$，小苯想要**最大化** $$a$$ 的极差。\n\n具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：  \n\n  \n\n$\\bullet$ 选择一个正整数 $$i \\ (1 \\leq i <n)$$，接着将 $$a_i$$ 与 $$a_{i+1}$$ 合并为一个数字，结果为二者的和。\n\n（即：将 $$a_i$$ 变为 $$a_i + a_{i+1}$$，然后删去 $$a_{i+1}$$，当然操作完后 $a$ 的长度也会减一。）\n\n\n小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。\n\n### 题解\n\n注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++)\n\t\tpre[i] = pre[i-1] + a[i];\n\n\tfor(int i=n;i;i--)\n\t\trep[i] = rep[i+1] + a[i];\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = max(pre[i-1] ,rep[i+1]);\n\t\tans = max(ans,mx - a[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## [D-小苯的排列构造_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/D)\n\n### 题意\n\n格格有一个长度为 $$n$$ 的排列 $$p$$，但她不记得 $$p$$ 具体的样子，她只记得数组 $$a$$。  \n其中：$$a_i = gcd(p_1, p_2,...,p_i)$$，也就是说，$$a_i$$ 表示排列 $$p$$ 中前 $$i$$ 个数字的最大公约数。  \n\n\n现在，她希望小苯将排列 $$p$$ 复原出来，请你帮帮他吧。\n\n（但有可能无解，这意味着格格给出的 $$a$$ 数组可能是不正确的，此时输出 $$-1$$ 即可。）\n\n### 题解\n\n公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。\n\n如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。\n\n如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可\n\n注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\n\tint f = 1;\n\tfor(int i = 1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tif(i > 1 && a[i-1] % a[i] != 0) f = 0;\n\t}\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tint c = 1, s = a[i];\n\t\twhile(i < n && a[i+1] == a[i])i ++,c ++;\n\t\tint t = s;\n\t\twhile(c && t <= n) {\n\t\t\twhile(st[t]) t+=s;\n\t\t\tif(t > n) break;\n\t\t\tves.push_back(t);\n\t\t\tst[t] = 1;\n\t\t\t// cout<<t<<endl;\n\t\t\tt+=s,c--;\n\t\t}\n\t\tif(c) {f = 0;break;}\n\t}\n\n\tif(!f) {cout<<-1<<endl; return ;}\n\n\tfor(int v: ves) cout<<v<<' ';\n\t\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [E-小苯的01背包（easy）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/E)\n\n##[F-小苯的01背包（hard）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/F)\n\n### 题意\n\n**注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。**  \n\n\n小苯有一个容量为 $k$ 的背包，现在有 $n$ 个物品，每个物品有一个体积 $v$ 和价值 $w$，他想知道在体积不超过 $k$ 的前提下，他最多能装价值为多少的物品。\n\n本问题中，物品的总体积定义为所装物品的体积的 $\\&$（按位与），总价值也定义为所装物品的价值的 $\\&$（按位与）。\n\n（如果不选物品，则价值为 0，所占体积也为 0。）\n\n### 题解\n\n按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）\n\n比如对于二进制下物品价值\n\n```\n101101\n110010\n101011\n110110\n```\n\n不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。\n\n构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑$$O(n\\times 4e3)$$即可，注意初始状态为(1<<14)-1，但是这样跑出来是过93%，哪里有问题？\n\n一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。\n\n官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\n\tfor(int i=1;i<=n;i++) cin>>v[i]>>w[i];\n\n\tint ans = 0;\n    for (int i = 0; i <= 2000; i++) {\n        int V = (1 << 20) - 1;\n        for (int j = 1; j <= n; j++) {\n            if ((i & w[j]) == i) {\n                V &= v[j];\n            }\n        }\n        if (V <= k)\n            ans = max(ans, i);\n    }\n    cout<<ans<<endl;\n}\n```\n\n不得不说这个写法更简洁也更正确\n\nhard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。\n\n```cpp\nvoid slove() {\n\tint i, j, k;\n     \n    cin >> n >> k;\n     \n    for (i = 1; i <= n; i++) {\n        cin >> w[i] >> v[i];\n        q[0].push({w[i], v[i]});\n    }\n    int ans = 0;\n    for (i = 30; i >= 0; i--) {\n        int ww = 0x7fffffff;\n        int now = q[0].size();\n        for (j = 0; j < now; j++) {\n            auto x = q[0].front();\n            q[0].pop();\n            if ((x.y >> i) & 1) {\n                q[1].push(x);\n                ww &= x.x;\n            } else {\n                q[0].push(x);\n            }\n        }\n         \n        if (ww <= k) {\n            ans |= (1 << i);\n            while (!q[0].empty()) {\n                q[0].pop();\n            }\n        }\n        while (!q[1].empty()) {\n            q[0].push(q[1].front());\n            q[1].pop();\n        }\n    }\n    cout << ans << endl;\n}\n```\n\n","source":"_posts/Xiaobai94.md","raw":"title: Xiaobai94\ndate: 2024-08-14 19:46:31\ntags: [newcoder]\ncategories: \n\t- 比赛\n\t- 日常赛\n\t- newcoder\n---\n\n## [B-小苯的好数组_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/B)\n\n<!--more-->\n\n### 题意\n\n大白熊给了小苯一个长度为 $n$ 的数组 $a$，这次他希望小苯从数组中选择一个**子序列**（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。  \n\n大白熊定义好数组是：如果一个数组按升序排序后和原来**不完全相同**，则其是一个好数组。例如 $[3,2,2]$ 升序排序后是 $[2, 2, 3]$，和原来不完全相同，因此**是**一个好数组，而 $[1,2,2]$ **不是**一个好数组。\n\n  \n\n小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？\n\n### 题解\n\n误入签到，答案只有0和n两种，很好判断\n\n```cpp\nvoid slove() {\n\tvector<int> ve;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tint x;cin>>x;\n\t\tve.pb(x);\n\t}\n\tint ls = 0,flag = 0;\n\tfor(int v:ve){\n\t\tif(v < ls)flag = 1;\n\t\tls = max(v,ls);\n\t}\n\tif(flag) cout<<n<<endl;\n\telse cout<<0<<endl;\n}\n```\n\n## [C-小苯的数字合并_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/C)\n\n### 题意\n\n大白熊给了小苯一个长度为 $$n$$ 的数组 $$a$$，小苯想要**最大化** $$a$$ 的极差。\n\n具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：  \n\n  \n\n$\\bullet$ 选择一个正整数 $$i \\ (1 \\leq i <n)$$，接着将 $$a_i$$ 与 $$a_{i+1}$$ 合并为一个数字，结果为二者的和。\n\n（即：将 $$a_i$$ 变为 $$a_i + a_{i+1}$$，然后删去 $$a_{i+1}$$，当然操作完后 $a$ 的长度也会减一。）\n\n\n小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。\n\n### 题解\n\n注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++)\n\t\tpre[i] = pre[i-1] + a[i];\n\n\tfor(int i=n;i;i--)\n\t\trep[i] = rep[i+1] + a[i];\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = max(pre[i-1] ,rep[i+1]);\n\t\tans = max(ans,mx - a[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## [D-小苯的排列构造_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/D)\n\n### 题意\n\n格格有一个长度为 $$n$$ 的排列 $$p$$，但她不记得 $$p$$ 具体的样子，她只记得数组 $$a$$。  \n其中：$$a_i = gcd(p_1, p_2,...,p_i)$$，也就是说，$$a_i$$ 表示排列 $$p$$ 中前 $$i$$ 个数字的最大公约数。  \n\n\n现在，她希望小苯将排列 $$p$$ 复原出来，请你帮帮他吧。\n\n（但有可能无解，这意味着格格给出的 $$a$$ 数组可能是不正确的，此时输出 $$-1$$ 即可。）\n\n### 题解\n\n公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。\n\n如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。\n\n如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可\n\n注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\n\tint f = 1;\n\tfor(int i = 1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tif(i > 1 && a[i-1] % a[i] != 0) f = 0;\n\t}\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tint c = 1, s = a[i];\n\t\twhile(i < n && a[i+1] == a[i])i ++,c ++;\n\t\tint t = s;\n\t\twhile(c && t <= n) {\n\t\t\twhile(st[t]) t+=s;\n\t\t\tif(t > n) break;\n\t\t\tves.push_back(t);\n\t\t\tst[t] = 1;\n\t\t\t// cout<<t<<endl;\n\t\t\tt+=s,c--;\n\t\t}\n\t\tif(c) {f = 0;break;}\n\t}\n\n\tif(!f) {cout<<-1<<endl; return ;}\n\n\tfor(int v: ves) cout<<v<<' ';\n\t\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [E-小苯的01背包（easy）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/E)\n\n##[F-小苯的01背包（hard）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/F)\n\n### 题意\n\n**注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。**  \n\n\n小苯有一个容量为 $k$ 的背包，现在有 $n$ 个物品，每个物品有一个体积 $v$ 和价值 $w$，他想知道在体积不超过 $k$ 的前提下，他最多能装价值为多少的物品。\n\n本问题中，物品的总体积定义为所装物品的体积的 $\\&$（按位与），总价值也定义为所装物品的价值的 $\\&$（按位与）。\n\n（如果不选物品，则价值为 0，所占体积也为 0。）\n\n### 题解\n\n按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）\n\n比如对于二进制下物品价值\n\n```\n101101\n110010\n101011\n110110\n```\n\n不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。\n\n构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑$$O(n\\times 4e3)$$即可，注意初始状态为(1<<14)-1，但是这样跑出来是过93%，哪里有问题？\n\n一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。\n\n官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\n\tfor(int i=1;i<=n;i++) cin>>v[i]>>w[i];\n\n\tint ans = 0;\n    for (int i = 0; i <= 2000; i++) {\n        int V = (1 << 20) - 1;\n        for (int j = 1; j <= n; j++) {\n            if ((i & w[j]) == i) {\n                V &= v[j];\n            }\n        }\n        if (V <= k)\n            ans = max(ans, i);\n    }\n    cout<<ans<<endl;\n}\n```\n\n不得不说这个写法更简洁也更正确\n\nhard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。\n\n```cpp\nvoid slove() {\n\tint i, j, k;\n     \n    cin >> n >> k;\n     \n    for (i = 1; i <= n; i++) {\n        cin >> w[i] >> v[i];\n        q[0].push({w[i], v[i]});\n    }\n    int ans = 0;\n    for (i = 30; i >= 0; i--) {\n        int ww = 0x7fffffff;\n        int now = q[0].size();\n        for (j = 0; j < now; j++) {\n            auto x = q[0].front();\n            q[0].pop();\n            if ((x.y >> i) & 1) {\n                q[1].push(x);\n                ww &= x.x;\n            } else {\n                q[0].push(x);\n            }\n        }\n         \n        if (ww <= k) {\n            ans |= (1 << i);\n            while (!q[0].empty()) {\n                q[0].pop();\n            }\n        }\n        while (!q[1].empty()) {\n            q[0].push(q[1].front());\n            q[1].pop();\n        }\n    }\n    cout << ans << endl;\n}\n```\n\n","slug":"Xiaobai94","published":1,"updated":"2024-08-15T04:52:04.681Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjac000slowv9vv3epwp","content":"<h2 id=\"b-小苯的好数组_牛客小白月赛94-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvQg==\">B-小苯的好数组_牛客小白月赛94\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<span id=\"more\"></span>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>大白熊给了小苯一个长度为 <span class=\"math inline\">\\(n\\)</span>\r\n的数组 <span\r\nclass=\"math inline\">\\(a\\)</span>，这次他希望小苯从数组中选择一个<strong>子序列</strong>（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。</p>\r\n<p>大白熊定义好数组是：如果一个数组按升序排序后和原来<strong>不完全相同</strong>，则其是一个好数组。例如\r\n<span class=\"math inline\">\\([3,2,2]\\)</span> 升序排序后是 <span\r\nclass=\"math inline\">\\([2, 2,\r\n3]\\)</span>，和原来不完全相同，因此<strong>是</strong>一个好数组，而\r\n<span class=\"math inline\">\\([1,2,2]\\)</span>\r\n<strong>不是</strong>一个好数组。</p>\r\n<p>小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>误入签到，答案只有0和n两种，很好判断</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ve;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x;cin&gt;&gt;x;</span><br><span class=\"line\">\t\tve.<span class=\"built_in\">pb</span>(x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ls = <span class=\"number\">0</span>,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v:ve)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(v &lt; ls)flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tls = <span class=\"built_in\">max</span>(v,ls);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flag) cout&lt;&lt;n&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"c-小苯的数字合并_牛客小白月赛94-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvQw==\">C-小苯的数字合并_牛客小白月赛94\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>大白熊给了小苯一个长度为 <span class=\"math display\">\\[n\\]</span>\r\n的数组 <span\r\nclass=\"math display\">\\[a\\]</span>，小苯想要<strong>最大化</strong> <span\r\nclass=\"math display\">\\[a\\]</span> 的极差。</p>\r\n<p>具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：</p>\r\n<p><span class=\"math inline\">\\(\\bullet\\)</span> 选择一个正整数 <span\r\nclass=\"math display\">\\[i \\ (1 \\leq i &lt;n)\\]</span>，接着将 <span\r\nclass=\"math display\">\\[a_i\\]</span> 与 <span\r\nclass=\"math display\">\\[a_{i+1}\\]</span>\r\n合并为一个数字，结果为二者的和。</p>\r\n<p>（即：将 <span class=\"math display\">\\[a_i\\]</span> 变为 <span\r\nclass=\"math display\">\\[a_i + a_{i+1}\\]</span>，然后删去 <span\r\nclass=\"math display\">\\[a_{i+1}\\]</span>，当然操作完后 <span\r\nclass=\"math inline\">\\(a\\)</span> 的长度也会减一。）</p>\r\n<p>小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\tpre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\trep[i] = rep[i<span class=\"number\">+1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(pre[i<span class=\"number\">-1</span>] ,rep[i<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\tans = <span class=\"built_in\">max</span>(ans,mx - a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d-小苯的排列构造_牛客小白月赛94-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRA==\">D-小苯的排列构造_牛客小白月赛94\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>格格有一个长度为 <span class=\"math display\">\\[n\\]</span> 的排列 <span\r\nclass=\"math display\">\\[p\\]</span>，但她不记得 <span\r\nclass=\"math display\">\\[p\\]</span> 具体的样子，她只记得数组 <span\r\nclass=\"math display\">\\[a\\]</span>。<br />\r\n其中：<span class=\"math display\">\\[a_i = gcd(p_1,\r\np_2,...,p_i)\\]</span>，也就是说，<span\r\nclass=\"math display\">\\[a_i\\]</span> 表示排列 <span\r\nclass=\"math display\">\\[p\\]</span> 中前 <span\r\nclass=\"math display\">\\[i\\]</span> 个数字的最大公约数。</p>\r\n<p>现在，她希望小苯将排列 <span class=\"math display\">\\[p\\]</span>\r\n复原出来，请你帮帮他吧。</p>\r\n<p>（但有可能无解，这意味着格格给出的 <span\r\nclass=\"math display\">\\[a\\]</span> 数组可能是不正确的，此时输出 <span\r\nclass=\"math display\">\\[-1\\]</span> 即可。）</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。</p>\r\n<p>如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。</p>\r\n<p>如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可</p>\r\n<p>注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i &gt; <span class=\"number\">1</span> &amp;&amp; a[i<span class=\"number\">-1</span>] % a[i] != <span class=\"number\">0</span>) f = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = <span class=\"number\">1</span>, s = a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; n &amp;&amp; a[i<span class=\"number\">+1</span>] == a[i])i ++,c ++;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(c &amp;&amp; t &lt;= n) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(st[t]) t+=s;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &gt; n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tves.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">\t\t\tst[t] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;t&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tt+=s,c--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c) &#123;f = <span class=\"number\">0</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ves) cout&lt;&lt;v&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e-小苯的01背包easy_牛客小白月赛94-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRQ==\">E-小苯的01背包（easy）_牛客小白月赛94\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<p>##<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRg==\">F-小苯的01背包（hard）_牛客小白月赛94\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p><strong>注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。</strong></p>\r\n<p>小苯有一个容量为 <span class=\"math inline\">\\(k\\)</span>\r\n的背包，现在有 <span class=\"math inline\">\\(n\\)</span>\r\n个物品，每个物品有一个体积 <span class=\"math inline\">\\(v\\)</span> 和价值\r\n<span class=\"math inline\">\\(w\\)</span>，他想知道在体积不超过 <span\r\nclass=\"math inline\">\\(k\\)</span>\r\n的前提下，他最多能装价值为多少的物品。</p>\r\n<p>本问题中，物品的总体积定义为所装物品的体积的 <span\r\nclass=\"math inline\">\\(\\&amp;\\)</span>（按位与），总价值也定义为所装物品的价值的\r\n<span class=\"math inline\">\\(\\&amp;\\)</span>（按位与）。</p>\r\n<p>（如果不选物品，则价值为 0，所占体积也为 0。）</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）</p>\r\n<p>比如对于二进制下物品价值</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">101101</span><br><span class=\"line\">110010</span><br><span class=\"line\">101011</span><br><span class=\"line\">110110</span><br></pre></td></tr></table></figure>\r\n<p>不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。</p>\r\n<p>构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑<span\r\nclass=\"math display\">\\[O(n\\times\r\n4e3)\\]</span>即可，注意初始状态为(1&lt;&lt;14)-1，但是这样跑出来是过93%，哪里有问题？</p>\r\n<p>一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。</p>\r\n<p>官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">2000</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> V = (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">20</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((i &amp; w[j]) == i) &#123;</span><br><span class=\"line\">                V &amp;= v[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (V &lt;= k)</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>不得不说这个写法更简洁也更正确</p>\r\n<p>hard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, j, k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class=\"line\">        q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(&#123;w[i], v[i]&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ww = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> now = q[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; now; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> x = q[<span class=\"number\">0</span>].<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((x.y &gt;&gt; i) &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">1</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">                ww &amp;= x.x;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ww &lt;= k) &#123;</span><br><span class=\"line\">            ans |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!q[<span class=\"number\">0</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q[<span class=\"number\">1</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(q[<span class=\"number\">1</span>].<span class=\"built_in\">front</span>());</span><br><span class=\"line\">            q[<span class=\"number\">1</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1738,"excerpt":"<h2 id=\"b-小苯的好数组_牛客小白月赛94-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvQg==\">B-小苯的好数组_牛客小白月赛94\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>","more":"<h3 id=\"题意\">题意</h3>\r\n<p>大白熊给了小苯一个长度为 <span class=\"math inline\">\\(n\\)</span>\r\n的数组 <span\r\nclass=\"math inline\">\\(a\\)</span>，这次他希望小苯从数组中选择一个<strong>子序列</strong>（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。</p>\r\n<p>大白熊定义好数组是：如果一个数组按升序排序后和原来<strong>不完全相同</strong>，则其是一个好数组。例如\r\n<span class=\"math inline\">\\([3,2,2]\\)</span> 升序排序后是 <span\r\nclass=\"math inline\">\\([2, 2,\r\n3]\\)</span>，和原来不完全相同，因此<strong>是</strong>一个好数组，而\r\n<span class=\"math inline\">\\([1,2,2]\\)</span>\r\n<strong>不是</strong>一个好数组。</p>\r\n<p>小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>误入签到，答案只有0和n两种，很好判断</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ve;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x;cin&gt;&gt;x;</span><br><span class=\"line\">\t\tve.<span class=\"built_in\">pb</span>(x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ls = <span class=\"number\">0</span>,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v:ve)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(v &lt; ls)flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tls = <span class=\"built_in\">max</span>(v,ls);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flag) cout&lt;&lt;n&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"c-小苯的数字合并_牛客小白月赛94-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvQw==\">C-小苯的数字合并_牛客小白月赛94\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>大白熊给了小苯一个长度为 <span class=\"math display\">\\[n\\]</span>\r\n的数组 <span\r\nclass=\"math display\">\\[a\\]</span>，小苯想要<strong>最大化</strong> <span\r\nclass=\"math display\">\\[a\\]</span> 的极差。</p>\r\n<p>具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：</p>\r\n<p><span class=\"math inline\">\\(\\bullet\\)</span> 选择一个正整数 <span\r\nclass=\"math display\">\\[i \\ (1 \\leq i &lt;n)\\]</span>，接着将 <span\r\nclass=\"math display\">\\[a_i\\]</span> 与 <span\r\nclass=\"math display\">\\[a_{i+1}\\]</span>\r\n合并为一个数字，结果为二者的和。</p>\r\n<p>（即：将 <span class=\"math display\">\\[a_i\\]</span> 变为 <span\r\nclass=\"math display\">\\[a_i + a_{i+1}\\]</span>，然后删去 <span\r\nclass=\"math display\">\\[a_{i+1}\\]</span>，当然操作完后 <span\r\nclass=\"math inline\">\\(a\\)</span> 的长度也会减一。）</p>\r\n<p>小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\tpre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\trep[i] = rep[i<span class=\"number\">+1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(pre[i<span class=\"number\">-1</span>] ,rep[i<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\tans = <span class=\"built_in\">max</span>(ans,mx - a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d-小苯的排列构造_牛客小白月赛94-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRA==\">D-小苯的排列构造_牛客小白月赛94\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>格格有一个长度为 <span class=\"math display\">\\[n\\]</span> 的排列 <span\r\nclass=\"math display\">\\[p\\]</span>，但她不记得 <span\r\nclass=\"math display\">\\[p\\]</span> 具体的样子，她只记得数组 <span\r\nclass=\"math display\">\\[a\\]</span>。<br />\r\n其中：<span class=\"math display\">\\[a_i = gcd(p_1,\r\np_2,...,p_i)\\]</span>，也就是说，<span\r\nclass=\"math display\">\\[a_i\\]</span> 表示排列 <span\r\nclass=\"math display\">\\[p\\]</span> 中前 <span\r\nclass=\"math display\">\\[i\\]</span> 个数字的最大公约数。</p>\r\n<p>现在，她希望小苯将排列 <span class=\"math display\">\\[p\\]</span>\r\n复原出来，请你帮帮他吧。</p>\r\n<p>（但有可能无解，这意味着格格给出的 <span\r\nclass=\"math display\">\\[a\\]</span> 数组可能是不正确的，此时输出 <span\r\nclass=\"math display\">\\[-1\\]</span> 即可。）</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。</p>\r\n<p>如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。</p>\r\n<p>如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可</p>\r\n<p>注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i &gt; <span class=\"number\">1</span> &amp;&amp; a[i<span class=\"number\">-1</span>] % a[i] != <span class=\"number\">0</span>) f = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = <span class=\"number\">1</span>, s = a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; n &amp;&amp; a[i<span class=\"number\">+1</span>] == a[i])i ++,c ++;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(c &amp;&amp; t &lt;= n) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(st[t]) t+=s;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &gt; n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tves.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">\t\t\tst[t] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;t&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tt+=s,c--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c) &#123;f = <span class=\"number\">0</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ves) cout&lt;&lt;v&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e-小苯的01背包easy_牛客小白月赛94-nowcoder.com\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRQ==\">E-小苯的01背包（easy）_牛客小白月赛94\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<p>##<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRg==\">F-小苯的01背包（hard）_牛客小白月赛94\r\n(nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p><strong>注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。</strong></p>\r\n<p>小苯有一个容量为 <span class=\"math inline\">\\(k\\)</span>\r\n的背包，现在有 <span class=\"math inline\">\\(n\\)</span>\r\n个物品，每个物品有一个体积 <span class=\"math inline\">\\(v\\)</span> 和价值\r\n<span class=\"math inline\">\\(w\\)</span>，他想知道在体积不超过 <span\r\nclass=\"math inline\">\\(k\\)</span>\r\n的前提下，他最多能装价值为多少的物品。</p>\r\n<p>本问题中，物品的总体积定义为所装物品的体积的 <span\r\nclass=\"math inline\">\\(\\&amp;\\)</span>（按位与），总价值也定义为所装物品的价值的\r\n<span class=\"math inline\">\\(\\&amp;\\)</span>（按位与）。</p>\r\n<p>（如果不选物品，则价值为 0，所占体积也为 0。）</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）</p>\r\n<p>比如对于二进制下物品价值</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">101101</span><br><span class=\"line\">110010</span><br><span class=\"line\">101011</span><br><span class=\"line\">110110</span><br></pre></td></tr></table></figure>\r\n<p>不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。</p>\r\n<p>构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑<span\r\nclass=\"math display\">\\[O(n\\times\r\n4e3)\\]</span>即可，注意初始状态为(1&lt;&lt;14)-1，但是这样跑出来是过93%，哪里有问题？</p>\r\n<p>一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。</p>\r\n<p>官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">2000</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> V = (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">20</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((i &amp; w[j]) == i) &#123;</span><br><span class=\"line\">                V &amp;= v[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (V &lt;= k)</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>不得不说这个写法更简洁也更正确</p>\r\n<p>hard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, j, k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class=\"line\">        q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(&#123;w[i], v[i]&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ww = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> now = q[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; now; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> x = q[<span class=\"number\">0</span>].<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((x.y &gt;&gt; i) &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">1</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">                ww &amp;= x.x;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ww &lt;= k) &#123;</span><br><span class=\"line\">            ans |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!q[<span class=\"number\">0</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q[<span class=\"number\">1</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(q[<span class=\"number\">1</span>].<span class=\"built_in\">front</span>());</span><br><span class=\"line\">            q[<span class=\"number\">1</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"abc353","date":"2024-08-14T11:46:31.000Z","_content":"\n[abc353 (atcoder.jp)](https://atcoder.jp/contests/abc353/tasks)\n\n## **C- Sigma Problem**\n\n<!--more-->\n\n第一个记录的abcC题\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 为 $$(x + y)$ 除以 $$10^8$ 的余数。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n### 题解\n\n注意题目并非是完全模运算，注意到$N\\times N\\times A_i$刚刚好在longlong 边界上。并且$A_i\\times A_i$ 最多减少一次Mod，我们只需要找出mod1e8的次数即可。\n\n刚刚开始我想的是二分，但实际上对于\n\n```text\n1 50000000 5000000 9999999 9999999 999999 999999 999999 \n```\n\n\n\n这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。\n\n我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。\n\ncode\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint cnt = 0;\n\tfor(int i=1,j=n;i<=n;i++)\n\t{\n\t\twhile(i<j && a[i] + a[j] >= MOD) j--;\n\t\tcnt += min(n-i,n-j);\n\t\t// cout<<i<<' '<<j<<endl;\n\t}\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tsum *= (n-1);\n\t// cout<<sum<<endl;\n\n\tcout<<sum - cnt * MOD<<endl;\n}\n```\n\n## **D - Another Sigma Problem**\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 如下：\n\n- 将 $$x$$ 和 $z$ 的十进制表示解释为字符串，并按此顺序连接，得到字符串 $$z$$ 。将 $$f(x, y)$$ 解释为十进制整数时，其值就是 $$z$$ 的值。\n\n例如， $$f(3, 14) = 314$$ 和 $$f(100, 1) = 1001$$ 。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式取模 $998244353$ 的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n\n### 题解\n\n写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。\n\n下面是代码code\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tint t= a[i].x,s=0;\n\t\twhile(t){\n\t\t\ts++;\n\t\t\tt/=10;\n\t\t}\n\t\ta[i].y = s;\n\t}\n\n\tfor(int i=n;i;i--){\n\t\trep[i] = (rep[i+1] + qmi(10,a[i].y)) % MOD;\n\t\t// cout<<rep[i]<<' '; \n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans = (ans + (rep[i+1] + (i-1)) * a[i].x % MOD) % MOD;\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## **E - Yet Another Sigma Problem**\n\n### 题意\n\n对于字符串 $x$ 和 $y$ ，定义 $$f(x, y)$$ 如下：\n\n- $$f(x, y)$$ 是 $$x$$ 和 $$y$$ 的最长公共前缀的长度。\n\n给你一个由小写英文字母组成的 $N$ 字符串 $$(S_1, \\ldots, S_N)$$ 。求以下表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)$$ .\n\n### 题解\n\n还是注意到同样的$O(N^2)$是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。\n\n很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案\n\n```cpp\nint build(string& s){\n\tint p = 0;\n\tint last = -1 ,res = 0;\n\tfor(int i=0;i<s.size();i++){\n\t\tint ip = s[i] - 'a';\n\t\t// cout<<ip<<endl;\n\t\tif(!son[p][ip]) son[p][ip] = ++idx;\n\t\t// cout<<s<< \"====\"<<last<< ' ' << cnt[son[p][ip]]<<nline;\n\t\tif(last == -1) last = cnt[son[p][ip]];\n\t\tif(cnt[son[p][ip]]!= last){\n\t\t\tres += (last - cnt[son[p][ip]]) * i;\n\t\t\tlast = cnt[son[p][ip]];\n\t\t}\n\t\tcnt[son[p][ip]]++;\n\t\tp = son[p][ip];\n\t}\n\tif(cnt[p]!=1){\n\t\tres +=(cnt[p] - 1)*s.size();\n\t}\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>s[i];\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans += build(s[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## **F - Tile Distance**\n\n### 题意\n\n#### 问题陈述\n\n瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 $$1\\times1$$ 的小瓦片和尺寸为 $$K\\times K$$ 的大瓦片，它们按以下规则摆放：\n\n- 对于每一对整数 $(i,j)$ ，正方形 $$\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge j\\leq y\\leq j+1\\rbrace$$ 要么包含在一块小方砖中，要么包含在一块大方砖中。\n    - 如果 $$\\left\\lfloor\\dfrac iK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor$$ 是偶数，则它包含在一个小方格中。\n    - 否则，它被包含在一个大瓦片中。\n\n瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。\n\n例如，当 $K=3$ 时，瓦片的布局如下：\n\n![](https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png)\n\n高桥开始于坐标平面上的点 $$(S_x+0.5,S_y+0.5)$$ 。\n\n他可以重复下面的动作任意多次：\n\n- 选择一个方向（上、下、左或右）和一个正整数 $$n$$ 。向该方向移动 $n$ 个单位。\n\n每次他从一张牌移动到另一张牌时，必须支付 $1$ 的过路费。\n\n求高桥到达点 $$(T_x+0.5,T_y+0.5)$$​ 所需的最小通行费。\n\n### 题解\n\n首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。\n\n然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。\n\n可以发现，不断走最大瓷砖是最优的。                  \n\n![70275E94F5C12B97C927177CEB804E4C](https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg)\n\n即上图所示的路径是最短的。\n\n显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：\n$$\ndistance = \\frac{d_s-d_a}{k} \\times 2 -1\n$$\n其中定义$$d_s$$为走过直线长度，$$d_a$$ 为两端长度，保证$$d_s - d_a \\equiv k$$​\n\n可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即$$\\frac{2}{k}$$，再减去$$1$$\n\n但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。\n\n根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k>=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。\n\n最后的结果形式上是切比雪夫距离\n\n于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小\n\n```cpp\nvoid slove() {\n\tlong k,sx,sy,tx,ty;\n\tcin>>k;\n\tcin>>sx>>sy;\n\tcin>>tx>>ty;\n\tlong ans=LLINF;\n\tint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\tfor(int i=0;i<4;++i)for(int j=0;j<4;++j)\n\t{\n\t\tlong x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=0;\n\t\tif((x+y)%2==0&&(X+Y)%2==0&&x==X&&y==Y)ans=min(ans,abs(sx-tx)+abs(sy-ty));\n\t\tif((x+y)%2==0)\n\t\t{\n\t\t\tif(dx[i]==-1)c+=sx-x*k+1;\n\t\t\tif(dx[i]==1)c+=k*(long)(x+1)-sx;\n\t\t\tif(dy[i]==-1)c+=sy-y*k+1;\n\t\t\tif(dy[i]==1)c+=k*(long)(y+1)-sy;\n\t\t\tif(k!=1)x+=dx[i],y+=dy[i];\n\t\t}\n\t\tif((X+Y)%2==0)\n\t\t{\n\t\t\tif(dx[j]==-1)c+=tx-X*k+1;\n\t\t\tif(dx[j]==1)c+=k*(long)(X+1)-tx;\n\t\t\tif(dy[j]==-1)c+=ty-Y*k+1;\n\t\t\tif(dy[j]==1)c+=k*(long)(Y+1)-ty;\n\t\t\tif(k!=1)X+=dx[j],Y+=dy[j];\n\t\t}\n\t\tif(k==1)c=abs(x-X)+abs(y-Y);\n\t\telse if(k==2)\n\t\t{\n\t\t\tlong d=min(abs(x-X),abs(y-Y));\n\t\t\tc+=d*(long)2;\n\t\t\tc+=(abs(x-X)-d)*(long)3/(long)2;\n\t\t\tc+=(abs(y-Y)-d)*(long)3/(long)2;\n\t\t}\n\t\telse c+=max(abs(x-X),abs(y-Y))*(long)2;\n\t\tans=min(ans,c);\n\t}\n\tcout<<ans;\n}\n```\n\n## **G - Merchant Takahashi**\n\n### 题意\n\nAtCoder 王国有 $N$ 个城镇：城镇 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。从 $i$ 镇到 $j$ 镇，必须支付 $C \\times |i-j|$ 日元的过路费。\n\n商人高桥正在考虑参加 $M$ 个或更多即将到来的市场。\n\n$i$ /-市场 $$(1 \\leq i \\leq M)$$ 由一对整数 $$(T_i, P_i)$$ 描述，其中市场在城镇 $$T_i$$ 举行，如果他参加将赚取 $$P_i$$ 日元。\n\n对于所有 $$1 \\leq i < M$$ ， $$i$$ 次市场在 $$(i+1)$$ 次市场开始之前结束。他移动的时间可以忽略不计。\n\n他从 $$10^{10^{100}}$$ 日元开始，最初在 $$1$$ 镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。\n\n形式上，如果他在 $$M$$ 个市场后获得最大资金额，那么 $$10^{10^{100}} + X$$ 就是他的最终资金额。求 $$X$$ 。\n\n### 题解\n\n显然的dp问题，如果你看不出来这是个dp问题建议你看一看[再看最著名的 NP 问题之 TSP 旅行商问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/659884622)，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。\n\n详细到这一题，很简单的状态表示为\n$$\nf_i:到i城的最大profit\n$$\n状态转移为：\n$$\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}\n$$\n对绝对值正负进行分类\n$$\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}\n$$\n提出取最大中的常数项：\n$$\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C\n$$\n接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。\n\n```cpp\n\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = -LLINF; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = -LLINF,ri = -LLINF;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>c;\n\tcin>>m;\n\tbuild(1,n,1,tr1);\n\tbuild(1,n,1,tr2);\n\n\tmodify(1,c,1,tr1);\n\tmodify(1,-c,1,tr2);\n\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>t[i]>>p[i];\n\t\tint l = query(1,t[i],1,tr1);\n\t\tint r = query(t[i],n,1,tr2);\n\t\t// cout<<l<<' '<<r<<endl;\n\t\tint mx = max(l+p[i]-t[i]*c,r+p[i]+t[i]*c);\n\t\tf[t[i]] = mx;\n\t\t// cout<<t[i]<< ' ' <<f[t[i]]<<nline;\n\t\tmodify(t[i],f[t[i]] + t[i] * c,1,tr1);\n\t\tmodify(t[i],f[t[i]] - t[i] * c,1,tr2);\n\t}\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) ans =max(ans,f[i]);\n\n\tcout<<ans<<endl;\n\treturn ;\n}\n```\n\n","source":"_posts/abc353.md","raw":"---\ntitle: abc353\ndate: 2024-08-14 19:46:31\ntags: [算法, 思维题, 模运算]\ncategories: \n\t- 算法\n\t- 思维题\n\t- 模运算\n---\n\n[abc353 (atcoder.jp)](https://atcoder.jp/contests/abc353/tasks)\n\n## **C- Sigma Problem**\n\n<!--more-->\n\n第一个记录的abcC题\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 为 $$(x + y)$ 除以 $$10^8$ 的余数。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n### 题解\n\n注意题目并非是完全模运算，注意到$N\\times N\\times A_i$刚刚好在longlong 边界上。并且$A_i\\times A_i$ 最多减少一次Mod，我们只需要找出mod1e8的次数即可。\n\n刚刚开始我想的是二分，但实际上对于\n\n```text\n1 50000000 5000000 9999999 9999999 999999 999999 999999 \n```\n\n\n\n这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。\n\n我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。\n\ncode\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint cnt = 0;\n\tfor(int i=1,j=n;i<=n;i++)\n\t{\n\t\twhile(i<j && a[i] + a[j] >= MOD) j--;\n\t\tcnt += min(n-i,n-j);\n\t\t// cout<<i<<' '<<j<<endl;\n\t}\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tsum *= (n-1);\n\t// cout<<sum<<endl;\n\n\tcout<<sum - cnt * MOD<<endl;\n}\n```\n\n## **D - Another Sigma Problem**\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 如下：\n\n- 将 $$x$$ 和 $z$ 的十进制表示解释为字符串，并按此顺序连接，得到字符串 $$z$$ 。将 $$f(x, y)$$ 解释为十进制整数时，其值就是 $$z$$ 的值。\n\n例如， $$f(3, 14) = 314$$ 和 $$f(100, 1) = 1001$$ 。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式取模 $998244353$ 的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n\n### 题解\n\n写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。\n\n下面是代码code\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tint t= a[i].x,s=0;\n\t\twhile(t){\n\t\t\ts++;\n\t\t\tt/=10;\n\t\t}\n\t\ta[i].y = s;\n\t}\n\n\tfor(int i=n;i;i--){\n\t\trep[i] = (rep[i+1] + qmi(10,a[i].y)) % MOD;\n\t\t// cout<<rep[i]<<' '; \n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans = (ans + (rep[i+1] + (i-1)) * a[i].x % MOD) % MOD;\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## **E - Yet Another Sigma Problem**\n\n### 题意\n\n对于字符串 $x$ 和 $y$ ，定义 $$f(x, y)$$ 如下：\n\n- $$f(x, y)$$ 是 $$x$$ 和 $$y$$ 的最长公共前缀的长度。\n\n给你一个由小写英文字母组成的 $N$ 字符串 $$(S_1, \\ldots, S_N)$$ 。求以下表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)$$ .\n\n### 题解\n\n还是注意到同样的$O(N^2)$是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。\n\n很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案\n\n```cpp\nint build(string& s){\n\tint p = 0;\n\tint last = -1 ,res = 0;\n\tfor(int i=0;i<s.size();i++){\n\t\tint ip = s[i] - 'a';\n\t\t// cout<<ip<<endl;\n\t\tif(!son[p][ip]) son[p][ip] = ++idx;\n\t\t// cout<<s<< \"====\"<<last<< ' ' << cnt[son[p][ip]]<<nline;\n\t\tif(last == -1) last = cnt[son[p][ip]];\n\t\tif(cnt[son[p][ip]]!= last){\n\t\t\tres += (last - cnt[son[p][ip]]) * i;\n\t\t\tlast = cnt[son[p][ip]];\n\t\t}\n\t\tcnt[son[p][ip]]++;\n\t\tp = son[p][ip];\n\t}\n\tif(cnt[p]!=1){\n\t\tres +=(cnt[p] - 1)*s.size();\n\t}\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>s[i];\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans += build(s[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## **F - Tile Distance**\n\n### 题意\n\n#### 问题陈述\n\n瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 $$1\\times1$$ 的小瓦片和尺寸为 $$K\\times K$$ 的大瓦片，它们按以下规则摆放：\n\n- 对于每一对整数 $(i,j)$ ，正方形 $$\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge j\\leq y\\leq j+1\\rbrace$$ 要么包含在一块小方砖中，要么包含在一块大方砖中。\n    - 如果 $$\\left\\lfloor\\dfrac iK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor$$ 是偶数，则它包含在一个小方格中。\n    - 否则，它被包含在一个大瓦片中。\n\n瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。\n\n例如，当 $K=3$ 时，瓦片的布局如下：\n\n![](https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png)\n\n高桥开始于坐标平面上的点 $$(S_x+0.5,S_y+0.5)$$ 。\n\n他可以重复下面的动作任意多次：\n\n- 选择一个方向（上、下、左或右）和一个正整数 $$n$$ 。向该方向移动 $n$ 个单位。\n\n每次他从一张牌移动到另一张牌时，必须支付 $1$ 的过路费。\n\n求高桥到达点 $$(T_x+0.5,T_y+0.5)$$​ 所需的最小通行费。\n\n### 题解\n\n首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。\n\n然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。\n\n可以发现，不断走最大瓷砖是最优的。                  \n\n![70275E94F5C12B97C927177CEB804E4C](https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg)\n\n即上图所示的路径是最短的。\n\n显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：\n$$\ndistance = \\frac{d_s-d_a}{k} \\times 2 -1\n$$\n其中定义$$d_s$$为走过直线长度，$$d_a$$ 为两端长度，保证$$d_s - d_a \\equiv k$$​\n\n可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即$$\\frac{2}{k}$$，再减去$$1$$\n\n但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。\n\n根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k>=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。\n\n最后的结果形式上是切比雪夫距离\n\n于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小\n\n```cpp\nvoid slove() {\n\tlong k,sx,sy,tx,ty;\n\tcin>>k;\n\tcin>>sx>>sy;\n\tcin>>tx>>ty;\n\tlong ans=LLINF;\n\tint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\tfor(int i=0;i<4;++i)for(int j=0;j<4;++j)\n\t{\n\t\tlong x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=0;\n\t\tif((x+y)%2==0&&(X+Y)%2==0&&x==X&&y==Y)ans=min(ans,abs(sx-tx)+abs(sy-ty));\n\t\tif((x+y)%2==0)\n\t\t{\n\t\t\tif(dx[i]==-1)c+=sx-x*k+1;\n\t\t\tif(dx[i]==1)c+=k*(long)(x+1)-sx;\n\t\t\tif(dy[i]==-1)c+=sy-y*k+1;\n\t\t\tif(dy[i]==1)c+=k*(long)(y+1)-sy;\n\t\t\tif(k!=1)x+=dx[i],y+=dy[i];\n\t\t}\n\t\tif((X+Y)%2==0)\n\t\t{\n\t\t\tif(dx[j]==-1)c+=tx-X*k+1;\n\t\t\tif(dx[j]==1)c+=k*(long)(X+1)-tx;\n\t\t\tif(dy[j]==-1)c+=ty-Y*k+1;\n\t\t\tif(dy[j]==1)c+=k*(long)(Y+1)-ty;\n\t\t\tif(k!=1)X+=dx[j],Y+=dy[j];\n\t\t}\n\t\tif(k==1)c=abs(x-X)+abs(y-Y);\n\t\telse if(k==2)\n\t\t{\n\t\t\tlong d=min(abs(x-X),abs(y-Y));\n\t\t\tc+=d*(long)2;\n\t\t\tc+=(abs(x-X)-d)*(long)3/(long)2;\n\t\t\tc+=(abs(y-Y)-d)*(long)3/(long)2;\n\t\t}\n\t\telse c+=max(abs(x-X),abs(y-Y))*(long)2;\n\t\tans=min(ans,c);\n\t}\n\tcout<<ans;\n}\n```\n\n## **G - Merchant Takahashi**\n\n### 题意\n\nAtCoder 王国有 $N$ 个城镇：城镇 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。从 $i$ 镇到 $j$ 镇，必须支付 $C \\times |i-j|$ 日元的过路费。\n\n商人高桥正在考虑参加 $M$ 个或更多即将到来的市场。\n\n$i$ /-市场 $$(1 \\leq i \\leq M)$$ 由一对整数 $$(T_i, P_i)$$ 描述，其中市场在城镇 $$T_i$$ 举行，如果他参加将赚取 $$P_i$$ 日元。\n\n对于所有 $$1 \\leq i < M$$ ， $$i$$ 次市场在 $$(i+1)$$ 次市场开始之前结束。他移动的时间可以忽略不计。\n\n他从 $$10^{10^{100}}$$ 日元开始，最初在 $$1$$ 镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。\n\n形式上，如果他在 $$M$$ 个市场后获得最大资金额，那么 $$10^{10^{100}} + X$$ 就是他的最终资金额。求 $$X$$ 。\n\n### 题解\n\n显然的dp问题，如果你看不出来这是个dp问题建议你看一看[再看最著名的 NP 问题之 TSP 旅行商问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/659884622)，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。\n\n详细到这一题，很简单的状态表示为\n$$\nf_i:到i城的最大profit\n$$\n状态转移为：\n$$\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}\n$$\n对绝对值正负进行分类\n$$\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}\n$$\n提出取最大中的常数项：\n$$\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C\n$$\n接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。\n\n```cpp\n\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = -LLINF; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = -LLINF,ri = -LLINF;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>c;\n\tcin>>m;\n\tbuild(1,n,1,tr1);\n\tbuild(1,n,1,tr2);\n\n\tmodify(1,c,1,tr1);\n\tmodify(1,-c,1,tr2);\n\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>t[i]>>p[i];\n\t\tint l = query(1,t[i],1,tr1);\n\t\tint r = query(t[i],n,1,tr2);\n\t\t// cout<<l<<' '<<r<<endl;\n\t\tint mx = max(l+p[i]-t[i]*c,r+p[i]+t[i]*c);\n\t\tf[t[i]] = mx;\n\t\t// cout<<t[i]<< ' ' <<f[t[i]]<<nline;\n\t\tmodify(t[i],f[t[i]] + t[i] * c,1,tr1);\n\t\tmodify(t[i],f[t[i]] - t[i] * c,1,tr2);\n\t}\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) ans =max(ans,f[i]);\n\n\tcout<<ans<<endl;\n\treturn ;\n}\n```\n\n","slug":"abc353","published":1,"updated":"2024-08-15T04:51:26.275Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjad000vlowv4tnqfzyh","content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1My90YXNrcw==\">abc353\r\n(atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h2 id=\"c--sigma-problem\"><strong>C- Sigma Problem</strong></h2>\r\n<span id=\"more\"></span>\r\n<p>第一个记录的abcC题</p>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>对于正整数 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 为 <span\r\nclass=\"math display\">\\[(x + y)$ 除以 \\]</span>10^8$ 的余数。</p>\r\n<p>给你一个长度为 <span class=\"math inline\">\\(N\\)</span> 的正整数序列\r\n<span class=\"math display\">\\[A = (A_1, \\ldots, A_N)\\]</span>\r\n。求下面表达式的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)\\]</span>​ . ### 题解</p>\r\n<p>注意题目并非是完全模运算，注意到<span class=\"math inline\">\\(N\\times\r\nN\\times A_i\\)</span>刚刚好在longlong 边界上。并且<span\r\nclass=\"math inline\">\\(A_i\\times A_i\\)</span>\r\n最多减少一次Mod，我们只需要找出mod1e8的次数即可。</p>\r\n<p>刚刚开始我想的是二分，但实际上对于</p>\r\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 50000000 5000000 9999999 9999999 999999 999999 999999 </span><br></pre></td></tr></table></figure>\r\n<p>这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。</p>\r\n<p>我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。</p>\r\n<p>code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=n;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i&lt;j &amp;&amp; a[i] + a[j] &gt;= MOD) j--;</span><br><span class=\"line\">\t\tcnt += <span class=\"built_in\">min</span>(n-i,n-j);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tsum *= (n<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum - cnt * MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d---another-sigma-problem\"><strong>D - Another Sigma\r\nProblem</strong></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>对于正整数 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 如下：</p>\r\n<ul>\r\n<li>将 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span>\r\n的十进制表示解释为字符串，并按此顺序连接，得到字符串 <span\r\nclass=\"math display\">\\[z\\]</span> 。将 <span class=\"math display\">\\[f(x,\r\ny)\\]</span> 解释为十进制整数时，其值就是 <span\r\nclass=\"math display\">\\[z\\]</span> 的值。</li>\r\n</ul>\r\n<p>例如， <span class=\"math display\">\\[f(3, 14) = 314\\]</span> 和 <span\r\nclass=\"math display\">\\[f(100, 1) = 1001\\]</span> 。</p>\r\n<p>给你一个长度为 <span class=\"math inline\">\\(N\\)</span> 的正整数序列\r\n<span class=\"math display\">\\[A = (A_1, \\ldots, A_N)\\]</span>\r\n。求下面表达式取模 <span class=\"math inline\">\\(998244353\\)</span>\r\n的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)\\]</span>​ .</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。</p>\r\n<p>下面是代码code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t= a[i].x,s=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(t)&#123;</span><br><span class=\"line\">\t\t\ts++;</span><br><span class=\"line\">\t\t\tt/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ta[i].y = s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\trep[i] = (rep[i<span class=\"number\">+1</span>] + <span class=\"built_in\">qmi</span>(<span class=\"number\">10</span>,a[i].y)) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;rep[i]&lt;&lt;&#x27; &#x27;; </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans = (ans + (rep[i<span class=\"number\">+1</span>] + (i<span class=\"number\">-1</span>)) * a[i].x % MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e---yet-another-sigma-problem\"><strong>E - Yet Another Sigma\r\nProblem</strong></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>对于字符串 <span class=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(y\\)</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 如下：</p>\r\n<ul>\r\n<li><span class=\"math display\">\\[f(x, y)\\]</span> 是 <span\r\nclass=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> 的最长公共前缀的长度。</li>\r\n</ul>\r\n<p>给你一个由小写英文字母组成的 <span class=\"math inline\">\\(N\\)</span>\r\n字符串 <span class=\"math display\">\\[(S_1, \\ldots, S_N)\\]</span>\r\n。求以下表达式的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)\\]</span> .</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>还是注意到同样的<span\r\nclass=\"math inline\">\\(O(N^2)\\)</span>是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。</p>\r\n<p>很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">build</span><span class=\"params\">(string&amp; s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> last = <span class=\"number\">-1</span> ,res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ip = s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ip&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!son[p][ip]) son[p][ip] = ++idx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;s&lt;&lt; &quot;====&quot;&lt;&lt;last&lt;&lt; &#x27; &#x27; &lt;&lt; cnt[son[p][ip]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(last == <span class=\"number\">-1</span>) last = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt[son[p][ip]]!= last)&#123;</span><br><span class=\"line\">\t\t\tres += (last - cnt[son[p][ip]]) * i;</span><br><span class=\"line\">\t\t\tlast = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt[son[p][ip]]++;</span><br><span class=\"line\">\t\tp = son[p][ip];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(cnt[p]!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tres +=(cnt[p] - <span class=\"number\">1</span>)*s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;s[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans += <span class=\"built_in\">build</span>(s[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f---tile-distance\"><strong>F - Tile Distance</strong></h2>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<h4 id=\"问题陈述\">问题陈述</h4>\r\n<p>瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 <span\r\nclass=\"math display\">\\[1\\times1\\]</span> 的小瓦片和尺寸为 <span\r\nclass=\"math display\">\\[K\\times K\\]</span>\r\n的大瓦片，它们按以下规则摆放：</p>\r\n<ul>\r\n<li>对于每一对整数 <span class=\"math inline\">\\((i,j)\\)</span> ，正方形\r\n<span class=\"math display\">\\[\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge\r\nj\\leq y\\leq j+1\\rbrace\\]</span>\r\n要么包含在一块小方砖中，要么包含在一块大方砖中。\r\n<ul>\r\n<li>如果 <span class=\"math display\">\\[\\left\\lfloor\\dfrac\r\niK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor\\]</span>\r\n是偶数，则它包含在一个小方格中。</li>\r\n<li>否则，它被包含在一个大瓦片中。</li>\r\n</ul></li>\r\n</ul>\r\n<p>瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。</p>\r\n<p>例如，当 <span class=\"math inline\">\\(K=3\\)</span>\r\n时，瓦片的布局如下：</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png\" /></p>\r\n<p>高桥开始于坐标平面上的点 <span\r\nclass=\"math display\">\\[(S_x+0.5,S_y+0.5)\\]</span> 。</p>\r\n<p>他可以重复下面的动作任意多次：</p>\r\n<ul>\r\n<li>选择一个方向（上、下、左或右）和一个正整数 <span\r\nclass=\"math display\">\\[n\\]</span> 。向该方向移动 <span\r\nclass=\"math inline\">\\(n\\)</span> 个单位。</li>\r\n</ul>\r\n<p>每次他从一张牌移动到另一张牌时，必须支付 <span\r\nclass=\"math inline\">\\(1\\)</span> 的过路费。</p>\r\n<p>求高桥到达点 <span class=\"math display\">\\[(T_x+0.5,T_y+0.5)\\]</span>​\r\n所需的最小通行费。</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。</p>\r\n<p>然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。</p>\r\n<p>可以发现，不断走最大瓷砖是最优的。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg\"\r\nalt=\"70275E94F5C12B97C927177CEB804E4C\" />\r\n<figcaption\r\naria-hidden=\"true\">70275E94F5C12B97C927177CEB804E4C</figcaption>\r\n</figure>\r\n<p>即上图所示的路径是最短的。</p>\r\n<p>显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：\r\n<span class=\"math display\">\\[\r\ndistance = \\frac{d_s-d_a}{k} \\times 2 -1\r\n\\]</span> 其中定义<span\r\nclass=\"math display\">\\[d_s\\]</span>为走过直线长度，<span\r\nclass=\"math display\">\\[d_a\\]</span> 为两端长度，保证<span\r\nclass=\"math display\">\\[d_s - d_a \\equiv k\\]</span>​</p>\r\n<p>可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即<span\r\nclass=\"math display\">\\[\\frac{2}{k}\\]</span>，再减去<span\r\nclass=\"math display\">\\[1\\]</span></p>\r\n<p>但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。</p>\r\n<p>根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k&gt;=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。</p>\r\n<p>最后的结果形式上是切比雪夫距离</p>\r\n<p>于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> k,sx,sy,tx,ty;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\tcin&gt;&gt;sx&gt;&gt;sy;</span><br><span class=\"line\">\tcin&gt;&gt;tx&gt;&gt;ty;</span><br><span class=\"line\">\t<span class=\"type\">long</span> ans=LLINF;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;++i)<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">4</span>;++j)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;(X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;x==X&amp;&amp;y==Y)ans=<span class=\"built_in\">min</span>(ans,<span class=\"built_in\">abs</span>(sx-tx)+<span class=\"built_in\">abs</span>(sy-ty));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">-1</span>)c+=sx-x*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(x<span class=\"number\">+1</span>)-sx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">-1</span>)c+=sy-y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(y<span class=\"number\">+1</span>)-sy;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)x+=dx[i],y+=dy[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">-1</span>)c+=tx-X*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(X<span class=\"number\">+1</span>)-tx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">-1</span>)c+=ty-Y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(Y<span class=\"number\">+1</span>)-ty;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)X+=dx[j],Y+=dy[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(k==<span class=\"number\">1</span>)c=<span class=\"built_in\">abs</span>(x-X)+<span class=\"built_in\">abs</span>(y-Y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k==<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">long</span> d=<span class=\"built_in\">min</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y));</span><br><span class=\"line\">\t\t\tc+=d*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(x-X)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(y-Y)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c+=<span class=\"built_in\">max</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y))*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tans=<span class=\"built_in\">min</span>(ans,c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g---merchant-takahashi\"><strong>G - Merchant\r\nTakahashi</strong></h2>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>AtCoder 王国有 <span class=\"math inline\">\\(N\\)</span> 个城镇：城镇\r\n<span class=\"math inline\">\\(1\\)</span> 、 <span\r\nclass=\"math inline\">\\(2\\)</span> 、 <span\r\nclass=\"math inline\">\\(\\ldots\\)</span> 、 <span\r\nclass=\"math inline\">\\(N\\)</span> 。从 <span\r\nclass=\"math inline\">\\(i\\)</span> 镇到 <span\r\nclass=\"math inline\">\\(j\\)</span> 镇，必须支付 <span\r\nclass=\"math inline\">\\(C \\times |i-j|\\)</span> 日元的过路费。</p>\r\n<p>商人高桥正在考虑参加 <span class=\"math inline\">\\(M\\)</span>\r\n个或更多即将到来的市场。</p>\r\n<p><span class=\"math inline\">\\(i\\)</span> /-市场 <span\r\nclass=\"math display\">\\[(1 \\leq i \\leq M)\\]</span> 由一对整数 <span\r\nclass=\"math display\">\\[(T_i, P_i)\\]</span> 描述，其中市场在城镇 <span\r\nclass=\"math display\">\\[T_i\\]</span> 举行，如果他参加将赚取 <span\r\nclass=\"math display\">\\[P_i\\]</span> 日元。</p>\r\n<p>对于所有 <span class=\"math display\">\\[1 \\leq i &lt; M\\]</span> ，\r\n<span class=\"math display\">\\[i\\]</span> 次市场在 <span\r\nclass=\"math display\">\\[(i+1)\\]</span>\r\n次市场开始之前结束。他移动的时间可以忽略不计。</p>\r\n<p>他从 <span class=\"math display\">\\[10^{10^{100}}\\]</span>\r\n日元开始，最初在 <span class=\"math display\">\\[1\\]</span>\r\n镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。</p>\r\n<p>形式上，如果他在 <span class=\"math display\">\\[M\\]</span>\r\n个市场后获得最大资金额，那么 <span class=\"math display\">\\[10^{10^{100}}\r\n+ X\\]</span> 就是他的最终资金额。求 <span\r\nclass=\"math display\">\\[X\\]</span> 。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>显然的dp问题，如果你看不出来这是个dp问题建议你看一看<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NTk4ODQ2MjI=\">再看最著名的 NP 问题之 TSP\r\n旅行商问题 - 知乎\r\n(zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span>，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。</p>\r\n<p>详细到这一题，很简单的状态表示为 <span class=\"math display\">\\[\r\nf_i:到i城的最大profit\r\n\\]</span> 状态转移为： <span class=\"math display\">\\[\r\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}\r\n\\]</span> 对绝对值正负进行分类 <span class=\"math display\">\\[\r\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\r\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}\r\n\\]</span> 提出取最大中的常数项： <span class=\"math display\">\\[\r\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\r\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C\r\n\\]</span>\r\n接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = -LLINF; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = -LLINF,ri = -LLINF;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;c;</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,-c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t[i]&gt;&gt;p[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,t[i],<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r = <span class=\"built_in\">query</span>(t[i],n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(l+p[i]-t[i]*c,r+p[i]+t[i]*c);</span><br><span class=\"line\">\t\tf[t[i]] = mx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;t[i]&lt;&lt; &#x27; &#x27; &lt;&lt;f[t[i]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] + t[i] * c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] - t[i] * c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans =<span class=\"built_in\">max</span>(ans,f[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":2758,"excerpt":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1My90YXNrcw==\">abc353\r\n(atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h2 id=\"c--sigma-problem\"><strong>C- Sigma Problem</strong></h2>","more":"<p>第一个记录的abcC题</p>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>对于正整数 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 为 <span\r\nclass=\"math display\">\\[(x + y)$ 除以 \\]</span>10^8$ 的余数。</p>\r\n<p>给你一个长度为 <span class=\"math inline\">\\(N\\)</span> 的正整数序列\r\n<span class=\"math display\">\\[A = (A_1, \\ldots, A_N)\\]</span>\r\n。求下面表达式的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)\\]</span>​ . ### 题解</p>\r\n<p>注意题目并非是完全模运算，注意到<span class=\"math inline\">\\(N\\times\r\nN\\times A_i\\)</span>刚刚好在longlong 边界上。并且<span\r\nclass=\"math inline\">\\(A_i\\times A_i\\)</span>\r\n最多减少一次Mod，我们只需要找出mod1e8的次数即可。</p>\r\n<p>刚刚开始我想的是二分，但实际上对于</p>\r\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 50000000 5000000 9999999 9999999 999999 999999 999999 </span><br></pre></td></tr></table></figure>\r\n<p>这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。</p>\r\n<p>我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。</p>\r\n<p>code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=n;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i&lt;j &amp;&amp; a[i] + a[j] &gt;= MOD) j--;</span><br><span class=\"line\">\t\tcnt += <span class=\"built_in\">min</span>(n-i,n-j);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tsum *= (n<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum - cnt * MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d---another-sigma-problem\"><strong>D - Another Sigma\r\nProblem</strong></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>对于正整数 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 如下：</p>\r\n<ul>\r\n<li>将 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span>\r\n的十进制表示解释为字符串，并按此顺序连接，得到字符串 <span\r\nclass=\"math display\">\\[z\\]</span> 。将 <span class=\"math display\">\\[f(x,\r\ny)\\]</span> 解释为十进制整数时，其值就是 <span\r\nclass=\"math display\">\\[z\\]</span> 的值。</li>\r\n</ul>\r\n<p>例如， <span class=\"math display\">\\[f(3, 14) = 314\\]</span> 和 <span\r\nclass=\"math display\">\\[f(100, 1) = 1001\\]</span> 。</p>\r\n<p>给你一个长度为 <span class=\"math inline\">\\(N\\)</span> 的正整数序列\r\n<span class=\"math display\">\\[A = (A_1, \\ldots, A_N)\\]</span>\r\n。求下面表达式取模 <span class=\"math inline\">\\(998244353\\)</span>\r\n的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)\\]</span>​ .</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。</p>\r\n<p>下面是代码code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t= a[i].x,s=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(t)&#123;</span><br><span class=\"line\">\t\t\ts++;</span><br><span class=\"line\">\t\t\tt/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ta[i].y = s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\trep[i] = (rep[i<span class=\"number\">+1</span>] + <span class=\"built_in\">qmi</span>(<span class=\"number\">10</span>,a[i].y)) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;rep[i]&lt;&lt;&#x27; &#x27;; </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans = (ans + (rep[i<span class=\"number\">+1</span>] + (i<span class=\"number\">-1</span>)) * a[i].x % MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e---yet-another-sigma-problem\"><strong>E - Yet Another Sigma\r\nProblem</strong></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>对于字符串 <span class=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(y\\)</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 如下：</p>\r\n<ul>\r\n<li><span class=\"math display\">\\[f(x, y)\\]</span> 是 <span\r\nclass=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> 的最长公共前缀的长度。</li>\r\n</ul>\r\n<p>给你一个由小写英文字母组成的 <span class=\"math inline\">\\(N\\)</span>\r\n字符串 <span class=\"math display\">\\[(S_1, \\ldots, S_N)\\]</span>\r\n。求以下表达式的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)\\]</span> .</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>还是注意到同样的<span\r\nclass=\"math inline\">\\(O(N^2)\\)</span>是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。</p>\r\n<p>很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">build</span><span class=\"params\">(string&amp; s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> last = <span class=\"number\">-1</span> ,res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ip = s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ip&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!son[p][ip]) son[p][ip] = ++idx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;s&lt;&lt; &quot;====&quot;&lt;&lt;last&lt;&lt; &#x27; &#x27; &lt;&lt; cnt[son[p][ip]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(last == <span class=\"number\">-1</span>) last = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt[son[p][ip]]!= last)&#123;</span><br><span class=\"line\">\t\t\tres += (last - cnt[son[p][ip]]) * i;</span><br><span class=\"line\">\t\t\tlast = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt[son[p][ip]]++;</span><br><span class=\"line\">\t\tp = son[p][ip];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(cnt[p]!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tres +=(cnt[p] - <span class=\"number\">1</span>)*s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;s[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans += <span class=\"built_in\">build</span>(s[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f---tile-distance\"><strong>F - Tile Distance</strong></h2>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<h4 id=\"问题陈述\">问题陈述</h4>\r\n<p>瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 <span\r\nclass=\"math display\">\\[1\\times1\\]</span> 的小瓦片和尺寸为 <span\r\nclass=\"math display\">\\[K\\times K\\]</span>\r\n的大瓦片，它们按以下规则摆放：</p>\r\n<ul>\r\n<li>对于每一对整数 <span class=\"math inline\">\\((i,j)\\)</span> ，正方形\r\n<span class=\"math display\">\\[\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge\r\nj\\leq y\\leq j+1\\rbrace\\]</span>\r\n要么包含在一块小方砖中，要么包含在一块大方砖中。\r\n<ul>\r\n<li>如果 <span class=\"math display\">\\[\\left\\lfloor\\dfrac\r\niK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor\\]</span>\r\n是偶数，则它包含在一个小方格中。</li>\r\n<li>否则，它被包含在一个大瓦片中。</li>\r\n</ul></li>\r\n</ul>\r\n<p>瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。</p>\r\n<p>例如，当 <span class=\"math inline\">\\(K=3\\)</span>\r\n时，瓦片的布局如下：</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png\" /></p>\r\n<p>高桥开始于坐标平面上的点 <span\r\nclass=\"math display\">\\[(S_x+0.5,S_y+0.5)\\]</span> 。</p>\r\n<p>他可以重复下面的动作任意多次：</p>\r\n<ul>\r\n<li>选择一个方向（上、下、左或右）和一个正整数 <span\r\nclass=\"math display\">\\[n\\]</span> 。向该方向移动 <span\r\nclass=\"math inline\">\\(n\\)</span> 个单位。</li>\r\n</ul>\r\n<p>每次他从一张牌移动到另一张牌时，必须支付 <span\r\nclass=\"math inline\">\\(1\\)</span> 的过路费。</p>\r\n<p>求高桥到达点 <span class=\"math display\">\\[(T_x+0.5,T_y+0.5)\\]</span>​\r\n所需的最小通行费。</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。</p>\r\n<p>然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。</p>\r\n<p>可以发现，不断走最大瓷砖是最优的。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg\"\r\nalt=\"70275E94F5C12B97C927177CEB804E4C\" />\r\n<figcaption\r\naria-hidden=\"true\">70275E94F5C12B97C927177CEB804E4C</figcaption>\r\n</figure>\r\n<p>即上图所示的路径是最短的。</p>\r\n<p>显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：\r\n<span class=\"math display\">\\[\r\ndistance = \\frac{d_s-d_a}{k} \\times 2 -1\r\n\\]</span> 其中定义<span\r\nclass=\"math display\">\\[d_s\\]</span>为走过直线长度，<span\r\nclass=\"math display\">\\[d_a\\]</span> 为两端长度，保证<span\r\nclass=\"math display\">\\[d_s - d_a \\equiv k\\]</span>​</p>\r\n<p>可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即<span\r\nclass=\"math display\">\\[\\frac{2}{k}\\]</span>，再减去<span\r\nclass=\"math display\">\\[1\\]</span></p>\r\n<p>但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。</p>\r\n<p>根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k&gt;=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。</p>\r\n<p>最后的结果形式上是切比雪夫距离</p>\r\n<p>于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> k,sx,sy,tx,ty;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\tcin&gt;&gt;sx&gt;&gt;sy;</span><br><span class=\"line\">\tcin&gt;&gt;tx&gt;&gt;ty;</span><br><span class=\"line\">\t<span class=\"type\">long</span> ans=LLINF;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;++i)<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">4</span>;++j)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;(X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;x==X&amp;&amp;y==Y)ans=<span class=\"built_in\">min</span>(ans,<span class=\"built_in\">abs</span>(sx-tx)+<span class=\"built_in\">abs</span>(sy-ty));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">-1</span>)c+=sx-x*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(x<span class=\"number\">+1</span>)-sx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">-1</span>)c+=sy-y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(y<span class=\"number\">+1</span>)-sy;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)x+=dx[i],y+=dy[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">-1</span>)c+=tx-X*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(X<span class=\"number\">+1</span>)-tx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">-1</span>)c+=ty-Y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(Y<span class=\"number\">+1</span>)-ty;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)X+=dx[j],Y+=dy[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(k==<span class=\"number\">1</span>)c=<span class=\"built_in\">abs</span>(x-X)+<span class=\"built_in\">abs</span>(y-Y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k==<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">long</span> d=<span class=\"built_in\">min</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y));</span><br><span class=\"line\">\t\t\tc+=d*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(x-X)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(y-Y)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c+=<span class=\"built_in\">max</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y))*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tans=<span class=\"built_in\">min</span>(ans,c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g---merchant-takahashi\"><strong>G - Merchant\r\nTakahashi</strong></h2>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>AtCoder 王国有 <span class=\"math inline\">\\(N\\)</span> 个城镇：城镇\r\n<span class=\"math inline\">\\(1\\)</span> 、 <span\r\nclass=\"math inline\">\\(2\\)</span> 、 <span\r\nclass=\"math inline\">\\(\\ldots\\)</span> 、 <span\r\nclass=\"math inline\">\\(N\\)</span> 。从 <span\r\nclass=\"math inline\">\\(i\\)</span> 镇到 <span\r\nclass=\"math inline\">\\(j\\)</span> 镇，必须支付 <span\r\nclass=\"math inline\">\\(C \\times |i-j|\\)</span> 日元的过路费。</p>\r\n<p>商人高桥正在考虑参加 <span class=\"math inline\">\\(M\\)</span>\r\n个或更多即将到来的市场。</p>\r\n<p><span class=\"math inline\">\\(i\\)</span> /-市场 <span\r\nclass=\"math display\">\\[(1 \\leq i \\leq M)\\]</span> 由一对整数 <span\r\nclass=\"math display\">\\[(T_i, P_i)\\]</span> 描述，其中市场在城镇 <span\r\nclass=\"math display\">\\[T_i\\]</span> 举行，如果他参加将赚取 <span\r\nclass=\"math display\">\\[P_i\\]</span> 日元。</p>\r\n<p>对于所有 <span class=\"math display\">\\[1 \\leq i &lt; M\\]</span> ，\r\n<span class=\"math display\">\\[i\\]</span> 次市场在 <span\r\nclass=\"math display\">\\[(i+1)\\]</span>\r\n次市场开始之前结束。他移动的时间可以忽略不计。</p>\r\n<p>他从 <span class=\"math display\">\\[10^{10^{100}}\\]</span>\r\n日元开始，最初在 <span class=\"math display\">\\[1\\]</span>\r\n镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。</p>\r\n<p>形式上，如果他在 <span class=\"math display\">\\[M\\]</span>\r\n个市场后获得最大资金额，那么 <span class=\"math display\">\\[10^{10^{100}}\r\n+ X\\]</span> 就是他的最终资金额。求 <span\r\nclass=\"math display\">\\[X\\]</span> 。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>显然的dp问题，如果你看不出来这是个dp问题建议你看一看<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NTk4ODQ2MjI=\">再看最著名的 NP 问题之 TSP\r\n旅行商问题 - 知乎\r\n(zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span>，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。</p>\r\n<p>详细到这一题，很简单的状态表示为 <span class=\"math display\">\\[\r\nf_i:到i城的最大profit\r\n\\]</span> 状态转移为： <span class=\"math display\">\\[\r\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}\r\n\\]</span> 对绝对值正负进行分类 <span class=\"math display\">\\[\r\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\r\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}\r\n\\]</span> 提出取最大中的常数项： <span class=\"math display\">\\[\r\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\r\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C\r\n\\]</span>\r\n接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = -LLINF; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = -LLINF,ri = -LLINF;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;c;</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,-c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t[i]&gt;&gt;p[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,t[i],<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r = <span class=\"built_in\">query</span>(t[i],n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(l+p[i]-t[i]*c,r+p[i]+t[i]*c);</span><br><span class=\"line\">\t\tf[t[i]] = mx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;t[i]&lt;&lt; &#x27; &#x27; &lt;&lt;f[t[i]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] + t[i] * c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] - t[i] * c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans =<span class=\"built_in\">max</span>(ans,f[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"abc354","date":"2024-08-14T11:46:31.000Z","_content":"\n##  [C - AtCoder Magics](https://atcoder.jp/contests/abc354/tasks/abc354_c)\n\n## 题意\n\n高桥有 $$N$$ 张纸牌，来自纸牌游戏 \"AtCoder Magics\"。其中的 $$i$$ 张卡将被称为 $$i$$ 张卡。每张卡都有两个参数：强度和成本。卡片 $$i$$ 的强度为 $$A_i$$ ，成本为 $$C_i$$ 。\n\n他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：\n\n- 选择两张牌 $$x$$ 和 $$y$$ ，即 $$A_x > A_y$$ 和 $$C_x < C_y$$ 。弃牌 $$y$$ 。\n\n可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。\n\n## 题解\n\n<!--more-->\n\n对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i].x.y>>a[i].x.x,a[i].y = i;\n\n\tsort(a+1,a+1+n);\n\t// for(int i=1;i<=n;i++) cout<<a[i].y<<endl;\n\n\tstd::vector<int> ans;\n\tint mx = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tint j = i;\n\t\tint t = 0;\n\t\tif(a[j].x.y > mx) ans.push_back(a[j].y);\n\t\tt = max(t, a[j].x.y);\n\t\t// while(j<n && a[j+1].x.x == a[j].x.x){\n\t\t// \tif(a[j].x.y > mx) {\n\t\t// \t\t// cout<<a[j].y<<endl;\n\t\t// \t\tans.push_back(a[j].y);\n\t\t// \t}\n\t\t// \tt = max(t, a[j].x.y);\n\t\t// \tj++;\n\t\t// }\n\t\tmx = max(t,mx);\n\t\t// cout<<mx<<endl;\n\t\ti = j;\n\t}\n\tsort(all(ans));\n\n\tcout<<ans.size()<<endl;\n\n\tfor(int idx: ans) cout<<idx<<' ';\n\t\tcout<<endl;\n}\n```\n\n##  [D - AtCoder Wallpaper](https://atcoder.jp/contests/abc354/tasks/abc354_d)\n\n## 题意\n\nAtCoder 的壁纸图案可以在 $xy$ (平面)上表示如下：\n\n- 该平面由以下三种线段划分：\n    - $$x = n$$ (其中 $n$ 为整数)\n    - $$y = n$$ (其中 $n$ 为偶数)\n    - $$x + y = n$$ (其中 $n$ 为偶数)\n- 每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。\n- 包含 $$(0.5, 0.5)$$ 的区域被涂成黑色。\n\n下图显示了图案的一部分。\n\n![](https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png)\n\n给你整数 $$A, B, C, D$$ 。考虑一个边平行于 $$x$$ \\- 和 $$y$$ \\- 轴的矩形，它的左下顶点在 $$(A, B)$$ ，右上顶点在 $(C, D)$ 。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。\n\n可以证明输出值将是一个整数。\n\n## 题解\n\n构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。\n\n对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。\n\n加上偏移量以确保两个数的正负号问题。\n\n```cpp\nvoid slove() {\n\tint a,b,c,d;\n\n    cin>>a>>b>>c>>d;\n\n    ll ans = 0;\n    for(int i = 0; i<2 ; i++){\n        for(int j = 0; j<4; j++){\n            ll x1 = (a - j + 3 + B)/4, x2 = (c - j + 3 + B)/4;\n            int coux = x2 - x1;\n            ll y1 = (b - i + 1 + B)/2, y2 = (d - i + 1 + B)/2;\n            int couy = y2 - y1;\n            ans += coux * couy * p[i][j];\n        }\n    }\n\n    cout<<ans<<endl;\n}\n```\n\n## [E - Remove Pairs (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_e)\n\n## 题意\n\n高桥和青木正在玩一个使用 $$N$$ 张卡片的游戏。 $￥$ 这张牌的正面写着 $$A_i$$ ，背面写着 $$B_i$$ 。最初， $$N$$ 这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：\n\n- 从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。\n\n最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？\n\n## 题解\n\n乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是$$N \\leq 18$$!\n\n于是直接暴力位dp即可\n\n但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i].x>>a[i].y;\n\n\n\tfor(int i=0;i<(1<<n);i++){\n\t\tfor(int x=0;x<n;x++)\n\t\t{\n\t\t\tfor(int y=x+1;y<n;y++){\n\t\t\t\tif((i >> x & 1) && (i >> y & 1) &&\n\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y))){\n\t\t\t\t\tf[i] |= !f[i^(1<<x)^(1<<y)];\n\t\t\t\t\t// cout<<i<<' '<<x<< ' '<<y<<' '\n\t\t\t\t\t// \t<<(i^(1<<x)^(1<<y))<<' '<<f[i^(1<<x)^(1<<y)]<<endl;\n\t\t\t\t\t// cout<<f[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(f[(1<<n)-1]) cout<<\"Takahashi\\n\";\n\telse cout<<\"Aoki\\n\";\n}\n```\n\n## [F - Useless for LIS (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_f)\n\n## 题意\n\n给你一个长度为 $$N$$ 的整数序列 $$A$$ 。\n\n对于每个 $$t = 1, 2, \\dots, N$$ ，判断 $$A_t$$ 是否包含在 $$A$$ 的最长递增子序列中。\n\n这里，当且仅当以下条件成立时， $$A_t$$ 才包含在 $A$ 的最长递增子序列中：\n\n- 设 $$L$$ 是 $$A$$ 的最长递增子序列的长度。存在一个严格递增整数序列 $$i = (i_1, i_2, \\dots, i_L)  (i_1 < i_2 < \\dots < i_ L)$$ ，其中每个元素都介于 $$1$$ 与 $$N$$ 之间，且满足以下所有条件：\n  \n    - $$A_{i_1}<A_{i_2}<\\dots<A _{i _L}$$ .\n    - $$i_k = t$$ 为某个 $$k (1 \\leq k \\leq L)$$ 。\n\n给你 $T$ 个测试用例，请逐个求解。\n\n什么是最长递增子序列？\n\n序列 $A$ 的子序列是指从 $A$ 中提取一些元素而不改变顺序所得到的序列。\n\n序列 $A$ 的最长递增子序列是 $A$ 的子序列，它以最大可能的长度严格递增。\n\n## 题解\n\n求不包含在样最长上升子序列中的数的下标集合\n\n回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值\n\n这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。\n\n可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。\n\n最后，数据范围离散化\n\n```cpp\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = 0; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = 0,ri = 0;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\n\nvoid slove() {\n\tcin>>n;\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tves.push_back(a[i]);\n\t}\n\n\tsort(all(ves));\n\tves.erase(unique(all(ves)),ves.end());\n\n\tfor(int i=0;i<ves.size();i++){\n\t\tmp[ves[i]] = i+1;\n\t}\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = query(1,mp[a[i]]-1,1,tr);\n\t\tf[i] = mx+1;\n\t\tmodify(mp[a[i]],f[i],1,tr);\n\t}\n\n\tint maxx = query(1,n,1,tr);\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=n;i;i--){\n\t\tint mx = query(mp[a[i]]+1,n,1,tr);\n\t\trf[i] = mx+1;\n\t\tmodify(mp[a[i]],rf[i],1,tr);\n\t}\n\n\t// cout<<maxx<<endl;\n\n\t// for(int i=1;i<=n;i++){\n\t// \tcout<<f[i]<< ' ' << rf[i]<<endl;\n\t// }\n\n\tvector<int> ans;\n\tfor(int i=1;i<=n;i++)\n\t\tif(f[i] + rf[i] - 1 == maxx){\n\t\t\tans.push_back(i);\n\t\t}\n\n\tcout<<ans.size()<<endl;\n\tfor(int v: ans) cout<<v<< ' ';\n\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [G - Select Strings (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_g)\n\n## 题意\n\n\n\n## 题解\n\n","source":"_posts/abc354.md","raw":"---\ntitle: abc354\ndate: 2024-08-14 19:46:31\ntags: [atcoder]\ncategories: \n\t- 比赛\n\t- 日常赛\n\t- atcoder\n---\n\n##  [C - AtCoder Magics](https://atcoder.jp/contests/abc354/tasks/abc354_c)\n\n## 题意\n\n高桥有 $$N$$ 张纸牌，来自纸牌游戏 \"AtCoder Magics\"。其中的 $$i$$ 张卡将被称为 $$i$$ 张卡。每张卡都有两个参数：强度和成本。卡片 $$i$$ 的强度为 $$A_i$$ ，成本为 $$C_i$$ 。\n\n他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：\n\n- 选择两张牌 $$x$$ 和 $$y$$ ，即 $$A_x > A_y$$ 和 $$C_x < C_y$$ 。弃牌 $$y$$ 。\n\n可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。\n\n## 题解\n\n<!--more-->\n\n对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i].x.y>>a[i].x.x,a[i].y = i;\n\n\tsort(a+1,a+1+n);\n\t// for(int i=1;i<=n;i++) cout<<a[i].y<<endl;\n\n\tstd::vector<int> ans;\n\tint mx = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tint j = i;\n\t\tint t = 0;\n\t\tif(a[j].x.y > mx) ans.push_back(a[j].y);\n\t\tt = max(t, a[j].x.y);\n\t\t// while(j<n && a[j+1].x.x == a[j].x.x){\n\t\t// \tif(a[j].x.y > mx) {\n\t\t// \t\t// cout<<a[j].y<<endl;\n\t\t// \t\tans.push_back(a[j].y);\n\t\t// \t}\n\t\t// \tt = max(t, a[j].x.y);\n\t\t// \tj++;\n\t\t// }\n\t\tmx = max(t,mx);\n\t\t// cout<<mx<<endl;\n\t\ti = j;\n\t}\n\tsort(all(ans));\n\n\tcout<<ans.size()<<endl;\n\n\tfor(int idx: ans) cout<<idx<<' ';\n\t\tcout<<endl;\n}\n```\n\n##  [D - AtCoder Wallpaper](https://atcoder.jp/contests/abc354/tasks/abc354_d)\n\n## 题意\n\nAtCoder 的壁纸图案可以在 $xy$ (平面)上表示如下：\n\n- 该平面由以下三种线段划分：\n    - $$x = n$$ (其中 $n$ 为整数)\n    - $$y = n$$ (其中 $n$ 为偶数)\n    - $$x + y = n$$ (其中 $n$ 为偶数)\n- 每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。\n- 包含 $$(0.5, 0.5)$$ 的区域被涂成黑色。\n\n下图显示了图案的一部分。\n\n![](https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png)\n\n给你整数 $$A, B, C, D$$ 。考虑一个边平行于 $$x$$ \\- 和 $$y$$ \\- 轴的矩形，它的左下顶点在 $$(A, B)$$ ，右上顶点在 $(C, D)$ 。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。\n\n可以证明输出值将是一个整数。\n\n## 题解\n\n构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。\n\n对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。\n\n加上偏移量以确保两个数的正负号问题。\n\n```cpp\nvoid slove() {\n\tint a,b,c,d;\n\n    cin>>a>>b>>c>>d;\n\n    ll ans = 0;\n    for(int i = 0; i<2 ; i++){\n        for(int j = 0; j<4; j++){\n            ll x1 = (a - j + 3 + B)/4, x2 = (c - j + 3 + B)/4;\n            int coux = x2 - x1;\n            ll y1 = (b - i + 1 + B)/2, y2 = (d - i + 1 + B)/2;\n            int couy = y2 - y1;\n            ans += coux * couy * p[i][j];\n        }\n    }\n\n    cout<<ans<<endl;\n}\n```\n\n## [E - Remove Pairs (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_e)\n\n## 题意\n\n高桥和青木正在玩一个使用 $$N$$ 张卡片的游戏。 $￥$ 这张牌的正面写着 $$A_i$$ ，背面写着 $$B_i$$ 。最初， $$N$$ 这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：\n\n- 从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。\n\n最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？\n\n## 题解\n\n乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是$$N \\leq 18$$!\n\n于是直接暴力位dp即可\n\n但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i].x>>a[i].y;\n\n\n\tfor(int i=0;i<(1<<n);i++){\n\t\tfor(int x=0;x<n;x++)\n\t\t{\n\t\t\tfor(int y=x+1;y<n;y++){\n\t\t\t\tif((i >> x & 1) && (i >> y & 1) &&\n\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y))){\n\t\t\t\t\tf[i] |= !f[i^(1<<x)^(1<<y)];\n\t\t\t\t\t// cout<<i<<' '<<x<< ' '<<y<<' '\n\t\t\t\t\t// \t<<(i^(1<<x)^(1<<y))<<' '<<f[i^(1<<x)^(1<<y)]<<endl;\n\t\t\t\t\t// cout<<f[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(f[(1<<n)-1]) cout<<\"Takahashi\\n\";\n\telse cout<<\"Aoki\\n\";\n}\n```\n\n## [F - Useless for LIS (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_f)\n\n## 题意\n\n给你一个长度为 $$N$$ 的整数序列 $$A$$ 。\n\n对于每个 $$t = 1, 2, \\dots, N$$ ，判断 $$A_t$$ 是否包含在 $$A$$ 的最长递增子序列中。\n\n这里，当且仅当以下条件成立时， $$A_t$$ 才包含在 $A$ 的最长递增子序列中：\n\n- 设 $$L$$ 是 $$A$$ 的最长递增子序列的长度。存在一个严格递增整数序列 $$i = (i_1, i_2, \\dots, i_L)  (i_1 < i_2 < \\dots < i_ L)$$ ，其中每个元素都介于 $$1$$ 与 $$N$$ 之间，且满足以下所有条件：\n  \n    - $$A_{i_1}<A_{i_2}<\\dots<A _{i _L}$$ .\n    - $$i_k = t$$ 为某个 $$k (1 \\leq k \\leq L)$$ 。\n\n给你 $T$ 个测试用例，请逐个求解。\n\n什么是最长递增子序列？\n\n序列 $A$ 的子序列是指从 $A$ 中提取一些元素而不改变顺序所得到的序列。\n\n序列 $A$ 的最长递增子序列是 $A$ 的子序列，它以最大可能的长度严格递增。\n\n## 题解\n\n求不包含在样最长上升子序列中的数的下标集合\n\n回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值\n\n这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。\n\n可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。\n\n最后，数据范围离散化\n\n```cpp\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = 0; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = 0,ri = 0;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\n\nvoid slove() {\n\tcin>>n;\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tves.push_back(a[i]);\n\t}\n\n\tsort(all(ves));\n\tves.erase(unique(all(ves)),ves.end());\n\n\tfor(int i=0;i<ves.size();i++){\n\t\tmp[ves[i]] = i+1;\n\t}\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = query(1,mp[a[i]]-1,1,tr);\n\t\tf[i] = mx+1;\n\t\tmodify(mp[a[i]],f[i],1,tr);\n\t}\n\n\tint maxx = query(1,n,1,tr);\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=n;i;i--){\n\t\tint mx = query(mp[a[i]]+1,n,1,tr);\n\t\trf[i] = mx+1;\n\t\tmodify(mp[a[i]],rf[i],1,tr);\n\t}\n\n\t// cout<<maxx<<endl;\n\n\t// for(int i=1;i<=n;i++){\n\t// \tcout<<f[i]<< ' ' << rf[i]<<endl;\n\t// }\n\n\tvector<int> ans;\n\tfor(int i=1;i<=n;i++)\n\t\tif(f[i] + rf[i] - 1 == maxx){\n\t\t\tans.push_back(i);\n\t\t}\n\n\tcout<<ans.size()<<endl;\n\tfor(int v: ans) cout<<v<< ' ';\n\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [G - Select Strings (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_g)\n\n## 题意\n\n\n\n## 题解\n\n","slug":"abc354","published":1,"updated":"2024-08-15T04:51:30.384Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjad000xlowv4h971bjd","content":"<h2 id=\"c---atcoder-magics\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfYw==\">C - AtCoder\r\nMagics<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h2 id=\"题意\">题意</h2>\r\n<p>高桥有 <span class=\"math display\">\\[N\\]</span> 张纸牌，来自纸牌游戏\r\n\"AtCoder Magics\"。其中的 <span class=\"math display\">\\[i\\]</span>\r\n张卡将被称为 <span class=\"math display\">\\[i\\]</span>\r\n张卡。每张卡都有两个参数：强度和成本。卡片 <span\r\nclass=\"math display\">\\[i\\]</span> 的强度为 <span\r\nclass=\"math display\">\\[A_i\\]</span> ，成本为 <span\r\nclass=\"math display\">\\[C_i\\]</span> 。</p>\r\n<p>他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：</p>\r\n<ul>\r\n<li>选择两张牌 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，即 <span class=\"math display\">\\[A_x\r\n&gt; A_y\\]</span> 和 <span class=\"math display\">\\[C_x &lt; C_y\\]</span>\r\n。弃牌 <span class=\"math display\">\\[y\\]</span> 。</li>\r\n</ul>\r\n<p>可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<span id=\"more\"></span>\r\n<p>对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x.y&gt;&gt;a[i].x.x,a[i].y = i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = i;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[j].x.y &gt; mx) ans.<span class=\"built_in\">push_back</span>(a[j].y);</span><br><span class=\"line\">\t\tt = <span class=\"built_in\">max</span>(t, a[j].x.y);</span><br><span class=\"line\">\t\t<span class=\"comment\">// while(j&lt;n &amp;&amp; a[j+1].x.x == a[j].x.x)&#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tif(a[j].x.y &gt; mx) &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\t// cout&lt;&lt;a[j].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\tans.push_back(a[j].y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tt = max(t, a[j].x.y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tj++;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\">\t\tmx = <span class=\"built_in\">max</span>(t,mx);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ans));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> idx: ans) cout&lt;&lt;idx&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d---atcoder-wallpaper\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZA==\">D - AtCoder\r\nWallpaper<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h2 id=\"题意-1\">题意</h2>\r\n<p>AtCoder 的壁纸图案可以在 <span class=\"math inline\">\\(xy\\)</span>\r\n(平面)上表示如下：</p>\r\n<ul>\r\n<li>该平面由以下三种线段划分：\r\n<ul>\r\n<li><span class=\"math display\">\\[x = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为整数)</li>\r\n<li><span class=\"math display\">\\[y = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为偶数)</li>\r\n<li><span class=\"math display\">\\[x + y = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为偶数)</li>\r\n</ul></li>\r\n<li>每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。</li>\r\n<li>包含 <span class=\"math display\">\\[(0.5, 0.5)\\]</span>\r\n的区域被涂成黑色。</li>\r\n</ul>\r\n<p>下图显示了图案的一部分。</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png\" /></p>\r\n<p>给你整数 <span class=\"math display\">\\[A, B, C, D\\]</span>\r\n。考虑一个边平行于 <span class=\"math display\">\\[x\\]</span> - 和 <span\r\nclass=\"math display\">\\[y\\]</span> - 轴的矩形，它的左下顶点在 <span\r\nclass=\"math display\">\\[(A, B)\\]</span> ，右上顶点在 <span\r\nclass=\"math inline\">\\((C, D)\\)</span>\r\n。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。</p>\r\n<p>可以证明输出值将是一个整数。</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。</p>\r\n<p>对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。</p>\r\n<p>加上偏移量以确保两个数的正负号问题。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a,b,c,d;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">2</span> ; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j&lt;<span class=\"number\">4</span>; j++)&#123;</span><br><span class=\"line\">            ll x1 = (a - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>, x2 = (c - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> coux = x2 - x1;</span><br><span class=\"line\">            ll y1 = (b - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>, y2 = (d - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> couy = y2 - y1;</span><br><span class=\"line\">            ans += coux * couy * p[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e---remove-pairs-atcoder.jp\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZQ==\">E - Remove\r\nPairs (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h2 id=\"题意-2\">题意</h2>\r\n<p>高桥和青木正在玩一个使用 <span class=\"math display\">\\[N\\]</span>\r\n张卡片的游戏。 <span class=\"math inline\">\\(￥\\)</span> 这张牌的正面写着\r\n<span class=\"math display\">\\[A_i\\]</span> ，背面写着 <span\r\nclass=\"math display\">\\[B_i\\]</span> 。最初， <span\r\nclass=\"math display\">\\[N\\]</span>\r\n这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：</p>\r\n<ul>\r\n<li>从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。</li>\r\n</ul>\r\n<p>最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是<span\r\nclass=\"math display\">\\[N \\leq 18\\]</span>!</p>\r\n<p>于是直接暴力位dp即可</p>\r\n<p>但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>;x&lt;n;x++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> y=x<span class=\"number\">+1</span>;y&lt;n;y++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>((i &gt;&gt; x &amp; <span class=\"number\">1</span>) &amp;&amp; (i &gt;&gt; y &amp; <span class=\"number\">1</span>) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y)))&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i] |= !f[i^(<span class=\"number\">1</span>&lt;&lt;x)^(<span class=\"number\">1</span>&lt;&lt;y)];</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;x&lt;&lt; &#x27; &#x27;&lt;&lt;y&lt;&lt;&#x27; &#x27;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// \t&lt;&lt;(i^(1&lt;&lt;x)^(1&lt;&lt;y))&lt;&lt;&#x27; &#x27;&lt;&lt;f[i^(1&lt;&lt;x)^(1&lt;&lt;y)]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(f[(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]) cout&lt;&lt;<span class=\"string\">&quot;Takahashi\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;Aoki\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f---useless-for-lis-atcoder.jp\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZg==\">F - Useless for\r\nLIS (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h2 id=\"题意-3\">题意</h2>\r\n<p>给你一个长度为 <span class=\"math display\">\\[N\\]</span> 的整数序列\r\n<span class=\"math display\">\\[A\\]</span> 。</p>\r\n<p>对于每个 <span class=\"math display\">\\[t = 1, 2, \\dots, N\\]</span>\r\n，判断 <span class=\"math display\">\\[A_t\\]</span> 是否包含在 <span\r\nclass=\"math display\">\\[A\\]</span> 的最长递增子序列中。</p>\r\n<p>这里，当且仅当以下条件成立时， <span\r\nclass=\"math display\">\\[A_t\\]</span> 才包含在 <span\r\nclass=\"math inline\">\\(A\\)</span> 的最长递增子序列中：</p>\r\n<ul>\r\n<li><p>设 <span class=\"math display\">\\[L\\]</span> 是 <span\r\nclass=\"math display\">\\[A\\]</span>\r\n的最长递增子序列的长度。存在一个严格递增整数序列 <span\r\nclass=\"math display\">\\[i = (i_1, i_2, \\dots, i_L)  (i_1 &lt; i_2 &lt;\r\n\\dots &lt; i_ L)\\]</span> ，其中每个元素都介于 <span\r\nclass=\"math display\">\\[1\\]</span> 与 <span\r\nclass=\"math display\">\\[N\\]</span> 之间，且满足以下所有条件：</p>\r\n<ul>\r\n<li><span class=\"math display\">\\[A_{i_1}&lt;A_{i_2}&lt;\\dots&lt;A _{i\r\n_L}\\]</span> .</li>\r\n<li><span class=\"math display\">\\[i_k = t\\]</span> 为某个 <span\r\nclass=\"math display\">\\[k (1 \\leq k \\leq L)\\]</span> 。</li>\r\n</ul></li>\r\n</ul>\r\n<p>给你 <span class=\"math inline\">\\(T\\)</span>\r\n个测试用例，请逐个求解。</p>\r\n<p>什么是最长递增子序列？</p>\r\n<p>序列 <span class=\"math inline\">\\(A\\)</span> 的子序列是指从 <span\r\nclass=\"math inline\">\\(A\\)</span>\r\n中提取一些元素而不改变顺序所得到的序列。</p>\r\n<p>序列 <span class=\"math inline\">\\(A\\)</span> 的最长递增子序列是 <span\r\nclass=\"math inline\">\\(A\\)</span>\r\n的子序列，它以最大可能的长度严格递增。</p>\r\n<h2 id=\"题解-3\">题解</h2>\r\n<p>求不包含在样最长上升子序列中的数的下标集合</p>\r\n<p>回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值</p>\r\n<p>这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。</p>\r\n<p>可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。</p>\r\n<p>最后，数据范围离散化</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = <span class=\"number\">0</span>; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = <span class=\"number\">0</span>,ri = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tves.<span class=\"built_in\">push_back</span>(a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ves));</span><br><span class=\"line\">\tves.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(ves)),ves.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;ves.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\tmp[ves[i]] = i<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,mp[a[i]]<span class=\"number\">-1</span>,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\tf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],f[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> maxx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(mp[a[i]]<span class=\"number\">+1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\trf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],rf[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;maxx&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;f[i]&lt;&lt; &#x27; &#x27; &lt;&lt; rf[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i] + rf[i] - <span class=\"number\">1</span> == maxx)&#123;</span><br><span class=\"line\">\t\t\tans.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ans) cout&lt;&lt;v&lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g---select-strings-atcoder.jp\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZw==\">G - Select\r\nStrings (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h2 id=\"题意-4\">题意</h2>\r\n<h2 id=\"题解-4\">题解</h2>\r\n","length":1930,"excerpt":"<h2 id=\"c---atcoder-magics\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfYw==\">C - AtCoder\r\nMagics<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h2 id=\"题意\">题意</h2>\r\n<p>高桥有 <span class=\"math display\">\\[N\\]</span> 张纸牌，来自纸牌游戏\r\n\"AtCoder Magics\"。其中的 <span class=\"math display\">\\[i\\]</span>\r\n张卡将被称为 <span class=\"math display\">\\[i\\]</span>\r\n张卡。每张卡都有两个参数：强度和成本。卡片 <span\r\nclass=\"math display\">\\[i\\]</span> 的强度为 <span\r\nclass=\"math display\">\\[A_i\\]</span> ，成本为 <span\r\nclass=\"math display\">\\[C_i\\]</span> 。</p>\r\n<p>他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：</p>\r\n<ul>\r\n<li>选择两张牌 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，即 <span class=\"math display\">\\[A_x\r\n&gt; A_y\\]</span> 和 <span class=\"math display\">\\[C_x &lt; C_y\\]</span>\r\n。弃牌 <span class=\"math display\">\\[y\\]</span> 。</li>\r\n</ul>\r\n<p>可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。</p>\r\n<h2 id=\"题解\">题解</h2>","more":"<p>对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x.y&gt;&gt;a[i].x.x,a[i].y = i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = i;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[j].x.y &gt; mx) ans.<span class=\"built_in\">push_back</span>(a[j].y);</span><br><span class=\"line\">\t\tt = <span class=\"built_in\">max</span>(t, a[j].x.y);</span><br><span class=\"line\">\t\t<span class=\"comment\">// while(j&lt;n &amp;&amp; a[j+1].x.x == a[j].x.x)&#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tif(a[j].x.y &gt; mx) &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\t// cout&lt;&lt;a[j].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\tans.push_back(a[j].y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tt = max(t, a[j].x.y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tj++;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\">\t\tmx = <span class=\"built_in\">max</span>(t,mx);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ans));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> idx: ans) cout&lt;&lt;idx&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d---atcoder-wallpaper\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZA==\">D - AtCoder\r\nWallpaper<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h2 id=\"题意-1\">题意</h2>\r\n<p>AtCoder 的壁纸图案可以在 <span class=\"math inline\">\\(xy\\)</span>\r\n(平面)上表示如下：</p>\r\n<ul>\r\n<li>该平面由以下三种线段划分：\r\n<ul>\r\n<li><span class=\"math display\">\\[x = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为整数)</li>\r\n<li><span class=\"math display\">\\[y = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为偶数)</li>\r\n<li><span class=\"math display\">\\[x + y = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为偶数)</li>\r\n</ul></li>\r\n<li>每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。</li>\r\n<li>包含 <span class=\"math display\">\\[(0.5, 0.5)\\]</span>\r\n的区域被涂成黑色。</li>\r\n</ul>\r\n<p>下图显示了图案的一部分。</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png\" /></p>\r\n<p>给你整数 <span class=\"math display\">\\[A, B, C, D\\]</span>\r\n。考虑一个边平行于 <span class=\"math display\">\\[x\\]</span> - 和 <span\r\nclass=\"math display\">\\[y\\]</span> - 轴的矩形，它的左下顶点在 <span\r\nclass=\"math display\">\\[(A, B)\\]</span> ，右上顶点在 <span\r\nclass=\"math inline\">\\((C, D)\\)</span>\r\n。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。</p>\r\n<p>可以证明输出值将是一个整数。</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。</p>\r\n<p>对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。</p>\r\n<p>加上偏移量以确保两个数的正负号问题。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a,b,c,d;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">2</span> ; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j&lt;<span class=\"number\">4</span>; j++)&#123;</span><br><span class=\"line\">            ll x1 = (a - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>, x2 = (c - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> coux = x2 - x1;</span><br><span class=\"line\">            ll y1 = (b - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>, y2 = (d - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> couy = y2 - y1;</span><br><span class=\"line\">            ans += coux * couy * p[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e---remove-pairs-atcoder.jp\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZQ==\">E - Remove\r\nPairs (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h2 id=\"题意-2\">题意</h2>\r\n<p>高桥和青木正在玩一个使用 <span class=\"math display\">\\[N\\]</span>\r\n张卡片的游戏。 <span class=\"math inline\">\\(￥\\)</span> 这张牌的正面写着\r\n<span class=\"math display\">\\[A_i\\]</span> ，背面写着 <span\r\nclass=\"math display\">\\[B_i\\]</span> 。最初， <span\r\nclass=\"math display\">\\[N\\]</span>\r\n这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：</p>\r\n<ul>\r\n<li>从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。</li>\r\n</ul>\r\n<p>最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是<span\r\nclass=\"math display\">\\[N \\leq 18\\]</span>!</p>\r\n<p>于是直接暴力位dp即可</p>\r\n<p>但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>;x&lt;n;x++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> y=x<span class=\"number\">+1</span>;y&lt;n;y++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>((i &gt;&gt; x &amp; <span class=\"number\">1</span>) &amp;&amp; (i &gt;&gt; y &amp; <span class=\"number\">1</span>) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y)))&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i] |= !f[i^(<span class=\"number\">1</span>&lt;&lt;x)^(<span class=\"number\">1</span>&lt;&lt;y)];</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;x&lt;&lt; &#x27; &#x27;&lt;&lt;y&lt;&lt;&#x27; &#x27;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// \t&lt;&lt;(i^(1&lt;&lt;x)^(1&lt;&lt;y))&lt;&lt;&#x27; &#x27;&lt;&lt;f[i^(1&lt;&lt;x)^(1&lt;&lt;y)]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(f[(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]) cout&lt;&lt;<span class=\"string\">&quot;Takahashi\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;Aoki\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f---useless-for-lis-atcoder.jp\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZg==\">F - Useless for\r\nLIS (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h2 id=\"题意-3\">题意</h2>\r\n<p>给你一个长度为 <span class=\"math display\">\\[N\\]</span> 的整数序列\r\n<span class=\"math display\">\\[A\\]</span> 。</p>\r\n<p>对于每个 <span class=\"math display\">\\[t = 1, 2, \\dots, N\\]</span>\r\n，判断 <span class=\"math display\">\\[A_t\\]</span> 是否包含在 <span\r\nclass=\"math display\">\\[A\\]</span> 的最长递增子序列中。</p>\r\n<p>这里，当且仅当以下条件成立时， <span\r\nclass=\"math display\">\\[A_t\\]</span> 才包含在 <span\r\nclass=\"math inline\">\\(A\\)</span> 的最长递增子序列中：</p>\r\n<ul>\r\n<li><p>设 <span class=\"math display\">\\[L\\]</span> 是 <span\r\nclass=\"math display\">\\[A\\]</span>\r\n的最长递增子序列的长度。存在一个严格递增整数序列 <span\r\nclass=\"math display\">\\[i = (i_1, i_2, \\dots, i_L)  (i_1 &lt; i_2 &lt;\r\n\\dots &lt; i_ L)\\]</span> ，其中每个元素都介于 <span\r\nclass=\"math display\">\\[1\\]</span> 与 <span\r\nclass=\"math display\">\\[N\\]</span> 之间，且满足以下所有条件：</p>\r\n<ul>\r\n<li><span class=\"math display\">\\[A_{i_1}&lt;A_{i_2}&lt;\\dots&lt;A _{i\r\n_L}\\]</span> .</li>\r\n<li><span class=\"math display\">\\[i_k = t\\]</span> 为某个 <span\r\nclass=\"math display\">\\[k (1 \\leq k \\leq L)\\]</span> 。</li>\r\n</ul></li>\r\n</ul>\r\n<p>给你 <span class=\"math inline\">\\(T\\)</span>\r\n个测试用例，请逐个求解。</p>\r\n<p>什么是最长递增子序列？</p>\r\n<p>序列 <span class=\"math inline\">\\(A\\)</span> 的子序列是指从 <span\r\nclass=\"math inline\">\\(A\\)</span>\r\n中提取一些元素而不改变顺序所得到的序列。</p>\r\n<p>序列 <span class=\"math inline\">\\(A\\)</span> 的最长递增子序列是 <span\r\nclass=\"math inline\">\\(A\\)</span>\r\n的子序列，它以最大可能的长度严格递增。</p>\r\n<h2 id=\"题解-3\">题解</h2>\r\n<p>求不包含在样最长上升子序列中的数的下标集合</p>\r\n<p>回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值</p>\r\n<p>这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。</p>\r\n<p>可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。</p>\r\n<p>最后，数据范围离散化</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = <span class=\"number\">0</span>; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = <span class=\"number\">0</span>,ri = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tves.<span class=\"built_in\">push_back</span>(a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ves));</span><br><span class=\"line\">\tves.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(ves)),ves.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;ves.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\tmp[ves[i]] = i<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,mp[a[i]]<span class=\"number\">-1</span>,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\tf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],f[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> maxx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(mp[a[i]]<span class=\"number\">+1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\trf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],rf[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;maxx&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;f[i]&lt;&lt; &#x27; &#x27; &lt;&lt; rf[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i] + rf[i] - <span class=\"number\">1</span> == maxx)&#123;</span><br><span class=\"line\">\t\t\tans.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ans) cout&lt;&lt;v&lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g---select-strings-atcoder.jp\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZw==\">G - Select\r\nStrings (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2>\r\n<h2 id=\"题意-4\">题意</h2>\r\n<h2 id=\"题解-4\">题解</h2>"},{"title":"cf-edu165D","date":"2024-08-14T11:45:21.000Z","_content":"## 题意：\n\n爱丽丝和鲍勃正在商店里玩游戏。商店里有 $$n$$ 件商品；每件商品有两个参数： $$a_i$$ （爱丽丝的物品价格）和 $$b_i$$ （鲍勃的物品价格）。\n\n爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：\n\n- 如果爱丽丝购买的物品少于 $$k$$ ，则鲍勃可以免费拿走所有物品；\n- 否则，他会免费拿走爱丽丝购买的$$k$$ 个物品（由鲍勃选择是哪个 $$k$$ 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 $$b_i$$。\n\n爱丽丝的利润等于 $$\\sum\\limits_{i \\in S} b_i - \\sum\\limits_{j \\in T} a_j$$ ，其中$$S$$ 是鲍勃从爱丽丝处购买的物品集， $$T$$ 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。\n\n爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。\n\n[Problem - D - Codeforces](https://codeforces.com/contest/1969/problem/D)\n\n<!--more-->\n\n## 题解：\n\n注意到，Bob在选择免费的时候显然是直接免费最大的$$b_i$$，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的$$b_i - a_i$$尽可能的大。\n\n先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n>count($$a_i<b_i$$)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。\n\n对于一个物品$$i$$，我们可以证明在$$a_i < b_i$$时该物品是必选的吗？如果我们选了这个物品：\n\n1. 并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它\n\n2. 被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。\n\n综上，无法确定在$$a_i < b_i$$时该物品是必选，对这个不等式的反也成立的物品也成立。\n\n注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。\n\n```cpp\nvoid slove() {\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) cin >> b[i];\n    vector<int> id(n);\n    for(int i=0;i<n;i++) id[i] = i;\n    sort(id.begin(), id.end(), [&](int x, int y){\n        if (b[x] != b[y]) return b[x] > b[y];\n        return a[x] < a[y];\n    });\n\n    // for(int i=0;i<n;i++) cout<<a[id[i]]<<' '<<b[id[i]]<<endl;\n    // cout<<nline;\n\n    ll s1 = 0, s2 = 0, ans = 0;\n    set<int> s;\n    for(int i = 0; i < k; i++){\n        s.insert(a[id[i]]);\n        s1 += a[id[i]];\n    }\n    for(int i = k; i < n; i++){\n        if (b[id[i]] > a[id[i]]){\n            s2 += b[id[i]] - a[id[i]];\n        }\n    }\n    for(int i = k; i < n; i++){\n        ans = max(ans, s2 - s1);\n        if (b[id[i]] > a[id[i]]){\n            s2 -= b[id[i]] - a[id[i]];\n        }\n        s.insert({a[id[i]], id[i]});\n        s1 += a[id[i]];\n        s1 -= *(--s.end());\n        s.erase(--s.end());\n    }\n    cout << ans << '\\n';\n}\n```\n","source":"_posts/cf-edu165D.md","raw":"---\ntitle: cf-edu165D\ndate: 2024-08-14 19:45:21\ntags: [算法, 博弈论, 不等式]\ncategories: \n\t- 算法\n\t- 数学\n\t- 博弈论\n---\n## 题意：\n\n爱丽丝和鲍勃正在商店里玩游戏。商店里有 $$n$$ 件商品；每件商品有两个参数： $$a_i$$ （爱丽丝的物品价格）和 $$b_i$$ （鲍勃的物品价格）。\n\n爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：\n\n- 如果爱丽丝购买的物品少于 $$k$$ ，则鲍勃可以免费拿走所有物品；\n- 否则，他会免费拿走爱丽丝购买的$$k$$ 个物品（由鲍勃选择是哪个 $$k$$ 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 $$b_i$$。\n\n爱丽丝的利润等于 $$\\sum\\limits_{i \\in S} b_i - \\sum\\limits_{j \\in T} a_j$$ ，其中$$S$$ 是鲍勃从爱丽丝处购买的物品集， $$T$$ 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。\n\n爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。\n\n[Problem - D - Codeforces](https://codeforces.com/contest/1969/problem/D)\n\n<!--more-->\n\n## 题解：\n\n注意到，Bob在选择免费的时候显然是直接免费最大的$$b_i$$，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的$$b_i - a_i$$尽可能的大。\n\n先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n>count($$a_i<b_i$$)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。\n\n对于一个物品$$i$$，我们可以证明在$$a_i < b_i$$时该物品是必选的吗？如果我们选了这个物品：\n\n1. 并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它\n\n2. 被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。\n\n综上，无法确定在$$a_i < b_i$$时该物品是必选，对这个不等式的反也成立的物品也成立。\n\n注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。\n\n```cpp\nvoid slove() {\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) cin >> b[i];\n    vector<int> id(n);\n    for(int i=0;i<n;i++) id[i] = i;\n    sort(id.begin(), id.end(), [&](int x, int y){\n        if (b[x] != b[y]) return b[x] > b[y];\n        return a[x] < a[y];\n    });\n\n    // for(int i=0;i<n;i++) cout<<a[id[i]]<<' '<<b[id[i]]<<endl;\n    // cout<<nline;\n\n    ll s1 = 0, s2 = 0, ans = 0;\n    set<int> s;\n    for(int i = 0; i < k; i++){\n        s.insert(a[id[i]]);\n        s1 += a[id[i]];\n    }\n    for(int i = k; i < n; i++){\n        if (b[id[i]] > a[id[i]]){\n            s2 += b[id[i]] - a[id[i]];\n        }\n    }\n    for(int i = k; i < n; i++){\n        ans = max(ans, s2 - s1);\n        if (b[id[i]] > a[id[i]]){\n            s2 -= b[id[i]] - a[id[i]];\n        }\n        s.insert({a[id[i]], id[i]});\n        s1 += a[id[i]];\n        s1 -= *(--s.end());\n        s.erase(--s.end());\n    }\n    cout << ans << '\\n';\n}\n```\n","slug":"cf-edu165D","published":1,"updated":"2024-08-14T13:38:37.760Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjae0010lowv13g73imn","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>爱丽丝和鲍勃正在商店里玩游戏。商店里有 <span\r\nclass=\"math display\">\\[n\\]</span> 件商品；每件商品有两个参数： <span\r\nclass=\"math display\">\\[a_i\\]</span> （爱丽丝的物品价格）和 <span\r\nclass=\"math display\">\\[b_i\\]</span> （鲍勃的物品价格）。</p>\r\n<p>爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob\r\n会执行以下操作：</p>\r\n<ul>\r\n<li>如果爱丽丝购买的物品少于 <span class=\"math display\">\\[k\\]</span>\r\n，则鲍勃可以免费拿走所有物品；</li>\r\n<li>否则，他会免费拿走爱丽丝购买的<span\r\nclass=\"math display\">\\[k\\]</span> 个物品（由鲍勃选择是哪个 <span\r\nclass=\"math display\">\\[k\\]</span>\r\n个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 <span\r\nclass=\"math inline\">\\(i\\)</span> -个物品支付 <span\r\nclass=\"math display\">\\[b_i\\]</span>。</li>\r\n</ul>\r\n<p>爱丽丝的利润等于 <span class=\"math display\">\\[\\sum\\limits_{i \\in S}\r\nb_i - \\sum\\limits_{j \\in T} a_j\\]</span> ，其中<span\r\nclass=\"math display\">\\[S\\]</span> 是鲍勃从爱丽丝处购买的物品集， <span\r\nclass=\"math display\">\\[T\\]</span>\r\n是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。</p>\r\n<p>爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9E\">Problem - D -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>注意到，Bob在选择免费的时候显然是直接免费最大的<span\r\nclass=\"math display\">\\[b_i\\]</span>，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的<span\r\nclass=\"math display\">\\[b_i - a_i\\]</span>尽可能的大。</p>\r\n<p>先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n&gt;count(<span\r\nclass=\"math display\">\\[a_i&lt;b_i\\]</span>)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。</p>\r\n<p>对于一个物品<span\r\nclass=\"math display\">\\[i\\]</span>，我们可以证明在<span\r\nclass=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选的吗？如果我们选了这个物品：</p>\r\n<ol type=\"1\">\r\n<li><p>并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它</p></li>\r\n<li><p>被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。</p></li>\r\n</ol>\r\n<p>综上，无法确定在<span class=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选，对这个不等式的反也成立的物品也成立。</p>\r\n<p>注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span>, <span class=\"title\">b</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">id</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) id[i] = i;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(id.<span class=\"built_in\">begin</span>(), id.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[x] != b[y]) <span class=\"keyword\">return</span> b[x] &gt; b[y];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[x] &lt; a[y];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=0;i&lt;n;i++) cout&lt;&lt;a[id[i]]&lt;&lt;&#x27; &#x27;&lt;&lt;b[id[i]]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ll s1 = <span class=\"number\">0</span>, s2 = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++)&#123;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(a[id[i]]);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 += b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, s2 - s1);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 -= b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(&#123;a[id[i]], id[i]&#125;);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">        s1 -= *(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        s.<span class=\"built_in\">erase</span>(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":959,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>爱丽丝和鲍勃正在商店里玩游戏。商店里有 <span\r\nclass=\"math display\">\\[n\\]</span> 件商品；每件商品有两个参数： <span\r\nclass=\"math display\">\\[a_i\\]</span> （爱丽丝的物品价格）和 <span\r\nclass=\"math display\">\\[b_i\\]</span> （鲍勃的物品价格）。</p>\r\n<p>爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob\r\n会执行以下操作：</p>\r\n<ul>\r\n<li>如果爱丽丝购买的物品少于 <span class=\"math display\">\\[k\\]</span>\r\n，则鲍勃可以免费拿走所有物品；</li>\r\n<li>否则，他会免费拿走爱丽丝购买的<span\r\nclass=\"math display\">\\[k\\]</span> 个物品（由鲍勃选择是哪个 <span\r\nclass=\"math display\">\\[k\\]</span>\r\n个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 <span\r\nclass=\"math inline\">\\(i\\)</span> -个物品支付 <span\r\nclass=\"math display\">\\[b_i\\]</span>。</li>\r\n</ul>\r\n<p>爱丽丝的利润等于 <span class=\"math display\">\\[\\sum\\limits_{i \\in S}\r\nb_i - \\sum\\limits_{j \\in T} a_j\\]</span> ，其中<span\r\nclass=\"math display\">\\[S\\]</span> 是鲍勃从爱丽丝处购买的物品集， <span\r\nclass=\"math display\">\\[T\\]</span>\r\n是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。</p>\r\n<p>爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9E\">Problem - D -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>注意到，Bob在选择免费的时候显然是直接免费最大的<span\r\nclass=\"math display\">\\[b_i\\]</span>，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的<span\r\nclass=\"math display\">\\[b_i - a_i\\]</span>尽可能的大。</p>\r\n<p>先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n&gt;count(<span\r\nclass=\"math display\">\\[a_i&lt;b_i\\]</span>)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。</p>\r\n<p>对于一个物品<span\r\nclass=\"math display\">\\[i\\]</span>，我们可以证明在<span\r\nclass=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选的吗？如果我们选了这个物品：</p>\r\n<ol type=\"1\">\r\n<li><p>并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它</p></li>\r\n<li><p>被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。</p></li>\r\n</ol>\r\n<p>综上，无法确定在<span class=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选，对这个不等式的反也成立的物品也成立。</p>\r\n<p>注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span>, <span class=\"title\">b</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">id</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) id[i] = i;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(id.<span class=\"built_in\">begin</span>(), id.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[x] != b[y]) <span class=\"keyword\">return</span> b[x] &gt; b[y];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[x] &lt; a[y];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=0;i&lt;n;i++) cout&lt;&lt;a[id[i]]&lt;&lt;&#x27; &#x27;&lt;&lt;b[id[i]]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ll s1 = <span class=\"number\">0</span>, s2 = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++)&#123;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(a[id[i]]);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 += b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, s2 - s1);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 -= b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(&#123;a[id[i]], id[i]&#125;);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">        s1 -= *(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        s.<span class=\"built_in\">erase</span>(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"cf-edu165C","date":"2024-08-14T11:46:31.000Z","_content":"## 题意：\n\n有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。\n\n[Problem - C - Codeforces](https://codeforces.com/contest/1969/problem/C)\n\n<!--more-->\n\n## 题解：\n\n教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。\n\n但为什么不能采用别的解法呢？\n\n考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1\n\n> 2,1,1,2,5\n\n显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。\n\n注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。\n\n于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。\n\n考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。\n\n> [x,a,b,c,y] -> [x,x,x,x,y]->[x,x,y,y,y] 其中含有无意义的两步操作\n\n再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。\n\n下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。\n\n> 对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于$$a_k|k>ii \\&\\& k <= i$$，因此所需操作数为i-ii-1\n\n最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）\n\n```cpp\nvoid slove() {\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=m;j++)f[i][j] = LLINF;\n\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) pre[i] = a[i] + pre[i-1];\n    f[0][0] = 0;\n    for(int i=1;i<=n;i++) {\n        for(int ii=i-1;ii>=0 && i-ii-1 <= m;ii--) {\n            int t = i-ii-1;\n            for(int j=t;j<=m;j++) {\n                for(int k=ii+1;k<=i;k++) {\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    // cout<<i<<' '<<j<<' '<< f[i][j]<<nline;\n                }\n            }\n        }\n    }\n\n    int ans = LLINF;\n    for(int i=0;i<=m;i++) ans = min(ans,f[n][i]);\n    cout<<ans<<endl;\n}\n```\n","source":"_posts/cf-edu165C.md","raw":"---\ntitle: cf-edu165C\ndate: 2024-08-14 19:46:31\ntags: [算法, 思维题, 贪心,状态转移]\ncategories: \n\t- 算法\n\t- 思维题\n\t- 贪心\n---\n## 题意：\n\n有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。\n\n[Problem - C - Codeforces](https://codeforces.com/contest/1969/problem/C)\n\n<!--more-->\n\n## 题解：\n\n教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。\n\n但为什么不能采用别的解法呢？\n\n考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1\n\n> 2,1,1,2,5\n\n显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。\n\n注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。\n\n于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。\n\n考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。\n\n> [x,a,b,c,y] -> [x,x,x,x,y]->[x,x,y,y,y] 其中含有无意义的两步操作\n\n再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。\n\n下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。\n\n> 对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于$$a_k|k>ii \\&\\& k <= i$$，因此所需操作数为i-ii-1\n\n最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）\n\n```cpp\nvoid slove() {\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=m;j++)f[i][j] = LLINF;\n\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) pre[i] = a[i] + pre[i-1];\n    f[0][0] = 0;\n    for(int i=1;i<=n;i++) {\n        for(int ii=i-1;ii>=0 && i-ii-1 <= m;ii--) {\n            int t = i-ii-1;\n            for(int j=t;j<=m;j++) {\n                for(int k=ii+1;k<=i;k++) {\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    // cout<<i<<' '<<j<<' '<< f[i][j]<<nline;\n                }\n            }\n        }\n    }\n\n    int ans = LLINF;\n    for(int i=0;i<=m;i++) ans = min(ans,f[n][i]);\n    cout<<ans<<endl;\n}\n```\n","slug":"cf-edu165C","published":1,"updated":"2024-08-15T04:57:58.784Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjae0011lowv7rpo9tbw","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9D\">Problem - C -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:)\r\n假的！），很容易想到用dp做法可以解。</p>\r\n<p>但为什么不能采用别的解法呢？</p>\r\n<p>考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1</p>\r\n<blockquote>\r\n<p>2,1,1,2,5</p>\r\n</blockquote>\r\n<p>显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。</p>\r\n<p>注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗?\r\n考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。</p>\r\n<p>于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。</p>\r\n<p>考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。</p>\r\n<blockquote>\r\n<p>[x,a,b,c,y] -&gt; [x,x,x,x,y]-&gt;[x,x,y,y,y]\r\n其中含有无意义的两步操作</p>\r\n</blockquote>\r\n<p>再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。</p>\r\n<p>下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。</p>\r\n<blockquote>\r\n<p>对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于<span\r\nclass=\"math display\">\\[a_k|k&gt;ii \\&amp;\\&amp; k &lt;=\r\ni\\]</span>，因此所需操作数为i-ii-1</p>\r\n</blockquote>\r\n<p>最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;j++)f[i][j] = LLINF;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = a[i] + pre[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=i<span class=\"number\">-1</span>;ii&gt;=<span class=\"number\">0</span> &amp;&amp; i-ii<span class=\"number\">-1</span> &lt;= m;ii--) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = i-ii<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=t;j&lt;=m;j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=ii<span class=\"number\">+1</span>;k&lt;=i;k++) &#123;</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt; f[i][j]&lt;&lt;nline;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans = LLINF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++) ans = <span class=\"built_in\">min</span>(ans,f[n][i]);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":875,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9D\">Problem - C -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:)\r\n假的！），很容易想到用dp做法可以解。</p>\r\n<p>但为什么不能采用别的解法呢？</p>\r\n<p>考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1</p>\r\n<blockquote>\r\n<p>2,1,1,2,5</p>\r\n</blockquote>\r\n<p>显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。</p>\r\n<p>注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗?\r\n考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。</p>\r\n<p>于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。</p>\r\n<p>考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。</p>\r\n<blockquote>\r\n<p>[x,a,b,c,y] -&gt; [x,x,x,x,y]-&gt;[x,x,y,y,y]\r\n其中含有无意义的两步操作</p>\r\n</blockquote>\r\n<p>再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。</p>\r\n<p>下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。</p>\r\n<blockquote>\r\n<p>对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于<span\r\nclass=\"math display\">\\[a_k|k&gt;ii \\&amp;\\&amp; k &lt;=\r\ni\\]</span>，因此所需操作数为i-ii-1</p>\r\n</blockquote>\r\n<p>最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;j++)f[i][j] = LLINF;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = a[i] + pre[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=i<span class=\"number\">-1</span>;ii&gt;=<span class=\"number\">0</span> &amp;&amp; i-ii<span class=\"number\">-1</span> &lt;= m;ii--) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = i-ii<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=t;j&lt;=m;j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=ii<span class=\"number\">+1</span>;k&lt;=i;k++) &#123;</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt; f[i][j]&lt;&lt;nline;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans = LLINF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++) ans = <span class=\"built_in\">min</span>(ans,f[n][i]);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"luogu蓝桥5_19","date":"2024-08-14T11:46:31.000Z","_content":"\n## B. 停车场\n\n[P10509 停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10509?contestId=174155)\n\n<!--more-->\n\n### 题意\n\n你有一片空地。这片空地可以视作一个一个 𝑛×𝑛 的正方形。空地外一圈为墙壁，你无法拆除它们。\n\n现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 1×1的正方形，且正方形的每条边与墙壁平行或者垂直。\n\n每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。\n\n下图为 𝑛=4 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png)\n\n请问 𝑛=2023 下最多能安排多少个停车位？\n\n### 题解\n\n这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸\n\n[云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/17rwjfcz)\n\n洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。\n\n这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png)\n\n直接构造可得\n\n答案为(2022+2021*(674*2-1)+673*2*2+3)\n\n## D. 方差\n\n[P10511 方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10511?contestId=174155)\n\n### 题意\n\n小 S 认为数学很简单，于是小 R 想要考考她。\n\n小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 `l r b`，表示 $a_l,a_{l+1},\\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。\n\n现在，小 R 有 $q$ 个问题。形如 `l r`，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。\n\n由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\\cdot s^2\\bmod 998244353$。可以证明 $(r-l+1)^2\\cdot s^2$ 一定是整数。\n\n作为小 S 的好朋友，你能帮帮她吗？\n\n### 题解\n\n推导一下公式发现结果是\n\n$$(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 - sum^2$$\n\n预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。\n\n但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题\n\n```cpp\nvoid slove() {\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++) {\n\t\tcin>>seg[i].l>>seg[i].r>>seg[i].v;\n\t\tseg[i].l %= MOD;\n\t\tseg[i].r %= MOD;\n\t\tseg[i].v %= MOD;\n\t}\n\n\t// sort(seg+1,seg+1+m);\n\n\tfor(int i=1;i<=m;i++){\n\t\tsegs[i] = segs[i-1] + ((((seg[i].r - seg[i].l  + 1) %MOD + MOD) %MOD) * seg[i].v) % MOD;\n\t\tsegs[i] %= MOD;\n\t\tsegs2[i] = segs2[i-1] + (((((seg[i].r - seg[i].l + 1) %MOD + MOD)%MOD) * seg[i].v %MOD)\n\t\t\t\t* seg[i].v) % MOD;\n\t\tsegs2[i] %= MOD;\n\t}\n\n\t// for(int i=1;i<=m;i++) cout<<segs[i]<<' '<<segs2[i]<<endl;\n\n\twhile(k--){\n\t\tint l,r;cin>>l>>r;\n\t\tint li = upper_bound(seg+1,seg+1+m,(Segment){l,0,0}) - seg - 1;\n\t\tint ri = upper_bound(seg+1,seg+1+m,(Segment){r,0,0}) - seg - 1;\n\t\t// cout<<\"###\"<<li<< ' ' << ri<<endl;\n\n\t\tif(li== ri)\n    \t{\n      \t\tcout<<0<<\"\\n\";\n      \t\tcontinue;\n    \t}\n\n\t\tint msum = ((segs[ri-1] - segs[li])%MOD + MOD) % MOD;\n\t\tmsum %= MOD;\n\t\tint rsum = (((r - seg[ri].l + 1) % MOD + MOD) % MOD * seg[ri].v) % MOD;\n\t\trsum %= MOD;\n\t\tint lsum = ((seg[li].r - l + 1 + MOD) % MOD * seg[li].v) % MOD;\n\t\tlsum %= MOD;\n\t\tint msum2 = ((segs2[ri-1] - segs2[li])%MOD + MOD) %MOD;\n\t\tmsum %=MOD;\n\t\tint rsum2 = ((((r - seg[ri].l + 1)%MOD + MOD) % MOD * seg[ri].v) % MOD\n\t\t\t\t* seg[ri].v) % MOD;\n\t\trsum2%=MOD;\n\t\tint lsum2 = ((((seg[li].r - l + 1) %MOD + MOD) % MOD * seg[li].v) % MOD\n\t\t\t\t*seg[li].v) %MOD;\n\t\tlsum2 %=MOD;\n\t\t// cout<<\"---\"<<lsum << ' '<<msum<< ' '<<rsum<<endl;\n\t\tint sum = lsum + msum % MOD + rsum %MOD;\n\t\tsum %=MOD;\n\t\tint sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;\n\t\tsum2%=MOD;\n\t\t// cout<<\"####\"<<sum<< ' '<< sum2<<endl;\n\t\tcout<<(((((r-l+1) %MOD + MOD) % MOD * sum2) % MOD -\n\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD<<endl;\n\t}\n}\n```\n\n## E. 序列合并\n\nhttps://www.luogu.com.cn/problem/P10512?contestId=174155\n\n## 题意\n\n给定一个长度为 𝑛的非负整数序列 {$$𝑎_𝑛$$}，你可以进行 𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。\n\n形式化地，一次操作中，你选择一个下标 𝑖*i*（1≤𝑖<𝑛1≤*i*<*n*），然后把原序列变成$${a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}$$。\n\n求 𝑘次操作后所有数按位与的最大值。\n\n## 题解\n\n首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大\n\n注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。\n\n要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。\n\n我觉得比取模题简单\n\n```CPP\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint ans = 0;\n\tfor(int i=29;~i;i--){\n\t\tint t = ans | (1<<i);\n\n\t\tint x = 0,cnt = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx |= a[i];\n\t\t\tif((x & t) == t) cnt++,x=0;\n\t\t}\n\t\tif(cnt >= n - k) {\n\t\t\tans = t;\n\t\t\t// cout<<cnt<<endl;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F. 括号\n\nhttps://www.luogu.com.cn/problem/P10513?contestId=174155\n\n### 题意\n\n圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 ```(``` 和 ```)``` 构成。\n\n她会对其做 $m$ 次操作，操作有两种类型：\n\n1. ```1 l r```，她会翻转 $l$ 到 $r$ 的括号，即 ```(``` 变 ```)```，```)``` 变 ```(```。\n1. ```2 l r```，她想知道区间 $\\left[ l,r\\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。\n\n\n圆认为以下的括号序列是合法的：\n\n1. 空序列是一个合法序列。\n\n1. 如果 ```A``` 是一个合法序列，则 ```(A)```  也是一个合法序列。\n\n1. 如果 ```A``` 和 ```B``` 都是合法序列，则 ```AB``` 也是一个合法序列。\n\n圆认为，序列 $a$ 的子序列是满足 $1\\le i_1<i_2<···<i_k \\le n$ 的序列 $[a_{i_1},a_{i_2},...a_{i_k}]$。\n\n由于操作太多了，她算不过来，请你帮帮她吧。\n\n### 题解\n\n洛谷真的要吓死我了，第六题线段树\n\n对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即\n\n$$ans=左边括号序列+右边括号序列+横跨中间的括号序列$$\n\n如何维护交换这一操作呢？\n\n我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。\n\n```cpp\nstruct node {\n\tint l,r,ans;\n\tnode(int x=0,int y=0,int z=0){l=x,r=y,ans=z;}\n};\nstruct tree{int tag;node t1,t2;}t[N<<2];\nchar s[N];\n\nnode merge(node x,node y)\n{\n    int cnt=min(x.l,y.r);\n    return {x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt};\n}\ninline void pushup(int p){t[p].t1=merge(t[ls].t1,t[rs].t1);t[p].t2=merge(t[ls].t2,t[rs].t2);}\ninline void pushson(int p){swap(t[p].t1,t[p].t2);t[p].tag^=1;}\ninline void pushdown(int p){if(!t[p].tag) return;pushson(ls),pushson(rs);t[p].tag=0;}\ninline void build(int p,int l,int r)\n{\n    if(l==r) return t[p].t2.r=t[p].t1.l=(s[l]=='('),t[p].t2.l=t[p].t1.r=(s[l]==')'),void();\n    build(ls,l,mid);build(rs,mid+1,r);pushup(p);\n}\ninline void modify(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return pushson(p);pushdown(p);\n    if(mid>=s) modify(ls,l,mid,s,e);if(mid<e) modify(rs,mid+1,r,s,e);\n    pushup(p);\n}\ninline node query(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return t[p].t1;pushdown(p);\n    if(e<=mid) return query(ls,l,mid,s,e);\n    if(s>mid) return query(rs,mid+1,r,s,e);\n    return merge(query(ls,l,mid,s,e),query(rs,mid+1,r,s,e));\n}\n\nvoid slove() {\n\tcin>>n;\n\tcin>>s+1;\n\tbuild(1,1,n);\n\tcin>>m;\n\twhile(m--){\n\t\tint op,l,r;cin>>op>>l>>r;\n\t\tif(op == 1) {\n\t\t\tmodify(1,1,n,l,r);\n\t\t}else {\n\t\t\tcout<<query(1,1,n,l,r).ans<<endl;\n\t\t}\n\t}\n}\n```\n\n## G.考试\n\nhttps://www.luogu.com.cn/problem/P10514?contestId=174155\n\n### 题意\n\n有 $n$ 名同学去参加考试，考试有 $m$ 道题。\n\n每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。\n\n考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。\n\n### 题解\n\n数学题。。。 懒得打公式了，如下\n\n![image-20240527221944431](https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png)\n\n预处理阶乘，快速幂分母时间复杂度为log(m)+n\n\n处理分子时间复杂度为mlog(n)\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tfac[0] = infac[0] = 1;\n\tfor(int i=1;i<N;i++){\n\t\tfac[i] = fac[i-1] *i % MOD;\n\t\tinfac[i] = infac[i-1] * qmi(i,MOD-2,MOD) % MOD;\n\t\t// cout<<fac[i]<<' ' <<infac[i]<<endl;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>m>>k;\n\n\tint mx = 0;\n\tfor(int i=1;i<=m;i++) cin>>a[i], mx= max(mx,a[i]);\n\n\tif(mx + k > n) {cout<<0<<endl;return ;}\n\n\tint inv = qmi(qmi(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD-2,MOD);\n\n\tint factor = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;\n\t}\n\n\tcout<<factor*inv % MOD<<endl;\n}\n```\n\n## H. 转圈、按钮P4861\n\nhttps://www.luogu.com.cn/problem/P10515?contestId=174155\n\n### 题意\n\n小 $\\delta$ 喜欢转圈圈。\n\n他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \\times m$，他现在站在第一个格子上。\n\n接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。\n\n求最终被小 $\\delta$ 踩到过的格子的数量。由于小 $\\delta$ 有很多圈圈，所以他会问你很多次。\n\n### 题解\n\n这题和P4861撞了，所以我干脆贴这题了\n\n根据欧拉定理$$a^{\\phi(p)}= 1 (modp)$$\n\n因此$$\\phi(p)$$一定是答案的倍数，我们只需要枚举它的因子即可\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\nint gcd(int x,int y){return y? gcd(y,x%y): x;}\n\nvoid init(){}\n\nint get_phi(int x){\n\tint res = x;\n\tif(!(x&1)) res >>= 1;\n\n\tfor(int i=3;i*i<=x; i+= 2){\n\t\tif(x % i == 0){\n\t\t\tres -= res /i;\n\t\t\twhile(x % i == 0) x/=i;\n\t\t}\n\t}\n\tif(x > 1) res -= res / x;\n\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n>>m;\n\tif(gcd(n,m)!=1)puts(\"Let's go Blue Jays!\");//无解\n    else{\n        int p=get_phi(n);//得到phi\n        int mm=p;\n        int tot = 0;\n        for(int i=2;(i*i)<=mm;i++){\n            if(mm%i)continue;\n            pri[++tot]=i;\n            while(mm%i==0){\n                mm/=i;\n                tim[tot]++;\n            }\n        }\n        if(mm!=1){\n            pri[++tot]=mm;\n            tim[tot]=1;\n        }\n\n        int ss=1,qq=p;\n        while(ss<=tot){\n            for(int i=1;i<=tim[ss];i++){\n                if(qmi(m,qq/pri[ss],n)==1)qq/=pri[ss];\n                else break;\n            }\n            ss++;\n        }\n        cout<<qq<<endl;\n    }\n}\n```\n","source":"_posts/luogu蓝桥5_19.md","raw":"---\ntitle: luogu蓝桥5_19\ndate: 2024-08-14 19:46:31\ntags: [luogu]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- 蓝桥模拟\n---\n\n## B. 停车场\n\n[P10509 停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10509?contestId=174155)\n\n<!--more-->\n\n### 题意\n\n你有一片空地。这片空地可以视作一个一个 𝑛×𝑛 的正方形。空地外一圈为墙壁，你无法拆除它们。\n\n现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 1×1的正方形，且正方形的每条边与墙壁平行或者垂直。\n\n每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。\n\n下图为 𝑛=4 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png)\n\n请问 𝑛=2023 下最多能安排多少个停车位？\n\n### 题解\n\n这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸\n\n[云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/17rwjfcz)\n\n洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。\n\n这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png)\n\n直接构造可得\n\n答案为(2022+2021*(674*2-1)+673*2*2+3)\n\n## D. 方差\n\n[P10511 方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10511?contestId=174155)\n\n### 题意\n\n小 S 认为数学很简单，于是小 R 想要考考她。\n\n小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 `l r b`，表示 $a_l,a_{l+1},\\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。\n\n现在，小 R 有 $q$ 个问题。形如 `l r`，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。\n\n由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\\cdot s^2\\bmod 998244353$。可以证明 $(r-l+1)^2\\cdot s^2$ 一定是整数。\n\n作为小 S 的好朋友，你能帮帮她吗？\n\n### 题解\n\n推导一下公式发现结果是\n\n$$(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 - sum^2$$\n\n预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。\n\n但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题\n\n```cpp\nvoid slove() {\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++) {\n\t\tcin>>seg[i].l>>seg[i].r>>seg[i].v;\n\t\tseg[i].l %= MOD;\n\t\tseg[i].r %= MOD;\n\t\tseg[i].v %= MOD;\n\t}\n\n\t// sort(seg+1,seg+1+m);\n\n\tfor(int i=1;i<=m;i++){\n\t\tsegs[i] = segs[i-1] + ((((seg[i].r - seg[i].l  + 1) %MOD + MOD) %MOD) * seg[i].v) % MOD;\n\t\tsegs[i] %= MOD;\n\t\tsegs2[i] = segs2[i-1] + (((((seg[i].r - seg[i].l + 1) %MOD + MOD)%MOD) * seg[i].v %MOD)\n\t\t\t\t* seg[i].v) % MOD;\n\t\tsegs2[i] %= MOD;\n\t}\n\n\t// for(int i=1;i<=m;i++) cout<<segs[i]<<' '<<segs2[i]<<endl;\n\n\twhile(k--){\n\t\tint l,r;cin>>l>>r;\n\t\tint li = upper_bound(seg+1,seg+1+m,(Segment){l,0,0}) - seg - 1;\n\t\tint ri = upper_bound(seg+1,seg+1+m,(Segment){r,0,0}) - seg - 1;\n\t\t// cout<<\"###\"<<li<< ' ' << ri<<endl;\n\n\t\tif(li== ri)\n    \t{\n      \t\tcout<<0<<\"\\n\";\n      \t\tcontinue;\n    \t}\n\n\t\tint msum = ((segs[ri-1] - segs[li])%MOD + MOD) % MOD;\n\t\tmsum %= MOD;\n\t\tint rsum = (((r - seg[ri].l + 1) % MOD + MOD) % MOD * seg[ri].v) % MOD;\n\t\trsum %= MOD;\n\t\tint lsum = ((seg[li].r - l + 1 + MOD) % MOD * seg[li].v) % MOD;\n\t\tlsum %= MOD;\n\t\tint msum2 = ((segs2[ri-1] - segs2[li])%MOD + MOD) %MOD;\n\t\tmsum %=MOD;\n\t\tint rsum2 = ((((r - seg[ri].l + 1)%MOD + MOD) % MOD * seg[ri].v) % MOD\n\t\t\t\t* seg[ri].v) % MOD;\n\t\trsum2%=MOD;\n\t\tint lsum2 = ((((seg[li].r - l + 1) %MOD + MOD) % MOD * seg[li].v) % MOD\n\t\t\t\t*seg[li].v) %MOD;\n\t\tlsum2 %=MOD;\n\t\t// cout<<\"---\"<<lsum << ' '<<msum<< ' '<<rsum<<endl;\n\t\tint sum = lsum + msum % MOD + rsum %MOD;\n\t\tsum %=MOD;\n\t\tint sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;\n\t\tsum2%=MOD;\n\t\t// cout<<\"####\"<<sum<< ' '<< sum2<<endl;\n\t\tcout<<(((((r-l+1) %MOD + MOD) % MOD * sum2) % MOD -\n\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD<<endl;\n\t}\n}\n```\n\n## E. 序列合并\n\nhttps://www.luogu.com.cn/problem/P10512?contestId=174155\n\n## 题意\n\n给定一个长度为 𝑛的非负整数序列 {$$𝑎_𝑛$$}，你可以进行 𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。\n\n形式化地，一次操作中，你选择一个下标 𝑖*i*（1≤𝑖<𝑛1≤*i*<*n*），然后把原序列变成$${a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}$$。\n\n求 𝑘次操作后所有数按位与的最大值。\n\n## 题解\n\n首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大\n\n注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。\n\n要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。\n\n我觉得比取模题简单\n\n```CPP\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint ans = 0;\n\tfor(int i=29;~i;i--){\n\t\tint t = ans | (1<<i);\n\n\t\tint x = 0,cnt = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx |= a[i];\n\t\t\tif((x & t) == t) cnt++,x=0;\n\t\t}\n\t\tif(cnt >= n - k) {\n\t\t\tans = t;\n\t\t\t// cout<<cnt<<endl;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F. 括号\n\nhttps://www.luogu.com.cn/problem/P10513?contestId=174155\n\n### 题意\n\n圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 ```(``` 和 ```)``` 构成。\n\n她会对其做 $m$ 次操作，操作有两种类型：\n\n1. ```1 l r```，她会翻转 $l$ 到 $r$ 的括号，即 ```(``` 变 ```)```，```)``` 变 ```(```。\n1. ```2 l r```，她想知道区间 $\\left[ l,r\\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。\n\n\n圆认为以下的括号序列是合法的：\n\n1. 空序列是一个合法序列。\n\n1. 如果 ```A``` 是一个合法序列，则 ```(A)```  也是一个合法序列。\n\n1. 如果 ```A``` 和 ```B``` 都是合法序列，则 ```AB``` 也是一个合法序列。\n\n圆认为，序列 $a$ 的子序列是满足 $1\\le i_1<i_2<···<i_k \\le n$ 的序列 $[a_{i_1},a_{i_2},...a_{i_k}]$。\n\n由于操作太多了，她算不过来，请你帮帮她吧。\n\n### 题解\n\n洛谷真的要吓死我了，第六题线段树\n\n对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即\n\n$$ans=左边括号序列+右边括号序列+横跨中间的括号序列$$\n\n如何维护交换这一操作呢？\n\n我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。\n\n```cpp\nstruct node {\n\tint l,r,ans;\n\tnode(int x=0,int y=0,int z=0){l=x,r=y,ans=z;}\n};\nstruct tree{int tag;node t1,t2;}t[N<<2];\nchar s[N];\n\nnode merge(node x,node y)\n{\n    int cnt=min(x.l,y.r);\n    return {x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt};\n}\ninline void pushup(int p){t[p].t1=merge(t[ls].t1,t[rs].t1);t[p].t2=merge(t[ls].t2,t[rs].t2);}\ninline void pushson(int p){swap(t[p].t1,t[p].t2);t[p].tag^=1;}\ninline void pushdown(int p){if(!t[p].tag) return;pushson(ls),pushson(rs);t[p].tag=0;}\ninline void build(int p,int l,int r)\n{\n    if(l==r) return t[p].t2.r=t[p].t1.l=(s[l]=='('),t[p].t2.l=t[p].t1.r=(s[l]==')'),void();\n    build(ls,l,mid);build(rs,mid+1,r);pushup(p);\n}\ninline void modify(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return pushson(p);pushdown(p);\n    if(mid>=s) modify(ls,l,mid,s,e);if(mid<e) modify(rs,mid+1,r,s,e);\n    pushup(p);\n}\ninline node query(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return t[p].t1;pushdown(p);\n    if(e<=mid) return query(ls,l,mid,s,e);\n    if(s>mid) return query(rs,mid+1,r,s,e);\n    return merge(query(ls,l,mid,s,e),query(rs,mid+1,r,s,e));\n}\n\nvoid slove() {\n\tcin>>n;\n\tcin>>s+1;\n\tbuild(1,1,n);\n\tcin>>m;\n\twhile(m--){\n\t\tint op,l,r;cin>>op>>l>>r;\n\t\tif(op == 1) {\n\t\t\tmodify(1,1,n,l,r);\n\t\t}else {\n\t\t\tcout<<query(1,1,n,l,r).ans<<endl;\n\t\t}\n\t}\n}\n```\n\n## G.考试\n\nhttps://www.luogu.com.cn/problem/P10514?contestId=174155\n\n### 题意\n\n有 $n$ 名同学去参加考试，考试有 $m$ 道题。\n\n每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。\n\n考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。\n\n### 题解\n\n数学题。。。 懒得打公式了，如下\n\n![image-20240527221944431](https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png)\n\n预处理阶乘，快速幂分母时间复杂度为log(m)+n\n\n处理分子时间复杂度为mlog(n)\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tfac[0] = infac[0] = 1;\n\tfor(int i=1;i<N;i++){\n\t\tfac[i] = fac[i-1] *i % MOD;\n\t\tinfac[i] = infac[i-1] * qmi(i,MOD-2,MOD) % MOD;\n\t\t// cout<<fac[i]<<' ' <<infac[i]<<endl;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>m>>k;\n\n\tint mx = 0;\n\tfor(int i=1;i<=m;i++) cin>>a[i], mx= max(mx,a[i]);\n\n\tif(mx + k > n) {cout<<0<<endl;return ;}\n\n\tint inv = qmi(qmi(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD-2,MOD);\n\n\tint factor = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;\n\t}\n\n\tcout<<factor*inv % MOD<<endl;\n}\n```\n\n## H. 转圈、按钮P4861\n\nhttps://www.luogu.com.cn/problem/P10515?contestId=174155\n\n### 题意\n\n小 $\\delta$ 喜欢转圈圈。\n\n他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \\times m$，他现在站在第一个格子上。\n\n接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。\n\n求最终被小 $\\delta$ 踩到过的格子的数量。由于小 $\\delta$ 有很多圈圈，所以他会问你很多次。\n\n### 题解\n\n这题和P4861撞了，所以我干脆贴这题了\n\n根据欧拉定理$$a^{\\phi(p)}= 1 (modp)$$\n\n因此$$\\phi(p)$$一定是答案的倍数，我们只需要枚举它的因子即可\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\nint gcd(int x,int y){return y? gcd(y,x%y): x;}\n\nvoid init(){}\n\nint get_phi(int x){\n\tint res = x;\n\tif(!(x&1)) res >>= 1;\n\n\tfor(int i=3;i*i<=x; i+= 2){\n\t\tif(x % i == 0){\n\t\t\tres -= res /i;\n\t\t\twhile(x % i == 0) x/=i;\n\t\t}\n\t}\n\tif(x > 1) res -= res / x;\n\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n>>m;\n\tif(gcd(n,m)!=1)puts(\"Let's go Blue Jays!\");//无解\n    else{\n        int p=get_phi(n);//得到phi\n        int mm=p;\n        int tot = 0;\n        for(int i=2;(i*i)<=mm;i++){\n            if(mm%i)continue;\n            pri[++tot]=i;\n            while(mm%i==0){\n                mm/=i;\n                tim[tot]++;\n            }\n        }\n        if(mm!=1){\n            pri[++tot]=mm;\n            tim[tot]=1;\n        }\n\n        int ss=1,qq=p;\n        while(ss<=tot){\n            for(int i=1;i<=tim[ss];i++){\n                if(qmi(m,qq/pri[ss],n)==1)qq/=pri[ss];\n                else break;\n            }\n            ss++;\n        }\n        cout<<qq<<endl;\n    }\n}\n```\n","slug":"luogu蓝桥5_19","published":1,"updated":"2024-08-15T04:51:55.211Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjae0014lowvcex2egsd","content":"<h2 id=\"b.-停车场\">B. 停车场</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTA5P2NvbnRlc3RJZD0xNzQxNTU=\">P10509\r\n停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>你有一片空地。这片空地可以视作一个一个 𝑛×𝑛\r\n的正方形。空地外一圈为墙壁，你无法拆除它们。</p>\r\n<p>现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是\r\n1×1的正方形，且正方形的每条边与墙壁平行或者垂直。</p>\r\n<p>每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。</p>\r\n<p>下图为 𝑛=4\r\n时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。</p>\r\n<figure>\r\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>请问 𝑛=2023 下最多能安排多少个停车位？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Bhc3RlLzE3cndqZmN6\">云剪贴板 - 洛谷 |\r\n计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。</p>\r\n<p>这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种</p>\r\n<figure>\r\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>直接构造可得</p>\r\n<p>答案为(2022+2021<em>(674</em>2-1)+673<em>2</em>2+3)</p>\r\n<h2 id=\"d.-方差\">D. 方差</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTExP2NvbnRlc3RJZD0xNzQxNTU=\">P10511\r\n方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>小 S 认为数学很简单，于是小 R 想要考考她。</p>\r\n<p>小 R 给了小 S 一个序列 <span\r\nclass=\"math inline\">\\(a\\)</span>，这个序列由 <span\r\nclass=\"math inline\">\\(m\\)</span> 段构成，第 <span\r\nclass=\"math inline\">\\(i\\)</span> 段被表示为 <code>l r b</code>，表示\r\n<span class=\"math inline\">\\(a_l,a_{l+1},\\ldots,a_r\\)</span> 为 <span\r\nclass=\"math inline\">\\(b\\)</span>，保证给出的任意两个区间不相交。</p>\r\n<p>现在，小 R 有 <span class=\"math inline\">\\(q\\)</span> 个问题。形如\r\n<code>l r</code>，想让你查询区间 <span\r\nclass=\"math inline\">\\([l,r]\\)</span> 的方差 <span\r\nclass=\"math inline\">\\(s^2\\)</span>（需要注意：<span\r\nclass=\"math inline\">\\(l\\)</span> 可能等于 <span\r\nclass=\"math inline\">\\(r\\)</span>，此时该段方差为 <span\r\nclass=\"math inline\">\\(0\\)</span>）。</p>\r\n<p>由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出\r\n<span class=\"math inline\">\\((r-l+1)^2\\cdot s^2\\bmod\r\n998244353\\)</span>。可以证明 <span class=\"math inline\">\\((r-l+1)^2\\cdot\r\ns^2\\)</span> 一定是整数。</p>\r\n<p>作为小 S 的好朋友，你能帮帮她吗？</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>推导一下公式发现结果是</p>\r\n<p><span class=\"math display\">\\[(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 -\r\nsum^2\\]</span></p>\r\n<p>预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。</p>\r\n<p>但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;seg[i].l&gt;&gt;seg[i].r&gt;&gt;seg[i].v;</span><br><span class=\"line\">\t\tseg[i].l %= MOD;</span><br><span class=\"line\">\t\tseg[i].r %= MOD;</span><br><span class=\"line\">\t\tseg[i].v %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sort(seg+1,seg+1+m);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tsegs[i] = segs[i<span class=\"number\">-1</span>] + ((((seg[i].r - seg[i].l  + <span class=\"number\">1</span>) %MOD + MOD) %MOD) * seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs[i] %= MOD;</span><br><span class=\"line\">\t\tsegs2[i] = segs2[i<span class=\"number\">-1</span>] + (((((seg[i].r - seg[i].l + <span class=\"number\">1</span>) %MOD + MOD)%MOD) * seg[i].v %MOD)</span><br><span class=\"line\">\t\t\t\t* seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs2[i] %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=m;i++) cout&lt;&lt;segs[i]&lt;&lt;&#x27; &#x27;&lt;&lt;segs2[i]&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(k--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> li = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;l,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ri = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;r,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;li&lt;&lt; &#x27; &#x27; &lt;&lt; ri&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(li== ri)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">      \t\tcout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum = ((segs[ri<span class=\"number\">-1</span>] - segs[li])%MOD + MOD) % MOD;</span><br><span class=\"line\">\t\tmsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum = (((r - seg[ri].l + <span class=\"number\">1</span>) % MOD + MOD) % MOD * seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum = ((seg[li].r - l + <span class=\"number\">1</span> + MOD) % MOD * seg[li].v) % MOD;</span><br><span class=\"line\">\t\tlsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum2 = ((segs2[ri<span class=\"number\">-1</span>] - segs2[li])%MOD + MOD) %MOD;</span><br><span class=\"line\">\t\tmsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum2 = ((((r - seg[ri].l + <span class=\"number\">1</span>)%MOD + MOD) % MOD * seg[ri].v) % MOD</span><br><span class=\"line\">\t\t\t\t* seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum2 = ((((seg[li].r - l + <span class=\"number\">1</span>) %MOD + MOD) % MOD * seg[li].v) % MOD</span><br><span class=\"line\">\t\t\t\t*seg[li].v) %MOD;</span><br><span class=\"line\">\t\tlsum2 %=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;lsum &lt;&lt; &#x27; &#x27;&lt;&lt;msum&lt;&lt; &#x27; &#x27;&lt;&lt;rsum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum = lsum + msum % MOD + rsum %MOD;</span><br><span class=\"line\">\t\tsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;</span><br><span class=\"line\">\t\tsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;####&quot;&lt;&lt;sum&lt;&lt; &#x27; &#x27;&lt;&lt; sum2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tcout&lt;&lt;(((((r-l<span class=\"number\">+1</span>) %MOD + MOD) % MOD * sum2) % MOD -</span><br><span class=\"line\">\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e.-序列合并\">E. 序列合并</h2>\r\n<p>https://www.luogu.com.cn/problem/P10512?contestId=174155</p>\r\n<h2 id=\"题意-2\">题意</h2>\r\n<p>给定一个长度为 𝑛的非负整数序列 {<span\r\nclass=\"math display\">\\[𝑎_𝑛\\]</span>}，你可以进行\r\n𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。</p>\r\n<p>形式化地，一次操作中，你选择一个下标\r\n𝑖<em>i</em>（1≤𝑖&lt;𝑛1≤<em>i</em>&lt;<em>n</em>），然后把原序列变成<span\r\nclass=\"math display\">\\[{a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}\\]</span>。</p>\r\n<p>求 𝑘次操作后所有数按位与的最大值。</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大</p>\r\n<p>注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。</p>\r\n<p>要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。</p>\r\n<p>我觉得比取模题简单</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">29</span>;~i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = ans | (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tx |= a[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((x &amp; t) == t) cnt++,x=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &gt;= n - k) &#123;</span><br><span class=\"line\">\t\t\tans = t;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f.-括号\">F. 括号</h2>\r\n<p>https://www.luogu.com.cn/problem/P10513?contestId=174155</p>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p>圆给了你一个长度为 <span class=\"math inline\">\\(n\\)</span> 的字符串\r\n<span class=\"math inline\">\\(S\\)</span>，<span\r\nclass=\"math inline\">\\(S\\)</span> 仅由 <code>(</code> 和 <code>)</code>\r\n构成。</p>\r\n<p>她会对其做 <span class=\"math inline\">\\(m\\)</span>\r\n次操作，操作有两种类型：</p>\r\n<ol type=\"1\">\r\n<li><code>1 l r</code>，她会翻转 <span class=\"math inline\">\\(l\\)</span>\r\n到 <span class=\"math inline\">\\(r\\)</span> 的括号，即 <code>(</code> 变\r\n<code>)</code>，<code>)</code> 变 <code>(</code>。</li>\r\n<li><code>2 l r</code>，她想知道区间 <span class=\"math inline\">\\(\\left[\r\nl,r\\right]\\)</span> 中最长合法括号子序列的长度除以 <span\r\nclass=\"math inline\">\\(2\\)</span> 的答案。</li>\r\n</ol>\r\n<p>圆认为以下的括号序列是合法的：</p>\r\n<ol type=\"1\">\r\n<li><p>空序列是一个合法序列。</p></li>\r\n<li><p>如果 <code>A</code> 是一个合法序列，则 <code>(A)</code>\r\n也是一个合法序列。</p></li>\r\n<li><p>如果 <code>A</code> 和 <code>B</code> 都是合法序列，则\r\n<code>AB</code> 也是一个合法序列。</p></li>\r\n</ol>\r\n<p>圆认为，序列 <span class=\"math inline\">\\(a\\)</span> 的子序列是满足\r\n<span class=\"math inline\">\\(1\\le i_1&lt;i_2&lt;···&lt;i_k \\le n\\)</span>\r\n的序列 <span\r\nclass=\"math inline\">\\([a_{i_1},a_{i_2},...a_{i_k}]\\)</span>。</p>\r\n<p>由于操作太多了，她算不过来，请你帮帮她吧。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>洛谷真的要吓死我了，第六题线段树</p>\r\n<p>对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即</p>\r\n<p><span\r\nclass=\"math display\">\\[ans=左边括号序列+右边括号序列+横跨中间的括号序列\\]</span></p>\r\n<p>如何维护交换这一操作呢？</p>\r\n<p>我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,ans;</span><br><span class=\"line\">\t<span class=\"built_in\">node</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>,<span class=\"type\">int</span> y=<span class=\"number\">0</span>,<span class=\"type\">int</span> z=<span class=\"number\">0</span>)&#123;l=x,r=y,ans=z;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tree</span>&#123;<span class=\"type\">int</span> tag;node t1,t2;&#125;t[N&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">merge</span><span class=\"params\">(node x,node y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt=<span class=\"built_in\">min</span>(x.l,y.r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;t[p].t1=<span class=\"built_in\">merge</span>(t[ls].t1,t[rs].t1);t[p].t2=<span class=\"built_in\">merge</span>(t[ls].t2,t[rs].t2);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushson</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"built_in\">swap</span>(t[p].t1,t[p].t2);t[p].tag^=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"keyword\">if</span>(!t[p].tag) <span class=\"keyword\">return</span>;<span class=\"built_in\">pushson</span>(ls),<span class=\"built_in\">pushson</span>(rs);t[p].tag=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r) <span class=\"keyword\">return</span> t[p].t<span class=\"number\">2.</span>r=t[p].t<span class=\"number\">1.l</span>=(s[l]==<span class=\"string\">&#x27;(&#x27;</span>),t[p].t<span class=\"number\">2.l</span>=t[p].t<span class=\"number\">1.</span>r=(s[l]==<span class=\"string\">&#x27;)&#x27;</span>),<span class=\"built_in\">void</span>();</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(ls,l,mid);<span class=\"built_in\">build</span>(rs,mid<span class=\"number\">+1</span>,r);<span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> <span class=\"built_in\">pushson</span>(p);<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&gt;=s) <span class=\"built_in\">modify</span>(ls,l,mid,s,e);<span class=\"keyword\">if</span>(mid&lt;e) <span class=\"built_in\">modify</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> t[p].t1;<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e&lt;=mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(ls,l,mid,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s&gt;mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">merge</span>(<span class=\"built_in\">query</span>(ls,l,mid,s,e),<span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tcin&gt;&gt;s<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op,l,r;cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r).ans&lt;&lt;endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g.考试\">G.考试</h2>\r\n<p>https://www.luogu.com.cn/problem/P10514?contestId=174155</p>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>有 <span class=\"math inline\">\\(n\\)</span> 名同学去参加考试，考试有\r\n<span class=\"math inline\">\\(m\\)</span> 道题。</p>\r\n<p>每个学生的实力是相同的，但是每道题的难度可能不同。第 <span\r\nclass=\"math inline\">\\(i\\)</span> 道题会有随机的 <span\r\nclass=\"math inline\">\\(a_i\\)</span> 名同学做错。</p>\r\n<p>考试结束后，随机选出 <span class=\"math inline\">\\(k\\)</span>\r\n名同学，求出这些同学全部做对的概率。答案对 <span\r\nclass=\"math inline\">\\(998244353\\)</span> 取模。</p>\r\n<h3 id=\"题解-4\">题解</h3>\r\n<p>数学题。。。 懒得打公式了，如下</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png\"\r\nalt=\"image-20240527221944431\" />\r\n<figcaption aria-hidden=\"true\">image-20240527221944431</figcaption>\r\n</figure>\r\n<p>预处理阶乘，快速幂分母时间复杂度为log(m)+n</p>\r\n<p>处理分子时间复杂度为mlog(n)</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tfac[<span class=\"number\">0</span>] = infac[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">\t\tfac[i] = fac[i<span class=\"number\">-1</span>] *i % MOD;</span><br><span class=\"line\">\t\tinfac[i] = infac[i<span class=\"number\">-1</span>] * <span class=\"built_in\">qmi</span>(i,MOD<span class=\"number\">-2</span>,MOD) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;fac[i]&lt;&lt;&#x27; &#x27; &lt;&lt;infac[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i], mx= <span class=\"built_in\">max</span>(mx,a[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(mx + k &gt; n) &#123;cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;<span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> inv = <span class=\"built_in\">qmi</span>(<span class=\"built_in\">qmi</span>(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD<span class=\"number\">-2</span>,MOD);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> factor = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;factor*inv % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"h.-转圈按钮p4861\">H. 转圈、按钮P4861</h2>\r\n<p>https://www.luogu.com.cn/problem/P10515?contestId=174155</p>\r\n<h3 id=\"题意-5\">题意</h3>\r\n<p>小 <span class=\"math inline\">\\(\\delta\\)</span> 喜欢转圈圈。</p>\r\n<p>他有一个圈，被均匀分成了 <span class=\"math inline\">\\(n\\)</span>\r\n个格子，神奇的是，<span class=\"math inline\">\\(n\\)</span> 是一个质数。第\r\n<span class=\"math inline\">\\(i\\)</span> 个格子上写着一个数 <span\r\nclass=\"math inline\">\\(i \\times m\\)</span>，他现在站在第一个格子上。</p>\r\n<p>接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。</p>\r\n<p>求最终被小 <span class=\"math inline\">\\(\\delta\\)</span>\r\n踩到过的格子的数量。由于小 <span class=\"math inline\">\\(\\delta\\)</span>\r\n有很多圈圈，所以他会问你很多次。</p>\r\n<h3 id=\"题解-5\">题解</h3>\r\n<p>这题和P4861撞了，所以我干脆贴这题了</p>\r\n<p>根据欧拉定理<span class=\"math display\">\\[a^{\\phi(p)}= 1\r\n(modp)\\]</span></p>\r\n<p>因此<span\r\nclass=\"math display\">\\[\\phi(p)\\]</span>一定是答案的倍数，我们只需要枚举它的因子即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;<span class=\"keyword\">return</span> y? <span class=\"built_in\">gcd</span>(y,x%y): x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_phi</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> res = x;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(x&amp;<span class=\"number\">1</span>)) res &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">3</span>;i*i&lt;=x; i+= <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tres -= res /i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(x % i == <span class=\"number\">0</span>) x/=i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt; <span class=\"number\">1</span>) res -= res / x;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">gcd</span>(n,m)!=<span class=\"number\">1</span>)<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Let&#x27;s go Blue Jays!&quot;</span>);<span class=\"comment\">//无解</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p=<span class=\"built_in\">get_phi</span>(n);<span class=\"comment\">//得到phi</span></span><br><span class=\"line\">        <span class=\"type\">int</span> mm=p;</span><br><span class=\"line\">        <span class=\"type\">int</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;(i*i)&lt;=mm;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mm%i)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            pri[++tot]=i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(mm%i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                mm/=i;</span><br><span class=\"line\">                tim[tot]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mm!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            pri[++tot]=mm;</span><br><span class=\"line\">            tim[tot]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ss=<span class=\"number\">1</span>,qq=p;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ss&lt;=tot)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tim[ss];i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">qmi</span>(m,qq/pri[ss],n)==<span class=\"number\">1</span>)qq/=pri[ss];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ss++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;qq&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":2696,"excerpt":"<h2 id=\"b.-停车场\">B. 停车场</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTA5P2NvbnRlc3RJZD0xNzQxNTU=\">P10509\r\n停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h3 id=\"题意\">题意</h3>\r\n<p>你有一片空地。这片空地可以视作一个一个 𝑛×𝑛\r\n的正方形。空地外一圈为墙壁，你无法拆除它们。</p>\r\n<p>现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是\r\n1×1的正方形，且正方形的每条边与墙壁平行或者垂直。</p>\r\n<p>每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。</p>\r\n<p>下图为 𝑛=4\r\n时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。</p>\r\n<figure>\r\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>请问 𝑛=2023 下最多能安排多少个停车位？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Bhc3RlLzE3cndqZmN6\">云剪贴板 - 洛谷 |\r\n计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。</p>\r\n<p>这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种</p>\r\n<figure>\r\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>直接构造可得</p>\r\n<p>答案为(2022+2021<em>(674</em>2-1)+673<em>2</em>2+3)</p>\r\n<h2 id=\"d.-方差\">D. 方差</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTExP2NvbnRlc3RJZD0xNzQxNTU=\">P10511\r\n方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>小 S 认为数学很简单，于是小 R 想要考考她。</p>\r\n<p>小 R 给了小 S 一个序列 <span\r\nclass=\"math inline\">\\(a\\)</span>，这个序列由 <span\r\nclass=\"math inline\">\\(m\\)</span> 段构成，第 <span\r\nclass=\"math inline\">\\(i\\)</span> 段被表示为 <code>l r b</code>，表示\r\n<span class=\"math inline\">\\(a_l,a_{l+1},\\ldots,a_r\\)</span> 为 <span\r\nclass=\"math inline\">\\(b\\)</span>，保证给出的任意两个区间不相交。</p>\r\n<p>现在，小 R 有 <span class=\"math inline\">\\(q\\)</span> 个问题。形如\r\n<code>l r</code>，想让你查询区间 <span\r\nclass=\"math inline\">\\([l,r]\\)</span> 的方差 <span\r\nclass=\"math inline\">\\(s^2\\)</span>（需要注意：<span\r\nclass=\"math inline\">\\(l\\)</span> 可能等于 <span\r\nclass=\"math inline\">\\(r\\)</span>，此时该段方差为 <span\r\nclass=\"math inline\">\\(0\\)</span>）。</p>\r\n<p>由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出\r\n<span class=\"math inline\">\\((r-l+1)^2\\cdot s^2\\bmod\r\n998244353\\)</span>。可以证明 <span class=\"math inline\">\\((r-l+1)^2\\cdot\r\ns^2\\)</span> 一定是整数。</p>\r\n<p>作为小 S 的好朋友，你能帮帮她吗？</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>推导一下公式发现结果是</p>\r\n<p><span class=\"math display\">\\[(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 -\r\nsum^2\\]</span></p>\r\n<p>预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。</p>\r\n<p>但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;seg[i].l&gt;&gt;seg[i].r&gt;&gt;seg[i].v;</span><br><span class=\"line\">\t\tseg[i].l %= MOD;</span><br><span class=\"line\">\t\tseg[i].r %= MOD;</span><br><span class=\"line\">\t\tseg[i].v %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sort(seg+1,seg+1+m);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tsegs[i] = segs[i<span class=\"number\">-1</span>] + ((((seg[i].r - seg[i].l  + <span class=\"number\">1</span>) %MOD + MOD) %MOD) * seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs[i] %= MOD;</span><br><span class=\"line\">\t\tsegs2[i] = segs2[i<span class=\"number\">-1</span>] + (((((seg[i].r - seg[i].l + <span class=\"number\">1</span>) %MOD + MOD)%MOD) * seg[i].v %MOD)</span><br><span class=\"line\">\t\t\t\t* seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs2[i] %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=m;i++) cout&lt;&lt;segs[i]&lt;&lt;&#x27; &#x27;&lt;&lt;segs2[i]&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(k--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> li = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;l,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ri = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;r,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;li&lt;&lt; &#x27; &#x27; &lt;&lt; ri&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(li== ri)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">      \t\tcout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum = ((segs[ri<span class=\"number\">-1</span>] - segs[li])%MOD + MOD) % MOD;</span><br><span class=\"line\">\t\tmsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum = (((r - seg[ri].l + <span class=\"number\">1</span>) % MOD + MOD) % MOD * seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum = ((seg[li].r - l + <span class=\"number\">1</span> + MOD) % MOD * seg[li].v) % MOD;</span><br><span class=\"line\">\t\tlsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum2 = ((segs2[ri<span class=\"number\">-1</span>] - segs2[li])%MOD + MOD) %MOD;</span><br><span class=\"line\">\t\tmsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum2 = ((((r - seg[ri].l + <span class=\"number\">1</span>)%MOD + MOD) % MOD * seg[ri].v) % MOD</span><br><span class=\"line\">\t\t\t\t* seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum2 = ((((seg[li].r - l + <span class=\"number\">1</span>) %MOD + MOD) % MOD * seg[li].v) % MOD</span><br><span class=\"line\">\t\t\t\t*seg[li].v) %MOD;</span><br><span class=\"line\">\t\tlsum2 %=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;lsum &lt;&lt; &#x27; &#x27;&lt;&lt;msum&lt;&lt; &#x27; &#x27;&lt;&lt;rsum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum = lsum + msum % MOD + rsum %MOD;</span><br><span class=\"line\">\t\tsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;</span><br><span class=\"line\">\t\tsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;####&quot;&lt;&lt;sum&lt;&lt; &#x27; &#x27;&lt;&lt; sum2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tcout&lt;&lt;(((((r-l<span class=\"number\">+1</span>) %MOD + MOD) % MOD * sum2) % MOD -</span><br><span class=\"line\">\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e.-序列合并\">E. 序列合并</h2>\r\n<p>https://www.luogu.com.cn/problem/P10512?contestId=174155</p>\r\n<h2 id=\"题意-2\">题意</h2>\r\n<p>给定一个长度为 𝑛的非负整数序列 {<span\r\nclass=\"math display\">\\[𝑎_𝑛\\]</span>}，你可以进行\r\n𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。</p>\r\n<p>形式化地，一次操作中，你选择一个下标\r\n𝑖<em>i</em>（1≤𝑖&lt;𝑛1≤<em>i</em>&lt;<em>n</em>），然后把原序列变成<span\r\nclass=\"math display\">\\[{a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}\\]</span>。</p>\r\n<p>求 𝑘次操作后所有数按位与的最大值。</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大</p>\r\n<p>注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。</p>\r\n<p>要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。</p>\r\n<p>我觉得比取模题简单</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">29</span>;~i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = ans | (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tx |= a[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((x &amp; t) == t) cnt++,x=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &gt;= n - k) &#123;</span><br><span class=\"line\">\t\t\tans = t;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f.-括号\">F. 括号</h2>\r\n<p>https://www.luogu.com.cn/problem/P10513?contestId=174155</p>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p>圆给了你一个长度为 <span class=\"math inline\">\\(n\\)</span> 的字符串\r\n<span class=\"math inline\">\\(S\\)</span>，<span\r\nclass=\"math inline\">\\(S\\)</span> 仅由 <code>(</code> 和 <code>)</code>\r\n构成。</p>\r\n<p>她会对其做 <span class=\"math inline\">\\(m\\)</span>\r\n次操作，操作有两种类型：</p>\r\n<ol type=\"1\">\r\n<li><code>1 l r</code>，她会翻转 <span class=\"math inline\">\\(l\\)</span>\r\n到 <span class=\"math inline\">\\(r\\)</span> 的括号，即 <code>(</code> 变\r\n<code>)</code>，<code>)</code> 变 <code>(</code>。</li>\r\n<li><code>2 l r</code>，她想知道区间 <span class=\"math inline\">\\(\\left[\r\nl,r\\right]\\)</span> 中最长合法括号子序列的长度除以 <span\r\nclass=\"math inline\">\\(2\\)</span> 的答案。</li>\r\n</ol>\r\n<p>圆认为以下的括号序列是合法的：</p>\r\n<ol type=\"1\">\r\n<li><p>空序列是一个合法序列。</p></li>\r\n<li><p>如果 <code>A</code> 是一个合法序列，则 <code>(A)</code>\r\n也是一个合法序列。</p></li>\r\n<li><p>如果 <code>A</code> 和 <code>B</code> 都是合法序列，则\r\n<code>AB</code> 也是一个合法序列。</p></li>\r\n</ol>\r\n<p>圆认为，序列 <span class=\"math inline\">\\(a\\)</span> 的子序列是满足\r\n<span class=\"math inline\">\\(1\\le i_1&lt;i_2&lt;···&lt;i_k \\le n\\)</span>\r\n的序列 <span\r\nclass=\"math inline\">\\([a_{i_1},a_{i_2},...a_{i_k}]\\)</span>。</p>\r\n<p>由于操作太多了，她算不过来，请你帮帮她吧。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>洛谷真的要吓死我了，第六题线段树</p>\r\n<p>对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即</p>\r\n<p><span\r\nclass=\"math display\">\\[ans=左边括号序列+右边括号序列+横跨中间的括号序列\\]</span></p>\r\n<p>如何维护交换这一操作呢？</p>\r\n<p>我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,ans;</span><br><span class=\"line\">\t<span class=\"built_in\">node</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>,<span class=\"type\">int</span> y=<span class=\"number\">0</span>,<span class=\"type\">int</span> z=<span class=\"number\">0</span>)&#123;l=x,r=y,ans=z;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tree</span>&#123;<span class=\"type\">int</span> tag;node t1,t2;&#125;t[N&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">merge</span><span class=\"params\">(node x,node y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt=<span class=\"built_in\">min</span>(x.l,y.r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;t[p].t1=<span class=\"built_in\">merge</span>(t[ls].t1,t[rs].t1);t[p].t2=<span class=\"built_in\">merge</span>(t[ls].t2,t[rs].t2);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushson</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"built_in\">swap</span>(t[p].t1,t[p].t2);t[p].tag^=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"keyword\">if</span>(!t[p].tag) <span class=\"keyword\">return</span>;<span class=\"built_in\">pushson</span>(ls),<span class=\"built_in\">pushson</span>(rs);t[p].tag=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r) <span class=\"keyword\">return</span> t[p].t<span class=\"number\">2.</span>r=t[p].t<span class=\"number\">1.l</span>=(s[l]==<span class=\"string\">&#x27;(&#x27;</span>),t[p].t<span class=\"number\">2.l</span>=t[p].t<span class=\"number\">1.</span>r=(s[l]==<span class=\"string\">&#x27;)&#x27;</span>),<span class=\"built_in\">void</span>();</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(ls,l,mid);<span class=\"built_in\">build</span>(rs,mid<span class=\"number\">+1</span>,r);<span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> <span class=\"built_in\">pushson</span>(p);<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&gt;=s) <span class=\"built_in\">modify</span>(ls,l,mid,s,e);<span class=\"keyword\">if</span>(mid&lt;e) <span class=\"built_in\">modify</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> t[p].t1;<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e&lt;=mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(ls,l,mid,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s&gt;mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">merge</span>(<span class=\"built_in\">query</span>(ls,l,mid,s,e),<span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tcin&gt;&gt;s<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op,l,r;cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r).ans&lt;&lt;endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g.考试\">G.考试</h2>\r\n<p>https://www.luogu.com.cn/problem/P10514?contestId=174155</p>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>有 <span class=\"math inline\">\\(n\\)</span> 名同学去参加考试，考试有\r\n<span class=\"math inline\">\\(m\\)</span> 道题。</p>\r\n<p>每个学生的实力是相同的，但是每道题的难度可能不同。第 <span\r\nclass=\"math inline\">\\(i\\)</span> 道题会有随机的 <span\r\nclass=\"math inline\">\\(a_i\\)</span> 名同学做错。</p>\r\n<p>考试结束后，随机选出 <span class=\"math inline\">\\(k\\)</span>\r\n名同学，求出这些同学全部做对的概率。答案对 <span\r\nclass=\"math inline\">\\(998244353\\)</span> 取模。</p>\r\n<h3 id=\"题解-4\">题解</h3>\r\n<p>数学题。。。 懒得打公式了，如下</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png\"\r\nalt=\"image-20240527221944431\" />\r\n<figcaption aria-hidden=\"true\">image-20240527221944431</figcaption>\r\n</figure>\r\n<p>预处理阶乘，快速幂分母时间复杂度为log(m)+n</p>\r\n<p>处理分子时间复杂度为mlog(n)</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tfac[<span class=\"number\">0</span>] = infac[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">\t\tfac[i] = fac[i<span class=\"number\">-1</span>] *i % MOD;</span><br><span class=\"line\">\t\tinfac[i] = infac[i<span class=\"number\">-1</span>] * <span class=\"built_in\">qmi</span>(i,MOD<span class=\"number\">-2</span>,MOD) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;fac[i]&lt;&lt;&#x27; &#x27; &lt;&lt;infac[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i], mx= <span class=\"built_in\">max</span>(mx,a[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(mx + k &gt; n) &#123;cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;<span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> inv = <span class=\"built_in\">qmi</span>(<span class=\"built_in\">qmi</span>(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD<span class=\"number\">-2</span>,MOD);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> factor = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;factor*inv % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"h.-转圈按钮p4861\">H. 转圈、按钮P4861</h2>\r\n<p>https://www.luogu.com.cn/problem/P10515?contestId=174155</p>\r\n<h3 id=\"题意-5\">题意</h3>\r\n<p>小 <span class=\"math inline\">\\(\\delta\\)</span> 喜欢转圈圈。</p>\r\n<p>他有一个圈，被均匀分成了 <span class=\"math inline\">\\(n\\)</span>\r\n个格子，神奇的是，<span class=\"math inline\">\\(n\\)</span> 是一个质数。第\r\n<span class=\"math inline\">\\(i\\)</span> 个格子上写着一个数 <span\r\nclass=\"math inline\">\\(i \\times m\\)</span>，他现在站在第一个格子上。</p>\r\n<p>接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。</p>\r\n<p>求最终被小 <span class=\"math inline\">\\(\\delta\\)</span>\r\n踩到过的格子的数量。由于小 <span class=\"math inline\">\\(\\delta\\)</span>\r\n有很多圈圈，所以他会问你很多次。</p>\r\n<h3 id=\"题解-5\">题解</h3>\r\n<p>这题和P4861撞了，所以我干脆贴这题了</p>\r\n<p>根据欧拉定理<span class=\"math display\">\\[a^{\\phi(p)}= 1\r\n(modp)\\]</span></p>\r\n<p>因此<span\r\nclass=\"math display\">\\[\\phi(p)\\]</span>一定是答案的倍数，我们只需要枚举它的因子即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;<span class=\"keyword\">return</span> y? <span class=\"built_in\">gcd</span>(y,x%y): x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_phi</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> res = x;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(x&amp;<span class=\"number\">1</span>)) res &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">3</span>;i*i&lt;=x; i+= <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tres -= res /i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(x % i == <span class=\"number\">0</span>) x/=i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt; <span class=\"number\">1</span>) res -= res / x;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">gcd</span>(n,m)!=<span class=\"number\">1</span>)<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Let&#x27;s go Blue Jays!&quot;</span>);<span class=\"comment\">//无解</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p=<span class=\"built_in\">get_phi</span>(n);<span class=\"comment\">//得到phi</span></span><br><span class=\"line\">        <span class=\"type\">int</span> mm=p;</span><br><span class=\"line\">        <span class=\"type\">int</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;(i*i)&lt;=mm;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mm%i)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            pri[++tot]=i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(mm%i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                mm/=i;</span><br><span class=\"line\">                tim[tot]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mm!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            pri[++tot]=mm;</span><br><span class=\"line\">            tim[tot]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ss=<span class=\"number\">1</span>,qq=p;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ss&lt;=tot)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tim[ss];i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">qmi</span>(m,qq/pri[ss],n)==<span class=\"number\">1</span>)qq/=pri[ss];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ss++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;qq&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"三种操作系统模拟软件使用手册","date":"2024-05-13T09:07:09.000Z","_content":"\n# 三种操作系统简单模拟使用手册\n\n## 可运行程序图标\n\nhttps://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw\n\n![image-20240525143542993](https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png)\n\n<!--more-->\n\n## 安装\n\n程序提供了三种安装形式。\n\n### exe模式\n\n第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考[Java官网](https://www.java.com/zh-CN/download/manual.jsp)\n\n### JAR模式\n\n第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用\n\n<!--more-->\n\n### install安装包模式\n\n第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。\n\n## 卸载方式\n\n通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。\n\n## 程序使用指南\n\n### 开源协议窗口\n\n![image-20240525143707804](https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png)\n\n该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。\n\n\n\n### 导航菜单界面\n\n![image-20240525143849896](https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png)\n\n该界面为程序主题界面，可通过界面导航到三个算法界面\n\n### 生产者消费者\n\n![image-20240525144036276](https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png)\n\n该界面可实现生产者消费者业务功能\n\n使用方式为：\n\n1. 按照程序显示按钮进行操作，请勿输入未指定的，空数据。\n\n1.0.1 版本常见问题为：\n\n1. 该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。\n\n### 银行家算法\n\n   ![image-20240525144551258](https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png)\n\n该界面为银行家算法界面，可实现银行家算法的功能与设计\n\n使用方式为：\n\n1. 给定总进程与总资源数\n2. 设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵\n3. 是否继续请求\n\n1.0.1版本可能遇到的问题：\n\n1. 设定过多进程与资源数导致无法输入\n2. ![image-20240525145256829](https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png)\n\n### 调度算法模拟\n\n![image-20240525144538081](https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png)\n\n调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能\n\n![image-20240525144654678](https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png)\n\n六种调度算法全称分别是\n\n1. 先到先执行\n2. 非抢占式短作业优先\n3. 最短剩余时间优先（抢占式最短作业优先）\n4. 非抢占式优先级优先\n5. 抢占式优先级优先\n6. 时间片轮转算法\n\n使用方法为：\n\n1. 输入每个进程的前四列信息\n2. 选择算法\n3. 点击计算\n\n1.0.1版本可能遇到的问题：\n\n1. 请勿设置相同进程号\n2. 请勿设置小数时间片轮转或设置为0\n3. 给定的完成时间，周转时间，等待时间将被忽略","source":"_posts/三种操作系统模拟软件使用手册.md","raw":"---\ntitle: 三种操作系统模拟软件使用手册\ndate: 2024-05-13 17:07:09\ntags: [开发, 文档, 学校]\ncategories: \n   - 软件\n   - 手册\n---\n\n# 三种操作系统简单模拟使用手册\n\n## 可运行程序图标\n\nhttps://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw\n\n![image-20240525143542993](https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png)\n\n<!--more-->\n\n## 安装\n\n程序提供了三种安装形式。\n\n### exe模式\n\n第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考[Java官网](https://www.java.com/zh-CN/download/manual.jsp)\n\n### JAR模式\n\n第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用\n\n<!--more-->\n\n### install安装包模式\n\n第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。\n\n## 卸载方式\n\n通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。\n\n## 程序使用指南\n\n### 开源协议窗口\n\n![image-20240525143707804](https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png)\n\n该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。\n\n\n\n### 导航菜单界面\n\n![image-20240525143849896](https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png)\n\n该界面为程序主题界面，可通过界面导航到三个算法界面\n\n### 生产者消费者\n\n![image-20240525144036276](https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png)\n\n该界面可实现生产者消费者业务功能\n\n使用方式为：\n\n1. 按照程序显示按钮进行操作，请勿输入未指定的，空数据。\n\n1.0.1 版本常见问题为：\n\n1. 该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。\n\n### 银行家算法\n\n   ![image-20240525144551258](https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png)\n\n该界面为银行家算法界面，可实现银行家算法的功能与设计\n\n使用方式为：\n\n1. 给定总进程与总资源数\n2. 设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵\n3. 是否继续请求\n\n1.0.1版本可能遇到的问题：\n\n1. 设定过多进程与资源数导致无法输入\n2. ![image-20240525145256829](https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png)\n\n### 调度算法模拟\n\n![image-20240525144538081](https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png)\n\n调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能\n\n![image-20240525144654678](https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png)\n\n六种调度算法全称分别是\n\n1. 先到先执行\n2. 非抢占式短作业优先\n3. 最短剩余时间优先（抢占式最短作业优先）\n4. 非抢占式优先级优先\n5. 抢占式优先级优先\n6. 时间片轮转算法\n\n使用方法为：\n\n1. 输入每个进程的前四列信息\n2. 选择算法\n3. 点击计算\n\n1.0.1版本可能遇到的问题：\n\n1. 请勿设置相同进程号\n2. 请勿设置小数时间片轮转或设置为0\n3. 给定的完成时间，周转时间，等待时间将被忽略","slug":"三种操作系统模拟软件使用手册","published":1,"updated":"2024-08-14T13:38:59.744Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjaf0016lowv4o2nachh","content":"<h1 id=\"三种操作系统简单模拟使用手册\">三种操作系统简单模拟使用手册</h1>\r\n<h2 id=\"可运行程序图标\">可运行程序图标</h2>\r\n<p>https://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png\"\r\nalt=\"image-20240525143542993\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143542993</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h2 id=\"安装\">安装</h2>\r\n<p>程序提供了三种安装形式。</p>\r\n<h3 id=\"exe模式\">exe模式</h3>\r\n<p>第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamF2YS5jb20vemgtQ04vZG93bmxvYWQvbWFudWFsLmpzcA==\">Java官网<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"jar模式\">JAR模式</h3>\r\n<p>第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java\r\n-jar直接调用，也可以通过ide导入为库调用</p>\r\n<!--more-->\r\n<h3 id=\"install安装包模式\">install安装包模式</h3>\r\n<p>第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。</p>\r\n<h2 id=\"卸载方式\">卸载方式</h2>\r\n<p>通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。</p>\r\n<h2 id=\"程序使用指南\">程序使用指南</h2>\r\n<h3 id=\"开源协议窗口\">开源协议窗口</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png\"\r\nalt=\"image-20240525143707804\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143707804</figcaption>\r\n</figure>\r\n<p>该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。</p>\r\n<h3 id=\"导航菜单界面\">导航菜单界面</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png\"\r\nalt=\"image-20240525143849896\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143849896</figcaption>\r\n</figure>\r\n<p>该界面为程序主题界面，可通过界面导航到三个算法界面</p>\r\n<h3 id=\"生产者消费者\">生产者消费者</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png\"\r\nalt=\"image-20240525144036276\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144036276</figcaption>\r\n</figure>\r\n<p>该界面可实现生产者消费者业务功能</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>按照程序显示按钮进行操作，请勿输入未指定的，空数据。</li>\r\n</ol>\r\n<p>1.0.1 版本常见问题为：</p>\r\n<ol type=\"1\">\r\n<li>该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。</li>\r\n</ol>\r\n<h3 id=\"银行家算法\">银行家算法</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png\"\r\nalt=\"image-20240525144551258\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144551258</figcaption>\r\n</figure>\r\n<p>该界面为银行家算法界面，可实现银行家算法的功能与设计</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>给定总进程与总资源数</li>\r\n<li>设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵</li>\r\n<li>是否继续请求</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>设定过多进程与资源数导致无法输入</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png\"\r\nalt=\"image-20240525145256829\" />\r\n<figcaption aria-hidden=\"true\">image-20240525145256829</figcaption>\r\n</figure></li>\r\n</ol>\r\n<h3 id=\"调度算法模拟\">调度算法模拟</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png\"\r\nalt=\"image-20240525144538081\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144538081</figcaption>\r\n</figure>\r\n<p>调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png\"\r\nalt=\"image-20240525144654678\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144654678</figcaption>\r\n</figure>\r\n<p>六种调度算法全称分别是</p>\r\n<ol type=\"1\">\r\n<li>先到先执行</li>\r\n<li>非抢占式短作业优先</li>\r\n<li>最短剩余时间优先（抢占式最短作业优先）</li>\r\n<li>非抢占式优先级优先</li>\r\n<li>抢占式优先级优先</li>\r\n<li>时间片轮转算法</li>\r\n</ol>\r\n<p>使用方法为：</p>\r\n<ol type=\"1\">\r\n<li>输入每个进程的前四列信息</li>\r\n<li>选择算法</li>\r\n<li>点击计算</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>请勿设置相同进程号</li>\r\n<li>请勿设置小数时间片轮转或设置为0</li>\r\n<li>给定的完成时间，周转时间，等待时间将被忽略</li>\r\n</ol>\r\n","length":830,"excerpt":"<h1 id=\"三种操作系统简单模拟使用手册\">三种操作系统简单模拟使用手册</h1>\r\n<h2 id=\"可运行程序图标\">可运行程序图标</h2>\r\n<p>https://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png\"\r\nalt=\"image-20240525143542993\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143542993</figcaption>\r\n</figure>","more":"<h2 id=\"安装\">安装</h2>\r\n<p>程序提供了三种安装形式。</p>\r\n<h3 id=\"exe模式\">exe模式</h3>\r\n<p>第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamF2YS5jb20vemgtQ04vZG93bmxvYWQvbWFudWFsLmpzcA==\">Java官网<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"jar模式\">JAR模式</h3>\r\n<p>第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java\r\n-jar直接调用，也可以通过ide导入为库调用</p>\r\n<!--more-->\r\n<h3 id=\"install安装包模式\">install安装包模式</h3>\r\n<p>第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。</p>\r\n<h2 id=\"卸载方式\">卸载方式</h2>\r\n<p>通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。</p>\r\n<h2 id=\"程序使用指南\">程序使用指南</h2>\r\n<h3 id=\"开源协议窗口\">开源协议窗口</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png\"\r\nalt=\"image-20240525143707804\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143707804</figcaption>\r\n</figure>\r\n<p>该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。</p>\r\n<h3 id=\"导航菜单界面\">导航菜单界面</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png\"\r\nalt=\"image-20240525143849896\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143849896</figcaption>\r\n</figure>\r\n<p>该界面为程序主题界面，可通过界面导航到三个算法界面</p>\r\n<h3 id=\"生产者消费者\">生产者消费者</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png\"\r\nalt=\"image-20240525144036276\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144036276</figcaption>\r\n</figure>\r\n<p>该界面可实现生产者消费者业务功能</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>按照程序显示按钮进行操作，请勿输入未指定的，空数据。</li>\r\n</ol>\r\n<p>1.0.1 版本常见问题为：</p>\r\n<ol type=\"1\">\r\n<li>该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。</li>\r\n</ol>\r\n<h3 id=\"银行家算法\">银行家算法</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png\"\r\nalt=\"image-20240525144551258\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144551258</figcaption>\r\n</figure>\r\n<p>该界面为银行家算法界面，可实现银行家算法的功能与设计</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>给定总进程与总资源数</li>\r\n<li>设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵</li>\r\n<li>是否继续请求</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>设定过多进程与资源数导致无法输入</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png\"\r\nalt=\"image-20240525145256829\" />\r\n<figcaption aria-hidden=\"true\">image-20240525145256829</figcaption>\r\n</figure></li>\r\n</ol>\r\n<h3 id=\"调度算法模拟\">调度算法模拟</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png\"\r\nalt=\"image-20240525144538081\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144538081</figcaption>\r\n</figure>\r\n<p>调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png\"\r\nalt=\"image-20240525144654678\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144654678</figcaption>\r\n</figure>\r\n<p>六种调度算法全称分别是</p>\r\n<ol type=\"1\">\r\n<li>先到先执行</li>\r\n<li>非抢占式短作业优先</li>\r\n<li>最短剩余时间优先（抢占式最短作业优先）</li>\r\n<li>非抢占式优先级优先</li>\r\n<li>抢占式优先级优先</li>\r\n<li>时间片轮转算法</li>\r\n</ol>\r\n<p>使用方法为：</p>\r\n<ol type=\"1\">\r\n<li>输入每个进程的前四列信息</li>\r\n<li>选择算法</li>\r\n<li>点击计算</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>请勿设置相同进程号</li>\r\n<li>请勿设置小数时间片轮转或设置为0</li>\r\n<li>给定的完成时间，周转时间，等待时间将被忽略</li>\r\n</ol>"},{"title":"为什么我用Typora——Typora与其他markdown的比较","date":"2023-08-13T07:20:34.000Z","_content":"## Typora\n\n​\tTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。\n\n<!--more-->\n\n## Typora的Markdown语法\n\n​\tTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。\n\n​\t但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在**Latex语法格式**。\n\n​\t因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。\n\n> ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化\n\n<!--more-->\n\n### 代码块语法\n\n​\t代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行\n\n### Html、js、css\n\n​\tTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。\n\n​\t通过html也可以实现索引官方的方式是 `[这样]()`\n\n## Typora中的Mermaid，Latex\n\n​\tMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。\n\n​\t但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此**Typora并未bundle Fontawesome**。因此无法使用fa: fa-xxx表示图标。\n\n## Typora中的媒体\n\n​\tTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：\n\n1. 以ssms图床为例[Image Upload - SM.MS - Simple Free Image Hosting](https://sm.ms/)\n2. 到ssms官网注册张航并拿到apikey\n3. 填入picgo插件的配置文件\n4. ![配置图](https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png)\n\n> ```\n> {\n>   \"picBed\": {\n>     \"current\": \"smms\",\n>     \"smms\": {\n>       \"token\": \"xxx\"\n>     }\n>   },\n>   \"picgoPlugins\": {}\n> }\n> ```\n\n5. 测试并运行\n\n## Typora的文档保存机制\n\n​\t当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失\n\n## Typora的个性化主题\n\n​\tTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。\n\n## 总结\n\n​\t对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。\n\n## 一些比较实用的不在Typora文档中的使用技巧\n\n1. 通过html标签扩展typora的显示格式\n\n   如`<details></details>`标签可以显示一个展开栏，做错题本时很好用\n\n2. 一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin\n\n   [obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)](https://github.com/obgnail/typora_plugin)\n\n---\n\n待更新","source":"_posts/为什么我用Typora——Typora与其他markdown的比较.md","raw":"---\ntitle: 为什么我用Typora——Typora与其他markdown的比较\ndate: 2023-08-13 15:20:34\ntags: [Typora, Markdown, 随笔]\ncategories:\n   - 软件\n   - 编辑器\n   - Markdown\n---\n## Typora\n\n​\tTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。\n\n<!--more-->\n\n## Typora的Markdown语法\n\n​\tTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。\n\n​\t但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在**Latex语法格式**。\n\n​\t因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。\n\n> ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化\n\n<!--more-->\n\n### 代码块语法\n\n​\t代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行\n\n### Html、js、css\n\n​\tTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。\n\n​\t通过html也可以实现索引官方的方式是 `[这样]()`\n\n## Typora中的Mermaid，Latex\n\n​\tMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。\n\n​\t但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此**Typora并未bundle Fontawesome**。因此无法使用fa: fa-xxx表示图标。\n\n## Typora中的媒体\n\n​\tTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：\n\n1. 以ssms图床为例[Image Upload - SM.MS - Simple Free Image Hosting](https://sm.ms/)\n2. 到ssms官网注册张航并拿到apikey\n3. 填入picgo插件的配置文件\n4. ![配置图](https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png)\n\n> ```\n> {\n>   \"picBed\": {\n>     \"current\": \"smms\",\n>     \"smms\": {\n>       \"token\": \"xxx\"\n>     }\n>   },\n>   \"picgoPlugins\": {}\n> }\n> ```\n\n5. 测试并运行\n\n## Typora的文档保存机制\n\n​\t当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失\n\n## Typora的个性化主题\n\n​\tTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。\n\n## 总结\n\n​\t对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。\n\n## 一些比较实用的不在Typora文档中的使用技巧\n\n1. 通过html标签扩展typora的显示格式\n\n   如`<details></details>`标签可以显示一个展开栏，做错题本时很好用\n\n2. 一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin\n\n   [obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)](https://github.com/obgnail/typora_plugin)\n\n---\n\n待更新","slug":"为什么我用Typora——Typora与其他markdown的比较","published":1,"updated":"2024-08-14T13:39:02.327Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjaf0019lowv3ob64z5c","content":"<h2 id=\"typora\">Typora</h2>\r\n<p>​\r\nTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"typora的markdown语法\">Typora的Markdown语法</h2>\r\n<p>​\r\nTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。</p>\r\n<p>​\r\n但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在<strong>Latex语法格式</strong>。</p>\r\n<p>​\r\n因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。</p>\r\n<blockquote>\r\n<p>ps:\r\n根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化</p>\r\n</blockquote>\r\n<!--more-->\r\n<h3 id=\"代码块语法\">代码块语法</h3>\r\n<p>​ 代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行</p>\r\n<h3 id=\"htmljscss\">Html、js、css</h3>\r\n<p>​\r\nTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。</p>\r\n<p>​ 通过html也可以实现索引官方的方式是 <code>[这样]()</code></p>\r\n<h2 id=\"typora中的mermaidlatex\">Typora中的Mermaid，Latex</h2>\r\n<p>​\r\nMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。</p>\r\n<p>​ 但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest\r\nversion为v6，因此<strong>Typora并未bundle\r\nFontawesome</strong>。因此无法使用fa: fa-xxx表示图标。</p>\r\n<h2 id=\"typora中的媒体\">Typora中的媒体</h2>\r\n<p>​\r\nTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：</p>\r\n<ol type=\"1\">\r\n<li>以ssms图床为例<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zbS5tcy8=\">Image Upload - SM.MS - Simple\r\nFree Image Hosting<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n<li>到ssms官网注册张航并拿到apikey</li>\r\n<li>填入picgo插件的配置文件</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png\"\r\nalt=\"配置图\" />\r\n<figcaption aria-hidden=\"true\">配置图</figcaption>\r\n</figure></li>\r\n</ol>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;picBed&quot;: &#123;</span><br><span class=\"line\">    &quot;current&quot;: &quot;smms&quot;,</span><br><span class=\"line\">    &quot;smms&quot;: &#123;</span><br><span class=\"line\">      &quot;token&quot;: &quot;xxx&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;picgoPlugins&quot;: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<ol start=\"5\" type=\"1\">\r\n<li>测试并运行</li>\r\n</ol>\r\n<h2 id=\"typora的文档保存机制\">Typora的文档保存机制</h2>\r\n<p>​\r\n当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失</p>\r\n<h2 id=\"typora的个性化主题\">Typora的个性化主题</h2>\r\n<p>​\r\nTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。</p>\r\n<h2 id=\"总结\">总结</h2>\r\n<p>​\r\n对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。</p>\r\n<h2\r\nid=\"一些比较实用的不在typora文档中的使用技巧\">一些比较实用的不在Typora文档中的使用技巧</h2>\r\n<ol type=\"1\">\r\n<li><p>通过html标签扩展typora的显示格式</p>\r\n<p>如<code>&lt;details&gt;&lt;/details&gt;</code>标签可以显示一个展开栏，做错题本时很好用</p></li>\r\n<li><p>一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29iZ25haWwvdHlwb3JhX3BsdWdpbg==\">obgnail/typora_plugin:\r\nTypora plugin. Feature enhancement tool | Typora 插件，功能增强工具\r\n(github.com)<i class=\"fa fa-external-link-alt\"></i></span></p></li>\r\n</ol>\r\n<hr />\r\n<p>待更新</p>\r\n","length":1122,"excerpt":"<h2 id=\"typora\">Typora</h2>\r\n<p>​\r\nTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。</p>","more":"<h2 id=\"typora的markdown语法\">Typora的Markdown语法</h2>\r\n<p>​\r\nTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。</p>\r\n<p>​\r\n但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在<strong>Latex语法格式</strong>。</p>\r\n<p>​\r\n因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。</p>\r\n<blockquote>\r\n<p>ps:\r\n根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化</p>\r\n</blockquote>\r\n<!--more-->\r\n<h3 id=\"代码块语法\">代码块语法</h3>\r\n<p>​ 代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行</p>\r\n<h3 id=\"htmljscss\">Html、js、css</h3>\r\n<p>​\r\nTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。</p>\r\n<p>​ 通过html也可以实现索引官方的方式是 <code>[这样]()</code></p>\r\n<h2 id=\"typora中的mermaidlatex\">Typora中的Mermaid，Latex</h2>\r\n<p>​\r\nMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。</p>\r\n<p>​ 但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest\r\nversion为v6，因此<strong>Typora并未bundle\r\nFontawesome</strong>。因此无法使用fa: fa-xxx表示图标。</p>\r\n<h2 id=\"typora中的媒体\">Typora中的媒体</h2>\r\n<p>​\r\nTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：</p>\r\n<ol type=\"1\">\r\n<li>以ssms图床为例<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zbS5tcy8=\">Image Upload - SM.MS - Simple\r\nFree Image Hosting<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n<li>到ssms官网注册张航并拿到apikey</li>\r\n<li>填入picgo插件的配置文件</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png\"\r\nalt=\"配置图\" />\r\n<figcaption aria-hidden=\"true\">配置图</figcaption>\r\n</figure></li>\r\n</ol>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;picBed&quot;: &#123;</span><br><span class=\"line\">    &quot;current&quot;: &quot;smms&quot;,</span><br><span class=\"line\">    &quot;smms&quot;: &#123;</span><br><span class=\"line\">      &quot;token&quot;: &quot;xxx&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;picgoPlugins&quot;: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<ol start=\"5\" type=\"1\">\r\n<li>测试并运行</li>\r\n</ol>\r\n<h2 id=\"typora的文档保存机制\">Typora的文档保存机制</h2>\r\n<p>​\r\n当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失</p>\r\n<h2 id=\"typora的个性化主题\">Typora的个性化主题</h2>\r\n<p>​\r\nTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。</p>\r\n<h2 id=\"总结\">总结</h2>\r\n<p>​\r\n对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。</p>\r\n<h2\r\nid=\"一些比较实用的不在typora文档中的使用技巧\">一些比较实用的不在Typora文档中的使用技巧</h2>\r\n<ol type=\"1\">\r\n<li><p>通过html标签扩展typora的显示格式</p>\r\n<p>如<code>&lt;details&gt;&lt;/details&gt;</code>标签可以显示一个展开栏，做错题本时很好用</p></li>\r\n<li><p>一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29iZ25haWwvdHlwb3JhX3BsdWdpbg==\">obgnail/typora_plugin:\r\nTypora plugin. Feature enhancement tool | Typora 插件，功能增强工具\r\n(github.com)<i class=\"fa fa-external-link-alt\"></i></span></p></li>\r\n</ol>\r\n<hr />\r\n<p>待更新</p>"},{"title":"字符串","date":"2024-08-14T11:37:01.000Z","_content":"# 题意：\n\n给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。\n\n# 题解：\n\n子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。\n\n子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt\\[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。\n\n这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。\n\n<!--more-->\n\n```cpp\nvoid get_next(){\n    for(int i=n;i>=0;i--){\n        for(int j=0;j<26;j++){\n            if(i==n) nxt[i][j]=n;\n            else nxt[i][j]=nxt[i+1][j];\n        }\n        if(i!=n) nxt[i][s[i]-'A']=i;\n    }\n}\n\nint get_pos(int st,string s){\n    int first=1;\n    for(auto ch:s){\n        if(first) st=nxt[st][ch-'A'];\n        else st=nxt[st+1][ch-'A'];\n        first=0;\n        if(st==n) return st;\n    }\n    return st;\n}\n\nvoid slove(){\n    cin>>n>>k>>s;\n    get_next();\n    string ac=\"ACCEPT\",wa=\"WA\";\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        int r1=get_pos(i,ac),r2=get_pos(i,wa);\n        r1=max(r1,i+k-1);\n        ans=ans+max(r2-r1,0ll);\n    }\n    cout<<ans<<endl;\n}\n```\n\n","source":"_posts/字符串习题1.md","raw":"---\ntitle: 字符串\ndate: 2024-08-14 19:37:01\ntags: [算法, 子序列自动机]\ncategories: \n\t- 算法\n\t- 字符串\n\t- 子序列自动机\n---\n# 题意：\n\n给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。\n\n# 题解：\n\n子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。\n\n子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt\\[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。\n\n这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。\n\n<!--more-->\n\n```cpp\nvoid get_next(){\n    for(int i=n;i>=0;i--){\n        for(int j=0;j<26;j++){\n            if(i==n) nxt[i][j]=n;\n            else nxt[i][j]=nxt[i+1][j];\n        }\n        if(i!=n) nxt[i][s[i]-'A']=i;\n    }\n}\n\nint get_pos(int st,string s){\n    int first=1;\n    for(auto ch:s){\n        if(first) st=nxt[st][ch-'A'];\n        else st=nxt[st+1][ch-'A'];\n        first=0;\n        if(st==n) return st;\n    }\n    return st;\n}\n\nvoid slove(){\n    cin>>n>>k>>s;\n    get_next();\n    string ac=\"ACCEPT\",wa=\"WA\";\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        int r1=get_pos(i,ac),r2=get_pos(i,wa);\n        r1=max(r1,i+k-1);\n        ans=ans+max(r2-r1,0ll);\n    }\n    cout<<ans<<endl;\n}\n```\n\n","slug":"字符串习题1","published":1,"updated":"2024-08-14T13:39:05.118Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjag001blowv8l807ti6","content":"<h1 id=\"题意\">题意：</h1>\r\n<p>给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。</p>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。</p>\r\n<p>子序列自动机的基本概念是用二维数组保存对于i位置\r\nj字符第一次出现的位置为nxt[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。</p>\r\n<p>这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">26</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==n) nxt[i][j]=n;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nxt[i][j]=nxt[i<span class=\"number\">+1</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=n) nxt[i][s[i]-<span class=\"string\">&#x27;A&#x27;</span>]=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pos</span><span class=\"params\">(<span class=\"type\">int</span> st,string s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> first=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> ch:s)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first) st=nxt[st][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> st=nxt[st<span class=\"number\">+1</span>][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        first=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st==n) <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">get_next</span>();</span><br><span class=\"line\">    string ac=<span class=\"string\">&quot;ACCEPT&quot;</span>,wa=<span class=\"string\">&quot;WA&quot;</span>;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> r1=<span class=\"built_in\">get_pos</span>(i,ac),r2=<span class=\"built_in\">get_pos</span>(i,wa);</span><br><span class=\"line\">        r1=<span class=\"built_in\">max</span>(r1,i+k<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ans=ans+<span class=\"built_in\">max</span>(r2-r1,<span class=\"number\">0ll</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":310,"excerpt":"<h1 id=\"题意\">题意：</h1>\r\n<p>给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。</p>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。</p>\r\n<p>子序列自动机的基本概念是用二维数组保存对于i位置\r\nj字符第一次出现的位置为nxt[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。</p>\r\n<p>这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">26</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==n) nxt[i][j]=n;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nxt[i][j]=nxt[i<span class=\"number\">+1</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=n) nxt[i][s[i]-<span class=\"string\">&#x27;A&#x27;</span>]=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pos</span><span class=\"params\">(<span class=\"type\">int</span> st,string s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> first=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> ch:s)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first) st=nxt[st][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> st=nxt[st<span class=\"number\">+1</span>][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        first=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st==n) <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">get_next</span>();</span><br><span class=\"line\">    string ac=<span class=\"string\">&quot;ACCEPT&quot;</span>,wa=<span class=\"string\">&quot;WA&quot;</span>;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> r1=<span class=\"built_in\">get_pos</span>(i,ac),r2=<span class=\"built_in\">get_pos</span>(i,wa);</span><br><span class=\"line\">        r1=<span class=\"built_in\">max</span>(r1,i+k<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ans=ans+<span class=\"built_in\">max</span>(r2-r1,<span class=\"number\">0ll</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"思维题1","date":"2024-08-14T11:35:22.000Z","_content":"# 题意\n题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小\n\n# 题解\n题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt->ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。\n\n<!--more-->\n\n```cpp\nvoid slove(){\n    cin>>n;\n    string s;\n    cin>>s;\n    int cnt = 0,ans = 0;\n\n    for(int i=0;i<n;i++){\n        if(s[i]=='0'){\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2)%MOD;\n        }else if(s[i]&1){\n            cnt=(cnt*2+1)%MOD;\n        }else{\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2+1)%MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。\n\n对于每一个偶数计算它的贡献值为$$2^{i-1}$$，对于每一个0计算它的贡献为$$-2^{n-i}$$，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。","source":"_posts/思维题习题1.md","raw":"---\ntitle: 思维题1\ndate: 2024-08-14 19:35:22\ntags: [算法, 思维题]\ncategories: \n\t- 算法\n\t- 思维题\n---\n# 题意\n题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小\n\n# 题解\n题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt->ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。\n\n<!--more-->\n\n```cpp\nvoid slove(){\n    cin>>n;\n    string s;\n    cin>>s;\n    int cnt = 0,ans = 0;\n\n    for(int i=0;i<n;i++){\n        if(s[i]=='0'){\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2)%MOD;\n        }else if(s[i]&1){\n            cnt=(cnt*2+1)%MOD;\n        }else{\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2+1)%MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。\n\n对于每一个偶数计算它的贡献值为$$2^{i-1}$$，对于每一个0计算它的贡献为$$-2^{n-i}$$，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。","slug":"思维题习题1","published":1,"updated":"2024-08-14T13:39:08.223Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjag001dlowvexr7977y","content":"<h1 id=\"题意\">题意</h1>\r\n<p>题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小</p>\r\n<h1 id=\"题解\">题解</h1>\r\n<p>题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt-&gt;ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。</p>\r\n<p>对于每一个偶数计算它的贡献值为<span\r\nclass=\"math display\">\\[2^{i-1}\\]</span>，对于每一个0计算它的贡献为<span\r\nclass=\"math display\">\\[-2^{n-i}\\]</span>，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。</p>\r\n","length":345,"excerpt":"<h1 id=\"题意\">题意</h1>\r\n<p>题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小</p>\r\n<h1 id=\"题解\">题解</h1>\r\n<p>题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt-&gt;ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。</p>\r\n<p>对于每一个偶数计算它的贡献值为<span\r\nclass=\"math display\">\\[2^{i-1}\\]</span>，对于每一个0计算它的贡献为<span\r\nclass=\"math display\">\\[-2^{n-i}\\]</span>，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。</p>"},{"title":"数学距离问题1","date":"2024-08-14T11:43:20.000Z","_content":"## 题意：\n\n给一个国际象棋中的“象”，但每次只能走一格，给N个点\n\n计算总和 $\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N \\text{dist}(P_i, P_j)$​ 。\n\n<!--more-->\n\n## 题解：\n\n注意到实际上这样的走法将整个棋盘以$$x+y$$的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\n$$\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\n$$\n即两个点之间的切比雪夫距离。\n\n证明如下，对于任意两个$$x+y$$奇偶性相同的顶点而言，设起始点为$$(x,y)$$，目的点为$$(xx,yy)$$设dx<dy即$$dist(p_i,p_j) = |p_i.y-p_j.y|$$。\n\n$$xx=x+dx,yy=y+dy$$，则有$$dx = a-b，a+b=dy$$，根据定义可知$$dy=yy-y$$​。\n\n由以上公式,且x,y的奇偶性相同可知xx为在dx<dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。\n\n详细参考[距离 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/geometry/distance/)\n\n如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）\n\n上图(1,4) -> (1,3)\n\n于是题目变为了求n个点的哈密顿距离之和，很经典的题。\n\n由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。\n\n<img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" />\n\ncoding。。。\n\n```cpp\nvoid slove() {\n    cin>>n;\n\n    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;\n\n    for(int i=1;i<=n;i++) {\n        if((a[i].x+a[i].y) %2==1)\n            bx[1][++cn[1]] = a[i].x + a[i].y,by[1][cn[1]] = a[i].y - a[i].x;\n        else\n            bx[0][++cn[0]] = a[i].x + a[i].y,by[0][cn[0]] = a[i].y - a[i].x;\n    }\n\n    sort(bx[0]+1,bx[0]+1+cn[0]);\n    sort(bx[1]+1,bx[1]+1+cn[1]);\n    sort(by[0]+1,by[0]+1+cn[0]);\n    sort(by[1]+1,by[1]+1+cn[1]);\n    int ans = 0;\n    for(int k =0;k<=1;k++) {\n        int sum1 =0 ,sum2=0;\n        for(int i=1;i<=cn[k];i++) {\n            // cout<<k<<' '<<bx[k][i]<<' '<<by[k][i]<<endl;\n            ans += (i-1) * (bx[k][i]+by[k][i]) - sum1-sum2;\n            sum1 += bx[k][i];\n            sum2 += by[k][i];\n        }\n    }\n    cout<<ans/2<<endl;\n}\n```\n\n","source":"_posts/数学距离问题1.md","raw":"---\ntitle: 数学距离问题1\ndate: 2024-08-14 19:43:20\ntags: [算法, 思维题, 坐标系转换, 几何问题]\ncategories: \n\t- 算法\n\t- 思维题\n---\n## 题意：\n\n给一个国际象棋中的“象”，但每次只能走一格，给N个点\n\n计算总和 $\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N \\text{dist}(P_i, P_j)$​ 。\n\n<!--more-->\n\n## 题解：\n\n注意到实际上这样的走法将整个棋盘以$$x+y$$的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\n$$\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\n$$\n即两个点之间的切比雪夫距离。\n\n证明如下，对于任意两个$$x+y$$奇偶性相同的顶点而言，设起始点为$$(x,y)$$，目的点为$$(xx,yy)$$设dx<dy即$$dist(p_i,p_j) = |p_i.y-p_j.y|$$。\n\n$$xx=x+dx,yy=y+dy$$，则有$$dx = a-b，a+b=dy$$，根据定义可知$$dy=yy-y$$​。\n\n由以上公式,且x,y的奇偶性相同可知xx为在dx<dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。\n\n详细参考[距离 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/geometry/distance/)\n\n如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）\n\n上图(1,4) -> (1,3)\n\n于是题目变为了求n个点的哈密顿距离之和，很经典的题。\n\n由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。\n\n<img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" />\n\ncoding。。。\n\n```cpp\nvoid slove() {\n    cin>>n;\n\n    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;\n\n    for(int i=1;i<=n;i++) {\n        if((a[i].x+a[i].y) %2==1)\n            bx[1][++cn[1]] = a[i].x + a[i].y,by[1][cn[1]] = a[i].y - a[i].x;\n        else\n            bx[0][++cn[0]] = a[i].x + a[i].y,by[0][cn[0]] = a[i].y - a[i].x;\n    }\n\n    sort(bx[0]+1,bx[0]+1+cn[0]);\n    sort(bx[1]+1,bx[1]+1+cn[1]);\n    sort(by[0]+1,by[0]+1+cn[0]);\n    sort(by[1]+1,by[1]+1+cn[1]);\n    int ans = 0;\n    for(int k =0;k<=1;k++) {\n        int sum1 =0 ,sum2=0;\n        for(int i=1;i<=cn[k];i++) {\n            // cout<<k<<' '<<bx[k][i]<<' '<<by[k][i]<<endl;\n            ans += (i-1) * (bx[k][i]+by[k][i]) - sum1-sum2;\n            sum1 += bx[k][i];\n            sum2 += by[k][i];\n        }\n    }\n    cout<<ans/2<<endl;\n}\n```\n\n","slug":"数学距离问题1","published":1,"updated":"2024-08-14T13:39:11.945Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjah001flowvgzxkezfo","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>给一个国际象棋中的“象”，但每次只能走一格，给N个点</p>\r\n<p>计算总和 <span\r\nclass=\"math inline\">\\(\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N\r\n\\text{dist}(P_i, P_j)\\)</span>​ 。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>注意到实际上这样的走法将整个棋盘以<span\r\nclass=\"math display\">\\[x+y\\]</span>的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\r\n<span class=\"math display\">\\[\r\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\r\n\\]</span> 即两个点之间的切比雪夫距离。</p>\r\n<p>证明如下，对于任意两个<span\r\nclass=\"math display\">\\[x+y\\]</span>奇偶性相同的顶点而言，设起始点为<span\r\nclass=\"math display\">\\[(x,y)\\]</span>，目的点为<span\r\nclass=\"math display\">\\[(xx,yy)\\]</span>设dx&lt;dy即<span\r\nclass=\"math display\">\\[dist(p_i,p_j) = |p_i.y-p_j.y|\\]</span>。</p>\r\n<p><span class=\"math display\">\\[xx=x+dx,yy=y+dy\\]</span>，则有<span\r\nclass=\"math display\">\\[dx = a-b，a+b=dy\\]</span>，根据定义可知<span\r\nclass=\"math display\">\\[dy=yy-y\\]</span>​。</p>\r\n<p>由以上公式,且x,y的奇偶性相同可知xx为在dx&lt;dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。</p>\r\n<p>详细参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaS13aWtpLm9yZy9nZW9tZXRyeS9kaXN0YW5jZS8=\">距离 - OI\r\nWiki (oi-wiki.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）</p>\r\n<p>上图(1,4) -&gt; (1,3)</p>\r\n<p>于是题目变为了求n个点的哈密顿距离之和，很经典的题。</p>\r\n<p>由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。</p>\r\n<p><img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" /></p>\r\n<p>coding。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((a[i].x+a[i].y) %<span class=\"number\">2</span>==<span class=\"number\">1</span>)</span><br><span class=\"line\">            bx[<span class=\"number\">1</span>][++cn[<span class=\"number\">1</span>]] = a[i].x + a[i].y,by[<span class=\"number\">1</span>][cn[<span class=\"number\">1</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            bx[<span class=\"number\">0</span>][++cn[<span class=\"number\">0</span>]] = a[i].x + a[i].y,by[<span class=\"number\">0</span>][cn[<span class=\"number\">0</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k =<span class=\"number\">0</span>;k&lt;=<span class=\"number\">1</span>;k++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum1 =<span class=\"number\">0</span> ,sum2=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cn[k];i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;bx[k][i]&lt;&lt;&#x27; &#x27;&lt;&lt;by[k][i]&lt;&lt;endl;</span></span><br><span class=\"line\">            ans += (i<span class=\"number\">-1</span>) * (bx[k][i]+by[k][i]) - sum1-sum2;</span><br><span class=\"line\">            sum1 += bx[k][i];</span><br><span class=\"line\">            sum2 += by[k][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":638,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>给一个国际象棋中的“象”，但每次只能走一格，给N个点</p>\r\n<p>计算总和 <span\r\nclass=\"math inline\">\\(\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N\r\n\\text{dist}(P_i, P_j)\\)</span>​ 。</p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>注意到实际上这样的走法将整个棋盘以<span\r\nclass=\"math display\">\\[x+y\\]</span>的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\r\n<span class=\"math display\">\\[\r\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\r\n\\]</span> 即两个点之间的切比雪夫距离。</p>\r\n<p>证明如下，对于任意两个<span\r\nclass=\"math display\">\\[x+y\\]</span>奇偶性相同的顶点而言，设起始点为<span\r\nclass=\"math display\">\\[(x,y)\\]</span>，目的点为<span\r\nclass=\"math display\">\\[(xx,yy)\\]</span>设dx&lt;dy即<span\r\nclass=\"math display\">\\[dist(p_i,p_j) = |p_i.y-p_j.y|\\]</span>。</p>\r\n<p><span class=\"math display\">\\[xx=x+dx,yy=y+dy\\]</span>，则有<span\r\nclass=\"math display\">\\[dx = a-b，a+b=dy\\]</span>，根据定义可知<span\r\nclass=\"math display\">\\[dy=yy-y\\]</span>​。</p>\r\n<p>由以上公式,且x,y的奇偶性相同可知xx为在dx&lt;dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。</p>\r\n<p>详细参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaS13aWtpLm9yZy9nZW9tZXRyeS9kaXN0YW5jZS8=\">距离 - OI\r\nWiki (oi-wiki.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）</p>\r\n<p>上图(1,4) -&gt; (1,3)</p>\r\n<p>于是题目变为了求n个点的哈密顿距离之和，很经典的题。</p>\r\n<p>由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。</p>\r\n<p><img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" /></p>\r\n<p>coding。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((a[i].x+a[i].y) %<span class=\"number\">2</span>==<span class=\"number\">1</span>)</span><br><span class=\"line\">            bx[<span class=\"number\">1</span>][++cn[<span class=\"number\">1</span>]] = a[i].x + a[i].y,by[<span class=\"number\">1</span>][cn[<span class=\"number\">1</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            bx[<span class=\"number\">0</span>][++cn[<span class=\"number\">0</span>]] = a[i].x + a[i].y,by[<span class=\"number\">0</span>][cn[<span class=\"number\">0</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k =<span class=\"number\">0</span>;k&lt;=<span class=\"number\">1</span>;k++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum1 =<span class=\"number\">0</span> ,sum2=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cn[k];i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;bx[k][i]&lt;&lt;&#x27; &#x27;&lt;&lt;by[k][i]&lt;&lt;endl;</span></span><br><span class=\"line\">            ans += (i<span class=\"number\">-1</span>) * (bx[k][i]+by[k][i]) - sum1-sum2;</span><br><span class=\"line\">            sum1 += bx[k][i];</span><br><span class=\"line\">            sum2 += by[k][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"树上最短回文问题","date":"2024-08-14T11:39:46.000Z","_content":"## 题意\n\n给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？\n\n<!--more-->\n\n## 题解\n\n不想看回文的读者请跳转到“真的题解”\n\n看到回文，回顾回文！下面以数组为例子，求最长回文字符串。\n\n回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度\n\n回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。\n\n回文哈希二分：对于i，从前从后hax，二分回文长度。\n\n二分如下：\n\n```cpp\null get(ull h[], ull l, ull r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = p[i-1] * P;\n    int t =0;\n    while(cin>>s,s!=\"END\") {\n        n = s.size();\n\n        n *= 2;\n        s.resize(n);\n        for (int i = n; i; i -= 2)\n        {\n            s[i] = s[i / 2];\n            s[i - 1] = '#';\n        }\n        s = '#' + s;\n        n++;\n        // cout<<n<<endl;\n        // cout<<s<<nline;\n\n        for(int i=0;i<n;i++)if(!i) ph[i] = s[i];else ph[i] = ph[i-1] * P + s[i];\n        for(int i=n-1;~i;i--)if(i==n-1) rh[i] = s[i];else rh[i] = rh[i+1] * P + s[i];\n\n        int ans = 1;\n        for (int i = 1; i <= n; i ++ )\n        {\n            ull r = min(i - 1, n - i);\n            if (ans >= r || get(ph, i - ans, i - 1) != get(rh, n - (i + ans) + 1, n - i)) continue;\n            while (ans <= r && get(ph, i - ans, i - 1) == get(rh, n - (i + ans) + 1, n - i)) ans ++ ;\n            ans -- ;\n        }\n        cout<<\"Case \" << ++t<<\": \"<<ans<<endl;\n    }\n}\n```\n\n题解要开始加速了！\n\n首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化$$log_2n$$的解法！\n\n注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！\n\n```cpp\null ans = 1;\nfor (int i = 1; i <= n; i ++ )\n{\n  ull r = min(i - 1, n - i);\n  if (ans >= r || get(h1, i - ans, i - 1) != get(h2, n - (i + ans) + 1, n - i)) continue;\n  while (ans <= r && get(h1, i - ans, i - 1) == get(h2, n - (i + ans) + 1, n - i)) ans ++ ;\n  ans -- ;\n}\n```\n\n最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。\n\n简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R 回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）\n\n整个该算法的重点在于：“回文对称”！\n\n![img](https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg)\n\n即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。\n\n若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。\n\n若i-w[i_mirror]>=0即i_mirror的回文子串碰到了边界，则中心扩展i\n\n```cpp\n// 马拉车算法\npublic String longestPalindrome2(String s) {\n    String T = preProcess(s);\n    int n = T.length();\n    int[] P = new int[n];\n    int C = 0, R = 0;\n    for (int i = 1; i < n - 1; i++) {\n        int i_mirror = 2 * C - i;\n        if (R > i) {\n            P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R\n        } else {\n            P[i] = 0;// 等于 R 的情况\n        }\n\n        // 碰到之前讲的三种情况时候，需要利用中心扩展法\n        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\n            P[i]++;\n        }\n\n        // 判断是否需要更新 R\n        if (i + P[i] > R) {\n            C = i;\n            R = i + P[i];\n        }\n\n    }\n   \\\\代码source :https://zhuanlan.zhihu.com/p/70532099\n```\n\n## 真的题解\n\n上面讲了一串，最后还得是哈！希！，字符串，哈！希！\n\n最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。\n\n注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大$$n^2$$）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！\n\n但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。\n\n但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。\n\n```cpp\nvoid add(int a,int b) {\n    e[a].pb(b);\n    e[b].pb(a);\n}\n\nint qmi(int a,int b,int mod){\n    int res=1%mod;\n    while(b){\n        if(b&1) res=res*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return res;\n}\n\nvoid dfs1(int u = 1) {\n    siz[u] = 1;\n    int mx = 0;\n    for(int& v: e[u]) {\n        if(v==fa[u])continue;\n\n        depth[v] = depth[u] + 1;\n        ph[v]=(ph[u]*P%MOD+(s[v]-'a'+1))%MOD;\n        rh[v]=(rh[u]+p[depth[v]-1]*(s[v]-'a'+1)% MOD)%MOD;\n\n        f[v][0] = u;\n        for(int i=1;i<=20;i++)\n            f[v][i] = f[f[v][i-1]][i-1];\n        dfs1(v);\n        siz[u] += siz[v];\n        if(siz[v] > mx) {\n            mx = siz[v];hs[u] = v;\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int t = 1) {\n    len[t] ++;\n    top[u] = t;\n    if(siz[u] == 1) return ;\n    dfs2(hs[u],t);\n\n    for(int v: e[u]) {\n        if(v!=hs[u]&&v!=fa[u]) {\n            dfs2(v,v);\n        }\n    }\n}\n\nint lca(int a,int b) {\n    while(top[a] != top[b]) {\n        if(depth[top[a]] < depth[top[b]])swap(a,b);\n        a = fa[top[a]];\n    }\n    if(depth[a] < depth[b]) swap(a,b);\n    return b;\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = (p[i-1] * P) % MOD;\n    cin>>n;\n    cin>>s;\n    s = ' ' + s;\n    depth[1] = 1;\n    for(int i=1;i<=n;i++) {\n        cin>>fa[i];\n        if(fa[i]) add(i,fa[i]);\n        else fa[i] = -1;\n    }\n\n\n    ph[1]=s[1]-'a'+1,rh[1]=s[1]-'a'+1;\n    dfs1();dfs2();\n\n    cin>>m;\n    while(m--) {\n        int a,b;cin>>a>>b;\n        if(depth[a] < depth[b]) swap(a,b);\n        lc = lca(a,b);\n\n        int f=lca(a,b);\n        int p1=((rh[a]-rh[fa[f]]*qmi(p[depth[f]-1],MOD-2,MOD)%MOD)+MOD) %MOD;\n        int p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;\n        int ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;\n        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*qmi(p[depth[f]-1],MOD-2,MOD)%MOD;\n        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;\n        int ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;\n        cout<<(ans1==ans2?\"YES\\n\":\"NO\\n\");\n        cout<<f<<endl;\n        cout<<ans1<<' '<<ans2<<nline;\n    }\n}\n```\n\n","source":"_posts/树上回文问题.md","raw":"---\ntitle: 树上最短回文问题\ndate: 2024-08-14 19:39:46\ntags: [算法, 树问题，哈希算法]\ncategories: \n\t- 算法\n\t- 图论\n\t- 图论中的回文问题\n---\n## 题意\n\n给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？\n\n<!--more-->\n\n## 题解\n\n不想看回文的读者请跳转到“真的题解”\n\n看到回文，回顾回文！下面以数组为例子，求最长回文字符串。\n\n回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度\n\n回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。\n\n回文哈希二分：对于i，从前从后hax，二分回文长度。\n\n二分如下：\n\n```cpp\null get(ull h[], ull l, ull r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = p[i-1] * P;\n    int t =0;\n    while(cin>>s,s!=\"END\") {\n        n = s.size();\n\n        n *= 2;\n        s.resize(n);\n        for (int i = n; i; i -= 2)\n        {\n            s[i] = s[i / 2];\n            s[i - 1] = '#';\n        }\n        s = '#' + s;\n        n++;\n        // cout<<n<<endl;\n        // cout<<s<<nline;\n\n        for(int i=0;i<n;i++)if(!i) ph[i] = s[i];else ph[i] = ph[i-1] * P + s[i];\n        for(int i=n-1;~i;i--)if(i==n-1) rh[i] = s[i];else rh[i] = rh[i+1] * P + s[i];\n\n        int ans = 1;\n        for (int i = 1; i <= n; i ++ )\n        {\n            ull r = min(i - 1, n - i);\n            if (ans >= r || get(ph, i - ans, i - 1) != get(rh, n - (i + ans) + 1, n - i)) continue;\n            while (ans <= r && get(ph, i - ans, i - 1) == get(rh, n - (i + ans) + 1, n - i)) ans ++ ;\n            ans -- ;\n        }\n        cout<<\"Case \" << ++t<<\": \"<<ans<<endl;\n    }\n}\n```\n\n题解要开始加速了！\n\n首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化$$log_2n$$的解法！\n\n注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！\n\n```cpp\null ans = 1;\nfor (int i = 1; i <= n; i ++ )\n{\n  ull r = min(i - 1, n - i);\n  if (ans >= r || get(h1, i - ans, i - 1) != get(h2, n - (i + ans) + 1, n - i)) continue;\n  while (ans <= r && get(h1, i - ans, i - 1) == get(h2, n - (i + ans) + 1, n - i)) ans ++ ;\n  ans -- ;\n}\n```\n\n最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。\n\n简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R 回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）\n\n整个该算法的重点在于：“回文对称”！\n\n![img](https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg)\n\n即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。\n\n若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。\n\n若i-w[i_mirror]>=0即i_mirror的回文子串碰到了边界，则中心扩展i\n\n```cpp\n// 马拉车算法\npublic String longestPalindrome2(String s) {\n    String T = preProcess(s);\n    int n = T.length();\n    int[] P = new int[n];\n    int C = 0, R = 0;\n    for (int i = 1; i < n - 1; i++) {\n        int i_mirror = 2 * C - i;\n        if (R > i) {\n            P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R\n        } else {\n            P[i] = 0;// 等于 R 的情况\n        }\n\n        // 碰到之前讲的三种情况时候，需要利用中心扩展法\n        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\n            P[i]++;\n        }\n\n        // 判断是否需要更新 R\n        if (i + P[i] > R) {\n            C = i;\n            R = i + P[i];\n        }\n\n    }\n   \\\\代码source :https://zhuanlan.zhihu.com/p/70532099\n```\n\n## 真的题解\n\n上面讲了一串，最后还得是哈！希！，字符串，哈！希！\n\n最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。\n\n注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大$$n^2$$）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！\n\n但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。\n\n但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。\n\n```cpp\nvoid add(int a,int b) {\n    e[a].pb(b);\n    e[b].pb(a);\n}\n\nint qmi(int a,int b,int mod){\n    int res=1%mod;\n    while(b){\n        if(b&1) res=res*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return res;\n}\n\nvoid dfs1(int u = 1) {\n    siz[u] = 1;\n    int mx = 0;\n    for(int& v: e[u]) {\n        if(v==fa[u])continue;\n\n        depth[v] = depth[u] + 1;\n        ph[v]=(ph[u]*P%MOD+(s[v]-'a'+1))%MOD;\n        rh[v]=(rh[u]+p[depth[v]-1]*(s[v]-'a'+1)% MOD)%MOD;\n\n        f[v][0] = u;\n        for(int i=1;i<=20;i++)\n            f[v][i] = f[f[v][i-1]][i-1];\n        dfs1(v);\n        siz[u] += siz[v];\n        if(siz[v] > mx) {\n            mx = siz[v];hs[u] = v;\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int t = 1) {\n    len[t] ++;\n    top[u] = t;\n    if(siz[u] == 1) return ;\n    dfs2(hs[u],t);\n\n    for(int v: e[u]) {\n        if(v!=hs[u]&&v!=fa[u]) {\n            dfs2(v,v);\n        }\n    }\n}\n\nint lca(int a,int b) {\n    while(top[a] != top[b]) {\n        if(depth[top[a]] < depth[top[b]])swap(a,b);\n        a = fa[top[a]];\n    }\n    if(depth[a] < depth[b]) swap(a,b);\n    return b;\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = (p[i-1] * P) % MOD;\n    cin>>n;\n    cin>>s;\n    s = ' ' + s;\n    depth[1] = 1;\n    for(int i=1;i<=n;i++) {\n        cin>>fa[i];\n        if(fa[i]) add(i,fa[i]);\n        else fa[i] = -1;\n    }\n\n\n    ph[1]=s[1]-'a'+1,rh[1]=s[1]-'a'+1;\n    dfs1();dfs2();\n\n    cin>>m;\n    while(m--) {\n        int a,b;cin>>a>>b;\n        if(depth[a] < depth[b]) swap(a,b);\n        lc = lca(a,b);\n\n        int f=lca(a,b);\n        int p1=((rh[a]-rh[fa[f]]*qmi(p[depth[f]-1],MOD-2,MOD)%MOD)+MOD) %MOD;\n        int p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;\n        int ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;\n        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*qmi(p[depth[f]-1],MOD-2,MOD)%MOD;\n        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;\n        int ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;\n        cout<<(ans1==ans2?\"YES\\n\":\"NO\\n\");\n        cout<<f<<endl;\n        cout<<ans1<<' '<<ans2<<nline;\n    }\n}\n```\n\n","slug":"树上回文问题","published":1,"updated":"2024-08-14T13:39:14.786Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjah001hlowvh35o48cx","content":"<h2 id=\"题意\">题意</h2>\r\n<p>给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>不想看回文的读者请跳转到“真的题解”</p>\r\n<p>看到回文，回顾回文！下面以数组为例子，求最长回文字符串。</p>\r\n<p>回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度</p>\r\n<p>回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。</p>\r\n<p>回文哈希二分：对于i，从前从后hax，二分回文长度。</p>\r\n<p>二分如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ull <span class=\"title\">get</span><span class=\"params\">(ull h[], ull l, ull r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h[r] - h[l - <span class=\"number\">1</span>] * p[r - l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = p[i<span class=\"number\">-1</span>] * P;</span><br><span class=\"line\">    <span class=\"type\">int</span> t =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;s,s!=<span class=\"string\">&quot;END&quot;</span>) &#123;</span><br><span class=\"line\">        n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i; i -= <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s[i] = s[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">            s[i - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s = <span class=\"string\">&#x27;#&#x27;</span> + s;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;s&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"keyword\">if</span>(!i) ph[i] = s[i];<span class=\"keyword\">else</span> ph[i] = ph[i<span class=\"number\">-1</span>] * P + s[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n<span class=\"number\">-1</span>;~i;i--)<span class=\"keyword\">if</span>(i==n<span class=\"number\">-1</span>) rh[i] = s[i];<span class=\"keyword\">else</span> rh[i] = rh[i<span class=\"number\">+1</span>] * P + s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">            ans -- ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case &quot;</span> &lt;&lt; ++t&lt;&lt;<span class=\"string\">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>题解要开始加速了！</p>\r\n<p>首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化<span\r\nclass=\"math display\">\\[log_2n\\]</span>的解法！</p>\r\n<p>注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ull ans = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">  ans -- ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。</p>\r\n<p>简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R\r\n回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）</p>\r\n<p>整个该算法的重点在于：“回文对称”！</p>\r\n<figure>\r\n<img\r\nsrc=\"https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。</p>\r\n<p>若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。</p>\r\n<p>若i-w[i_mirror]&gt;=0即i_mirror的回文子串碰到了边界，则中心扩展i</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 马拉车算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome2</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    String T = <span class=\"built_in\">preProcess</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = T.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] P = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n];</span><br><span class=\"line\">    <span class=\"type\">int</span> C = <span class=\"number\">0</span>, R = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i_mirror = <span class=\"number\">2</span> * C - i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (R &gt; i) &#123;</span><br><span class=\"line\">            P[i] = Math.<span class=\"built_in\">min</span>(R - i, P[i_mirror]);<span class=\"comment\">// 防止超出 R</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            P[i] = <span class=\"number\">0</span>;<span class=\"comment\">// 等于 R 的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T.<span class=\"built_in\">charAt</span>(i + <span class=\"number\">1</span> + P[i]) == T.<span class=\"built_in\">charAt</span>(i - <span class=\"number\">1</span> - P[i])) &#123;</span><br><span class=\"line\">            P[i]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否需要更新 R</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + P[i] &gt; R) &#123;</span><br><span class=\"line\">            C = i;</span><br><span class=\"line\">            R = i + P[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \\\\代码source :https:<span class=\"comment\">//zhuanlan.zhihu.com/p/70532099</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"真的题解\">真的题解</h2>\r\n<p>上面讲了一串，最后还得是哈！希！，字符串，哈！希！</p>\r\n<p>最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。</p>\r\n<p>注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大<span\r\nclass=\"math display\">\\[n^2\\]</span>）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！</p>\r\n<p>但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。</p>\r\n<p>但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">    e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">qmi</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> mod)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">1</span>%mod;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res=res*a%mod;</span><br><span class=\"line\">        a=a*a%mod;</span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    siz[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span>&amp; v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==fa[u])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        depth[v] = depth[u] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        ph[v]=(ph[u]*P%MOD+(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>))%MOD;</span><br><span class=\"line\">        rh[v]=(rh[u]+p[depth[v]<span class=\"number\">-1</span>]*(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>)% MOD)%MOD;</span><br><span class=\"line\"></span><br><span class=\"line\">        f[v][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">20</span>;i++)</span><br><span class=\"line\">            f[v][i] = f[f[v][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">dfs1</span>(v);</span><br><span class=\"line\">        siz[u] += siz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[v] &gt; mx) &#123;</span><br><span class=\"line\">            mx = siz[v];hs[u] = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>, <span class=\"type\">int</span> t = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    len[t] ++;</span><br><span class=\"line\">    top[u] = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(siz[u] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(hs[u],t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v!=hs[u]&amp;&amp;v!=fa[u]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs2</span>(v,v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[a] != top[b]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[top[a]] &lt; depth[top[b]])<span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        a = fa[top[a]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = (p[i<span class=\"number\">-1</span>] * P) % MOD;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    s = <span class=\"string\">&#x27; &#x27;</span> + s;</span><br><span class=\"line\">    depth[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;fa[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fa[i]) <span class=\"built_in\">add</span>(i,fa[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> fa[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    ph[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>,rh[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dfs1</span>();<span class=\"built_in\">dfs2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        lc = <span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> f=<span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\">        <span class=\"type\">int</span> p1=((rh[a]-rh[fa[f]]*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD)+MOD) %MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD;</span><br><span class=\"line\">        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        cout&lt;&lt;(ans1==ans2?<span class=\"string\">&quot;YES\\n&quot;</span>:<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        cout&lt;&lt;f&lt;&lt;endl;</span><br><span class=\"line\">        cout&lt;&lt;ans1&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;nline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1668,"excerpt":"<h2 id=\"题意\">题意</h2>\r\n<p>给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？</p>","more":"<h2 id=\"题解\">题解</h2>\r\n<p>不想看回文的读者请跳转到“真的题解”</p>\r\n<p>看到回文，回顾回文！下面以数组为例子，求最长回文字符串。</p>\r\n<p>回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度</p>\r\n<p>回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。</p>\r\n<p>回文哈希二分：对于i，从前从后hax，二分回文长度。</p>\r\n<p>二分如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ull <span class=\"title\">get</span><span class=\"params\">(ull h[], ull l, ull r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h[r] - h[l - <span class=\"number\">1</span>] * p[r - l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = p[i<span class=\"number\">-1</span>] * P;</span><br><span class=\"line\">    <span class=\"type\">int</span> t =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;s,s!=<span class=\"string\">&quot;END&quot;</span>) &#123;</span><br><span class=\"line\">        n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i; i -= <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s[i] = s[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">            s[i - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s = <span class=\"string\">&#x27;#&#x27;</span> + s;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;s&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"keyword\">if</span>(!i) ph[i] = s[i];<span class=\"keyword\">else</span> ph[i] = ph[i<span class=\"number\">-1</span>] * P + s[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n<span class=\"number\">-1</span>;~i;i--)<span class=\"keyword\">if</span>(i==n<span class=\"number\">-1</span>) rh[i] = s[i];<span class=\"keyword\">else</span> rh[i] = rh[i<span class=\"number\">+1</span>] * P + s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">            ans -- ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case &quot;</span> &lt;&lt; ++t&lt;&lt;<span class=\"string\">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>题解要开始加速了！</p>\r\n<p>首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化<span\r\nclass=\"math display\">\\[log_2n\\]</span>的解法！</p>\r\n<p>注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ull ans = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">  ans -- ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。</p>\r\n<p>简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R\r\n回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）</p>\r\n<p>整个该算法的重点在于：“回文对称”！</p>\r\n<figure>\r\n<img\r\nsrc=\"https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。</p>\r\n<p>若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。</p>\r\n<p>若i-w[i_mirror]&gt;=0即i_mirror的回文子串碰到了边界，则中心扩展i</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 马拉车算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome2</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    String T = <span class=\"built_in\">preProcess</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = T.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] P = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n];</span><br><span class=\"line\">    <span class=\"type\">int</span> C = <span class=\"number\">0</span>, R = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i_mirror = <span class=\"number\">2</span> * C - i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (R &gt; i) &#123;</span><br><span class=\"line\">            P[i] = Math.<span class=\"built_in\">min</span>(R - i, P[i_mirror]);<span class=\"comment\">// 防止超出 R</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            P[i] = <span class=\"number\">0</span>;<span class=\"comment\">// 等于 R 的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T.<span class=\"built_in\">charAt</span>(i + <span class=\"number\">1</span> + P[i]) == T.<span class=\"built_in\">charAt</span>(i - <span class=\"number\">1</span> - P[i])) &#123;</span><br><span class=\"line\">            P[i]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否需要更新 R</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + P[i] &gt; R) &#123;</span><br><span class=\"line\">            C = i;</span><br><span class=\"line\">            R = i + P[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \\\\代码source :https:<span class=\"comment\">//zhuanlan.zhihu.com/p/70532099</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"真的题解\">真的题解</h2>\r\n<p>上面讲了一串，最后还得是哈！希！，字符串，哈！希！</p>\r\n<p>最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。</p>\r\n<p>注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大<span\r\nclass=\"math display\">\\[n^2\\]</span>）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！</p>\r\n<p>但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。</p>\r\n<p>但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">    e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">qmi</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> mod)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">1</span>%mod;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res=res*a%mod;</span><br><span class=\"line\">        a=a*a%mod;</span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    siz[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span>&amp; v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==fa[u])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        depth[v] = depth[u] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        ph[v]=(ph[u]*P%MOD+(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>))%MOD;</span><br><span class=\"line\">        rh[v]=(rh[u]+p[depth[v]<span class=\"number\">-1</span>]*(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>)% MOD)%MOD;</span><br><span class=\"line\"></span><br><span class=\"line\">        f[v][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">20</span>;i++)</span><br><span class=\"line\">            f[v][i] = f[f[v][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">dfs1</span>(v);</span><br><span class=\"line\">        siz[u] += siz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[v] &gt; mx) &#123;</span><br><span class=\"line\">            mx = siz[v];hs[u] = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>, <span class=\"type\">int</span> t = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    len[t] ++;</span><br><span class=\"line\">    top[u] = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(siz[u] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(hs[u],t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v!=hs[u]&amp;&amp;v!=fa[u]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs2</span>(v,v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[a] != top[b]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[top[a]] &lt; depth[top[b]])<span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        a = fa[top[a]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = (p[i<span class=\"number\">-1</span>] * P) % MOD;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    s = <span class=\"string\">&#x27; &#x27;</span> + s;</span><br><span class=\"line\">    depth[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;fa[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fa[i]) <span class=\"built_in\">add</span>(i,fa[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> fa[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    ph[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>,rh[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dfs1</span>();<span class=\"built_in\">dfs2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        lc = <span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> f=<span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\">        <span class=\"type\">int</span> p1=((rh[a]-rh[fa[f]]*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD)+MOD) %MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD;</span><br><span class=\"line\">        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        cout&lt;&lt;(ans1==ans2?<span class=\"string\">&quot;YES\\n&quot;</span>:<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        cout&lt;&lt;f&lt;&lt;endl;</span><br><span class=\"line\">        cout&lt;&lt;ans1&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;nline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题","date":"2024-08-14T11:30:37.000Z","_content":"# 题意：\n\n给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。\n\n你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个**连续的子段**，然后从该子段中删除**所有**元素，**除**该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。\n\n如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。\n\n<!--more-->\n\n# 题解：\n\n根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。\n\n考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]<a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l_{a_i}$下标为j，则小于j且大于$l_{a_j}$的下标k的下标idx均无法转移至i，显然$l_{a_i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l_{a_x}$则无法转移到i。\n\n总结状态转移为$f_i = \\sum_{k={l_{a_i}+1}}^{i-1} f_k + \\sum_{k=l^x(l_{a_i})}^{k>0}f_{k}$\n\n前缀和处理即可。\n\n```cpp\n\tvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n\n    s[top] = {-1,-1};\n    for(int i = 1;i <= n;i++) {\n        while(top && s[top].x > a[i]) top--;\n        l[i] = s[top].y;\n        s[++top] = {a[i],i};\n    }\n\n    // for(int i=1;i<=n;i++) cout<<l[i]<<' ';\n    // cout<<endl;\n\n    for(int i=0;i<=n;i++) pre1[i] = pre2[i] = 0;\n\n    f[0] = 1;\n    pre1[0] = 1;\n    for(int i=1;i<=n;i++) {\n        if(l[i]!=-1) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;\n        int t = l[i] == -1 ? 0: pre1[l[i]];\n        f[i] = (pre1[i-1] - t) % MOD ;\n        // cout<<(pre1[i-1] - t)<<' ';\n        f[i] += pre2[i];\n\n        pre1[i] = pre1[i-1] + f[i] % MOD;\n        // cout<<i<<' '<<pre1[i]<<' '<<pre2[i]<<' '<<f[i]<<nline;\n    }\n\n    int mi = 1e18,ans = 0;\n    for(int i=n; i>=1; i--) {\n        mi = min(mi,a[i]);\n        if(mi==a[i]) {\n            ans = (ans + f[i]) % MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n","source":"_posts/状态转移习题1.md","raw":"---\ntitle: 状态转移习题\ndate: 2024-08-14 19:30:37\ntags: [算法, 状态转移]\ncategories: \n\t- 算法\n\t- 状态转移\n---\n# 题意：\n\n给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。\n\n你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个**连续的子段**，然后从该子段中删除**所有**元素，**除**该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。\n\n如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。\n\n<!--more-->\n\n# 题解：\n\n根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。\n\n考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]<a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l_{a_i}$下标为j，则小于j且大于$l_{a_j}$的下标k的下标idx均无法转移至i，显然$l_{a_i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l_{a_x}$则无法转移到i。\n\n总结状态转移为$f_i = \\sum_{k={l_{a_i}+1}}^{i-1} f_k + \\sum_{k=l^x(l_{a_i})}^{k>0}f_{k}$\n\n前缀和处理即可。\n\n```cpp\n\tvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n\n    s[top] = {-1,-1};\n    for(int i = 1;i <= n;i++) {\n        while(top && s[top].x > a[i]) top--;\n        l[i] = s[top].y;\n        s[++top] = {a[i],i};\n    }\n\n    // for(int i=1;i<=n;i++) cout<<l[i]<<' ';\n    // cout<<endl;\n\n    for(int i=0;i<=n;i++) pre1[i] = pre2[i] = 0;\n\n    f[0] = 1;\n    pre1[0] = 1;\n    for(int i=1;i<=n;i++) {\n        if(l[i]!=-1) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;\n        int t = l[i] == -1 ? 0: pre1[l[i]];\n        f[i] = (pre1[i-1] - t) % MOD ;\n        // cout<<(pre1[i-1] - t)<<' ';\n        f[i] += pre2[i];\n\n        pre1[i] = pre1[i-1] + f[i] % MOD;\n        // cout<<i<<' '<<pre1[i]<<' '<<pre2[i]<<' '<<f[i]<<nline;\n    }\n\n    int mi = 1e18,ans = 0;\n    for(int i=n; i>=1; i--) {\n        mi = min(mi,a[i]);\n        if(mi==a[i]) {\n            ans = (ans + f[i]) % MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n","slug":"状态转移习题1","published":1,"updated":"2024-08-14T13:39:18.757Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjai001jlowvel3y9co9","content":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。</p>\r\n<p>你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p\r\n中选择一个<strong>连续的子段</strong>，然后从该子段中删除<strong>所有</strong>元素，<strong>除</strong>该子段中最小的元素。例如，如果选择p\r\n= [3, 1, 4, 7, 5, 2,\r\n6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3,\r\n1, 2, 6]。</p>\r\n<p>如果数组\r\na可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a\r\n就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留\r\n𝑎𝑖 的情况下的贡献值。</p>\r\n<p>考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖\r\n是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为<span\r\nclass=\"math inline\">\\(dp(i) +=\r\ndp(j)(其中a[j]&lt;a[i])\\)</span>另外一种情况则是，不对i进行操作。考虑上一个比<span\r\nclass=\"math inline\">\\(a[i]\\)</span>小的数为<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>下标为j，则小于j且大于<span\r\nclass=\"math inline\">\\(l_{a_j}\\)</span>的下标k的下标idx均无法转移至i，显然<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于<span\r\nclass=\"math inline\">\\(l_{a_x}\\)</span>则无法转移到i。</p>\r\n<p>总结状态转移为<span class=\"math inline\">\\(f_i =\r\n\\sum_{k={l_{a_i}+1}}^{i-1} f_k +\r\n\\sum_{k=l^x(l_{a_i})}^{k&gt;0}f_{k}\\)</span></p>\r\n<p>前缀和处理即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    s[top] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(top &amp;&amp; s[top].x &gt; a[i]) top--;</span><br><span class=\"line\">        l[i] = s[top].y;</span><br><span class=\"line\">        s[++top] = &#123;a[i],i&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;l[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++) pre1[i] = pre2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    pre1[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l[i]!=<span class=\"number\">-1</span>) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = l[i] == <span class=\"number\">-1</span> ? <span class=\"number\">0</span>: pre1[l[i]];</span><br><span class=\"line\">        f[i] = (pre1[i<span class=\"number\">-1</span>] - t) % MOD ;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;(pre1[i-1] - t)&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">        f[i] += pre2[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        pre1[i] = pre1[i<span class=\"number\">-1</span>] + f[i] % MOD;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;pre1[i]&lt;&lt;&#x27; &#x27;&lt;&lt;pre2[i]&lt;&lt;&#x27; &#x27;&lt;&lt;f[i]&lt;&lt;nline;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mi = <span class=\"number\">1e18</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n; i&gt;=<span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        mi = <span class=\"built_in\">min</span>(mi,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mi==a[i]) &#123;</span><br><span class=\"line\">            ans = (ans + f[i]) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":708,"excerpt":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。</p>\r\n<p>你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p\r\n中选择一个<strong>连续的子段</strong>，然后从该子段中删除<strong>所有</strong>元素，<strong>除</strong>该子段中最小的元素。例如，如果选择p\r\n= [3, 1, 4, 7, 5, 2,\r\n6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3,\r\n1, 2, 6]。</p>\r\n<p>如果数组\r\na可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a\r\n就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。</p>","more":"<h1 id=\"题解\">题解：</h1>\r\n<p>根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留\r\n𝑎𝑖 的情况下的贡献值。</p>\r\n<p>考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖\r\n是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为<span\r\nclass=\"math inline\">\\(dp(i) +=\r\ndp(j)(其中a[j]&lt;a[i])\\)</span>另外一种情况则是，不对i进行操作。考虑上一个比<span\r\nclass=\"math inline\">\\(a[i]\\)</span>小的数为<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>下标为j，则小于j且大于<span\r\nclass=\"math inline\">\\(l_{a_j}\\)</span>的下标k的下标idx均无法转移至i，显然<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于<span\r\nclass=\"math inline\">\\(l_{a_x}\\)</span>则无法转移到i。</p>\r\n<p>总结状态转移为<span class=\"math inline\">\\(f_i =\r\n\\sum_{k={l_{a_i}+1}}^{i-1} f_k +\r\n\\sum_{k=l^x(l_{a_i})}^{k&gt;0}f_{k}\\)</span></p>\r\n<p>前缀和处理即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    s[top] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(top &amp;&amp; s[top].x &gt; a[i]) top--;</span><br><span class=\"line\">        l[i] = s[top].y;</span><br><span class=\"line\">        s[++top] = &#123;a[i],i&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;l[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++) pre1[i] = pre2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    pre1[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l[i]!=<span class=\"number\">-1</span>) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = l[i] == <span class=\"number\">-1</span> ? <span class=\"number\">0</span>: pre1[l[i]];</span><br><span class=\"line\">        f[i] = (pre1[i<span class=\"number\">-1</span>] - t) % MOD ;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;(pre1[i-1] - t)&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">        f[i] += pre2[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        pre1[i] = pre1[i<span class=\"number\">-1</span>] + f[i] % MOD;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;pre1[i]&lt;&lt;&#x27; &#x27;&lt;&lt;pre2[i]&lt;&lt;&#x27; &#x27;&lt;&lt;f[i]&lt;&lt;nline;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mi = <span class=\"number\">1e18</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n; i&gt;=<span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        mi = <span class=\"built_in\">min</span>(mi,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mi==a[i]) &#123;</span><br><span class=\"line\">            ans = (ans + f[i]) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题2","date":"2024-08-14T11:32:13.000Z","_content":"# 题意：\n\n给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。\n\n首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。\n\n然后，你必须使数组中的所有元素相等。一开始，你选择一个**正**整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。**注意， x 在所有操作中都是一样的**。\n\n选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？\n\n<!--more-->\n\n# 题解：\n\n容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。\n\n可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。\n\n```\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int mx = -INF;\n    for(int i=1;i<=n;i++) {\n        mx = max(mx,a[i]);\n    }\n\n    for(int i=1;i<=n;i++) d[i] = mx - a[i];\n\n    int gd = 0;\n    for(int i=1;i<=n;i++) gd = __gcd(d[i],gd);\n\n    if(!gd) {cout<<1<<endl;return ;}\n\n    ll sum = 0;\n    set<int> S;\n    for(int i=1;i<=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);\n    int t = 1;\n    while(1) if(S.count(t)) t++;else break;\n    cout<<sum + t<<endl;\n}\n```","source":"_posts/状态转移习题2.md","raw":"---\ntitle: 状态转移习题2\ndate: 2024-08-14 19:32:13\ntags: [算法, 状态转移]\ncategories: \n\t- 算法\n\t- 状态转移\n---\n# 题意：\n\n给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。\n\n首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。\n\n然后，你必须使数组中的所有元素相等。一开始，你选择一个**正**整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。**注意， x 在所有操作中都是一样的**。\n\n选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？\n\n<!--more-->\n\n# 题解：\n\n容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。\n\n可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。\n\n```\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int mx = -INF;\n    for(int i=1;i<=n;i++) {\n        mx = max(mx,a[i]);\n    }\n\n    for(int i=1;i<=n;i++) d[i] = mx - a[i];\n\n    int gd = 0;\n    for(int i=1;i<=n;i++) gd = __gcd(d[i],gd);\n\n    if(!gd) {cout<<1<<endl;return ;}\n\n    ll sum = 0;\n    set<int> S;\n    for(int i=1;i<=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);\n    int t = 1;\n    while(1) if(S.count(t)) t++;else break;\n    cout<<sum + t<<endl;\n}\n```","slug":"状态转移习题2","published":1,"updated":"2024-08-14T13:39:21.942Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjai001mlowvazzj1jki","content":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个整数数组 1, 2,…, ，它的所有元素都是不同的。</p>\r\n<p>首先，要求你在数组中再插入一个整数 an+1 。 an +1 不应等于 a1, a2,…,\r\nan中的任何一个。</p>\r\n<p>然后，你必须使数组中的所有元素相等。一开始，你选择一个<strong>正</strong>整数\r\nx。在一次操作中，你将 x 恰好加到数组的一个元素上。<strong>注意， x\r\n在所有操作中都是一样的</strong>。</p>\r\n<p>选择 +1 和 x 后，使所有元素相等的最小操作次数是多少？</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于\r\n∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖)\r\n（mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。</p>\r\n<p>可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void slove()&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int mx = -INF;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        mx = max(mx,a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) d[i] = mx - a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int gd = 0;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) gd = __gcd(d[i],gd);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!gd) &#123;cout&lt;&lt;1&lt;&lt;endl;return ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll sum = 0;</span><br><span class=\"line\">    set&lt;int&gt; S;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);</span><br><span class=\"line\">    int t = 1;</span><br><span class=\"line\">    while(1) if(S.count(t)) t++;else break;</span><br><span class=\"line\">    cout&lt;&lt;sum + t&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":355,"excerpt":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个整数数组 1, 2,…, ，它的所有元素都是不同的。</p>\r\n<p>首先，要求你在数组中再插入一个整数 an+1 。 an +1 不应等于 a1, a2,…,\r\nan中的任何一个。</p>\r\n<p>然后，你必须使数组中的所有元素相等。一开始，你选择一个<strong>正</strong>整数\r\nx。在一次操作中，你将 x 恰好加到数组的一个元素上。<strong>注意， x\r\n在所有操作中都是一样的</strong>。</p>\r\n<p>选择 +1 和 x 后，使所有元素相等的最小操作次数是多少？</p>","more":"<h1 id=\"题解\">题解：</h1>\r\n<p>容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于\r\n∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖)\r\n（mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。</p>\r\n<p>可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void slove()&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int mx = -INF;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        mx = max(mx,a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) d[i] = mx - a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int gd = 0;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) gd = __gcd(d[i],gd);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!gd) &#123;cout&lt;&lt;1&lt;&lt;endl;return ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll sum = 0;</span><br><span class=\"line\">    set&lt;int&gt; S;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);</span><br><span class=\"line\">    int t = 1;</span><br><span class=\"line\">    while(1) if(S.count(t)) t++;else break;</span><br><span class=\"line\">    cout&lt;&lt;sum + t&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题3","date":"2024-08-14T11:38:14.000Z","_content":"## 题意：\n\n对一个数组的所有非空子区间，计算这个公式$$w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus a_j $$的和。\n\n<!--more-->\n\n## 题解：\n\n非常经典的题目，看见了就再巩固一下。\n\n1. 拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\\lceil log_2mx\\rceil$个数组。计算每一位的贡献。\n\n当拆位后原式子会变为这样的\n$$\nallW = \\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil log_2mx\\rceil}cnt(a_{i-x} != a_{x})\n$$\n这个复杂度仍然是爆炸的，因此需要继续优化\n\n很容易想到的一个优化就是，对于$$a_i \\oplus a_j$$他是满足交换律的，即$$a_i \\oplus a_j = a_j \\oplus a_i$$因此我们仅需要计算单边值即可（然后乘2。\n\n因此将原有的式子改写$$w =2 \\times (\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) $$虽然对于$$a_i$$本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。\n\n再转头考虑所有子区间的问题，一个数组的所有子区间显然是$$n^2$$级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为$$i\\times (n-j+1)$$（下标从1开始），则对任意i,j，其贡献值为以下公式\n$$\nw(bt,{i,j}) = (i\\times (n-j+1) * (1<<bt) * (bit(x,a_i)\\not=bit(x,a_j))\n$$\n施展数学的神奇魔法！\n\n提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算$$a_j$$ 与$$a_i|i<j$$的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。\n\n最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。\n\n```cpp\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n\n    ll ans = 0;\n    for(int bt = 0;bt <=29;bt++) {\n        ll s1=0,s2 =0;\n        for(int i=1;i<=n;i++) {\n            if(a[i] >>bt&1) {\n                ans = (ans + s2 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s1 += i;\n                s1 %= MOD;\n            }\n            else {\n                ans = (ans + s1 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s2 += i;\n                s2 %= MOD;\n            }\n        }\n    }\n    cout<<(2ll * ans)%MOD<<endl;\n}\n```\n\n不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。","source":"_posts/状态转移习题3.md","raw":"---\ntitle: 状态转移习题3\ndate: 2024-08-14 19:38:14\ntags: [算法, 状态转移, 异或问题]\ncategories: \n\t- 算法\n\t- 状态转移\n\t- 状态转移中的异或问题\n---\n## 题意：\n\n对一个数组的所有非空子区间，计算这个公式$$w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus a_j $$的和。\n\n<!--more-->\n\n## 题解：\n\n非常经典的题目，看见了就再巩固一下。\n\n1. 拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\\lceil log_2mx\\rceil$个数组。计算每一位的贡献。\n\n当拆位后原式子会变为这样的\n$$\nallW = \\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil log_2mx\\rceil}cnt(a_{i-x} != a_{x})\n$$\n这个复杂度仍然是爆炸的，因此需要继续优化\n\n很容易想到的一个优化就是，对于$$a_i \\oplus a_j$$他是满足交换律的，即$$a_i \\oplus a_j = a_j \\oplus a_i$$因此我们仅需要计算单边值即可（然后乘2。\n\n因此将原有的式子改写$$w =2 \\times (\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) $$虽然对于$$a_i$$本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。\n\n再转头考虑所有子区间的问题，一个数组的所有子区间显然是$$n^2$$级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为$$i\\times (n-j+1)$$（下标从1开始），则对任意i,j，其贡献值为以下公式\n$$\nw(bt,{i,j}) = (i\\times (n-j+1) * (1<<bt) * (bit(x,a_i)\\not=bit(x,a_j))\n$$\n施展数学的神奇魔法！\n\n提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算$$a_j$$ 与$$a_i|i<j$$的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。\n\n最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。\n\n```cpp\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n\n    ll ans = 0;\n    for(int bt = 0;bt <=29;bt++) {\n        ll s1=0,s2 =0;\n        for(int i=1;i<=n;i++) {\n            if(a[i] >>bt&1) {\n                ans = (ans + s2 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s1 += i;\n                s1 %= MOD;\n            }\n            else {\n                ans = (ans + s1 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s2 += i;\n                s2 %= MOD;\n            }\n        }\n    }\n    cout<<(2ll * ans)%MOD<<endl;\n}\n```\n\n不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。","slug":"状态转移习题3","published":1,"updated":"2024-08-14T13:39:25.704Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjaj001plowv383h09a0","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>对一个数组的所有非空子区间，计算这个公式<span\r\nclass=\"math display\">\\[w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus\r\na_j \\]</span>的和。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>非常经典的题目，看见了就再巩固一下。</p>\r\n<ol type=\"1\">\r\n<li>拆位，\r\n对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。\r\n即将整个数组拆分为<span class=\"math inline\">\\(\\lceil\r\nlog_2mx\\rceil\\)</span>个数组。计算每一位的贡献。</li>\r\n</ol>\r\n<p>当拆位后原式子会变为这样的 <span class=\"math display\">\\[\r\nallW =\r\n\\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil\r\nlog_2mx\\rceil}cnt(a_{i-x} != a_{x})\r\n\\]</span> 这个复杂度仍然是爆炸的，因此需要继续优化</p>\r\n<p>很容易想到的一个优化就是，对于<span class=\"math display\">\\[a_i \\oplus\r\na_j\\]</span>他是满足交换律的，即<span class=\"math display\">\\[a_i \\oplus\r\na_j = a_j \\oplus a_i\\]</span>因此我们仅需要计算单边值即可（然后乘2。</p>\r\n<p>因此将原有的式子改写<span class=\"math display\">\\[w =2 \\times\r\n(\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) \\]</span>虽然对于<span\r\nclass=\"math display\">\\[a_i\\]</span>本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。</p>\r\n<p>再转头考虑所有子区间的问题，一个数组的所有子区间显然是<span\r\nclass=\"math display\">\\[n^2\\]</span>级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为<span\r\nclass=\"math display\">\\[i\\times\r\n(n-j+1)\\]</span>（下标从1开始），则对任意i,j，其贡献值为以下公式 <span\r\nclass=\"math display\">\\[\r\nw(bt,{i,j}) = (i\\times (n-j+1) * (1&lt;&lt;bt) *\r\n(bit(x,a_i)\\not=bit(x,a_j))\r\n\\]</span> 施展数学的神奇魔法！</p>\r\n<p>提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算<span\r\nclass=\"math display\">\\[a_j\\]</span> 与<span\r\nclass=\"math display\">\\[a_i|i&lt;j\\]</span>的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。</p>\r\n<p>最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> bt = <span class=\"number\">0</span>;bt &lt;=<span class=\"number\">29</span>;bt++) &#123;</span><br><span class=\"line\">        ll s1=<span class=\"number\">0</span>,s2 =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt;&gt;bt&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = (ans + s2 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s1 += i;</span><br><span class=\"line\">                s1 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = (ans + s1 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s2 += i;</span><br><span class=\"line\">                s2 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"number\">2ll</span> * ans)%MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。</p>\r\n","length":705,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>对一个数组的所有非空子区间，计算这个公式<span\r\nclass=\"math display\">\\[w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus\r\na_j \\]</span>的和。</p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>非常经典的题目，看见了就再巩固一下。</p>\r\n<ol type=\"1\">\r\n<li>拆位，\r\n对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。\r\n即将整个数组拆分为<span class=\"math inline\">\\(\\lceil\r\nlog_2mx\\rceil\\)</span>个数组。计算每一位的贡献。</li>\r\n</ol>\r\n<p>当拆位后原式子会变为这样的 <span class=\"math display\">\\[\r\nallW =\r\n\\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil\r\nlog_2mx\\rceil}cnt(a_{i-x} != a_{x})\r\n\\]</span> 这个复杂度仍然是爆炸的，因此需要继续优化</p>\r\n<p>很容易想到的一个优化就是，对于<span class=\"math display\">\\[a_i \\oplus\r\na_j\\]</span>他是满足交换律的，即<span class=\"math display\">\\[a_i \\oplus\r\na_j = a_j \\oplus a_i\\]</span>因此我们仅需要计算单边值即可（然后乘2。</p>\r\n<p>因此将原有的式子改写<span class=\"math display\">\\[w =2 \\times\r\n(\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) \\]</span>虽然对于<span\r\nclass=\"math display\">\\[a_i\\]</span>本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。</p>\r\n<p>再转头考虑所有子区间的问题，一个数组的所有子区间显然是<span\r\nclass=\"math display\">\\[n^2\\]</span>级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为<span\r\nclass=\"math display\">\\[i\\times\r\n(n-j+1)\\]</span>（下标从1开始），则对任意i,j，其贡献值为以下公式 <span\r\nclass=\"math display\">\\[\r\nw(bt,{i,j}) = (i\\times (n-j+1) * (1&lt;&lt;bt) *\r\n(bit(x,a_i)\\not=bit(x,a_j))\r\n\\]</span> 施展数学的神奇魔法！</p>\r\n<p>提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算<span\r\nclass=\"math display\">\\[a_j\\]</span> 与<span\r\nclass=\"math display\">\\[a_i|i&lt;j\\]</span>的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。</p>\r\n<p>最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> bt = <span class=\"number\">0</span>;bt &lt;=<span class=\"number\">29</span>;bt++) &#123;</span><br><span class=\"line\">        ll s1=<span class=\"number\">0</span>,s2 =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt;&gt;bt&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = (ans + s2 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s1 += i;</span><br><span class=\"line\">                s1 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = (ans + s1 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s2 += i;</span><br><span class=\"line\">                s2 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"number\">2ll</span> * ans)%MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。</p>"},{"title":"状态转移习题4","date":"2024-08-14T11:41:55.000Z","_content":"## 题意：\n\n给定m条线段，求将1-n覆盖两次的所有方案数\n\n<!--more-->\n\n## 题解：\n\n离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。\n\n个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。\n\n状态表示这样设计：$$dpi,j,k$$表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。\n\n之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    dp[0][0][0] = 1;\n    for(int i=1;i<=m;i++) {\n        for(int ii=0;ii<i;ii++) {\n            for(int j=200;j;j--) {\n                for(int k = 200;k;k--)\n                    dp[i][j][k] = dp[ii][j][k];\n            }\n            for(int j=200;~j;j--) {\n                for(int k = 200;~k;k--) {\n                    if(mp[segs[i].x] <= j+1) {\n                        if(mp[segs[i].x] > k+1) {\n                            dp[i][max(mp[segs[i].y], j)][k] =\n                                (dp[i][max(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][k]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"!\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<k<<' '<<dp[i][max(mp[segs[i].y], j)][k]<<nline;\n                            // }\n                        }\n                        else {\n                            dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] =\n                                (dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"?\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<max(k,min(j,mp[segs[i].y]))<<' '<<\n                            //         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]<<nline;\n                            // }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<dp[m][mp[n]][mp[n]]<<endl;\n}\n```\n\n这段代码中显然有一个很严重的问题：时间复杂度为$$1.6e^{9}$$略微有点超出复杂度\n\n其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。\n\n时间如何优化？\n\n首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f\\[i]\\[j][k] += f\\[i - 1]\\[j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        segs[i].x--;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    for(int i=1;i<=m;i++) {\n        segs[i].x = mp[segs[i].x];\n        segs[i].y = mp[segs[i].y];\n    }\n\n    f[0][0][0] = 1;\n    for (int k = 1; k <= m; k++) {\n        for (int i = 0; i <= mp[n]; i++) {\n            for (int j = i; j <= mp[n]; j++) {\n                if (f[k - 1][i][j] == 0) {\n                    continue;\n                }\n                f[k][i][j] += f[k - 1][i][j];\n                f[k][i][j] %=MOD;\n                if (segs[k].x <= i) {\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]+=f[k - 1][i][j];\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]%=MOD;\n                }\n            }\n        }\n    }\n\n    cout<<f[m][mp[n]][mp[n]]% MOD<<endl;\n}\n```\n","source":"_posts/状态转移习题4.md","raw":"---\ntitle: 状态转移习题4\ndate: 2024-08-14 19:41:55\ntags: [算法, 状态转移, 离散化]\ncategories: \n\t- 算法\n\t- 状态转移\n\t- 复杂状态转移与优化\n---\n## 题意：\n\n给定m条线段，求将1-n覆盖两次的所有方案数\n\n<!--more-->\n\n## 题解：\n\n离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。\n\n个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。\n\n状态表示这样设计：$$dpi,j,k$$表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。\n\n之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    dp[0][0][0] = 1;\n    for(int i=1;i<=m;i++) {\n        for(int ii=0;ii<i;ii++) {\n            for(int j=200;j;j--) {\n                for(int k = 200;k;k--)\n                    dp[i][j][k] = dp[ii][j][k];\n            }\n            for(int j=200;~j;j--) {\n                for(int k = 200;~k;k--) {\n                    if(mp[segs[i].x] <= j+1) {\n                        if(mp[segs[i].x] > k+1) {\n                            dp[i][max(mp[segs[i].y], j)][k] =\n                                (dp[i][max(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][k]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"!\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<k<<' '<<dp[i][max(mp[segs[i].y], j)][k]<<nline;\n                            // }\n                        }\n                        else {\n                            dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] =\n                                (dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"?\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<max(k,min(j,mp[segs[i].y]))<<' '<<\n                            //         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]<<nline;\n                            // }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<dp[m][mp[n]][mp[n]]<<endl;\n}\n```\n\n这段代码中显然有一个很严重的问题：时间复杂度为$$1.6e^{9}$$略微有点超出复杂度\n\n其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。\n\n时间如何优化？\n\n首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f\\[i]\\[j][k] += f\\[i - 1]\\[j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        segs[i].x--;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    for(int i=1;i<=m;i++) {\n        segs[i].x = mp[segs[i].x];\n        segs[i].y = mp[segs[i].y];\n    }\n\n    f[0][0][0] = 1;\n    for (int k = 1; k <= m; k++) {\n        for (int i = 0; i <= mp[n]; i++) {\n            for (int j = i; j <= mp[n]; j++) {\n                if (f[k - 1][i][j] == 0) {\n                    continue;\n                }\n                f[k][i][j] += f[k - 1][i][j];\n                f[k][i][j] %=MOD;\n                if (segs[k].x <= i) {\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]+=f[k - 1][i][j];\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]%=MOD;\n                }\n            }\n        }\n    }\n\n    cout<<f[m][mp[n]][mp[n]]% MOD<<endl;\n}\n```\n","slug":"状态转移习题4","published":1,"updated":"2024-08-14T13:39:29.254Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjak001slowvfa3hdvg1","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>给定m条线段，求将1-n覆盖两次的所有方案数</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。</p>\r\n<p>个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。</p>\r\n<p>状态表示这样设计：<span\r\nclass=\"math display\">\\[dpi,j,k\\]</span>表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。</p>\r\n<p>之后可以根据segs[i].x\r\n是否小于两个前缀长度做转移了。暴力转移code如下</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=<span class=\"number\">0</span>;ii&lt;i;ii++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;k;k--)</span><br><span class=\"line\">                    dp[i][j][k] = dp[ii][j][k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;~j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;~k;k--) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(mp[segs[i].x] &lt;= j<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(mp[segs[i].x] &gt; k<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][k] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][k]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;!&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][max(mp[segs[i].y], j)][k]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;?&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;max(k,min(j,mp[segs[i].y]))&lt;&lt;&#x27; &#x27;&lt;&lt;</span></span><br><span class=\"line\">                            <span class=\"comment\">//         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;dp[m][mp[n]][mp[n]]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这段代码中显然有一个很严重的问题：时间复杂度为<span\r\nclass=\"math display\">\\[1.6e^{9}\\]</span>略微有点超出复杂度</p>\r\n<p>其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。</p>\r\n<p>时间如何优化？</p>\r\n<p>首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f[i][j][k]\r\n+= f[i -\r\n1][j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        segs[i].x--;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        segs[i].x = mp[segs[i].x];</span><br><span class=\"line\">        segs[i].y = mp[segs[i].y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= m; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= mp[n]; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= mp[n]; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f[k - <span class=\"number\">1</span>][i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                f[k][i][j] += f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                f[k][i][j] %=MOD;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (segs[k].x &lt;= i) &#123;</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]+=f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]%=MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;f[m][mp[n]][mp[n]]% MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1004,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>给定m条线段，求将1-n覆盖两次的所有方案数</p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。</p>\r\n<p>个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。</p>\r\n<p>状态表示这样设计：<span\r\nclass=\"math display\">\\[dpi,j,k\\]</span>表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。</p>\r\n<p>之后可以根据segs[i].x\r\n是否小于两个前缀长度做转移了。暴力转移code如下</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=<span class=\"number\">0</span>;ii&lt;i;ii++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;k;k--)</span><br><span class=\"line\">                    dp[i][j][k] = dp[ii][j][k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;~j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;~k;k--) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(mp[segs[i].x] &lt;= j<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(mp[segs[i].x] &gt; k<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][k] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][k]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;!&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][max(mp[segs[i].y], j)][k]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;?&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;max(k,min(j,mp[segs[i].y]))&lt;&lt;&#x27; &#x27;&lt;&lt;</span></span><br><span class=\"line\">                            <span class=\"comment\">//         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;dp[m][mp[n]][mp[n]]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这段代码中显然有一个很严重的问题：时间复杂度为<span\r\nclass=\"math display\">\\[1.6e^{9}\\]</span>略微有点超出复杂度</p>\r\n<p>其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。</p>\r\n<p>时间如何优化？</p>\r\n<p>首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f[i][j][k]\r\n+= f[i -\r\n1][j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        segs[i].x--;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        segs[i].x = mp[segs[i].x];</span><br><span class=\"line\">        segs[i].y = mp[segs[i].y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= m; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= mp[n]; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= mp[n]; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f[k - <span class=\"number\">1</span>][i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                f[k][i][j] += f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                f[k][i][j] %=MOD;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (segs[k].x &lt;= i) &#123;</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]+=f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]%=MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;f[m][mp[n]][mp[n]]% MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"MindSpore专题","date":"2024-08-14T11:47:58.000Z","_content":"\n# MindSpore Studying By Windows And Ubuntu\n\n文档编写采用Typora，须获得更好观看体验请自行clone本仓库\n\n## 初级教程\n\n[前置数学](../Chapters/Concept/article.html)\n\n<!--more-->\n\n[第一章 Ubuntu以及Windows安装MindSpore](../Chapters/First_Install/article.html)\n\n[第二章 尝试使用MindSpore](../Chapters/Second_TryMindSpore/article.html)\n\n[第三章 张量](../Chapters/Third_Tensor/article.html)\n\n[第四章 数据集](../Chapters/Fourth_DataSet/article.html)\n\n[第五章 网格构建](../Chapters/Fivth_ConstructNetwork/article.html)\n\n[第六章 函数式自动微分](../Chapters/Sixth_FunctionAutoDifferentalCalc/article.html)\n\n[第七章 模型训练](../Chapters/Seven_ModelTrain/article.html)","source":"_posts/special_subject/MindSpore/MindSpore学习目录.md","raw":"---\ntitle: MindSpore专题\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n\n# MindSpore Studying By Windows And Ubuntu\n\n文档编写采用Typora，须获得更好观看体验请自行clone本仓库\n\n## 初级教程\n\n[前置数学](../Chapters/Concept/article.html)\n\n<!--more-->\n\n[第一章 Ubuntu以及Windows安装MindSpore](../Chapters/First_Install/article.html)\n\n[第二章 尝试使用MindSpore](../Chapters/Second_TryMindSpore/article.html)\n\n[第三章 张量](../Chapters/Third_Tensor/article.html)\n\n[第四章 数据集](../Chapters/Fourth_DataSet/article.html)\n\n[第五章 网格构建](../Chapters/Fivth_ConstructNetwork/article.html)\n\n[第六章 函数式自动微分](../Chapters/Sixth_FunctionAutoDifferentalCalc/article.html)\n\n[第七章 模型训练](../Chapters/Seven_ModelTrain/article.html)","slug":"special_subject/MindSpore/MindSpore学习目录","published":1,"updated":"2024-08-17T07:58:14.334Z","_id":"clzwonjak001tlowv5rq2a4up","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"mindspore-studying-by-windows-and-ubuntu\">MindSpore Studying By\r\nWindows And Ubuntu</h1>\r\n<p>文档编写采用Typora，须获得更好观看体验请自行clone本仓库</p>\r\n<h2 id=\"初级教程\">初级教程</h2>\r\n<p><a href=\"../Chapters/Concept/article.html\">前置数学</a></p>\r\n<span id=\"more\"></span>\r\n<p><a href=\"../Chapters/First_Install/article.html\">第一章\r\nUbuntu以及Windows安装MindSpore</a></p>\r\n<p><a href=\"../Chapters/Second_TryMindSpore/article.html\">第二章\r\n尝试使用MindSpore</a></p>\r\n<p><a href=\"../Chapters/Third_Tensor/article.html\">第三章 张量</a></p>\r\n<p><a href=\"../Chapters/Fourth_DataSet/article.html\">第四章\r\n数据集</a></p>\r\n<p><a href=\"../Chapters/Fivth_ConstructNetwork/article.html\">第五章\r\n网格构建</a></p>\r\n<p><a\r\nhref=\"../Chapters/Sixth_FunctionAutoDifferentalCalc/article.html\">第六章\r\n函数式自动微分</a></p>\r\n<p><a href=\"../Chapters/Seven_ModelTrain/article.html\">第七章\r\n模型训练</a></p>\r\n","length":91,"excerpt":"<h1 id=\"mindspore-studying-by-windows-and-ubuntu\">MindSpore Studying By\r\nWindows And Ubuntu</h1>\r\n<p>文档编写采用Typora，须获得更好观看体验请自行clone本仓库</p>\r\n<h2 id=\"初级教程\">初级教程</h2>\r\n<p><a href=\"../Chapters/Concept/article.html\">前置数学</a></p>","more":"<p><a href=\"../Chapters/First_Install/article.html\">第一章\r\nUbuntu以及Windows安装MindSpore</a></p>\r\n<p><a href=\"../Chapters/Second_TryMindSpore/article.html\">第二章\r\n尝试使用MindSpore</a></p>\r\n<p><a href=\"../Chapters/Third_Tensor/article.html\">第三章 张量</a></p>\r\n<p><a href=\"../Chapters/Fourth_DataSet/article.html\">第四章\r\n数据集</a></p>\r\n<p><a href=\"../Chapters/Fivth_ConstructNetwork/article.html\">第五章\r\n网格构建</a></p>\r\n<p><a\r\nhref=\"../Chapters/Sixth_FunctionAutoDifferentalCalc/article.html\">第六章\r\n函数式自动微分</a></p>\r\n<p><a href=\"../Chapters/Seven_ModelTrain/article.html\">第七章\r\n模型训练</a></p>"},{"title":"由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估","date":"2024-08-14T11:41:55.000Z","_content":"\n于江西理工大学信息安全课程的论文综述\n\n学术，未发表，Miarcl\n下载连接：http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\n\n感谢母校对我的指导\n\n{% pdf http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf 3000px}","source":"_posts/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估.md","raw":"---\ntitle: 由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估\ndate: 2024-08-14 19:41:55\ntags: [信息安全, 加密算法, Miracl, ECC]\ncategories: \n\t- 学术\n\t- 综述\n---\n\n于江西理工大学信息安全课程的论文综述\n\n学术，未发表，Miarcl\n下载连接：http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\n\n感谢母校对我的指导\n\n{% pdf http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf 3000px}","slug":"由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估","published":1,"updated":"2024-08-15T02:58:38.900Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjal001wlowvc6cyef0x","content":"<p>于江西理工大学信息安全课程的论文综述</p>\r\n<p>学术，未发表，Miarcl\r\n下载连接：http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf</p>\r\n<p>感谢母校对我的指导</p>\r\n<p><div class=\"pdf-container\" data-target=\"http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\" data-height=\"3000px}</p>\"></div>","length":115,"excerpt":"","more":"<p>于江西理工大学信息安全课程的论文综述</p>\r\n<p>学术，未发表，Miarcl\r\n下载连接：http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf</p>\r\n<p>感谢母校对我的指导</p>\r\n<p><div class=\"pdf-container\" data-target=\"http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\" data-height=\"3000px}</p>\"></div>"},{"title":"MindSpore专题——第〇章、概念","date":"2024-08-14T11:47:58.000Z","_content":"# 初等概念名词解释\n\n在接近学完初级的机器学习后，我意识到单纯的看MindSpore文档以及看Youtube视频是远远不够的，我必须系统的学习一些概念知识以避免在后面的学习中云里雾里，故就有了这一章，在这一章中几乎全是对概念的解释，他们的来源广泛，传送门我都会贴在此处，供查阅：\n\n> [神经网络入门 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2017/07/neural-network.html)\n>\n> https://github.com/exacity/deeplearningbook-chinese\n\n<!--more-->\n\n##  感知机（Perceptron）\n\n![img](https://s2.loli.net/2024/06/10/bkVr3Lymea1OAnw.png)\n\n​\t上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3...），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。\n\n​\t感知机是输出传入参数的一个函数变换，大多数情况下他是(最初涉及)\n$$\noutput = \\sigma(w_1*a_1 +\\cdots +w_n*a_n + b)\n$$\n其中$$\\sigma $$​函数表达式如下\n$$\nσ(z) = 1 / (1 + e^{-z})\n$$\n\n## 表示学习（Representation Learning）\n\n使用机器学习来发掘表示本身，而不仅仅把表示映射到输出,学习到的表示往往比手动设计的表示表现得更好。并且不需要人工干预就能迅速适应新的任务。\n\n## 变差因素\n\n在此背景下，‘‘因素’’这个词仅指代影响的不同来源；因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反，它们可能是现实世界中观察不到的物体或者不可观测的力，但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因，它们还可能以概念的形式存在于人类的思维中。\n\n它们可以被看作数据的概念或者抽象，帮助我们了解这些数据的丰富多样性。\n\n## 可见层\n\n也就是神经网路的输入层，这样命名的原因是因为它包含我们能观察到的变量。\n\n## 隐藏层\n\n也就是神经网路的中间层。因为它们的值不在数据中给出，所以将这些层称为‘‘隐藏”;模型必须确定哪些概念有利于解释观察数据中的关系。这里的图像是每个隐藏单元表示的特征的可视化。这里也是分形的思想运用的层次。\n\n## 输出层\n\n输出神经网路的判断也称Object Identify\n\n## 前馈深度网络\n\n### 多层感知机（Multilayer Perceptron）\n\n多层感知机仅仅是一个将一组输入值映射到输出值的数学函数。该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。\n\n## 为什么需要使用非线性函数\n\n这是由于线性模型的局限性，一个很经典的例子是，线性模型是无法学习异或函数的。\n\n## 分布式表示\n\n其思想是：系统的每一个输入都应该由多个特征表示，并且每一个特征都应该参与到多个可能输入的表示。这显然也与神经网络每一层layer与layer之间的dense有关联\n\n## 激活函数\n\n## 损失函数\n\n## 梯度下降\n\n## 正则化\n\n## 过拟合\n\n## 线性代数\n\n### 主对角线\n\n即满足$$a = \\{a_{i,j}|i=j\\}$$的元素构成的线，特殊的$$n\\not =m$$\n\n![image-20240609143044969](https://s2.loli.net/2024/06/10/7WA9zDuB2UYrlKF.png)\n\n### 转置\n\n即矩阵对主对角线的镜像，特俗的有$$n\\not = m$$\n\n![image-20240609143213322](https://s2.loli.net/2024/06/10/vtux96qNrkAH8jZ.png)\n\n### 元素对应乘积（Hadamard 乘积）\n\n记为$$A\\odot B$$\n\n### 点积\n\n两个相同维数的向量x和y的点积（dot product）可看作是矩阵乘积$$A^\\top B$$​。我们可以把矩阵乘积C=AB中计算Cij的步骤看作是A的第i行和B的第j列之间的点积。\n\n矩阵的乘法是不满足交换律的，但是矩阵的点积是满足的。\n$$\nx^\\top y = y^\\top x\n$$\n\n\n矩阵乘积转置的简单形式\n$$\n(AB)^\\top = B^\\top A^\\top\n$$\n注意顺序是不能更改的因为矩阵乘法不满足交换律\n\n### 单位矩阵\n\n单位矩阵指主对角线上的值都为1，其他地方都为零的矩阵。\n\n我们将保持n维向量不变的单位矩阵记作$$I_n$$。\n\n### 逆矩阵\n\n很朴素的定义，需要注意的是由于矩阵乘法不满足交换律，因此我们再说一个矩阵的逆的时候通常是说矩阵的左逆。\n\n对于方阵而言，它的左逆和右逆是相等的\n\n### 线性相关与生成子空间\n\n如果逆矩阵$$A^{-1}$$​存在。那么式(2.11)肯定对于每一个向量b恰好存在一个解。但是，对于方程组而言，对于向量b的某些值，有可能不存在解，或者存在无限多个解。存在多于一个解但是少于无限多个解的情况是不可能发生的；因为如果x和y都是某方程组的解，则x,y则构成了一个张成空间。\n\n为了分析方程有多少个解，我们可以将A的列向量看作从原点（origin）（元素都是零的向量）出发的不同方向，确定有多少种方法可以到达向量b。在这个观点下，向量x中的每个元素表示我们应该沿着这些方向走多远，即xi表示我们需要沿着第i个向量的方向走多远：\n$$\nAx = \\sum _i x_i A_{:,i}\n$$\n这样的操作我们称为线性组合。形式上，一组向量的线性组合是指每个向量乘以对应标量系数之后的和，即：\n$$\n\\sum _i c_i v^{(i)}\n$$\n一组向量的生成子空间（span）是原始向量线性组合后所能抵达的点的集合。\n\n确定Ax=b是否有解相当于确定向量b是否在A列向量的生成子空间中。这个特殊的生成子空间被称为A的列空间（column space）或者A的值域（range）。\n\n为了使方程Ax=b对于任意向量$$b\\in \\mathbb{R}^m$$都存在解，我们要求A的列空间构成整个$$\\mathbb{R}^m$$。如果$$\\mathbb{R}^m$$中的某个点不在A的列空间中，那么该点对应的b会使得该方程没有解。矩阵A的列空间是整个$$\\mathbb{R}^m$$的要求，意味着A至少有m列，即n>=m。否则，A列空间的维数会小于m。例如，假设A是一个$$3\\times 2$$的矩阵。目标b是3维的，但是x只有2维。所以无论如何修改x的值，也只能描绘出$$\\mathbb{R}^3$$空间中的二维平面。当且仅当向量b在该二维平面中时，该方程有解。\n\n不等式n>=m仅是方程对每一点都有解的必要条件。这不是一个充分条件，因为有些列向量可能是冗余的。假设有一个$$\\mathbb{R}^{2\\times2}$$中的矩阵，它的两个列向量是相同的。那么它的列空间和它的一个列向量作为矩阵的列空间是一样的。换言之，虽然该矩阵有2列，但是它的列空间仍然只是一条线，不能涵盖整个$$\\mathbb{R}^2$$空间。\n\n正式地说，这种冗余被称为线性相关（linear dependence）。如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为线性无关（linearly independent）。如果某个向量是一组向量中某些向量的线性组合，那么我们将这个向量加入这组向量后不会增加这组向量的生成子空间。这意味着，如果一个矩阵的列空间涵盖整个$$\\mathbb{R}^m$$，那么该矩阵必须包含至少一组m个线性无关的向量。这是对于每一个向量b的取值都有解的充分必要条件。值得注意的是，这个条件是说该向量集恰好有m个线性无关的列向量，而不是至少m个。不存在一个m维向量的集合具有多于m个彼此线性不相关的列向量，但是一个有多于m个列向量的矩阵有可能拥有不止一个大小为m的线性无关向量集。\n\n要想使矩阵可逆，我们还需要保证对于每一个b值至多有一个解。为此，我们需要确保该矩阵至多有m个列向量。否则，该方程会有不止一个解。\n\n### 奇异矩阵（singular square）\n\n该矩阵必须是一个方阵（square），即m=n，并且所有列向量都是线性无关的。一个列向量线性相关的方阵被称为奇异的（singular）。\n\n### 矩阵右乘\n\n$$\nAA^{-1}=I\n$$\n\n### 范数（norm）\n\n用来衡量一个向量的大小。机器学习中常用范数衡量向量大小。形式上$$L^p$$定义如下\n$$\n||x||_p = \\left( \\sum _i |x_i|^p \\right) ^{\\frac{1}{p}}\n$$\n范数（包括Lp范数）是将向量映射到非负值的函数\n\n严格的讲，范数是满足以下性质的函数\n\n- f(x) = 0 => x=0\n- f(x+y) <=f(x) + f(y) （三角不等式）\n- 对$$\\forall \\alpha \\in \\mathbb{R},f(\\alpha x) = |\\alpha|f(x)$$\n\n当p= 2时，$$L^2$$范数被称为欧几里得范数（Euclidean norm）。它表示从原点出发到向量x确定的点的欧几里得距离。$$L^2$$范数在机器学习中出现地十分频繁，经常简化表示为∥x∥，略去了下标2。平方$$L^2$$范数也经常用来衡量向量的大小，可以简单地通过点积$$x ^\\top x$$计算。\n\n但是在很多情况下，平方$$L^2$$范数也可能不受欢迎，因为它在原点附近增长得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数：$$L^1$$范数。$$L^1$$范数可以简化如下：\n$$\n||x||_1 = \\sum _i |x_i|\n$$\n有时候我们会统计向量中非零元素的个数来衡量向量的大小。有些作者将这种函数称为“$$L^0$$范数’’，但是这个术语在数学意义上是不对的\n\n另外一个经常在机器学习中出现的范数是$$L^\\inf$$范数，也被称为最大范数（maxnorm）。这个范数表示向量中具有最大幅值的元素的绝对值：\n$$\n||x||_1 = \\max _i |x_i|\n$$\n有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用Frobenius范数（Frobenius norm），\n$$\n||A||_F = \\sqrt{\\sum _{i,j} A^2_{i,j}}\n$$\n两个向量的点集可以用范数来表示，具体的\n$$\nx^\\top y = ||x||_2 ||y||_2 cos\\theta\n$$\n$$\\theta$$表示x,y之间的夹角\n\n### 对角矩阵\n\n只在主对角线上含有非零元素，，其他位置都是零。用diag($$v$$)表示一个对角矩阵。\n\n计算乘法diag(v)x，我们只需要将x中的每个元素xi放大vi倍。换言之，diag(v)x=v⊙x\n\n对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，在这种情况下，diag(v)1=diag([1/v1;.... ;1/vn]⊤)。\n\n非方阵的对角矩阵没有逆矩阵\n\n### 对称矩阵\n\n对称矩阵是矩阵的转置和自己相等的矩阵\n$$\nA = A ^\\top\n$$\n\n### 单位矩阵\n\n具有单位范数的矩阵\n\n如果$$x^\\top y=0$$，那么向量x和向量y互相正交（orthogonal）。如果两个向量都有非零范数，那么这两个向量之间的夹角是90度。在Rn中，至多有n个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为1，那么我们称它们是标准正交（orthonormal）。\n\n正交矩阵（orthogonal matrix）是指行向量和列向量是分别标准正交的方阵，更具体的，他们是满足以下条件的矩阵\n$$\nA^\\top A = A ^\\top A = I.\n$$\n这样意味着\n$$\nA^{-1} = A^\\top\n$$\n\n### 特征分解\n\n特征分解（eigendecomposition）是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值。\n\n方阵A的特征向量（eigenvector）是指与A相乘后相当于对该向量进行缩放的非零向量v：\n$$\nA v = \\lambda v\n$$\n标量$\\lambda$被称为这个特征向量对应的特征值（eigenvalue）。\n\n（类似地，我们也可以定义左特征向量（left eigenvector）$$v^⊤A=\\lambda v^⊤$$，但是通常我们更关注右特征向量（right eigenvector））。\n\n所有特征值都是正数的矩阵被称为正定（positive definite）；所有特征值都是非负数的矩阵被称为半正定（positive semidefinite）。同样地，所有特征值都是负数的矩阵被称为负定（negative definite）；所有特征值都是非正数的矩阵被称为半负定（negative semidefinite）。\n\n然而，我们也常常希望将矩阵分解（decompose）成特征值和特征向量。这样可以帮助我们分析矩阵的特定性质，就像质因数分解有助于我们理解整数。\n\n矩阵A的特征分解可以记作\n$$\nA = V diag(\\lambda) V^{-1}\n$$\n不是每一个矩阵都可以分解成特征值和特征向量。在某些情况下，特征分解存在，但是会涉及复数而非实数。\n\n其中Q是A的特征向量组成的正交矩阵，是对角矩阵。特征值$$\\lambda_{i;i}$$对应的特征向量是矩阵Q的第i列，记作Q:;i。因为Q是正交矩阵，我们可以将A看作沿方向v(i)延展i倍的空间","source":"_posts/special_subject/MindSpore/Chapters/Concept.md","raw":"---\ntitle: MindSpore专题——第〇章、概念\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n# 初等概念名词解释\n\n在接近学完初级的机器学习后，我意识到单纯的看MindSpore文档以及看Youtube视频是远远不够的，我必须系统的学习一些概念知识以避免在后面的学习中云里雾里，故就有了这一章，在这一章中几乎全是对概念的解释，他们的来源广泛，传送门我都会贴在此处，供查阅：\n\n> [神经网络入门 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2017/07/neural-network.html)\n>\n> https://github.com/exacity/deeplearningbook-chinese\n\n<!--more-->\n\n##  感知机（Perceptron）\n\n![img](https://s2.loli.net/2024/06/10/bkVr3Lymea1OAnw.png)\n\n​\t上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3...），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。\n\n​\t感知机是输出传入参数的一个函数变换，大多数情况下他是(最初涉及)\n$$\noutput = \\sigma(w_1*a_1 +\\cdots +w_n*a_n + b)\n$$\n其中$$\\sigma $$​函数表达式如下\n$$\nσ(z) = 1 / (1 + e^{-z})\n$$\n\n## 表示学习（Representation Learning）\n\n使用机器学习来发掘表示本身，而不仅仅把表示映射到输出,学习到的表示往往比手动设计的表示表现得更好。并且不需要人工干预就能迅速适应新的任务。\n\n## 变差因素\n\n在此背景下，‘‘因素’’这个词仅指代影响的不同来源；因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反，它们可能是现实世界中观察不到的物体或者不可观测的力，但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因，它们还可能以概念的形式存在于人类的思维中。\n\n它们可以被看作数据的概念或者抽象，帮助我们了解这些数据的丰富多样性。\n\n## 可见层\n\n也就是神经网路的输入层，这样命名的原因是因为它包含我们能观察到的变量。\n\n## 隐藏层\n\n也就是神经网路的中间层。因为它们的值不在数据中给出，所以将这些层称为‘‘隐藏”;模型必须确定哪些概念有利于解释观察数据中的关系。这里的图像是每个隐藏单元表示的特征的可视化。这里也是分形的思想运用的层次。\n\n## 输出层\n\n输出神经网路的判断也称Object Identify\n\n## 前馈深度网络\n\n### 多层感知机（Multilayer Perceptron）\n\n多层感知机仅仅是一个将一组输入值映射到输出值的数学函数。该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。\n\n## 为什么需要使用非线性函数\n\n这是由于线性模型的局限性，一个很经典的例子是，线性模型是无法学习异或函数的。\n\n## 分布式表示\n\n其思想是：系统的每一个输入都应该由多个特征表示，并且每一个特征都应该参与到多个可能输入的表示。这显然也与神经网络每一层layer与layer之间的dense有关联\n\n## 激活函数\n\n## 损失函数\n\n## 梯度下降\n\n## 正则化\n\n## 过拟合\n\n## 线性代数\n\n### 主对角线\n\n即满足$$a = \\{a_{i,j}|i=j\\}$$的元素构成的线，特殊的$$n\\not =m$$\n\n![image-20240609143044969](https://s2.loli.net/2024/06/10/7WA9zDuB2UYrlKF.png)\n\n### 转置\n\n即矩阵对主对角线的镜像，特俗的有$$n\\not = m$$\n\n![image-20240609143213322](https://s2.loli.net/2024/06/10/vtux96qNrkAH8jZ.png)\n\n### 元素对应乘积（Hadamard 乘积）\n\n记为$$A\\odot B$$\n\n### 点积\n\n两个相同维数的向量x和y的点积（dot product）可看作是矩阵乘积$$A^\\top B$$​。我们可以把矩阵乘积C=AB中计算Cij的步骤看作是A的第i行和B的第j列之间的点积。\n\n矩阵的乘法是不满足交换律的，但是矩阵的点积是满足的。\n$$\nx^\\top y = y^\\top x\n$$\n\n\n矩阵乘积转置的简单形式\n$$\n(AB)^\\top = B^\\top A^\\top\n$$\n注意顺序是不能更改的因为矩阵乘法不满足交换律\n\n### 单位矩阵\n\n单位矩阵指主对角线上的值都为1，其他地方都为零的矩阵。\n\n我们将保持n维向量不变的单位矩阵记作$$I_n$$。\n\n### 逆矩阵\n\n很朴素的定义，需要注意的是由于矩阵乘法不满足交换律，因此我们再说一个矩阵的逆的时候通常是说矩阵的左逆。\n\n对于方阵而言，它的左逆和右逆是相等的\n\n### 线性相关与生成子空间\n\n如果逆矩阵$$A^{-1}$$​存在。那么式(2.11)肯定对于每一个向量b恰好存在一个解。但是，对于方程组而言，对于向量b的某些值，有可能不存在解，或者存在无限多个解。存在多于一个解但是少于无限多个解的情况是不可能发生的；因为如果x和y都是某方程组的解，则x,y则构成了一个张成空间。\n\n为了分析方程有多少个解，我们可以将A的列向量看作从原点（origin）（元素都是零的向量）出发的不同方向，确定有多少种方法可以到达向量b。在这个观点下，向量x中的每个元素表示我们应该沿着这些方向走多远，即xi表示我们需要沿着第i个向量的方向走多远：\n$$\nAx = \\sum _i x_i A_{:,i}\n$$\n这样的操作我们称为线性组合。形式上，一组向量的线性组合是指每个向量乘以对应标量系数之后的和，即：\n$$\n\\sum _i c_i v^{(i)}\n$$\n一组向量的生成子空间（span）是原始向量线性组合后所能抵达的点的集合。\n\n确定Ax=b是否有解相当于确定向量b是否在A列向量的生成子空间中。这个特殊的生成子空间被称为A的列空间（column space）或者A的值域（range）。\n\n为了使方程Ax=b对于任意向量$$b\\in \\mathbb{R}^m$$都存在解，我们要求A的列空间构成整个$$\\mathbb{R}^m$$。如果$$\\mathbb{R}^m$$中的某个点不在A的列空间中，那么该点对应的b会使得该方程没有解。矩阵A的列空间是整个$$\\mathbb{R}^m$$的要求，意味着A至少有m列，即n>=m。否则，A列空间的维数会小于m。例如，假设A是一个$$3\\times 2$$的矩阵。目标b是3维的，但是x只有2维。所以无论如何修改x的值，也只能描绘出$$\\mathbb{R}^3$$空间中的二维平面。当且仅当向量b在该二维平面中时，该方程有解。\n\n不等式n>=m仅是方程对每一点都有解的必要条件。这不是一个充分条件，因为有些列向量可能是冗余的。假设有一个$$\\mathbb{R}^{2\\times2}$$中的矩阵，它的两个列向量是相同的。那么它的列空间和它的一个列向量作为矩阵的列空间是一样的。换言之，虽然该矩阵有2列，但是它的列空间仍然只是一条线，不能涵盖整个$$\\mathbb{R}^2$$空间。\n\n正式地说，这种冗余被称为线性相关（linear dependence）。如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为线性无关（linearly independent）。如果某个向量是一组向量中某些向量的线性组合，那么我们将这个向量加入这组向量后不会增加这组向量的生成子空间。这意味着，如果一个矩阵的列空间涵盖整个$$\\mathbb{R}^m$$，那么该矩阵必须包含至少一组m个线性无关的向量。这是对于每一个向量b的取值都有解的充分必要条件。值得注意的是，这个条件是说该向量集恰好有m个线性无关的列向量，而不是至少m个。不存在一个m维向量的集合具有多于m个彼此线性不相关的列向量，但是一个有多于m个列向量的矩阵有可能拥有不止一个大小为m的线性无关向量集。\n\n要想使矩阵可逆，我们还需要保证对于每一个b值至多有一个解。为此，我们需要确保该矩阵至多有m个列向量。否则，该方程会有不止一个解。\n\n### 奇异矩阵（singular square）\n\n该矩阵必须是一个方阵（square），即m=n，并且所有列向量都是线性无关的。一个列向量线性相关的方阵被称为奇异的（singular）。\n\n### 矩阵右乘\n\n$$\nAA^{-1}=I\n$$\n\n### 范数（norm）\n\n用来衡量一个向量的大小。机器学习中常用范数衡量向量大小。形式上$$L^p$$定义如下\n$$\n||x||_p = \\left( \\sum _i |x_i|^p \\right) ^{\\frac{1}{p}}\n$$\n范数（包括Lp范数）是将向量映射到非负值的函数\n\n严格的讲，范数是满足以下性质的函数\n\n- f(x) = 0 => x=0\n- f(x+y) <=f(x) + f(y) （三角不等式）\n- 对$$\\forall \\alpha \\in \\mathbb{R},f(\\alpha x) = |\\alpha|f(x)$$\n\n当p= 2时，$$L^2$$范数被称为欧几里得范数（Euclidean norm）。它表示从原点出发到向量x确定的点的欧几里得距离。$$L^2$$范数在机器学习中出现地十分频繁，经常简化表示为∥x∥，略去了下标2。平方$$L^2$$范数也经常用来衡量向量的大小，可以简单地通过点积$$x ^\\top x$$计算。\n\n但是在很多情况下，平方$$L^2$$范数也可能不受欢迎，因为它在原点附近增长得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数：$$L^1$$范数。$$L^1$$范数可以简化如下：\n$$\n||x||_1 = \\sum _i |x_i|\n$$\n有时候我们会统计向量中非零元素的个数来衡量向量的大小。有些作者将这种函数称为“$$L^0$$范数’’，但是这个术语在数学意义上是不对的\n\n另外一个经常在机器学习中出现的范数是$$L^\\inf$$范数，也被称为最大范数（maxnorm）。这个范数表示向量中具有最大幅值的元素的绝对值：\n$$\n||x||_1 = \\max _i |x_i|\n$$\n有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用Frobenius范数（Frobenius norm），\n$$\n||A||_F = \\sqrt{\\sum _{i,j} A^2_{i,j}}\n$$\n两个向量的点集可以用范数来表示，具体的\n$$\nx^\\top y = ||x||_2 ||y||_2 cos\\theta\n$$\n$$\\theta$$表示x,y之间的夹角\n\n### 对角矩阵\n\n只在主对角线上含有非零元素，，其他位置都是零。用diag($$v$$)表示一个对角矩阵。\n\n计算乘法diag(v)x，我们只需要将x中的每个元素xi放大vi倍。换言之，diag(v)x=v⊙x\n\n对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，在这种情况下，diag(v)1=diag([1/v1;.... ;1/vn]⊤)。\n\n非方阵的对角矩阵没有逆矩阵\n\n### 对称矩阵\n\n对称矩阵是矩阵的转置和自己相等的矩阵\n$$\nA = A ^\\top\n$$\n\n### 单位矩阵\n\n具有单位范数的矩阵\n\n如果$$x^\\top y=0$$，那么向量x和向量y互相正交（orthogonal）。如果两个向量都有非零范数，那么这两个向量之间的夹角是90度。在Rn中，至多有n个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为1，那么我们称它们是标准正交（orthonormal）。\n\n正交矩阵（orthogonal matrix）是指行向量和列向量是分别标准正交的方阵，更具体的，他们是满足以下条件的矩阵\n$$\nA^\\top A = A ^\\top A = I.\n$$\n这样意味着\n$$\nA^{-1} = A^\\top\n$$\n\n### 特征分解\n\n特征分解（eigendecomposition）是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值。\n\n方阵A的特征向量（eigenvector）是指与A相乘后相当于对该向量进行缩放的非零向量v：\n$$\nA v = \\lambda v\n$$\n标量$\\lambda$被称为这个特征向量对应的特征值（eigenvalue）。\n\n（类似地，我们也可以定义左特征向量（left eigenvector）$$v^⊤A=\\lambda v^⊤$$，但是通常我们更关注右特征向量（right eigenvector））。\n\n所有特征值都是正数的矩阵被称为正定（positive definite）；所有特征值都是非负数的矩阵被称为半正定（positive semidefinite）。同样地，所有特征值都是负数的矩阵被称为负定（negative definite）；所有特征值都是非正数的矩阵被称为半负定（negative semidefinite）。\n\n然而，我们也常常希望将矩阵分解（decompose）成特征值和特征向量。这样可以帮助我们分析矩阵的特定性质，就像质因数分解有助于我们理解整数。\n\n矩阵A的特征分解可以记作\n$$\nA = V diag(\\lambda) V^{-1}\n$$\n不是每一个矩阵都可以分解成特征值和特征向量。在某些情况下，特征分解存在，但是会涉及复数而非实数。\n\n其中Q是A的特征向量组成的正交矩阵，是对角矩阵。特征值$$\\lambda_{i;i}$$对应的特征向量是矩阵Q的第i列，记作Q:;i。因为Q是正交矩阵，我们可以将A看作沿方向v(i)延展i倍的空间","slug":"special_subject/MindSpore/Chapters/Concept","published":1,"updated":"2024-08-16T08:58:46.139Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjal001xlowv8lrqdg1c","content":"<h1 id=\"初等概念名词解释\">初等概念名词解释</h1>\r\n<p>在接近学完初级的机器学习后，我意识到单纯的看MindSpore文档以及看Youtube视频是远远不够的，我必须系统的学习一些概念知识以避免在后面的学习中云里雾里，故就有了这一章，在这一章中几乎全是对概念的解释，他们的来源广泛，传送门我都会贴在此处，供查阅：</p>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE3LzA3L25ldXJhbC1uZXR3b3JrLmh0bWw=\">神经网络入门\r\n- 阮一峰的网络日志 (ruanyifeng.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>https://github.com/exacity/deeplearningbook-chinese</p>\r\n</blockquote>\r\n<span id=\"more\"></span>\r\n<h2 id=\"感知机perceptron\">感知机（Perceptron）</h2>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/bkVr3Lymea1OAnw.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>​\r\n上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3...），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。</p>\r\n<p>​ 感知机是输出传入参数的一个函数变换，大多数情况下他是(最初涉及) <span\r\nclass=\"math display\">\\[\r\noutput = \\sigma(w_1*a_1 +\\cdots +w_n*a_n + b)\r\n\\]</span> 其中<span class=\"math display\">\\[\\sigma\r\n\\]</span>​函数表达式如下 <span class=\"math display\">\\[\r\nσ(z) = 1 / (1 + e^{-z})\r\n\\]</span></p>\r\n<h2 id=\"表示学习representation-learning\">表示学习（Representation\r\nLearning）</h2>\r\n<p>使用机器学习来发掘表示本身，而不仅仅把表示映射到输出,学习到的表示往往比手动设计的表示表现得更好。并且不需要人工干预就能迅速适应新的任务。</p>\r\n<h2 id=\"变差因素\">变差因素</h2>\r\n<p>在此背景下，‘‘因素’’这个词仅指代影响的不同来源；因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反，它们可能是现实世界中观察不到的物体或者不可观测的力，但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因，它们还可能以概念的形式存在于人类的思维中。</p>\r\n<p>它们可以被看作数据的概念或者抽象，帮助我们了解这些数据的丰富多样性。</p>\r\n<h2 id=\"可见层\">可见层</h2>\r\n<p>也就是神经网路的输入层，这样命名的原因是因为它包含我们能观察到的变量。</p>\r\n<h2 id=\"隐藏层\">隐藏层</h2>\r\n<p>也就是神经网路的中间层。因为它们的值不在数据中给出，所以将这些层称为‘‘隐藏”;模型必须确定哪些概念有利于解释观察数据中的关系。这里的图像是每个隐藏单元表示的特征的可视化。这里也是分形的思想运用的层次。</p>\r\n<h2 id=\"输出层\">输出层</h2>\r\n<p>输出神经网路的判断也称Object Identify</p>\r\n<h2 id=\"前馈深度网络\">前馈深度网络</h2>\r\n<h3 id=\"多层感知机multilayer-perceptron\">多层感知机（Multilayer\r\nPerceptron）</h3>\r\n<p>多层感知机仅仅是一个将一组输入值映射到输出值的数学函数。该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。</p>\r\n<h2 id=\"为什么需要使用非线性函数\">为什么需要使用非线性函数</h2>\r\n<p>这是由于线性模型的局限性，一个很经典的例子是，线性模型是无法学习异或函数的。</p>\r\n<h2 id=\"分布式表示\">分布式表示</h2>\r\n<p>其思想是：系统的每一个输入都应该由多个特征表示，并且每一个特征都应该参与到多个可能输入的表示。这显然也与神经网络每一层layer与layer之间的dense有关联</p>\r\n<h2 id=\"激活函数\">激活函数</h2>\r\n<h2 id=\"损失函数\">损失函数</h2>\r\n<h2 id=\"梯度下降\">梯度下降</h2>\r\n<h2 id=\"正则化\">正则化</h2>\r\n<h2 id=\"过拟合\">过拟合</h2>\r\n<h2 id=\"线性代数\">线性代数</h2>\r\n<h3 id=\"主对角线\">主对角线</h3>\r\n<p>即满足<span class=\"math display\">\\[a =\r\n\\{a_{i,j}|i=j\\}\\]</span>的元素构成的线，特殊的<span\r\nclass=\"math display\">\\[n\\not =m\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/7WA9zDuB2UYrlKF.png\"\r\nalt=\"image-20240609143044969\" />\r\n<figcaption aria-hidden=\"true\">image-20240609143044969</figcaption>\r\n</figure>\r\n<h3 id=\"转置\">转置</h3>\r\n<p>即矩阵对主对角线的镜像，特俗的有<span class=\"math display\">\\[n\\not =\r\nm\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/vtux96qNrkAH8jZ.png\"\r\nalt=\"image-20240609143213322\" />\r\n<figcaption aria-hidden=\"true\">image-20240609143213322</figcaption>\r\n</figure>\r\n<h3 id=\"元素对应乘积hadamard-乘积\">元素对应乘积（Hadamard 乘积）</h3>\r\n<p>记为<span class=\"math display\">\\[A\\odot B\\]</span></p>\r\n<h3 id=\"点积\">点积</h3>\r\n<p>两个相同维数的向量x和y的点积（dot product）可看作是矩阵乘积<span\r\nclass=\"math display\">\\[A^\\top\r\nB\\]</span>​。我们可以把矩阵乘积C=AB中计算Cij的步骤看作是A的第i行和B的第j列之间的点积。</p>\r\n<p>矩阵的乘法是不满足交换律的，但是矩阵的点积是满足的。 <span\r\nclass=\"math display\">\\[\r\nx^\\top y = y^\\top x\r\n\\]</span></p>\r\n<p>矩阵乘积转置的简单形式 <span class=\"math display\">\\[\r\n(AB)^\\top = B^\\top A^\\top\r\n\\]</span> 注意顺序是不能更改的因为矩阵乘法不满足交换律</p>\r\n<h3 id=\"单位矩阵\">单位矩阵</h3>\r\n<p>单位矩阵指主对角线上的值都为1，其他地方都为零的矩阵。</p>\r\n<p>我们将保持n维向量不变的单位矩阵记作<span\r\nclass=\"math display\">\\[I_n\\]</span>。</p>\r\n<h3 id=\"逆矩阵\">逆矩阵</h3>\r\n<p>很朴素的定义，需要注意的是由于矩阵乘法不满足交换律，因此我们再说一个矩阵的逆的时候通常是说矩阵的左逆。</p>\r\n<p>对于方阵而言，它的左逆和右逆是相等的</p>\r\n<h3 id=\"线性相关与生成子空间\">线性相关与生成子空间</h3>\r\n<p>如果逆矩阵<span\r\nclass=\"math display\">\\[A^{-1}\\]</span>​存在。那么式(2.11)肯定对于每一个向量b恰好存在一个解。但是，对于方程组而言，对于向量b的某些值，有可能不存在解，或者存在无限多个解。存在多于一个解但是少于无限多个解的情况是不可能发生的；因为如果x和y都是某方程组的解，则x,y则构成了一个张成空间。</p>\r\n<p>为了分析方程有多少个解，我们可以将A的列向量看作从原点（origin）（元素都是零的向量）出发的不同方向，确定有多少种方法可以到达向量b。在这个观点下，向量x中的每个元素表示我们应该沿着这些方向走多远，即xi表示我们需要沿着第i个向量的方向走多远：\r\n<span class=\"math display\">\\[\r\nAx = \\sum _i x_i A_{:,i}\r\n\\]</span>\r\n这样的操作我们称为线性组合。形式上，一组向量的线性组合是指每个向量乘以对应标量系数之后的和，即：\r\n<span class=\"math display\">\\[\r\n\\sum _i c_i v^{(i)}\r\n\\]</span>\r\n一组向量的生成子空间（span）是原始向量线性组合后所能抵达的点的集合。</p>\r\n<p>确定Ax=b是否有解相当于确定向量b是否在A列向量的生成子空间中。这个特殊的生成子空间被称为A的列空间（column\r\nspace）或者A的值域（range）。</p>\r\n<p>为了使方程Ax=b对于任意向量<span class=\"math display\">\\[b\\in\r\n\\mathbb{R}^m\\]</span>都存在解，我们要求A的列空间构成整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>。如果<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>中的某个点不在A的列空间中，那么该点对应的b会使得该方程没有解。矩阵A的列空间是整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>的要求，意味着A至少有m列，即n&gt;=m。否则，A列空间的维数会小于m。例如，假设A是一个<span\r\nclass=\"math display\">\\[3\\times\r\n2\\]</span>的矩阵。目标b是3维的，但是x只有2维。所以无论如何修改x的值，也只能描绘出<span\r\nclass=\"math display\">\\[\\mathbb{R}^3\\]</span>空间中的二维平面。当且仅当向量b在该二维平面中时，该方程有解。</p>\r\n<p>不等式n&gt;=m仅是方程对每一点都有解的必要条件。这不是一个充分条件，因为有些列向量可能是冗余的。假设有一个<span\r\nclass=\"math display\">\\[\\mathbb{R}^{2\\times2}\\]</span>中的矩阵，它的两个列向量是相同的。那么它的列空间和它的一个列向量作为矩阵的列空间是一样的。换言之，虽然该矩阵有2列，但是它的列空间仍然只是一条线，不能涵盖整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^2\\]</span>空间。</p>\r\n<p>正式地说，这种冗余被称为线性相关（linear\r\ndependence）。如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为线性无关（linearly\r\nindependent）。如果某个向量是一组向量中某些向量的线性组合，那么我们将这个向量加入这组向量后不会增加这组向量的生成子空间。这意味着，如果一个矩阵的列空间涵盖整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>，那么该矩阵必须包含至少一组m个线性无关的向量。这是对于每一个向量b的取值都有解的充分必要条件。值得注意的是，这个条件是说该向量集恰好有m个线性无关的列向量，而不是至少m个。不存在一个m维向量的集合具有多于m个彼此线性不相关的列向量，但是一个有多于m个列向量的矩阵有可能拥有不止一个大小为m的线性无关向量集。</p>\r\n<p>要想使矩阵可逆，我们还需要保证对于每一个b值至多有一个解。为此，我们需要确保该矩阵至多有m个列向量。否则，该方程会有不止一个解。</p>\r\n<h3 id=\"奇异矩阵singular-square\">奇异矩阵（singular square）</h3>\r\n<p>该矩阵必须是一个方阵（square），即m=n，并且所有列向量都是线性无关的。一个列向量线性相关的方阵被称为奇异的（singular）。</p>\r\n<h3 id=\"矩阵右乘\">矩阵右乘</h3>\r\n<p><span class=\"math display\">\\[\r\nAA^{-1}=I\r\n\\]</span></p>\r\n<h3 id=\"范数norm\">范数（norm）</h3>\r\n<p>用来衡量一个向量的大小。机器学习中常用范数衡量向量大小。形式上<span\r\nclass=\"math display\">\\[L^p\\]</span>定义如下 <span\r\nclass=\"math display\">\\[\r\n||x||_p = \\left( \\sum _i |x_i|^p \\right) ^{\\frac{1}{p}}\r\n\\]</span> 范数（包括Lp范数）是将向量映射到非负值的函数</p>\r\n<p>严格的讲，范数是满足以下性质的函数</p>\r\n<ul>\r\n<li>f(x) = 0 =&gt; x=0</li>\r\n<li>f(x+y) &lt;=f(x) + f(y) （三角不等式）</li>\r\n<li>对<span class=\"math display\">\\[\\forall \\alpha \\in\r\n\\mathbb{R},f(\\alpha x) = |\\alpha|f(x)\\]</span></li>\r\n</ul>\r\n<p>当p= 2时，<span\r\nclass=\"math display\">\\[L^2\\]</span>范数被称为欧几里得范数（Euclidean\r\nnorm）。它表示从原点出发到向量x确定的点的欧几里得距离。<span\r\nclass=\"math display\">\\[L^2\\]</span>范数在机器学习中出现地十分频繁，经常简化表示为∥x∥，略去了下标2。平方<span\r\nclass=\"math display\">\\[L^2\\]</span>范数也经常用来衡量向量的大小，可以简单地通过点积<span\r\nclass=\"math display\">\\[x ^\\top x\\]</span>计算。</p>\r\n<p>但是在很多情况下，平方<span\r\nclass=\"math display\">\\[L^2\\]</span>范数也可能不受欢迎，因为它在原点附近增长得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数：<span\r\nclass=\"math display\">\\[L^1\\]</span>范数。<span\r\nclass=\"math display\">\\[L^1\\]</span>范数可以简化如下： <span\r\nclass=\"math display\">\\[\r\n||x||_1 = \\sum _i |x_i|\r\n\\]</span>\r\n有时候我们会统计向量中非零元素的个数来衡量向量的大小。有些作者将这种函数称为“<span\r\nclass=\"math display\">\\[L^0\\]</span>范数’’，但是这个术语在数学意义上是不对的</p>\r\n<p>另外一个经常在机器学习中出现的范数是<span\r\nclass=\"math display\">\\[L^\\inf\\]</span>范数，也被称为最大范数（maxnorm）。这个范数表示向量中具有最大幅值的元素的绝对值：\r\n<span class=\"math display\">\\[\r\n||x||_1 = \\max _i |x_i|\r\n\\]</span>\r\n有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用Frobenius范数（Frobenius\r\nnorm）， <span class=\"math display\">\\[\r\n||A||_F = \\sqrt{\\sum _{i,j} A^2_{i,j}}\r\n\\]</span> 两个向量的点集可以用范数来表示，具体的 <span\r\nclass=\"math display\">\\[\r\nx^\\top y = ||x||_2 ||y||_2 cos\\theta\r\n\\]</span> <span\r\nclass=\"math display\">\\[\\theta\\]</span>表示x,y之间的夹角</p>\r\n<h3 id=\"对角矩阵\">对角矩阵</h3>\r\n<p>只在主对角线上含有非零元素，，其他位置都是零。用diag(<span\r\nclass=\"math display\">\\[v\\]</span>)表示一个对角矩阵。</p>\r\n<p>计算乘法diag(v)x，我们只需要将x中的每个元素xi放大vi倍。换言之，diag(v)x=v⊙x</p>\r\n<p>对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，在这种情况下，diag(v)1=diag([1/v1;....\r\n;1/vn]⊤)。</p>\r\n<p>非方阵的对角矩阵没有逆矩阵</p>\r\n<h3 id=\"对称矩阵\">对称矩阵</h3>\r\n<p>对称矩阵是矩阵的转置和自己相等的矩阵 <span class=\"math display\">\\[\r\nA = A ^\\top\r\n\\]</span></p>\r\n<h3 id=\"单位矩阵-1\">单位矩阵</h3>\r\n<p>具有单位范数的矩阵</p>\r\n<p>如果<span class=\"math display\">\\[x^\\top\r\ny=0\\]</span>，那么向量x和向量y互相正交（orthogonal）。如果两个向量都有非零范数，那么这两个向量之间的夹角是90度。在Rn中，至多有n个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为1，那么我们称它们是标准正交（orthonormal）。</p>\r\n<p>正交矩阵（orthogonal\r\nmatrix）是指行向量和列向量是分别标准正交的方阵，更具体的，他们是满足以下条件的矩阵\r\n<span class=\"math display\">\\[\r\nA^\\top A = A ^\\top A = I.\r\n\\]</span> 这样意味着 <span class=\"math display\">\\[\r\nA^{-1} = A^\\top\r\n\\]</span></p>\r\n<h3 id=\"特征分解\">特征分解</h3>\r\n<p>特征分解（eigendecomposition）是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值。</p>\r\n<p>方阵A的特征向量（eigenvector）是指与A相乘后相当于对该向量进行缩放的非零向量v：\r\n<span class=\"math display\">\\[\r\nA v = \\lambda v\r\n\\]</span> 标量<span\r\nclass=\"math inline\">\\(\\lambda\\)</span>被称为这个特征向量对应的特征值（eigenvalue）。</p>\r\n<p>（类似地，我们也可以定义左特征向量（left eigenvector）<span\r\nclass=\"math display\">\\[v^⊤A=\\lambda\r\nv^⊤\\]</span>，但是通常我们更关注右特征向量（right eigenvector））。</p>\r\n<p>所有特征值都是正数的矩阵被称为正定（positive\r\ndefinite）；所有特征值都是非负数的矩阵被称为半正定（positive\r\nsemidefinite）。同样地，所有特征值都是负数的矩阵被称为负定（negative\r\ndefinite）；所有特征值都是非正数的矩阵被称为半负定（negative\r\nsemidefinite）。</p>\r\n<p>然而，我们也常常希望将矩阵分解（decompose）成特征值和特征向量。这样可以帮助我们分析矩阵的特定性质，就像质因数分解有助于我们理解整数。</p>\r\n<p>矩阵A的特征分解可以记作 <span class=\"math display\">\\[\r\nA = V diag(\\lambda) V^{-1}\r\n\\]</span>\r\n不是每一个矩阵都可以分解成特征值和特征向量。在某些情况下，特征分解存在，但是会涉及复数而非实数。</p>\r\n<p>其中Q是A的特征向量组成的正交矩阵，是对角矩阵。特征值<span\r\nclass=\"math display\">\\[\\lambda_{i;i}\\]</span>对应的特征向量是矩阵Q的第i列，记作Q:;i。因为Q是正交矩阵，我们可以将A看作沿方向v(i)延展i倍的空间</p>\r\n","length":3525,"excerpt":"<h1 id=\"初等概念名词解释\">初等概念名词解释</h1>\r\n<p>在接近学完初级的机器学习后，我意识到单纯的看MindSpore文档以及看Youtube视频是远远不够的，我必须系统的学习一些概念知识以避免在后面的学习中云里雾里，故就有了这一章，在这一章中几乎全是对概念的解释，他们的来源广泛，传送门我都会贴在此处，供查阅：</p>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE3LzA3L25ldXJhbC1uZXR3b3JrLmh0bWw=\">神经网络入门\r\n- 阮一峰的网络日志 (ruanyifeng.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>https://github.com/exacity/deeplearningbook-chinese</p>\r\n</blockquote>","more":"<h2 id=\"感知机perceptron\">感知机（Perceptron）</h2>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/bkVr3Lymea1OAnw.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>​\r\n上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3...），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。</p>\r\n<p>​ 感知机是输出传入参数的一个函数变换，大多数情况下他是(最初涉及) <span\r\nclass=\"math display\">\\[\r\noutput = \\sigma(w_1*a_1 +\\cdots +w_n*a_n + b)\r\n\\]</span> 其中<span class=\"math display\">\\[\\sigma\r\n\\]</span>​函数表达式如下 <span class=\"math display\">\\[\r\nσ(z) = 1 / (1 + e^{-z})\r\n\\]</span></p>\r\n<h2 id=\"表示学习representation-learning\">表示学习（Representation\r\nLearning）</h2>\r\n<p>使用机器学习来发掘表示本身，而不仅仅把表示映射到输出,学习到的表示往往比手动设计的表示表现得更好。并且不需要人工干预就能迅速适应新的任务。</p>\r\n<h2 id=\"变差因素\">变差因素</h2>\r\n<p>在此背景下，‘‘因素’’这个词仅指代影响的不同来源；因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反，它们可能是现实世界中观察不到的物体或者不可观测的力，但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因，它们还可能以概念的形式存在于人类的思维中。</p>\r\n<p>它们可以被看作数据的概念或者抽象，帮助我们了解这些数据的丰富多样性。</p>\r\n<h2 id=\"可见层\">可见层</h2>\r\n<p>也就是神经网路的输入层，这样命名的原因是因为它包含我们能观察到的变量。</p>\r\n<h2 id=\"隐藏层\">隐藏层</h2>\r\n<p>也就是神经网路的中间层。因为它们的值不在数据中给出，所以将这些层称为‘‘隐藏”;模型必须确定哪些概念有利于解释观察数据中的关系。这里的图像是每个隐藏单元表示的特征的可视化。这里也是分形的思想运用的层次。</p>\r\n<h2 id=\"输出层\">输出层</h2>\r\n<p>输出神经网路的判断也称Object Identify</p>\r\n<h2 id=\"前馈深度网络\">前馈深度网络</h2>\r\n<h3 id=\"多层感知机multilayer-perceptron\">多层感知机（Multilayer\r\nPerceptron）</h3>\r\n<p>多层感知机仅仅是一个将一组输入值映射到输出值的数学函数。该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。</p>\r\n<h2 id=\"为什么需要使用非线性函数\">为什么需要使用非线性函数</h2>\r\n<p>这是由于线性模型的局限性，一个很经典的例子是，线性模型是无法学习异或函数的。</p>\r\n<h2 id=\"分布式表示\">分布式表示</h2>\r\n<p>其思想是：系统的每一个输入都应该由多个特征表示，并且每一个特征都应该参与到多个可能输入的表示。这显然也与神经网络每一层layer与layer之间的dense有关联</p>\r\n<h2 id=\"激活函数\">激活函数</h2>\r\n<h2 id=\"损失函数\">损失函数</h2>\r\n<h2 id=\"梯度下降\">梯度下降</h2>\r\n<h2 id=\"正则化\">正则化</h2>\r\n<h2 id=\"过拟合\">过拟合</h2>\r\n<h2 id=\"线性代数\">线性代数</h2>\r\n<h3 id=\"主对角线\">主对角线</h3>\r\n<p>即满足<span class=\"math display\">\\[a =\r\n\\{a_{i,j}|i=j\\}\\]</span>的元素构成的线，特殊的<span\r\nclass=\"math display\">\\[n\\not =m\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/7WA9zDuB2UYrlKF.png\"\r\nalt=\"image-20240609143044969\" />\r\n<figcaption aria-hidden=\"true\">image-20240609143044969</figcaption>\r\n</figure>\r\n<h3 id=\"转置\">转置</h3>\r\n<p>即矩阵对主对角线的镜像，特俗的有<span class=\"math display\">\\[n\\not =\r\nm\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/vtux96qNrkAH8jZ.png\"\r\nalt=\"image-20240609143213322\" />\r\n<figcaption aria-hidden=\"true\">image-20240609143213322</figcaption>\r\n</figure>\r\n<h3 id=\"元素对应乘积hadamard-乘积\">元素对应乘积（Hadamard 乘积）</h3>\r\n<p>记为<span class=\"math display\">\\[A\\odot B\\]</span></p>\r\n<h3 id=\"点积\">点积</h3>\r\n<p>两个相同维数的向量x和y的点积（dot product）可看作是矩阵乘积<span\r\nclass=\"math display\">\\[A^\\top\r\nB\\]</span>​。我们可以把矩阵乘积C=AB中计算Cij的步骤看作是A的第i行和B的第j列之间的点积。</p>\r\n<p>矩阵的乘法是不满足交换律的，但是矩阵的点积是满足的。 <span\r\nclass=\"math display\">\\[\r\nx^\\top y = y^\\top x\r\n\\]</span></p>\r\n<p>矩阵乘积转置的简单形式 <span class=\"math display\">\\[\r\n(AB)^\\top = B^\\top A^\\top\r\n\\]</span> 注意顺序是不能更改的因为矩阵乘法不满足交换律</p>\r\n<h3 id=\"单位矩阵\">单位矩阵</h3>\r\n<p>单位矩阵指主对角线上的值都为1，其他地方都为零的矩阵。</p>\r\n<p>我们将保持n维向量不变的单位矩阵记作<span\r\nclass=\"math display\">\\[I_n\\]</span>。</p>\r\n<h3 id=\"逆矩阵\">逆矩阵</h3>\r\n<p>很朴素的定义，需要注意的是由于矩阵乘法不满足交换律，因此我们再说一个矩阵的逆的时候通常是说矩阵的左逆。</p>\r\n<p>对于方阵而言，它的左逆和右逆是相等的</p>\r\n<h3 id=\"线性相关与生成子空间\">线性相关与生成子空间</h3>\r\n<p>如果逆矩阵<span\r\nclass=\"math display\">\\[A^{-1}\\]</span>​存在。那么式(2.11)肯定对于每一个向量b恰好存在一个解。但是，对于方程组而言，对于向量b的某些值，有可能不存在解，或者存在无限多个解。存在多于一个解但是少于无限多个解的情况是不可能发生的；因为如果x和y都是某方程组的解，则x,y则构成了一个张成空间。</p>\r\n<p>为了分析方程有多少个解，我们可以将A的列向量看作从原点（origin）（元素都是零的向量）出发的不同方向，确定有多少种方法可以到达向量b。在这个观点下，向量x中的每个元素表示我们应该沿着这些方向走多远，即xi表示我们需要沿着第i个向量的方向走多远：\r\n<span class=\"math display\">\\[\r\nAx = \\sum _i x_i A_{:,i}\r\n\\]</span>\r\n这样的操作我们称为线性组合。形式上，一组向量的线性组合是指每个向量乘以对应标量系数之后的和，即：\r\n<span class=\"math display\">\\[\r\n\\sum _i c_i v^{(i)}\r\n\\]</span>\r\n一组向量的生成子空间（span）是原始向量线性组合后所能抵达的点的集合。</p>\r\n<p>确定Ax=b是否有解相当于确定向量b是否在A列向量的生成子空间中。这个特殊的生成子空间被称为A的列空间（column\r\nspace）或者A的值域（range）。</p>\r\n<p>为了使方程Ax=b对于任意向量<span class=\"math display\">\\[b\\in\r\n\\mathbb{R}^m\\]</span>都存在解，我们要求A的列空间构成整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>。如果<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>中的某个点不在A的列空间中，那么该点对应的b会使得该方程没有解。矩阵A的列空间是整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>的要求，意味着A至少有m列，即n&gt;=m。否则，A列空间的维数会小于m。例如，假设A是一个<span\r\nclass=\"math display\">\\[3\\times\r\n2\\]</span>的矩阵。目标b是3维的，但是x只有2维。所以无论如何修改x的值，也只能描绘出<span\r\nclass=\"math display\">\\[\\mathbb{R}^3\\]</span>空间中的二维平面。当且仅当向量b在该二维平面中时，该方程有解。</p>\r\n<p>不等式n&gt;=m仅是方程对每一点都有解的必要条件。这不是一个充分条件，因为有些列向量可能是冗余的。假设有一个<span\r\nclass=\"math display\">\\[\\mathbb{R}^{2\\times2}\\]</span>中的矩阵，它的两个列向量是相同的。那么它的列空间和它的一个列向量作为矩阵的列空间是一样的。换言之，虽然该矩阵有2列，但是它的列空间仍然只是一条线，不能涵盖整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^2\\]</span>空间。</p>\r\n<p>正式地说，这种冗余被称为线性相关（linear\r\ndependence）。如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为线性无关（linearly\r\nindependent）。如果某个向量是一组向量中某些向量的线性组合，那么我们将这个向量加入这组向量后不会增加这组向量的生成子空间。这意味着，如果一个矩阵的列空间涵盖整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>，那么该矩阵必须包含至少一组m个线性无关的向量。这是对于每一个向量b的取值都有解的充分必要条件。值得注意的是，这个条件是说该向量集恰好有m个线性无关的列向量，而不是至少m个。不存在一个m维向量的集合具有多于m个彼此线性不相关的列向量，但是一个有多于m个列向量的矩阵有可能拥有不止一个大小为m的线性无关向量集。</p>\r\n<p>要想使矩阵可逆，我们还需要保证对于每一个b值至多有一个解。为此，我们需要确保该矩阵至多有m个列向量。否则，该方程会有不止一个解。</p>\r\n<h3 id=\"奇异矩阵singular-square\">奇异矩阵（singular square）</h3>\r\n<p>该矩阵必须是一个方阵（square），即m=n，并且所有列向量都是线性无关的。一个列向量线性相关的方阵被称为奇异的（singular）。</p>\r\n<h3 id=\"矩阵右乘\">矩阵右乘</h3>\r\n<p><span class=\"math display\">\\[\r\nAA^{-1}=I\r\n\\]</span></p>\r\n<h3 id=\"范数norm\">范数（norm）</h3>\r\n<p>用来衡量一个向量的大小。机器学习中常用范数衡量向量大小。形式上<span\r\nclass=\"math display\">\\[L^p\\]</span>定义如下 <span\r\nclass=\"math display\">\\[\r\n||x||_p = \\left( \\sum _i |x_i|^p \\right) ^{\\frac{1}{p}}\r\n\\]</span> 范数（包括Lp范数）是将向量映射到非负值的函数</p>\r\n<p>严格的讲，范数是满足以下性质的函数</p>\r\n<ul>\r\n<li>f(x) = 0 =&gt; x=0</li>\r\n<li>f(x+y) &lt;=f(x) + f(y) （三角不等式）</li>\r\n<li>对<span class=\"math display\">\\[\\forall \\alpha \\in\r\n\\mathbb{R},f(\\alpha x) = |\\alpha|f(x)\\]</span></li>\r\n</ul>\r\n<p>当p= 2时，<span\r\nclass=\"math display\">\\[L^2\\]</span>范数被称为欧几里得范数（Euclidean\r\nnorm）。它表示从原点出发到向量x确定的点的欧几里得距离。<span\r\nclass=\"math display\">\\[L^2\\]</span>范数在机器学习中出现地十分频繁，经常简化表示为∥x∥，略去了下标2。平方<span\r\nclass=\"math display\">\\[L^2\\]</span>范数也经常用来衡量向量的大小，可以简单地通过点积<span\r\nclass=\"math display\">\\[x ^\\top x\\]</span>计算。</p>\r\n<p>但是在很多情况下，平方<span\r\nclass=\"math display\">\\[L^2\\]</span>范数也可能不受欢迎，因为它在原点附近增长得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数：<span\r\nclass=\"math display\">\\[L^1\\]</span>范数。<span\r\nclass=\"math display\">\\[L^1\\]</span>范数可以简化如下： <span\r\nclass=\"math display\">\\[\r\n||x||_1 = \\sum _i |x_i|\r\n\\]</span>\r\n有时候我们会统计向量中非零元素的个数来衡量向量的大小。有些作者将这种函数称为“<span\r\nclass=\"math display\">\\[L^0\\]</span>范数’’，但是这个术语在数学意义上是不对的</p>\r\n<p>另外一个经常在机器学习中出现的范数是<span\r\nclass=\"math display\">\\[L^\\inf\\]</span>范数，也被称为最大范数（maxnorm）。这个范数表示向量中具有最大幅值的元素的绝对值：\r\n<span class=\"math display\">\\[\r\n||x||_1 = \\max _i |x_i|\r\n\\]</span>\r\n有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用Frobenius范数（Frobenius\r\nnorm）， <span class=\"math display\">\\[\r\n||A||_F = \\sqrt{\\sum _{i,j} A^2_{i,j}}\r\n\\]</span> 两个向量的点集可以用范数来表示，具体的 <span\r\nclass=\"math display\">\\[\r\nx^\\top y = ||x||_2 ||y||_2 cos\\theta\r\n\\]</span> <span\r\nclass=\"math display\">\\[\\theta\\]</span>表示x,y之间的夹角</p>\r\n<h3 id=\"对角矩阵\">对角矩阵</h3>\r\n<p>只在主对角线上含有非零元素，，其他位置都是零。用diag(<span\r\nclass=\"math display\">\\[v\\]</span>)表示一个对角矩阵。</p>\r\n<p>计算乘法diag(v)x，我们只需要将x中的每个元素xi放大vi倍。换言之，diag(v)x=v⊙x</p>\r\n<p>对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，在这种情况下，diag(v)1=diag([1/v1;....\r\n;1/vn]⊤)。</p>\r\n<p>非方阵的对角矩阵没有逆矩阵</p>\r\n<h3 id=\"对称矩阵\">对称矩阵</h3>\r\n<p>对称矩阵是矩阵的转置和自己相等的矩阵 <span class=\"math display\">\\[\r\nA = A ^\\top\r\n\\]</span></p>\r\n<h3 id=\"单位矩阵-1\">单位矩阵</h3>\r\n<p>具有单位范数的矩阵</p>\r\n<p>如果<span class=\"math display\">\\[x^\\top\r\ny=0\\]</span>，那么向量x和向量y互相正交（orthogonal）。如果两个向量都有非零范数，那么这两个向量之间的夹角是90度。在Rn中，至多有n个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为1，那么我们称它们是标准正交（orthonormal）。</p>\r\n<p>正交矩阵（orthogonal\r\nmatrix）是指行向量和列向量是分别标准正交的方阵，更具体的，他们是满足以下条件的矩阵\r\n<span class=\"math display\">\\[\r\nA^\\top A = A ^\\top A = I.\r\n\\]</span> 这样意味着 <span class=\"math display\">\\[\r\nA^{-1} = A^\\top\r\n\\]</span></p>\r\n<h3 id=\"特征分解\">特征分解</h3>\r\n<p>特征分解（eigendecomposition）是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值。</p>\r\n<p>方阵A的特征向量（eigenvector）是指与A相乘后相当于对该向量进行缩放的非零向量v：\r\n<span class=\"math display\">\\[\r\nA v = \\lambda v\r\n\\]</span> 标量<span\r\nclass=\"math inline\">\\(\\lambda\\)</span>被称为这个特征向量对应的特征值（eigenvalue）。</p>\r\n<p>（类似地，我们也可以定义左特征向量（left eigenvector）<span\r\nclass=\"math display\">\\[v^⊤A=\\lambda\r\nv^⊤\\]</span>，但是通常我们更关注右特征向量（right eigenvector））。</p>\r\n<p>所有特征值都是正数的矩阵被称为正定（positive\r\ndefinite）；所有特征值都是非负数的矩阵被称为半正定（positive\r\nsemidefinite）。同样地，所有特征值都是负数的矩阵被称为负定（negative\r\ndefinite）；所有特征值都是非正数的矩阵被称为半负定（negative\r\nsemidefinite）。</p>\r\n<p>然而，我们也常常希望将矩阵分解（decompose）成特征值和特征向量。这样可以帮助我们分析矩阵的特定性质，就像质因数分解有助于我们理解整数。</p>\r\n<p>矩阵A的特征分解可以记作 <span class=\"math display\">\\[\r\nA = V diag(\\lambda) V^{-1}\r\n\\]</span>\r\n不是每一个矩阵都可以分解成特征值和特征向量。在某些情况下，特征分解存在，但是会涉及复数而非实数。</p>\r\n<p>其中Q是A的特征向量组成的正交矩阵，是对角矩阵。特征值<span\r\nclass=\"math display\">\\[\\lambda_{i;i}\\]</span>对应的特征向量是矩阵Q的第i列，记作Q:;i。因为Q是正交矩阵，我们可以将A看作沿方向v(i)延展i倍的空间</p>"},{"title":"MindSpore专题——第一章、安装","date":"2024-08-14T11:47:58.000Z","_content":"## Ubuntu系统安装\n\n### 环境\n\n VMware Workstation 17Pro\n\n1. 原有的系统为Ubuntu22.04因此下载Ubuntu18.04 镜像光盘文件\n   -  通过cat /proc/version文件查看当前的系统版本\n\n<!--more-->\n\n![image-20240604174857507](https://s2.loli.net/2024/06/04/9tNsqxUkrJFHQOc.png)\n\n2. 下载Ubuntu18.04系统光盘https://releases.ubuntu.com/18.04/ubuntu-18.04.6-desktop-amd64.iso\n\n3. VMware简易安装后对18旧版本遇到的问题的解决方案\n   1. 旧版本屏幕无法适应屏幕，想到vmwaretools的问题，检查该部分发现并未自动安装\n\n通过重新启动挂载\\VMware\\VMware Workstation目录下linux.iso文件出现\n\n![image-20240604182654391](https://s2.loli.net/2024/06/06/IWioHYeLj9JgMtb.png)\n\n安装该软件\n\n![image-20240604182901358](https://s2.loli.net/2024/06/04/vIXUHlWVx2sb1co.png)\n\n```shell\nsudo perl vmware-install.pl\n```\n\n通过在解压的目录下运行该脚本文件安装vmware-tools\n\n![image-20240604183315457](https://s2.loli.net/2024/06/04/pJI4WAgKdYmvPES.png)\n\n在经过一系列configure后安装完成\n\n由此问题解决\n\n \t2. update apt-get\n\n```shell\nsudo update apt-get\n```\n\n\n\n![image-20240604184437693](https://s2.loli.net/2024/06/04/9cXhEq3V2DMiWNx.png)\n\n3. 修复vmware剪贴板不共享的问题\n\n```shell\nsudo apt-get install open-vm-tools-desktop\n```\n\n​\t安装该软件一路回车即可\n\n## 尝试自动脚本安装\n\n由于vmware对nvdia的支持补全，此处采用版本如下\n\n![image-20240604183528425](https://s2.loli.net/2024/06/04/5e3IG9tuAPdfjKr.png)\n\n进入默认源码目录进行操作\n\n![image-20240604183616489](https://s2.loli.net/2024/06/04/K8tqnFmeQuOMiZc.png)\n\n![image-20240604185144770](https://s2.loli.net/2024/06/04/d1YgnqUjbWJfXLH.png)\n\n由于系统全新，设定一下系统密码并切换到root用户\n\n![image-20240604185341858](https://s2.loli.net/2024/06/04/KQiWzJtOUsS2mnT.png)\n\n根据官网下载\n\n![image-20240604185417980](https://s2.loli.net/2024/06/04/g3BCMVGQHDzjAUL.png)\n\n根据官网命令执行脚本\n\n![MindSpore安装成功](https://s2.loli.net/2024/06/05/xBlJgjPwU3krsqa.png)\n\n可见安装成功\n\n## Windows中安装MindSpore以及杂项\n\n1. 相似的安装程序，记得更改选定的官方安装脚本\n2. Windows一般位于C:\\Users\\%USERNAME%\\pip 目录下存在配置文件，可通过更改该配置文件修改镜像，在使用镜像中启用代理可能会导致满屏的飘红报错\n3. 对于MindSpore的前置软件安装而言，最重要易错的为Python的版本，建议多通过\n\n```shell\npython --version\n```\n4. 查看当前版本，及时正确配置环境变量","source":"_posts/special_subject/MindSpore/Chapters/First_Install.md","raw":"---\ntitle: MindSpore专题——第一章、安装\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## Ubuntu系统安装\n\n### 环境\n\n VMware Workstation 17Pro\n\n1. 原有的系统为Ubuntu22.04因此下载Ubuntu18.04 镜像光盘文件\n   -  通过cat /proc/version文件查看当前的系统版本\n\n<!--more-->\n\n![image-20240604174857507](https://s2.loli.net/2024/06/04/9tNsqxUkrJFHQOc.png)\n\n2. 下载Ubuntu18.04系统光盘https://releases.ubuntu.com/18.04/ubuntu-18.04.6-desktop-amd64.iso\n\n3. VMware简易安装后对18旧版本遇到的问题的解决方案\n   1. 旧版本屏幕无法适应屏幕，想到vmwaretools的问题，检查该部分发现并未自动安装\n\n通过重新启动挂载\\VMware\\VMware Workstation目录下linux.iso文件出现\n\n![image-20240604182654391](https://s2.loli.net/2024/06/06/IWioHYeLj9JgMtb.png)\n\n安装该软件\n\n![image-20240604182901358](https://s2.loli.net/2024/06/04/vIXUHlWVx2sb1co.png)\n\n```shell\nsudo perl vmware-install.pl\n```\n\n通过在解压的目录下运行该脚本文件安装vmware-tools\n\n![image-20240604183315457](https://s2.loli.net/2024/06/04/pJI4WAgKdYmvPES.png)\n\n在经过一系列configure后安装完成\n\n由此问题解决\n\n \t2. update apt-get\n\n```shell\nsudo update apt-get\n```\n\n\n\n![image-20240604184437693](https://s2.loli.net/2024/06/04/9cXhEq3V2DMiWNx.png)\n\n3. 修复vmware剪贴板不共享的问题\n\n```shell\nsudo apt-get install open-vm-tools-desktop\n```\n\n​\t安装该软件一路回车即可\n\n## 尝试自动脚本安装\n\n由于vmware对nvdia的支持补全，此处采用版本如下\n\n![image-20240604183528425](https://s2.loli.net/2024/06/04/5e3IG9tuAPdfjKr.png)\n\n进入默认源码目录进行操作\n\n![image-20240604183616489](https://s2.loli.net/2024/06/04/K8tqnFmeQuOMiZc.png)\n\n![image-20240604185144770](https://s2.loli.net/2024/06/04/d1YgnqUjbWJfXLH.png)\n\n由于系统全新，设定一下系统密码并切换到root用户\n\n![image-20240604185341858](https://s2.loli.net/2024/06/04/KQiWzJtOUsS2mnT.png)\n\n根据官网下载\n\n![image-20240604185417980](https://s2.loli.net/2024/06/04/g3BCMVGQHDzjAUL.png)\n\n根据官网命令执行脚本\n\n![MindSpore安装成功](https://s2.loli.net/2024/06/05/xBlJgjPwU3krsqa.png)\n\n可见安装成功\n\n## Windows中安装MindSpore以及杂项\n\n1. 相似的安装程序，记得更改选定的官方安装脚本\n2. Windows一般位于C:\\Users\\%USERNAME%\\pip 目录下存在配置文件，可通过更改该配置文件修改镜像，在使用镜像中启用代理可能会导致满屏的飘红报错\n3. 对于MindSpore的前置软件安装而言，最重要易错的为Python的版本，建议多通过\n\n```shell\npython --version\n```\n4. 查看当前版本，及时正确配置环境变量","slug":"special_subject/MindSpore/Chapters/First_Install","published":1,"updated":"2024-08-16T08:58:49.871Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjam001zlowvdtz1fm6v","content":"<h2 id=\"ubuntu系统安装\">Ubuntu系统安装</h2>\r\n<h3 id=\"环境\">环境</h3>\r\n<p>VMware Workstation 17Pro</p>\r\n<ol type=\"1\">\r\n<li>原有的系统为Ubuntu22.04因此下载Ubuntu18.04 镜像光盘文件\r\n<ul>\r\n<li>通过cat /proc/version文件查看当前的系统版本</li>\r\n</ul></li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/9tNsqxUkrJFHQOc.png\"\r\nalt=\"image-20240604174857507\" />\r\n<figcaption aria-hidden=\"true\">image-20240604174857507</figcaption>\r\n</figure>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>下载Ubuntu18.04系统光盘https://releases.ubuntu.com/18.04/ubuntu-18.04.6-desktop-amd64.iso</p></li>\r\n<li><p>VMware简易安装后对18旧版本遇到的问题的解决方案</p>\r\n<ol type=\"1\">\r\n<li>旧版本屏幕无法适应屏幕，想到vmwaretools的问题，检查该部分发现并未自动安装</li>\r\n</ol></li>\r\n</ol>\r\n<p>通过重新启动挂载Workstation目录下linux.iso文件出现</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/IWioHYeLj9JgMtb.png\"\r\nalt=\"image-20240604182654391\" />\r\n<figcaption aria-hidden=\"true\">image-20240604182654391</figcaption>\r\n</figure>\r\n<p>安装该软件</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/vIXUHlWVx2sb1co.png\"\r\nalt=\"image-20240604182901358\" />\r\n<figcaption aria-hidden=\"true\">image-20240604182901358</figcaption>\r\n</figure>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo perl vmware-install.pl</span><br></pre></td></tr></table></figure>\r\n<p>通过在解压的目录下运行该脚本文件安装vmware-tools</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/pJI4WAgKdYmvPES.png\"\r\nalt=\"image-20240604183315457\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183315457</figcaption>\r\n</figure>\r\n<p>在经过一系列configure后安装完成</p>\r\n<p>由此问题解决</p>\r\n<pre><code>2. update apt-get</code></pre>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo update apt-get</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/9cXhEq3V2DMiWNx.png\"\r\nalt=\"image-20240604184437693\" />\r\n<figcaption aria-hidden=\"true\">image-20240604184437693</figcaption>\r\n</figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li>修复vmware剪贴板不共享的问题</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>\r\n<p>​ 安装该软件一路回车即可</p>\r\n<h2 id=\"尝试自动脚本安装\">尝试自动脚本安装</h2>\r\n<p>由于vmware对nvdia的支持补全，此处采用版本如下</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/5e3IG9tuAPdfjKr.png\"\r\nalt=\"image-20240604183528425\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183528425</figcaption>\r\n</figure>\r\n<p>进入默认源码目录进行操作</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/K8tqnFmeQuOMiZc.png\"\r\nalt=\"image-20240604183616489\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183616489</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/d1YgnqUjbWJfXLH.png\"\r\nalt=\"image-20240604185144770\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185144770</figcaption>\r\n</figure>\r\n<p>由于系统全新，设定一下系统密码并切换到root用户</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/KQiWzJtOUsS2mnT.png\"\r\nalt=\"image-20240604185341858\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185341858</figcaption>\r\n</figure>\r\n<p>根据官网下载</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/g3BCMVGQHDzjAUL.png\"\r\nalt=\"image-20240604185417980\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185417980</figcaption>\r\n</figure>\r\n<p>根据官网命令执行脚本</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/xBlJgjPwU3krsqa.png\"\r\nalt=\"MindSpore安装成功\" />\r\n<figcaption aria-hidden=\"true\">MindSpore安装成功</figcaption>\r\n</figure>\r\n<p>可见安装成功</p>\r\n<h2\r\nid=\"windows中安装mindspore以及杂项\">Windows中安装MindSpore以及杂项</h2>\r\n<ol type=\"1\">\r\n<li>相似的安装程序，记得更改选定的官方安装脚本</li>\r\n<li>Windows一般位于C:%USERNAME%目录下存在配置文件，可通过更改该配置文件修改镜像，在使用镜像中启用代理可能会导致满屏的飘红报错</li>\r\n<li>对于MindSpore的前置软件安装而言，最重要易错的为Python的版本，建议多通过</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python --version</span><br></pre></td></tr></table></figure>\r\n<ol start=\"4\" type=\"1\">\r\n<li>查看当前版本，及时正确配置环境变量</li>\r\n</ol>\r\n","length":464,"excerpt":"<h2 id=\"ubuntu系统安装\">Ubuntu系统安装</h2>\r\n<h3 id=\"环境\">环境</h3>\r\n<p>VMware Workstation 17Pro</p>\r\n<ol type=\"1\">\r\n<li>原有的系统为Ubuntu22.04因此下载Ubuntu18.04 镜像光盘文件\r\n<ul>\r\n<li>通过cat /proc/version文件查看当前的系统版本</li>\r\n</ul></li>\r\n</ol>","more":"<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/9tNsqxUkrJFHQOc.png\"\r\nalt=\"image-20240604174857507\" />\r\n<figcaption aria-hidden=\"true\">image-20240604174857507</figcaption>\r\n</figure>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>下载Ubuntu18.04系统光盘https://releases.ubuntu.com/18.04/ubuntu-18.04.6-desktop-amd64.iso</p></li>\r\n<li><p>VMware简易安装后对18旧版本遇到的问题的解决方案</p>\r\n<ol type=\"1\">\r\n<li>旧版本屏幕无法适应屏幕，想到vmwaretools的问题，检查该部分发现并未自动安装</li>\r\n</ol></li>\r\n</ol>\r\n<p>通过重新启动挂载Workstation目录下linux.iso文件出现</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/IWioHYeLj9JgMtb.png\"\r\nalt=\"image-20240604182654391\" />\r\n<figcaption aria-hidden=\"true\">image-20240604182654391</figcaption>\r\n</figure>\r\n<p>安装该软件</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/vIXUHlWVx2sb1co.png\"\r\nalt=\"image-20240604182901358\" />\r\n<figcaption aria-hidden=\"true\">image-20240604182901358</figcaption>\r\n</figure>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo perl vmware-install.pl</span><br></pre></td></tr></table></figure>\r\n<p>通过在解压的目录下运行该脚本文件安装vmware-tools</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/pJI4WAgKdYmvPES.png\"\r\nalt=\"image-20240604183315457\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183315457</figcaption>\r\n</figure>\r\n<p>在经过一系列configure后安装完成</p>\r\n<p>由此问题解决</p>\r\n<pre><code>2. update apt-get</code></pre>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo update apt-get</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/9cXhEq3V2DMiWNx.png\"\r\nalt=\"image-20240604184437693\" />\r\n<figcaption aria-hidden=\"true\">image-20240604184437693</figcaption>\r\n</figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li>修复vmware剪贴板不共享的问题</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>\r\n<p>​ 安装该软件一路回车即可</p>\r\n<h2 id=\"尝试自动脚本安装\">尝试自动脚本安装</h2>\r\n<p>由于vmware对nvdia的支持补全，此处采用版本如下</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/5e3IG9tuAPdfjKr.png\"\r\nalt=\"image-20240604183528425\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183528425</figcaption>\r\n</figure>\r\n<p>进入默认源码目录进行操作</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/K8tqnFmeQuOMiZc.png\"\r\nalt=\"image-20240604183616489\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183616489</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/d1YgnqUjbWJfXLH.png\"\r\nalt=\"image-20240604185144770\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185144770</figcaption>\r\n</figure>\r\n<p>由于系统全新，设定一下系统密码并切换到root用户</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/KQiWzJtOUsS2mnT.png\"\r\nalt=\"image-20240604185341858\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185341858</figcaption>\r\n</figure>\r\n<p>根据官网下载</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/g3BCMVGQHDzjAUL.png\"\r\nalt=\"image-20240604185417980\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185417980</figcaption>\r\n</figure>\r\n<p>根据官网命令执行脚本</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/xBlJgjPwU3krsqa.png\"\r\nalt=\"MindSpore安装成功\" />\r\n<figcaption aria-hidden=\"true\">MindSpore安装成功</figcaption>\r\n</figure>\r\n<p>可见安装成功</p>\r\n<h2\r\nid=\"windows中安装mindspore以及杂项\">Windows中安装MindSpore以及杂项</h2>\r\n<ol type=\"1\">\r\n<li>相似的安装程序，记得更改选定的官方安装脚本</li>\r\n<li>Windows一般位于C:%USERNAME%目录下存在配置文件，可通过更改该配置文件修改镜像，在使用镜像中启用代理可能会导致满屏的飘红报错</li>\r\n<li>对于MindSpore的前置软件安装而言，最重要易错的为Python的版本，建议多通过</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python --version</span><br></pre></td></tr></table></figure>\r\n<ol start=\"4\" type=\"1\">\r\n<li>查看当前版本，及时正确配置环境变量</li>\r\n</ol>"},{"title":"MindSpore专题","date":"2024-08-14T11:47:58.000Z","_content":"[MindSpore](https://www.mindspore.cn/tutorials/zh-CN/r2.3.0rc2/beginner/quick_start.html)\n\n<!--more-->\n\n## MindSpore 数据处理\n\n### download\n\n```shell\npip install download\n```\n\n下载download python模块\n\n### 引包并下载所需数据集\n\n```python\nimport mindspore\nfrom mindspore import nn\nfrom mindspore.dataset import vision, transforms\nfrom mindspore.dataset import MnistDataset\n```\n\n```python\n# Download data from open datasets\nfrom download import download\n\nurl = \"https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/\" \\\n      \"notebook/datasets/MNIST_Data.zip\"\npath = download(url, \"./\", kind=\"zip\", replace=True)\n```\n\n![image-20240605204942126](https://s2.loli.net/2024/06/05/EuK87I6YUjdAs2v.png)\n\n下载下来MNIST_Data数据，根据官网这是一份Mnist数据集，结构如下\n\n```\nMNIST_Data\n└── train\n    ├── train-images-idx3-ubyte (60000个训练图片)\n    ├── train-labels-idx1-ubyte (60000个训练标签)\n└── test\n    ├── t10k-images-idx3-ubyte (10000个测试图片)\n    ├── t10k-labels-idx1-ubyte (10000个测试标签)\n```\n\n### MindSpore数据处理\n\n```python\nprint(train_dataset.get_col_names())\n```\n\n打印数据集中所包含的数据列名\n\n> MindSpore的dataset使用数据处理流水线（Data Processing Pipeline），需指定map、batch、shuffle等操作。这里我们使用map对图像数据及标签进行变换处理，将输入的图像缩放为1/255，根据均值0.1307和标准差值0.3081进行归一化处理，然后将处理好的数据集打包为大小为64的batch。\n\n上面是官网对以下代码的处理。\n\n其中出现了一个新名词——[归一化处理](#归一化处理)，这里使用的是Z-score normalization。\n\n```python\ndef datapipe(dataset, batch_size):\n    image_transforms = [\n        vision.Rescale(1.0 / 255.0, 0),\n        vision.Normalize(mean=(0.1307,), std=(0.3081,)),\n        vision.HWC2CHW()\n    ]\n    label_transform = transforms.TypeCast(mindspore.int32)\n\n    dataset = dataset.map(image_transforms, 'image')\n    dataset = dataset.map(label_transform, 'label')\n    dataset = dataset.batch(batch_size)\n    return dataset\n\n\n# Map vision transforms and batch dataset\ntrain_dataset = datapipe(train_dataset, 64)\ntest_dataset = datapipe(test_dataset, 64)\n```\n\n---\n\n可使用[create_tuple_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_tuple_iterator.html) 或[create_dict_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_dict_iterator.html)对数据集进行迭代访问，查看数据和标签的shape和datatype。\n\n```python\nfor image, label in test_dataset.create_tuple_iterator():\n    print(f\"Shape of image [N, C, H, W]: {image.shape} {image.dtype}\")\n    print(f\"Shape of label: {label.shape} {label.dtype}\")\n    break\n```\n\n>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32\n>Shape of label: (64,) Int32\n\n```python\nfor data in test_dataset.create_dict_iterator():\n    print(f\"Shape of image [N, C, H, W]: {data['image'].shape} {data['image'].dtype}\")\n    print(f\"Shape of label: {data['label'].shape} {data['label'].dtype}\")\n    break\n```\n\n> Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32\n> Shape of label: (64,) Int32\n\n更多细节详见[数据集 Dataset](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/dataset.html)与[数据变换 Transforms](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/transforms.html)。\n\n### 网络构建\n\n```python\n# Define model\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512),\n            nn.ReLU(),\n            nn.Dense(512, 512),\n            nn.ReLU(),\n            nn.Dense(512, 10)\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\nmodel = Network()\nprint(model)\n```\n\n> Network<\n>   (flatten): Flatten<>\n>   (dense_relu_sequential): SequentialCell<\n>     (0): Dense<input_channels=784, output_channels=512, has_bias=True>\n>     (1): ReLU<>\n>     (2): Dense<input_channels=512, output_channels=512, has_bias=True>\n>     (3): ReLU<>\n>     (4): Dense<input_channels=512, output_channels=10, has_bias=True>\n>     >\n\n以上为网格的构建以及其输出，有以下几点需要注意\n\n1. 上面重命名过MindSpore中的nn类是构建所有网格的基类，也是网格的基本单元\n2. 当需要自定义网络时可以重写``nn.Cell`类重写`__init__`方法和`construct`方法\n3. `__init__`包含所有网络层的定义`construct`中包含数据（[Tensor](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/tensor.html)）的变换过程\n\n> `mindspore.nn`类是构建所有网络的基类，也是网络的基本单元。当用户需要自定义网络时，可以继承`nn.Cell`类，并重写`__init__`方法和`construct`方法。`__init__`包含所有网络层的定义，`construct`中包含数据（[Tensor](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/tensor.html)）的变换过程。\n\n### 模型训练\n\n个人菜狗形象的想，实际上这里的网格神经网络对图像的识别类似一种带指向的可变哈希函数（只不过这个函数的实现比较复杂和通用）。他是从大量信息到小量准确抽象的描述过程。下面是[3.2. 机器学习工作流 — 机器学习系统：设计和实现 1.0.0 documentation (openmlsys.github.io)](https://openmlsys.github.io/chapter_programming_interface/ml_workflow.html)手册上的机器学习流程图，这里以求形象的理解\n\n![img_workflow](./../img/img_workflow.svg)\n\n> 在模型训练中，一个完整的训练过程（step）需要实现以下三步：\n>\n> 1. **正向计算**：模型预测结果（logits），并与正确标签（label）求预测损失（loss）。\n> 2. **反向传播**：利用自动微分机制，自动求模型参数（parameters）对于loss的梯度（gradients）。\n> 3. **参数优化**：将梯度更新到参数上。\n\n> MindSpore使用函数式自动微分机制，因此针对上述步骤需要实现：\n>\n> 1. 定义正向计算函数。\n> 2. 使用[value_and_grad](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.value_and_grad.html)通过函数变换获得梯度计算函数。\n> 3. 定义训练函数，使用[set_train](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Cell.html#mindspore.nn.Cell.set_train)设置为训练模式，执行正向计算、反向传播和参数优化。\n\n```python\n# Instantiate loss function and optimizer\nloss_fn = nn.CrossEntropyLoss()\noptimizer = nn.SGD(model.trainable_params(), 1e-2)\n\n# 1. Define forward function\ndef forward_fn(data, label):\n    logits = model(data)\n    loss = loss_fn(logits, label)\n    return loss, logits\n\n# 2. Get gradient function\ngrad_fn = mindspore.value_and_grad(forward_fn, None, optimizer.parameters, has_aux=True)\n\n# 3. Define function of one-step training\ndef train_step(data, label):\n    (loss, _), grads = grad_fn(data, label)\n    optimizer(grads)\n    return loss\n\ndef train(model, dataset):\n    size = dataset.get_dataset_size()\n    model.set_train()\n    for batch, (data, label) in enumerate(dataset.create_tuple_iterator()):\n        loss = train_step(data, label)\n\n        if batch % 100 == 0:\n            loss, current = loss.asnumpy(), batch\n            print(f\"loss: {loss:>7f}  [{current:>3d}/{size:>3d}]\")\n```\n\n> 除训练外，我们定义测试函数，用来评估模型的性能。\n\n```python\ndef test(model, dataset, loss_fn):\n    num_batches = dataset.get_dataset_size()\n    model.set_train(False)\n    total, test_loss, correct = 0, 0, 0\n    for data, label in dataset.create_tuple_iterator():\n        pred = model(data)\n        total += len(data)\n        test_loss += loss_fn(pred, label).asnumpy()\n        correct += (pred.argmax(1) == label).asnumpy().sum()\n    test_loss /= num_batches\n    correct /= total\n    print(f\"Test: \\n Accuracy: {(100*correct):>0.1f}%, Avg loss: {test_loss:>8f} \\n\")\n```\n\n> 训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。\n\n```python\nepochs = 3\nfor t in range(epochs):\n    print(f\"Epoch {t+1}\\n-------------------------------\")\n    train(model, train_dataset)\n    test(model, test_dataset, loss_fn)\nprint(\"Done!\")\n```\n\n>```\n>Epoch 1\n>-------------------------------\n>loss: 2.302088  [  0/938]\n>loss: 2.290692  [100/938]\n>loss: 2.266338  [200/938]\n>loss: 2.205240  [300/938]\n>loss: 1.907198  [400/938]\n>loss: 1.455603  [500/938]\n>loss: 0.861103  [600/938]\n>loss: 0.767219  [700/938]\n>loss: 0.422253  [800/938]\n>loss: 0.513922  [900/938]\n>Test:\n> Accuracy: 83.8%, Avg loss: 0.529534\n>\n>Epoch 2\n>-------------------------------\n>loss: 0.580867  [  0/938]\n>loss: 0.479347  [100/938]\n>loss: 0.677991  [200/938]\n>loss: 0.550141  [300/938]\n>loss: 0.226565  [400/938]\n>loss: 0.314738  [500/938]\n>loss: 0.298739  [600/938]\n>loss: 0.459540  [700/938]\n>loss: 0.332978  [800/938]\n>loss: 0.406709  [900/938]\n>Test:\n> Accuracy: 90.2%, Avg loss: 0.334828\n>\n>Epoch 3\n>-------------------------------\n>loss: 0.461890  [  0/938]\n>loss: 0.242303  [100/938]\n>loss: 0.281414  [200/938]\n>loss: 0.207835  [300/938]\n>loss: 0.206000  [400/938]\n>loss: 0.409646  [500/938]\n>loss: 0.193608  [600/938]\n>loss: 0.217575  [700/938]\n>loss: 0.212817  [800/938]\n>loss: 0.202862  [900/938]\n>Test:\n> Accuracy: 91.9%, Avg loss: 0.280962\n>\n>Done!\n>```\n\n> 训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。\n\n### 保存模型\n\n模型训练完成后，需要将其参数进行保存。\n\n```python\n# Save checkpoint\nmindspore.save_checkpoint(model, \"model.ckpt\")\nprint(\"Saved Model to model.ckpt\")\n```\n\n> Saved Model to model.ckpt\n\n### 加载模型\n\n> 加载保存的权重分为两步：\n>\n> 1. 重新实例化模型对象，构造模型。\n> 2. 加载模型参数，并将其加载至模型上。\n\n```python\n# Instantiate a random initialized model\nmodel = Network()\n# Load checkpoint and load parameter to model\nparam_dict = mindspore.load_checkpoint(\"model.ckpt\")\nparam_not_load, _ = mindspore.load_param_into_net(model, param_dict)\nprint(param_not_load)\n```\n\n> `param_not_load未被加载的参数列表，为空时代表所有参数均加载成功。`\n\n> 加载后的模型可以直接用于预测推理。\n\n```python\nmodel.set_train(False)\nfor data, label in test_dataset:\n    pred = model(data)\n    predicted = pred.argmax(1)\n    print(f'Predicted: \"{predicted[:10]}\", Actual: \"{label[:10]}\"')\n    break\n```\n\n以上就是一个简单的图像识别机械学习\n\n**注意在加载模型的过程中必须定义模型构建与datapipe**\n\n## 归一化处理\n\n> 一些传送门：\n> [归一化基础知识点 — PaddleEdu documentation (paddlepedia.readthedocs.io)](https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/normalization/basic_normalization.html)\n>\n> [Numpy数组归一化|极客教程 (geek-docs.com)](https://geek-docs.com/numpy/numpy-ask-answer/normalize-numpy-array_z1.html)\n\n归一化是一种数据处理方式，能将数据经过处理后限制在某个固定范围内。\n\n### 归一化处理的两种形式\n\n归一化存在两种形式\n\n1. 将数处理为 [0, 1] 之间的小数，其目的是为了在随后的数据处理过程中更便捷，其他情况下，也可将数据处理到 [-1, 1] 之间，或其他的固定范围内。\n\n> 例如，在图像处理中，就会将图像从 [0, 255] 归一化到 [0, 1]之间，这样既不会改变图像本身的信息储存，又可加速后续的网络处理。\n\n2. 通过归一化将有[量纲表达式](#有/无量纲表达式)变成[无量纲表达式](#有/无量纲表达式)。\n\n### 为什么要进行归一化\n\n1. 解决数据间的可比性问题\n2. 数据归一化后，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。[为什么能提高收敛速度](为什么归一化能提高求解最优解的速度).\n\n### 归一化类型\n\n1. Min-max normalization (Rescaling) 范围为[0,1]:\n\n$$\nx^{'} = \\frac{x - min(x)}{max(x) - min(x)}\n$$\n\n2. Mean normalization范围为[-1,1]：\n\n$$\nx^{'} = \\frac{x - mean(x)}{max(x) - min(x)}\n$$\n\n> mean(x)：x数据的平均值\n\n​\tMin-max归一化和mean归一化适合在最大最小值明确不变的情况下使用，比如图像处理时，灰度值限定在 [0, 255] 的范围内，就可以用min-max归一化将其处理到[0, 1]之间。在最大最小值不明确时，每当有新数据加入，都可能会改变最大或最小值，导致归一化结果不稳定，后续使用效果也不稳定。同时，数据需要相对稳定，如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。如果对处理后的数据范围有严格要求，也应使用min-max归一化或mean归一化。\n\n3. Z-score normalization (Standardization)范围为实数集：\n\n$$\nx^{'} = \\frac{x - \\mu}{\\sigma}\n$$\n\n> 𝜇、𝜎 分别为样本数据的均值和标准差。\n\n​\tZ-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。标准化会改变数据的状态分布，但不会改变分布的种类。特别地，神经网络中经常会使用到z-score归一化，针对这一点，我们将在后续的文章中进行详细的介绍。\n\n4. 对数归一化：\n\n$$\nx^{'} = \\frac{\\lg x}{\\lg max(x)}\n$$\n\n5. 反正切函数归一化：\n\n$$\nx^{'} = \\arctan(x) * \\frac{2}{\\pi}\n$$\n\n6. 小数定标标准化（Demical Point Normalization）:\n\n$$\nx^{'} = \\frac{x}{10^j}\n$$\n\n​\t非线性归一化通常被用在数据分化程度较大的场景，有时需要通过一些数学函数对原始值进行映射，如对数、反正切等。\n\n### 归一化和标准化的联系与区别\n\n谈到归一化和标准化可能会存在一些概念的混淆，我们都知道归一化是指normalization，标准化是指standardization，但根据wiki上对feature scaling方法的定义，standardization其实就是z-score normalization，也就是说标准化其实是归一化的一种，而一般情况下，我们会把z-score归一化称为标准化，把min-max归一化简称为归一化。在下文中，我们也是用标准化指代z-score归一化，并使用归一化指代min-max归一化。\n\n其实，归一化和标准化在本质上都是一种线性变换。在[归一化类型](#归一化类型)中，我们提到了归一化和标准化的公式，对于归一化的公式，在数据给定的情况下，可以令𝑎=𝑚𝑎𝑥(𝑥)−𝑚𝑖𝑛(𝑥)、𝑏=𝑚𝑖𝑛(𝑥)，则归一化的公式可变形为：\n$$\nx^{'} = \\frac{x - b}{a} = \\frac{x}{a} - \\frac{b}{a} = \\frac{x}{a} - c\n$$\n标准化的公式与变形后的归一化类似，其中的$\\mu $和$\\sigma$在数据给定的情况下，可以看作常数。因此，标准化的变形与归一化的类似，都可看作对𝑥按比例𝑎进行缩放，再进行𝑐个单位的平移。由此可见，归一化和标准化的本质都是一种线性变换，他们都不会因为对数据的处理而改变数据的原始数值排序。\n\n那么归一化和标准化又有什么区别呢？\n\n1. 归一化不会改变数据的状态分布，但标准化会改变数据的状态分布；\n2. 归一化会将数据限定在一个具体的范围内，如 [0, 1]，但标准化不会，标准化只会将数据处理为均值为0，标准差为1。\n\n### 为什么归一化能提高求解最优解的速度\n\n$$\n\\begin{split}\n\\begin{align}\ny &= \\theta_1x_1 + \\theta_2x_2 \\\\\nJ &= (\\theta_{1}x_{1} + \\theta_{2}x_{2} - y_{label})^2\n\\end{align}\n\\end{split}\n$$\n\n假设自变量只有房子到地铁站的距离$$𝑥_1$$和房子内房间的个数$$𝑥_2$$，因变量为房价，预测公式和损失函数分别为：\n\n$$\nJ = (1000\\theta_{1}+3\\theta_{2} - y_{label})^2\n$$\n\n![normalization](https://s2.loli.net/2024/06/05/QAonmGKX4FqxUMt.png)\n\n<div align=\"center\">图1: 损失函数的等高线，图1（左）为未归一化时，图1（右）为归一化</div>\n\n​\t在图1中，左图的红色椭圆代表归一化前的损失函数等高线，蓝色线段代表梯度的更新，箭头的方向代表梯度更新的方向。寻求最优解的过程就是梯度更新的过程，其更新方向与登高线垂直。由于𝑥1 和 𝑥2 的量级相差过大，损失函数的等高线呈现为一个瘦窄的椭圆。因此如图1（左）所示，瘦窄的椭圆形会使得梯度下降过程呈之字形呈现，导致梯度下降速度缓慢。\n\n​\t当数据经过归一化后，$x_{1}^{'} = \\frac{1000-0}{5000-0}=0.2$，$x_{2}^{'} = \\frac{3-0}{10-0}=0.3$，那么损失函数的公式可以写为：\n$$\nJ(x) = (0.2\\theta_{1} + 0.3\\theta_{2} - y_{label})^2\n$$\n​\t我们可以看到，经过归一化后的数据属于同一量级，损失函数的等高线呈现为一个矮胖的椭圆形（如图1（右）所示），求解最优解过程变得更加迅速且平缓，因此可以在通过梯度下降进行求解时获得更快的收敛。\n\n## 有/无量纲表达式\n\n我们假定数据都是一个个变量（不过提前收集好了）量纲指有些未知数他们是变量存在的一种或几种依赖关系，该变量的值由这些依赖关系的未知数（量纲）决定。\n\n>  就像一些函数的y值，理想状态下的房价，他们由x，面积/位置决定。\n\n显然位置差几百米，面积差几百平方米对变量影响差距极大，这种情况下我们称对这些依赖关系式是有量纲的。他们对变量影响的系数存在数量级的不同。\n\n## 常见问题\n\n1. vscode 出现python解释器的选择错误，这在windows经常有非常多版本的相同软件上经常出现，选定安装MindSpore库的python版本\n\n![image-20240605210110827](https://s2.loli.net/2024/06/05/QSIFMsjBCUAo34y.png)\n\n​\t点击此处python版本即可\n\n2. 注意python的多数语法检查集成已分离为插件，一些在2023.10发布，发布后一些网络上的blog修改linting的将禁用，详情请看[迁移到 Python 工具扩展 ·microsoft/vscode-python 维基 (github.com)](https://github.com/microsoft/vscode-python/wiki/Migration-to-Python-Tools-Extensions)\n\n3. 解决一些格式上的报错也可以不理会，但根据PEP 8 python规范，一行不能超过80个字符，同时换行需要缩进,如果看不管可以在扩展语法检查中增加args\n\n```\n--max-line-length=120\n```\n\n","source":"_posts/special_subject/MindSpore/Chapters/Second_TryMindSpore.md","raw":"---\ntitle: MindSpore专题\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n[MindSpore](https://www.mindspore.cn/tutorials/zh-CN/r2.3.0rc2/beginner/quick_start.html)\n\n<!--more-->\n\n## MindSpore 数据处理\n\n### download\n\n```shell\npip install download\n```\n\n下载download python模块\n\n### 引包并下载所需数据集\n\n```python\nimport mindspore\nfrom mindspore import nn\nfrom mindspore.dataset import vision, transforms\nfrom mindspore.dataset import MnistDataset\n```\n\n```python\n# Download data from open datasets\nfrom download import download\n\nurl = \"https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/\" \\\n      \"notebook/datasets/MNIST_Data.zip\"\npath = download(url, \"./\", kind=\"zip\", replace=True)\n```\n\n![image-20240605204942126](https://s2.loli.net/2024/06/05/EuK87I6YUjdAs2v.png)\n\n下载下来MNIST_Data数据，根据官网这是一份Mnist数据集，结构如下\n\n```\nMNIST_Data\n└── train\n    ├── train-images-idx3-ubyte (60000个训练图片)\n    ├── train-labels-idx1-ubyte (60000个训练标签)\n└── test\n    ├── t10k-images-idx3-ubyte (10000个测试图片)\n    ├── t10k-labels-idx1-ubyte (10000个测试标签)\n```\n\n### MindSpore数据处理\n\n```python\nprint(train_dataset.get_col_names())\n```\n\n打印数据集中所包含的数据列名\n\n> MindSpore的dataset使用数据处理流水线（Data Processing Pipeline），需指定map、batch、shuffle等操作。这里我们使用map对图像数据及标签进行变换处理，将输入的图像缩放为1/255，根据均值0.1307和标准差值0.3081进行归一化处理，然后将处理好的数据集打包为大小为64的batch。\n\n上面是官网对以下代码的处理。\n\n其中出现了一个新名词——[归一化处理](#归一化处理)，这里使用的是Z-score normalization。\n\n```python\ndef datapipe(dataset, batch_size):\n    image_transforms = [\n        vision.Rescale(1.0 / 255.0, 0),\n        vision.Normalize(mean=(0.1307,), std=(0.3081,)),\n        vision.HWC2CHW()\n    ]\n    label_transform = transforms.TypeCast(mindspore.int32)\n\n    dataset = dataset.map(image_transforms, 'image')\n    dataset = dataset.map(label_transform, 'label')\n    dataset = dataset.batch(batch_size)\n    return dataset\n\n\n# Map vision transforms and batch dataset\ntrain_dataset = datapipe(train_dataset, 64)\ntest_dataset = datapipe(test_dataset, 64)\n```\n\n---\n\n可使用[create_tuple_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_tuple_iterator.html) 或[create_dict_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_dict_iterator.html)对数据集进行迭代访问，查看数据和标签的shape和datatype。\n\n```python\nfor image, label in test_dataset.create_tuple_iterator():\n    print(f\"Shape of image [N, C, H, W]: {image.shape} {image.dtype}\")\n    print(f\"Shape of label: {label.shape} {label.dtype}\")\n    break\n```\n\n>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32\n>Shape of label: (64,) Int32\n\n```python\nfor data in test_dataset.create_dict_iterator():\n    print(f\"Shape of image [N, C, H, W]: {data['image'].shape} {data['image'].dtype}\")\n    print(f\"Shape of label: {data['label'].shape} {data['label'].dtype}\")\n    break\n```\n\n> Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32\n> Shape of label: (64,) Int32\n\n更多细节详见[数据集 Dataset](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/dataset.html)与[数据变换 Transforms](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/transforms.html)。\n\n### 网络构建\n\n```python\n# Define model\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512),\n            nn.ReLU(),\n            nn.Dense(512, 512),\n            nn.ReLU(),\n            nn.Dense(512, 10)\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\nmodel = Network()\nprint(model)\n```\n\n> Network<\n>   (flatten): Flatten<>\n>   (dense_relu_sequential): SequentialCell<\n>     (0): Dense<input_channels=784, output_channels=512, has_bias=True>\n>     (1): ReLU<>\n>     (2): Dense<input_channels=512, output_channels=512, has_bias=True>\n>     (3): ReLU<>\n>     (4): Dense<input_channels=512, output_channels=10, has_bias=True>\n>     >\n\n以上为网格的构建以及其输出，有以下几点需要注意\n\n1. 上面重命名过MindSpore中的nn类是构建所有网格的基类，也是网格的基本单元\n2. 当需要自定义网络时可以重写``nn.Cell`类重写`__init__`方法和`construct`方法\n3. `__init__`包含所有网络层的定义`construct`中包含数据（[Tensor](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/tensor.html)）的变换过程\n\n> `mindspore.nn`类是构建所有网络的基类，也是网络的基本单元。当用户需要自定义网络时，可以继承`nn.Cell`类，并重写`__init__`方法和`construct`方法。`__init__`包含所有网络层的定义，`construct`中包含数据（[Tensor](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/tensor.html)）的变换过程。\n\n### 模型训练\n\n个人菜狗形象的想，实际上这里的网格神经网络对图像的识别类似一种带指向的可变哈希函数（只不过这个函数的实现比较复杂和通用）。他是从大量信息到小量准确抽象的描述过程。下面是[3.2. 机器学习工作流 — 机器学习系统：设计和实现 1.0.0 documentation (openmlsys.github.io)](https://openmlsys.github.io/chapter_programming_interface/ml_workflow.html)手册上的机器学习流程图，这里以求形象的理解\n\n![img_workflow](./../img/img_workflow.svg)\n\n> 在模型训练中，一个完整的训练过程（step）需要实现以下三步：\n>\n> 1. **正向计算**：模型预测结果（logits），并与正确标签（label）求预测损失（loss）。\n> 2. **反向传播**：利用自动微分机制，自动求模型参数（parameters）对于loss的梯度（gradients）。\n> 3. **参数优化**：将梯度更新到参数上。\n\n> MindSpore使用函数式自动微分机制，因此针对上述步骤需要实现：\n>\n> 1. 定义正向计算函数。\n> 2. 使用[value_and_grad](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.value_and_grad.html)通过函数变换获得梯度计算函数。\n> 3. 定义训练函数，使用[set_train](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Cell.html#mindspore.nn.Cell.set_train)设置为训练模式，执行正向计算、反向传播和参数优化。\n\n```python\n# Instantiate loss function and optimizer\nloss_fn = nn.CrossEntropyLoss()\noptimizer = nn.SGD(model.trainable_params(), 1e-2)\n\n# 1. Define forward function\ndef forward_fn(data, label):\n    logits = model(data)\n    loss = loss_fn(logits, label)\n    return loss, logits\n\n# 2. Get gradient function\ngrad_fn = mindspore.value_and_grad(forward_fn, None, optimizer.parameters, has_aux=True)\n\n# 3. Define function of one-step training\ndef train_step(data, label):\n    (loss, _), grads = grad_fn(data, label)\n    optimizer(grads)\n    return loss\n\ndef train(model, dataset):\n    size = dataset.get_dataset_size()\n    model.set_train()\n    for batch, (data, label) in enumerate(dataset.create_tuple_iterator()):\n        loss = train_step(data, label)\n\n        if batch % 100 == 0:\n            loss, current = loss.asnumpy(), batch\n            print(f\"loss: {loss:>7f}  [{current:>3d}/{size:>3d}]\")\n```\n\n> 除训练外，我们定义测试函数，用来评估模型的性能。\n\n```python\ndef test(model, dataset, loss_fn):\n    num_batches = dataset.get_dataset_size()\n    model.set_train(False)\n    total, test_loss, correct = 0, 0, 0\n    for data, label in dataset.create_tuple_iterator():\n        pred = model(data)\n        total += len(data)\n        test_loss += loss_fn(pred, label).asnumpy()\n        correct += (pred.argmax(1) == label).asnumpy().sum()\n    test_loss /= num_batches\n    correct /= total\n    print(f\"Test: \\n Accuracy: {(100*correct):>0.1f}%, Avg loss: {test_loss:>8f} \\n\")\n```\n\n> 训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。\n\n```python\nepochs = 3\nfor t in range(epochs):\n    print(f\"Epoch {t+1}\\n-------------------------------\")\n    train(model, train_dataset)\n    test(model, test_dataset, loss_fn)\nprint(\"Done!\")\n```\n\n>```\n>Epoch 1\n>-------------------------------\n>loss: 2.302088  [  0/938]\n>loss: 2.290692  [100/938]\n>loss: 2.266338  [200/938]\n>loss: 2.205240  [300/938]\n>loss: 1.907198  [400/938]\n>loss: 1.455603  [500/938]\n>loss: 0.861103  [600/938]\n>loss: 0.767219  [700/938]\n>loss: 0.422253  [800/938]\n>loss: 0.513922  [900/938]\n>Test:\n> Accuracy: 83.8%, Avg loss: 0.529534\n>\n>Epoch 2\n>-------------------------------\n>loss: 0.580867  [  0/938]\n>loss: 0.479347  [100/938]\n>loss: 0.677991  [200/938]\n>loss: 0.550141  [300/938]\n>loss: 0.226565  [400/938]\n>loss: 0.314738  [500/938]\n>loss: 0.298739  [600/938]\n>loss: 0.459540  [700/938]\n>loss: 0.332978  [800/938]\n>loss: 0.406709  [900/938]\n>Test:\n> Accuracy: 90.2%, Avg loss: 0.334828\n>\n>Epoch 3\n>-------------------------------\n>loss: 0.461890  [  0/938]\n>loss: 0.242303  [100/938]\n>loss: 0.281414  [200/938]\n>loss: 0.207835  [300/938]\n>loss: 0.206000  [400/938]\n>loss: 0.409646  [500/938]\n>loss: 0.193608  [600/938]\n>loss: 0.217575  [700/938]\n>loss: 0.212817  [800/938]\n>loss: 0.202862  [900/938]\n>Test:\n> Accuracy: 91.9%, Avg loss: 0.280962\n>\n>Done!\n>```\n\n> 训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。\n\n### 保存模型\n\n模型训练完成后，需要将其参数进行保存。\n\n```python\n# Save checkpoint\nmindspore.save_checkpoint(model, \"model.ckpt\")\nprint(\"Saved Model to model.ckpt\")\n```\n\n> Saved Model to model.ckpt\n\n### 加载模型\n\n> 加载保存的权重分为两步：\n>\n> 1. 重新实例化模型对象，构造模型。\n> 2. 加载模型参数，并将其加载至模型上。\n\n```python\n# Instantiate a random initialized model\nmodel = Network()\n# Load checkpoint and load parameter to model\nparam_dict = mindspore.load_checkpoint(\"model.ckpt\")\nparam_not_load, _ = mindspore.load_param_into_net(model, param_dict)\nprint(param_not_load)\n```\n\n> `param_not_load未被加载的参数列表，为空时代表所有参数均加载成功。`\n\n> 加载后的模型可以直接用于预测推理。\n\n```python\nmodel.set_train(False)\nfor data, label in test_dataset:\n    pred = model(data)\n    predicted = pred.argmax(1)\n    print(f'Predicted: \"{predicted[:10]}\", Actual: \"{label[:10]}\"')\n    break\n```\n\n以上就是一个简单的图像识别机械学习\n\n**注意在加载模型的过程中必须定义模型构建与datapipe**\n\n## 归一化处理\n\n> 一些传送门：\n> [归一化基础知识点 — PaddleEdu documentation (paddlepedia.readthedocs.io)](https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/normalization/basic_normalization.html)\n>\n> [Numpy数组归一化|极客教程 (geek-docs.com)](https://geek-docs.com/numpy/numpy-ask-answer/normalize-numpy-array_z1.html)\n\n归一化是一种数据处理方式，能将数据经过处理后限制在某个固定范围内。\n\n### 归一化处理的两种形式\n\n归一化存在两种形式\n\n1. 将数处理为 [0, 1] 之间的小数，其目的是为了在随后的数据处理过程中更便捷，其他情况下，也可将数据处理到 [-1, 1] 之间，或其他的固定范围内。\n\n> 例如，在图像处理中，就会将图像从 [0, 255] 归一化到 [0, 1]之间，这样既不会改变图像本身的信息储存，又可加速后续的网络处理。\n\n2. 通过归一化将有[量纲表达式](#有/无量纲表达式)变成[无量纲表达式](#有/无量纲表达式)。\n\n### 为什么要进行归一化\n\n1. 解决数据间的可比性问题\n2. 数据归一化后，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。[为什么能提高收敛速度](为什么归一化能提高求解最优解的速度).\n\n### 归一化类型\n\n1. Min-max normalization (Rescaling) 范围为[0,1]:\n\n$$\nx^{'} = \\frac{x - min(x)}{max(x) - min(x)}\n$$\n\n2. Mean normalization范围为[-1,1]：\n\n$$\nx^{'} = \\frac{x - mean(x)}{max(x) - min(x)}\n$$\n\n> mean(x)：x数据的平均值\n\n​\tMin-max归一化和mean归一化适合在最大最小值明确不变的情况下使用，比如图像处理时，灰度值限定在 [0, 255] 的范围内，就可以用min-max归一化将其处理到[0, 1]之间。在最大最小值不明确时，每当有新数据加入，都可能会改变最大或最小值，导致归一化结果不稳定，后续使用效果也不稳定。同时，数据需要相对稳定，如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。如果对处理后的数据范围有严格要求，也应使用min-max归一化或mean归一化。\n\n3. Z-score normalization (Standardization)范围为实数集：\n\n$$\nx^{'} = \\frac{x - \\mu}{\\sigma}\n$$\n\n> 𝜇、𝜎 分别为样本数据的均值和标准差。\n\n​\tZ-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。标准化会改变数据的状态分布，但不会改变分布的种类。特别地，神经网络中经常会使用到z-score归一化，针对这一点，我们将在后续的文章中进行详细的介绍。\n\n4. 对数归一化：\n\n$$\nx^{'} = \\frac{\\lg x}{\\lg max(x)}\n$$\n\n5. 反正切函数归一化：\n\n$$\nx^{'} = \\arctan(x) * \\frac{2}{\\pi}\n$$\n\n6. 小数定标标准化（Demical Point Normalization）:\n\n$$\nx^{'} = \\frac{x}{10^j}\n$$\n\n​\t非线性归一化通常被用在数据分化程度较大的场景，有时需要通过一些数学函数对原始值进行映射，如对数、反正切等。\n\n### 归一化和标准化的联系与区别\n\n谈到归一化和标准化可能会存在一些概念的混淆，我们都知道归一化是指normalization，标准化是指standardization，但根据wiki上对feature scaling方法的定义，standardization其实就是z-score normalization，也就是说标准化其实是归一化的一种，而一般情况下，我们会把z-score归一化称为标准化，把min-max归一化简称为归一化。在下文中，我们也是用标准化指代z-score归一化，并使用归一化指代min-max归一化。\n\n其实，归一化和标准化在本质上都是一种线性变换。在[归一化类型](#归一化类型)中，我们提到了归一化和标准化的公式，对于归一化的公式，在数据给定的情况下，可以令𝑎=𝑚𝑎𝑥(𝑥)−𝑚𝑖𝑛(𝑥)、𝑏=𝑚𝑖𝑛(𝑥)，则归一化的公式可变形为：\n$$\nx^{'} = \\frac{x - b}{a} = \\frac{x}{a} - \\frac{b}{a} = \\frac{x}{a} - c\n$$\n标准化的公式与变形后的归一化类似，其中的$\\mu $和$\\sigma$在数据给定的情况下，可以看作常数。因此，标准化的变形与归一化的类似，都可看作对𝑥按比例𝑎进行缩放，再进行𝑐个单位的平移。由此可见，归一化和标准化的本质都是一种线性变换，他们都不会因为对数据的处理而改变数据的原始数值排序。\n\n那么归一化和标准化又有什么区别呢？\n\n1. 归一化不会改变数据的状态分布，但标准化会改变数据的状态分布；\n2. 归一化会将数据限定在一个具体的范围内，如 [0, 1]，但标准化不会，标准化只会将数据处理为均值为0，标准差为1。\n\n### 为什么归一化能提高求解最优解的速度\n\n$$\n\\begin{split}\n\\begin{align}\ny &= \\theta_1x_1 + \\theta_2x_2 \\\\\nJ &= (\\theta_{1}x_{1} + \\theta_{2}x_{2} - y_{label})^2\n\\end{align}\n\\end{split}\n$$\n\n假设自变量只有房子到地铁站的距离$$𝑥_1$$和房子内房间的个数$$𝑥_2$$，因变量为房价，预测公式和损失函数分别为：\n\n$$\nJ = (1000\\theta_{1}+3\\theta_{2} - y_{label})^2\n$$\n\n![normalization](https://s2.loli.net/2024/06/05/QAonmGKX4FqxUMt.png)\n\n<div align=\"center\">图1: 损失函数的等高线，图1（左）为未归一化时，图1（右）为归一化</div>\n\n​\t在图1中，左图的红色椭圆代表归一化前的损失函数等高线，蓝色线段代表梯度的更新，箭头的方向代表梯度更新的方向。寻求最优解的过程就是梯度更新的过程，其更新方向与登高线垂直。由于𝑥1 和 𝑥2 的量级相差过大，损失函数的等高线呈现为一个瘦窄的椭圆。因此如图1（左）所示，瘦窄的椭圆形会使得梯度下降过程呈之字形呈现，导致梯度下降速度缓慢。\n\n​\t当数据经过归一化后，$x_{1}^{'} = \\frac{1000-0}{5000-0}=0.2$，$x_{2}^{'} = \\frac{3-0}{10-0}=0.3$，那么损失函数的公式可以写为：\n$$\nJ(x) = (0.2\\theta_{1} + 0.3\\theta_{2} - y_{label})^2\n$$\n​\t我们可以看到，经过归一化后的数据属于同一量级，损失函数的等高线呈现为一个矮胖的椭圆形（如图1（右）所示），求解最优解过程变得更加迅速且平缓，因此可以在通过梯度下降进行求解时获得更快的收敛。\n\n## 有/无量纲表达式\n\n我们假定数据都是一个个变量（不过提前收集好了）量纲指有些未知数他们是变量存在的一种或几种依赖关系，该变量的值由这些依赖关系的未知数（量纲）决定。\n\n>  就像一些函数的y值，理想状态下的房价，他们由x，面积/位置决定。\n\n显然位置差几百米，面积差几百平方米对变量影响差距极大，这种情况下我们称对这些依赖关系式是有量纲的。他们对变量影响的系数存在数量级的不同。\n\n## 常见问题\n\n1. vscode 出现python解释器的选择错误，这在windows经常有非常多版本的相同软件上经常出现，选定安装MindSpore库的python版本\n\n![image-20240605210110827](https://s2.loli.net/2024/06/05/QSIFMsjBCUAo34y.png)\n\n​\t点击此处python版本即可\n\n2. 注意python的多数语法检查集成已分离为插件，一些在2023.10发布，发布后一些网络上的blog修改linting的将禁用，详情请看[迁移到 Python 工具扩展 ·microsoft/vscode-python 维基 (github.com)](https://github.com/microsoft/vscode-python/wiki/Migration-to-Python-Tools-Extensions)\n\n3. 解决一些格式上的报错也可以不理会，但根据PEP 8 python规范，一行不能超过80个字符，同时换行需要缩进,如果看不管可以在扩展语法检查中增加args\n\n```\n--max-line-length=120\n```\n\n","slug":"special_subject/MindSpore/Chapters/Second_TryMindSpore","published":1,"updated":"2024-08-16T08:59:00.222Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjam0022lowvexcn8zm6","content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4zLjByYzIvYmVnaW5uZXIvcXVpY2tfc3RhcnQuaHRtbA==\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"mindspore-数据处理\">MindSpore 数据处理</h2>\r\n<h3 id=\"download\">download</h3>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install download</span><br></pre></td></tr></table></figure>\r\n<p>下载download python模块</p>\r\n<h3 id=\"引包并下载所需数据集\">引包并下载所需数据集</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> mindspore</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore <span class=\"keyword\">import</span> nn</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore.dataset <span class=\"keyword\">import</span> vision, transforms</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore.dataset <span class=\"keyword\">import</span> MnistDataset</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Download data from open datasets</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> download <span class=\"keyword\">import</span> download</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">&quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&quot;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&quot;notebook/datasets/MNIST_Data.zip&quot;</span></span><br><span class=\"line\">path = download(url, <span class=\"string\">&quot;./&quot;</span>, kind=<span class=\"string\">&quot;zip&quot;</span>, replace=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/EuK87I6YUjdAs2v.png\"\r\nalt=\"image-20240605204942126\" />\r\n<figcaption aria-hidden=\"true\">image-20240605204942126</figcaption>\r\n</figure>\r\n<p>下载下来MNIST_Data数据，根据官网这是一份Mnist数据集，结构如下</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MNIST_Data</span><br><span class=\"line\">└── train</span><br><span class=\"line\">    ├── train-images-idx3-ubyte (60000个训练图片)</span><br><span class=\"line\">    ├── train-labels-idx1-ubyte (60000个训练标签)</span><br><span class=\"line\">└── test</span><br><span class=\"line\">    ├── t10k-images-idx3-ubyte (10000个测试图片)</span><br><span class=\"line\">    ├── t10k-labels-idx1-ubyte (10000个测试标签)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"mindspore数据处理\">MindSpore数据处理</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(train_dataset.get_col_names())</span><br></pre></td></tr></table></figure>\r\n<p>打印数据集中所包含的数据列名</p>\r\n<blockquote>\r\n<p>MindSpore的dataset使用数据处理流水线（Data Processing\r\nPipeline），需指定map、batch、shuffle等操作。这里我们使用map对图像数据及标签进行变换处理，将输入的图像缩放为1/255，根据均值0.1307和标准差值0.3081进行归一化处理，然后将处理好的数据集打包为大小为64的batch。</p>\r\n</blockquote>\r\n<p>上面是官网对以下代码的处理。</p>\r\n<p>其中出现了一个新名词——<a\r\nhref=\"#归一化处理\">归一化处理</a>，这里使用的是Z-score\r\nnormalization。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">datapipe</span>(<span class=\"params\">dataset, batch_size</span>):</span><br><span class=\"line\">    image_transforms = [</span><br><span class=\"line\">        vision.Rescale(<span class=\"number\">1.0</span> / <span class=\"number\">255.0</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">        vision.Normalize(mean=(<span class=\"number\">0.1307</span>,), std=(<span class=\"number\">0.3081</span>,)),</span><br><span class=\"line\">        vision.HWC2CHW()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    label_transform = transforms.TypeCast(mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\">    dataset = dataset.<span class=\"built_in\">map</span>(image_transforms, <span class=\"string\">&#x27;image&#x27;</span>)</span><br><span class=\"line\">    dataset = dataset.<span class=\"built_in\">map</span>(label_transform, <span class=\"string\">&#x27;label&#x27;</span>)</span><br><span class=\"line\">    dataset = dataset.batch(batch_size)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataset</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Map vision transforms and batch dataset</span></span><br><span class=\"line\">train_dataset = datapipe(train_dataset, <span class=\"number\">64</span>)</span><br><span class=\"line\">test_dataset = datapipe(test_dataset, <span class=\"number\">64</span>)</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<p>可使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfdHVwbGVfaXRlcmF0b3IuaHRtbA==\">create_tuple_iterator<i class=\"fa fa-external-link-alt\"></i></span>\r\n或<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfZGljdF9pdGVyYXRvci5odG1s\">create_dict_iterator<i class=\"fa fa-external-link-alt\"></i></span>对数据集进行迭代访问，查看数据和标签的shape和datatype。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> image, label <span class=\"keyword\">in</span> test_dataset.create_tuple_iterator():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of image [N, C, H, W]: <span class=\"subst\">&#123;image.shape&#125;</span> <span class=\"subst\">&#123;image.dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of label: <span class=\"subst\">&#123;label.shape&#125;</span> <span class=\"subst\">&#123;label.dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32 Shape of label:\r\n(64,) Int32</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> test_dataset.create_dict_iterator():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of image [N, C, H, W]: <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;image&#x27;</span>].shape&#125;</span> <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;image&#x27;</span>].dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of label: <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;label&#x27;</span>].shape&#125;</span> <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;label&#x27;</span>].dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32 Shape of label:\r\n(64,) Int32</p>\r\n</blockquote>\r\n<p>更多细节详见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL2RhdGFzZXQuaHRtbA==\">数据集\r\nDataset<i class=\"fa fa-external-link-alt\"></i></span>与<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RyYW5zZm9ybXMuaHRtbA==\">数据变换\r\nTransforms<i class=\"fa fa-external-link-alt\"></i></span>。</p>\r\n<h3 id=\"网络构建\">网络构建</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define model</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Network&lt; (flatten): Flatten&lt;&gt; (dense_relu_sequential):\r\nSequentialCell&lt; (0): Dense&lt;input_channels=784,\r\noutput_channels=512, has_bias=True&gt; (1): ReLU&lt;&gt; (2):\r\nDense&lt;input_channels=512, output_channels=512, has_bias=True&gt; (3):\r\nReLU&lt;&gt; (4): Dense&lt;input_channels=512, output_channels=10,\r\nhas_bias=True&gt; &gt;</p>\r\n</blockquote>\r\n<p>以上为网格的构建以及其输出，有以下几点需要注意</p>\r\n<ol type=\"1\">\r\n<li>上面重命名过MindSpore中的nn类是构建所有网格的基类，也是网格的基本单元</li>\r\n<li>当需要自定义网络时可以重写`<code>nn.Cell</code>类重写<code>__init__</code>方法和<code>construct</code>方法</li>\r\n<li><code>__init__</code>包含所有网络层的定义<code>construct</code>中包含数据（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RlbnNvci5odG1s\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）的变换过程</li>\r\n</ol>\r\n<blockquote>\r\n<p><code>mindspore.nn</code>类是构建所有网络的基类，也是网络的基本单元。当用户需要自定义网络时，可以继承<code>nn.Cell</code>类，并重写<code>__init__</code>方法和<code>construct</code>方法。<code>__init__</code>包含所有网络层的定义，<code>construct</code>中包含数据（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RlbnNvci5odG1s\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）的变换过程。</p>\r\n</blockquote>\r\n<h3 id=\"模型训练\">模型训练</h3>\r\n<p>个人菜狗形象的想，实际上这里的网格神经网络对图像的识别类似一种带指向的可变哈希函数（只不过这个函数的实现比较复杂和通用）。他是从大量信息到小量准确抽象的描述过程。下面是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVubWxzeXMuZ2l0aHViLmlvL2NoYXB0ZXJfcHJvZ3JhbW1pbmdfaW50ZXJmYWNlL21sX3dvcmtmbG93Lmh0bWw=\">3.2.\r\n机器学习工作流 — 机器学习系统：设计和实现 1.0.0 documentation\r\n(openmlsys.github.io)<i class=\"fa fa-external-link-alt\"></i></span>手册上的机器学习流程图，这里以求形象的理解</p>\r\n<figure>\r\n<img src=\"./../img/img_workflow.svg\" alt=\"img_workflow\" />\r\n<figcaption aria-hidden=\"true\">img_workflow</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>在模型训练中，一个完整的训练过程（step）需要实现以下三步：</p>\r\n<ol type=\"1\">\r\n<li><strong>正向计算</strong>：模型预测结果（logits），并与正确标签（label）求预测损失（loss）。</li>\r\n<li><strong>反向传播</strong>：利用自动微分机制，自动求模型参数（parameters）对于loss的梯度（gradients）。</li>\r\n<li><strong>参数优化</strong>：将梯度更新到参数上。</li>\r\n</ol>\r\n</blockquote>\r\n<blockquote>\r\n<p>MindSpore使用函数式自动微分机制，因此针对上述步骤需要实现：</p>\r\n<ol type=\"1\">\r\n<li>定义正向计算函数。</li>\r\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUudmFsdWVfYW5kX2dyYWQuaHRtbA==\">value_and_grad<i class=\"fa fa-external-link-alt\"></i></span>通过函数变换获得梯度计算函数。</li>\r\n<li>定义训练函数，使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5DZWxsLmh0bWwjbWluZHNwb3JlLm5uLkNlbGwuc2V0X3RyYWlu\">set_train<i class=\"fa fa-external-link-alt\"></i></span>设置为训练模式，执行正向计算、反向传播和参数优化。</li>\r\n</ol>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Instantiate loss function and optimizer</span></span><br><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), <span class=\"number\">1e-2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    logits = model(data)</span><br><span class=\"line\">    loss = loss_fn(logits, label)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, logits</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. Get gradient function</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, optimizer.parameters, has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. Define function of one-step training</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_step</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    (loss, _), grads = grad_fn(data, label)</span><br><span class=\"line\">    optimizer(grads)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train</span>(<span class=\"params\">model, dataset</span>):</span><br><span class=\"line\">    size = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> batch, (data, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        loss = train_step(data, label)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> batch % <span class=\"number\">100</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            loss, current = loss.asnumpy(), batch</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;loss: <span class=\"subst\">&#123;loss:&gt;7f&#125;</span>  [<span class=\"subst\">&#123;current:&gt;3d&#125;</span>/<span class=\"subst\">&#123;size:&gt;3d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>除训练外，我们定义测试函数，用来评估模型的性能。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">model, dataset, loss_fn</span>):</span><br><span class=\"line\">    num_batches = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\">    total, test_loss, correct = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> dataset.create_tuple_iterator():</span><br><span class=\"line\">        pred = model(data)</span><br><span class=\"line\">        total += <span class=\"built_in\">len</span>(data)</span><br><span class=\"line\">        test_loss += loss_fn(pred, label).asnumpy()</span><br><span class=\"line\">        correct += (pred.argmax(<span class=\"number\">1</span>) == label).asnumpy().<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">    test_loss /= num_batches</span><br><span class=\"line\">    correct /= total</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Test: \\n Accuracy: <span class=\"subst\">&#123;(<span class=\"number\">100</span>*correct):&gt;<span class=\"number\">0.1</span>f&#125;</span>%, Avg loss: <span class=\"subst\">&#123;test_loss:&gt;8f&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">epochs = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(epochs):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Epoch <span class=\"subst\">&#123;t+<span class=\"number\">1</span>&#125;</span>\\n-------------------------------&quot;</span>)</span><br><span class=\"line\">    train(model, train_dataset)</span><br><span class=\"line\">    test(model, test_dataset, loss_fn)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;Epoch 1</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 2.302088  [  0/938]</span><br><span class=\"line\">&gt;loss: 2.290692  [100/938]</span><br><span class=\"line\">&gt;loss: 2.266338  [200/938]</span><br><span class=\"line\">&gt;loss: 2.205240  [300/938]</span><br><span class=\"line\">&gt;loss: 1.907198  [400/938]</span><br><span class=\"line\">&gt;loss: 1.455603  [500/938]</span><br><span class=\"line\">&gt;loss: 0.861103  [600/938]</span><br><span class=\"line\">&gt;loss: 0.767219  [700/938]</span><br><span class=\"line\">&gt;loss: 0.422253  [800/938]</span><br><span class=\"line\">&gt;loss: 0.513922  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 83.8%, Avg loss: 0.529534</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Epoch 2</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 0.580867  [  0/938]</span><br><span class=\"line\">&gt;loss: 0.479347  [100/938]</span><br><span class=\"line\">&gt;loss: 0.677991  [200/938]</span><br><span class=\"line\">&gt;loss: 0.550141  [300/938]</span><br><span class=\"line\">&gt;loss: 0.226565  [400/938]</span><br><span class=\"line\">&gt;loss: 0.314738  [500/938]</span><br><span class=\"line\">&gt;loss: 0.298739  [600/938]</span><br><span class=\"line\">&gt;loss: 0.459540  [700/938]</span><br><span class=\"line\">&gt;loss: 0.332978  [800/938]</span><br><span class=\"line\">&gt;loss: 0.406709  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 90.2%, Avg loss: 0.334828</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Epoch 3</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 0.461890  [  0/938]</span><br><span class=\"line\">&gt;loss: 0.242303  [100/938]</span><br><span class=\"line\">&gt;loss: 0.281414  [200/938]</span><br><span class=\"line\">&gt;loss: 0.207835  [300/938]</span><br><span class=\"line\">&gt;loss: 0.206000  [400/938]</span><br><span class=\"line\">&gt;loss: 0.409646  [500/938]</span><br><span class=\"line\">&gt;loss: 0.193608  [600/938]</span><br><span class=\"line\">&gt;loss: 0.217575  [700/938]</span><br><span class=\"line\">&gt;loss: 0.212817  [800/938]</span><br><span class=\"line\">&gt;loss: 0.202862  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 91.9%, Avg loss: 0.280962</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Done!</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<blockquote>\r\n<p>训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。</p>\r\n</blockquote>\r\n<h3 id=\"保存模型\">保存模型</h3>\r\n<p>模型训练完成后，需要将其参数进行保存。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Save checkpoint</span></span><br><span class=\"line\">mindspore.save_checkpoint(model, <span class=\"string\">&quot;model.ckpt&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Saved Model to model.ckpt&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Saved Model to model.ckpt</p>\r\n</blockquote>\r\n<h3 id=\"加载模型\">加载模型</h3>\r\n<blockquote>\r\n<p>加载保存的权重分为两步：</p>\r\n<ol type=\"1\">\r\n<li>重新实例化模型对象，构造模型。</li>\r\n<li>加载模型参数，并将其加载至模型上。</li>\r\n</ol>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Instantiate a random initialized model</span></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"comment\"># Load checkpoint and load parameter to model</span></span><br><span class=\"line\">param_dict = mindspore.load_checkpoint(<span class=\"string\">&quot;model.ckpt&quot;</span>)</span><br><span class=\"line\">param_not_load, _ = mindspore.load_param_into_net(model, param_dict)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(param_not_load)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p><code>param_not_load未被加载的参数列表，为空时代表所有参数均加载成功。</code></p>\r\n</blockquote>\r\n<blockquote>\r\n<p>加载后的模型可以直接用于预测推理。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> test_dataset:</span><br><span class=\"line\">    pred = model(data)</span><br><span class=\"line\">    predicted = pred.argmax(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Predicted: &quot;<span class=\"subst\">&#123;predicted[:<span class=\"number\">10</span>]&#125;</span>&quot;, Actual: &quot;<span class=\"subst\">&#123;label[:<span class=\"number\">10</span>]&#125;</span>&quot;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<p>以上就是一个简单的图像识别机械学习</p>\r\n<p><strong>注意在加载模型的过程中必须定义模型构建与datapipe</strong></p>\r\n<h2 id=\"归一化处理\">归一化处理</h2>\r\n<blockquote>\r\n<p>一些传送门： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWRkbGVwZWRpYS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvdHV0b3JpYWxzL2RlZXBfbGVhcm5pbmcvbm9ybWFsaXphdGlvbi9iYXNpY19ub3JtYWxpemF0aW9uLmh0bWw=\">归一化基础知识点\r\n— PaddleEdu documentation (paddlepedia.readthedocs.io)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9nZWVrLWRvY3MuY29tL251bXB5L251bXB5LWFzay1hbnN3ZXIvbm9ybWFsaXplLW51bXB5LWFycmF5X3oxLmh0bWw=\">Numpy数组归一化|极客教程\r\n(geek-docs.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n</blockquote>\r\n<p>归一化是一种数据处理方式，能将数据经过处理后限制在某个固定范围内。</p>\r\n<h3 id=\"归一化处理的两种形式\">归一化处理的两种形式</h3>\r\n<p>归一化存在两种形式</p>\r\n<ol type=\"1\">\r\n<li>将数处理为 [0, 1]\r\n之间的小数，其目的是为了在随后的数据处理过程中更便捷，其他情况下，也可将数据处理到\r\n[-1, 1] 之间，或其他的固定范围内。</li>\r\n</ol>\r\n<blockquote>\r\n<p>例如，在图像处理中，就会将图像从 [0, 255] 归一化到 [0,\r\n1]之间，这样既不会改变图像本身的信息储存，又可加速后续的网络处理。</p>\r\n</blockquote>\r\n<ol start=\"2\" type=\"1\">\r\n<li>通过归一化将有<a href=\"#有/无量纲表达式\">量纲表达式</a>变成<a\r\nhref=\"#有/无量纲表达式\">无量纲表达式</a>。</li>\r\n</ol>\r\n<h3 id=\"为什么要进行归一化\">为什么要进行归一化</h3>\r\n<ol type=\"1\">\r\n<li>解决数据间的可比性问题</li>\r\n<li>数据归一化后，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。<a\r\nhref=\"为什么归一化能提高求解最优解的速度\">为什么能提高收敛速度</a>.</li>\r\n</ol>\r\n<h3 id=\"归一化类型\">归一化类型</h3>\r\n<ol type=\"1\">\r\n<li>Min-max normalization (Rescaling) 范围为[0,1]:</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - min(x)}{max(x) - min(x)}\r\n\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Mean normalization范围为[-1,1]：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - mean(x)}{max(x) - min(x)}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>mean(x)：x数据的平均值</p>\r\n</blockquote>\r\n<p>​\r\nMin-max归一化和mean归一化适合在最大最小值明确不变的情况下使用，比如图像处理时，灰度值限定在\r\n[0, 255] 的范围内，就可以用min-max归一化将其处理到[0,\r\n1]之间。在最大最小值不明确时，每当有新数据加入，都可能会改变最大或最小值，导致归一化结果不稳定，后续使用效果也不稳定。同时，数据需要相对稳定，如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。如果对处理后的数据范围有严格要求，也应使用min-max归一化或mean归一化。</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Z-score normalization (Standardization)范围为实数集：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - \\mu}{\\sigma}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>𝜇、𝜎 分别为样本数据的均值和标准差。</p>\r\n</blockquote>\r\n<p>​\r\nZ-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。标准化会改变数据的状态分布，但不会改变分布的种类。特别地，神经网络中经常会使用到z-score归一化，针对这一点，我们将在后续的文章中进行详细的介绍。</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>对数归一化：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{\\lg x}{\\lg max(x)}\r\n\\]</span></p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>反正切函数归一化：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\arctan(x) * \\frac{2}{\\pi}\r\n\\]</span></p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>小数定标标准化（Demical Point Normalization）:</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x}{10^j}\r\n\\]</span></p>\r\n<p>​\r\n非线性归一化通常被用在数据分化程度较大的场景，有时需要通过一些数学函数对原始值进行映射，如对数、反正切等。</p>\r\n<h3 id=\"归一化和标准化的联系与区别\">归一化和标准化的联系与区别</h3>\r\n<p>谈到归一化和标准化可能会存在一些概念的混淆，我们都知道归一化是指normalization，标准化是指standardization，但根据wiki上对feature\r\nscaling方法的定义，standardization其实就是z-score\r\nnormalization，也就是说标准化其实是归一化的一种，而一般情况下，我们会把z-score归一化称为标准化，把min-max归一化简称为归一化。在下文中，我们也是用标准化指代z-score归一化，并使用归一化指代min-max归一化。</p>\r\n<p>其实，归一化和标准化在本质上都是一种线性变换。在<a\r\nhref=\"#归一化类型\">归一化类型</a>中，我们提到了归一化和标准化的公式，对于归一化的公式，在数据给定的情况下，可以令𝑎=𝑚𝑎𝑥(𝑥)−𝑚𝑖𝑛(𝑥)、𝑏=𝑚𝑖𝑛(𝑥)，则归一化的公式可变形为：\r\n<span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - b}{a} = \\frac{x}{a} - \\frac{b}{a} = \\frac{x}{a} -\r\nc\r\n\\]</span> 标准化的公式与变形后的归一化类似，其中的$<span\r\nclass=\"math inline\">\\(和\\)</span>$在数据给定的情况下，可以看作常数。因此，标准化的变形与归一化的类似，都可看作对𝑥按比例𝑎进行缩放，再进行𝑐个单位的平移。由此可见，归一化和标准化的本质都是一种线性变换，他们都不会因为对数据的处理而改变数据的原始数值排序。</p>\r\n<p>那么归一化和标准化又有什么区别呢？</p>\r\n<ol type=\"1\">\r\n<li>归一化不会改变数据的状态分布，但标准化会改变数据的状态分布；</li>\r\n<li>归一化会将数据限定在一个具体的范围内，如 [0,\r\n1]，但标准化不会，标准化只会将数据处理为均值为0，标准差为1。</li>\r\n</ol>\r\n<h3\r\nid=\"为什么归一化能提高求解最优解的速度\">为什么归一化能提高求解最优解的速度</h3>\r\n<p><span class=\"math display\">\\[\r\n\\begin{split}\r\n\\begin{align}\r\ny &amp;= \\theta_1x_1 + \\theta_2x_2 \\\\\r\nJ &amp;= (\\theta_{1}x_{1} + \\theta_{2}x_{2} - y_{label})^2\r\n\\end{align}\r\n\\end{split}\r\n\\]</span></p>\r\n<p>假设自变量只有房子到地铁站的距离<span\r\nclass=\"math display\">\\[𝑥_1\\]</span>和房子内房间的个数<span\r\nclass=\"math display\">\\[𝑥_2\\]</span>，因变量为房价，预测公式和损失函数分别为：</p>\r\n<p><span class=\"math display\">\\[\r\nJ = (1000\\theta_{1}+3\\theta_{2} - y_{label})^2\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/QAonmGKX4FqxUMt.png\"\r\nalt=\"normalization\" />\r\n<figcaption aria-hidden=\"true\">normalization</figcaption>\r\n</figure>\r\n<div data-align=\"center\">\r\n图1: 损失函数的等高线，图1（左）为未归一化时，图1（右）为归一化\r\n</div>\r\n<p>​\r\n在图1中，左图的红色椭圆代表归一化前的损失函数等高线，蓝色线段代表梯度的更新，箭头的方向代表梯度更新的方向。寻求最优解的过程就是梯度更新的过程，其更新方向与登高线垂直。由于𝑥1\r\n和 𝑥2\r\n的量级相差过大，损失函数的等高线呈现为一个瘦窄的椭圆。因此如图1（左）所示，瘦窄的椭圆形会使得梯度下降过程呈之字形呈现，导致梯度下降速度缓慢。</p>\r\n<p>​ 当数据经过归一化后，<span class=\"math inline\">\\(x_{1}^{&#39;} =\r\n\\frac{1000-0}{5000-0}=0.2\\)</span>，<span\r\nclass=\"math inline\">\\(x_{2}^{&#39;} =\r\n\\frac{3-0}{10-0}=0.3\\)</span>，那么损失函数的公式可以写为： <span\r\nclass=\"math display\">\\[\r\nJ(x) = (0.2\\theta_{1} + 0.3\\theta_{2} - y_{label})^2\r\n\\]</span> ​\r\n我们可以看到，经过归一化后的数据属于同一量级，损失函数的等高线呈现为一个矮胖的椭圆形（如图1（右）所示），求解最优解过程变得更加迅速且平缓，因此可以在通过梯度下降进行求解时获得更快的收敛。</p>\r\n<h2 id=\"有无量纲表达式\">有/无量纲表达式</h2>\r\n<p>我们假定数据都是一个个变量（不过提前收集好了）量纲指有些未知数他们是变量存在的一种或几种依赖关系，该变量的值由这些依赖关系的未知数（量纲）决定。</p>\r\n<blockquote>\r\n<p>就像一些函数的y值，理想状态下的房价，他们由x，面积/位置决定。</p>\r\n</blockquote>\r\n<p>显然位置差几百米，面积差几百平方米对变量影响差距极大，这种情况下我们称对这些依赖关系式是有量纲的。他们对变量影响的系数存在数量级的不同。</p>\r\n<h2 id=\"常见问题\">常见问题</h2>\r\n<ol type=\"1\">\r\n<li>vscode\r\n出现python解释器的选择错误，这在windows经常有非常多版本的相同软件上经常出现，选定安装MindSpore库的python版本</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/QSIFMsjBCUAo34y.png\"\r\nalt=\"image-20240605210110827\" />\r\n<figcaption aria-hidden=\"true\">image-20240605210110827</figcaption>\r\n</figure>\r\n<p>​ 点击此处python版本即可</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>注意python的多数语法检查集成已分离为插件，一些在2023.10发布，发布后一些网络上的blog修改linting的将禁用，详情请看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUtcHl0aG9uL3dpa2kvTWlncmF0aW9uLXRvLVB5dGhvbi1Ub29scy1FeHRlbnNpb25z\">迁移到\r\nPython 工具扩展 ·microsoft/vscode-python 维基 (github.com)<i class=\"fa fa-external-link-alt\"></i></span></p></li>\r\n<li><p>解决一些格式上的报错也可以不理会，但根据PEP 8\r\npython规范，一行不能超过80个字符，同时换行需要缩进,如果看不管可以在扩展语法检查中增加args</p></li>\r\n</ol>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--max-line-length=120</span><br></pre></td></tr></table></figure>\r\n","length":3710,"excerpt":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4zLjByYzIvYmVnaW5uZXIvcXVpY2tfc3RhcnQuaHRtbA==\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h2 id=\"mindspore-数据处理\">MindSpore 数据处理</h2>\r\n<h3 id=\"download\">download</h3>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install download</span><br></pre></td></tr></table></figure>\r\n<p>下载download python模块</p>\r\n<h3 id=\"引包并下载所需数据集\">引包并下载所需数据集</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> mindspore</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore <span class=\"keyword\">import</span> nn</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore.dataset <span class=\"keyword\">import</span> vision, transforms</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore.dataset <span class=\"keyword\">import</span> MnistDataset</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Download data from open datasets</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> download <span class=\"keyword\">import</span> download</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">&quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&quot;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&quot;notebook/datasets/MNIST_Data.zip&quot;</span></span><br><span class=\"line\">path = download(url, <span class=\"string\">&quot;./&quot;</span>, kind=<span class=\"string\">&quot;zip&quot;</span>, replace=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/EuK87I6YUjdAs2v.png\"\r\nalt=\"image-20240605204942126\" />\r\n<figcaption aria-hidden=\"true\">image-20240605204942126</figcaption>\r\n</figure>\r\n<p>下载下来MNIST_Data数据，根据官网这是一份Mnist数据集，结构如下</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MNIST_Data</span><br><span class=\"line\">└── train</span><br><span class=\"line\">    ├── train-images-idx3-ubyte (60000个训练图片)</span><br><span class=\"line\">    ├── train-labels-idx1-ubyte (60000个训练标签)</span><br><span class=\"line\">└── test</span><br><span class=\"line\">    ├── t10k-images-idx3-ubyte (10000个测试图片)</span><br><span class=\"line\">    ├── t10k-labels-idx1-ubyte (10000个测试标签)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"mindspore数据处理\">MindSpore数据处理</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(train_dataset.get_col_names())</span><br></pre></td></tr></table></figure>\r\n<p>打印数据集中所包含的数据列名</p>\r\n<blockquote>\r\n<p>MindSpore的dataset使用数据处理流水线（Data Processing\r\nPipeline），需指定map、batch、shuffle等操作。这里我们使用map对图像数据及标签进行变换处理，将输入的图像缩放为1/255，根据均值0.1307和标准差值0.3081进行归一化处理，然后将处理好的数据集打包为大小为64的batch。</p>\r\n</blockquote>\r\n<p>上面是官网对以下代码的处理。</p>\r\n<p>其中出现了一个新名词——<a\r\nhref=\"#归一化处理\">归一化处理</a>，这里使用的是Z-score\r\nnormalization。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">datapipe</span>(<span class=\"params\">dataset, batch_size</span>):</span><br><span class=\"line\">    image_transforms = [</span><br><span class=\"line\">        vision.Rescale(<span class=\"number\">1.0</span> / <span class=\"number\">255.0</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">        vision.Normalize(mean=(<span class=\"number\">0.1307</span>,), std=(<span class=\"number\">0.3081</span>,)),</span><br><span class=\"line\">        vision.HWC2CHW()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    label_transform = transforms.TypeCast(mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\">    dataset = dataset.<span class=\"built_in\">map</span>(image_transforms, <span class=\"string\">&#x27;image&#x27;</span>)</span><br><span class=\"line\">    dataset = dataset.<span class=\"built_in\">map</span>(label_transform, <span class=\"string\">&#x27;label&#x27;</span>)</span><br><span class=\"line\">    dataset = dataset.batch(batch_size)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataset</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Map vision transforms and batch dataset</span></span><br><span class=\"line\">train_dataset = datapipe(train_dataset, <span class=\"number\">64</span>)</span><br><span class=\"line\">test_dataset = datapipe(test_dataset, <span class=\"number\">64</span>)</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<p>可使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfdHVwbGVfaXRlcmF0b3IuaHRtbA==\">create_tuple_iterator<i class=\"fa fa-external-link-alt\"></i></span>\r\n或<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfZGljdF9pdGVyYXRvci5odG1s\">create_dict_iterator<i class=\"fa fa-external-link-alt\"></i></span>对数据集进行迭代访问，查看数据和标签的shape和datatype。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> image, label <span class=\"keyword\">in</span> test_dataset.create_tuple_iterator():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of image [N, C, H, W]: <span class=\"subst\">&#123;image.shape&#125;</span> <span class=\"subst\">&#123;image.dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of label: <span class=\"subst\">&#123;label.shape&#125;</span> <span class=\"subst\">&#123;label.dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32 Shape of label:\r\n(64,) Int32</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> test_dataset.create_dict_iterator():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of image [N, C, H, W]: <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;image&#x27;</span>].shape&#125;</span> <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;image&#x27;</span>].dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of label: <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;label&#x27;</span>].shape&#125;</span> <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;label&#x27;</span>].dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32 Shape of label:\r\n(64,) Int32</p>\r\n</blockquote>\r\n<p>更多细节详见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL2RhdGFzZXQuaHRtbA==\">数据集\r\nDataset<i class=\"fa fa-external-link-alt\"></i></span>与<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RyYW5zZm9ybXMuaHRtbA==\">数据变换\r\nTransforms<i class=\"fa fa-external-link-alt\"></i></span>。</p>\r\n<h3 id=\"网络构建\">网络构建</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define model</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Network&lt; (flatten): Flatten&lt;&gt; (dense_relu_sequential):\r\nSequentialCell&lt; (0): Dense&lt;input_channels=784,\r\noutput_channels=512, has_bias=True&gt; (1): ReLU&lt;&gt; (2):\r\nDense&lt;input_channels=512, output_channels=512, has_bias=True&gt; (3):\r\nReLU&lt;&gt; (4): Dense&lt;input_channels=512, output_channels=10,\r\nhas_bias=True&gt; &gt;</p>\r\n</blockquote>\r\n<p>以上为网格的构建以及其输出，有以下几点需要注意</p>\r\n<ol type=\"1\">\r\n<li>上面重命名过MindSpore中的nn类是构建所有网格的基类，也是网格的基本单元</li>\r\n<li>当需要自定义网络时可以重写`<code>nn.Cell</code>类重写<code>__init__</code>方法和<code>construct</code>方法</li>\r\n<li><code>__init__</code>包含所有网络层的定义<code>construct</code>中包含数据（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RlbnNvci5odG1s\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）的变换过程</li>\r\n</ol>\r\n<blockquote>\r\n<p><code>mindspore.nn</code>类是构建所有网络的基类，也是网络的基本单元。当用户需要自定义网络时，可以继承<code>nn.Cell</code>类，并重写<code>__init__</code>方法和<code>construct</code>方法。<code>__init__</code>包含所有网络层的定义，<code>construct</code>中包含数据（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RlbnNvci5odG1s\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）的变换过程。</p>\r\n</blockquote>\r\n<h3 id=\"模型训练\">模型训练</h3>\r\n<p>个人菜狗形象的想，实际上这里的网格神经网络对图像的识别类似一种带指向的可变哈希函数（只不过这个函数的实现比较复杂和通用）。他是从大量信息到小量准确抽象的描述过程。下面是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVubWxzeXMuZ2l0aHViLmlvL2NoYXB0ZXJfcHJvZ3JhbW1pbmdfaW50ZXJmYWNlL21sX3dvcmtmbG93Lmh0bWw=\">3.2.\r\n机器学习工作流 — 机器学习系统：设计和实现 1.0.0 documentation\r\n(openmlsys.github.io)<i class=\"fa fa-external-link-alt\"></i></span>手册上的机器学习流程图，这里以求形象的理解</p>\r\n<figure>\r\n<img src=\"./../img/img_workflow.svg\" alt=\"img_workflow\" />\r\n<figcaption aria-hidden=\"true\">img_workflow</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>在模型训练中，一个完整的训练过程（step）需要实现以下三步：</p>\r\n<ol type=\"1\">\r\n<li><strong>正向计算</strong>：模型预测结果（logits），并与正确标签（label）求预测损失（loss）。</li>\r\n<li><strong>反向传播</strong>：利用自动微分机制，自动求模型参数（parameters）对于loss的梯度（gradients）。</li>\r\n<li><strong>参数优化</strong>：将梯度更新到参数上。</li>\r\n</ol>\r\n</blockquote>\r\n<blockquote>\r\n<p>MindSpore使用函数式自动微分机制，因此针对上述步骤需要实现：</p>\r\n<ol type=\"1\">\r\n<li>定义正向计算函数。</li>\r\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUudmFsdWVfYW5kX2dyYWQuaHRtbA==\">value_and_grad<i class=\"fa fa-external-link-alt\"></i></span>通过函数变换获得梯度计算函数。</li>\r\n<li>定义训练函数，使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5DZWxsLmh0bWwjbWluZHNwb3JlLm5uLkNlbGwuc2V0X3RyYWlu\">set_train<i class=\"fa fa-external-link-alt\"></i></span>设置为训练模式，执行正向计算、反向传播和参数优化。</li>\r\n</ol>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Instantiate loss function and optimizer</span></span><br><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), <span class=\"number\">1e-2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    logits = model(data)</span><br><span class=\"line\">    loss = loss_fn(logits, label)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, logits</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. Get gradient function</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, optimizer.parameters, has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. Define function of one-step training</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_step</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    (loss, _), grads = grad_fn(data, label)</span><br><span class=\"line\">    optimizer(grads)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train</span>(<span class=\"params\">model, dataset</span>):</span><br><span class=\"line\">    size = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> batch, (data, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        loss = train_step(data, label)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> batch % <span class=\"number\">100</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            loss, current = loss.asnumpy(), batch</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;loss: <span class=\"subst\">&#123;loss:&gt;7f&#125;</span>  [<span class=\"subst\">&#123;current:&gt;3d&#125;</span>/<span class=\"subst\">&#123;size:&gt;3d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>除训练外，我们定义测试函数，用来评估模型的性能。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">model, dataset, loss_fn</span>):</span><br><span class=\"line\">    num_batches = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\">    total, test_loss, correct = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> dataset.create_tuple_iterator():</span><br><span class=\"line\">        pred = model(data)</span><br><span class=\"line\">        total += <span class=\"built_in\">len</span>(data)</span><br><span class=\"line\">        test_loss += loss_fn(pred, label).asnumpy()</span><br><span class=\"line\">        correct += (pred.argmax(<span class=\"number\">1</span>) == label).asnumpy().<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">    test_loss /= num_batches</span><br><span class=\"line\">    correct /= total</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Test: \\n Accuracy: <span class=\"subst\">&#123;(<span class=\"number\">100</span>*correct):&gt;<span class=\"number\">0.1</span>f&#125;</span>%, Avg loss: <span class=\"subst\">&#123;test_loss:&gt;8f&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">epochs = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(epochs):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Epoch <span class=\"subst\">&#123;t+<span class=\"number\">1</span>&#125;</span>\\n-------------------------------&quot;</span>)</span><br><span class=\"line\">    train(model, train_dataset)</span><br><span class=\"line\">    test(model, test_dataset, loss_fn)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;Epoch 1</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 2.302088  [  0/938]</span><br><span class=\"line\">&gt;loss: 2.290692  [100/938]</span><br><span class=\"line\">&gt;loss: 2.266338  [200/938]</span><br><span class=\"line\">&gt;loss: 2.205240  [300/938]</span><br><span class=\"line\">&gt;loss: 1.907198  [400/938]</span><br><span class=\"line\">&gt;loss: 1.455603  [500/938]</span><br><span class=\"line\">&gt;loss: 0.861103  [600/938]</span><br><span class=\"line\">&gt;loss: 0.767219  [700/938]</span><br><span class=\"line\">&gt;loss: 0.422253  [800/938]</span><br><span class=\"line\">&gt;loss: 0.513922  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 83.8%, Avg loss: 0.529534</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Epoch 2</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 0.580867  [  0/938]</span><br><span class=\"line\">&gt;loss: 0.479347  [100/938]</span><br><span class=\"line\">&gt;loss: 0.677991  [200/938]</span><br><span class=\"line\">&gt;loss: 0.550141  [300/938]</span><br><span class=\"line\">&gt;loss: 0.226565  [400/938]</span><br><span class=\"line\">&gt;loss: 0.314738  [500/938]</span><br><span class=\"line\">&gt;loss: 0.298739  [600/938]</span><br><span class=\"line\">&gt;loss: 0.459540  [700/938]</span><br><span class=\"line\">&gt;loss: 0.332978  [800/938]</span><br><span class=\"line\">&gt;loss: 0.406709  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 90.2%, Avg loss: 0.334828</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Epoch 3</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 0.461890  [  0/938]</span><br><span class=\"line\">&gt;loss: 0.242303  [100/938]</span><br><span class=\"line\">&gt;loss: 0.281414  [200/938]</span><br><span class=\"line\">&gt;loss: 0.207835  [300/938]</span><br><span class=\"line\">&gt;loss: 0.206000  [400/938]</span><br><span class=\"line\">&gt;loss: 0.409646  [500/938]</span><br><span class=\"line\">&gt;loss: 0.193608  [600/938]</span><br><span class=\"line\">&gt;loss: 0.217575  [700/938]</span><br><span class=\"line\">&gt;loss: 0.212817  [800/938]</span><br><span class=\"line\">&gt;loss: 0.202862  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 91.9%, Avg loss: 0.280962</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Done!</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<blockquote>\r\n<p>训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。</p>\r\n</blockquote>\r\n<h3 id=\"保存模型\">保存模型</h3>\r\n<p>模型训练完成后，需要将其参数进行保存。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Save checkpoint</span></span><br><span class=\"line\">mindspore.save_checkpoint(model, <span class=\"string\">&quot;model.ckpt&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Saved Model to model.ckpt&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Saved Model to model.ckpt</p>\r\n</blockquote>\r\n<h3 id=\"加载模型\">加载模型</h3>\r\n<blockquote>\r\n<p>加载保存的权重分为两步：</p>\r\n<ol type=\"1\">\r\n<li>重新实例化模型对象，构造模型。</li>\r\n<li>加载模型参数，并将其加载至模型上。</li>\r\n</ol>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Instantiate a random initialized model</span></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"comment\"># Load checkpoint and load parameter to model</span></span><br><span class=\"line\">param_dict = mindspore.load_checkpoint(<span class=\"string\">&quot;model.ckpt&quot;</span>)</span><br><span class=\"line\">param_not_load, _ = mindspore.load_param_into_net(model, param_dict)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(param_not_load)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p><code>param_not_load未被加载的参数列表，为空时代表所有参数均加载成功。</code></p>\r\n</blockquote>\r\n<blockquote>\r\n<p>加载后的模型可以直接用于预测推理。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> test_dataset:</span><br><span class=\"line\">    pred = model(data)</span><br><span class=\"line\">    predicted = pred.argmax(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Predicted: &quot;<span class=\"subst\">&#123;predicted[:<span class=\"number\">10</span>]&#125;</span>&quot;, Actual: &quot;<span class=\"subst\">&#123;label[:<span class=\"number\">10</span>]&#125;</span>&quot;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<p>以上就是一个简单的图像识别机械学习</p>\r\n<p><strong>注意在加载模型的过程中必须定义模型构建与datapipe</strong></p>\r\n<h2 id=\"归一化处理\">归一化处理</h2>\r\n<blockquote>\r\n<p>一些传送门： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWRkbGVwZWRpYS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvdHV0b3JpYWxzL2RlZXBfbGVhcm5pbmcvbm9ybWFsaXphdGlvbi9iYXNpY19ub3JtYWxpemF0aW9uLmh0bWw=\">归一化基础知识点\r\n— PaddleEdu documentation (paddlepedia.readthedocs.io)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9nZWVrLWRvY3MuY29tL251bXB5L251bXB5LWFzay1hbnN3ZXIvbm9ybWFsaXplLW51bXB5LWFycmF5X3oxLmh0bWw=\">Numpy数组归一化|极客教程\r\n(geek-docs.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n</blockquote>\r\n<p>归一化是一种数据处理方式，能将数据经过处理后限制在某个固定范围内。</p>\r\n<h3 id=\"归一化处理的两种形式\">归一化处理的两种形式</h3>\r\n<p>归一化存在两种形式</p>\r\n<ol type=\"1\">\r\n<li>将数处理为 [0, 1]\r\n之间的小数，其目的是为了在随后的数据处理过程中更便捷，其他情况下，也可将数据处理到\r\n[-1, 1] 之间，或其他的固定范围内。</li>\r\n</ol>\r\n<blockquote>\r\n<p>例如，在图像处理中，就会将图像从 [0, 255] 归一化到 [0,\r\n1]之间，这样既不会改变图像本身的信息储存，又可加速后续的网络处理。</p>\r\n</blockquote>\r\n<ol start=\"2\" type=\"1\">\r\n<li>通过归一化将有<a href=\"#有/无量纲表达式\">量纲表达式</a>变成<a\r\nhref=\"#有/无量纲表达式\">无量纲表达式</a>。</li>\r\n</ol>\r\n<h3 id=\"为什么要进行归一化\">为什么要进行归一化</h3>\r\n<ol type=\"1\">\r\n<li>解决数据间的可比性问题</li>\r\n<li>数据归一化后，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。<a\r\nhref=\"为什么归一化能提高求解最优解的速度\">为什么能提高收敛速度</a>.</li>\r\n</ol>\r\n<h3 id=\"归一化类型\">归一化类型</h3>\r\n<ol type=\"1\">\r\n<li>Min-max normalization (Rescaling) 范围为[0,1]:</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - min(x)}{max(x) - min(x)}\r\n\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Mean normalization范围为[-1,1]：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - mean(x)}{max(x) - min(x)}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>mean(x)：x数据的平均值</p>\r\n</blockquote>\r\n<p>​\r\nMin-max归一化和mean归一化适合在最大最小值明确不变的情况下使用，比如图像处理时，灰度值限定在\r\n[0, 255] 的范围内，就可以用min-max归一化将其处理到[0,\r\n1]之间。在最大最小值不明确时，每当有新数据加入，都可能会改变最大或最小值，导致归一化结果不稳定，后续使用效果也不稳定。同时，数据需要相对稳定，如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。如果对处理后的数据范围有严格要求，也应使用min-max归一化或mean归一化。</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Z-score normalization (Standardization)范围为实数集：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - \\mu}{\\sigma}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>𝜇、𝜎 分别为样本数据的均值和标准差。</p>\r\n</blockquote>\r\n<p>​\r\nZ-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。标准化会改变数据的状态分布，但不会改变分布的种类。特别地，神经网络中经常会使用到z-score归一化，针对这一点，我们将在后续的文章中进行详细的介绍。</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>对数归一化：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{\\lg x}{\\lg max(x)}\r\n\\]</span></p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>反正切函数归一化：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\arctan(x) * \\frac{2}{\\pi}\r\n\\]</span></p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>小数定标标准化（Demical Point Normalization）:</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x}{10^j}\r\n\\]</span></p>\r\n<p>​\r\n非线性归一化通常被用在数据分化程度较大的场景，有时需要通过一些数学函数对原始值进行映射，如对数、反正切等。</p>\r\n<h3 id=\"归一化和标准化的联系与区别\">归一化和标准化的联系与区别</h3>\r\n<p>谈到归一化和标准化可能会存在一些概念的混淆，我们都知道归一化是指normalization，标准化是指standardization，但根据wiki上对feature\r\nscaling方法的定义，standardization其实就是z-score\r\nnormalization，也就是说标准化其实是归一化的一种，而一般情况下，我们会把z-score归一化称为标准化，把min-max归一化简称为归一化。在下文中，我们也是用标准化指代z-score归一化，并使用归一化指代min-max归一化。</p>\r\n<p>其实，归一化和标准化在本质上都是一种线性变换。在<a\r\nhref=\"#归一化类型\">归一化类型</a>中，我们提到了归一化和标准化的公式，对于归一化的公式，在数据给定的情况下，可以令𝑎=𝑚𝑎𝑥(𝑥)−𝑚𝑖𝑛(𝑥)、𝑏=𝑚𝑖𝑛(𝑥)，则归一化的公式可变形为：\r\n<span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - b}{a} = \\frac{x}{a} - \\frac{b}{a} = \\frac{x}{a} -\r\nc\r\n\\]</span> 标准化的公式与变形后的归一化类似，其中的$<span\r\nclass=\"math inline\">\\(和\\)</span>$在数据给定的情况下，可以看作常数。因此，标准化的变形与归一化的类似，都可看作对𝑥按比例𝑎进行缩放，再进行𝑐个单位的平移。由此可见，归一化和标准化的本质都是一种线性变换，他们都不会因为对数据的处理而改变数据的原始数值排序。</p>\r\n<p>那么归一化和标准化又有什么区别呢？</p>\r\n<ol type=\"1\">\r\n<li>归一化不会改变数据的状态分布，但标准化会改变数据的状态分布；</li>\r\n<li>归一化会将数据限定在一个具体的范围内，如 [0,\r\n1]，但标准化不会，标准化只会将数据处理为均值为0，标准差为1。</li>\r\n</ol>\r\n<h3\r\nid=\"为什么归一化能提高求解最优解的速度\">为什么归一化能提高求解最优解的速度</h3>\r\n<p><span class=\"math display\">\\[\r\n\\begin{split}\r\n\\begin{align}\r\ny &amp;= \\theta_1x_1 + \\theta_2x_2 \\\\\r\nJ &amp;= (\\theta_{1}x_{1} + \\theta_{2}x_{2} - y_{label})^2\r\n\\end{align}\r\n\\end{split}\r\n\\]</span></p>\r\n<p>假设自变量只有房子到地铁站的距离<span\r\nclass=\"math display\">\\[𝑥_1\\]</span>和房子内房间的个数<span\r\nclass=\"math display\">\\[𝑥_2\\]</span>，因变量为房价，预测公式和损失函数分别为：</p>\r\n<p><span class=\"math display\">\\[\r\nJ = (1000\\theta_{1}+3\\theta_{2} - y_{label})^2\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/QAonmGKX4FqxUMt.png\"\r\nalt=\"normalization\" />\r\n<figcaption aria-hidden=\"true\">normalization</figcaption>\r\n</figure>\r\n<div data-align=\"center\">\r\n图1: 损失函数的等高线，图1（左）为未归一化时，图1（右）为归一化\r\n</div>\r\n<p>​\r\n在图1中，左图的红色椭圆代表归一化前的损失函数等高线，蓝色线段代表梯度的更新，箭头的方向代表梯度更新的方向。寻求最优解的过程就是梯度更新的过程，其更新方向与登高线垂直。由于𝑥1\r\n和 𝑥2\r\n的量级相差过大，损失函数的等高线呈现为一个瘦窄的椭圆。因此如图1（左）所示，瘦窄的椭圆形会使得梯度下降过程呈之字形呈现，导致梯度下降速度缓慢。</p>\r\n<p>​ 当数据经过归一化后，<span class=\"math inline\">\\(x_{1}^{&#39;} =\r\n\\frac{1000-0}{5000-0}=0.2\\)</span>，<span\r\nclass=\"math inline\">\\(x_{2}^{&#39;} =\r\n\\frac{3-0}{10-0}=0.3\\)</span>，那么损失函数的公式可以写为： <span\r\nclass=\"math display\">\\[\r\nJ(x) = (0.2\\theta_{1} + 0.3\\theta_{2} - y_{label})^2\r\n\\]</span> ​\r\n我们可以看到，经过归一化后的数据属于同一量级，损失函数的等高线呈现为一个矮胖的椭圆形（如图1（右）所示），求解最优解过程变得更加迅速且平缓，因此可以在通过梯度下降进行求解时获得更快的收敛。</p>\r\n<h2 id=\"有无量纲表达式\">有/无量纲表达式</h2>\r\n<p>我们假定数据都是一个个变量（不过提前收集好了）量纲指有些未知数他们是变量存在的一种或几种依赖关系，该变量的值由这些依赖关系的未知数（量纲）决定。</p>\r\n<blockquote>\r\n<p>就像一些函数的y值，理想状态下的房价，他们由x，面积/位置决定。</p>\r\n</blockquote>\r\n<p>显然位置差几百米，面积差几百平方米对变量影响差距极大，这种情况下我们称对这些依赖关系式是有量纲的。他们对变量影响的系数存在数量级的不同。</p>\r\n<h2 id=\"常见问题\">常见问题</h2>\r\n<ol type=\"1\">\r\n<li>vscode\r\n出现python解释器的选择错误，这在windows经常有非常多版本的相同软件上经常出现，选定安装MindSpore库的python版本</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/QSIFMsjBCUAo34y.png\"\r\nalt=\"image-20240605210110827\" />\r\n<figcaption aria-hidden=\"true\">image-20240605210110827</figcaption>\r\n</figure>\r\n<p>​ 点击此处python版本即可</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>注意python的多数语法检查集成已分离为插件，一些在2023.10发布，发布后一些网络上的blog修改linting的将禁用，详情请看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUtcHl0aG9uL3dpa2kvTWlncmF0aW9uLXRvLVB5dGhvbi1Ub29scy1FeHRlbnNpb25z\">迁移到\r\nPython 工具扩展 ·microsoft/vscode-python 维基 (github.com)<i class=\"fa fa-external-link-alt\"></i></span></p></li>\r\n<li><p>解决一些格式上的报错也可以不理会，但根据PEP 8\r\npython规范，一行不能超过80个字符，同时换行需要缩进,如果看不管可以在扩展语法检查中增加args</p></li>\r\n</ol>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--max-line-length=120</span><br></pre></td></tr></table></figure>"},{"title":"MindSpore专题——第四章、数据集","date":"2024-08-14T11:47:58.000Z","_content":"## 数据集\n\n继续[第二章](./Second_TryMindSpore.md)中的Mnist数据库为例，介绍使用mindspore.dataset进行加载的方法。\n\n详情请见MNIST数据官方网站：[MNIST handwritten digit database, Yann LeCun, Corinna Cortes and Chris Burges](http://yann.lecun.com/exdb/mnist/)\n\n<!--more-->\n\n下面是简略介绍\n\n|   数据集   |      MNIST中的文件名       |                          下载地址                           |  文件大小   |\n| :--------: | :------------------------: | :---------------------------------------------------------: | :---------: |\n| 训练集图像 | train-images-idx3-ubyte.gz | http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz | 9912422字节 |\n| 训练集标签 | train-labels-idx1-ubyte.gz | http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz |  28881字节  |\n| 测试集图像 | t10k-images-idx3-ubyte.gz  | http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz  | 1648877字节 |\n| 测试集标签 | t10k-labels-idx1-ubyte.gz  | http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz  |  4542字节   |\n\n\n\n### 数据库加载\n\n*请注意：mindspore.dataset的接口仅支持解压后的数据文件*\n\n```python\ntrain_dataset = MnistDataset(\"MNIST_Data/train\", shuffle=False)\nprint(type(train_dataset))\n```\n\n> <class 'mindspore.dataset.engine.datasets_vision.MnistDataset'>\n\n### 数据库迭代\n\n数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。我们可以用[create_tuple_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_tuple_iterator.html)或[create_dict_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_dict_iterator.html)接口创建数据迭代器，迭代访问数据。访问的数据类型默认为`Tensor`；若设置`output_numpy=True`，访问的数据类型为`Numpy`。\n\n下面定义一个可视化函数，迭代9张图片进行展示。\n\n```python\ndef visualize(dataset):\n    figure = plt.figure(figsize=(4, 4))\n    cols, rows = 3, 3\n\n    plt.subplots_adjust(wspace=0.5, hspace=0.5)\n\n    for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):\n        figure.add_subplot(rows, cols, idx + 1)\n        plt.title(int(label))\n        plt.axis(\"off\")\n        plt.imshow(image.asnumpy().squeeze(), cmap=\"gray\")\n        if idx == cols * rows - 1:\n            break\n    plt.show()\n```\n\n在`for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):`此处的循环中枚举了训练集的前9个图像`enumerate()`函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\n\n在循环体中使用了plt类画图。\n\n![image-20240606173353887](https://s2.loli.net/2024/06/06/36CU8spH9eSEkxl.png)\n\n### 数据集常用操作\n\nPipeline的设计理念使得数据集的常用操作采用`dataset = dataset.operation()`的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。\n\n下面分别介绍几种常见的数据集操作。\n\n### shuffle\n\n数据集随机`shuffle`可以消除数据排列造成的分布不均问题\n\n![op-shuffle](https://s2.loli.net/2024/06/06/M54ICySt9dzenva.png)\n\n`mindspore.dataset`提供的数据集在加载时可配置`shuffle=True`，或使用如下操作\n\n```python\ntrain_dataset = train_dataset.shuffle(buffer_size=64)\nvisualize(train_dataset)\n```\n\n![image-20240606173414784](https://s2.loli.net/2024/06/06/yB76TmklvtYXIgE.png)\n\n### map\n\n`map`操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。\n\n```python\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(\"map前：\")\nprint(image.shape, image.dtype)\ntrain_dataset = train_dataset.map(vision.Rescale(1.0 / 255.0, 0), input_columns='image')\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(\"map后：\")\nprint(image.shape, image.dtype)\n```\n\n> ```\n> map前：\n> (28, 28, 1) UInt8\n> map后：\n> (28, 28, 1) Float32\n> ```\n\n### batch\n\n将数据集打包为固定大小的`batch`是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。分块思想\n\n一般我们会设置一个固定的batch size，将连续的数据分为若干批（batch）。\n\n```python\n# 一般设定固定batchSize\ntrain_dataset = train_dataset.batch(batch_size=32)\n# batch后的数据增加一维，大小为batch_size\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(image.shape, image.dtype)\n```\n\n> (32, 28, 28, 1) Float32\n\n### 自定义数据集\n\n`mindspore.dataset`模块提供了一些常用的公开数据集和标准格式数据集的加载API。\n\n对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过`GeneratorDataset`接口实现自定义方式的数据集加载。\n\n`GeneratorDataset`支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。\n\n#### 可随机访问数据集\n\n可随机访问数据集是实现了`__getitem__`和`__len__`方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。\n\n1. 实现了` __init__`，`__getitem__ ` 和`__len__`\n2. 当使用`dataset[idx]`访问这样的数据集时，可以读取dataset内容中第idx个样本或标签\n\n```python\n# Random-accessible object as input source\nclass RandomAccessDataset:\n    def __init__(self):\n        self._data = np.ones((5, 2))\n        self._label = np.zeros((5, 1))\n\n    def __getitem__(self, index):\n        return self._data[index], self._label[index]\n\n    def __len__(self):\n        return len(self._data)\n\n\nloader = RandomAccessDataset()\ndataset = GeneratorDataset(source=loader, column_names=[\"data\", \"label\"])\n\nfor data in dataset:\n    print(data)\n    \nloader = [np.array(0), np.array(1), np.array(2)]\ndataset = GeneratorDataset(source=loader, column_names=[\"data\"])\n\nfor data in dataset:\n    print(data)\n\n```\n\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n\n创建的过程非常简单，通过numpy的数据结构为底层，实现三个方法就好了，更简单的直接使用list，tuple也是可行的。\n\n#### 可迭代数据集\n\n可迭代的数据集是实现了`__iter__`和`__next__`方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。\n\n例如，当使用`iter(dataset)`的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。\n\n下面构造一个简单迭代器，并将其加载至`GeneratorDataset`。\n\n```python\n# Iterator as input source\nclass IterableDataset():\n    def __init__(self, start, end):\n        '''init the class object to hold the data'''\n        self.start = start\n        self.end = end\n\n    def __next__(self):\n        '''iter one data and return'''\n        return next(self.data)\n\n    def __iter__(self):\n        '''reset the iter'''\n        self.data = iter(range(self.start, self.end))\n        return self\n\n\nloader = IterableDataset(1, 5)\ndataset = GeneratorDataset(source=loader, column_names=[\"data\"])\n\nfor d in dataset:\n    print(d)\n\n```\n\n> [Tensor(shape=[], dtype=Int32, value= 1)]\n> [Tensor(shape=[], dtype=Int32, value= 2)]\n> [Tensor(shape=[], dtype=Int32, value= 3)]\n> [Tensor(shape=[], dtype=Int32, value= 4)]\n\n同样的，实现方法即可\n\n#### 生成器\n\n生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型`generator`返回数据，直至生成器抛出`StopIteration`异常。\n\n下面构造一个生成器，并将其加载至`GeneratorDataset`。\n\n```python\n# Generator\ndef my_generator(start, end):\n    for i in range(start, end):\n        yield i\n\n\n# since a generator instance can be only iterated once, we need to wrap it by lambda to generate multiple instances\ndataset = GeneratorDataset(source=lambda: my_generator(3, 6), column_names=[\"data\"])\n\nfor d in dataset:\n    print(d)\n```\n\n>[Tensor(shape=[], dtype=Int32, value= 3)]\n>[Tensor(shape=[], dtype=Int32, value= 4)]\n>[Tensor(shape=[], dtype=Int32, value= 5)]\n\n这个更绝，仅用一个函数即可生成。（此处匿不匿名无关紧要）\n\n## 常见问题\n\n1. 找不到模块 matplotlib\n\n```shell\npip install matplotlib\n```\n\n","source":"_posts/special_subject/MindSpore/Chapters/Fourth_DataSet.md","raw":"---\ntitle: MindSpore专题——第四章、数据集\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## 数据集\n\n继续[第二章](./Second_TryMindSpore.md)中的Mnist数据库为例，介绍使用mindspore.dataset进行加载的方法。\n\n详情请见MNIST数据官方网站：[MNIST handwritten digit database, Yann LeCun, Corinna Cortes and Chris Burges](http://yann.lecun.com/exdb/mnist/)\n\n<!--more-->\n\n下面是简略介绍\n\n|   数据集   |      MNIST中的文件名       |                          下载地址                           |  文件大小   |\n| :--------: | :------------------------: | :---------------------------------------------------------: | :---------: |\n| 训练集图像 | train-images-idx3-ubyte.gz | http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz | 9912422字节 |\n| 训练集标签 | train-labels-idx1-ubyte.gz | http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz |  28881字节  |\n| 测试集图像 | t10k-images-idx3-ubyte.gz  | http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz  | 1648877字节 |\n| 测试集标签 | t10k-labels-idx1-ubyte.gz  | http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz  |  4542字节   |\n\n\n\n### 数据库加载\n\n*请注意：mindspore.dataset的接口仅支持解压后的数据文件*\n\n```python\ntrain_dataset = MnistDataset(\"MNIST_Data/train\", shuffle=False)\nprint(type(train_dataset))\n```\n\n> <class 'mindspore.dataset.engine.datasets_vision.MnistDataset'>\n\n### 数据库迭代\n\n数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。我们可以用[create_tuple_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_tuple_iterator.html)或[create_dict_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_dict_iterator.html)接口创建数据迭代器，迭代访问数据。访问的数据类型默认为`Tensor`；若设置`output_numpy=True`，访问的数据类型为`Numpy`。\n\n下面定义一个可视化函数，迭代9张图片进行展示。\n\n```python\ndef visualize(dataset):\n    figure = plt.figure(figsize=(4, 4))\n    cols, rows = 3, 3\n\n    plt.subplots_adjust(wspace=0.5, hspace=0.5)\n\n    for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):\n        figure.add_subplot(rows, cols, idx + 1)\n        plt.title(int(label))\n        plt.axis(\"off\")\n        plt.imshow(image.asnumpy().squeeze(), cmap=\"gray\")\n        if idx == cols * rows - 1:\n            break\n    plt.show()\n```\n\n在`for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):`此处的循环中枚举了训练集的前9个图像`enumerate()`函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\n\n在循环体中使用了plt类画图。\n\n![image-20240606173353887](https://s2.loli.net/2024/06/06/36CU8spH9eSEkxl.png)\n\n### 数据集常用操作\n\nPipeline的设计理念使得数据集的常用操作采用`dataset = dataset.operation()`的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。\n\n下面分别介绍几种常见的数据集操作。\n\n### shuffle\n\n数据集随机`shuffle`可以消除数据排列造成的分布不均问题\n\n![op-shuffle](https://s2.loli.net/2024/06/06/M54ICySt9dzenva.png)\n\n`mindspore.dataset`提供的数据集在加载时可配置`shuffle=True`，或使用如下操作\n\n```python\ntrain_dataset = train_dataset.shuffle(buffer_size=64)\nvisualize(train_dataset)\n```\n\n![image-20240606173414784](https://s2.loli.net/2024/06/06/yB76TmklvtYXIgE.png)\n\n### map\n\n`map`操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。\n\n```python\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(\"map前：\")\nprint(image.shape, image.dtype)\ntrain_dataset = train_dataset.map(vision.Rescale(1.0 / 255.0, 0), input_columns='image')\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(\"map后：\")\nprint(image.shape, image.dtype)\n```\n\n> ```\n> map前：\n> (28, 28, 1) UInt8\n> map后：\n> (28, 28, 1) Float32\n> ```\n\n### batch\n\n将数据集打包为固定大小的`batch`是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。分块思想\n\n一般我们会设置一个固定的batch size，将连续的数据分为若干批（batch）。\n\n```python\n# 一般设定固定batchSize\ntrain_dataset = train_dataset.batch(batch_size=32)\n# batch后的数据增加一维，大小为batch_size\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(image.shape, image.dtype)\n```\n\n> (32, 28, 28, 1) Float32\n\n### 自定义数据集\n\n`mindspore.dataset`模块提供了一些常用的公开数据集和标准格式数据集的加载API。\n\n对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过`GeneratorDataset`接口实现自定义方式的数据集加载。\n\n`GeneratorDataset`支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。\n\n#### 可随机访问数据集\n\n可随机访问数据集是实现了`__getitem__`和`__len__`方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。\n\n1. 实现了` __init__`，`__getitem__ ` 和`__len__`\n2. 当使用`dataset[idx]`访问这样的数据集时，可以读取dataset内容中第idx个样本或标签\n\n```python\n# Random-accessible object as input source\nclass RandomAccessDataset:\n    def __init__(self):\n        self._data = np.ones((5, 2))\n        self._label = np.zeros((5, 1))\n\n    def __getitem__(self, index):\n        return self._data[index], self._label[index]\n\n    def __len__(self):\n        return len(self._data)\n\n\nloader = RandomAccessDataset()\ndataset = GeneratorDataset(source=loader, column_names=[\"data\", \"label\"])\n\nfor data in dataset:\n    print(data)\n    \nloader = [np.array(0), np.array(1), np.array(2)]\ndataset = GeneratorDataset(source=loader, column_names=[\"data\"])\n\nfor data in dataset:\n    print(data)\n\n```\n\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n\n创建的过程非常简单，通过numpy的数据结构为底层，实现三个方法就好了，更简单的直接使用list，tuple也是可行的。\n\n#### 可迭代数据集\n\n可迭代的数据集是实现了`__iter__`和`__next__`方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。\n\n例如，当使用`iter(dataset)`的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。\n\n下面构造一个简单迭代器，并将其加载至`GeneratorDataset`。\n\n```python\n# Iterator as input source\nclass IterableDataset():\n    def __init__(self, start, end):\n        '''init the class object to hold the data'''\n        self.start = start\n        self.end = end\n\n    def __next__(self):\n        '''iter one data and return'''\n        return next(self.data)\n\n    def __iter__(self):\n        '''reset the iter'''\n        self.data = iter(range(self.start, self.end))\n        return self\n\n\nloader = IterableDataset(1, 5)\ndataset = GeneratorDataset(source=loader, column_names=[\"data\"])\n\nfor d in dataset:\n    print(d)\n\n```\n\n> [Tensor(shape=[], dtype=Int32, value= 1)]\n> [Tensor(shape=[], dtype=Int32, value= 2)]\n> [Tensor(shape=[], dtype=Int32, value= 3)]\n> [Tensor(shape=[], dtype=Int32, value= 4)]\n\n同样的，实现方法即可\n\n#### 生成器\n\n生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型`generator`返回数据，直至生成器抛出`StopIteration`异常。\n\n下面构造一个生成器，并将其加载至`GeneratorDataset`。\n\n```python\n# Generator\ndef my_generator(start, end):\n    for i in range(start, end):\n        yield i\n\n\n# since a generator instance can be only iterated once, we need to wrap it by lambda to generate multiple instances\ndataset = GeneratorDataset(source=lambda: my_generator(3, 6), column_names=[\"data\"])\n\nfor d in dataset:\n    print(d)\n```\n\n>[Tensor(shape=[], dtype=Int32, value= 3)]\n>[Tensor(shape=[], dtype=Int32, value= 4)]\n>[Tensor(shape=[], dtype=Int32, value= 5)]\n\n这个更绝，仅用一个函数即可生成。（此处匿不匿名无关紧要）\n\n## 常见问题\n\n1. 找不到模块 matplotlib\n\n```shell\npip install matplotlib\n```\n\n","slug":"special_subject/MindSpore/Chapters/Fourth_DataSet","published":1,"updated":"2024-08-16T08:58:57.218Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjan0025lowv1hth8r6z","content":"<h2 id=\"数据集\">数据集</h2>\r\n<p>继续<a\r\nhref=\"./Second_TryMindSpore.md\">第二章</a>中的Mnist数据库为例，介绍使用mindspore.dataset进行加载的方法。</p>\r\n<p>详情请见MNIST数据官方网站：<span class=\"exturl\" data-url=\"aHR0cDovL3lhbm4ubGVjdW4uY29tL2V4ZGIvbW5pc3Qv\">MNIST handwritten digit\r\ndatabase, Yann LeCun, Corinna Cortes and Chris Burges<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<p>下面是简略介绍</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 9%\" />\r\n<col style=\"width: 24%\" />\r\n<col style=\"width: 55%\" />\r\n<col style=\"width: 10%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">数据集</th>\r\n<th style=\"text-align: center;\">MNIST中的文件名</th>\r\n<th style=\"text-align: center;\">下载地址</th>\r\n<th style=\"text-align: center;\">文件大小</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">训练集图像</td>\r\n<td style=\"text-align: center;\">train-images-idx3-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz</td>\r\n<td style=\"text-align: center;\">9912422字节</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">训练集标签</td>\r\n<td style=\"text-align: center;\">train-labels-idx1-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz</td>\r\n<td style=\"text-align: center;\">28881字节</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">测试集图像</td>\r\n<td style=\"text-align: center;\">t10k-images-idx3-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz</td>\r\n<td style=\"text-align: center;\">1648877字节</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">测试集标签</td>\r\n<td style=\"text-align: center;\">t10k-labels-idx1-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz</td>\r\n<td style=\"text-align: center;\">4542字节</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"数据库加载\">数据库加载</h3>\r\n<p><em>请注意：mindspore.dataset的接口仅支持解压后的数据文件</em></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">train_dataset = MnistDataset(<span class=\"string\">&quot;MNIST_Data/train&quot;</span>, shuffle=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(train_dataset))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>&lt;class\r\n'mindspore.dataset.engine.datasets_vision.MnistDataset'&gt;</p>\r\n</blockquote>\r\n<h3 id=\"数据库迭代\">数据库迭代</h3>\r\n<p>数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。我们可以用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfdHVwbGVfaXRlcmF0b3IuaHRtbA==\">create_tuple_iterator<i class=\"fa fa-external-link-alt\"></i></span>或<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfZGljdF9pdGVyYXRvci5odG1s\">create_dict_iterator<i class=\"fa fa-external-link-alt\"></i></span>接口创建数据迭代器，迭代访问数据。访问的数据类型默认为<code>Tensor</code>；若设置<code>output_numpy=True</code>，访问的数据类型为<code>Numpy</code>。</p>\r\n<p>下面定义一个可视化函数，迭代9张图片进行展示。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">visualize</span>(<span class=\"params\">dataset</span>):</span><br><span class=\"line\">    figure = plt.figure(figsize=(<span class=\"number\">4</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\">    cols, rows = <span class=\"number\">3</span>, <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    plt.subplots_adjust(wspace=<span class=\"number\">0.5</span>, hspace=<span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx, (image, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        figure.add_subplot(rows, cols, idx + <span class=\"number\">1</span>)</span><br><span class=\"line\">        plt.title(<span class=\"built_in\">int</span>(label))</span><br><span class=\"line\">        plt.axis(<span class=\"string\">&quot;off&quot;</span>)</span><br><span class=\"line\">        plt.imshow(image.asnumpy().squeeze(), cmap=<span class=\"string\">&quot;gray&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> idx == cols * rows - <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    plt.show()</span><br></pre></td></tr></table></figure>\r\n<p>在<code>for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):</code>此处的循环中枚举了训练集的前9个图像<code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在\r\nfor 循环当中。</p>\r\n<p>在循环体中使用了plt类画图。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/36CU8spH9eSEkxl.png\"\r\nalt=\"image-20240606173353887\" />\r\n<figcaption aria-hidden=\"true\">image-20240606173353887</figcaption>\r\n</figure>\r\n<h3 id=\"数据集常用操作\">数据集常用操作</h3>\r\n<p>Pipeline的设计理念使得数据集的常用操作采用<code>dataset = dataset.operation()</code>的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。</p>\r\n<p>下面分别介绍几种常见的数据集操作。</p>\r\n<h3 id=\"shuffle\">shuffle</h3>\r\n<p>数据集随机<code>shuffle</code>可以消除数据排列造成的分布不均问题</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/M54ICySt9dzenva.png\"\r\nalt=\"op-shuffle\" />\r\n<figcaption aria-hidden=\"true\">op-shuffle</figcaption>\r\n</figure>\r\n<p><code>mindspore.dataset</code>提供的数据集在加载时可配置<code>shuffle=True</code>，或使用如下操作</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">train_dataset = train_dataset.shuffle(buffer_size=<span class=\"number\">64</span>)</span><br><span class=\"line\">visualize(train_dataset)</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/yB76TmklvtYXIgE.png\"\r\nalt=\"image-20240606173414784\" />\r\n<figcaption aria-hidden=\"true\">image-20240606173414784</figcaption>\r\n</figure>\r\n<h3 id=\"map\">map</h3>\r\n<p><code>map</code>操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;map前：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br><span class=\"line\">train_dataset = train_dataset.<span class=\"built_in\">map</span>(vision.Rescale(<span class=\"number\">1.0</span> / <span class=\"number\">255.0</span>, <span class=\"number\">0</span>), input_columns=<span class=\"string\">&#x27;image&#x27;</span>)</span><br><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;map后：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map前：</span><br><span class=\"line\">(28, 28, 1) UInt8</span><br><span class=\"line\">map后：</span><br><span class=\"line\">(28, 28, 1) Float32</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<h3 id=\"batch\">batch</h3>\r\n<p>将数据集打包为固定大小的<code>batch</code>是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。分块思想</p>\r\n<p>一般我们会设置一个固定的batch\r\nsize，将连续的数据分为若干批（batch）。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一般设定固定batchSize</span></span><br><span class=\"line\">train_dataset = train_dataset.batch(batch_size=<span class=\"number\">32</span>)</span><br><span class=\"line\"><span class=\"comment\"># batch后的数据增加一维，大小为batch_size</span></span><br><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>(32, 28, 28, 1) Float32</p>\r\n</blockquote>\r\n<h3 id=\"自定义数据集\">自定义数据集</h3>\r\n<p><code>mindspore.dataset</code>模块提供了一些常用的公开数据集和标准格式数据集的加载API。</p>\r\n<p>对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过<code>GeneratorDataset</code>接口实现自定义方式的数据集加载。</p>\r\n<p><code>GeneratorDataset</code>支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。</p>\r\n<h4 id=\"可随机访问数据集\">可随机访问数据集</h4>\r\n<p>可随机访问数据集是实现了<code>__getitem__</code>和<code>__len__</code>方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。</p>\r\n<ol type=\"1\">\r\n<li>实现了<code>__init__</code>，<code>__getitem__</code>\r\n和<code>__len__</code></li>\r\n<li>当使用<code>dataset[idx]</code>访问这样的数据集时，可以读取dataset内容中第idx个样本或标签</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Random-accessible object as input source</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RandomAccessDataset</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>._data = np.ones((<span class=\"number\">5</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>._label = np.zeros((<span class=\"number\">5</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__getitem__</span>(<span class=\"params\">self, index</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>._data[index], <span class=\"variable language_\">self</span>._label[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__len__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(<span class=\"variable language_\">self</span>._data)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">loader = RandomAccessDataset()</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>, <span class=\"string\">&quot;label&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data)</span><br><span class=\"line\">    </span><br><span class=\"line\">loader = [np.array(<span class=\"number\">0</span>), np.array(<span class=\"number\">1</span>), np.array(<span class=\"number\">2</span>)]</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,\r\n1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [\r\n0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])]</p>\r\n</blockquote>\r\n<p>创建的过程非常简单，通过numpy的数据结构为底层，实现三个方法就好了，更简单的直接使用list，tuple也是可行的。</p>\r\n<h4 id=\"可迭代数据集\">可迭代数据集</h4>\r\n<p>可迭代的数据集是实现了<code>__iter__</code>和<code>__next__</code>方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。</p>\r\n<p>例如，当使用<code>iter(dataset)</code>的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。</p>\r\n<p>下面构造一个简单迭代器，并将其加载至<code>GeneratorDataset</code>。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Iterator as input source</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IterableDataset</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, start, end</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;init the class object to hold the data&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.start = start</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.end = end</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;iter one data and return&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(<span class=\"variable language_\">self</span>.data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;reset the iter&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.data = <span class=\"built_in\">iter</span>(<span class=\"built_in\">range</span>(<span class=\"variable language_\">self</span>.start, <span class=\"variable language_\">self</span>.end))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">loader = IterableDataset(<span class=\"number\">1</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(d)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[], dtype=Int32, value= 1)] [Tensor(shape=[],\r\ndtype=Int32, value= 2)] [Tensor(shape=[], dtype=Int32, value= 3)]\r\n[Tensor(shape=[], dtype=Int32, value= 4)]</p>\r\n</blockquote>\r\n<p>同样的，实现方法即可</p>\r\n<h4 id=\"生成器\">生成器</h4>\r\n<p>生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型<code>generator</code>返回数据，直至生成器抛出<code>StopIteration</code>异常。</p>\r\n<p>下面构造一个生成器，并将其加载至<code>GeneratorDataset</code>。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Generator</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_generator</span>(<span class=\"params\">start, end</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(start, end):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># since a generator instance can be only iterated once, we need to wrap it by lambda to generate multiple instances</span></span><br><span class=\"line\">dataset = GeneratorDataset(source=<span class=\"keyword\">lambda</span>: my_generator(<span class=\"number\">3</span>, <span class=\"number\">6</span>), column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(d)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[], dtype=Int32, value= 3)] [Tensor(shape=[],\r\ndtype=Int32, value= 4)] [Tensor(shape=[], dtype=Int32, value= 5)]</p>\r\n</blockquote>\r\n<p>这个更绝，仅用一个函数即可生成。（此处匿不匿名无关紧要）</p>\r\n<h2 id=\"常见问题\">常见问题</h2>\r\n<ol type=\"1\">\r\n<li>找不到模块 matplotlib</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install matplotlib</span><br></pre></td></tr></table></figure>\r\n","length":1651,"excerpt":"<h2 id=\"数据集\">数据集</h2>\r\n<p>继续<a\r\nhref=\"./Second_TryMindSpore.md\">第二章</a>中的Mnist数据库为例，介绍使用mindspore.dataset进行加载的方法。</p>\r\n<p>详情请见MNIST数据官方网站：<span class=\"exturl\" data-url=\"aHR0cDovL3lhbm4ubGVjdW4uY29tL2V4ZGIvbW5pc3Qv\">MNIST handwritten digit\r\ndatabase, Yann LeCun, Corinna Cortes and Chris Burges<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<p>下面是简略介绍</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 9%\" />\r\n<col style=\"width: 24%\" />\r\n<col style=\"width: 55%\" />\r\n<col style=\"width: 10%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">数据集</th>\r\n<th style=\"text-align: center;\">MNIST中的文件名</th>\r\n<th style=\"text-align: center;\">下载地址</th>\r\n<th style=\"text-align: center;\">文件大小</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">训练集图像</td>\r\n<td style=\"text-align: center;\">train-images-idx3-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz</td>\r\n<td style=\"text-align: center;\">9912422字节</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">训练集标签</td>\r\n<td style=\"text-align: center;\">train-labels-idx1-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz</td>\r\n<td style=\"text-align: center;\">28881字节</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">测试集图像</td>\r\n<td style=\"text-align: center;\">t10k-images-idx3-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz</td>\r\n<td style=\"text-align: center;\">1648877字节</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">测试集标签</td>\r\n<td style=\"text-align: center;\">t10k-labels-idx1-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz</td>\r\n<td style=\"text-align: center;\">4542字节</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"数据库加载\">数据库加载</h3>\r\n<p><em>请注意：mindspore.dataset的接口仅支持解压后的数据文件</em></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">train_dataset = MnistDataset(<span class=\"string\">&quot;MNIST_Data/train&quot;</span>, shuffle=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(train_dataset))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>&lt;class\r\n'mindspore.dataset.engine.datasets_vision.MnistDataset'&gt;</p>\r\n</blockquote>\r\n<h3 id=\"数据库迭代\">数据库迭代</h3>\r\n<p>数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。我们可以用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfdHVwbGVfaXRlcmF0b3IuaHRtbA==\">create_tuple_iterator<i class=\"fa fa-external-link-alt\"></i></span>或<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfZGljdF9pdGVyYXRvci5odG1s\">create_dict_iterator<i class=\"fa fa-external-link-alt\"></i></span>接口创建数据迭代器，迭代访问数据。访问的数据类型默认为<code>Tensor</code>；若设置<code>output_numpy=True</code>，访问的数据类型为<code>Numpy</code>。</p>\r\n<p>下面定义一个可视化函数，迭代9张图片进行展示。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">visualize</span>(<span class=\"params\">dataset</span>):</span><br><span class=\"line\">    figure = plt.figure(figsize=(<span class=\"number\">4</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\">    cols, rows = <span class=\"number\">3</span>, <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    plt.subplots_adjust(wspace=<span class=\"number\">0.5</span>, hspace=<span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx, (image, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        figure.add_subplot(rows, cols, idx + <span class=\"number\">1</span>)</span><br><span class=\"line\">        plt.title(<span class=\"built_in\">int</span>(label))</span><br><span class=\"line\">        plt.axis(<span class=\"string\">&quot;off&quot;</span>)</span><br><span class=\"line\">        plt.imshow(image.asnumpy().squeeze(), cmap=<span class=\"string\">&quot;gray&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> idx == cols * rows - <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    plt.show()</span><br></pre></td></tr></table></figure>\r\n<p>在<code>for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):</code>此处的循环中枚举了训练集的前9个图像<code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在\r\nfor 循环当中。</p>\r\n<p>在循环体中使用了plt类画图。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/36CU8spH9eSEkxl.png\"\r\nalt=\"image-20240606173353887\" />\r\n<figcaption aria-hidden=\"true\">image-20240606173353887</figcaption>\r\n</figure>\r\n<h3 id=\"数据集常用操作\">数据集常用操作</h3>\r\n<p>Pipeline的设计理念使得数据集的常用操作采用<code>dataset = dataset.operation()</code>的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。</p>\r\n<p>下面分别介绍几种常见的数据集操作。</p>\r\n<h3 id=\"shuffle\">shuffle</h3>\r\n<p>数据集随机<code>shuffle</code>可以消除数据排列造成的分布不均问题</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/M54ICySt9dzenva.png\"\r\nalt=\"op-shuffle\" />\r\n<figcaption aria-hidden=\"true\">op-shuffle</figcaption>\r\n</figure>\r\n<p><code>mindspore.dataset</code>提供的数据集在加载时可配置<code>shuffle=True</code>，或使用如下操作</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">train_dataset = train_dataset.shuffle(buffer_size=<span class=\"number\">64</span>)</span><br><span class=\"line\">visualize(train_dataset)</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/yB76TmklvtYXIgE.png\"\r\nalt=\"image-20240606173414784\" />\r\n<figcaption aria-hidden=\"true\">image-20240606173414784</figcaption>\r\n</figure>\r\n<h3 id=\"map\">map</h3>\r\n<p><code>map</code>操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;map前：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br><span class=\"line\">train_dataset = train_dataset.<span class=\"built_in\">map</span>(vision.Rescale(<span class=\"number\">1.0</span> / <span class=\"number\">255.0</span>, <span class=\"number\">0</span>), input_columns=<span class=\"string\">&#x27;image&#x27;</span>)</span><br><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;map后：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map前：</span><br><span class=\"line\">(28, 28, 1) UInt8</span><br><span class=\"line\">map后：</span><br><span class=\"line\">(28, 28, 1) Float32</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<h3 id=\"batch\">batch</h3>\r\n<p>将数据集打包为固定大小的<code>batch</code>是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。分块思想</p>\r\n<p>一般我们会设置一个固定的batch\r\nsize，将连续的数据分为若干批（batch）。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一般设定固定batchSize</span></span><br><span class=\"line\">train_dataset = train_dataset.batch(batch_size=<span class=\"number\">32</span>)</span><br><span class=\"line\"><span class=\"comment\"># batch后的数据增加一维，大小为batch_size</span></span><br><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>(32, 28, 28, 1) Float32</p>\r\n</blockquote>\r\n<h3 id=\"自定义数据集\">自定义数据集</h3>\r\n<p><code>mindspore.dataset</code>模块提供了一些常用的公开数据集和标准格式数据集的加载API。</p>\r\n<p>对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过<code>GeneratorDataset</code>接口实现自定义方式的数据集加载。</p>\r\n<p><code>GeneratorDataset</code>支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。</p>\r\n<h4 id=\"可随机访问数据集\">可随机访问数据集</h4>\r\n<p>可随机访问数据集是实现了<code>__getitem__</code>和<code>__len__</code>方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。</p>\r\n<ol type=\"1\">\r\n<li>实现了<code>__init__</code>，<code>__getitem__</code>\r\n和<code>__len__</code></li>\r\n<li>当使用<code>dataset[idx]</code>访问这样的数据集时，可以读取dataset内容中第idx个样本或标签</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Random-accessible object as input source</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RandomAccessDataset</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>._data = np.ones((<span class=\"number\">5</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>._label = np.zeros((<span class=\"number\">5</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__getitem__</span>(<span class=\"params\">self, index</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>._data[index], <span class=\"variable language_\">self</span>._label[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__len__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(<span class=\"variable language_\">self</span>._data)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">loader = RandomAccessDataset()</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>, <span class=\"string\">&quot;label&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data)</span><br><span class=\"line\">    </span><br><span class=\"line\">loader = [np.array(<span class=\"number\">0</span>), np.array(<span class=\"number\">1</span>), np.array(<span class=\"number\">2</span>)]</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,\r\n1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [\r\n0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])]</p>\r\n</blockquote>\r\n<p>创建的过程非常简单，通过numpy的数据结构为底层，实现三个方法就好了，更简单的直接使用list，tuple也是可行的。</p>\r\n<h4 id=\"可迭代数据集\">可迭代数据集</h4>\r\n<p>可迭代的数据集是实现了<code>__iter__</code>和<code>__next__</code>方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。</p>\r\n<p>例如，当使用<code>iter(dataset)</code>的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。</p>\r\n<p>下面构造一个简单迭代器，并将其加载至<code>GeneratorDataset</code>。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Iterator as input source</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IterableDataset</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, start, end</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;init the class object to hold the data&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.start = start</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.end = end</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;iter one data and return&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(<span class=\"variable language_\">self</span>.data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;reset the iter&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.data = <span class=\"built_in\">iter</span>(<span class=\"built_in\">range</span>(<span class=\"variable language_\">self</span>.start, <span class=\"variable language_\">self</span>.end))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">loader = IterableDataset(<span class=\"number\">1</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(d)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[], dtype=Int32, value= 1)] [Tensor(shape=[],\r\ndtype=Int32, value= 2)] [Tensor(shape=[], dtype=Int32, value= 3)]\r\n[Tensor(shape=[], dtype=Int32, value= 4)]</p>\r\n</blockquote>\r\n<p>同样的，实现方法即可</p>\r\n<h4 id=\"生成器\">生成器</h4>\r\n<p>生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型<code>generator</code>返回数据，直至生成器抛出<code>StopIteration</code>异常。</p>\r\n<p>下面构造一个生成器，并将其加载至<code>GeneratorDataset</code>。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Generator</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_generator</span>(<span class=\"params\">start, end</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(start, end):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># since a generator instance can be only iterated once, we need to wrap it by lambda to generate multiple instances</span></span><br><span class=\"line\">dataset = GeneratorDataset(source=<span class=\"keyword\">lambda</span>: my_generator(<span class=\"number\">3</span>, <span class=\"number\">6</span>), column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(d)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[], dtype=Int32, value= 3)] [Tensor(shape=[],\r\ndtype=Int32, value= 4)] [Tensor(shape=[], dtype=Int32, value= 5)]</p>\r\n</blockquote>\r\n<p>这个更绝，仅用一个函数即可生成。（此处匿不匿名无关紧要）</p>\r\n<h2 id=\"常见问题\">常见问题</h2>\r\n<ol type=\"1\">\r\n<li>找不到模块 matplotlib</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install matplotlib</span><br></pre></td></tr></table></figure>"},{"title":"MindSpore专题——第五章、网络构建","date":"2024-08-14T11:47:58.000Z","_content":"## 网格构建\n\n神经网络模型是由神经网络层和Tensor操作构成的，[mindspore.nn](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.nn.html)提供了常见神经网络层的实现，在MindSpore中，[Cell](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Cell.html)类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个`Cell`，它由不同的子`Cell`构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。\n\n下面我们将构建一个用于Mnist数据集分类的神经网络模型。\n\n<!--more-->\n\n### 定义模型类\n\n当我们定义神经网络时，可以继承`nn.Cell`类，在`__init__`方法中进行子Cell的实例化和状态管理，在`construct`方法中实现Tensor操作。\n\n```python\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512, weight_init=\"normal\", bias_init=\"zeros\"),\n            nn.ReLU(),\n            nn.Dense(512, 512, weight_init=\"normal\", bias_init=\"zeros\"),\n            nn.ReLU(),\n            nn.Dense(512, 10, weight_init=\"normal\", bias_init=\"zeros\")\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\n\nmodel = Network()\nprint(model)\n\n```\n\n> ```\n> Network<\n>   (flatten): Flatten<>\n>   (dense_relu_sequential): SequentialCell<\n>     (0): Dense<input_channels=784, output_channels=512, has_bias=True>\n>     (1): ReLU<>\n>     (2): Dense<input_channels=512, output_channels=512, has_bias=True>\n>     (3): ReLU<>\n>     (4): Dense<input_channels=512, output_channels=10, has_bias=True>\n>     >\n>   >\n> ```\n\n我们构造一个输入数据，直接调用模型，可以获得一个十维的Tensor输出，其包含每个类别的原始预测值。\n\n**`model.construct()`方法不可直接调用。**\n\n这里出现了很多很抽象的概念好像一下子让机器学习变成了一个黑盒子，实际上，我们观察上面的代码，很容易可以从中看出一些结构来，下面记录一下我这个初学者的理解。\n\n首先搬出一幅经典的图像\n\n![神经网络入门 - 阮一峰的网络日志](https://s2.loli.net/2024/06/07/n358NwDPeSg1LsZ.jpg)\n\n这幅图形象的描述了上面的过程。其中\n\n![image-20240607140358272](https://s2.loli.net/2024/06/07/KgVFjZ6LTY54r1s.png)\n\n这里开始的inputLayer就是我们的输入数据，中间连的密密麻麻的线就是上面结构输出中的Dense，可以观察到我们分别有$$784\\rightarrow 512\\rightarrow512\\rightarrow10$$​四层这样的全连接。最初的784也和28*28对应了起来。即我们每一个像素点都是一个参数，为最初输入的一个点，最后输出的则是代表数字概率的10个参数，最终我们会选择一个最接近的参数。这里的变量名用logits（不确定是否标准，但这里是这么用的）\n\n下面是一些展示调用的代码\n\n```python\nX = ops.ones((1, 28, 28), mindspore.float32)\nlogits = model(X)\n# print logits\n\nprint(Tensor(logits))\npred_probab = nn.Softmax(axis=1)(logits)\ny_pred = pred_probab.argmax(1)\nprint(f\"Predicted class: {y_pred}\")\n```\n\n读者可以试着运行几次，由于给出数据全是1，代表全黑或全白。因此输出是杂乱的。但可以观察到，我们最终的预测值为最大的值的标签。\n\n下面官网上给出了一些模型层次的解释，来看看。\n\n### 模型层\n\n>  本节中我们分解上节构造的神经网络模型中的每一层。首先我们构造一个shape为(3, 28, 28)的随机数据（3个28x28的图像），依次通过每一个神经网络层来观察其效果。\n\n```\ninput_image = ops.ones((3, 28, 28), mindspore.float32)\nprint(input_image.shape)\n```\n\n> (3, 28, 28)\n\n### nn.Flatten\n\n>  实例化[nn.Flatten](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Flatten.html)层，将28x28的2D张量转换为784大小的连续数组。\n\n```python\nflatten = nn.Flatten()\nflat_image = flatten(input_image)\nprint(flat_image.shape)\n```\n\n> ```\n> (3, 784)\n> ```\n\n这里可见flatten打平只是打平第一维以外即输入数据样例外的维度，如果说初始数据是一个结构体数组，那Flatten的作用就是将其变为一个一维数组的数组。\n\n### nn.Dense\n\n> [nn.Dense](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Dense.html)为全连接层，其使用权重和偏差对输入进行线性变换。\n\n```\nlayer1 = nn.Dense(in_channels=28*28, out_channels=20)\nhidden1 = layer1(flat_image)\nprint(hidden1.shape)\n```\n\n> ```\n> (3, 20)\n> ```\n\n这里注意到有两个额外的参数即权重和偏差。也就是说下面每一层的节点就是上一层节点的带权和加上一个常数。\n\n### nn.ReLU\n\n>  [nn.ReLU](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.ReLU.html)层给网络中加入非线性的激活函数，帮助神经网络学习各种复杂的特征。\n\n```python\nprint(f\"Before ReLU: {hidden1}\\n\\n\")\nhidden1 = nn.ReLU()(hidden1)\nprint(f\"After ReLU: {hidden1}\")\n```\n\n> ```\n> Before ReLU: [[-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]\n>  [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]\n>  [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]]\n> \n> \n> After ReLU: [[0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]\n>  [0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]\n>  [0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]]\n> ```\n\n注意到，这里首次提出非线性运算的概念，也就是说，在这之前，运算都是线性的，这一步显然比较复杂，也不谈论。\n\n### nn.SequentialCell\n\n> [nn.SequentialCell](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.SequentialCell.html)是一个有序的Cell容器。输入Tensor将按照定义的顺序通过所有Cell。我们可以使用`SequentialCell`来快速组合构造一个神经网络模型。\n\n```python\nseq_modules = nn.SequentialCell(\n    flatten,\n    layer1,\n    nn.ReLU(),\n    nn.Dense(20, 10)\n)\n\nlogits = seq_modules(input_image)\nprint(logits.shape)\n```\n\n> ```\n> (3, 10)\n> ```\n\n注意看代码，对于这里的代码最好都不要跳过，也不要深究实现原理（新手），可见这里依次调用了上面的所有步骤，是对这一流程的封装。\n\n### nn.Softmax\n\n>  最后使用[nn.Softmax](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Softmax.html)将神经网络最后一个全连接层返回的logits的值缩放为[0, 1]，表示每个类别的预测概率。`axis`指定的维度数值和为1。\n\n```\nsoftmax = nn.Softmax(axis=1)\npred_probab = softmax(logits)\n```\n\n官网文档已经非常清楚了。还有不懂可以跑跑代码\n\n## 模型参数\n\n> 网络内部神经网络层具有权重参数和偏置参数（如`nn.Dense`），这些参数会在训练过程中不断进行优化，可通过 `model.parameters_and_names()` 来获取参数名及对应的参数详情。\n\n```python\nprint(f\"Model structure: {model}\\n\\n\")\n\nfor name, param in model.parameters_and_names():\n    print(f\"Layer: {name}\\nSize: {param.shape}\\nValues : {param[:2]} \\n\")\n```\n\n通过这一代码可以查看权重参数和偏置参数，这一代码应该是十分常见并且常用的。","source":"_posts/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork.md","raw":"---\ntitle: MindSpore专题——第五章、网络构建\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## 网格构建\n\n神经网络模型是由神经网络层和Tensor操作构成的，[mindspore.nn](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.nn.html)提供了常见神经网络层的实现，在MindSpore中，[Cell](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Cell.html)类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个`Cell`，它由不同的子`Cell`构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。\n\n下面我们将构建一个用于Mnist数据集分类的神经网络模型。\n\n<!--more-->\n\n### 定义模型类\n\n当我们定义神经网络时，可以继承`nn.Cell`类，在`__init__`方法中进行子Cell的实例化和状态管理，在`construct`方法中实现Tensor操作。\n\n```python\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512, weight_init=\"normal\", bias_init=\"zeros\"),\n            nn.ReLU(),\n            nn.Dense(512, 512, weight_init=\"normal\", bias_init=\"zeros\"),\n            nn.ReLU(),\n            nn.Dense(512, 10, weight_init=\"normal\", bias_init=\"zeros\")\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\n\nmodel = Network()\nprint(model)\n\n```\n\n> ```\n> Network<\n>   (flatten): Flatten<>\n>   (dense_relu_sequential): SequentialCell<\n>     (0): Dense<input_channels=784, output_channels=512, has_bias=True>\n>     (1): ReLU<>\n>     (2): Dense<input_channels=512, output_channels=512, has_bias=True>\n>     (3): ReLU<>\n>     (4): Dense<input_channels=512, output_channels=10, has_bias=True>\n>     >\n>   >\n> ```\n\n我们构造一个输入数据，直接调用模型，可以获得一个十维的Tensor输出，其包含每个类别的原始预测值。\n\n**`model.construct()`方法不可直接调用。**\n\n这里出现了很多很抽象的概念好像一下子让机器学习变成了一个黑盒子，实际上，我们观察上面的代码，很容易可以从中看出一些结构来，下面记录一下我这个初学者的理解。\n\n首先搬出一幅经典的图像\n\n![神经网络入门 - 阮一峰的网络日志](https://s2.loli.net/2024/06/07/n358NwDPeSg1LsZ.jpg)\n\n这幅图形象的描述了上面的过程。其中\n\n![image-20240607140358272](https://s2.loli.net/2024/06/07/KgVFjZ6LTY54r1s.png)\n\n这里开始的inputLayer就是我们的输入数据，中间连的密密麻麻的线就是上面结构输出中的Dense，可以观察到我们分别有$$784\\rightarrow 512\\rightarrow512\\rightarrow10$$​四层这样的全连接。最初的784也和28*28对应了起来。即我们每一个像素点都是一个参数，为最初输入的一个点，最后输出的则是代表数字概率的10个参数，最终我们会选择一个最接近的参数。这里的变量名用logits（不确定是否标准，但这里是这么用的）\n\n下面是一些展示调用的代码\n\n```python\nX = ops.ones((1, 28, 28), mindspore.float32)\nlogits = model(X)\n# print logits\n\nprint(Tensor(logits))\npred_probab = nn.Softmax(axis=1)(logits)\ny_pred = pred_probab.argmax(1)\nprint(f\"Predicted class: {y_pred}\")\n```\n\n读者可以试着运行几次，由于给出数据全是1，代表全黑或全白。因此输出是杂乱的。但可以观察到，我们最终的预测值为最大的值的标签。\n\n下面官网上给出了一些模型层次的解释，来看看。\n\n### 模型层\n\n>  本节中我们分解上节构造的神经网络模型中的每一层。首先我们构造一个shape为(3, 28, 28)的随机数据（3个28x28的图像），依次通过每一个神经网络层来观察其效果。\n\n```\ninput_image = ops.ones((3, 28, 28), mindspore.float32)\nprint(input_image.shape)\n```\n\n> (3, 28, 28)\n\n### nn.Flatten\n\n>  实例化[nn.Flatten](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Flatten.html)层，将28x28的2D张量转换为784大小的连续数组。\n\n```python\nflatten = nn.Flatten()\nflat_image = flatten(input_image)\nprint(flat_image.shape)\n```\n\n> ```\n> (3, 784)\n> ```\n\n这里可见flatten打平只是打平第一维以外即输入数据样例外的维度，如果说初始数据是一个结构体数组，那Flatten的作用就是将其变为一个一维数组的数组。\n\n### nn.Dense\n\n> [nn.Dense](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Dense.html)为全连接层，其使用权重和偏差对输入进行线性变换。\n\n```\nlayer1 = nn.Dense(in_channels=28*28, out_channels=20)\nhidden1 = layer1(flat_image)\nprint(hidden1.shape)\n```\n\n> ```\n> (3, 20)\n> ```\n\n这里注意到有两个额外的参数即权重和偏差。也就是说下面每一层的节点就是上一层节点的带权和加上一个常数。\n\n### nn.ReLU\n\n>  [nn.ReLU](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.ReLU.html)层给网络中加入非线性的激活函数，帮助神经网络学习各种复杂的特征。\n\n```python\nprint(f\"Before ReLU: {hidden1}\\n\\n\")\nhidden1 = nn.ReLU()(hidden1)\nprint(f\"After ReLU: {hidden1}\")\n```\n\n> ```\n> Before ReLU: [[-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]\n>  [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]\n>  [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]]\n> \n> \n> After ReLU: [[0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]\n>  [0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]\n>  [0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]]\n> ```\n\n注意到，这里首次提出非线性运算的概念，也就是说，在这之前，运算都是线性的，这一步显然比较复杂，也不谈论。\n\n### nn.SequentialCell\n\n> [nn.SequentialCell](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.SequentialCell.html)是一个有序的Cell容器。输入Tensor将按照定义的顺序通过所有Cell。我们可以使用`SequentialCell`来快速组合构造一个神经网络模型。\n\n```python\nseq_modules = nn.SequentialCell(\n    flatten,\n    layer1,\n    nn.ReLU(),\n    nn.Dense(20, 10)\n)\n\nlogits = seq_modules(input_image)\nprint(logits.shape)\n```\n\n> ```\n> (3, 10)\n> ```\n\n注意看代码，对于这里的代码最好都不要跳过，也不要深究实现原理（新手），可见这里依次调用了上面的所有步骤，是对这一流程的封装。\n\n### nn.Softmax\n\n>  最后使用[nn.Softmax](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Softmax.html)将神经网络最后一个全连接层返回的logits的值缩放为[0, 1]，表示每个类别的预测概率。`axis`指定的维度数值和为1。\n\n```\nsoftmax = nn.Softmax(axis=1)\npred_probab = softmax(logits)\n```\n\n官网文档已经非常清楚了。还有不懂可以跑跑代码\n\n## 模型参数\n\n> 网络内部神经网络层具有权重参数和偏置参数（如`nn.Dense`），这些参数会在训练过程中不断进行优化，可通过 `model.parameters_and_names()` 来获取参数名及对应的参数详情。\n\n```python\nprint(f\"Model structure: {model}\\n\\n\")\n\nfor name, param in model.parameters_and_names():\n    print(f\"Layer: {name}\\nSize: {param.shape}\\nValues : {param[:2]} \\n\")\n```\n\n通过这一代码可以查看权重参数和偏置参数，这一代码应该是十分常见并且常用的。","slug":"special_subject/MindSpore/Chapters/Fivth_ConstructNetwork","published":1,"updated":"2024-08-16T08:58:53.357Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjbi00a4lowvb2dga8e8","content":"<h2 id=\"网格构建\">网格构建</h2>\r\n<p>神经网络模型是由神经网络层和Tensor操作构成的，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5ubi5odG1s\">mindspore.nn<i class=\"fa fa-external-link-alt\"></i></span>提供了常见神经网络层的实现，在MindSpore中，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5DZWxsLmh0bWw=\">Cell<i class=\"fa fa-external-link-alt\"></i></span>类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个<code>Cell</code>，它由不同的子<code>Cell</code>构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。</p>\r\n<p>下面我们将构建一个用于Mnist数据集分类的神经网络模型。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"定义模型类\">定义模型类</h3>\r\n<p>当我们定义神经网络时，可以继承<code>nn.Cell</code>类，在<code>__init__</code>方法中进行子Cell的实例化和状态管理，在<code>construct</code>方法中实现Tensor操作。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Network&lt;</span><br><span class=\"line\">  (flatten): Flatten&lt;&gt;</span><br><span class=\"line\">  (dense_relu_sequential): SequentialCell&lt;</span><br><span class=\"line\">    (0): Dense&lt;input_channels=784, output_channels=512, has_bias=True&gt;</span><br><span class=\"line\">    (1): ReLU&lt;&gt;</span><br><span class=\"line\">    (2): Dense&lt;input_channels=512, output_channels=512, has_bias=True&gt;</span><br><span class=\"line\">    (3): ReLU&lt;&gt;</span><br><span class=\"line\">    (4): Dense&lt;input_channels=512, output_channels=10, has_bias=True&gt;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">  &gt;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>我们构造一个输入数据，直接调用模型，可以获得一个十维的Tensor输出，其包含每个类别的原始预测值。</p>\r\n<p><strong><code>model.construct()</code>方法不可直接调用。</strong></p>\r\n<p>这里出现了很多很抽象的概念好像一下子让机器学习变成了一个黑盒子，实际上，我们观察上面的代码，很容易可以从中看出一些结构来，下面记录一下我这个初学者的理解。</p>\r\n<p>首先搬出一幅经典的图像</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/n358NwDPeSg1LsZ.jpg\"\r\nalt=\"神经网络入门 - 阮一峰的网络日志\" />\r\n<figcaption aria-hidden=\"true\">神经网络入门 -\r\n阮一峰的网络日志</figcaption>\r\n</figure>\r\n<p>这幅图形象的描述了上面的过程。其中</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/KgVFjZ6LTY54r1s.png\"\r\nalt=\"image-20240607140358272\" />\r\n<figcaption aria-hidden=\"true\">image-20240607140358272</figcaption>\r\n</figure>\r\n<p>这里开始的inputLayer就是我们的输入数据，中间连的密密麻麻的线就是上面结构输出中的Dense，可以观察到我们分别有<span\r\nclass=\"math display\">\\[784\\rightarrow\r\n512\\rightarrow512\\rightarrow10\\]</span>​四层这样的全连接。最初的784也和28*28对应了起来。即我们每一个像素点都是一个参数，为最初输入的一个点，最后输出的则是代表数字概率的10个参数，最终我们会选择一个最接近的参数。这里的变量名用logits（不确定是否标准，但这里是这么用的）</p>\r\n<p>下面是一些展示调用的代码</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X = ops.ones((<span class=\"number\">1</span>, <span class=\"number\">28</span>, <span class=\"number\">28</span>), mindspore.float32)</span><br><span class=\"line\">logits = model(X)</span><br><span class=\"line\"><span class=\"comment\"># print logits</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(Tensor(logits))</span><br><span class=\"line\">pred_probab = nn.Softmax(axis=<span class=\"number\">1</span>)(logits)</span><br><span class=\"line\">y_pred = pred_probab.argmax(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Predicted class: <span class=\"subst\">&#123;y_pred&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>读者可以试着运行几次，由于给出数据全是1，代表全黑或全白。因此输出是杂乱的。但可以观察到，我们最终的预测值为最大的值的标签。</p>\r\n<p>下面官网上给出了一些模型层次的解释，来看看。</p>\r\n<h3 id=\"模型层\">模型层</h3>\r\n<blockquote>\r\n<p>本节中我们分解上节构造的神经网络模型中的每一层。首先我们构造一个shape为(3,\r\n28,\r\n28)的随机数据（3个28x28的图像），依次通过每一个神经网络层来观察其效果。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_image = ops.ones((3, 28, 28), mindspore.float32)</span><br><span class=\"line\">print(input_image.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>(3, 28, 28)</p>\r\n</blockquote>\r\n<h3 id=\"nn.flatten\">nn.Flatten</h3>\r\n<blockquote>\r\n<p>实例化<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5GbGF0dGVuLmh0bWw=\">nn.Flatten<i class=\"fa fa-external-link-alt\"></i></span>层，将28x28的2D张量转换为784大小的连续数组。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flatten = nn.Flatten()</span><br><span class=\"line\">flat_image = flatten(input_image)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(flat_image.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 784)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>这里可见flatten打平只是打平第一维以外即输入数据样例外的维度，如果说初始数据是一个结构体数组，那Flatten的作用就是将其变为一个一维数组的数组。</p>\r\n<h3 id=\"nn.dense\">nn.Dense</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5EZW5zZS5odG1s\">nn.Dense<i class=\"fa fa-external-link-alt\"></i></span>为全连接层，其使用权重和偏差对输入进行线性变换。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layer1 = nn.Dense(in_channels=28*28, out_channels=20)</span><br><span class=\"line\">hidden1 = layer1(flat_image)</span><br><span class=\"line\">print(hidden1.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 20)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>这里注意到有两个额外的参数即权重和偏差。也就是说下面每一层的节点就是上一层节点的带权和加上一个常数。</p>\r\n<h3 id=\"nn.relu\">nn.ReLU</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5SZUxVLmh0bWw=\">nn.ReLU<i class=\"fa fa-external-link-alt\"></i></span>层给网络中加入非线性的激活函数，帮助神经网络学习各种复杂的特征。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Before ReLU: <span class=\"subst\">&#123;hidden1&#125;</span>\\n\\n&quot;</span>)</span><br><span class=\"line\">hidden1 = nn.ReLU()(hidden1)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;After ReLU: <span class=\"subst\">&#123;hidden1&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before ReLU: [[-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]</span><br><span class=\"line\"> [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]</span><br><span class=\"line\"> [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">After ReLU: [[0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]</span><br><span class=\"line\"> [0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]</span><br><span class=\"line\"> [0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]]</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>注意到，这里首次提出非线性运算的概念，也就是说，在这之前，运算都是线性的，这一步显然比较复杂，也不谈论。</p>\r\n<h3 id=\"nn.sequentialcell\">nn.SequentialCell</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5TZXF1ZW50aWFsQ2VsbC5odG1s\">nn.SequentialCell<i class=\"fa fa-external-link-alt\"></i></span>是一个有序的Cell容器。输入Tensor将按照定义的顺序通过所有Cell。我们可以使用<code>SequentialCell</code>来快速组合构造一个神经网络模型。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seq_modules = nn.SequentialCell(</span><br><span class=\"line\">    flatten,</span><br><span class=\"line\">    layer1,</span><br><span class=\"line\">    nn.ReLU(),</span><br><span class=\"line\">    nn.Dense(<span class=\"number\">20</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">logits = seq_modules(input_image)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logits.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 10)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>注意看代码，对于这里的代码最好都不要跳过，也不要深究实现原理（新手），可见这里依次调用了上面的所有步骤，是对这一流程的封装。</p>\r\n<h3 id=\"nn.softmax\">nn.Softmax</h3>\r\n<blockquote>\r\n<p>最后使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5Tb2Z0bWF4Lmh0bWw=\">nn.Softmax<i class=\"fa fa-external-link-alt\"></i></span>将神经网络最后一个全连接层返回的logits的值缩放为[0,\r\n1]，表示每个类别的预测概率。<code>axis</code>指定的维度数值和为1。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">softmax = nn.Softmax(axis=1)</span><br><span class=\"line\">pred_probab = softmax(logits)</span><br></pre></td></tr></table></figure>\r\n<p>官网文档已经非常清楚了。还有不懂可以跑跑代码</p>\r\n<h2 id=\"模型参数\">模型参数</h2>\r\n<blockquote>\r\n<p>网络内部神经网络层具有权重参数和偏置参数（如<code>nn.Dense</code>），这些参数会在训练过程中不断进行优化，可通过\r\n<code>model.parameters_and_names()</code>\r\n来获取参数名及对应的参数详情。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Model structure: <span class=\"subst\">&#123;model&#125;</span>\\n\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> name, param <span class=\"keyword\">in</span> model.parameters_and_names():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Layer: <span class=\"subst\">&#123;name&#125;</span>\\nSize: <span class=\"subst\">&#123;param.shape&#125;</span>\\nValues : <span class=\"subst\">&#123;param[:<span class=\"number\">2</span>]&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>通过这一代码可以查看权重参数和偏置参数，这一代码应该是十分常见并且常用的。</p>\r\n","length":1514,"excerpt":"<h2 id=\"网格构建\">网格构建</h2>\r\n<p>神经网络模型是由神经网络层和Tensor操作构成的，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5ubi5odG1s\">mindspore.nn<i class=\"fa fa-external-link-alt\"></i></span>提供了常见神经网络层的实现，在MindSpore中，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5DZWxsLmh0bWw=\">Cell<i class=\"fa fa-external-link-alt\"></i></span>类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个<code>Cell</code>，它由不同的子<code>Cell</code>构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。</p>\r\n<p>下面我们将构建一个用于Mnist数据集分类的神经网络模型。</p>","more":"<h3 id=\"定义模型类\">定义模型类</h3>\r\n<p>当我们定义神经网络时，可以继承<code>nn.Cell</code>类，在<code>__init__</code>方法中进行子Cell的实例化和状态管理，在<code>construct</code>方法中实现Tensor操作。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Network&lt;</span><br><span class=\"line\">  (flatten): Flatten&lt;&gt;</span><br><span class=\"line\">  (dense_relu_sequential): SequentialCell&lt;</span><br><span class=\"line\">    (0): Dense&lt;input_channels=784, output_channels=512, has_bias=True&gt;</span><br><span class=\"line\">    (1): ReLU&lt;&gt;</span><br><span class=\"line\">    (2): Dense&lt;input_channels=512, output_channels=512, has_bias=True&gt;</span><br><span class=\"line\">    (3): ReLU&lt;&gt;</span><br><span class=\"line\">    (4): Dense&lt;input_channels=512, output_channels=10, has_bias=True&gt;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">  &gt;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>我们构造一个输入数据，直接调用模型，可以获得一个十维的Tensor输出，其包含每个类别的原始预测值。</p>\r\n<p><strong><code>model.construct()</code>方法不可直接调用。</strong></p>\r\n<p>这里出现了很多很抽象的概念好像一下子让机器学习变成了一个黑盒子，实际上，我们观察上面的代码，很容易可以从中看出一些结构来，下面记录一下我这个初学者的理解。</p>\r\n<p>首先搬出一幅经典的图像</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/n358NwDPeSg1LsZ.jpg\"\r\nalt=\"神经网络入门 - 阮一峰的网络日志\" />\r\n<figcaption aria-hidden=\"true\">神经网络入门 -\r\n阮一峰的网络日志</figcaption>\r\n</figure>\r\n<p>这幅图形象的描述了上面的过程。其中</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/KgVFjZ6LTY54r1s.png\"\r\nalt=\"image-20240607140358272\" />\r\n<figcaption aria-hidden=\"true\">image-20240607140358272</figcaption>\r\n</figure>\r\n<p>这里开始的inputLayer就是我们的输入数据，中间连的密密麻麻的线就是上面结构输出中的Dense，可以观察到我们分别有<span\r\nclass=\"math display\">\\[784\\rightarrow\r\n512\\rightarrow512\\rightarrow10\\]</span>​四层这样的全连接。最初的784也和28*28对应了起来。即我们每一个像素点都是一个参数，为最初输入的一个点，最后输出的则是代表数字概率的10个参数，最终我们会选择一个最接近的参数。这里的变量名用logits（不确定是否标准，但这里是这么用的）</p>\r\n<p>下面是一些展示调用的代码</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X = ops.ones((<span class=\"number\">1</span>, <span class=\"number\">28</span>, <span class=\"number\">28</span>), mindspore.float32)</span><br><span class=\"line\">logits = model(X)</span><br><span class=\"line\"><span class=\"comment\"># print logits</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(Tensor(logits))</span><br><span class=\"line\">pred_probab = nn.Softmax(axis=<span class=\"number\">1</span>)(logits)</span><br><span class=\"line\">y_pred = pred_probab.argmax(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Predicted class: <span class=\"subst\">&#123;y_pred&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>读者可以试着运行几次，由于给出数据全是1，代表全黑或全白。因此输出是杂乱的。但可以观察到，我们最终的预测值为最大的值的标签。</p>\r\n<p>下面官网上给出了一些模型层次的解释，来看看。</p>\r\n<h3 id=\"模型层\">模型层</h3>\r\n<blockquote>\r\n<p>本节中我们分解上节构造的神经网络模型中的每一层。首先我们构造一个shape为(3,\r\n28,\r\n28)的随机数据（3个28x28的图像），依次通过每一个神经网络层来观察其效果。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_image = ops.ones((3, 28, 28), mindspore.float32)</span><br><span class=\"line\">print(input_image.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>(3, 28, 28)</p>\r\n</blockquote>\r\n<h3 id=\"nn.flatten\">nn.Flatten</h3>\r\n<blockquote>\r\n<p>实例化<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5GbGF0dGVuLmh0bWw=\">nn.Flatten<i class=\"fa fa-external-link-alt\"></i></span>层，将28x28的2D张量转换为784大小的连续数组。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flatten = nn.Flatten()</span><br><span class=\"line\">flat_image = flatten(input_image)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(flat_image.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 784)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>这里可见flatten打平只是打平第一维以外即输入数据样例外的维度，如果说初始数据是一个结构体数组，那Flatten的作用就是将其变为一个一维数组的数组。</p>\r\n<h3 id=\"nn.dense\">nn.Dense</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5EZW5zZS5odG1s\">nn.Dense<i class=\"fa fa-external-link-alt\"></i></span>为全连接层，其使用权重和偏差对输入进行线性变换。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layer1 = nn.Dense(in_channels=28*28, out_channels=20)</span><br><span class=\"line\">hidden1 = layer1(flat_image)</span><br><span class=\"line\">print(hidden1.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 20)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>这里注意到有两个额外的参数即权重和偏差。也就是说下面每一层的节点就是上一层节点的带权和加上一个常数。</p>\r\n<h3 id=\"nn.relu\">nn.ReLU</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5SZUxVLmh0bWw=\">nn.ReLU<i class=\"fa fa-external-link-alt\"></i></span>层给网络中加入非线性的激活函数，帮助神经网络学习各种复杂的特征。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Before ReLU: <span class=\"subst\">&#123;hidden1&#125;</span>\\n\\n&quot;</span>)</span><br><span class=\"line\">hidden1 = nn.ReLU()(hidden1)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;After ReLU: <span class=\"subst\">&#123;hidden1&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before ReLU: [[-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]</span><br><span class=\"line\"> [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]</span><br><span class=\"line\"> [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">After ReLU: [[0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]</span><br><span class=\"line\"> [0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]</span><br><span class=\"line\"> [0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]]</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>注意到，这里首次提出非线性运算的概念，也就是说，在这之前，运算都是线性的，这一步显然比较复杂，也不谈论。</p>\r\n<h3 id=\"nn.sequentialcell\">nn.SequentialCell</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5TZXF1ZW50aWFsQ2VsbC5odG1s\">nn.SequentialCell<i class=\"fa fa-external-link-alt\"></i></span>是一个有序的Cell容器。输入Tensor将按照定义的顺序通过所有Cell。我们可以使用<code>SequentialCell</code>来快速组合构造一个神经网络模型。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seq_modules = nn.SequentialCell(</span><br><span class=\"line\">    flatten,</span><br><span class=\"line\">    layer1,</span><br><span class=\"line\">    nn.ReLU(),</span><br><span class=\"line\">    nn.Dense(<span class=\"number\">20</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">logits = seq_modules(input_image)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logits.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 10)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>注意看代码，对于这里的代码最好都不要跳过，也不要深究实现原理（新手），可见这里依次调用了上面的所有步骤，是对这一流程的封装。</p>\r\n<h3 id=\"nn.softmax\">nn.Softmax</h3>\r\n<blockquote>\r\n<p>最后使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5Tb2Z0bWF4Lmh0bWw=\">nn.Softmax<i class=\"fa fa-external-link-alt\"></i></span>将神经网络最后一个全连接层返回的logits的值缩放为[0,\r\n1]，表示每个类别的预测概率。<code>axis</code>指定的维度数值和为1。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">softmax = nn.Softmax(axis=1)</span><br><span class=\"line\">pred_probab = softmax(logits)</span><br></pre></td></tr></table></figure>\r\n<p>官网文档已经非常清楚了。还有不懂可以跑跑代码</p>\r\n<h2 id=\"模型参数\">模型参数</h2>\r\n<blockquote>\r\n<p>网络内部神经网络层具有权重参数和偏置参数（如<code>nn.Dense</code>），这些参数会在训练过程中不断进行优化，可通过\r\n<code>model.parameters_and_names()</code>\r\n来获取参数名及对应的参数详情。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Model structure: <span class=\"subst\">&#123;model&#125;</span>\\n\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> name, param <span class=\"keyword\">in</span> model.parameters_and_names():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Layer: <span class=\"subst\">&#123;name&#125;</span>\\nSize: <span class=\"subst\">&#123;param.shape&#125;</span>\\nValues : <span class=\"subst\">&#123;param[:<span class=\"number\">2</span>]&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>通过这一代码可以查看权重参数和偏置参数，这一代码应该是十分常见并且常用的。</p>"},{"title":"MindSpore专题——第六章——函数式微分","date":"2024-08-14T11:47:58.000Z","_content":"## 函数式自动微分\n\n> 神经网络的训练主要使用反向传播算法，模型预测值（logits）与正确标签（label）送入损失函数（loss function）获得loss，然后进行反向传播计算，求得梯度（gradients），最终更新至模型参数（parameters）。自动微分能够计算可导函数在某点处的导数值，是反向传播算法的一般化。自动微分主要解决的问题是将一个复杂的数学运算分解为一系列简单的基本运算，该功能对用户屏蔽了大量的求导细节和过程，大大降低了框架的使用门槛。\n\n<!--more-->\n\n> MindSpore使用函数式自动微分的设计理念，提供更接近于数学语义的自动微分接口`grad`和`value_and_grad`。下面我们使用一个简单的单层线性变换模型进行介绍。\n\n这里总算是提到了反向传播，最近我看到了一系列视频有关Machine Learning，传送门如下：\n\n[🔴 World of Warships / USS Des Moines cut (youtube.com)](https://www.youtube.com/watch?v=Ilg3gGewQ5U)\n\n如果你试图看下去的话，可能会发现，事情好像突然变难了，似乎一群从未见过的知识组合在了一起，神经网络就像一个黑箱连着另一个黑箱，而你根本不知道如何优化它，使得黑箱在给定的输入下输出正确答案\n\n## 神经网络到底代表了什么\n\n首先让我们定义什么是神经：他是一个携带一个浮点数的结构，然后让我们看向神经网络\n\n![R](https://s2.loli.net/2024/06/07/MLN1Ap2wslU4SQB.jpg)\n\n对于每一个点，我们从最后看起，显然，他们代表0-9，更准确的说，他们代表0-9的图像。为什么这样的网络是生效的呢？\n\n***因为分形思想***，我们将一段连续的图像区分为一段一段，比如9是⚪在上而线条在下。4由多端线段1组成。而⚪和线条又可以继续再分，我们可以将神经网络中的每一个节点代表的数据想象成这种规律图案的集合。他们之间的传递就是图案在网络中不断组合。这也是为什么在网络中使用全连接的原因，因为每一个图案都能与其他任何图案组合。最终我们使图案变成了不断分形像素的组合。\n\n但如何做到这一点呢？ 考虑我们前面提到的参数，权值。\n\n![image-20240607181215798](./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240607181215798.png)\n\n这张图相信有很多人见过类似的图，实际上权值代表的就是神经网络之间的连线，假设我们让正权值在下表中为绿负权值在下表中为红，我们将这样描述一条“线段”：一段由红色包围的长条状绿色区域这样我们就能得出，如果这段线条是成立得话，比如确实原图这里存在一条线段，我们得到的这个神经节点上得值就会很接近1，否则就会很接近零。这就是权值得意义。但同时，我们会注意到神经得值是许多这样计算的累和，因此我们需要一个bias，偏差值将其计算到到0-1。\n\n注意这里得权值和偏差值均是变量，是训练出来的。并且注意，我们并不知道机器是如何分形得，这取决于学习数据和使用的算法，以上只为举例理解。\n\n如果将最初得神经网络拿去使用，你只会得到一大堆垃圾数据。我们都知道神经网络存在“进化”过程，但他是如何知道自己错得有多离谱的呢？\n\n## Cost Function（Maybe also loss function?）\n\n初略的定义是他是输出的张量与正确的张量的差值平方和，比如，机器输出了一个全是0.5的10个数的张量，而正确答案是其中之一，那么\n$$\n\\text{Cost} = (1-0.5) + 0.5*9\n$$\n显然这个数字更接近0，说明结果更加准确\n\n考虑如何让模型表现得更好，显然是需要找到一组参数，使得每次输出的cost值最小。我们可以考虑这样一种方式，以参数作为输入，cost的值作为输出，而训练数据则是参数。\n\n### 梯度下降 (Gradient Descent)\n\n似乎难以理解，假设我们只有一个参数cost=f(c)，c是唯一的参数。于是变为了函数的最值问题，只需要求导数然后慢慢移动我们的初始点。很显然，一个函数在常数域上可能存在多个极大值而只有一个最大值。当我们从一个点出发寻找最大值时，很有可能（概率学上讲应该是绝对）我们只会找到一个极大值。即在神经网络中，我们不能保证我们的参数是最优的，只能保证我们的参数是局部最优的（这取决于我们的起始点）。\n\n变到多维，我们意识到，一个数的导数是否只有正或负两种信息有效（代表是应该增加这个数还是减少这个数）。假定两个变量在一个点上的导数其中一个是另一个的三倍，这至少说明在该点的邻域内，这一变量应该减少的更多是正确的。（可能有一些函数存在极端的尖点导致错误，但这在神经网络中是低概率的，掌控好更改数据的大小即可）。\n\n一个简单的例子是，维护好一个$$\\nabla C$$矩阵，一阶导数对应的值高则其增加，反之则减少。\n\n## 反向传播\n\n从特殊到一般，我们先观察这样一个样例\n\n![image-20240607205110764](https://s2.loli.net/2024/06/07/SJ5Rf7m6cXFs8yN.png)\n\n显然我们需要增加2，并且如果给我们要做的事情做出一个排序，增加2显然排在减少8之前。\n\n因此，让我们继续看增加2所涉及的值\n\n1. 更改偏差值\n2. 更改权值（根据节点值）\n3. 更改上一层节点的值（根据权值）\n\n我们对权值和边权同时改变，并统计下一层节点需要的变化对上一层的节点影响的累和\n\n通过多组数据得出权值的总共改变值改变值。这就是随机梯度下降（Stochastic gradient descent）\n\n下面简单讲一讲其他的名词解释\n\n## Mini-batches\n\n和他的名字一样，这个技术就是将训练数据分为几组以提高收敛参数的效率\n\n## Backpropagation\n\n反向传播是一种梯度下降法的应用，通过链式法则计算损失函数相对于每个权重的梯度，然后利用这些梯度来更新权重。\n\n## 函数与计算图\n\n![compute-graph](https://s2.loli.net/2024/06/07/iqHnjI12DSKR6P7.png)\n\n> 计算图是用图论语言表示数学函数的一种方式，也是深度学习框架表达神经网络模型的统一方法。我们将根据下面的计算图构造计算函数和神经网络。\n\n> 在这个模型中，𝑥为输入，𝑦为正确值，𝑤和𝑏是我们需要优化的参数。\n\n1. 𝑥为输入\n2. 𝑦为正确值\n3. 𝑤和𝑏是我们需要优化的参数\n\n即对应了原始数据，输出结果，权重和偏差\n\n```python\nx = ops.ones(5, mindspore.float32)  # input tensor\ny = ops.zeros(3, mindspore.float32)  # expected output\nw = Parameter(Tensor(np.random.randn(5, 3), mindspore.float32), name='w') # weight\nb = Parameter(Tensor(np.random.randn(3,), mindspore.float32), name='b') # bias\n```\n\n> 我们根据计算图描述的计算过程，构造计算函数。 其中，[binary_cross_entropy_with_logits](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.binary_cross_entropy_with_logits.html) 是一个损失函数，计算预测值和目标值之间的二值交叉熵损失。\n\n解释一下Parameter(): **Parameter** 是 Tensor 的子类，当它们被绑定为Cell的属性时，会自动添加到其参数列表中，并且可以通过Cell的某些方法获取，例如 cell.get_**parameter**s() 。\n\n```python\ndef function(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss\n\nloss = function(x, y, w, b)\nprint(loss)\n```\n\n这里有复杂概念[*二值交叉熵损失*](#二值交叉熵损失)，如果你不想深究只需要这是一个对参数的函数，当这个函数值最低时，整体参数就是一个准确率较高的局部最优解即可。\n\n## 微分函数与梯度计算\n\n>  为了优化模型参数，需要求参数对loss的导数：$$\\frac{𝜕loss}{𝜕𝑤}$$和$$\\frac{𝜕loss}{𝜕𝑏}$$，此时我们调用`mindspore.grad`函数，来获得`function`的微分函数。\n\n> 这里使用了`grad`函数的两个入参，分别为：\n>\n> - `fn`：待求导的函数。\n> - `grad_position`：指定求导输入位置的索引。\n\n> 由于我们对$$𝑤$$和$$𝑏$$​求导，因此配置其在`function`入参对应的位置`(2, 3)`。\n\n> *使用`grad`获得微分函数是一种函数变换，即输入为函数，输出也为函数。*\n\n```python\ngrad_fn = mindspore.grad(function, (2, 3))\n\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n```\n\n> ```\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]]), Tensor(shape=[3], dtype=Float32, value= [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]))\n> ```\n\n执行微分函数，即可获得$$𝑤$$、$$𝑏$$​对应的梯度。可以注意到w,b的梯度与最初始的梯度是一致的。\n\n### Stop Gradient\n\n> 通常情况下，求导时会求loss对参数的导数，因此函数的输出只有loss一项。**当我们希望函数输出多项时，微分函数会求所有输出项对参数的导数**。此时如果想实现对某个输出项的梯度截断，或消除某个Tensor对梯度的影响，需要用到Stop Gradient操作。\n\n> 这里我们将`function`改为同时输出loss和z的`function_with_logits`，获得微分函数并执行。\n\n```python\ndef function_with_logits(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss, z\n\ngrad_fn = mindspore.grad(function_with_logits, (2, 3))\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n```\n\n```python\ndef function_stop_gradient(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss, ops.stop_gradient(z)\n\ngrad_fn = mindspore.grad(function_stop_gradient, (2, 3))\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n\n```\n\n`ops.stop_gradient(z)`:重点在该函数，表示屏蔽了z对梯度的影响，即仍只求参数对loss的导数。\n\n这里解释一下一些api的含义\n\n```python\nmindspore.grad(fn, grad_position=0, weights=None, has_aux=False, return_ids=False)\n```\n\n- [MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.grad.html?highlight=grad#mindspore.grad)\n\n```\nmindspore.numpy.matmul(x1, x2, dtype=None)\n```\n\n- [MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/numpy/mindspore.numpy.matmul.html?highlight=matmul#mindspore.numpy.matmul)\n\n### Auxiliary data\n\nAuxiliary data意为辅助数据，是函数除第一个输出项外的其他输出。通常我们会将函数的loss设置为函数的第一个输出，其他的输出即为辅助数据。\n\n`grad`和`value_and_grad`提供`has_aux`参数，当其设置为`True`时，可以自动实现前文手动添加`stop_gradient`的功能，满足返回辅助数据的同时不影响梯度计算的效果。\n\n下面仍使用`function_with_logits`，配置`has_aux=True`，并执行。\n\n```python\ngrad_fn = mindspore.grad(function_with_logits, (2, 3), has_aux=True)\ngrads, (z,) = grad_fn(x, y, w, b)\nprint(grads, z)\n```\n\n### 神经网络梯度计算\n\n>  前述章节主要根据计算图对应的函数介绍了MindSpore的函数式自动微分，但我们的神经网络构造是继承自面向对象编程范式的`nn.Cell`。接下来我们通过`Cell`构造同样的神经网络，利用函数式自动微分来实现反向传播。\n\n> 首先我们继承`nn.Cell`构造单层线性变换神经网络。这里我们直接使用前文的𝑤、𝑏作为模型参数，使用`mindspore.Parameter`进行包装后，作为内部属性，并在`construct`内实现相同的Tensor操作。\n\n这里出现了反向传播方法,并且是包装好的,建议读者仔细看一下代码并尝试自己运行一下。\n\n```python\n# 定义神经网络模型\n# Define model\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.w = w\n        self.b = b\n\n    def construct(self, x):\n        z = ops.matmul(x, self.w) + self.b\n        return z\n\n\n# Instantiate model\nmodel = Network()\n# Instantiate loss function\nloss_fn = nn.BCEWithLogitsLoss()\n\n\n# Define forward function\ndef forward_fn(x, y):\n    z = model(x)\n    loss = loss_fn(z, y)\n    return loss\n\n\n# 注入损失函数\ngrad_fn = mindspore.value_and_grad(forward_fn, None, weights=model.trainable_params())\nloss, grads = grad_fn(x, y)\nprint(grads)\n```\n\n### 总结输出（单次）\n\n> ```\n> 0.92031693\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> 计算多个参数的导数\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]]), Tensor(shape=[3], dtype=Float32, value= [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]))\n> 消除部分张量对梯度的影响\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> Auxiliary data 辅助数据测试\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01])) [ 0.8580145   0.62723386 -0.44728255]      \n> 开始实测网络模型的反向传播\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> ```\n\n可见，除了在计算z的导数对梯度的影响情况下，均保持了相同的输出，并且可以观察到w,b的权值\n\n## 二值交叉熵损失\n\n***以下的对数均为自然对数***\n\nBinary cross entropy 二元[交叉熵](https://zh.wikipedia.org/wiki/交叉熵)是二分类问题中常用的一个Loss损失函数，在常见的机器学习模块中都有实现。就二元交叉熵这个损失函数的原理，简单地进行解释。下面是二元交叉熵损失函数的公式\n$$\nL=-\\frac1N \\sum_{i=1}^{N}[y_ilog(p_i)+(1-y_i)log(1-p_i)]\n$$\n先不尝试理解他，先看看他是如何运作的\n\n![img](https://s2.loli.net/2024/06/07/MAOZxqKodRSW6uy.jpg)\n$$\nL=\\frac13[(1*log0.8+(1-1)*log(1-0.8))+(0*log0.2+(1-0)*log(1-0.2))+(0*log0.4+(1-0)*log(1-0.4))]=0.319 \\\\\n$$\n对于以上的案例计算损失函数，结果是0.31903\n\n### 从熵来看交叉熵损失\n\n#### 信息量\n\n信息量来衡量一个事件的不确定性，一个事件发生的概率越大，不确定性越小，则其携带的信息量就越小。\n\n设$$X$$是一个离散型随机变量，其取值为集合$$X = {x_0,x_1,\\dots,x_n}$$，则其概率分布函数为$$p(x) = Pr(X = x),x \\in X$$，则定义事件$$X=x_0$$的信息量为：\n$$\nI(x_0) = -\\log(p(x_0))\n$$\n当$$p(x_0) = 1$$时，其携带的信息量为0。\n\n#### 熵\n\n熵用来衡量一个系统的混乱程度，代表系统中信息量的总和；熵值越大，表明这个系统的不确定性就越大。具体而数学的讲，熵就是一个系统中所有信息量的期望。\n\n信息量是衡量某个事件的不确定性，而熵是衡量一个系统（所有事件）的不确定性。\n\n熵的计算公式\n$$\nH(x) = -\\sum_{i=1}^np(x_i)\\log(p(x_i))\n$$\n比较特殊的有二项分布熵\n$$\n\\begin{eqnarray}\nH(X)&=&-\\sum_{i=1}^n p(x_i)log(p(x_i))\\\\\n&=&-p(x)log(p(x))-(1-p(x))log(1-p(x))\n\\end{eqnarray}\n$$\n*熵也有其他类型的计算公式，这里是信息学上的定义*\n\n其中$$p(x)$$为这件事发生的概率，$$-log(p(x_i))$$是事件$$x_i$$所携带的信息量。\n\n可以看出，熵是信息量的期望值，是一个随机变量（一个系统，事件所有可能性）不确定性的度量。熵值越大，随机变量的取值就越难确定，系统也就越不稳定；熵值越小，随机变量的取值也就越容易确定，系统越稳定。\n\n#### 相对熵 （Relative entropy）/  KL散度\n\nwiki对相对熵的定义如下：`In the context of machine learning, DKL(P‖Q) is often called the information gain achieved if P is used instead of Q.`\n\n即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。\n\n在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。\n\n总结：相对熵也称为KL散度(Kullback-Leibler divergence)，表示同一个随机变量的两个不同分布间的距离。\n\n设 $$p(x),𝑞(𝑥)$$分别是 离散随机变量$$X$$的两个概率分布，则$$p$$对$$q$$的相对熵是：\n$$\nD_{KL}(p \\parallel q) = \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\n$$\n相对熵具有以下性质：\n\n- 如果p(x)和q(x)的分布相同，则其相对熵等于0\n- $$D_{KL}(p∥q)≠D_{KL}(q∥p)𝐷_{𝐾𝐿}(𝑝∥𝑞)≠𝐷_{𝐾𝐿}(𝑞∥𝑝)$$，也就是相对熵不具有对称性。\n- $$D_{KL}(p∥q)≥0$$\n\n总的来说，相对熵是用来衡量同一个随机变量的两个不同分布之间的距离。**在实际应用中，假如p(x)是目标真实的分布，而q(x)是预测得来的分布，为了让这两个分布尽可能的相同的，就需要最小化KL散度。**\n\n#### 交叉熵 Cross Entropy\n\n设$$p(x),q(x)$$分别是 离散随机变量$$X$$的两个概率分布，其中$$p(x)$$是目标分布，$$p$$和$$q$$的交叉熵可以看做是，使用分布$$q(x)$$表示目标分布$$p(x)$$的困难程度\n$$\nH(p,q) = \\sum_ip(x_i)log\\frac{1}{\\log q(x_i)} = -\\sum_ip(x_i)\\log q(x_i)\n$$\n将熵、相对熵以及交叉熵的公式放到一起，\n$$\n\\begin{align}\nH(p) &= -\\sum_{i}p(x_i) \\log p(x_i) \\\\\nD_{KL}(p \\parallel q) &= \\sum_{i}p(x_i)\\log \\frac{p(x_i)}{q(x_i)} = \\sum_i (p(x_i)\\log p(x_i) - p(x_i) \\log q(x_i)) \\\\\nH(p,q) &=  -\\sum_ip(x_i)\\log q(x_i)\n\\end{align}\n$$\n通过上面三个公式就可以得到\n$$\nD_{KL}(p,q) = H(p,q)- H(p)\n$$\n其中，前一项$$H(p,q)$$就是$$p,q$$的交叉熵。在机器学习中，目标的分布$$p(x)$$通常是训练数据的分布是固定，即是$$H(p)$$是一个常量。这样两个分布的交叉熵$$H(p,q)$$也就等价于最小化这两个分布的相对熵$$D_{KL}(p \\parallel q)$$\n\n设$$p(x)$$是目标分布（训练数据的分布），我们的目标的就让训练得到的分布$$q(x)$$尽可能的接近$$p(x)$$，这时候就可以最小化$$D_{KL}(p∥q)$$，等价于最小化交叉熵$$H(p,q)$$​。\n\n### 为什么要用交叉熵做loss函数\n\n在线性回归问题中，常常使用MSE（Mean Squared Error）作为loss函数，比如：\n$$\nloss = \\frac{1}{2m}\\sum_{i=1}^m(y_i-\\hat{y_i})^2\n$$\n这里的m表示m个样本的，loss为m个样本的loss均值。\nMSE在[线性回归问题](# 回归问题)中比较好用，那么在逻辑分类问题中还是如此么？\n\n### 交叉熵在单分类问题中的使用\n\n这里的单类别是指，每一张图像样本只能有一个类别，比如只能是狗或只能是猫。\n交叉熵在单分类问题上基本是标配的方法\n$$\nloss=-\\sum_{i=1}^{n}y_ilog(\\hat{y_i})\n$$\n上式为一张样本的loss计算方法。n代表着n种类别。\n举例说明,比如有如下样本\n\n对应的标签和预测值\n\n| *     | 猫   | 青蛙 | 老鼠 |\n| ----- | ---- | ---- | ---- |\n| Label | 0    | 1    | 0    |\n| Pred  | 0.3  | 0.6  | 0.1  |\n\n\n$$\n\\begin{eqnarray}\nloss&=&-(0\\times log(0.3)+1\\times log(0.6)+0\\times log(0.1)\\\\\n&=&-log(0.6)\n\\end{eqnarray}\n$$\n对应的一个batch的loss就是\n$$\nloss=-\\frac{1}{m}\\sum_{j=1}^m\\sum_{i=1}^{n}y_{ji}log(\\hat{y_{ji}})\n$$\nm为当前batch的样本数\n\n### 交叉熵在多分类问题中的使用\n\n这里的多类别是指，每一张图像样本可以有多个类别，比如同时包含一只猫和一只狗\n和单分类问题的标签不同，多分类的标签是n-hot。\n比如下面这张样本图，即有青蛙，又有老鼠，所以是一个多分类问题\n\n栗子\n\n| *     | 猫   | 青蛙 | 老鼠 |\n| ----- | ---- | ---- | ---- |\n| Label | 0    | 1    | 1    |\n| Pred  | 0.1  | 0.7  | 0.8  |\n\n值得注意的是，这里的Pred不再是通过softmax计算的了，这里采用的是sigmoid。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。换句话说，就是每一个Label都是独立分布的，相互之间没有影响。所以交叉熵在这里是单独对每一个节点进行计算，每一个节点只有两种可能值，所以是一个二项分布。前面说过对于二项分布这种特殊的分布，熵的计算可以进行简化。\n\n同样的，交叉熵的计算也可以简化，即\n$$\nloss =-ylog(\\hat{y})-(1-y)log(1-\\hat{y})\n$$\n注意，上式只是针对一个节点的计算公式。这一点一定要和单分类loss区分开来。\n例子中可以计算为：\n$$\n\\begin{eqnarray}\nloss_猫 &=&-0\\times log(0.1)-(1-0)log(1-0.1)=-log(0.9)\\\\\nloss_蛙 &=&-1\\times log(0.7)-(1-1)log(1-0.7)=-log(0.7)\\\\\nloss_鼠 &=&-1\\times log(0.8)-(1-1)log(1-0.8)=-log(0.8)\n\\end{eqnarray}\n$$\n单张样本的loss即为\n每一个batch的loss就是：\n$$\nloss =\\sum_{j=1}^{m}\\sum_{i=1}^{n}-y_{ji}log(\\hat{y_{ji}})-(1-y_{ji})log(1-\\hat{y_{ji}})\n$$\n式中m为当前batch中的样本量，n为类别数。\n\n### 从[最大似然](# 最大似然估计)看交叉熵\n\n设有一组训练样本$X= \\{x_1,x_2,\\cdots,x_m\\}$ ,该样本的分布为$p(x)$ 。假设使用$\\theta$ 参数化模型得到$q(x;\\theta)$ ，现用这个模型来估计$X$ 的概率分布，得到似然函数\n$$\nL(\\theta) = q(X; \\theta) = \\prod_i^mq(x_i;\\theta)\n$$\n最大似然估计就是求得$\\theta$ 使得$L(\\theta)$ 的值最大，也就是\n$$\n\\theta_{ML} = arg \\max_{\\theta} \\prod_i^mq(x_i;\\theta)\n$$\n对上式的两边同时取$\\log$ ，等价优化$\\log$ 的最大似然估计即`log-likelyhood` ，最大对数似然估计\n$$\n\\theta_{ML} = arg \\max_\\theta \\sum_i^m \\log q(x_i;\\theta)\n$$\n对上式的右边进行缩放并不会改变$arg \\max$ 的解，上式的右边除以样本的个数$m$\n$$\n\\theta_{ML} = arg \\max_\\theta \\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\n$$\n\n#### 和相对熵等价\n\n上式的最大化$\\theta_{ML}$ 是和没有训练样本没有关联的，就需要某种变换使其可以用训练的样本分布来表示，因为训练样本的分布可以看作是已知的，也是对最大化似然的一个约束条件。\n\n注意上式的\n$$\n\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\n$$\n相当于**求随机变量$X$ 的函数$\\log (X;\\theta)$ 的均值** ，根据大数定理，**随着样本容量的增加，样本的算术平均值将趋近于随机变量的期望。** 也就是说\n$$\n\\frac{1}{m}\\sum_i^m \\log q(x_i;\\theta) \\rightarrow E_{x\\sim P}(\\log q(x;\\theta))\n$$\n其中$E_{X\\sim P}$ 表示符合样本分布$P$ 的期望，这样就将最大似然估计使用真实样本的期望来表示\n$$\n\\begin{aligned} \\theta_{ML} &= arg \\max_{\\theta} E_{x\\sim P}({\\log q(x;\\theta)}) \\\\ &= arg \\min_{\\theta} E_{x \\sim P}(- \\log q(x;\\theta)) \\end{aligned}\n$$\n对右边取负号，将最大化变成最小化运算。\n\n> 上述的推导过程，可以参考 《Deep Learning》 的第五章。 但是，在书中变为期望的只有一句话，将式子的右边除以样本数量$m$ 进行缩放，从而可以将其变为$E_{x \\sim p}\\log q(x;\\theta)$，没有细节过程，也可能是作者默认上面的变换对读者是一直。 确实是理解不了，查了很多文章，都是对这个变换的细节含糊其辞。一个周，对这个点一直耿耿于怀，就看了些关于概率论的科普书籍，其中共有介绍大数定理的：**当样本容量趋于无穷时，样本的均值趋于其期望**。\n>\n> 针对上面公式，除以$m$后，$\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)$ ，确实是关于随机变量函数$\\log q(x)$ 的算术平均值，而$x$ 是训练样本其分布是已知的$p(x)$ ，这样就得到了$E_{x \\sim p}(\\log q(x))$ 。\n\n$$\n\\begin{aligned} D_{KL}(p \\parallel q) &= \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\\\\ &= E_{x\\sim p}(\\log \\frac{p(x)}{q(x)}) \\\\ &= E_{x \\sim p}(\\log p(x) - \\log q(x)) \\\\ &= E_{x \\sim p}(\\log p(x)) - E_{x \\sim p} (\\log q(x)) \\end{aligned}\n$$\n\n由于$E_{x \\sim p} (\\log p(x))$ 是训练样本的期望，是个固定的常数，在求最小值时可以忽略，所以最小化$D_{KL}(p \\parallel q)$ 就变成了最小化$-E_{x\\sim p}(\\log q(x))$ ，这和最大似然估计是等价的。\n\n#### 和交叉熵等价\n\n最大似然估计、相对熵、交叉熵的公式如下\n$$\n\\begin{aligned}\\theta_{ML} &= -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log q(x) \\\\H(p,q) &= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log q(x)\\end{aligned}\\begin{aligned}\\theta_{ML} &= arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log q(x) \\\\H(p,q) &= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log q(x)\\end{aligned}\n$$\n从上面可以看出，最小化交叉熵，也就是最小化$D_{KL}$ ，从而预测的分布$q(x)$ 和训练样本的真实分布$p(x)$ 最接近。而最小化$D_{KL}$ 和最大似然估计是等价的。\n\n### 多分类交叉熵\n\n多分类任务中输出的是目标属于**每个类别的概率，所有类别概率的和为1，其中概率最大的类别就是目标所属的分类。** 而`softmax` 函数能将一个向量的每个分量映射到$[0,1]$ 区间，并且对整个向量的输出做了归一化，保证所有分量输出的和为1，正好满足多分类任务的输出要求。所以，在多分类中，在最后就需要将提取的到特征经过`softmax`函数的，输出为每个类别的概率，然后再使用**交叉熵** 作为损失函数。\n\n`softmax`函数定义如下：\n$$\nS_i = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\n$$\n其中，输入的向量为$z_i(i = 1,2,\\dots,n)$ 。\n\n更直观的参见下图\n\n![img](https://s2.loli.net/2024/06/07/XvLsuFKjBe39AaD.png)\n\n通过前面的特征提取到的特征向量为$(z_1,z_2,\\dots,z_k)$ ，将向量输入到`softmax`函数中，即可得到目标属于每个类别的概率，概率最大的就是预测得到的目标的类别。\n\n#### Cross Entropy Loss\n\n使用`softmax`函数可以将特征向量映射为所属类别的概率，可以看作是预测类别的概率分布$q(c_i)$ ，有\n$$\nq(c_i) = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\n$$\n其中$c_i$ 为某个类别。\n\n设训练数据中类别的概率分布为$p(c_i)$ ，那么目标分布$p(c_i)$ 和预测分布$q(c_i)$的交叉熵为\n\n$$H(p,q) =-\\sum_ip(c_i)\\log q(c_i) $$\n\n每个训练样本所属的类别是已知的，并且每个样本只会属于一个类别（概率为1），属于其他类别概率为0。具体的，可以假设有个三分类任务，三个类分别是：猫，猪，狗。现有一个训练样本类别为猫，则有：\n\n$$\\begin{align} p(cat) & = 1 \\\\ p(pig) &= 0 \\\\ p(dog) & = 0 \\end{align} $$\n\n通过预测得到的三个类别的概率分别为：$q(cat) = 0.6,q(pig) = 0.2,q(dog) = 0.2$ ，计算$p$ 和$q$ 的交叉熵为：\n$$\n\\begin{aligned} H(p,q) &= -(p(cat) \\log q(cat) + p(pig) + \\log q(pig) + \\log q(dog)) \\\\ &= - (1 \\cdot \\log 0.6 + 0 \\cdot \\log 0.2 +0 \\cdot \\log 0.2) \\\\ &= - \\log 0.6 \\\\ &= - \\log q(cat) \\end{aligned}\n$$\n利用这种特性，可以将样本的类别进行重新编码，就可以简化交叉熵的计算，这种编码方式就是**one-hot** 编码。以上面例子为例，\n$$\n\\begin{aligned} \\text{cat} &= (1 0 0) \\\\ \\text{pig} &= (010) \\\\ \\text{dog} &= (001) \\end{aligned}\n$$\n\n\n通过这种编码方式，在计算交叉熵时，只需要计算和训练样本对应类别预测概率的值，其他的项都是$0 \\cdot \\log q(c_i) = 0$ 。\n\n具体的，交叉熵计算公式变成如下：\n$$\n(p,q) = - \\log q(c_i)\n$$\n其中$c_i$ 为训练样本对应的类别，上式也被称为**负对数似然（negative log-likelihood,nll）**。\n\n#### PyTorch中的Cross Entropy\n\nPyTorch中实现交叉熵损失的有三个函数`torch.nn.CrossEntropyLoss`，`torch.nn.LogSoftmax`以及`torch.nn.NLLLoss`。\n\n- `torch.nn.functional.log_softmax` 比较简单，输入为$n$维向量，指定要计算的维度`dim`，输出为$log(Softmax(x))$。其计算公式如下：\n\n$$\n\\text{LogSoftmax}(x_i) = \\log (\\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)})\n$$\n\n没有额外的处理，就是对输入的$n$维向量的每个元素进行上述运算。\n\n- `torch.nn.functional.nll_loss` 负对数似然损失（Negative Log Likelihood Loss)，用于多分类，其输入的通常是`torch.nn.functional.log_softmax`的输出值。其函数如下\n\n```python\ntorch.nn.functional.nll_loss(input, target, weight=None, size_average=None, ignore_index=-100, reduce=None, reduction='mean')\n```\n\n`input` 也就是`log_softmax`的输出值，各个类别的对数概率。`target` 目标正确类别,`weight` 针对类别不平衡问题，可以为类别设置不同的权值；`ignore_index` 要忽略的类别，不参与loss的计算；比较重要的是`reduction` 的值，有三个取值：`none` 不做处理，输出的结果为向量；`mean` 将`none`结果求均值后输出；`sum` 将`none` 结果求和后输出。\n\n- `torch.nn.CrossEntropyLoss`就是上面两个函数的组合`nll_loss(log_softmax(input))`。\n\n### 二分类交叉熵\n\n多分类中使用`softmax`函数将最后的输出映射为每个类别的概率，而在二分类中则通常使用`sigmoid` 将输出映射为正样本的概率。这是因为二分类中，只有两个类别：{正样本，负样本}，只需要求得正样本的概率$q$,则$1-q$ 就是负样本的概率。这也是多分类和二分类不同的地方。\n\n$\\text{sigmoid}$ 函数的表达式如下：\n$$\n\\sigma(z) = \\frac{1}{1 + e^{-z}}\n$$\nsigmoid的输入为$z$ ，其输出为$(0,1)$ ，可以表示分类为正样本的概率。\n\n二分类的交叉熵可以看作是交叉熵损失的一个特列，交叉熵为\n$$\n\\text{$Cross\\_Entorpy$}(p,q) = -\\sum_i^m p(x_i) \\log q(x_i)\n$$\n这里只有两个类别$x \\in {x_1,x_2}$ ，则有\n$$\n\\begin{aligned}\\text{$Cross\\_Entorpy$}(p,q) &= -(p(x_1) \\log q(x_1) + p(x_2) \\log q(x_2)) \\end{aligned} \n$$\n\n\n因为只有两个选择，则有$p(x_1) + p(x_2) = 1,q(x_1) + q(x_2) = 1$ 。设，训练样本中$x_1$的概率为$p$，则$x_2$为$1-p$; 预测的$x_1$的概率为$q$，则$x_2$的预测概率为$1 - q$ 。则上式可改写为\n$$\n\\text{$Cross\\_Entropy$}(p,q) = -(p \\log q + (1-p) \\log (1-q))\n$$\n也就是二分类交叉熵的损失函数。\n\n### 总结\n\n相对熵可以用来度量两个分布相似性，假设分布$p$是训练样本的分布，$q$是预测得到的分布。分类训练的过程实际上就是最小化$D_{KL}(p \\parallel q)$，由于由于交叉熵\n$$\nH(p,q)= D_{KL}(p \\parallel q) + H(p)\n$$\n其中,$H(p)$是训练样本的熵，是一个已知的常量，这样最小化相对熵就等价于最小化交叉熵。\n\n从最大似然估计转化为最小化负对数似然\n$$\n\\theta_{ML} = -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta)\n$$\n也等价于最小化相对熵。\n\n## 回归问题\n\n回归：人们在测量事物的时候因为客观条件所限，求得的都是测量值，而不是事物真实的值，为了能够得到真实值，无限次的进行测量，最后通过这些测量数据计算**回归到真实值**，这就是回归的由来。\n\n回归分析的主要算法包括：\n\n1. 线性回归(Linear Regression)\n2. 逻辑回归（Logistic regressions）\n3. 多项式回归(Polynomial Regression)\n4. 逐步回归(Step Regression)\n5. 岭回归(Ridge Regression)\n6. 套索回归(Lasso Regression)\n7. 弹性网回归(ElasticNet)\n\n## 最大似然估计\n\nwiki定义：`在统计学中，最大似然估计（英语：maximum likelihood estimation，简作MLE），也称极大似然估计，是用来估计一个概率模型的参数的一种方法。`\n\n### 原理\n\n给定一个概率分布𝐷，已知其[概率密度函数](https://zh.wikipedia.org/wiki/概率密度函数)（连续分布）或[概率质量函数](https://zh.wikipedia.org/wiki/概率质量函数)（离散分布）为𝑓𝐷，以及一个分布参数𝜃，我们可以从这个分布中抽出一个具有𝑛个值的采样𝑋1,𝑋2,…,𝑋𝑛，利用𝑓𝐷计算出其[似然函数](https://zh.wikipedia.org/wiki/似然函数)：\n\n![{\\displaystyle {\\mbox{L}}(\\theta \\mid x_{1},\\dots ,x_{n})=f_{\\theta }(x_{1},\\dots ,x_{n}).}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a9702eeec5a8eb416883af66665ac11bd8151f0f)\n\n若𝐷是离散分布，𝑓𝜃即是在参数为𝜃时观测到这一采样的概率；若其是连续分布，𝑓𝜃则为𝑋1,𝑋2,…,𝑋𝑛联合分布的概率密度函数在观测值处的取值。一旦我们获得𝑋1,𝑋2,…,𝑋𝑛，我们就能求得一个关于𝜃的估计。最大似然估计会寻找关于𝜃的最可能的值（即，在所有可能的𝜃取值中，寻找一个值使这个采样的“可能性”最大化）。从数学上来说，我们可以在𝜃的所有可能取值中寻找一个值使得似然[函数](https://zh.wikipedia.org/wiki/函数)取到最大值。这个使可能性最大的$$\\hat 𝜃$$值即称为𝜃的**最大似然估计**。由定义，最大似然估计是样本的函数。\n\n[最大似然估计 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/最大似然估计)","source":"_posts/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc.md","raw":"---\ntitle: MindSpore专题——第六章——函数式微分\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## 函数式自动微分\n\n> 神经网络的训练主要使用反向传播算法，模型预测值（logits）与正确标签（label）送入损失函数（loss function）获得loss，然后进行反向传播计算，求得梯度（gradients），最终更新至模型参数（parameters）。自动微分能够计算可导函数在某点处的导数值，是反向传播算法的一般化。自动微分主要解决的问题是将一个复杂的数学运算分解为一系列简单的基本运算，该功能对用户屏蔽了大量的求导细节和过程，大大降低了框架的使用门槛。\n\n<!--more-->\n\n> MindSpore使用函数式自动微分的设计理念，提供更接近于数学语义的自动微分接口`grad`和`value_and_grad`。下面我们使用一个简单的单层线性变换模型进行介绍。\n\n这里总算是提到了反向传播，最近我看到了一系列视频有关Machine Learning，传送门如下：\n\n[🔴 World of Warships / USS Des Moines cut (youtube.com)](https://www.youtube.com/watch?v=Ilg3gGewQ5U)\n\n如果你试图看下去的话，可能会发现，事情好像突然变难了，似乎一群从未见过的知识组合在了一起，神经网络就像一个黑箱连着另一个黑箱，而你根本不知道如何优化它，使得黑箱在给定的输入下输出正确答案\n\n## 神经网络到底代表了什么\n\n首先让我们定义什么是神经：他是一个携带一个浮点数的结构，然后让我们看向神经网络\n\n![R](https://s2.loli.net/2024/06/07/MLN1Ap2wslU4SQB.jpg)\n\n对于每一个点，我们从最后看起，显然，他们代表0-9，更准确的说，他们代表0-9的图像。为什么这样的网络是生效的呢？\n\n***因为分形思想***，我们将一段连续的图像区分为一段一段，比如9是⚪在上而线条在下。4由多端线段1组成。而⚪和线条又可以继续再分，我们可以将神经网络中的每一个节点代表的数据想象成这种规律图案的集合。他们之间的传递就是图案在网络中不断组合。这也是为什么在网络中使用全连接的原因，因为每一个图案都能与其他任何图案组合。最终我们使图案变成了不断分形像素的组合。\n\n但如何做到这一点呢？ 考虑我们前面提到的参数，权值。\n\n![image-20240607181215798](./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240607181215798.png)\n\n这张图相信有很多人见过类似的图，实际上权值代表的就是神经网络之间的连线，假设我们让正权值在下表中为绿负权值在下表中为红，我们将这样描述一条“线段”：一段由红色包围的长条状绿色区域这样我们就能得出，如果这段线条是成立得话，比如确实原图这里存在一条线段，我们得到的这个神经节点上得值就会很接近1，否则就会很接近零。这就是权值得意义。但同时，我们会注意到神经得值是许多这样计算的累和，因此我们需要一个bias，偏差值将其计算到到0-1。\n\n注意这里得权值和偏差值均是变量，是训练出来的。并且注意，我们并不知道机器是如何分形得，这取决于学习数据和使用的算法，以上只为举例理解。\n\n如果将最初得神经网络拿去使用，你只会得到一大堆垃圾数据。我们都知道神经网络存在“进化”过程，但他是如何知道自己错得有多离谱的呢？\n\n## Cost Function（Maybe also loss function?）\n\n初略的定义是他是输出的张量与正确的张量的差值平方和，比如，机器输出了一个全是0.5的10个数的张量，而正确答案是其中之一，那么\n$$\n\\text{Cost} = (1-0.5) + 0.5*9\n$$\n显然这个数字更接近0，说明结果更加准确\n\n考虑如何让模型表现得更好，显然是需要找到一组参数，使得每次输出的cost值最小。我们可以考虑这样一种方式，以参数作为输入，cost的值作为输出，而训练数据则是参数。\n\n### 梯度下降 (Gradient Descent)\n\n似乎难以理解，假设我们只有一个参数cost=f(c)，c是唯一的参数。于是变为了函数的最值问题，只需要求导数然后慢慢移动我们的初始点。很显然，一个函数在常数域上可能存在多个极大值而只有一个最大值。当我们从一个点出发寻找最大值时，很有可能（概率学上讲应该是绝对）我们只会找到一个极大值。即在神经网络中，我们不能保证我们的参数是最优的，只能保证我们的参数是局部最优的（这取决于我们的起始点）。\n\n变到多维，我们意识到，一个数的导数是否只有正或负两种信息有效（代表是应该增加这个数还是减少这个数）。假定两个变量在一个点上的导数其中一个是另一个的三倍，这至少说明在该点的邻域内，这一变量应该减少的更多是正确的。（可能有一些函数存在极端的尖点导致错误，但这在神经网络中是低概率的，掌控好更改数据的大小即可）。\n\n一个简单的例子是，维护好一个$$\\nabla C$$矩阵，一阶导数对应的值高则其增加，反之则减少。\n\n## 反向传播\n\n从特殊到一般，我们先观察这样一个样例\n\n![image-20240607205110764](https://s2.loli.net/2024/06/07/SJ5Rf7m6cXFs8yN.png)\n\n显然我们需要增加2，并且如果给我们要做的事情做出一个排序，增加2显然排在减少8之前。\n\n因此，让我们继续看增加2所涉及的值\n\n1. 更改偏差值\n2. 更改权值（根据节点值）\n3. 更改上一层节点的值（根据权值）\n\n我们对权值和边权同时改变，并统计下一层节点需要的变化对上一层的节点影响的累和\n\n通过多组数据得出权值的总共改变值改变值。这就是随机梯度下降（Stochastic gradient descent）\n\n下面简单讲一讲其他的名词解释\n\n## Mini-batches\n\n和他的名字一样，这个技术就是将训练数据分为几组以提高收敛参数的效率\n\n## Backpropagation\n\n反向传播是一种梯度下降法的应用，通过链式法则计算损失函数相对于每个权重的梯度，然后利用这些梯度来更新权重。\n\n## 函数与计算图\n\n![compute-graph](https://s2.loli.net/2024/06/07/iqHnjI12DSKR6P7.png)\n\n> 计算图是用图论语言表示数学函数的一种方式，也是深度学习框架表达神经网络模型的统一方法。我们将根据下面的计算图构造计算函数和神经网络。\n\n> 在这个模型中，𝑥为输入，𝑦为正确值，𝑤和𝑏是我们需要优化的参数。\n\n1. 𝑥为输入\n2. 𝑦为正确值\n3. 𝑤和𝑏是我们需要优化的参数\n\n即对应了原始数据，输出结果，权重和偏差\n\n```python\nx = ops.ones(5, mindspore.float32)  # input tensor\ny = ops.zeros(3, mindspore.float32)  # expected output\nw = Parameter(Tensor(np.random.randn(5, 3), mindspore.float32), name='w') # weight\nb = Parameter(Tensor(np.random.randn(3,), mindspore.float32), name='b') # bias\n```\n\n> 我们根据计算图描述的计算过程，构造计算函数。 其中，[binary_cross_entropy_with_logits](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.binary_cross_entropy_with_logits.html) 是一个损失函数，计算预测值和目标值之间的二值交叉熵损失。\n\n解释一下Parameter(): **Parameter** 是 Tensor 的子类，当它们被绑定为Cell的属性时，会自动添加到其参数列表中，并且可以通过Cell的某些方法获取，例如 cell.get_**parameter**s() 。\n\n```python\ndef function(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss\n\nloss = function(x, y, w, b)\nprint(loss)\n```\n\n这里有复杂概念[*二值交叉熵损失*](#二值交叉熵损失)，如果你不想深究只需要这是一个对参数的函数，当这个函数值最低时，整体参数就是一个准确率较高的局部最优解即可。\n\n## 微分函数与梯度计算\n\n>  为了优化模型参数，需要求参数对loss的导数：$$\\frac{𝜕loss}{𝜕𝑤}$$和$$\\frac{𝜕loss}{𝜕𝑏}$$，此时我们调用`mindspore.grad`函数，来获得`function`的微分函数。\n\n> 这里使用了`grad`函数的两个入参，分别为：\n>\n> - `fn`：待求导的函数。\n> - `grad_position`：指定求导输入位置的索引。\n\n> 由于我们对$$𝑤$$和$$𝑏$$​求导，因此配置其在`function`入参对应的位置`(2, 3)`。\n\n> *使用`grad`获得微分函数是一种函数变换，即输入为函数，输出也为函数。*\n\n```python\ngrad_fn = mindspore.grad(function, (2, 3))\n\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n```\n\n> ```\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]]), Tensor(shape=[3], dtype=Float32, value= [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]))\n> ```\n\n执行微分函数，即可获得$$𝑤$$、$$𝑏$$​对应的梯度。可以注意到w,b的梯度与最初始的梯度是一致的。\n\n### Stop Gradient\n\n> 通常情况下，求导时会求loss对参数的导数，因此函数的输出只有loss一项。**当我们希望函数输出多项时，微分函数会求所有输出项对参数的导数**。此时如果想实现对某个输出项的梯度截断，或消除某个Tensor对梯度的影响，需要用到Stop Gradient操作。\n\n> 这里我们将`function`改为同时输出loss和z的`function_with_logits`，获得微分函数并执行。\n\n```python\ndef function_with_logits(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss, z\n\ngrad_fn = mindspore.grad(function_with_logits, (2, 3))\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n```\n\n```python\ndef function_stop_gradient(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss, ops.stop_gradient(z)\n\ngrad_fn = mindspore.grad(function_stop_gradient, (2, 3))\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n\n```\n\n`ops.stop_gradient(z)`:重点在该函数，表示屏蔽了z对梯度的影响，即仍只求参数对loss的导数。\n\n这里解释一下一些api的含义\n\n```python\nmindspore.grad(fn, grad_position=0, weights=None, has_aux=False, return_ids=False)\n```\n\n- [MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.grad.html?highlight=grad#mindspore.grad)\n\n```\nmindspore.numpy.matmul(x1, x2, dtype=None)\n```\n\n- [MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/numpy/mindspore.numpy.matmul.html?highlight=matmul#mindspore.numpy.matmul)\n\n### Auxiliary data\n\nAuxiliary data意为辅助数据，是函数除第一个输出项外的其他输出。通常我们会将函数的loss设置为函数的第一个输出，其他的输出即为辅助数据。\n\n`grad`和`value_and_grad`提供`has_aux`参数，当其设置为`True`时，可以自动实现前文手动添加`stop_gradient`的功能，满足返回辅助数据的同时不影响梯度计算的效果。\n\n下面仍使用`function_with_logits`，配置`has_aux=True`，并执行。\n\n```python\ngrad_fn = mindspore.grad(function_with_logits, (2, 3), has_aux=True)\ngrads, (z,) = grad_fn(x, y, w, b)\nprint(grads, z)\n```\n\n### 神经网络梯度计算\n\n>  前述章节主要根据计算图对应的函数介绍了MindSpore的函数式自动微分，但我们的神经网络构造是继承自面向对象编程范式的`nn.Cell`。接下来我们通过`Cell`构造同样的神经网络，利用函数式自动微分来实现反向传播。\n\n> 首先我们继承`nn.Cell`构造单层线性变换神经网络。这里我们直接使用前文的𝑤、𝑏作为模型参数，使用`mindspore.Parameter`进行包装后，作为内部属性，并在`construct`内实现相同的Tensor操作。\n\n这里出现了反向传播方法,并且是包装好的,建议读者仔细看一下代码并尝试自己运行一下。\n\n```python\n# 定义神经网络模型\n# Define model\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.w = w\n        self.b = b\n\n    def construct(self, x):\n        z = ops.matmul(x, self.w) + self.b\n        return z\n\n\n# Instantiate model\nmodel = Network()\n# Instantiate loss function\nloss_fn = nn.BCEWithLogitsLoss()\n\n\n# Define forward function\ndef forward_fn(x, y):\n    z = model(x)\n    loss = loss_fn(z, y)\n    return loss\n\n\n# 注入损失函数\ngrad_fn = mindspore.value_and_grad(forward_fn, None, weights=model.trainable_params())\nloss, grads = grad_fn(x, y)\nprint(grads)\n```\n\n### 总结输出（单次）\n\n> ```\n> 0.92031693\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> 计算多个参数的导数\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]]), Tensor(shape=[3], dtype=Float32, value= [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]))\n> 消除部分张量对梯度的影响\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> Auxiliary data 辅助数据测试\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01])) [ 0.8580145   0.62723386 -0.44728255]      \n> 开始实测网络模型的反向传播\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> ```\n\n可见，除了在计算z的导数对梯度的影响情况下，均保持了相同的输出，并且可以观察到w,b的权值\n\n## 二值交叉熵损失\n\n***以下的对数均为自然对数***\n\nBinary cross entropy 二元[交叉熵](https://zh.wikipedia.org/wiki/交叉熵)是二分类问题中常用的一个Loss损失函数，在常见的机器学习模块中都有实现。就二元交叉熵这个损失函数的原理，简单地进行解释。下面是二元交叉熵损失函数的公式\n$$\nL=-\\frac1N \\sum_{i=1}^{N}[y_ilog(p_i)+(1-y_i)log(1-p_i)]\n$$\n先不尝试理解他，先看看他是如何运作的\n\n![img](https://s2.loli.net/2024/06/07/MAOZxqKodRSW6uy.jpg)\n$$\nL=\\frac13[(1*log0.8+(1-1)*log(1-0.8))+(0*log0.2+(1-0)*log(1-0.2))+(0*log0.4+(1-0)*log(1-0.4))]=0.319 \\\\\n$$\n对于以上的案例计算损失函数，结果是0.31903\n\n### 从熵来看交叉熵损失\n\n#### 信息量\n\n信息量来衡量一个事件的不确定性，一个事件发生的概率越大，不确定性越小，则其携带的信息量就越小。\n\n设$$X$$是一个离散型随机变量，其取值为集合$$X = {x_0,x_1,\\dots,x_n}$$，则其概率分布函数为$$p(x) = Pr(X = x),x \\in X$$，则定义事件$$X=x_0$$的信息量为：\n$$\nI(x_0) = -\\log(p(x_0))\n$$\n当$$p(x_0) = 1$$时，其携带的信息量为0。\n\n#### 熵\n\n熵用来衡量一个系统的混乱程度，代表系统中信息量的总和；熵值越大，表明这个系统的不确定性就越大。具体而数学的讲，熵就是一个系统中所有信息量的期望。\n\n信息量是衡量某个事件的不确定性，而熵是衡量一个系统（所有事件）的不确定性。\n\n熵的计算公式\n$$\nH(x) = -\\sum_{i=1}^np(x_i)\\log(p(x_i))\n$$\n比较特殊的有二项分布熵\n$$\n\\begin{eqnarray}\nH(X)&=&-\\sum_{i=1}^n p(x_i)log(p(x_i))\\\\\n&=&-p(x)log(p(x))-(1-p(x))log(1-p(x))\n\\end{eqnarray}\n$$\n*熵也有其他类型的计算公式，这里是信息学上的定义*\n\n其中$$p(x)$$为这件事发生的概率，$$-log(p(x_i))$$是事件$$x_i$$所携带的信息量。\n\n可以看出，熵是信息量的期望值，是一个随机变量（一个系统，事件所有可能性）不确定性的度量。熵值越大，随机变量的取值就越难确定，系统也就越不稳定；熵值越小，随机变量的取值也就越容易确定，系统越稳定。\n\n#### 相对熵 （Relative entropy）/  KL散度\n\nwiki对相对熵的定义如下：`In the context of machine learning, DKL(P‖Q) is often called the information gain achieved if P is used instead of Q.`\n\n即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。\n\n在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。\n\n总结：相对熵也称为KL散度(Kullback-Leibler divergence)，表示同一个随机变量的两个不同分布间的距离。\n\n设 $$p(x),𝑞(𝑥)$$分别是 离散随机变量$$X$$的两个概率分布，则$$p$$对$$q$$的相对熵是：\n$$\nD_{KL}(p \\parallel q) = \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\n$$\n相对熵具有以下性质：\n\n- 如果p(x)和q(x)的分布相同，则其相对熵等于0\n- $$D_{KL}(p∥q)≠D_{KL}(q∥p)𝐷_{𝐾𝐿}(𝑝∥𝑞)≠𝐷_{𝐾𝐿}(𝑞∥𝑝)$$，也就是相对熵不具有对称性。\n- $$D_{KL}(p∥q)≥0$$\n\n总的来说，相对熵是用来衡量同一个随机变量的两个不同分布之间的距离。**在实际应用中，假如p(x)是目标真实的分布，而q(x)是预测得来的分布，为了让这两个分布尽可能的相同的，就需要最小化KL散度。**\n\n#### 交叉熵 Cross Entropy\n\n设$$p(x),q(x)$$分别是 离散随机变量$$X$$的两个概率分布，其中$$p(x)$$是目标分布，$$p$$和$$q$$的交叉熵可以看做是，使用分布$$q(x)$$表示目标分布$$p(x)$$的困难程度\n$$\nH(p,q) = \\sum_ip(x_i)log\\frac{1}{\\log q(x_i)} = -\\sum_ip(x_i)\\log q(x_i)\n$$\n将熵、相对熵以及交叉熵的公式放到一起，\n$$\n\\begin{align}\nH(p) &= -\\sum_{i}p(x_i) \\log p(x_i) \\\\\nD_{KL}(p \\parallel q) &= \\sum_{i}p(x_i)\\log \\frac{p(x_i)}{q(x_i)} = \\sum_i (p(x_i)\\log p(x_i) - p(x_i) \\log q(x_i)) \\\\\nH(p,q) &=  -\\sum_ip(x_i)\\log q(x_i)\n\\end{align}\n$$\n通过上面三个公式就可以得到\n$$\nD_{KL}(p,q) = H(p,q)- H(p)\n$$\n其中，前一项$$H(p,q)$$就是$$p,q$$的交叉熵。在机器学习中，目标的分布$$p(x)$$通常是训练数据的分布是固定，即是$$H(p)$$是一个常量。这样两个分布的交叉熵$$H(p,q)$$也就等价于最小化这两个分布的相对熵$$D_{KL}(p \\parallel q)$$\n\n设$$p(x)$$是目标分布（训练数据的分布），我们的目标的就让训练得到的分布$$q(x)$$尽可能的接近$$p(x)$$，这时候就可以最小化$$D_{KL}(p∥q)$$，等价于最小化交叉熵$$H(p,q)$$​。\n\n### 为什么要用交叉熵做loss函数\n\n在线性回归问题中，常常使用MSE（Mean Squared Error）作为loss函数，比如：\n$$\nloss = \\frac{1}{2m}\\sum_{i=1}^m(y_i-\\hat{y_i})^2\n$$\n这里的m表示m个样本的，loss为m个样本的loss均值。\nMSE在[线性回归问题](# 回归问题)中比较好用，那么在逻辑分类问题中还是如此么？\n\n### 交叉熵在单分类问题中的使用\n\n这里的单类别是指，每一张图像样本只能有一个类别，比如只能是狗或只能是猫。\n交叉熵在单分类问题上基本是标配的方法\n$$\nloss=-\\sum_{i=1}^{n}y_ilog(\\hat{y_i})\n$$\n上式为一张样本的loss计算方法。n代表着n种类别。\n举例说明,比如有如下样本\n\n对应的标签和预测值\n\n| *     | 猫   | 青蛙 | 老鼠 |\n| ----- | ---- | ---- | ---- |\n| Label | 0    | 1    | 0    |\n| Pred  | 0.3  | 0.6  | 0.1  |\n\n\n$$\n\\begin{eqnarray}\nloss&=&-(0\\times log(0.3)+1\\times log(0.6)+0\\times log(0.1)\\\\\n&=&-log(0.6)\n\\end{eqnarray}\n$$\n对应的一个batch的loss就是\n$$\nloss=-\\frac{1}{m}\\sum_{j=1}^m\\sum_{i=1}^{n}y_{ji}log(\\hat{y_{ji}})\n$$\nm为当前batch的样本数\n\n### 交叉熵在多分类问题中的使用\n\n这里的多类别是指，每一张图像样本可以有多个类别，比如同时包含一只猫和一只狗\n和单分类问题的标签不同，多分类的标签是n-hot。\n比如下面这张样本图，即有青蛙，又有老鼠，所以是一个多分类问题\n\n栗子\n\n| *     | 猫   | 青蛙 | 老鼠 |\n| ----- | ---- | ---- | ---- |\n| Label | 0    | 1    | 1    |\n| Pred  | 0.1  | 0.7  | 0.8  |\n\n值得注意的是，这里的Pred不再是通过softmax计算的了，这里采用的是sigmoid。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。换句话说，就是每一个Label都是独立分布的，相互之间没有影响。所以交叉熵在这里是单独对每一个节点进行计算，每一个节点只有两种可能值，所以是一个二项分布。前面说过对于二项分布这种特殊的分布，熵的计算可以进行简化。\n\n同样的，交叉熵的计算也可以简化，即\n$$\nloss =-ylog(\\hat{y})-(1-y)log(1-\\hat{y})\n$$\n注意，上式只是针对一个节点的计算公式。这一点一定要和单分类loss区分开来。\n例子中可以计算为：\n$$\n\\begin{eqnarray}\nloss_猫 &=&-0\\times log(0.1)-(1-0)log(1-0.1)=-log(0.9)\\\\\nloss_蛙 &=&-1\\times log(0.7)-(1-1)log(1-0.7)=-log(0.7)\\\\\nloss_鼠 &=&-1\\times log(0.8)-(1-1)log(1-0.8)=-log(0.8)\n\\end{eqnarray}\n$$\n单张样本的loss即为\n每一个batch的loss就是：\n$$\nloss =\\sum_{j=1}^{m}\\sum_{i=1}^{n}-y_{ji}log(\\hat{y_{ji}})-(1-y_{ji})log(1-\\hat{y_{ji}})\n$$\n式中m为当前batch中的样本量，n为类别数。\n\n### 从[最大似然](# 最大似然估计)看交叉熵\n\n设有一组训练样本$X= \\{x_1,x_2,\\cdots,x_m\\}$ ,该样本的分布为$p(x)$ 。假设使用$\\theta$ 参数化模型得到$q(x;\\theta)$ ，现用这个模型来估计$X$ 的概率分布，得到似然函数\n$$\nL(\\theta) = q(X; \\theta) = \\prod_i^mq(x_i;\\theta)\n$$\n最大似然估计就是求得$\\theta$ 使得$L(\\theta)$ 的值最大，也就是\n$$\n\\theta_{ML} = arg \\max_{\\theta} \\prod_i^mq(x_i;\\theta)\n$$\n对上式的两边同时取$\\log$ ，等价优化$\\log$ 的最大似然估计即`log-likelyhood` ，最大对数似然估计\n$$\n\\theta_{ML} = arg \\max_\\theta \\sum_i^m \\log q(x_i;\\theta)\n$$\n对上式的右边进行缩放并不会改变$arg \\max$ 的解，上式的右边除以样本的个数$m$\n$$\n\\theta_{ML} = arg \\max_\\theta \\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\n$$\n\n#### 和相对熵等价\n\n上式的最大化$\\theta_{ML}$ 是和没有训练样本没有关联的，就需要某种变换使其可以用训练的样本分布来表示，因为训练样本的分布可以看作是已知的，也是对最大化似然的一个约束条件。\n\n注意上式的\n$$\n\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\n$$\n相当于**求随机变量$X$ 的函数$\\log (X;\\theta)$ 的均值** ，根据大数定理，**随着样本容量的增加，样本的算术平均值将趋近于随机变量的期望。** 也就是说\n$$\n\\frac{1}{m}\\sum_i^m \\log q(x_i;\\theta) \\rightarrow E_{x\\sim P}(\\log q(x;\\theta))\n$$\n其中$E_{X\\sim P}$ 表示符合样本分布$P$ 的期望，这样就将最大似然估计使用真实样本的期望来表示\n$$\n\\begin{aligned} \\theta_{ML} &= arg \\max_{\\theta} E_{x\\sim P}({\\log q(x;\\theta)}) \\\\ &= arg \\min_{\\theta} E_{x \\sim P}(- \\log q(x;\\theta)) \\end{aligned}\n$$\n对右边取负号，将最大化变成最小化运算。\n\n> 上述的推导过程，可以参考 《Deep Learning》 的第五章。 但是，在书中变为期望的只有一句话，将式子的右边除以样本数量$m$ 进行缩放，从而可以将其变为$E_{x \\sim p}\\log q(x;\\theta)$，没有细节过程，也可能是作者默认上面的变换对读者是一直。 确实是理解不了，查了很多文章，都是对这个变换的细节含糊其辞。一个周，对这个点一直耿耿于怀，就看了些关于概率论的科普书籍，其中共有介绍大数定理的：**当样本容量趋于无穷时，样本的均值趋于其期望**。\n>\n> 针对上面公式，除以$m$后，$\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)$ ，确实是关于随机变量函数$\\log q(x)$ 的算术平均值，而$x$ 是训练样本其分布是已知的$p(x)$ ，这样就得到了$E_{x \\sim p}(\\log q(x))$ 。\n\n$$\n\\begin{aligned} D_{KL}(p \\parallel q) &= \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\\\\ &= E_{x\\sim p}(\\log \\frac{p(x)}{q(x)}) \\\\ &= E_{x \\sim p}(\\log p(x) - \\log q(x)) \\\\ &= E_{x \\sim p}(\\log p(x)) - E_{x \\sim p} (\\log q(x)) \\end{aligned}\n$$\n\n由于$E_{x \\sim p} (\\log p(x))$ 是训练样本的期望，是个固定的常数，在求最小值时可以忽略，所以最小化$D_{KL}(p \\parallel q)$ 就变成了最小化$-E_{x\\sim p}(\\log q(x))$ ，这和最大似然估计是等价的。\n\n#### 和交叉熵等价\n\n最大似然估计、相对熵、交叉熵的公式如下\n$$\n\\begin{aligned}\\theta_{ML} &= -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log q(x) \\\\H(p,q) &= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log q(x)\\end{aligned}\\begin{aligned}\\theta_{ML} &= arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log q(x) \\\\H(p,q) &= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log q(x)\\end{aligned}\n$$\n从上面可以看出，最小化交叉熵，也就是最小化$D_{KL}$ ，从而预测的分布$q(x)$ 和训练样本的真实分布$p(x)$ 最接近。而最小化$D_{KL}$ 和最大似然估计是等价的。\n\n### 多分类交叉熵\n\n多分类任务中输出的是目标属于**每个类别的概率，所有类别概率的和为1，其中概率最大的类别就是目标所属的分类。** 而`softmax` 函数能将一个向量的每个分量映射到$[0,1]$ 区间，并且对整个向量的输出做了归一化，保证所有分量输出的和为1，正好满足多分类任务的输出要求。所以，在多分类中，在最后就需要将提取的到特征经过`softmax`函数的，输出为每个类别的概率，然后再使用**交叉熵** 作为损失函数。\n\n`softmax`函数定义如下：\n$$\nS_i = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\n$$\n其中，输入的向量为$z_i(i = 1,2,\\dots,n)$ 。\n\n更直观的参见下图\n\n![img](https://s2.loli.net/2024/06/07/XvLsuFKjBe39AaD.png)\n\n通过前面的特征提取到的特征向量为$(z_1,z_2,\\dots,z_k)$ ，将向量输入到`softmax`函数中，即可得到目标属于每个类别的概率，概率最大的就是预测得到的目标的类别。\n\n#### Cross Entropy Loss\n\n使用`softmax`函数可以将特征向量映射为所属类别的概率，可以看作是预测类别的概率分布$q(c_i)$ ，有\n$$\nq(c_i) = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\n$$\n其中$c_i$ 为某个类别。\n\n设训练数据中类别的概率分布为$p(c_i)$ ，那么目标分布$p(c_i)$ 和预测分布$q(c_i)$的交叉熵为\n\n$$H(p,q) =-\\sum_ip(c_i)\\log q(c_i) $$\n\n每个训练样本所属的类别是已知的，并且每个样本只会属于一个类别（概率为1），属于其他类别概率为0。具体的，可以假设有个三分类任务，三个类分别是：猫，猪，狗。现有一个训练样本类别为猫，则有：\n\n$$\\begin{align} p(cat) & = 1 \\\\ p(pig) &= 0 \\\\ p(dog) & = 0 \\end{align} $$\n\n通过预测得到的三个类别的概率分别为：$q(cat) = 0.6,q(pig) = 0.2,q(dog) = 0.2$ ，计算$p$ 和$q$ 的交叉熵为：\n$$\n\\begin{aligned} H(p,q) &= -(p(cat) \\log q(cat) + p(pig) + \\log q(pig) + \\log q(dog)) \\\\ &= - (1 \\cdot \\log 0.6 + 0 \\cdot \\log 0.2 +0 \\cdot \\log 0.2) \\\\ &= - \\log 0.6 \\\\ &= - \\log q(cat) \\end{aligned}\n$$\n利用这种特性，可以将样本的类别进行重新编码，就可以简化交叉熵的计算，这种编码方式就是**one-hot** 编码。以上面例子为例，\n$$\n\\begin{aligned} \\text{cat} &= (1 0 0) \\\\ \\text{pig} &= (010) \\\\ \\text{dog} &= (001) \\end{aligned}\n$$\n\n\n通过这种编码方式，在计算交叉熵时，只需要计算和训练样本对应类别预测概率的值，其他的项都是$0 \\cdot \\log q(c_i) = 0$ 。\n\n具体的，交叉熵计算公式变成如下：\n$$\n(p,q) = - \\log q(c_i)\n$$\n其中$c_i$ 为训练样本对应的类别，上式也被称为**负对数似然（negative log-likelihood,nll）**。\n\n#### PyTorch中的Cross Entropy\n\nPyTorch中实现交叉熵损失的有三个函数`torch.nn.CrossEntropyLoss`，`torch.nn.LogSoftmax`以及`torch.nn.NLLLoss`。\n\n- `torch.nn.functional.log_softmax` 比较简单，输入为$n$维向量，指定要计算的维度`dim`，输出为$log(Softmax(x))$。其计算公式如下：\n\n$$\n\\text{LogSoftmax}(x_i) = \\log (\\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)})\n$$\n\n没有额外的处理，就是对输入的$n$维向量的每个元素进行上述运算。\n\n- `torch.nn.functional.nll_loss` 负对数似然损失（Negative Log Likelihood Loss)，用于多分类，其输入的通常是`torch.nn.functional.log_softmax`的输出值。其函数如下\n\n```python\ntorch.nn.functional.nll_loss(input, target, weight=None, size_average=None, ignore_index=-100, reduce=None, reduction='mean')\n```\n\n`input` 也就是`log_softmax`的输出值，各个类别的对数概率。`target` 目标正确类别,`weight` 针对类别不平衡问题，可以为类别设置不同的权值；`ignore_index` 要忽略的类别，不参与loss的计算；比较重要的是`reduction` 的值，有三个取值：`none` 不做处理，输出的结果为向量；`mean` 将`none`结果求均值后输出；`sum` 将`none` 结果求和后输出。\n\n- `torch.nn.CrossEntropyLoss`就是上面两个函数的组合`nll_loss(log_softmax(input))`。\n\n### 二分类交叉熵\n\n多分类中使用`softmax`函数将最后的输出映射为每个类别的概率，而在二分类中则通常使用`sigmoid` 将输出映射为正样本的概率。这是因为二分类中，只有两个类别：{正样本，负样本}，只需要求得正样本的概率$q$,则$1-q$ 就是负样本的概率。这也是多分类和二分类不同的地方。\n\n$\\text{sigmoid}$ 函数的表达式如下：\n$$\n\\sigma(z) = \\frac{1}{1 + e^{-z}}\n$$\nsigmoid的输入为$z$ ，其输出为$(0,1)$ ，可以表示分类为正样本的概率。\n\n二分类的交叉熵可以看作是交叉熵损失的一个特列，交叉熵为\n$$\n\\text{$Cross\\_Entorpy$}(p,q) = -\\sum_i^m p(x_i) \\log q(x_i)\n$$\n这里只有两个类别$x \\in {x_1,x_2}$ ，则有\n$$\n\\begin{aligned}\\text{$Cross\\_Entorpy$}(p,q) &= -(p(x_1) \\log q(x_1) + p(x_2) \\log q(x_2)) \\end{aligned} \n$$\n\n\n因为只有两个选择，则有$p(x_1) + p(x_2) = 1,q(x_1) + q(x_2) = 1$ 。设，训练样本中$x_1$的概率为$p$，则$x_2$为$1-p$; 预测的$x_1$的概率为$q$，则$x_2$的预测概率为$1 - q$ 。则上式可改写为\n$$\n\\text{$Cross\\_Entropy$}(p,q) = -(p \\log q + (1-p) \\log (1-q))\n$$\n也就是二分类交叉熵的损失函数。\n\n### 总结\n\n相对熵可以用来度量两个分布相似性，假设分布$p$是训练样本的分布，$q$是预测得到的分布。分类训练的过程实际上就是最小化$D_{KL}(p \\parallel q)$，由于由于交叉熵\n$$\nH(p,q)= D_{KL}(p \\parallel q) + H(p)\n$$\n其中,$H(p)$是训练样本的熵，是一个已知的常量，这样最小化相对熵就等价于最小化交叉熵。\n\n从最大似然估计转化为最小化负对数似然\n$$\n\\theta_{ML} = -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta)\n$$\n也等价于最小化相对熵。\n\n## 回归问题\n\n回归：人们在测量事物的时候因为客观条件所限，求得的都是测量值，而不是事物真实的值，为了能够得到真实值，无限次的进行测量，最后通过这些测量数据计算**回归到真实值**，这就是回归的由来。\n\n回归分析的主要算法包括：\n\n1. 线性回归(Linear Regression)\n2. 逻辑回归（Logistic regressions）\n3. 多项式回归(Polynomial Regression)\n4. 逐步回归(Step Regression)\n5. 岭回归(Ridge Regression)\n6. 套索回归(Lasso Regression)\n7. 弹性网回归(ElasticNet)\n\n## 最大似然估计\n\nwiki定义：`在统计学中，最大似然估计（英语：maximum likelihood estimation，简作MLE），也称极大似然估计，是用来估计一个概率模型的参数的一种方法。`\n\n### 原理\n\n给定一个概率分布𝐷，已知其[概率密度函数](https://zh.wikipedia.org/wiki/概率密度函数)（连续分布）或[概率质量函数](https://zh.wikipedia.org/wiki/概率质量函数)（离散分布）为𝑓𝐷，以及一个分布参数𝜃，我们可以从这个分布中抽出一个具有𝑛个值的采样𝑋1,𝑋2,…,𝑋𝑛，利用𝑓𝐷计算出其[似然函数](https://zh.wikipedia.org/wiki/似然函数)：\n\n![{\\displaystyle {\\mbox{L}}(\\theta \\mid x_{1},\\dots ,x_{n})=f_{\\theta }(x_{1},\\dots ,x_{n}).}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a9702eeec5a8eb416883af66665ac11bd8151f0f)\n\n若𝐷是离散分布，𝑓𝜃即是在参数为𝜃时观测到这一采样的概率；若其是连续分布，𝑓𝜃则为𝑋1,𝑋2,…,𝑋𝑛联合分布的概率密度函数在观测值处的取值。一旦我们获得𝑋1,𝑋2,…,𝑋𝑛，我们就能求得一个关于𝜃的估计。最大似然估计会寻找关于𝜃的最可能的值（即，在所有可能的𝜃取值中，寻找一个值使这个采样的“可能性”最大化）。从数学上来说，我们可以在𝜃的所有可能取值中寻找一个值使得似然[函数](https://zh.wikipedia.org/wiki/函数)取到最大值。这个使可能性最大的$$\\hat 𝜃$$值即称为𝜃的**最大似然估计**。由定义，最大似然估计是样本的函数。\n\n[最大似然估计 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/最大似然估计)","slug":"special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc","published":1,"updated":"2024-08-16T08:59:11.713Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjbj00a5lowv3vba0xo5","content":"<h2 id=\"函数式自动微分\">函数式自动微分</h2>\r\n<blockquote>\r\n<p>神经网络的训练主要使用反向传播算法，模型预测值（logits）与正确标签（label）送入损失函数（loss\r\nfunction）获得loss，然后进行反向传播计算，求得梯度（gradients），最终更新至模型参数（parameters）。自动微分能够计算可导函数在某点处的导数值，是反向传播算法的一般化。自动微分主要解决的问题是将一个复杂的数学运算分解为一系列简单的基本运算，该功能对用户屏蔽了大量的求导细节和过程，大大降低了框架的使用门槛。</p>\r\n</blockquote>\r\n<span id=\"more\"></span>\r\n<blockquote>\r\n<p>MindSpore使用函数式自动微分的设计理念，提供更接近于数学语义的自动微分接口<code>grad</code>和<code>value_and_grad</code>。下面我们使用一个简单的单层线性变换模型进行介绍。</p>\r\n</blockquote>\r\n<p>这里总算是提到了反向传播，最近我看到了一系列视频有关Machine\r\nLearning，传送门如下：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1JbGczZ0dld1E1VQ==\">🔴 World of\r\nWarships / USS Des Moines cut (youtube.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>如果你试图看下去的话，可能会发现，事情好像突然变难了，似乎一群从未见过的知识组合在了一起，神经网络就像一个黑箱连着另一个黑箱，而你根本不知道如何优化它，使得黑箱在给定的输入下输出正确答案</p>\r\n<h2 id=\"神经网络到底代表了什么\">神经网络到底代表了什么</h2>\r\n<p>首先让我们定义什么是神经：他是一个携带一个浮点数的结构，然后让我们看向神经网络</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/MLN1Ap2wslU4SQB.jpg\" alt=\"R\" />\r\n<figcaption aria-hidden=\"true\">R</figcaption>\r\n</figure>\r\n<p>对于每一个点，我们从最后看起，显然，他们代表0-9，更准确的说，他们代表0-9的图像。为什么这样的网络是生效的呢？</p>\r\n<p><strong><em>因为分形思想</em></strong>，我们将一段连续的图像区分为一段一段，比如9是⚪在上而线条在下。4由多端线段1组成。而⚪和线条又可以继续再分，我们可以将神经网络中的每一个节点代表的数据想象成这种规律图案的集合。他们之间的传递就是图案在网络中不断组合。这也是为什么在网络中使用全连接的原因，因为每一个图案都能与其他任何图案组合。最终我们使图案变成了不断分形像素的组合。</p>\r\n<p>但如何做到这一点呢？ 考虑我们前面提到的参数，权值。</p>\r\n<figure>\r\n<img\r\nsrc=\"./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240607181215798.png\"\r\nalt=\"image-20240607181215798\" />\r\n<figcaption aria-hidden=\"true\">image-20240607181215798</figcaption>\r\n</figure>\r\n<p>这张图相信有很多人见过类似的图，实际上权值代表的就是神经网络之间的连线，假设我们让正权值在下表中为绿负权值在下表中为红，我们将这样描述一条“线段”：一段由红色包围的长条状绿色区域这样我们就能得出，如果这段线条是成立得话，比如确实原图这里存在一条线段，我们得到的这个神经节点上得值就会很接近1，否则就会很接近零。这就是权值得意义。但同时，我们会注意到神经得值是许多这样计算的累和，因此我们需要一个bias，偏差值将其计算到到0-1。</p>\r\n<p>注意这里得权值和偏差值均是变量，是训练出来的。并且注意，我们并不知道机器是如何分形得，这取决于学习数据和使用的算法，以上只为举例理解。</p>\r\n<p>如果将最初得神经网络拿去使用，你只会得到一大堆垃圾数据。我们都知道神经网络存在“进化”过程，但他是如何知道自己错得有多离谱的呢？</p>\r\n<h2 id=\"cost-functionmaybe-also-loss-function\">Cost Function（Maybe also\r\nloss function?）</h2>\r\n<p>初略的定义是他是输出的张量与正确的张量的差值平方和，比如，机器输出了一个全是0.5的10个数的张量，而正确答案是其中之一，那么\r\n<span class=\"math display\">\\[\r\n\\text{Cost} = (1-0.5) + 0.5*9\r\n\\]</span> 显然这个数字更接近0，说明结果更加准确</p>\r\n<p>考虑如何让模型表现得更好，显然是需要找到一组参数，使得每次输出的cost值最小。我们可以考虑这样一种方式，以参数作为输入，cost的值作为输出，而训练数据则是参数。</p>\r\n<h3 id=\"梯度下降-gradient-descent\">梯度下降 (Gradient Descent)</h3>\r\n<p>似乎难以理解，假设我们只有一个参数cost=f(c)，c是唯一的参数。于是变为了函数的最值问题，只需要求导数然后慢慢移动我们的初始点。很显然，一个函数在常数域上可能存在多个极大值而只有一个最大值。当我们从一个点出发寻找最大值时，很有可能（概率学上讲应该是绝对）我们只会找到一个极大值。即在神经网络中，我们不能保证我们的参数是最优的，只能保证我们的参数是局部最优的（这取决于我们的起始点）。</p>\r\n<p>变到多维，我们意识到，一个数的导数是否只有正或负两种信息有效（代表是应该增加这个数还是减少这个数）。假定两个变量在一个点上的导数其中一个是另一个的三倍，这至少说明在该点的邻域内，这一变量应该减少的更多是正确的。（可能有一些函数存在极端的尖点导致错误，但这在神经网络中是低概率的，掌控好更改数据的大小即可）。</p>\r\n<p>一个简单的例子是，维护好一个<span class=\"math display\">\\[\\nabla\r\nC\\]</span>矩阵，一阶导数对应的值高则其增加，反之则减少。</p>\r\n<h2 id=\"反向传播\">反向传播</h2>\r\n<p>从特殊到一般，我们先观察这样一个样例</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/SJ5Rf7m6cXFs8yN.png\"\r\nalt=\"image-20240607205110764\" />\r\n<figcaption aria-hidden=\"true\">image-20240607205110764</figcaption>\r\n</figure>\r\n<p>显然我们需要增加2，并且如果给我们要做的事情做出一个排序，增加2显然排在减少8之前。</p>\r\n<p>因此，让我们继续看增加2所涉及的值</p>\r\n<ol type=\"1\">\r\n<li>更改偏差值</li>\r\n<li>更改权值（根据节点值）</li>\r\n<li>更改上一层节点的值（根据权值）</li>\r\n</ol>\r\n<p>我们对权值和边权同时改变，并统计下一层节点需要的变化对上一层的节点影响的累和</p>\r\n<p>通过多组数据得出权值的总共改变值改变值。这就是随机梯度下降（Stochastic\r\ngradient descent）</p>\r\n<p>下面简单讲一讲其他的名词解释</p>\r\n<h2 id=\"mini-batches\">Mini-batches</h2>\r\n<p>和他的名字一样，这个技术就是将训练数据分为几组以提高收敛参数的效率</p>\r\n<h2 id=\"backpropagation\">Backpropagation</h2>\r\n<p>反向传播是一种梯度下降法的应用，通过链式法则计算损失函数相对于每个权重的梯度，然后利用这些梯度来更新权重。</p>\r\n<h2 id=\"函数与计算图\">函数与计算图</h2>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/iqHnjI12DSKR6P7.png\"\r\nalt=\"compute-graph\" />\r\n<figcaption aria-hidden=\"true\">compute-graph</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>计算图是用图论语言表示数学函数的一种方式，也是深度学习框架表达神经网络模型的统一方法。我们将根据下面的计算图构造计算函数和神经网络。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>在这个模型中，𝑥为输入，𝑦为正确值，𝑤和𝑏是我们需要优化的参数。</p>\r\n</blockquote>\r\n<ol type=\"1\">\r\n<li>𝑥为输入</li>\r\n<li>𝑦为正确值</li>\r\n<li>𝑤和𝑏是我们需要优化的参数</li>\r\n</ol>\r\n<p>即对应了原始数据，输出结果，权重和偏差</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = ops.ones(<span class=\"number\">5</span>, mindspore.float32)  <span class=\"comment\"># input tensor</span></span><br><span class=\"line\">y = ops.zeros(<span class=\"number\">3</span>, mindspore.float32)  <span class=\"comment\"># expected output</span></span><br><span class=\"line\">w = Parameter(Tensor(np.random.randn(<span class=\"number\">5</span>, <span class=\"number\">3</span>), mindspore.float32), name=<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"comment\"># weight</span></span><br><span class=\"line\">b = Parameter(Tensor(np.random.randn(<span class=\"number\">3</span>,), mindspore.float32), name=<span class=\"string\">&#x27;b&#x27;</span>) <span class=\"comment\"># bias</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>我们根据计算图描述的计算过程，构造计算函数。 其中，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLmJpbmFyeV9jcm9zc19lbnRyb3B5X3dpdGhfbG9naXRzLmh0bWw=\">binary_cross_entropy_with_logits<i class=\"fa fa-external-link-alt\"></i></span>\r\n是一个损失函数，计算预测值和目标值之间的二值交叉熵损失。</p>\r\n</blockquote>\r\n<p>解释一下Parameter(): <strong>Parameter</strong> 是 Tensor\r\n的子类，当它们被绑定为Cell的属性时，会自动添加到其参数列表中，并且可以通过Cell的某些方法获取，例如\r\ncell.get_<strong>parameter</strong>s() 。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\">loss = function(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(loss)</span><br></pre></td></tr></table></figure>\r\n<p>这里有复杂概念<a\r\nhref=\"#二值交叉熵损失\"><em>二值交叉熵损失</em></a>，如果你不想深究只需要这是一个对参数的函数，当这个函数值最低时，整体参数就是一个准确率较高的局部最优解即可。</p>\r\n<h2 id=\"微分函数与梯度计算\">微分函数与梯度计算</h2>\r\n<blockquote>\r\n<p>为了优化模型参数，需要求参数对loss的导数：<span\r\nclass=\"math display\">\\[\\frac{𝜕loss}{𝜕𝑤}\\]</span>和<span\r\nclass=\"math display\">\\[\\frac{𝜕loss}{𝜕𝑏}\\]</span>，此时我们调用<code>mindspore.grad</code>函数，来获得<code>function</code>的微分函数。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>这里使用了<code>grad</code>函数的两个入参，分别为：</p>\r\n<ul>\r\n<li><code>fn</code>：待求导的函数。</li>\r\n<li><code>grad_position</code>：指定求导输入位置的索引。</li>\r\n</ul>\r\n</blockquote>\r\n<blockquote>\r\n<p>由于我们对<span class=\"math display\">\\[𝑤\\]</span>和<span\r\nclass=\"math display\">\\[𝑏\\]</span>​求导，因此配置其在<code>function</code>入参对应的位置<code>(2, 3)</code>。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p><em>使用<code>grad</code>获得微分函数是一种函数变换，即输入为函数，输出也为函数。</em></p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grad_fn = mindspore.grad(function, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]]), Tensor(shape=[3], dtype=Float32, value= [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]))</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>执行微分函数，即可获得<span class=\"math display\">\\[𝑤\\]</span>、<span\r\nclass=\"math display\">\\[𝑏\\]</span>​对应的梯度。可以注意到w,b的梯度与最初始的梯度是一致的。</p>\r\n<h3 id=\"stop-gradient\">Stop Gradient</h3>\r\n<blockquote>\r\n<p>通常情况下，求导时会求loss对参数的导数，因此函数的输出只有loss一项。<strong>当我们希望函数输出多项时，微分函数会求所有输出项对参数的导数</strong>。此时如果想实现对某个输出项的梯度截断，或消除某个Tensor对梯度的影响，需要用到Stop\r\nGradient操作。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>这里我们将<code>function</code>改为同时输出loss和z的<code>function_with_logits</code>，获得微分函数并执行。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function_with_logits</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, z</span><br><span class=\"line\"></span><br><span class=\"line\">grad_fn = mindspore.grad(function_with_logits, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function_stop_gradient</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, ops.stop_gradient(z)</span><br><span class=\"line\"></span><br><span class=\"line\">grad_fn = mindspore.grad(function_stop_gradient, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p><code>ops.stop_gradient(z)</code>:重点在该函数，表示屏蔽了z对梯度的影响，即仍只求参数对loss的导数。</p>\r\n<p>这里解释一下一些api的含义</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mindspore.grad(fn, grad_position=<span class=\"number\">0</span>, weights=<span class=\"literal\">None</span>, has_aux=<span class=\"literal\">False</span>, return_ids=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZ3JhZC5odG1sP2hpZ2hsaWdodD1ncmFkI21pbmRzcG9yZS5ncmFk\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mindspore.numpy.matmul(x1, x2, dtype=None)</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL251bXB5L21pbmRzcG9yZS5udW1weS5tYXRtdWwuaHRtbD9oaWdobGlnaHQ9bWF0bXVsI21pbmRzcG9yZS5udW1weS5tYXRtdWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n</ul>\r\n<h3 id=\"auxiliary-data\">Auxiliary data</h3>\r\n<p>Auxiliary\r\ndata意为辅助数据，是函数除第一个输出项外的其他输出。通常我们会将函数的loss设置为函数的第一个输出，其他的输出即为辅助数据。</p>\r\n<p><code>grad</code>和<code>value_and_grad</code>提供<code>has_aux</code>参数，当其设置为<code>True</code>时，可以自动实现前文手动添加<code>stop_gradient</code>的功能，满足返回辅助数据的同时不影响梯度计算的效果。</p>\r\n<p>下面仍使用<code>function_with_logits</code>，配置<code>has_aux=True</code>，并执行。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grad_fn = mindspore.grad(function_with_logits, (<span class=\"number\">2</span>, <span class=\"number\">3</span>), has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\">grads, (z,) = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads, z)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"神经网络梯度计算\">神经网络梯度计算</h3>\r\n<blockquote>\r\n<p>前述章节主要根据计算图对应的函数介绍了MindSpore的函数式自动微分，但我们的神经网络构造是继承自面向对象编程范式的<code>nn.Cell</code>。接下来我们通过<code>Cell</code>构造同样的神经网络，利用函数式自动微分来实现反向传播。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>首先我们继承<code>nn.Cell</code>构造单层线性变换神经网络。这里我们直接使用前文的𝑤、𝑏作为模型参数，使用<code>mindspore.Parameter</code>进行包装后，作为内部属性，并在<code>construct</code>内实现相同的Tensor操作。</p>\r\n</blockquote>\r\n<p>这里出现了反向传播方法,并且是包装好的,建议读者仔细看一下代码并尝试自己运行一下。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义神经网络模型</span></span><br><span class=\"line\"><span class=\"comment\"># Define model</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.w = w</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.b = b</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        z = ops.matmul(x, <span class=\"variable language_\">self</span>.w) + <span class=\"variable language_\">self</span>.b</span><br><span class=\"line\">        <span class=\"keyword\">return</span> z</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Instantiate model</span></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"comment\"># Instantiate loss function</span></span><br><span class=\"line\">loss_fn = nn.BCEWithLogitsLoss()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">x, y</span>):</span><br><span class=\"line\">    z = model(x)</span><br><span class=\"line\">    loss = loss_fn(z, y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注入损失函数</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, weights=model.trainable_params())</span><br><span class=\"line\">loss, grads = grad_fn(x, y)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"总结输出单次\">总结输出（单次）</h3>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0.92031693</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br><span class=\"line\">计算多个参数的导数</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]]), Tensor(shape=[3], dtype=Float32, value= [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]))</span><br><span class=\"line\">消除部分张量对梯度的影响</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br><span class=\"line\">Auxiliary data 辅助数据测试</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01])) [ 0.8580145   0.62723386 -0.44728255]      </span><br><span class=\"line\">开始实测网络模型的反向传播</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>可见，除了在计算z的导数对梯度的影响情况下，均保持了相同的输出，并且可以观察到w,b的权值</p>\r\n<h2 id=\"二值交叉熵损失\">二值交叉熵损失</h2>\r\n<p><strong><em>以下的对数均为自然对数</em></strong></p>\r\n<p>Binary cross entropy 二元<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Lqk5Y+J54a1\">交叉熵<i class=\"fa fa-external-link-alt\"></i></span>是二分类问题中常用的一个Loss损失函数，在常见的机器学习模块中都有实现。就二元交叉熵这个损失函数的原理，简单地进行解释。下面是二元交叉熵损失函数的公式\r\n<span class=\"math display\">\\[\r\nL=-\\frac1N \\sum_{i=1}^{N}[y_ilog(p_i)+(1-y_i)log(1-p_i)]\r\n\\]</span> 先不尝试理解他，先看看他是如何运作的</p>\r\n<p><img src=\"https://s2.loli.net/2024/06/07/MAOZxqKodRSW6uy.jpg\"\r\nalt=\"img\" /> <span class=\"math display\">\\[\r\nL=\\frac13[(1*log0.8+(1-1)*log(1-0.8))+(0*log0.2+(1-0)*log(1-0.2))+(0*log0.4+(1-0)*log(1-0.4))]=0.319\r\n\\\\\r\n\\]</span> 对于以上的案例计算损失函数，结果是0.31903</p>\r\n<h3 id=\"从熵来看交叉熵损失\">从熵来看交叉熵损失</h3>\r\n<h4 id=\"信息量\">信息量</h4>\r\n<p>信息量来衡量一个事件的不确定性，一个事件发生的概率越大，不确定性越小，则其携带的信息量就越小。</p>\r\n<p>设<span\r\nclass=\"math display\">\\[X\\]</span>是一个离散型随机变量，其取值为集合<span\r\nclass=\"math display\">\\[X =\r\n{x_0,x_1,\\dots,x_n}\\]</span>，则其概率分布函数为<span\r\nclass=\"math display\">\\[p(x) = Pr(X = x),x \\in\r\nX\\]</span>，则定义事件<span\r\nclass=\"math display\">\\[X=x_0\\]</span>的信息量为： <span\r\nclass=\"math display\">\\[\r\nI(x_0) = -\\log(p(x_0))\r\n\\]</span> 当<span class=\"math display\">\\[p(x_0) =\r\n1\\]</span>时，其携带的信息量为0。</p>\r\n<h4 id=\"熵\">熵</h4>\r\n<p>熵用来衡量一个系统的混乱程度，代表系统中信息量的总和；熵值越大，表明这个系统的不确定性就越大。具体而数学的讲，熵就是一个系统中所有信息量的期望。</p>\r\n<p>信息量是衡量某个事件的不确定性，而熵是衡量一个系统（所有事件）的不确定性。</p>\r\n<p>熵的计算公式 <span class=\"math display\">\\[\r\nH(x) = -\\sum_{i=1}^np(x_i)\\log(p(x_i))\r\n\\]</span> 比较特殊的有二项分布熵 <span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nH(X)&amp;=&amp;-\\sum_{i=1}^n p(x_i)log(p(x_i))\\\\\r\n&amp;=&amp;-p(x)log(p(x))-(1-p(x))log(1-p(x))\r\n\\end{eqnarray}\r\n\\]</span> <em>熵也有其他类型的计算公式，这里是信息学上的定义</em></p>\r\n<p>其中<span\r\nclass=\"math display\">\\[p(x)\\]</span>为这件事发生的概率，<span\r\nclass=\"math display\">\\[-log(p(x_i))\\]</span>是事件<span\r\nclass=\"math display\">\\[x_i\\]</span>所携带的信息量。</p>\r\n<p>可以看出，熵是信息量的期望值，是一个随机变量（一个系统，事件所有可能性）不确定性的度量。熵值越大，随机变量的取值就越难确定，系统也就越不稳定；熵值越小，随机变量的取值也就越容易确定，系统越稳定。</p>\r\n<h4 id=\"相对熵-relative-entropy-kl散度\">相对熵 （Relative entropy）/\r\nKL散度</h4>\r\n<p>wiki对相对熵的定义如下：<code>In the context of machine learning, DKL(P‖Q) is often called the information gain achieved if P is used instead of Q.</code></p>\r\n<p>即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。</p>\r\n<p>在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。</p>\r\n<p>总结：相对熵也称为KL散度(Kullback-Leibler\r\ndivergence)，表示同一个随机变量的两个不同分布间的距离。</p>\r\n<p>设 <span class=\"math display\">\\[p(x),𝑞(𝑥)\\]</span>分别是\r\n离散随机变量<span\r\nclass=\"math display\">\\[X\\]</span>的两个概率分布，则<span\r\nclass=\"math display\">\\[p\\]</span>对<span\r\nclass=\"math display\">\\[q\\]</span>的相对熵是： <span\r\nclass=\"math display\">\\[\r\nD_{KL}(p \\parallel q) = \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\r\n\\]</span> 相对熵具有以下性质：</p>\r\n<ul>\r\n<li>如果p(x)和q(x)的分布相同，则其相对熵等于0</li>\r\n<li><span\r\nclass=\"math display\">\\[D_{KL}(p∥q)≠D_{KL}(q∥p)𝐷_{𝐾𝐿}(𝑝∥𝑞)≠𝐷_{𝐾𝐿}(𝑞∥𝑝)\\]</span>，也就是相对熵不具有对称性。</li>\r\n<li><span class=\"math display\">\\[D_{KL}(p∥q)≥0\\]</span></li>\r\n</ul>\r\n<p>总的来说，相对熵是用来衡量同一个随机变量的两个不同分布之间的距离。<strong>在实际应用中，假如p(x)是目标真实的分布，而q(x)是预测得来的分布，为了让这两个分布尽可能的相同的，就需要最小化KL散度。</strong></p>\r\n<h4 id=\"交叉熵-cross-entropy\">交叉熵 Cross Entropy</h4>\r\n<p>设<span class=\"math display\">\\[p(x),q(x)\\]</span>分别是\r\n离散随机变量<span\r\nclass=\"math display\">\\[X\\]</span>的两个概率分布，其中<span\r\nclass=\"math display\">\\[p(x)\\]</span>是目标分布，<span\r\nclass=\"math display\">\\[p\\]</span>和<span\r\nclass=\"math display\">\\[q\\]</span>的交叉熵可以看做是，使用分布<span\r\nclass=\"math display\">\\[q(x)\\]</span>表示目标分布<span\r\nclass=\"math display\">\\[p(x)\\]</span>的困难程度 <span\r\nclass=\"math display\">\\[\r\nH(p,q) = \\sum_ip(x_i)log\\frac{1}{\\log q(x_i)} = -\\sum_ip(x_i)\\log q(x_i)\r\n\\]</span> 将熵、相对熵以及交叉熵的公式放到一起， <span\r\nclass=\"math display\">\\[\r\n\\begin{align}\r\nH(p) &amp;= -\\sum_{i}p(x_i) \\log p(x_i) \\\\\r\nD_{KL}(p \\parallel q) &amp;= \\sum_{i}p(x_i)\\log \\frac{p(x_i)}{q(x_i)} =\r\n\\sum_i (p(x_i)\\log p(x_i) - p(x_i) \\log q(x_i)) \\\\\r\nH(p,q) &amp;=  -\\sum_ip(x_i)\\log q(x_i)\r\n\\end{align}\r\n\\]</span> 通过上面三个公式就可以得到 <span class=\"math display\">\\[\r\nD_{KL}(p,q) = H(p,q)- H(p)\r\n\\]</span> 其中，前一项<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>就是<span\r\nclass=\"math display\">\\[p,q\\]</span>的交叉熵。在机器学习中，目标的分布<span\r\nclass=\"math display\">\\[p(x)\\]</span>通常是训练数据的分布是固定，即是<span\r\nclass=\"math display\">\\[H(p)\\]</span>是一个常量。这样两个分布的交叉熵<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>也就等价于最小化这两个分布的相对熵<span\r\nclass=\"math display\">\\[D_{KL}(p \\parallel q)\\]</span></p>\r\n<p>设<span\r\nclass=\"math display\">\\[p(x)\\]</span>是目标分布（训练数据的分布），我们的目标的就让训练得到的分布<span\r\nclass=\"math display\">\\[q(x)\\]</span>尽可能的接近<span\r\nclass=\"math display\">\\[p(x)\\]</span>，这时候就可以最小化<span\r\nclass=\"math display\">\\[D_{KL}(p∥q)\\]</span>，等价于最小化交叉熵<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>​。</p>\r\n<h3 id=\"为什么要用交叉熵做loss函数\">为什么要用交叉熵做loss函数</h3>\r\n<p>在线性回归问题中，常常使用MSE（Mean Squared\r\nError）作为loss函数，比如： <span class=\"math display\">\\[\r\nloss = \\frac{1}{2m}\\sum_{i=1}^m(y_i-\\hat{y_i})^2\r\n\\]</span> 这里的m表示m个样本的，loss为m个样本的loss均值。 MSE在<a\r\nhref=\"#%20回归问题\">线性回归问题</a>中比较好用，那么在逻辑分类问题中还是如此么？</p>\r\n<h3 id=\"交叉熵在单分类问题中的使用\">交叉熵在单分类问题中的使用</h3>\r\n<p>这里的单类别是指，每一张图像样本只能有一个类别，比如只能是狗或只能是猫。\r\n交叉熵在单分类问题上基本是标配的方法 <span class=\"math display\">\\[\r\nloss=-\\sum_{i=1}^{n}y_ilog(\\hat{y_i})\r\n\\]</span> 上式为一张样本的loss计算方法。n代表着n种类别。\r\n举例说明,比如有如下样本</p>\r\n<p>对应的标签和预测值</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>*</th>\r\n<th>猫</th>\r\n<th>青蛙</th>\r\n<th>老鼠</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Label</td>\r\n<td>0</td>\r\n<td>1</td>\r\n<td>0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Pred</td>\r\n<td>0.3</td>\r\n<td>0.6</td>\r\n<td>0.1</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nloss&amp;=&amp;-(0\\times log(0.3)+1\\times log(0.6)+0\\times log(0.1)\\\\\r\n&amp;=&amp;-log(0.6)\r\n\\end{eqnarray}\r\n\\]</span> 对应的一个batch的loss就是 <span class=\"math display\">\\[\r\nloss=-\\frac{1}{m}\\sum_{j=1}^m\\sum_{i=1}^{n}y_{ji}log(\\hat{y_{ji}})\r\n\\]</span> m为当前batch的样本数</p>\r\n<h3 id=\"交叉熵在多分类问题中的使用\">交叉熵在多分类问题中的使用</h3>\r\n<p>这里的多类别是指，每一张图像样本可以有多个类别，比如同时包含一只猫和一只狗\r\n和单分类问题的标签不同，多分类的标签是n-hot。\r\n比如下面这张样本图，即有青蛙，又有老鼠，所以是一个多分类问题</p>\r\n<p>栗子</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>*</th>\r\n<th>猫</th>\r\n<th>青蛙</th>\r\n<th>老鼠</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Label</td>\r\n<td>0</td>\r\n<td>1</td>\r\n<td>1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Pred</td>\r\n<td>0.1</td>\r\n<td>0.7</td>\r\n<td>0.8</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>值得注意的是，这里的Pred不再是通过softmax计算的了，这里采用的是sigmoid。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。换句话说，就是每一个Label都是独立分布的，相互之间没有影响。所以交叉熵在这里是单独对每一个节点进行计算，每一个节点只有两种可能值，所以是一个二项分布。前面说过对于二项分布这种特殊的分布，熵的计算可以进行简化。</p>\r\n<p>同样的，交叉熵的计算也可以简化，即 <span class=\"math display\">\\[\r\nloss =-ylog(\\hat{y})-(1-y)log(1-\\hat{y})\r\n\\]</span>\r\n注意，上式只是针对一个节点的计算公式。这一点一定要和单分类loss区分开来。\r\n例子中可以计算为： <span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nloss_猫 &amp;=&amp;-0\\times log(0.1)-(1-0)log(1-0.1)=-log(0.9)\\\\\r\nloss_蛙 &amp;=&amp;-1\\times log(0.7)-(1-1)log(1-0.7)=-log(0.7)\\\\\r\nloss_鼠 &amp;=&amp;-1\\times log(0.8)-(1-1)log(1-0.8)=-log(0.8)\r\n\\end{eqnarray}\r\n\\]</span> 单张样本的loss即为 每一个batch的loss就是： <span\r\nclass=\"math display\">\\[\r\nloss\r\n=\\sum_{j=1}^{m}\\sum_{i=1}^{n}-y_{ji}log(\\hat{y_{ji}})-(1-y_{ji})log(1-\\hat{y_{ji}})\r\n\\]</span> 式中m为当前batch中的样本量，n为类别数。</p>\r\n<h3 id=\"从最大似然看交叉熵\">从<a\r\nhref=\"#%20最大似然估计\">最大似然</a>看交叉熵</h3>\r\n<p>设有一组训练样本<span class=\"math inline\">\\(X=\r\n\\{x_1,x_2,\\cdots,x_m\\}\\)</span> ,该样本的分布为<span\r\nclass=\"math inline\">\\(p(x)\\)</span> 。假设使用<span\r\nclass=\"math inline\">\\(\\theta\\)</span> 参数化模型得到<span\r\nclass=\"math inline\">\\(q(x;\\theta)\\)</span> ，现用这个模型来估计<span\r\nclass=\"math inline\">\\(X\\)</span> 的概率分布，得到似然函数 <span\r\nclass=\"math display\">\\[\r\nL(\\theta) = q(X; \\theta) = \\prod_i^mq(x_i;\\theta)\r\n\\]</span> 最大似然估计就是求得<span\r\nclass=\"math inline\">\\(\\theta\\)</span> 使得<span\r\nclass=\"math inline\">\\(L(\\theta)\\)</span> 的值最大，也就是 <span\r\nclass=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_{\\theta} \\prod_i^mq(x_i;\\theta)\r\n\\]</span> 对上式的两边同时取<span class=\"math inline\">\\(\\log\\)</span>\r\n，等价优化<span class=\"math inline\">\\(\\log\\)</span>\r\n的最大似然估计即<code>log-likelyhood</code> ，最大对数似然估计 <span\r\nclass=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_\\theta \\sum_i^m \\log q(x_i;\\theta)\r\n\\]</span> 对上式的右边进行缩放并不会改变<span class=\"math inline\">\\(arg\r\n\\max\\)</span> 的解，上式的右边除以样本的个数<span\r\nclass=\"math inline\">\\(m\\)</span> <span class=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_\\theta \\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\r\n\\]</span></p>\r\n<h4 id=\"和相对熵等价\">和相对熵等价</h4>\r\n<p>上式的最大化<span class=\"math inline\">\\(\\theta_{ML}\\)</span>\r\n是和没有训练样本没有关联的，就需要某种变换使其可以用训练的样本分布来表示，因为训练样本的分布可以看作是已知的，也是对最大化似然的一个约束条件。</p>\r\n<p>注意上式的 <span class=\"math display\">\\[\r\n\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\r\n\\]</span> 相当于<strong>求随机变量<span class=\"math inline\">\\(X\\)</span>\r\n的函数<span class=\"math inline\">\\(\\log (X;\\theta)\\)</span>\r\n的均值</strong>\r\n，根据大数定理，<strong>随着样本容量的增加，样本的算术平均值将趋近于随机变量的期望。</strong>\r\n也就是说 <span class=\"math display\">\\[\r\n\\frac{1}{m}\\sum_i^m \\log q(x_i;\\theta) \\rightarrow E_{x\\sim P}(\\log\r\nq(x;\\theta))\r\n\\]</span> 其中<span class=\"math inline\">\\(E_{X\\sim P}\\)</span>\r\n表示符合样本分布<span class=\"math inline\">\\(P\\)</span>\r\n的期望，这样就将最大似然估计使用真实样本的期望来表示 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned} \\theta_{ML} &amp;= arg \\max_{\\theta} E_{x\\sim P}({\\log\r\nq(x;\\theta)}) \\\\ &amp;= arg \\min_{\\theta} E_{x \\sim P}(- \\log\r\nq(x;\\theta)) \\end{aligned}\r\n\\]</span> 对右边取负号，将最大化变成最小化运算。</p>\r\n<blockquote>\r\n<p>上述的推导过程，可以参考 《Deep Learning》 的第五章。\r\n但是，在书中变为期望的只有一句话，将式子的右边除以样本数量<span\r\nclass=\"math inline\">\\(m\\)</span> 进行缩放，从而可以将其变为<span\r\nclass=\"math inline\">\\(E_{x \\sim p}\\log\r\nq(x;\\theta)\\)</span>，没有细节过程，也可能是作者默认上面的变换对读者是一直。\r\n确实是理解不了，查了很多文章，都是对这个变换的细节含糊其辞。一个周，对这个点一直耿耿于怀，就看了些关于概率论的科普书籍，其中共有介绍大数定理的：<strong>当样本容量趋于无穷时，样本的均值趋于其期望</strong>。</p>\r\n<p>针对上面公式，除以<span class=\"math inline\">\\(m\\)</span>后，<span\r\nclass=\"math inline\">\\(\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\\)</span>\r\n，确实是关于随机变量函数<span class=\"math inline\">\\(\\log q(x)\\)</span>\r\n的算术平均值，而<span class=\"math inline\">\\(x\\)</span>\r\n是训练样本其分布是已知的<span class=\"math inline\">\\(p(x)\\)</span>\r\n，这样就得到了<span class=\"math inline\">\\(E_{x \\sim p}(\\log\r\nq(x))\\)</span> 。</p>\r\n</blockquote>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned} D_{KL}(p \\parallel q) &amp;= \\sum_i p(x_i)\r\nlog(\\frac{p(x_i)}{q(x_i)})\\\\ &amp;= E_{x\\sim p}(\\log \\frac{p(x)}{q(x)})\r\n\\\\ &amp;= E_{x \\sim p}(\\log p(x) - \\log q(x)) \\\\ &amp;= E_{x \\sim\r\np}(\\log p(x)) - E_{x \\sim p} (\\log q(x)) \\end{aligned}\r\n\\]</span></p>\r\n<p>由于<span class=\"math inline\">\\(E_{x \\sim p} (\\log p(x))\\)</span>\r\n是训练样本的期望，是个固定的常数，在求最小值时可以忽略，所以最小化<span\r\nclass=\"math inline\">\\(D_{KL}(p \\parallel q)\\)</span> 就变成了最小化<span\r\nclass=\"math inline\">\\(-E_{x\\sim p}(\\log q(x))\\)</span>\r\n，这和最大似然估计是等价的。</p>\r\n<h4 id=\"和交叉熵等价\">和交叉熵等价</h4>\r\n<p>最大似然估计、相对熵、交叉熵的公式如下 <span class=\"math display\">\\[\r\n\\begin{aligned}\\theta_{ML} &amp;= -arg \\min_\\theta E_{x\\sim p}\\log\r\nq(x;\\theta) \\\\D_{KL} &amp;= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log\r\nq(x) \\\\H(p,q) &amp;= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log\r\nq(x)\\end{aligned}\\begin{aligned}\\theta_{ML} &amp;= arg \\min_\\theta\r\nE_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &amp;= E_{x \\sim p}\\log p(x) - E_{x\r\n\\sim p} \\log q(x) \\\\H(p,q) &amp;= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x\r\n\\sim p} \\log q(x)\\end{aligned}\r\n\\]</span> 从上面可以看出，最小化交叉熵，也就是最小化<span\r\nclass=\"math inline\">\\(D_{KL}\\)</span> ，从而预测的分布<span\r\nclass=\"math inline\">\\(q(x)\\)</span> 和训练样本的真实分布<span\r\nclass=\"math inline\">\\(p(x)\\)</span> 最接近。而最小化<span\r\nclass=\"math inline\">\\(D_{KL}\\)</span> 和最大似然估计是等价的。</p>\r\n<h3 id=\"多分类交叉熵\">多分类交叉熵</h3>\r\n<p>多分类任务中输出的是目标属于<strong>每个类别的概率，所有类别概率的和为1，其中概率最大的类别就是目标所属的分类。</strong>\r\n而<code>softmax</code> 函数能将一个向量的每个分量映射到<span\r\nclass=\"math inline\">\\([0,1]\\)</span>\r\n区间，并且对整个向量的输出做了归一化，保证所有分量输出的和为1，正好满足多分类任务的输出要求。所以，在多分类中，在最后就需要将提取的到特征经过<code>softmax</code>函数的，输出为每个类别的概率，然后再使用<strong>交叉熵</strong>\r\n作为损失函数。</p>\r\n<p><code>softmax</code>函数定义如下： <span class=\"math display\">\\[\r\nS_i = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\r\n\\]</span> 其中，输入的向量为<span class=\"math inline\">\\(z_i(i =\r\n1,2,\\dots,n)\\)</span> 。</p>\r\n<p>更直观的参见下图</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/XvLsuFKjBe39AaD.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>通过前面的特征提取到的特征向量为<span\r\nclass=\"math inline\">\\((z_1,z_2,\\dots,z_k)\\)</span>\r\n，将向量输入到<code>softmax</code>函数中，即可得到目标属于每个类别的概率，概率最大的就是预测得到的目标的类别。</p>\r\n<h4 id=\"cross-entropy-loss\">Cross Entropy Loss</h4>\r\n<p>使用<code>softmax</code>函数可以将特征向量映射为所属类别的概率，可以看作是预测类别的概率分布<span\r\nclass=\"math inline\">\\(q(c_i)\\)</span> ，有 <span class=\"math display\">\\[\r\nq(c_i) = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\r\n\\]</span> 其中<span class=\"math inline\">\\(c_i\\)</span> 为某个类别。</p>\r\n<p>设训练数据中类别的概率分布为<span\r\nclass=\"math inline\">\\(p(c_i)\\)</span> ，那么目标分布<span\r\nclass=\"math inline\">\\(p(c_i)\\)</span> 和预测分布<span\r\nclass=\"math inline\">\\(q(c_i)\\)</span>的交叉熵为</p>\r\n<p><span class=\"math display\">\\[H(p,q) =-\\sum_ip(c_i)\\log q(c_i)\r\n\\]</span></p>\r\n<p>每个训练样本所属的类别是已知的，并且每个样本只会属于一个类别（概率为1），属于其他类别概率为0。具体的，可以假设有个三分类任务，三个类分别是：猫，猪，狗。现有一个训练样本类别为猫，则有：</p>\r\n<p><span class=\"math display\">\\[\\begin{align} p(cat) &amp; = 1 \\\\ p(pig)\r\n&amp;= 0 \\\\ p(dog) &amp; = 0 \\end{align} \\]</span></p>\r\n<p>通过预测得到的三个类别的概率分别为：<span\r\nclass=\"math inline\">\\(q(cat) = 0.6,q(pig) = 0.2,q(dog) = 0.2\\)</span>\r\n，计算<span class=\"math inline\">\\(p\\)</span> 和<span\r\nclass=\"math inline\">\\(q\\)</span> 的交叉熵为： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned} H(p,q) &amp;= -(p(cat) \\log q(cat) + p(pig) + \\log\r\nq(pig) + \\log q(dog)) \\\\ &amp;= - (1 \\cdot \\log 0.6 + 0 \\cdot \\log 0.2\r\n+0 \\cdot \\log 0.2) \\\\ &amp;= - \\log 0.6 \\\\ &amp;= - \\log q(cat)\r\n\\end{aligned}\r\n\\]</span>\r\n利用这种特性，可以将样本的类别进行重新编码，就可以简化交叉熵的计算，这种编码方式就是<strong>one-hot</strong>\r\n编码。以上面例子为例， <span class=\"math display\">\\[\r\n\\begin{aligned} \\text{cat} &amp;= (1 0 0) \\\\ \\text{pig} &amp;= (010) \\\\\r\n\\text{dog} &amp;= (001) \\end{aligned}\r\n\\]</span></p>\r\n<p>通过这种编码方式，在计算交叉熵时，只需要计算和训练样本对应类别预测概率的值，其他的项都是<span\r\nclass=\"math inline\">\\(0 \\cdot \\log q(c_i) = 0\\)</span> 。</p>\r\n<p>具体的，交叉熵计算公式变成如下： <span class=\"math display\">\\[\r\n(p,q) = - \\log q(c_i)\r\n\\]</span> 其中<span class=\"math inline\">\\(c_i\\)</span>\r\n为训练样本对应的类别，上式也被称为<strong>负对数似然（negative\r\nlog-likelihood,nll）</strong>。</p>\r\n<h4 id=\"pytorch中的cross-entropy\">PyTorch中的Cross Entropy</h4>\r\n<p>PyTorch中实现交叉熵损失的有三个函数<code>torch.nn.CrossEntropyLoss</code>，<code>torch.nn.LogSoftmax</code>以及<code>torch.nn.NLLLoss</code>。</p>\r\n<ul>\r\n<li><code>torch.nn.functional.log_softmax</code> 比较简单，输入为<span\r\nclass=\"math inline\">\\(n\\)</span>维向量，指定要计算的维度<code>dim</code>，输出为<span\r\nclass=\"math inline\">\\(log(Softmax(x))\\)</span>。其计算公式如下：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\text{LogSoftmax}(x_i) = \\log (\\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)})\r\n\\]</span></p>\r\n<p>没有额外的处理，就是对输入的<span\r\nclass=\"math inline\">\\(n\\)</span>维向量的每个元素进行上述运算。</p>\r\n<ul>\r\n<li><code>torch.nn.functional.nll_loss</code> 负对数似然损失（Negative\r\nLog Likelihood\r\nLoss)，用于多分类，其输入的通常是<code>torch.nn.functional.log_softmax</code>的输出值。其函数如下</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">torch.nn.functional.nll_loss(<span class=\"built_in\">input</span>, target, weight=<span class=\"literal\">None</span>, size_average=<span class=\"literal\">None</span>, ignore_index=-<span class=\"number\">100</span>, reduce=<span class=\"literal\">None</span>, reduction=<span class=\"string\">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p><code>input</code>\r\n也就是<code>log_softmax</code>的输出值，各个类别的对数概率。<code>target</code>\r\n目标正确类别,<code>weight</code>\r\n针对类别不平衡问题，可以为类别设置不同的权值；<code>ignore_index</code>\r\n要忽略的类别，不参与loss的计算；比较重要的是<code>reduction</code>\r\n的值，有三个取值：<code>none</code>\r\n不做处理，输出的结果为向量；<code>mean</code>\r\n将<code>none</code>结果求均值后输出；<code>sum</code>\r\n将<code>none</code> 结果求和后输出。</p>\r\n<ul>\r\n<li><code>torch.nn.CrossEntropyLoss</code>就是上面两个函数的组合<code>nll_loss(log_softmax(input))</code>。</li>\r\n</ul>\r\n<h3 id=\"二分类交叉熵\">二分类交叉熵</h3>\r\n<p>多分类中使用<code>softmax</code>函数将最后的输出映射为每个类别的概率，而在二分类中则通常使用<code>sigmoid</code>\r\n将输出映射为正样本的概率。这是因为二分类中，只有两个类别：{正样本，负样本}，只需要求得正样本的概率<span\r\nclass=\"math inline\">\\(q\\)</span>,则<span\r\nclass=\"math inline\">\\(1-q\\)</span>\r\n就是负样本的概率。这也是多分类和二分类不同的地方。</p>\r\n<p><span class=\"math inline\">\\(\\text{sigmoid}\\)</span>\r\n函数的表达式如下： <span class=\"math display\">\\[\r\n\\sigma(z) = \\frac{1}{1 + e^{-z}}\r\n\\]</span> sigmoid的输入为<span class=\"math inline\">\\(z\\)</span>\r\n，其输出为<span class=\"math inline\">\\((0,1)\\)</span>\r\n，可以表示分类为正样本的概率。</p>\r\n<p>二分类的交叉熵可以看作是交叉熵损失的一个特列，交叉熵为 <span\r\nclass=\"math display\">\\[\r\n\\text{$Cross\\_Entorpy$}(p,q) = -\\sum_i^m p(x_i) \\log q(x_i)\r\n\\]</span> 这里只有两个类别<span class=\"math inline\">\\(x \\in\r\n{x_1,x_2}\\)</span> ，则有 <span class=\"math display\">\\[\r\n\\begin{aligned}\\text{$Cross\\_Entorpy$}(p,q) &amp;= -(p(x_1) \\log q(x_1)\r\n+ p(x_2) \\log q(x_2)) \\end{aligned}\r\n\\]</span></p>\r\n<p>因为只有两个选择，则有<span class=\"math inline\">\\(p(x_1) + p(x_2) =\r\n1,q(x_1) + q(x_2) = 1\\)</span> 。设，训练样本中<span\r\nclass=\"math inline\">\\(x_1\\)</span>的概率为<span\r\nclass=\"math inline\">\\(p\\)</span>，则<span\r\nclass=\"math inline\">\\(x_2\\)</span>为<span\r\nclass=\"math inline\">\\(1-p\\)</span>; 预测的<span\r\nclass=\"math inline\">\\(x_1\\)</span>的概率为<span\r\nclass=\"math inline\">\\(q\\)</span>，则<span\r\nclass=\"math inline\">\\(x_2\\)</span>的预测概率为<span\r\nclass=\"math inline\">\\(1 - q\\)</span> 。则上式可改写为 <span\r\nclass=\"math display\">\\[\r\n\\text{$Cross\\_Entropy$}(p,q) = -(p \\log q + (1-p) \\log (1-q))\r\n\\]</span> 也就是二分类交叉熵的损失函数。</p>\r\n<h3 id=\"总结\">总结</h3>\r\n<p>相对熵可以用来度量两个分布相似性，假设分布<span\r\nclass=\"math inline\">\\(p\\)</span>是训练样本的分布，<span\r\nclass=\"math inline\">\\(q\\)</span>是预测得到的分布。分类训练的过程实际上就是最小化<span\r\nclass=\"math inline\">\\(D_{KL}(p \\parallel q)\\)</span>，由于由于交叉熵\r\n<span class=\"math display\">\\[\r\nH(p,q)= D_{KL}(p \\parallel q) + H(p)\r\n\\]</span> 其中,<span\r\nclass=\"math inline\">\\(H(p)\\)</span>是训练样本的熵，是一个已知的常量，这样最小化相对熵就等价于最小化交叉熵。</p>\r\n<p>从最大似然估计转化为最小化负对数似然 <span class=\"math display\">\\[\r\n\\theta_{ML} = -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta)\r\n\\]</span> 也等价于最小化相对熵。</p>\r\n<h2 id=\"回归问题\">回归问题</h2>\r\n<p>回归：人们在测量事物的时候因为客观条件所限，求得的都是测量值，而不是事物真实的值，为了能够得到真实值，无限次的进行测量，最后通过这些测量数据计算<strong>回归到真实值</strong>，这就是回归的由来。</p>\r\n<p>回归分析的主要算法包括：</p>\r\n<ol type=\"1\">\r\n<li>线性回归(Linear Regression)</li>\r\n<li>逻辑回归（Logistic regressions）</li>\r\n<li>多项式回归(Polynomial Regression)</li>\r\n<li>逐步回归(Step Regression)</li>\r\n<li>岭回归(Ridge Regression)</li>\r\n<li>套索回归(Lasso Regression)</li>\r\n<li>弹性网回归(ElasticNet)</li>\r\n</ol>\r\n<h2 id=\"最大似然估计\">最大似然估计</h2>\r\n<p>wiki定义：<code>在统计学中，最大似然估计（英语：maximum likelihood estimation，简作MLE），也称极大似然估计，是用来估计一个概率模型的参数的一种方法。</code></p>\r\n<h3 id=\"原理\">原理</h3>\r\n<p>给定一个概率分布𝐷，已知其<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5qaC546H5a+G5bqm5Ye95pWw\">概率密度函数<i class=\"fa fa-external-link-alt\"></i></span>（连续分布）或<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5qaC546H6LSo6YeP5Ye95pWw\">概率质量函数<i class=\"fa fa-external-link-alt\"></i></span>（离散分布）为𝑓𝐷，以及一个分布参数𝜃，我们可以从这个分布中抽出一个具有𝑛个值的采样𝑋1,𝑋2,…,𝑋𝑛，利用𝑓𝐷计算出其<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Ly854S25Ye95pWw\">似然函数<i class=\"fa fa-external-link-alt\"></i></span>：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a9702eeec5a8eb416883af66665ac11bd8151f0f\"\r\nalt=\"{(x_{1},,x_{n})=f_{}(x_{1},,x_{n}).}\" />\r\n<figcaption\r\naria-hidden=\"true\">{(x_{1},,x_{n})=f_{}(x_{1},,x_{n}).}</figcaption>\r\n</figure>\r\n<p>若𝐷是离散分布，𝑓𝜃即是在参数为𝜃时观测到这一采样的概率；若其是连续分布，𝑓𝜃则为𝑋1,𝑋2,…,𝑋𝑛联合分布的概率密度函数在观测值处的取值。一旦我们获得𝑋1,𝑋2,…,𝑋𝑛，我们就能求得一个关于𝜃的估计。最大似然估计会寻找关于𝜃的最可能的值（即，在所有可能的𝜃取值中，寻找一个值使这个采样的“可能性”最大化）。从数学上来说，我们可以在𝜃的所有可能取值中寻找一个值使得似然<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Ye95pWw\">函数<i class=\"fa fa-external-link-alt\"></i></span>取到最大值。这个使可能性最大的<span\r\nclass=\"math display\">\\[\\hat\r\n𝜃\\]</span>值即称为𝜃的<strong>最大似然估计</strong>。由定义，最大似然估计是样本的函数。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5pyA5aSn5Ly854S25Lyw6K6h\">最大似然估计 -\r\n维基百科，自由的百科全书 (wikipedia.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n","length":8376,"excerpt":"<h2 id=\"函数式自动微分\">函数式自动微分</h2>\r\n<blockquote>\r\n<p>神经网络的训练主要使用反向传播算法，模型预测值（logits）与正确标签（label）送入损失函数（loss\r\nfunction）获得loss，然后进行反向传播计算，求得梯度（gradients），最终更新至模型参数（parameters）。自动微分能够计算可导函数在某点处的导数值，是反向传播算法的一般化。自动微分主要解决的问题是将一个复杂的数学运算分解为一系列简单的基本运算，该功能对用户屏蔽了大量的求导细节和过程，大大降低了框架的使用门槛。</p>\r\n</blockquote>","more":"<blockquote>\r\n<p>MindSpore使用函数式自动微分的设计理念，提供更接近于数学语义的自动微分接口<code>grad</code>和<code>value_and_grad</code>。下面我们使用一个简单的单层线性变换模型进行介绍。</p>\r\n</blockquote>\r\n<p>这里总算是提到了反向传播，最近我看到了一系列视频有关Machine\r\nLearning，传送门如下：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1JbGczZ0dld1E1VQ==\">🔴 World of\r\nWarships / USS Des Moines cut (youtube.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>如果你试图看下去的话，可能会发现，事情好像突然变难了，似乎一群从未见过的知识组合在了一起，神经网络就像一个黑箱连着另一个黑箱，而你根本不知道如何优化它，使得黑箱在给定的输入下输出正确答案</p>\r\n<h2 id=\"神经网络到底代表了什么\">神经网络到底代表了什么</h2>\r\n<p>首先让我们定义什么是神经：他是一个携带一个浮点数的结构，然后让我们看向神经网络</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/MLN1Ap2wslU4SQB.jpg\" alt=\"R\" />\r\n<figcaption aria-hidden=\"true\">R</figcaption>\r\n</figure>\r\n<p>对于每一个点，我们从最后看起，显然，他们代表0-9，更准确的说，他们代表0-9的图像。为什么这样的网络是生效的呢？</p>\r\n<p><strong><em>因为分形思想</em></strong>，我们将一段连续的图像区分为一段一段，比如9是⚪在上而线条在下。4由多端线段1组成。而⚪和线条又可以继续再分，我们可以将神经网络中的每一个节点代表的数据想象成这种规律图案的集合。他们之间的传递就是图案在网络中不断组合。这也是为什么在网络中使用全连接的原因，因为每一个图案都能与其他任何图案组合。最终我们使图案变成了不断分形像素的组合。</p>\r\n<p>但如何做到这一点呢？ 考虑我们前面提到的参数，权值。</p>\r\n<figure>\r\n<img\r\nsrc=\"./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240607181215798.png\"\r\nalt=\"image-20240607181215798\" />\r\n<figcaption aria-hidden=\"true\">image-20240607181215798</figcaption>\r\n</figure>\r\n<p>这张图相信有很多人见过类似的图，实际上权值代表的就是神经网络之间的连线，假设我们让正权值在下表中为绿负权值在下表中为红，我们将这样描述一条“线段”：一段由红色包围的长条状绿色区域这样我们就能得出，如果这段线条是成立得话，比如确实原图这里存在一条线段，我们得到的这个神经节点上得值就会很接近1，否则就会很接近零。这就是权值得意义。但同时，我们会注意到神经得值是许多这样计算的累和，因此我们需要一个bias，偏差值将其计算到到0-1。</p>\r\n<p>注意这里得权值和偏差值均是变量，是训练出来的。并且注意，我们并不知道机器是如何分形得，这取决于学习数据和使用的算法，以上只为举例理解。</p>\r\n<p>如果将最初得神经网络拿去使用，你只会得到一大堆垃圾数据。我们都知道神经网络存在“进化”过程，但他是如何知道自己错得有多离谱的呢？</p>\r\n<h2 id=\"cost-functionmaybe-also-loss-function\">Cost Function（Maybe also\r\nloss function?）</h2>\r\n<p>初略的定义是他是输出的张量与正确的张量的差值平方和，比如，机器输出了一个全是0.5的10个数的张量，而正确答案是其中之一，那么\r\n<span class=\"math display\">\\[\r\n\\text{Cost} = (1-0.5) + 0.5*9\r\n\\]</span> 显然这个数字更接近0，说明结果更加准确</p>\r\n<p>考虑如何让模型表现得更好，显然是需要找到一组参数，使得每次输出的cost值最小。我们可以考虑这样一种方式，以参数作为输入，cost的值作为输出，而训练数据则是参数。</p>\r\n<h3 id=\"梯度下降-gradient-descent\">梯度下降 (Gradient Descent)</h3>\r\n<p>似乎难以理解，假设我们只有一个参数cost=f(c)，c是唯一的参数。于是变为了函数的最值问题，只需要求导数然后慢慢移动我们的初始点。很显然，一个函数在常数域上可能存在多个极大值而只有一个最大值。当我们从一个点出发寻找最大值时，很有可能（概率学上讲应该是绝对）我们只会找到一个极大值。即在神经网络中，我们不能保证我们的参数是最优的，只能保证我们的参数是局部最优的（这取决于我们的起始点）。</p>\r\n<p>变到多维，我们意识到，一个数的导数是否只有正或负两种信息有效（代表是应该增加这个数还是减少这个数）。假定两个变量在一个点上的导数其中一个是另一个的三倍，这至少说明在该点的邻域内，这一变量应该减少的更多是正确的。（可能有一些函数存在极端的尖点导致错误，但这在神经网络中是低概率的，掌控好更改数据的大小即可）。</p>\r\n<p>一个简单的例子是，维护好一个<span class=\"math display\">\\[\\nabla\r\nC\\]</span>矩阵，一阶导数对应的值高则其增加，反之则减少。</p>\r\n<h2 id=\"反向传播\">反向传播</h2>\r\n<p>从特殊到一般，我们先观察这样一个样例</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/SJ5Rf7m6cXFs8yN.png\"\r\nalt=\"image-20240607205110764\" />\r\n<figcaption aria-hidden=\"true\">image-20240607205110764</figcaption>\r\n</figure>\r\n<p>显然我们需要增加2，并且如果给我们要做的事情做出一个排序，增加2显然排在减少8之前。</p>\r\n<p>因此，让我们继续看增加2所涉及的值</p>\r\n<ol type=\"1\">\r\n<li>更改偏差值</li>\r\n<li>更改权值（根据节点值）</li>\r\n<li>更改上一层节点的值（根据权值）</li>\r\n</ol>\r\n<p>我们对权值和边权同时改变，并统计下一层节点需要的变化对上一层的节点影响的累和</p>\r\n<p>通过多组数据得出权值的总共改变值改变值。这就是随机梯度下降（Stochastic\r\ngradient descent）</p>\r\n<p>下面简单讲一讲其他的名词解释</p>\r\n<h2 id=\"mini-batches\">Mini-batches</h2>\r\n<p>和他的名字一样，这个技术就是将训练数据分为几组以提高收敛参数的效率</p>\r\n<h2 id=\"backpropagation\">Backpropagation</h2>\r\n<p>反向传播是一种梯度下降法的应用，通过链式法则计算损失函数相对于每个权重的梯度，然后利用这些梯度来更新权重。</p>\r\n<h2 id=\"函数与计算图\">函数与计算图</h2>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/iqHnjI12DSKR6P7.png\"\r\nalt=\"compute-graph\" />\r\n<figcaption aria-hidden=\"true\">compute-graph</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>计算图是用图论语言表示数学函数的一种方式，也是深度学习框架表达神经网络模型的统一方法。我们将根据下面的计算图构造计算函数和神经网络。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>在这个模型中，𝑥为输入，𝑦为正确值，𝑤和𝑏是我们需要优化的参数。</p>\r\n</blockquote>\r\n<ol type=\"1\">\r\n<li>𝑥为输入</li>\r\n<li>𝑦为正确值</li>\r\n<li>𝑤和𝑏是我们需要优化的参数</li>\r\n</ol>\r\n<p>即对应了原始数据，输出结果，权重和偏差</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = ops.ones(<span class=\"number\">5</span>, mindspore.float32)  <span class=\"comment\"># input tensor</span></span><br><span class=\"line\">y = ops.zeros(<span class=\"number\">3</span>, mindspore.float32)  <span class=\"comment\"># expected output</span></span><br><span class=\"line\">w = Parameter(Tensor(np.random.randn(<span class=\"number\">5</span>, <span class=\"number\">3</span>), mindspore.float32), name=<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"comment\"># weight</span></span><br><span class=\"line\">b = Parameter(Tensor(np.random.randn(<span class=\"number\">3</span>,), mindspore.float32), name=<span class=\"string\">&#x27;b&#x27;</span>) <span class=\"comment\"># bias</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>我们根据计算图描述的计算过程，构造计算函数。 其中，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLmJpbmFyeV9jcm9zc19lbnRyb3B5X3dpdGhfbG9naXRzLmh0bWw=\">binary_cross_entropy_with_logits<i class=\"fa fa-external-link-alt\"></i></span>\r\n是一个损失函数，计算预测值和目标值之间的二值交叉熵损失。</p>\r\n</blockquote>\r\n<p>解释一下Parameter(): <strong>Parameter</strong> 是 Tensor\r\n的子类，当它们被绑定为Cell的属性时，会自动添加到其参数列表中，并且可以通过Cell的某些方法获取，例如\r\ncell.get_<strong>parameter</strong>s() 。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\">loss = function(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(loss)</span><br></pre></td></tr></table></figure>\r\n<p>这里有复杂概念<a\r\nhref=\"#二值交叉熵损失\"><em>二值交叉熵损失</em></a>，如果你不想深究只需要这是一个对参数的函数，当这个函数值最低时，整体参数就是一个准确率较高的局部最优解即可。</p>\r\n<h2 id=\"微分函数与梯度计算\">微分函数与梯度计算</h2>\r\n<blockquote>\r\n<p>为了优化模型参数，需要求参数对loss的导数：<span\r\nclass=\"math display\">\\[\\frac{𝜕loss}{𝜕𝑤}\\]</span>和<span\r\nclass=\"math display\">\\[\\frac{𝜕loss}{𝜕𝑏}\\]</span>，此时我们调用<code>mindspore.grad</code>函数，来获得<code>function</code>的微分函数。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>这里使用了<code>grad</code>函数的两个入参，分别为：</p>\r\n<ul>\r\n<li><code>fn</code>：待求导的函数。</li>\r\n<li><code>grad_position</code>：指定求导输入位置的索引。</li>\r\n</ul>\r\n</blockquote>\r\n<blockquote>\r\n<p>由于我们对<span class=\"math display\">\\[𝑤\\]</span>和<span\r\nclass=\"math display\">\\[𝑏\\]</span>​求导，因此配置其在<code>function</code>入参对应的位置<code>(2, 3)</code>。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p><em>使用<code>grad</code>获得微分函数是一种函数变换，即输入为函数，输出也为函数。</em></p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grad_fn = mindspore.grad(function, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]]), Tensor(shape=[3], dtype=Float32, value= [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]))</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>执行微分函数，即可获得<span class=\"math display\">\\[𝑤\\]</span>、<span\r\nclass=\"math display\">\\[𝑏\\]</span>​对应的梯度。可以注意到w,b的梯度与最初始的梯度是一致的。</p>\r\n<h3 id=\"stop-gradient\">Stop Gradient</h3>\r\n<blockquote>\r\n<p>通常情况下，求导时会求loss对参数的导数，因此函数的输出只有loss一项。<strong>当我们希望函数输出多项时，微分函数会求所有输出项对参数的导数</strong>。此时如果想实现对某个输出项的梯度截断，或消除某个Tensor对梯度的影响，需要用到Stop\r\nGradient操作。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>这里我们将<code>function</code>改为同时输出loss和z的<code>function_with_logits</code>，获得微分函数并执行。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function_with_logits</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, z</span><br><span class=\"line\"></span><br><span class=\"line\">grad_fn = mindspore.grad(function_with_logits, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function_stop_gradient</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, ops.stop_gradient(z)</span><br><span class=\"line\"></span><br><span class=\"line\">grad_fn = mindspore.grad(function_stop_gradient, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p><code>ops.stop_gradient(z)</code>:重点在该函数，表示屏蔽了z对梯度的影响，即仍只求参数对loss的导数。</p>\r\n<p>这里解释一下一些api的含义</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mindspore.grad(fn, grad_position=<span class=\"number\">0</span>, weights=<span class=\"literal\">None</span>, has_aux=<span class=\"literal\">False</span>, return_ids=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZ3JhZC5odG1sP2hpZ2hsaWdodD1ncmFkI21pbmRzcG9yZS5ncmFk\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mindspore.numpy.matmul(x1, x2, dtype=None)</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL251bXB5L21pbmRzcG9yZS5udW1weS5tYXRtdWwuaHRtbD9oaWdobGlnaHQ9bWF0bXVsI21pbmRzcG9yZS5udW1weS5tYXRtdWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n</ul>\r\n<h3 id=\"auxiliary-data\">Auxiliary data</h3>\r\n<p>Auxiliary\r\ndata意为辅助数据，是函数除第一个输出项外的其他输出。通常我们会将函数的loss设置为函数的第一个输出，其他的输出即为辅助数据。</p>\r\n<p><code>grad</code>和<code>value_and_grad</code>提供<code>has_aux</code>参数，当其设置为<code>True</code>时，可以自动实现前文手动添加<code>stop_gradient</code>的功能，满足返回辅助数据的同时不影响梯度计算的效果。</p>\r\n<p>下面仍使用<code>function_with_logits</code>，配置<code>has_aux=True</code>，并执行。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grad_fn = mindspore.grad(function_with_logits, (<span class=\"number\">2</span>, <span class=\"number\">3</span>), has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\">grads, (z,) = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads, z)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"神经网络梯度计算\">神经网络梯度计算</h3>\r\n<blockquote>\r\n<p>前述章节主要根据计算图对应的函数介绍了MindSpore的函数式自动微分，但我们的神经网络构造是继承自面向对象编程范式的<code>nn.Cell</code>。接下来我们通过<code>Cell</code>构造同样的神经网络，利用函数式自动微分来实现反向传播。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>首先我们继承<code>nn.Cell</code>构造单层线性变换神经网络。这里我们直接使用前文的𝑤、𝑏作为模型参数，使用<code>mindspore.Parameter</code>进行包装后，作为内部属性，并在<code>construct</code>内实现相同的Tensor操作。</p>\r\n</blockquote>\r\n<p>这里出现了反向传播方法,并且是包装好的,建议读者仔细看一下代码并尝试自己运行一下。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义神经网络模型</span></span><br><span class=\"line\"><span class=\"comment\"># Define model</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.w = w</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.b = b</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        z = ops.matmul(x, <span class=\"variable language_\">self</span>.w) + <span class=\"variable language_\">self</span>.b</span><br><span class=\"line\">        <span class=\"keyword\">return</span> z</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Instantiate model</span></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"comment\"># Instantiate loss function</span></span><br><span class=\"line\">loss_fn = nn.BCEWithLogitsLoss()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">x, y</span>):</span><br><span class=\"line\">    z = model(x)</span><br><span class=\"line\">    loss = loss_fn(z, y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注入损失函数</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, weights=model.trainable_params())</span><br><span class=\"line\">loss, grads = grad_fn(x, y)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"总结输出单次\">总结输出（单次）</h3>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0.92031693</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br><span class=\"line\">计算多个参数的导数</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]]), Tensor(shape=[3], dtype=Float32, value= [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]))</span><br><span class=\"line\">消除部分张量对梯度的影响</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br><span class=\"line\">Auxiliary data 辅助数据测试</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01])) [ 0.8580145   0.62723386 -0.44728255]      </span><br><span class=\"line\">开始实测网络模型的反向传播</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>可见，除了在计算z的导数对梯度的影响情况下，均保持了相同的输出，并且可以观察到w,b的权值</p>\r\n<h2 id=\"二值交叉熵损失\">二值交叉熵损失</h2>\r\n<p><strong><em>以下的对数均为自然对数</em></strong></p>\r\n<p>Binary cross entropy 二元<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Lqk5Y+J54a1\">交叉熵<i class=\"fa fa-external-link-alt\"></i></span>是二分类问题中常用的一个Loss损失函数，在常见的机器学习模块中都有实现。就二元交叉熵这个损失函数的原理，简单地进行解释。下面是二元交叉熵损失函数的公式\r\n<span class=\"math display\">\\[\r\nL=-\\frac1N \\sum_{i=1}^{N}[y_ilog(p_i)+(1-y_i)log(1-p_i)]\r\n\\]</span> 先不尝试理解他，先看看他是如何运作的</p>\r\n<p><img src=\"https://s2.loli.net/2024/06/07/MAOZxqKodRSW6uy.jpg\"\r\nalt=\"img\" /> <span class=\"math display\">\\[\r\nL=\\frac13[(1*log0.8+(1-1)*log(1-0.8))+(0*log0.2+(1-0)*log(1-0.2))+(0*log0.4+(1-0)*log(1-0.4))]=0.319\r\n\\\\\r\n\\]</span> 对于以上的案例计算损失函数，结果是0.31903</p>\r\n<h3 id=\"从熵来看交叉熵损失\">从熵来看交叉熵损失</h3>\r\n<h4 id=\"信息量\">信息量</h4>\r\n<p>信息量来衡量一个事件的不确定性，一个事件发生的概率越大，不确定性越小，则其携带的信息量就越小。</p>\r\n<p>设<span\r\nclass=\"math display\">\\[X\\]</span>是一个离散型随机变量，其取值为集合<span\r\nclass=\"math display\">\\[X =\r\n{x_0,x_1,\\dots,x_n}\\]</span>，则其概率分布函数为<span\r\nclass=\"math display\">\\[p(x) = Pr(X = x),x \\in\r\nX\\]</span>，则定义事件<span\r\nclass=\"math display\">\\[X=x_0\\]</span>的信息量为： <span\r\nclass=\"math display\">\\[\r\nI(x_0) = -\\log(p(x_0))\r\n\\]</span> 当<span class=\"math display\">\\[p(x_0) =\r\n1\\]</span>时，其携带的信息量为0。</p>\r\n<h4 id=\"熵\">熵</h4>\r\n<p>熵用来衡量一个系统的混乱程度，代表系统中信息量的总和；熵值越大，表明这个系统的不确定性就越大。具体而数学的讲，熵就是一个系统中所有信息量的期望。</p>\r\n<p>信息量是衡量某个事件的不确定性，而熵是衡量一个系统（所有事件）的不确定性。</p>\r\n<p>熵的计算公式 <span class=\"math display\">\\[\r\nH(x) = -\\sum_{i=1}^np(x_i)\\log(p(x_i))\r\n\\]</span> 比较特殊的有二项分布熵 <span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nH(X)&amp;=&amp;-\\sum_{i=1}^n p(x_i)log(p(x_i))\\\\\r\n&amp;=&amp;-p(x)log(p(x))-(1-p(x))log(1-p(x))\r\n\\end{eqnarray}\r\n\\]</span> <em>熵也有其他类型的计算公式，这里是信息学上的定义</em></p>\r\n<p>其中<span\r\nclass=\"math display\">\\[p(x)\\]</span>为这件事发生的概率，<span\r\nclass=\"math display\">\\[-log(p(x_i))\\]</span>是事件<span\r\nclass=\"math display\">\\[x_i\\]</span>所携带的信息量。</p>\r\n<p>可以看出，熵是信息量的期望值，是一个随机变量（一个系统，事件所有可能性）不确定性的度量。熵值越大，随机变量的取值就越难确定，系统也就越不稳定；熵值越小，随机变量的取值也就越容易确定，系统越稳定。</p>\r\n<h4 id=\"相对熵-relative-entropy-kl散度\">相对熵 （Relative entropy）/\r\nKL散度</h4>\r\n<p>wiki对相对熵的定义如下：<code>In the context of machine learning, DKL(P‖Q) is often called the information gain achieved if P is used instead of Q.</code></p>\r\n<p>即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。</p>\r\n<p>在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。</p>\r\n<p>总结：相对熵也称为KL散度(Kullback-Leibler\r\ndivergence)，表示同一个随机变量的两个不同分布间的距离。</p>\r\n<p>设 <span class=\"math display\">\\[p(x),𝑞(𝑥)\\]</span>分别是\r\n离散随机变量<span\r\nclass=\"math display\">\\[X\\]</span>的两个概率分布，则<span\r\nclass=\"math display\">\\[p\\]</span>对<span\r\nclass=\"math display\">\\[q\\]</span>的相对熵是： <span\r\nclass=\"math display\">\\[\r\nD_{KL}(p \\parallel q) = \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\r\n\\]</span> 相对熵具有以下性质：</p>\r\n<ul>\r\n<li>如果p(x)和q(x)的分布相同，则其相对熵等于0</li>\r\n<li><span\r\nclass=\"math display\">\\[D_{KL}(p∥q)≠D_{KL}(q∥p)𝐷_{𝐾𝐿}(𝑝∥𝑞)≠𝐷_{𝐾𝐿}(𝑞∥𝑝)\\]</span>，也就是相对熵不具有对称性。</li>\r\n<li><span class=\"math display\">\\[D_{KL}(p∥q)≥0\\]</span></li>\r\n</ul>\r\n<p>总的来说，相对熵是用来衡量同一个随机变量的两个不同分布之间的距离。<strong>在实际应用中，假如p(x)是目标真实的分布，而q(x)是预测得来的分布，为了让这两个分布尽可能的相同的，就需要最小化KL散度。</strong></p>\r\n<h4 id=\"交叉熵-cross-entropy\">交叉熵 Cross Entropy</h4>\r\n<p>设<span class=\"math display\">\\[p(x),q(x)\\]</span>分别是\r\n离散随机变量<span\r\nclass=\"math display\">\\[X\\]</span>的两个概率分布，其中<span\r\nclass=\"math display\">\\[p(x)\\]</span>是目标分布，<span\r\nclass=\"math display\">\\[p\\]</span>和<span\r\nclass=\"math display\">\\[q\\]</span>的交叉熵可以看做是，使用分布<span\r\nclass=\"math display\">\\[q(x)\\]</span>表示目标分布<span\r\nclass=\"math display\">\\[p(x)\\]</span>的困难程度 <span\r\nclass=\"math display\">\\[\r\nH(p,q) = \\sum_ip(x_i)log\\frac{1}{\\log q(x_i)} = -\\sum_ip(x_i)\\log q(x_i)\r\n\\]</span> 将熵、相对熵以及交叉熵的公式放到一起， <span\r\nclass=\"math display\">\\[\r\n\\begin{align}\r\nH(p) &amp;= -\\sum_{i}p(x_i) \\log p(x_i) \\\\\r\nD_{KL}(p \\parallel q) &amp;= \\sum_{i}p(x_i)\\log \\frac{p(x_i)}{q(x_i)} =\r\n\\sum_i (p(x_i)\\log p(x_i) - p(x_i) \\log q(x_i)) \\\\\r\nH(p,q) &amp;=  -\\sum_ip(x_i)\\log q(x_i)\r\n\\end{align}\r\n\\]</span> 通过上面三个公式就可以得到 <span class=\"math display\">\\[\r\nD_{KL}(p,q) = H(p,q)- H(p)\r\n\\]</span> 其中，前一项<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>就是<span\r\nclass=\"math display\">\\[p,q\\]</span>的交叉熵。在机器学习中，目标的分布<span\r\nclass=\"math display\">\\[p(x)\\]</span>通常是训练数据的分布是固定，即是<span\r\nclass=\"math display\">\\[H(p)\\]</span>是一个常量。这样两个分布的交叉熵<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>也就等价于最小化这两个分布的相对熵<span\r\nclass=\"math display\">\\[D_{KL}(p \\parallel q)\\]</span></p>\r\n<p>设<span\r\nclass=\"math display\">\\[p(x)\\]</span>是目标分布（训练数据的分布），我们的目标的就让训练得到的分布<span\r\nclass=\"math display\">\\[q(x)\\]</span>尽可能的接近<span\r\nclass=\"math display\">\\[p(x)\\]</span>，这时候就可以最小化<span\r\nclass=\"math display\">\\[D_{KL}(p∥q)\\]</span>，等价于最小化交叉熵<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>​。</p>\r\n<h3 id=\"为什么要用交叉熵做loss函数\">为什么要用交叉熵做loss函数</h3>\r\n<p>在线性回归问题中，常常使用MSE（Mean Squared\r\nError）作为loss函数，比如： <span class=\"math display\">\\[\r\nloss = \\frac{1}{2m}\\sum_{i=1}^m(y_i-\\hat{y_i})^2\r\n\\]</span> 这里的m表示m个样本的，loss为m个样本的loss均值。 MSE在<a\r\nhref=\"#%20回归问题\">线性回归问题</a>中比较好用，那么在逻辑分类问题中还是如此么？</p>\r\n<h3 id=\"交叉熵在单分类问题中的使用\">交叉熵在单分类问题中的使用</h3>\r\n<p>这里的单类别是指，每一张图像样本只能有一个类别，比如只能是狗或只能是猫。\r\n交叉熵在单分类问题上基本是标配的方法 <span class=\"math display\">\\[\r\nloss=-\\sum_{i=1}^{n}y_ilog(\\hat{y_i})\r\n\\]</span> 上式为一张样本的loss计算方法。n代表着n种类别。\r\n举例说明,比如有如下样本</p>\r\n<p>对应的标签和预测值</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>*</th>\r\n<th>猫</th>\r\n<th>青蛙</th>\r\n<th>老鼠</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Label</td>\r\n<td>0</td>\r\n<td>1</td>\r\n<td>0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Pred</td>\r\n<td>0.3</td>\r\n<td>0.6</td>\r\n<td>0.1</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nloss&amp;=&amp;-(0\\times log(0.3)+1\\times log(0.6)+0\\times log(0.1)\\\\\r\n&amp;=&amp;-log(0.6)\r\n\\end{eqnarray}\r\n\\]</span> 对应的一个batch的loss就是 <span class=\"math display\">\\[\r\nloss=-\\frac{1}{m}\\sum_{j=1}^m\\sum_{i=1}^{n}y_{ji}log(\\hat{y_{ji}})\r\n\\]</span> m为当前batch的样本数</p>\r\n<h3 id=\"交叉熵在多分类问题中的使用\">交叉熵在多分类问题中的使用</h3>\r\n<p>这里的多类别是指，每一张图像样本可以有多个类别，比如同时包含一只猫和一只狗\r\n和单分类问题的标签不同，多分类的标签是n-hot。\r\n比如下面这张样本图，即有青蛙，又有老鼠，所以是一个多分类问题</p>\r\n<p>栗子</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>*</th>\r\n<th>猫</th>\r\n<th>青蛙</th>\r\n<th>老鼠</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Label</td>\r\n<td>0</td>\r\n<td>1</td>\r\n<td>1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Pred</td>\r\n<td>0.1</td>\r\n<td>0.7</td>\r\n<td>0.8</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>值得注意的是，这里的Pred不再是通过softmax计算的了，这里采用的是sigmoid。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。换句话说，就是每一个Label都是独立分布的，相互之间没有影响。所以交叉熵在这里是单独对每一个节点进行计算，每一个节点只有两种可能值，所以是一个二项分布。前面说过对于二项分布这种特殊的分布，熵的计算可以进行简化。</p>\r\n<p>同样的，交叉熵的计算也可以简化，即 <span class=\"math display\">\\[\r\nloss =-ylog(\\hat{y})-(1-y)log(1-\\hat{y})\r\n\\]</span>\r\n注意，上式只是针对一个节点的计算公式。这一点一定要和单分类loss区分开来。\r\n例子中可以计算为： <span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nloss_猫 &amp;=&amp;-0\\times log(0.1)-(1-0)log(1-0.1)=-log(0.9)\\\\\r\nloss_蛙 &amp;=&amp;-1\\times log(0.7)-(1-1)log(1-0.7)=-log(0.7)\\\\\r\nloss_鼠 &amp;=&amp;-1\\times log(0.8)-(1-1)log(1-0.8)=-log(0.8)\r\n\\end{eqnarray}\r\n\\]</span> 单张样本的loss即为 每一个batch的loss就是： <span\r\nclass=\"math display\">\\[\r\nloss\r\n=\\sum_{j=1}^{m}\\sum_{i=1}^{n}-y_{ji}log(\\hat{y_{ji}})-(1-y_{ji})log(1-\\hat{y_{ji}})\r\n\\]</span> 式中m为当前batch中的样本量，n为类别数。</p>\r\n<h3 id=\"从最大似然看交叉熵\">从<a\r\nhref=\"#%20最大似然估计\">最大似然</a>看交叉熵</h3>\r\n<p>设有一组训练样本<span class=\"math inline\">\\(X=\r\n\\{x_1,x_2,\\cdots,x_m\\}\\)</span> ,该样本的分布为<span\r\nclass=\"math inline\">\\(p(x)\\)</span> 。假设使用<span\r\nclass=\"math inline\">\\(\\theta\\)</span> 参数化模型得到<span\r\nclass=\"math inline\">\\(q(x;\\theta)\\)</span> ，现用这个模型来估计<span\r\nclass=\"math inline\">\\(X\\)</span> 的概率分布，得到似然函数 <span\r\nclass=\"math display\">\\[\r\nL(\\theta) = q(X; \\theta) = \\prod_i^mq(x_i;\\theta)\r\n\\]</span> 最大似然估计就是求得<span\r\nclass=\"math inline\">\\(\\theta\\)</span> 使得<span\r\nclass=\"math inline\">\\(L(\\theta)\\)</span> 的值最大，也就是 <span\r\nclass=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_{\\theta} \\prod_i^mq(x_i;\\theta)\r\n\\]</span> 对上式的两边同时取<span class=\"math inline\">\\(\\log\\)</span>\r\n，等价优化<span class=\"math inline\">\\(\\log\\)</span>\r\n的最大似然估计即<code>log-likelyhood</code> ，最大对数似然估计 <span\r\nclass=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_\\theta \\sum_i^m \\log q(x_i;\\theta)\r\n\\]</span> 对上式的右边进行缩放并不会改变<span class=\"math inline\">\\(arg\r\n\\max\\)</span> 的解，上式的右边除以样本的个数<span\r\nclass=\"math inline\">\\(m\\)</span> <span class=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_\\theta \\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\r\n\\]</span></p>\r\n<h4 id=\"和相对熵等价\">和相对熵等价</h4>\r\n<p>上式的最大化<span class=\"math inline\">\\(\\theta_{ML}\\)</span>\r\n是和没有训练样本没有关联的，就需要某种变换使其可以用训练的样本分布来表示，因为训练样本的分布可以看作是已知的，也是对最大化似然的一个约束条件。</p>\r\n<p>注意上式的 <span class=\"math display\">\\[\r\n\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\r\n\\]</span> 相当于<strong>求随机变量<span class=\"math inline\">\\(X\\)</span>\r\n的函数<span class=\"math inline\">\\(\\log (X;\\theta)\\)</span>\r\n的均值</strong>\r\n，根据大数定理，<strong>随着样本容量的增加，样本的算术平均值将趋近于随机变量的期望。</strong>\r\n也就是说 <span class=\"math display\">\\[\r\n\\frac{1}{m}\\sum_i^m \\log q(x_i;\\theta) \\rightarrow E_{x\\sim P}(\\log\r\nq(x;\\theta))\r\n\\]</span> 其中<span class=\"math inline\">\\(E_{X\\sim P}\\)</span>\r\n表示符合样本分布<span class=\"math inline\">\\(P\\)</span>\r\n的期望，这样就将最大似然估计使用真实样本的期望来表示 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned} \\theta_{ML} &amp;= arg \\max_{\\theta} E_{x\\sim P}({\\log\r\nq(x;\\theta)}) \\\\ &amp;= arg \\min_{\\theta} E_{x \\sim P}(- \\log\r\nq(x;\\theta)) \\end{aligned}\r\n\\]</span> 对右边取负号，将最大化变成最小化运算。</p>\r\n<blockquote>\r\n<p>上述的推导过程，可以参考 《Deep Learning》 的第五章。\r\n但是，在书中变为期望的只有一句话，将式子的右边除以样本数量<span\r\nclass=\"math inline\">\\(m\\)</span> 进行缩放，从而可以将其变为<span\r\nclass=\"math inline\">\\(E_{x \\sim p}\\log\r\nq(x;\\theta)\\)</span>，没有细节过程，也可能是作者默认上面的变换对读者是一直。\r\n确实是理解不了，查了很多文章，都是对这个变换的细节含糊其辞。一个周，对这个点一直耿耿于怀，就看了些关于概率论的科普书籍，其中共有介绍大数定理的：<strong>当样本容量趋于无穷时，样本的均值趋于其期望</strong>。</p>\r\n<p>针对上面公式，除以<span class=\"math inline\">\\(m\\)</span>后，<span\r\nclass=\"math inline\">\\(\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\\)</span>\r\n，确实是关于随机变量函数<span class=\"math inline\">\\(\\log q(x)\\)</span>\r\n的算术平均值，而<span class=\"math inline\">\\(x\\)</span>\r\n是训练样本其分布是已知的<span class=\"math inline\">\\(p(x)\\)</span>\r\n，这样就得到了<span class=\"math inline\">\\(E_{x \\sim p}(\\log\r\nq(x))\\)</span> 。</p>\r\n</blockquote>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned} D_{KL}(p \\parallel q) &amp;= \\sum_i p(x_i)\r\nlog(\\frac{p(x_i)}{q(x_i)})\\\\ &amp;= E_{x\\sim p}(\\log \\frac{p(x)}{q(x)})\r\n\\\\ &amp;= E_{x \\sim p}(\\log p(x) - \\log q(x)) \\\\ &amp;= E_{x \\sim\r\np}(\\log p(x)) - E_{x \\sim p} (\\log q(x)) \\end{aligned}\r\n\\]</span></p>\r\n<p>由于<span class=\"math inline\">\\(E_{x \\sim p} (\\log p(x))\\)</span>\r\n是训练样本的期望，是个固定的常数，在求最小值时可以忽略，所以最小化<span\r\nclass=\"math inline\">\\(D_{KL}(p \\parallel q)\\)</span> 就变成了最小化<span\r\nclass=\"math inline\">\\(-E_{x\\sim p}(\\log q(x))\\)</span>\r\n，这和最大似然估计是等价的。</p>\r\n<h4 id=\"和交叉熵等价\">和交叉熵等价</h4>\r\n<p>最大似然估计、相对熵、交叉熵的公式如下 <span class=\"math display\">\\[\r\n\\begin{aligned}\\theta_{ML} &amp;= -arg \\min_\\theta E_{x\\sim p}\\log\r\nq(x;\\theta) \\\\D_{KL} &amp;= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log\r\nq(x) \\\\H(p,q) &amp;= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log\r\nq(x)\\end{aligned}\\begin{aligned}\\theta_{ML} &amp;= arg \\min_\\theta\r\nE_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &amp;= E_{x \\sim p}\\log p(x) - E_{x\r\n\\sim p} \\log q(x) \\\\H(p,q) &amp;= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x\r\n\\sim p} \\log q(x)\\end{aligned}\r\n\\]</span> 从上面可以看出，最小化交叉熵，也就是最小化<span\r\nclass=\"math inline\">\\(D_{KL}\\)</span> ，从而预测的分布<span\r\nclass=\"math inline\">\\(q(x)\\)</span> 和训练样本的真实分布<span\r\nclass=\"math inline\">\\(p(x)\\)</span> 最接近。而最小化<span\r\nclass=\"math inline\">\\(D_{KL}\\)</span> 和最大似然估计是等价的。</p>\r\n<h3 id=\"多分类交叉熵\">多分类交叉熵</h3>\r\n<p>多分类任务中输出的是目标属于<strong>每个类别的概率，所有类别概率的和为1，其中概率最大的类别就是目标所属的分类。</strong>\r\n而<code>softmax</code> 函数能将一个向量的每个分量映射到<span\r\nclass=\"math inline\">\\([0,1]\\)</span>\r\n区间，并且对整个向量的输出做了归一化，保证所有分量输出的和为1，正好满足多分类任务的输出要求。所以，在多分类中，在最后就需要将提取的到特征经过<code>softmax</code>函数的，输出为每个类别的概率，然后再使用<strong>交叉熵</strong>\r\n作为损失函数。</p>\r\n<p><code>softmax</code>函数定义如下： <span class=\"math display\">\\[\r\nS_i = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\r\n\\]</span> 其中，输入的向量为<span class=\"math inline\">\\(z_i(i =\r\n1,2,\\dots,n)\\)</span> 。</p>\r\n<p>更直观的参见下图</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/XvLsuFKjBe39AaD.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>通过前面的特征提取到的特征向量为<span\r\nclass=\"math inline\">\\((z_1,z_2,\\dots,z_k)\\)</span>\r\n，将向量输入到<code>softmax</code>函数中，即可得到目标属于每个类别的概率，概率最大的就是预测得到的目标的类别。</p>\r\n<h4 id=\"cross-entropy-loss\">Cross Entropy Loss</h4>\r\n<p>使用<code>softmax</code>函数可以将特征向量映射为所属类别的概率，可以看作是预测类别的概率分布<span\r\nclass=\"math inline\">\\(q(c_i)\\)</span> ，有 <span class=\"math display\">\\[\r\nq(c_i) = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\r\n\\]</span> 其中<span class=\"math inline\">\\(c_i\\)</span> 为某个类别。</p>\r\n<p>设训练数据中类别的概率分布为<span\r\nclass=\"math inline\">\\(p(c_i)\\)</span> ，那么目标分布<span\r\nclass=\"math inline\">\\(p(c_i)\\)</span> 和预测分布<span\r\nclass=\"math inline\">\\(q(c_i)\\)</span>的交叉熵为</p>\r\n<p><span class=\"math display\">\\[H(p,q) =-\\sum_ip(c_i)\\log q(c_i)\r\n\\]</span></p>\r\n<p>每个训练样本所属的类别是已知的，并且每个样本只会属于一个类别（概率为1），属于其他类别概率为0。具体的，可以假设有个三分类任务，三个类分别是：猫，猪，狗。现有一个训练样本类别为猫，则有：</p>\r\n<p><span class=\"math display\">\\[\\begin{align} p(cat) &amp; = 1 \\\\ p(pig)\r\n&amp;= 0 \\\\ p(dog) &amp; = 0 \\end{align} \\]</span></p>\r\n<p>通过预测得到的三个类别的概率分别为：<span\r\nclass=\"math inline\">\\(q(cat) = 0.6,q(pig) = 0.2,q(dog) = 0.2\\)</span>\r\n，计算<span class=\"math inline\">\\(p\\)</span> 和<span\r\nclass=\"math inline\">\\(q\\)</span> 的交叉熵为： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned} H(p,q) &amp;= -(p(cat) \\log q(cat) + p(pig) + \\log\r\nq(pig) + \\log q(dog)) \\\\ &amp;= - (1 \\cdot \\log 0.6 + 0 \\cdot \\log 0.2\r\n+0 \\cdot \\log 0.2) \\\\ &amp;= - \\log 0.6 \\\\ &amp;= - \\log q(cat)\r\n\\end{aligned}\r\n\\]</span>\r\n利用这种特性，可以将样本的类别进行重新编码，就可以简化交叉熵的计算，这种编码方式就是<strong>one-hot</strong>\r\n编码。以上面例子为例， <span class=\"math display\">\\[\r\n\\begin{aligned} \\text{cat} &amp;= (1 0 0) \\\\ \\text{pig} &amp;= (010) \\\\\r\n\\text{dog} &amp;= (001) \\end{aligned}\r\n\\]</span></p>\r\n<p>通过这种编码方式，在计算交叉熵时，只需要计算和训练样本对应类别预测概率的值，其他的项都是<span\r\nclass=\"math inline\">\\(0 \\cdot \\log q(c_i) = 0\\)</span> 。</p>\r\n<p>具体的，交叉熵计算公式变成如下： <span class=\"math display\">\\[\r\n(p,q) = - \\log q(c_i)\r\n\\]</span> 其中<span class=\"math inline\">\\(c_i\\)</span>\r\n为训练样本对应的类别，上式也被称为<strong>负对数似然（negative\r\nlog-likelihood,nll）</strong>。</p>\r\n<h4 id=\"pytorch中的cross-entropy\">PyTorch中的Cross Entropy</h4>\r\n<p>PyTorch中实现交叉熵损失的有三个函数<code>torch.nn.CrossEntropyLoss</code>，<code>torch.nn.LogSoftmax</code>以及<code>torch.nn.NLLLoss</code>。</p>\r\n<ul>\r\n<li><code>torch.nn.functional.log_softmax</code> 比较简单，输入为<span\r\nclass=\"math inline\">\\(n\\)</span>维向量，指定要计算的维度<code>dim</code>，输出为<span\r\nclass=\"math inline\">\\(log(Softmax(x))\\)</span>。其计算公式如下：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\text{LogSoftmax}(x_i) = \\log (\\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)})\r\n\\]</span></p>\r\n<p>没有额外的处理，就是对输入的<span\r\nclass=\"math inline\">\\(n\\)</span>维向量的每个元素进行上述运算。</p>\r\n<ul>\r\n<li><code>torch.nn.functional.nll_loss</code> 负对数似然损失（Negative\r\nLog Likelihood\r\nLoss)，用于多分类，其输入的通常是<code>torch.nn.functional.log_softmax</code>的输出值。其函数如下</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">torch.nn.functional.nll_loss(<span class=\"built_in\">input</span>, target, weight=<span class=\"literal\">None</span>, size_average=<span class=\"literal\">None</span>, ignore_index=-<span class=\"number\">100</span>, reduce=<span class=\"literal\">None</span>, reduction=<span class=\"string\">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p><code>input</code>\r\n也就是<code>log_softmax</code>的输出值，各个类别的对数概率。<code>target</code>\r\n目标正确类别,<code>weight</code>\r\n针对类别不平衡问题，可以为类别设置不同的权值；<code>ignore_index</code>\r\n要忽略的类别，不参与loss的计算；比较重要的是<code>reduction</code>\r\n的值，有三个取值：<code>none</code>\r\n不做处理，输出的结果为向量；<code>mean</code>\r\n将<code>none</code>结果求均值后输出；<code>sum</code>\r\n将<code>none</code> 结果求和后输出。</p>\r\n<ul>\r\n<li><code>torch.nn.CrossEntropyLoss</code>就是上面两个函数的组合<code>nll_loss(log_softmax(input))</code>。</li>\r\n</ul>\r\n<h3 id=\"二分类交叉熵\">二分类交叉熵</h3>\r\n<p>多分类中使用<code>softmax</code>函数将最后的输出映射为每个类别的概率，而在二分类中则通常使用<code>sigmoid</code>\r\n将输出映射为正样本的概率。这是因为二分类中，只有两个类别：{正样本，负样本}，只需要求得正样本的概率<span\r\nclass=\"math inline\">\\(q\\)</span>,则<span\r\nclass=\"math inline\">\\(1-q\\)</span>\r\n就是负样本的概率。这也是多分类和二分类不同的地方。</p>\r\n<p><span class=\"math inline\">\\(\\text{sigmoid}\\)</span>\r\n函数的表达式如下： <span class=\"math display\">\\[\r\n\\sigma(z) = \\frac{1}{1 + e^{-z}}\r\n\\]</span> sigmoid的输入为<span class=\"math inline\">\\(z\\)</span>\r\n，其输出为<span class=\"math inline\">\\((0,1)\\)</span>\r\n，可以表示分类为正样本的概率。</p>\r\n<p>二分类的交叉熵可以看作是交叉熵损失的一个特列，交叉熵为 <span\r\nclass=\"math display\">\\[\r\n\\text{$Cross\\_Entorpy$}(p,q) = -\\sum_i^m p(x_i) \\log q(x_i)\r\n\\]</span> 这里只有两个类别<span class=\"math inline\">\\(x \\in\r\n{x_1,x_2}\\)</span> ，则有 <span class=\"math display\">\\[\r\n\\begin{aligned}\\text{$Cross\\_Entorpy$}(p,q) &amp;= -(p(x_1) \\log q(x_1)\r\n+ p(x_2) \\log q(x_2)) \\end{aligned}\r\n\\]</span></p>\r\n<p>因为只有两个选择，则有<span class=\"math inline\">\\(p(x_1) + p(x_2) =\r\n1,q(x_1) + q(x_2) = 1\\)</span> 。设，训练样本中<span\r\nclass=\"math inline\">\\(x_1\\)</span>的概率为<span\r\nclass=\"math inline\">\\(p\\)</span>，则<span\r\nclass=\"math inline\">\\(x_2\\)</span>为<span\r\nclass=\"math inline\">\\(1-p\\)</span>; 预测的<span\r\nclass=\"math inline\">\\(x_1\\)</span>的概率为<span\r\nclass=\"math inline\">\\(q\\)</span>，则<span\r\nclass=\"math inline\">\\(x_2\\)</span>的预测概率为<span\r\nclass=\"math inline\">\\(1 - q\\)</span> 。则上式可改写为 <span\r\nclass=\"math display\">\\[\r\n\\text{$Cross\\_Entropy$}(p,q) = -(p \\log q + (1-p) \\log (1-q))\r\n\\]</span> 也就是二分类交叉熵的损失函数。</p>\r\n<h3 id=\"总结\">总结</h3>\r\n<p>相对熵可以用来度量两个分布相似性，假设分布<span\r\nclass=\"math inline\">\\(p\\)</span>是训练样本的分布，<span\r\nclass=\"math inline\">\\(q\\)</span>是预测得到的分布。分类训练的过程实际上就是最小化<span\r\nclass=\"math inline\">\\(D_{KL}(p \\parallel q)\\)</span>，由于由于交叉熵\r\n<span class=\"math display\">\\[\r\nH(p,q)= D_{KL}(p \\parallel q) + H(p)\r\n\\]</span> 其中,<span\r\nclass=\"math inline\">\\(H(p)\\)</span>是训练样本的熵，是一个已知的常量，这样最小化相对熵就等价于最小化交叉熵。</p>\r\n<p>从最大似然估计转化为最小化负对数似然 <span class=\"math display\">\\[\r\n\\theta_{ML} = -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta)\r\n\\]</span> 也等价于最小化相对熵。</p>\r\n<h2 id=\"回归问题\">回归问题</h2>\r\n<p>回归：人们在测量事物的时候因为客观条件所限，求得的都是测量值，而不是事物真实的值，为了能够得到真实值，无限次的进行测量，最后通过这些测量数据计算<strong>回归到真实值</strong>，这就是回归的由来。</p>\r\n<p>回归分析的主要算法包括：</p>\r\n<ol type=\"1\">\r\n<li>线性回归(Linear Regression)</li>\r\n<li>逻辑回归（Logistic regressions）</li>\r\n<li>多项式回归(Polynomial Regression)</li>\r\n<li>逐步回归(Step Regression)</li>\r\n<li>岭回归(Ridge Regression)</li>\r\n<li>套索回归(Lasso Regression)</li>\r\n<li>弹性网回归(ElasticNet)</li>\r\n</ol>\r\n<h2 id=\"最大似然估计\">最大似然估计</h2>\r\n<p>wiki定义：<code>在统计学中，最大似然估计（英语：maximum likelihood estimation，简作MLE），也称极大似然估计，是用来估计一个概率模型的参数的一种方法。</code></p>\r\n<h3 id=\"原理\">原理</h3>\r\n<p>给定一个概率分布𝐷，已知其<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5qaC546H5a+G5bqm5Ye95pWw\">概率密度函数<i class=\"fa fa-external-link-alt\"></i></span>（连续分布）或<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5qaC546H6LSo6YeP5Ye95pWw\">概率质量函数<i class=\"fa fa-external-link-alt\"></i></span>（离散分布）为𝑓𝐷，以及一个分布参数𝜃，我们可以从这个分布中抽出一个具有𝑛个值的采样𝑋1,𝑋2,…,𝑋𝑛，利用𝑓𝐷计算出其<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Ly854S25Ye95pWw\">似然函数<i class=\"fa fa-external-link-alt\"></i></span>：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a9702eeec5a8eb416883af66665ac11bd8151f0f\"\r\nalt=\"{(x_{1},,x_{n})=f_{}(x_{1},,x_{n}).}\" />\r\n<figcaption\r\naria-hidden=\"true\">{(x_{1},,x_{n})=f_{}(x_{1},,x_{n}).}</figcaption>\r\n</figure>\r\n<p>若𝐷是离散分布，𝑓𝜃即是在参数为𝜃时观测到这一采样的概率；若其是连续分布，𝑓𝜃则为𝑋1,𝑋2,…,𝑋𝑛联合分布的概率密度函数在观测值处的取值。一旦我们获得𝑋1,𝑋2,…,𝑋𝑛，我们就能求得一个关于𝜃的估计。最大似然估计会寻找关于𝜃的最可能的值（即，在所有可能的𝜃取值中，寻找一个值使这个采样的“可能性”最大化）。从数学上来说，我们可以在𝜃的所有可能取值中寻找一个值使得似然<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Ye95pWw\">函数<i class=\"fa fa-external-link-alt\"></i></span>取到最大值。这个使可能性最大的<span\r\nclass=\"math display\">\\[\\hat\r\n𝜃\\]</span>值即称为𝜃的<strong>最大似然估计</strong>。由定义，最大似然估计是样本的函数。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5pyA5aSn5Ly854S25Lyw6K6h\">最大似然估计 -\r\n维基百科，自由的百科全书 (wikipedia.org)<i class=\"fa fa-external-link-alt\"></i></span></p>"},{"title":"MindSpore专题——第七章、模型训练","date":"2024-08-14T11:47:58.000Z","_content":"## 模型训练\n\n本片涉及大量之前提到概念的定义以及大量引用MindSpore官方文档。原文传送门：\n\n[MindSpore](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/train.html)\n\n<!--more-->\n\n### 四个步骤\n\n1. 构建数据集。\n2. 定义神经网络模型。\n3. 定义超参、损失函数及优化器。\n4. 输入数据集进行训练与评估。\n\n现在我们有了数据集和模型后，可以进行模型的训练与评估。\n\n### 构建数据集\n\n从dataset加载代码，构建数据集\n\n```\ndef datapipe(path, batch_size):\n    image_transforms = [\n        vision.Rescale(1.0 / 255.0, 0),\n        vision.Normalize(mean=(0.1307,), std=(0.3081,)),\n        vision.HWC2CHW()\n    ]\n    label_transform = transforms.TypeCast(mindspore.int32)\n\n    dataset = MnistDataset(path)\n    dataset = dataset.map(image_transforms, 'image')\n    dataset = dataset.map(label_transform, 'label')\n    dataset = dataset.batch(batch_size)\n    return dataset\n\ntrain_dataset = datapipe('MNIST_Data/train', batch_size=64)\ntest_dataset = datapipe('MNIST_Data/test', batch_size=64)\n```\n\n*class*mindspore.dataset.vision.HWC2CHW\n\n将输入图像的shape从 <H, W, C> 转换为 <C, H, W>。 如果输入图像的shape为 <H, W> ，图像将保持不变。\n\n异常处理\n\n- **RuntimeError** - 如果输入图像的shape不是 <H, W> 或 <H, W, C>。\n\n*class*mindspore.nn.**ReLU**\n\n逐元素求 max(0,𝑥) 。\n\n- **x** (Tensor) - 用于计算**ReLU**的任意维度的Tensor。数据类型为 [number](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.dtype.html#mindspore.dtype)。\n\n### 定义神经网络模型\n\n>  从[网络构建](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/model.html)中加载代码，构建一个神经网络模型。\n\n```python\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512),\n            nn.ReLU(),\n            nn.Dense(512, 512),\n            nn.ReLU(),\n            nn.Dense(512, 10)\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\nmodel = Network()\nprint(model)\n```\n\n### 定义超参、损失函数和优化器\n\n#### 超参\n\n超参（Hyperparameters）是可以调整的参数，可以控制模型训练优化的过程，不同的超参数值可能会影响模型训练和收敛速度。目前深度学习模型多采用批量随机梯度下降算法进行优化，随机梯度下降算法的原理如下：\n$$\nw_{t+1}=w_{t}-\\eta \\frac{1}{n} \\sum_{x \\in \\mathcal{B}} \\nabla l\\left(x, w_{t}\\right)\n$$\n公式中，𝑛是批量大小（batch size），𝜂是学习率（learning rate）。另外，𝑤𝑡为训练轮次𝑡中的权重参数，∇𝑙为损失函数的导数。除了梯度本身，这两个因子直接决定了模型的权重更新，从优化本身来看，它们是影响模型性能收敛最重要的参数。一般会定义以下超参用于训练：\n\n- **训练轮次（epoch）**：训练时遍历数据集的次数。\n- **批次大小（batch size）**：数据集进行分批读取训练，设定每个批次数据的大小。batch size过小，花费时间多，同时梯度震荡严重，不利于收敛；batch size过大，不同batch的梯度方向没有任何变化，容易陷入局部极小值，因此需要选择合适的batch size，可以有效提高模型精度、全局收敛。\n- **学习率（learning rate）**：如果学习率偏小，会导致收敛的速度变慢，如果学习率偏大，则可能会导致训练不收敛等不可预测的结果。梯度下降法被广泛应用在最小化模型误差的参数优化算法上。梯度下降法通过多次迭代，并在每一步中最小化损失函数来预估模型的参数。学习率就是在迭代过程中，会控制模型的学习进度。\n\n```python\nepochs = 3\nbatch_size = 64\nlearning_rate = 1e-2\n```\n\n#### 损失函数\n\n损失函数（loss function）用于评估模型的预测值（logits）和目标值（targets）之间的误差。训练模型时，随机初始化的神经网络模型开始时会预测出错误的结果。损失函数会评估预测结果与目标值的相异程度，模型训练的目标即为降低损失函数求得的误差。\n\n常见的损失函数包括用于回归任务的`nn.MSELoss`（均方误差）和用于分类的`nn.NLLLoss`（负对数似然）等。 `nn.CrossEntropyLoss` 结合了`nn.LogSoftmax`和`nn.NLLLoss`，可以对logits 进行归一化并计算预测误差。\n\n```python\nloss_fn = nn.CrossEntropyLoss()\n```\n\n#### 优化器\n\n模型优化（Optimization）是在每个训练步骤中调整模型参数以减少模型误差的过程。MindSpore提供多种优化算法的实现，称之为优化器（Optimizer）。优化器内部定义了模型的参数优化过程（即梯度如何更新至模型参数），所有优化逻辑都封装在优化器对象中。在这里，我们使用SGD（Stochastic Gradient Descent）优化器。\n\n我们通过`model.trainable_params()`方法获得模型的可训练参数，并传入学习率超参来初始化优化器。\n\n```python\noptimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)\n```\n\n*class*mindspore.experimental.optim.**SGD**(*params*, *lr*, *momentum=0*, *dampening=0*, *weight_decay=0*, *nesterov=False*, ***, *maximize=False*)\n\n随机梯度下降算法。\n$$\nv_{t+1} = u \\ast v_{t} + gradient \\ast (1-dampening)\n$$\n如果nesterov为True：\n$$\np_{t+1} = p_{t} - lr \\ast (gradient + u \\ast v_{t+1})\n$$\n如果nesterov为False：\n$$\np_{t+1} = p_{t} - lr \\ast v_{t+1}\n$$\n需要注意的是，对于训练的第一步 𝑣𝑡+1=𝑔𝑟𝑎𝑑𝑖𝑒𝑛𝑡。其中，p、v和u分别表示 parameters、accum 和 momentum。\n\n#### 训练与评估\n\n设置了超参、损失函数和优化器后，我们就可以循环输入数据来训练模型。一次数据集的完整迭代循环称为一轮（epoch）。每轮执行训练时包括两个步骤：\n\n1. 训练：迭代训练数据集，并尝试收敛到最佳参数。\n2. 验证/测试：迭代测试数据集，以检查模型性能是否提升。\n\n接下来我们定义用于训练的`train_loop`函数和用于测试的`test_loop`函数。\n\n使用函数式自动微分，需先定义正向函数`forward_fn`，使用[value_and_grad](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.value_and_grad.html)获得微分函数`grad_fn`。然后，我们将微分函数和优化器的执行封装为`train_step`函数，接下来循环迭代数据集进行训练即可。\n\n```python\n# Define forward function\ndef forward_fn(data, label):\n    logits = model(data)\n    loss = loss_fn(logits, label)\n    return loss, logits\n\n# Get gradient function\ngrad_fn = mindspore.value_and_grad(forward_fn, None, optimizer.parameters, has_aux=True)\n\n# Define function of one-step training\ndef train_step(data, label):\n    (loss, _), grads = grad_fn(data, label)\n    optimizer(grads)\n    return loss\n\ndef train_loop(model, dataset):\n    size = dataset.get_dataset_size()\n    model.set_train()\n    for batch, (data, label) in enumerate(dataset.create_tuple_iterator()):\n        loss = train_step(data, label)\n\n        if batch % 100 == 0:\n            loss, current = loss.asnumpy(), batch\n            print(f\"loss: {loss:>7f}  [{current:>3d}/{size:>3d}]\")\n```\n\n`test_loop`函数同样需循环遍历数据集，调用模型计算loss和Accuray并返回最终结果。\n\n```python\ndef test_loop(model, dataset, loss_fn):\n    num_batches = dataset.get_dataset_size()\n    model.set_train(False)\n    total, test_loss, correct = 0, 0, 0\n    for data, label in dataset.create_tuple_iterator():\n        pred = model(data)\n        total += len(data)\n        test_loss += loss_fn(pred, label).asnumpy()\n        correct += (pred.argmax(1) == label).asnumpy().sum()\n    test_loss /= num_batches\n    correct /= total\n    print(f\"Test: \\n Accuracy: {(100*correct):>0.1f}%, Avg loss: {test_loss:>8f} \\n\")\n```\n\n我们将实例化的损失函数和优化器传入`train_loop`和`test_loop`中。训练3轮并输出loss和Accuracy，查看性能变化。\n\n```python\nloss_fn = nn.CrossEntropyLoss()\noptimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)\n\nfor t in range(epochs):\n    print(f\"Epoch {t+1}\\n-------------------------------\")\n    train_loop(model, train_dataset)\n    test_loop(model, test_dataset, loss_fn)\nprint(\"Done!\")\n```\n\n> ```\n> Epoch 1\n> -------------------------------\n> loss: 2.302806  [  0/938]\n> loss: 2.285086  [100/938]\n> loss: 2.264712  [200/938]\n> loss: 2.174010  [300/938]\n> loss: 1.931853  [400/938]\n> loss: 1.340721  [500/938]\n> loss: 0.953515  [600/938]\n> loss: 0.756860  [700/938]\n> loss: 0.756263  [800/938]\n> loss: 0.463846  [900/938]\n> Test:\n>  Accuracy: 84.7%, Avg loss: 0.527155\n> \n> Epoch 2\n> -------------------------------\n> loss: 0.479126  [  0/938]\n> loss: 0.437443  [100/938]\n> loss: 0.685504  [200/938]\n> loss: 0.395121  [300/938]\n> loss: 0.550566  [400/938]\n> loss: 0.459457  [500/938]\n> loss: 0.293049  [600/938]\n> loss: 0.422102  [700/938]\n> loss: 0.333153  [800/938]\n> loss: 0.412182  [900/938]\n> Test:\n>  Accuracy: 90.5%, Avg loss: 0.335083\n> \n> Epoch 3\n> -------------------------------\n> loss: 0.207366  [  0/938]\n> loss: 0.343559  [100/938]\n> loss: 0.391145  [200/938]\n> loss: 0.317566  [300/938]\n> loss: 0.200746  [400/938]\n> loss: 0.445798  [500/938]\n> loss: 0.603720  [600/938]\n> loss: 0.170811  [700/938]\n> loss: 0.411954  [800/938]\n> loss: 0.315902  [900/938]\n> Test:\n>  Accuracy: 91.9%, Avg loss: 0.279034\n> \n> Done!\n> ```\n\n读者可以修改参数多跑几边，观察数据的变化，不懂随机梯度下降算法或不懂正向反向传播、学习率乃至超参的概念可以回顾之前文章中提到的视频并重复观看之前的文章，这几个概念应该比较好理解。","source":"_posts/special_subject/MindSpore/Chapters/Seven_ModelTrain.md","raw":"---\ntitle: MindSpore专题——第七章、模型训练\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## 模型训练\n\n本片涉及大量之前提到概念的定义以及大量引用MindSpore官方文档。原文传送门：\n\n[MindSpore](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/train.html)\n\n<!--more-->\n\n### 四个步骤\n\n1. 构建数据集。\n2. 定义神经网络模型。\n3. 定义超参、损失函数及优化器。\n4. 输入数据集进行训练与评估。\n\n现在我们有了数据集和模型后，可以进行模型的训练与评估。\n\n### 构建数据集\n\n从dataset加载代码，构建数据集\n\n```\ndef datapipe(path, batch_size):\n    image_transforms = [\n        vision.Rescale(1.0 / 255.0, 0),\n        vision.Normalize(mean=(0.1307,), std=(0.3081,)),\n        vision.HWC2CHW()\n    ]\n    label_transform = transforms.TypeCast(mindspore.int32)\n\n    dataset = MnistDataset(path)\n    dataset = dataset.map(image_transforms, 'image')\n    dataset = dataset.map(label_transform, 'label')\n    dataset = dataset.batch(batch_size)\n    return dataset\n\ntrain_dataset = datapipe('MNIST_Data/train', batch_size=64)\ntest_dataset = datapipe('MNIST_Data/test', batch_size=64)\n```\n\n*class*mindspore.dataset.vision.HWC2CHW\n\n将输入图像的shape从 <H, W, C> 转换为 <C, H, W>。 如果输入图像的shape为 <H, W> ，图像将保持不变。\n\n异常处理\n\n- **RuntimeError** - 如果输入图像的shape不是 <H, W> 或 <H, W, C>。\n\n*class*mindspore.nn.**ReLU**\n\n逐元素求 max(0,𝑥) 。\n\n- **x** (Tensor) - 用于计算**ReLU**的任意维度的Tensor。数据类型为 [number](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.dtype.html#mindspore.dtype)。\n\n### 定义神经网络模型\n\n>  从[网络构建](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/model.html)中加载代码，构建一个神经网络模型。\n\n```python\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512),\n            nn.ReLU(),\n            nn.Dense(512, 512),\n            nn.ReLU(),\n            nn.Dense(512, 10)\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\nmodel = Network()\nprint(model)\n```\n\n### 定义超参、损失函数和优化器\n\n#### 超参\n\n超参（Hyperparameters）是可以调整的参数，可以控制模型训练优化的过程，不同的超参数值可能会影响模型训练和收敛速度。目前深度学习模型多采用批量随机梯度下降算法进行优化，随机梯度下降算法的原理如下：\n$$\nw_{t+1}=w_{t}-\\eta \\frac{1}{n} \\sum_{x \\in \\mathcal{B}} \\nabla l\\left(x, w_{t}\\right)\n$$\n公式中，𝑛是批量大小（batch size），𝜂是学习率（learning rate）。另外，𝑤𝑡为训练轮次𝑡中的权重参数，∇𝑙为损失函数的导数。除了梯度本身，这两个因子直接决定了模型的权重更新，从优化本身来看，它们是影响模型性能收敛最重要的参数。一般会定义以下超参用于训练：\n\n- **训练轮次（epoch）**：训练时遍历数据集的次数。\n- **批次大小（batch size）**：数据集进行分批读取训练，设定每个批次数据的大小。batch size过小，花费时间多，同时梯度震荡严重，不利于收敛；batch size过大，不同batch的梯度方向没有任何变化，容易陷入局部极小值，因此需要选择合适的batch size，可以有效提高模型精度、全局收敛。\n- **学习率（learning rate）**：如果学习率偏小，会导致收敛的速度变慢，如果学习率偏大，则可能会导致训练不收敛等不可预测的结果。梯度下降法被广泛应用在最小化模型误差的参数优化算法上。梯度下降法通过多次迭代，并在每一步中最小化损失函数来预估模型的参数。学习率就是在迭代过程中，会控制模型的学习进度。\n\n```python\nepochs = 3\nbatch_size = 64\nlearning_rate = 1e-2\n```\n\n#### 损失函数\n\n损失函数（loss function）用于评估模型的预测值（logits）和目标值（targets）之间的误差。训练模型时，随机初始化的神经网络模型开始时会预测出错误的结果。损失函数会评估预测结果与目标值的相异程度，模型训练的目标即为降低损失函数求得的误差。\n\n常见的损失函数包括用于回归任务的`nn.MSELoss`（均方误差）和用于分类的`nn.NLLLoss`（负对数似然）等。 `nn.CrossEntropyLoss` 结合了`nn.LogSoftmax`和`nn.NLLLoss`，可以对logits 进行归一化并计算预测误差。\n\n```python\nloss_fn = nn.CrossEntropyLoss()\n```\n\n#### 优化器\n\n模型优化（Optimization）是在每个训练步骤中调整模型参数以减少模型误差的过程。MindSpore提供多种优化算法的实现，称之为优化器（Optimizer）。优化器内部定义了模型的参数优化过程（即梯度如何更新至模型参数），所有优化逻辑都封装在优化器对象中。在这里，我们使用SGD（Stochastic Gradient Descent）优化器。\n\n我们通过`model.trainable_params()`方法获得模型的可训练参数，并传入学习率超参来初始化优化器。\n\n```python\noptimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)\n```\n\n*class*mindspore.experimental.optim.**SGD**(*params*, *lr*, *momentum=0*, *dampening=0*, *weight_decay=0*, *nesterov=False*, ***, *maximize=False*)\n\n随机梯度下降算法。\n$$\nv_{t+1} = u \\ast v_{t} + gradient \\ast (1-dampening)\n$$\n如果nesterov为True：\n$$\np_{t+1} = p_{t} - lr \\ast (gradient + u \\ast v_{t+1})\n$$\n如果nesterov为False：\n$$\np_{t+1} = p_{t} - lr \\ast v_{t+1}\n$$\n需要注意的是，对于训练的第一步 𝑣𝑡+1=𝑔𝑟𝑎𝑑𝑖𝑒𝑛𝑡。其中，p、v和u分别表示 parameters、accum 和 momentum。\n\n#### 训练与评估\n\n设置了超参、损失函数和优化器后，我们就可以循环输入数据来训练模型。一次数据集的完整迭代循环称为一轮（epoch）。每轮执行训练时包括两个步骤：\n\n1. 训练：迭代训练数据集，并尝试收敛到最佳参数。\n2. 验证/测试：迭代测试数据集，以检查模型性能是否提升。\n\n接下来我们定义用于训练的`train_loop`函数和用于测试的`test_loop`函数。\n\n使用函数式自动微分，需先定义正向函数`forward_fn`，使用[value_and_grad](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.value_and_grad.html)获得微分函数`grad_fn`。然后，我们将微分函数和优化器的执行封装为`train_step`函数，接下来循环迭代数据集进行训练即可。\n\n```python\n# Define forward function\ndef forward_fn(data, label):\n    logits = model(data)\n    loss = loss_fn(logits, label)\n    return loss, logits\n\n# Get gradient function\ngrad_fn = mindspore.value_and_grad(forward_fn, None, optimizer.parameters, has_aux=True)\n\n# Define function of one-step training\ndef train_step(data, label):\n    (loss, _), grads = grad_fn(data, label)\n    optimizer(grads)\n    return loss\n\ndef train_loop(model, dataset):\n    size = dataset.get_dataset_size()\n    model.set_train()\n    for batch, (data, label) in enumerate(dataset.create_tuple_iterator()):\n        loss = train_step(data, label)\n\n        if batch % 100 == 0:\n            loss, current = loss.asnumpy(), batch\n            print(f\"loss: {loss:>7f}  [{current:>3d}/{size:>3d}]\")\n```\n\n`test_loop`函数同样需循环遍历数据集，调用模型计算loss和Accuray并返回最终结果。\n\n```python\ndef test_loop(model, dataset, loss_fn):\n    num_batches = dataset.get_dataset_size()\n    model.set_train(False)\n    total, test_loss, correct = 0, 0, 0\n    for data, label in dataset.create_tuple_iterator():\n        pred = model(data)\n        total += len(data)\n        test_loss += loss_fn(pred, label).asnumpy()\n        correct += (pred.argmax(1) == label).asnumpy().sum()\n    test_loss /= num_batches\n    correct /= total\n    print(f\"Test: \\n Accuracy: {(100*correct):>0.1f}%, Avg loss: {test_loss:>8f} \\n\")\n```\n\n我们将实例化的损失函数和优化器传入`train_loop`和`test_loop`中。训练3轮并输出loss和Accuracy，查看性能变化。\n\n```python\nloss_fn = nn.CrossEntropyLoss()\noptimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)\n\nfor t in range(epochs):\n    print(f\"Epoch {t+1}\\n-------------------------------\")\n    train_loop(model, train_dataset)\n    test_loop(model, test_dataset, loss_fn)\nprint(\"Done!\")\n```\n\n> ```\n> Epoch 1\n> -------------------------------\n> loss: 2.302806  [  0/938]\n> loss: 2.285086  [100/938]\n> loss: 2.264712  [200/938]\n> loss: 2.174010  [300/938]\n> loss: 1.931853  [400/938]\n> loss: 1.340721  [500/938]\n> loss: 0.953515  [600/938]\n> loss: 0.756860  [700/938]\n> loss: 0.756263  [800/938]\n> loss: 0.463846  [900/938]\n> Test:\n>  Accuracy: 84.7%, Avg loss: 0.527155\n> \n> Epoch 2\n> -------------------------------\n> loss: 0.479126  [  0/938]\n> loss: 0.437443  [100/938]\n> loss: 0.685504  [200/938]\n> loss: 0.395121  [300/938]\n> loss: 0.550566  [400/938]\n> loss: 0.459457  [500/938]\n> loss: 0.293049  [600/938]\n> loss: 0.422102  [700/938]\n> loss: 0.333153  [800/938]\n> loss: 0.412182  [900/938]\n> Test:\n>  Accuracy: 90.5%, Avg loss: 0.335083\n> \n> Epoch 3\n> -------------------------------\n> loss: 0.207366  [  0/938]\n> loss: 0.343559  [100/938]\n> loss: 0.391145  [200/938]\n> loss: 0.317566  [300/938]\n> loss: 0.200746  [400/938]\n> loss: 0.445798  [500/938]\n> loss: 0.603720  [600/938]\n> loss: 0.170811  [700/938]\n> loss: 0.411954  [800/938]\n> loss: 0.315902  [900/938]\n> Test:\n>  Accuracy: 91.9%, Avg loss: 0.279034\n> \n> Done!\n> ```\n\n读者可以修改参数多跑几边，观察数据的变化，不懂随机梯度下降算法或不懂正向反向传播、学习率乃至超参的概念可以回顾之前文章中提到的视频并重复观看之前的文章，这几个概念应该比较好理解。","slug":"special_subject/MindSpore/Chapters/Seven_ModelTrain","published":1,"updated":"2024-08-16T08:59:02.737Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjbj00a7lowvf6ws7xca","content":"<h2 id=\"模型训练\">模型训练</h2>\r\n<p>本片涉及大量之前提到概念的定义以及大量引用MindSpore官方文档。原文传送门：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RyYWluLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"四个步骤\">四个步骤</h3>\r\n<ol type=\"1\">\r\n<li>构建数据集。</li>\r\n<li>定义神经网络模型。</li>\r\n<li>定义超参、损失函数及优化器。</li>\r\n<li>输入数据集进行训练与评估。</li>\r\n</ol>\r\n<p>现在我们有了数据集和模型后，可以进行模型的训练与评估。</p>\r\n<h3 id=\"构建数据集\">构建数据集</h3>\r\n<p>从dataset加载代码，构建数据集</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def datapipe(path, batch_size):</span><br><span class=\"line\">    image_transforms = [</span><br><span class=\"line\">        vision.Rescale(1.0 / 255.0, 0),</span><br><span class=\"line\">        vision.Normalize(mean=(0.1307,), std=(0.3081,)),</span><br><span class=\"line\">        vision.HWC2CHW()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    label_transform = transforms.TypeCast(mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\">    dataset = MnistDataset(path)</span><br><span class=\"line\">    dataset = dataset.map(image_transforms, &#x27;image&#x27;)</span><br><span class=\"line\">    dataset = dataset.map(label_transform, &#x27;label&#x27;)</span><br><span class=\"line\">    dataset = dataset.batch(batch_size)</span><br><span class=\"line\">    return dataset</span><br><span class=\"line\"></span><br><span class=\"line\">train_dataset = datapipe(&#x27;MNIST_Data/train&#x27;, batch_size=64)</span><br><span class=\"line\">test_dataset = datapipe(&#x27;MNIST_Data/test&#x27;, batch_size=64)</span><br></pre></td></tr></table></figure>\r\n<p><em>class</em>mindspore.dataset.vision.HWC2CHW</p>\r\n<p>将输入图像的shape从 &lt;H, W, C&gt; 转换为 &lt;C, H, W&gt;。\r\n如果输入图像的shape为 &lt;H, W&gt; ，图像将保持不变。</p>\r\n<p>异常处理</p>\r\n<ul>\r\n<li><strong>RuntimeError</strong> - 如果输入图像的shape不是 &lt;H, W&gt;\r\n或 &lt;H, W, C&gt;。</li>\r\n</ul>\r\n<p><em>class</em>mindspore.nn.<strong>ReLU</strong></p>\r\n<p>逐元素求 max(0,𝑥) 。</p>\r\n<ul>\r\n<li><strong>x</strong> (Tensor) -\r\n用于计算<strong>ReLU</strong>的任意维度的Tensor。数据类型为 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZHR5cGUuaHRtbCNtaW5kc3BvcmUuZHR5cGU=\">number<i class=\"fa fa-external-link-alt\"></i></span>。</li>\r\n</ul>\r\n<h3 id=\"定义神经网络模型\">定义神经网络模型</h3>\r\n<blockquote>\r\n<p>从<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL21vZGVsLmh0bWw=\">网络构建<i class=\"fa fa-external-link-alt\"></i></span>中加载代码，构建一个神经网络模型。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"定义超参损失函数和优化器\">定义超参、损失函数和优化器</h3>\r\n<h4 id=\"超参\">超参</h4>\r\n<p>超参（Hyperparameters）是可以调整的参数，可以控制模型训练优化的过程，不同的超参数值可能会影响模型训练和收敛速度。目前深度学习模型多采用批量随机梯度下降算法进行优化，随机梯度下降算法的原理如下：\r\n<span class=\"math display\">\\[\r\nw_{t+1}=w_{t}-\\eta \\frac{1}{n} \\sum_{x \\in \\mathcal{B}} \\nabla l\\left(x,\r\nw_{t}\\right)\r\n\\]</span> 公式中，𝑛是批量大小（batch size），𝜂是学习率（learning\r\nrate）。另外，𝑤𝑡为训练轮次𝑡中的权重参数，∇𝑙为损失函数的导数。除了梯度本身，这两个因子直接决定了模型的权重更新，从优化本身来看，它们是影响模型性能收敛最重要的参数。一般会定义以下超参用于训练：</p>\r\n<ul>\r\n<li><strong>训练轮次（epoch）</strong>：训练时遍历数据集的次数。</li>\r\n<li><strong>批次大小（batch\r\nsize）</strong>：数据集进行分批读取训练，设定每个批次数据的大小。batch\r\nsize过小，花费时间多，同时梯度震荡严重，不利于收敛；batch\r\nsize过大，不同batch的梯度方向没有任何变化，容易陷入局部极小值，因此需要选择合适的batch\r\nsize，可以有效提高模型精度、全局收敛。</li>\r\n<li><strong>学习率（learning\r\nrate）</strong>：如果学习率偏小，会导致收敛的速度变慢，如果学习率偏大，则可能会导致训练不收敛等不可预测的结果。梯度下降法被广泛应用在最小化模型误差的参数优化算法上。梯度下降法通过多次迭代，并在每一步中最小化损失函数来预估模型的参数。学习率就是在迭代过程中，会控制模型的学习进度。</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">epochs = <span class=\"number\">3</span></span><br><span class=\"line\">batch_size = <span class=\"number\">64</span></span><br><span class=\"line\">learning_rate = <span class=\"number\">1e-2</span></span><br></pre></td></tr></table></figure>\r\n<h4 id=\"损失函数\">损失函数</h4>\r\n<p>损失函数（loss\r\nfunction）用于评估模型的预测值（logits）和目标值（targets）之间的误差。训练模型时，随机初始化的神经网络模型开始时会预测出错误的结果。损失函数会评估预测结果与目标值的相异程度，模型训练的目标即为降低损失函数求得的误差。</p>\r\n<p>常见的损失函数包括用于回归任务的<code>nn.MSELoss</code>（均方误差）和用于分类的<code>nn.NLLLoss</code>（负对数似然）等。\r\n<code>nn.CrossEntropyLoss</code>\r\n结合了<code>nn.LogSoftmax</code>和<code>nn.NLLLoss</code>，可以对logits\r\n进行归一化并计算预测误差。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"优化器\">优化器</h4>\r\n<p>模型优化（Optimization）是在每个训练步骤中调整模型参数以减少模型误差的过程。MindSpore提供多种优化算法的实现，称之为优化器（Optimizer）。优化器内部定义了模型的参数优化过程（即梯度如何更新至模型参数），所有优化逻辑都封装在优化器对象中。在这里，我们使用SGD（Stochastic\r\nGradient Descent）优化器。</p>\r\n<p>我们通过<code>model.trainable_params()</code>方法获得模型的可训练参数，并传入学习率超参来初始化优化器。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)</span><br></pre></td></tr></table></figure>\r\n<p><em>class</em>mindspore.experimental.optim.<strong>SGD</strong>(<em>params</em>,\r\n<em>lr</em>, <em>momentum=0</em>, <em>dampening=0</em>,\r\n<em>weight_decay=0</em>, <em>nesterov=False</em>, **<em>,\r\n</em>maximize=False*)</p>\r\n<p>随机梯度下降算法。 <span class=\"math display\">\\[\r\nv_{t+1} = u \\ast v_{t} + gradient \\ast (1-dampening)\r\n\\]</span> 如果nesterov为True： <span class=\"math display\">\\[\r\np_{t+1} = p_{t} - lr \\ast (gradient + u \\ast v_{t+1})\r\n\\]</span> 如果nesterov为False： <span class=\"math display\">\\[\r\np_{t+1} = p_{t} - lr \\ast v_{t+1}\r\n\\]</span> 需要注意的是，对于训练的第一步\r\n𝑣𝑡+1=𝑔𝑟𝑎𝑑𝑖𝑒𝑛𝑡。其中，p、v和u分别表示 parameters、accum 和 momentum。</p>\r\n<h4 id=\"训练与评估\">训练与评估</h4>\r\n<p>设置了超参、损失函数和优化器后，我们就可以循环输入数据来训练模型。一次数据集的完整迭代循环称为一轮（epoch）。每轮执行训练时包括两个步骤：</p>\r\n<ol type=\"1\">\r\n<li>训练：迭代训练数据集，并尝试收敛到最佳参数。</li>\r\n<li>验证/测试：迭代测试数据集，以检查模型性能是否提升。</li>\r\n</ol>\r\n<p>接下来我们定义用于训练的<code>train_loop</code>函数和用于测试的<code>test_loop</code>函数。</p>\r\n<p>使用函数式自动微分，需先定义正向函数<code>forward_fn</code>，使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUudmFsdWVfYW5kX2dyYWQuaHRtbA==\">value_and_grad<i class=\"fa fa-external-link-alt\"></i></span>获得微分函数<code>grad_fn</code>。然后，我们将微分函数和优化器的执行封装为<code>train_step</code>函数，接下来循环迭代数据集进行训练即可。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    logits = model(data)</span><br><span class=\"line\">    loss = loss_fn(logits, label)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, logits</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get gradient function</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, optimizer.parameters, has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Define function of one-step training</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_step</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    (loss, _), grads = grad_fn(data, label)</span><br><span class=\"line\">    optimizer(grads)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_loop</span>(<span class=\"params\">model, dataset</span>):</span><br><span class=\"line\">    size = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> batch, (data, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        loss = train_step(data, label)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> batch % <span class=\"number\">100</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            loss, current = loss.asnumpy(), batch</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;loss: <span class=\"subst\">&#123;loss:&gt;7f&#125;</span>  [<span class=\"subst\">&#123;current:&gt;3d&#125;</span>/<span class=\"subst\">&#123;size:&gt;3d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p><code>test_loop</code>函数同样需循环遍历数据集，调用模型计算loss和Accuray并返回最终结果。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_loop</span>(<span class=\"params\">model, dataset, loss_fn</span>):</span><br><span class=\"line\">    num_batches = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\">    total, test_loss, correct = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> dataset.create_tuple_iterator():</span><br><span class=\"line\">        pred = model(data)</span><br><span class=\"line\">        total += <span class=\"built_in\">len</span>(data)</span><br><span class=\"line\">        test_loss += loss_fn(pred, label).asnumpy()</span><br><span class=\"line\">        correct += (pred.argmax(<span class=\"number\">1</span>) == label).asnumpy().<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">    test_loss /= num_batches</span><br><span class=\"line\">    correct /= total</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Test: \\n Accuracy: <span class=\"subst\">&#123;(<span class=\"number\">100</span>*correct):&gt;<span class=\"number\">0.1</span>f&#125;</span>%, Avg loss: <span class=\"subst\">&#123;test_loss:&gt;8f&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>我们将实例化的损失函数和优化器传入<code>train_loop</code>和<code>test_loop</code>中。训练3轮并输出loss和Accuracy，查看性能变化。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(epochs):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Epoch <span class=\"subst\">&#123;t+<span class=\"number\">1</span>&#125;</span>\\n-------------------------------&quot;</span>)</span><br><span class=\"line\">    train_loop(model, train_dataset)</span><br><span class=\"line\">    test_loop(model, test_dataset, loss_fn)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Epoch 1</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 2.302806  [  0/938]</span><br><span class=\"line\">loss: 2.285086  [100/938]</span><br><span class=\"line\">loss: 2.264712  [200/938]</span><br><span class=\"line\">loss: 2.174010  [300/938]</span><br><span class=\"line\">loss: 1.931853  [400/938]</span><br><span class=\"line\">loss: 1.340721  [500/938]</span><br><span class=\"line\">loss: 0.953515  [600/938]</span><br><span class=\"line\">loss: 0.756860  [700/938]</span><br><span class=\"line\">loss: 0.756263  [800/938]</span><br><span class=\"line\">loss: 0.463846  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 84.7%, Avg loss: 0.527155</span><br><span class=\"line\"></span><br><span class=\"line\">Epoch 2</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 0.479126  [  0/938]</span><br><span class=\"line\">loss: 0.437443  [100/938]</span><br><span class=\"line\">loss: 0.685504  [200/938]</span><br><span class=\"line\">loss: 0.395121  [300/938]</span><br><span class=\"line\">loss: 0.550566  [400/938]</span><br><span class=\"line\">loss: 0.459457  [500/938]</span><br><span class=\"line\">loss: 0.293049  [600/938]</span><br><span class=\"line\">loss: 0.422102  [700/938]</span><br><span class=\"line\">loss: 0.333153  [800/938]</span><br><span class=\"line\">loss: 0.412182  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 90.5%, Avg loss: 0.335083</span><br><span class=\"line\"></span><br><span class=\"line\">Epoch 3</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 0.207366  [  0/938]</span><br><span class=\"line\">loss: 0.343559  [100/938]</span><br><span class=\"line\">loss: 0.391145  [200/938]</span><br><span class=\"line\">loss: 0.317566  [300/938]</span><br><span class=\"line\">loss: 0.200746  [400/938]</span><br><span class=\"line\">loss: 0.445798  [500/938]</span><br><span class=\"line\">loss: 0.603720  [600/938]</span><br><span class=\"line\">loss: 0.170811  [700/938]</span><br><span class=\"line\">loss: 0.411954  [800/938]</span><br><span class=\"line\">loss: 0.315902  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 91.9%, Avg loss: 0.279034</span><br><span class=\"line\"></span><br><span class=\"line\">Done!</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>读者可以修改参数多跑几边，观察数据的变化，不懂随机梯度下降算法或不懂正向反向传播、学习率乃至超参的概念可以回顾之前文章中提到的视频并重复观看之前的文章，这几个概念应该比较好理解。</p>\r\n","length":1864,"excerpt":"<h2 id=\"模型训练\">模型训练</h2>\r\n<p>本片涉及大量之前提到概念的定义以及大量引用MindSpore官方文档。原文传送门：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RyYWluLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h3 id=\"四个步骤\">四个步骤</h3>\r\n<ol type=\"1\">\r\n<li>构建数据集。</li>\r\n<li>定义神经网络模型。</li>\r\n<li>定义超参、损失函数及优化器。</li>\r\n<li>输入数据集进行训练与评估。</li>\r\n</ol>\r\n<p>现在我们有了数据集和模型后，可以进行模型的训练与评估。</p>\r\n<h3 id=\"构建数据集\">构建数据集</h3>\r\n<p>从dataset加载代码，构建数据集</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def datapipe(path, batch_size):</span><br><span class=\"line\">    image_transforms = [</span><br><span class=\"line\">        vision.Rescale(1.0 / 255.0, 0),</span><br><span class=\"line\">        vision.Normalize(mean=(0.1307,), std=(0.3081,)),</span><br><span class=\"line\">        vision.HWC2CHW()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    label_transform = transforms.TypeCast(mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\">    dataset = MnistDataset(path)</span><br><span class=\"line\">    dataset = dataset.map(image_transforms, &#x27;image&#x27;)</span><br><span class=\"line\">    dataset = dataset.map(label_transform, &#x27;label&#x27;)</span><br><span class=\"line\">    dataset = dataset.batch(batch_size)</span><br><span class=\"line\">    return dataset</span><br><span class=\"line\"></span><br><span class=\"line\">train_dataset = datapipe(&#x27;MNIST_Data/train&#x27;, batch_size=64)</span><br><span class=\"line\">test_dataset = datapipe(&#x27;MNIST_Data/test&#x27;, batch_size=64)</span><br></pre></td></tr></table></figure>\r\n<p><em>class</em>mindspore.dataset.vision.HWC2CHW</p>\r\n<p>将输入图像的shape从 &lt;H, W, C&gt; 转换为 &lt;C, H, W&gt;。\r\n如果输入图像的shape为 &lt;H, W&gt; ，图像将保持不变。</p>\r\n<p>异常处理</p>\r\n<ul>\r\n<li><strong>RuntimeError</strong> - 如果输入图像的shape不是 &lt;H, W&gt;\r\n或 &lt;H, W, C&gt;。</li>\r\n</ul>\r\n<p><em>class</em>mindspore.nn.<strong>ReLU</strong></p>\r\n<p>逐元素求 max(0,𝑥) 。</p>\r\n<ul>\r\n<li><strong>x</strong> (Tensor) -\r\n用于计算<strong>ReLU</strong>的任意维度的Tensor。数据类型为 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZHR5cGUuaHRtbCNtaW5kc3BvcmUuZHR5cGU=\">number<i class=\"fa fa-external-link-alt\"></i></span>。</li>\r\n</ul>\r\n<h3 id=\"定义神经网络模型\">定义神经网络模型</h3>\r\n<blockquote>\r\n<p>从<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL21vZGVsLmh0bWw=\">网络构建<i class=\"fa fa-external-link-alt\"></i></span>中加载代码，构建一个神经网络模型。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"定义超参损失函数和优化器\">定义超参、损失函数和优化器</h3>\r\n<h4 id=\"超参\">超参</h4>\r\n<p>超参（Hyperparameters）是可以调整的参数，可以控制模型训练优化的过程，不同的超参数值可能会影响模型训练和收敛速度。目前深度学习模型多采用批量随机梯度下降算法进行优化，随机梯度下降算法的原理如下：\r\n<span class=\"math display\">\\[\r\nw_{t+1}=w_{t}-\\eta \\frac{1}{n} \\sum_{x \\in \\mathcal{B}} \\nabla l\\left(x,\r\nw_{t}\\right)\r\n\\]</span> 公式中，𝑛是批量大小（batch size），𝜂是学习率（learning\r\nrate）。另外，𝑤𝑡为训练轮次𝑡中的权重参数，∇𝑙为损失函数的导数。除了梯度本身，这两个因子直接决定了模型的权重更新，从优化本身来看，它们是影响模型性能收敛最重要的参数。一般会定义以下超参用于训练：</p>\r\n<ul>\r\n<li><strong>训练轮次（epoch）</strong>：训练时遍历数据集的次数。</li>\r\n<li><strong>批次大小（batch\r\nsize）</strong>：数据集进行分批读取训练，设定每个批次数据的大小。batch\r\nsize过小，花费时间多，同时梯度震荡严重，不利于收敛；batch\r\nsize过大，不同batch的梯度方向没有任何变化，容易陷入局部极小值，因此需要选择合适的batch\r\nsize，可以有效提高模型精度、全局收敛。</li>\r\n<li><strong>学习率（learning\r\nrate）</strong>：如果学习率偏小，会导致收敛的速度变慢，如果学习率偏大，则可能会导致训练不收敛等不可预测的结果。梯度下降法被广泛应用在最小化模型误差的参数优化算法上。梯度下降法通过多次迭代，并在每一步中最小化损失函数来预估模型的参数。学习率就是在迭代过程中，会控制模型的学习进度。</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">epochs = <span class=\"number\">3</span></span><br><span class=\"line\">batch_size = <span class=\"number\">64</span></span><br><span class=\"line\">learning_rate = <span class=\"number\">1e-2</span></span><br></pre></td></tr></table></figure>\r\n<h4 id=\"损失函数\">损失函数</h4>\r\n<p>损失函数（loss\r\nfunction）用于评估模型的预测值（logits）和目标值（targets）之间的误差。训练模型时，随机初始化的神经网络模型开始时会预测出错误的结果。损失函数会评估预测结果与目标值的相异程度，模型训练的目标即为降低损失函数求得的误差。</p>\r\n<p>常见的损失函数包括用于回归任务的<code>nn.MSELoss</code>（均方误差）和用于分类的<code>nn.NLLLoss</code>（负对数似然）等。\r\n<code>nn.CrossEntropyLoss</code>\r\n结合了<code>nn.LogSoftmax</code>和<code>nn.NLLLoss</code>，可以对logits\r\n进行归一化并计算预测误差。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"优化器\">优化器</h4>\r\n<p>模型优化（Optimization）是在每个训练步骤中调整模型参数以减少模型误差的过程。MindSpore提供多种优化算法的实现，称之为优化器（Optimizer）。优化器内部定义了模型的参数优化过程（即梯度如何更新至模型参数），所有优化逻辑都封装在优化器对象中。在这里，我们使用SGD（Stochastic\r\nGradient Descent）优化器。</p>\r\n<p>我们通过<code>model.trainable_params()</code>方法获得模型的可训练参数，并传入学习率超参来初始化优化器。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)</span><br></pre></td></tr></table></figure>\r\n<p><em>class</em>mindspore.experimental.optim.<strong>SGD</strong>(<em>params</em>,\r\n<em>lr</em>, <em>momentum=0</em>, <em>dampening=0</em>,\r\n<em>weight_decay=0</em>, <em>nesterov=False</em>, **<em>,\r\n</em>maximize=False*)</p>\r\n<p>随机梯度下降算法。 <span class=\"math display\">\\[\r\nv_{t+1} = u \\ast v_{t} + gradient \\ast (1-dampening)\r\n\\]</span> 如果nesterov为True： <span class=\"math display\">\\[\r\np_{t+1} = p_{t} - lr \\ast (gradient + u \\ast v_{t+1})\r\n\\]</span> 如果nesterov为False： <span class=\"math display\">\\[\r\np_{t+1} = p_{t} - lr \\ast v_{t+1}\r\n\\]</span> 需要注意的是，对于训练的第一步\r\n𝑣𝑡+1=𝑔𝑟𝑎𝑑𝑖𝑒𝑛𝑡。其中，p、v和u分别表示 parameters、accum 和 momentum。</p>\r\n<h4 id=\"训练与评估\">训练与评估</h4>\r\n<p>设置了超参、损失函数和优化器后，我们就可以循环输入数据来训练模型。一次数据集的完整迭代循环称为一轮（epoch）。每轮执行训练时包括两个步骤：</p>\r\n<ol type=\"1\">\r\n<li>训练：迭代训练数据集，并尝试收敛到最佳参数。</li>\r\n<li>验证/测试：迭代测试数据集，以检查模型性能是否提升。</li>\r\n</ol>\r\n<p>接下来我们定义用于训练的<code>train_loop</code>函数和用于测试的<code>test_loop</code>函数。</p>\r\n<p>使用函数式自动微分，需先定义正向函数<code>forward_fn</code>，使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUudmFsdWVfYW5kX2dyYWQuaHRtbA==\">value_and_grad<i class=\"fa fa-external-link-alt\"></i></span>获得微分函数<code>grad_fn</code>。然后，我们将微分函数和优化器的执行封装为<code>train_step</code>函数，接下来循环迭代数据集进行训练即可。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    logits = model(data)</span><br><span class=\"line\">    loss = loss_fn(logits, label)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, logits</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get gradient function</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, optimizer.parameters, has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Define function of one-step training</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_step</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    (loss, _), grads = grad_fn(data, label)</span><br><span class=\"line\">    optimizer(grads)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_loop</span>(<span class=\"params\">model, dataset</span>):</span><br><span class=\"line\">    size = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> batch, (data, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        loss = train_step(data, label)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> batch % <span class=\"number\">100</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            loss, current = loss.asnumpy(), batch</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;loss: <span class=\"subst\">&#123;loss:&gt;7f&#125;</span>  [<span class=\"subst\">&#123;current:&gt;3d&#125;</span>/<span class=\"subst\">&#123;size:&gt;3d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p><code>test_loop</code>函数同样需循环遍历数据集，调用模型计算loss和Accuray并返回最终结果。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_loop</span>(<span class=\"params\">model, dataset, loss_fn</span>):</span><br><span class=\"line\">    num_batches = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\">    total, test_loss, correct = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> dataset.create_tuple_iterator():</span><br><span class=\"line\">        pred = model(data)</span><br><span class=\"line\">        total += <span class=\"built_in\">len</span>(data)</span><br><span class=\"line\">        test_loss += loss_fn(pred, label).asnumpy()</span><br><span class=\"line\">        correct += (pred.argmax(<span class=\"number\">1</span>) == label).asnumpy().<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">    test_loss /= num_batches</span><br><span class=\"line\">    correct /= total</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Test: \\n Accuracy: <span class=\"subst\">&#123;(<span class=\"number\">100</span>*correct):&gt;<span class=\"number\">0.1</span>f&#125;</span>%, Avg loss: <span class=\"subst\">&#123;test_loss:&gt;8f&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>我们将实例化的损失函数和优化器传入<code>train_loop</code>和<code>test_loop</code>中。训练3轮并输出loss和Accuracy，查看性能变化。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(epochs):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Epoch <span class=\"subst\">&#123;t+<span class=\"number\">1</span>&#125;</span>\\n-------------------------------&quot;</span>)</span><br><span class=\"line\">    train_loop(model, train_dataset)</span><br><span class=\"line\">    test_loop(model, test_dataset, loss_fn)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Epoch 1</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 2.302806  [  0/938]</span><br><span class=\"line\">loss: 2.285086  [100/938]</span><br><span class=\"line\">loss: 2.264712  [200/938]</span><br><span class=\"line\">loss: 2.174010  [300/938]</span><br><span class=\"line\">loss: 1.931853  [400/938]</span><br><span class=\"line\">loss: 1.340721  [500/938]</span><br><span class=\"line\">loss: 0.953515  [600/938]</span><br><span class=\"line\">loss: 0.756860  [700/938]</span><br><span class=\"line\">loss: 0.756263  [800/938]</span><br><span class=\"line\">loss: 0.463846  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 84.7%, Avg loss: 0.527155</span><br><span class=\"line\"></span><br><span class=\"line\">Epoch 2</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 0.479126  [  0/938]</span><br><span class=\"line\">loss: 0.437443  [100/938]</span><br><span class=\"line\">loss: 0.685504  [200/938]</span><br><span class=\"line\">loss: 0.395121  [300/938]</span><br><span class=\"line\">loss: 0.550566  [400/938]</span><br><span class=\"line\">loss: 0.459457  [500/938]</span><br><span class=\"line\">loss: 0.293049  [600/938]</span><br><span class=\"line\">loss: 0.422102  [700/938]</span><br><span class=\"line\">loss: 0.333153  [800/938]</span><br><span class=\"line\">loss: 0.412182  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 90.5%, Avg loss: 0.335083</span><br><span class=\"line\"></span><br><span class=\"line\">Epoch 3</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 0.207366  [  0/938]</span><br><span class=\"line\">loss: 0.343559  [100/938]</span><br><span class=\"line\">loss: 0.391145  [200/938]</span><br><span class=\"line\">loss: 0.317566  [300/938]</span><br><span class=\"line\">loss: 0.200746  [400/938]</span><br><span class=\"line\">loss: 0.445798  [500/938]</span><br><span class=\"line\">loss: 0.603720  [600/938]</span><br><span class=\"line\">loss: 0.170811  [700/938]</span><br><span class=\"line\">loss: 0.411954  [800/938]</span><br><span class=\"line\">loss: 0.315902  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 91.9%, Avg loss: 0.279034</span><br><span class=\"line\"></span><br><span class=\"line\">Done!</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>读者可以修改参数多跑几边，观察数据的变化，不懂随机梯度下降算法或不懂正向反向传播、学习率乃至超参的概念可以回顾之前文章中提到的视频并重复观看之前的文章，这几个概念应该比较好理解。</p>"},{"title":"MindSpore专题——番外、Trans Fore模型","date":"2024-08-14T11:47:58.000Z","_content":"# Transformer\n\nTransformer是一种神经网络结构，有Vaswani等人在2017年的论文“Attention Is All You Need”中提出，用于处理机器翻译、语言建模和文本生成登自然语言处理任务。\n\n<!--more-->\n\nTransformer与传统NLP特征提取类模型的区别主要在以下两点。\n\n- Transformer是一个纯基于注意力机制的结构，并将自**注意力机制**和**多头注意力机制**的概念运用到模型中；\n- 由于缺少RNN模型的时序性，Transformer引入了位置编码，在数据上而非模型中添加位置信息；\n\n以上的处理带来了几个优点\n\n- 更容易并行化，训练更加高效；\n- 在处理长序列的任务中表现优秀，可以快速捕捉长距离中的关联信息；\n\n## 注意力机制\n\n注意力机制是判断词在句子中的重要性，通过**注意力分数**来表达某个词在句子中的重要性\n\n### 注意力分数的计算\n\n#### query、key、value\n\n- query:任务内容_目标序列_\n- key:索引/标签（帮助定位到答案）_原序列_\n- value:答案\n\n![image-20240629145758835](https://s2.loli.net/2024/06/29/ESPv4kLWxinFZqy.png)\n\n#### 常用的计算注意力分数的方法\n\nadditive attention可加性注意力计算方法\n\nscaled dot-product attention缩放的“点-积”注意力\n\n","source":"_posts/special_subject/MindSpore/Chapters/TransformerStructure.md","raw":"---\ntitle: MindSpore专题——番外、Trans Fore模型\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n# Transformer\n\nTransformer是一种神经网络结构，有Vaswani等人在2017年的论文“Attention Is All You Need”中提出，用于处理机器翻译、语言建模和文本生成登自然语言处理任务。\n\n<!--more-->\n\nTransformer与传统NLP特征提取类模型的区别主要在以下两点。\n\n- Transformer是一个纯基于注意力机制的结构，并将自**注意力机制**和**多头注意力机制**的概念运用到模型中；\n- 由于缺少RNN模型的时序性，Transformer引入了位置编码，在数据上而非模型中添加位置信息；\n\n以上的处理带来了几个优点\n\n- 更容易并行化，训练更加高效；\n- 在处理长序列的任务中表现优秀，可以快速捕捉长距离中的关联信息；\n\n## 注意力机制\n\n注意力机制是判断词在句子中的重要性，通过**注意力分数**来表达某个词在句子中的重要性\n\n### 注意力分数的计算\n\n#### query、key、value\n\n- query:任务内容_目标序列_\n- key:索引/标签（帮助定位到答案）_原序列_\n- value:答案\n\n![image-20240629145758835](https://s2.loli.net/2024/06/29/ESPv4kLWxinFZqy.png)\n\n#### 常用的计算注意力分数的方法\n\nadditive attention可加性注意力计算方法\n\nscaled dot-product attention缩放的“点-积”注意力\n\n","slug":"special_subject/MindSpore/Chapters/TransformerStructure","published":1,"updated":"2024-08-16T08:59:16.882Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjbk00a9lowvbwh69gbk","content":"<h1 id=\"transformer\">Transformer</h1>\r\n<p>Transformer是一种神经网络结构，有Vaswani等人在2017年的论文“Attention\r\nIs All You\r\nNeed”中提出，用于处理机器翻译、语言建模和文本生成登自然语言处理任务。</p>\r\n<span id=\"more\"></span>\r\n<p>Transformer与传统NLP特征提取类模型的区别主要在以下两点。</p>\r\n<ul>\r\n<li>Transformer是一个纯基于注意力机制的结构，并将自<strong>注意力机制</strong>和<strong>多头注意力机制</strong>的概念运用到模型中；</li>\r\n<li>由于缺少RNN模型的时序性，Transformer引入了位置编码，在数据上而非模型中添加位置信息；</li>\r\n</ul>\r\n<p>以上的处理带来了几个优点</p>\r\n<ul>\r\n<li>更容易并行化，训练更加高效；</li>\r\n<li>在处理长序列的任务中表现优秀，可以快速捕捉长距离中的关联信息；</li>\r\n</ul>\r\n<h2 id=\"注意力机制\">注意力机制</h2>\r\n<p>注意力机制是判断词在句子中的重要性，通过<strong>注意力分数</strong>来表达某个词在句子中的重要性</p>\r\n<h3 id=\"注意力分数的计算\">注意力分数的计算</h3>\r\n<h4 id=\"querykeyvalue\">query、key、value</h4>\r\n<ul>\r\n<li>query:任务内容_目标序列_</li>\r\n<li>key:索引/标签（帮助定位到答案）<em>原序列</em></li>\r\n<li>value:答案</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/29/ESPv4kLWxinFZqy.png\"\r\nalt=\"image-20240629145758835\" />\r\n<figcaption aria-hidden=\"true\">image-20240629145758835</figcaption>\r\n</figure>\r\n<h4 id=\"常用的计算注意力分数的方法\">常用的计算注意力分数的方法</h4>\r\n<p>additive attention可加性注意力计算方法</p>\r\n<p>scaled dot-product attention缩放的“点-积”注意力</p>\r\n","length":325,"excerpt":"<h1 id=\"transformer\">Transformer</h1>\r\n<p>Transformer是一种神经网络结构，有Vaswani等人在2017年的论文“Attention\r\nIs All You\r\nNeed”中提出，用于处理机器翻译、语言建模和文本生成登自然语言处理任务。</p>","more":"<p>Transformer与传统NLP特征提取类模型的区别主要在以下两点。</p>\r\n<ul>\r\n<li>Transformer是一个纯基于注意力机制的结构，并将自<strong>注意力机制</strong>和<strong>多头注意力机制</strong>的概念运用到模型中；</li>\r\n<li>由于缺少RNN模型的时序性，Transformer引入了位置编码，在数据上而非模型中添加位置信息；</li>\r\n</ul>\r\n<p>以上的处理带来了几个优点</p>\r\n<ul>\r\n<li>更容易并行化，训练更加高效；</li>\r\n<li>在处理长序列的任务中表现优秀，可以快速捕捉长距离中的关联信息；</li>\r\n</ul>\r\n<h2 id=\"注意力机制\">注意力机制</h2>\r\n<p>注意力机制是判断词在句子中的重要性，通过<strong>注意力分数</strong>来表达某个词在句子中的重要性</p>\r\n<h3 id=\"注意力分数的计算\">注意力分数的计算</h3>\r\n<h4 id=\"querykeyvalue\">query、key、value</h4>\r\n<ul>\r\n<li>query:任务内容_目标序列_</li>\r\n<li>key:索引/标签（帮助定位到答案）<em>原序列</em></li>\r\n<li>value:答案</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/29/ESPv4kLWxinFZqy.png\"\r\nalt=\"image-20240629145758835\" />\r\n<figcaption aria-hidden=\"true\">image-20240629145758835</figcaption>\r\n</figure>\r\n<h4 id=\"常用的计算注意力分数的方法\">常用的计算注意力分数的方法</h4>\r\n<p>additive attention可加性注意力计算方法</p>\r\n<p>scaled dot-product attention缩放的“点-积”注意力</p>"},{"title":"MindSpore专题——第三章——张量","date":"2024-08-14T11:47:58.000Z","_content":"## 张量 Tensor\n\n​\t张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 $n$ 维空间内，有 $n^r$ 个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。$r$ 称为该张量的秩或阶（与矩阵的秩和阶均无关系）。\n\n<!--more-->\n\n​\t张量是一种特殊的数据结构，与数组和矩阵非常相似，他表示的是一种多维的“矩阵”的集合。张量（[Tensor](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.Tensor.html)）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。\n\n​\t*矩阵的秩或阶是人工智能中基础且常考的考点：一般形式是求矩阵秩是多少*\n\n下面是对张量在MindSpore中的实践\n\n### 创建张量\n\n1. **根据数据直接生成**\n\n```python\ndata = [1, 0, 1, 0]\nx_data = Tensor(data)\nprint(x_data, x_data.shape, x_data.dtype)\n```\n\n> [1 0 1 0] (4,) Int64\n\n2. **从NumPy数组生成**\n\n```python\nnp_array = np.array(data)\nx_np = Tensor(np_array)\nprint(x_np, x_np.shape, x_np.dtype)\n```\n\n> [1 0 1 0] (4,) Int64\n\n3. **使用init初始化器构造张量**\n\n​\t当使用`init`初始化器对张量进行初始化时，支持传入的参数有`init`、`shape`、`dtype`。\n\n   - `init`: 支持传入[initializer](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html)的子类。如：下方示例中的 [One()](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html#mindspore.common.initializer.One) 和 [Normal()](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html#mindspore.common.initializer.Normal)。\n\n  - `shape`: 支持传入 `list`、`tuple`、 `int`。\n\n  - `dtype`: 支持传入[mindspore.dtype](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.dtype.html#mindspore.dtype)。\n\n4. 继承张量并形成新的张量\n\n```python\nfrom mindspore import ops\n\nx_ones = ops.ones_like(x_data)\nprint(f\"Ones Tensor: \\n {x_ones} \\n\")\n\nx_zeros = ops.zeros_like(x_data)\nprint(f\"Zeros Tensor: \\n {x_zeros} \\n\")\n```\n\n### 张量的属性\n\n- 张量的属性包括形状、数据类型、转置张量、单个元素大小、占用字节数量、维数、元素个数和每一维步长。\n  - 形状（shape）：`Tensor`的shape，是一个tuple（元组，python中的数据类型标签）。\n  - 数据类型（dtype）：`Tensor`的dtype，是MindSpore的一个数据类型。\n  - 单个元素大小（itemsize）： `Tensor`中每一个元素占用字节数，是一个整数。\n  - 占用字节数量（nbytes）： `Tensor`占用的总字节数，是一个整数。\n  - 维数（ndim）： `Tensor`的秩，也就是len(tensor.shape)，是一个整数。\n  - 元素个数（size）： `Tensor`中所有元素的个数，是一个整数。\n  - 每一维步长（strides）： `Tensor`每一维所需要的字节数，是一个tuple。\n\n为更简单的理解shape的含义，我修改了一下官方文档中的x张量\n\n```python\nx = Tensor(np.array([[1, 2], [3, 4], [5, 6]]), mindspore.int32)\n\nprint(\"x_shape:\", x.shape)\nprint(\"x_dtype:\", x.dtype)\nprint(\"x_itemsize:\", x.itemsize)\nprint(\"x_nbytes:\", x.nbytes)\nprint(\"x_ndim:\", x.ndim)\nprint(\"x_size:\", x.size)\nprint(\"x_strides:\", x.strides)\n```\n\n> x_shape: (3, 2)\n> x_dtype: Int32\n> x_itemsize: 4\n> x_nbytes: 24\n> x_ndim: 2\n> x_size: 6\n> x_strides: (8, 4)\n\n### 张量的下标索引\n\nTensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号`:`和 `...`用于对数据进行切片。切片的意思是后面的参数是按行算的还是按列算的，详细请看代码\n\n```\ntensor = Tensor(np.array([[0, 1], [2, 3]]).astype(np.float32))\n\nprint(\"First row: {}\".format(tensor[0]))\nprint(\"value of bottom right corner: {}\".format(tensor[1, 1]))\nprint(\"Last column: {}\".format(tensor[:, -1]))\nprint(\"First column: {}\".format(tensor[..., 0]))\n```\n\n> First row: [0. 1.]\n> value of bottom right corner: 3.0\n> Last column: [1. 3.]\n> First column: [0. 2.]\n\n### 张量运算\n\n张量之间有很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，张量运算和NumPy的使用方式类似，下面介绍其中几种操作。\n\n> 普通算术运算有：加（+）、减（-）、乘（*）、除（/）、取模（%）、整除（//）。\n\n```python\nx = Tensor(np.array([1, 2, 3]), mindspore.float32)\ny = Tensor(np.array([4, 5, 6]), mindspore.float32)\n\noutput_add = x + y\noutput_sub = x - y\noutput_mul = x * y\noutput_div = y / x\noutput_mod = y % x\noutput_floordiv = y // x\n\nprint(\"add:\", output_add)\nprint(\"sub:\", output_sub)\nprint(\"mul:\", output_mul)\nprint(\"div:\", output_div)\nprint(\"mod:\", output_mod)\nprint(\"floordiv:\", output_floordiv)\n```\n\n> add: [5. 7. 9.]\n> sub: [-3. -3. -3.]\n> mul: [ 4. 10. 18.]\n> div: [4.  2.5 2. ]\n> mod: [0. 1. 0.]\n> floordiv: [4. 2. 2.]\n\n对于一些函数的使用，这里之贴出定义，详细运行库中代码（个人觉得没必要，知道这些函数即可，毕竟到处可见类似函数）\n\n[concat](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.concat.html)() : 将给定维度上的一系列张量连接起来，0表示最高得也就是直接通过`张量名[下标索引]`时的张量名所代表的元组。\n\n[stack](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.stack.html)()：则是从另一个维度上将两个张量合并起来。（新建一个维度）\n\n### Tensor与Numpy之间的相互转化\n\nTensor() : 将ndarray转化为Tensor\n\nasnumpy()：将Tensor转化为ndarray\n\n```python\nt = Tensor([1., 1., 1., 1., 1.])\nprint(f\"t: {t}\", type(t))\nn = t.asnumpy()\nprint(f\"n: {n}\", type(n))\n```\n\n> t: [1. 1. 1. 1. 1.] <class 'mindspore.common.tensor.Tensor'>\n> n: [1. 1. 1. 1. 1.] <class 'numpy.ndarray'>\n\n将NumPy变量转换为Tensor变量同样也不贴出来了，详情请运行本章代码对应部分查看\n\n有一个值得注意的点： \n\n当我们运行代码时调用了`np.add(n, 1, out=n)`函数，该函数**同时改变了我们的Numpy数据和Tensor数据**，这说明当我们进行转化时我们并没有创建新的变量，而是创建了新的变量指针。\n\n## 稀疏张量\n\n稀疏张量是一种特殊张量，其中绝大部分元素的值为零。\n\n在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。\n\n两种常用的稀疏张量格式\n\n1. CRS（Compressed Sparse Row）其中，非零元素的值存储在`values`中，非零元素的位置存储在`indptr`（行）和`indices`（列）中。\n2. COOCoordinate Format）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为`N`，被压缩的张量的维数为`ndims`。\n\n常用稀疏张量的表达形式是`<indices:Tensor, values:Tensor, shape:Tensor>`。其中，`indices`表示非零下标元素， `values`表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。在这个结构下，我们定义了三种稀疏张量结构：`CSRTensor`、`COOTensor`和`RowTensor`。\n\n### CSRTensor\n\n- `indptr`: 一维整数张量, 表示稀疏数据每一行的非零元素在`values`中的起始位置和终止位置, 索引数据类型支持int16、int32、int64。\n- `indices`: 一维整数张量，表示稀疏张量非零元素在列中的位置, 与`values`长度相等，索引数据类型支持int16、int32、int64。\n- `values`: 一维张量，表示`CSRTensor`相对应的非零元素的值，与`indices`长度相等。\n- `shape`: 表示被压缩的稀疏张量的形状，数据类型为`Tuple`，目前仅支持二维`CSRTensor`。\n\n### COOTensor\n\n- `indices`: 二维整数张量，每行代表非零元素下标。形状：`[N, ndims]`， 索引数据类型支持int16、int32、int64。\n- `values`: 一维张量，表示相对应的非零元素的值。形状：`[N]`。\n- `shape`: 表示被压缩的稀疏张量的形状，目前仅支持二维`COOTensor`。\n\n### 使用实例\n\n在源代码最后有CSRTensor、COOTensor的使用实例\n\n这里得给出代码，我做了一些修改，不然不好理解\n\n```python\n# CSRTensor 稀疏张量表实例\nindptr = Tensor([0, 1, 2])\nindices = Tensor([0, 1])\nvalues = Tensor([1, 2], dtype=mindspore.float32)\nshape = (2, 4)\n\n# Make a CSRTensor\ncsr_tensor = CSRTensor(indptr, indices, values, shape)\n\nprint(csr_tensor.astype(mindspore.float64).dtype)\n\nprint(csr_tensor)\n\nindices = Tensor([[0, 1], [1, 2]], dtype=mindspore.int32)\nvalues = Tensor([1, 2], dtype=mindspore.float32)\nshape = (3, 4)\n\n# Make a COOTensor\ncoo_tensor = COOTensor(indices, values, shape)\n\nprint(coo_tensor)\n\n```\n\n> Float64\n> CSRTensor(shape=[2, 4], \n>\n> dtype=Float32,\n>\n>  indptr=Tensor(shape=[3], dtype=Int64, value=[0 1 2]), \n>\n> indices=Tensor(shape=[2], dtype=Int64, value=[0 1]), \n>\n> values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))\n> COOTensor(shape=[3, 4], \n>\n> dtype=Float32, \n>\n> indices=Tensor(shape=[2, 2], dtype=Int32, value=[[0 1] [1 2]]), \n>\n> values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))\n\n其生成实例如下\n\nCSRTensor: \n$$\n\\begin{split}\\left[\n\\begin{matrix}\n  1 & 0 & 0 & 0 \\\\\n  0 & 2 & 0 & 0\n \\end{matrix}\n \\right]\\end{split}\n$$\nCOOTensor:\n$$\n\\begin{split}\\left[\n\\begin{matrix}\n  0 & 1 & 0 & 0 \\\\\n  0 & 0 & 2 & 0 \\\\\n  0 & 0 & 0 & 0\n \\end{matrix}\n \\right]\\end{split}\n$$\n\n- CSRTensor(indptr, indices, values, shape)： 构造一个CSR稀疏张量表\n- COOTensor(indices, values, shape) ：构造一个COO稀疏张量表\n\n理解不了CSR请参考:[MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.CSRTensor.html)\n\n理解不了COO请参考:[MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.COOTensor.html)\n","source":"_posts/special_subject/MindSpore/Chapters/Third_Tensor.md","raw":"---\ntitle: MindSpore专题——第三章——张量\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## 张量 Tensor\n\n​\t张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 $n$ 维空间内，有 $n^r$ 个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。$r$ 称为该张量的秩或阶（与矩阵的秩和阶均无关系）。\n\n<!--more-->\n\n​\t张量是一种特殊的数据结构，与数组和矩阵非常相似，他表示的是一种多维的“矩阵”的集合。张量（[Tensor](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.Tensor.html)）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。\n\n​\t*矩阵的秩或阶是人工智能中基础且常考的考点：一般形式是求矩阵秩是多少*\n\n下面是对张量在MindSpore中的实践\n\n### 创建张量\n\n1. **根据数据直接生成**\n\n```python\ndata = [1, 0, 1, 0]\nx_data = Tensor(data)\nprint(x_data, x_data.shape, x_data.dtype)\n```\n\n> [1 0 1 0] (4,) Int64\n\n2. **从NumPy数组生成**\n\n```python\nnp_array = np.array(data)\nx_np = Tensor(np_array)\nprint(x_np, x_np.shape, x_np.dtype)\n```\n\n> [1 0 1 0] (4,) Int64\n\n3. **使用init初始化器构造张量**\n\n​\t当使用`init`初始化器对张量进行初始化时，支持传入的参数有`init`、`shape`、`dtype`。\n\n   - `init`: 支持传入[initializer](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html)的子类。如：下方示例中的 [One()](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html#mindspore.common.initializer.One) 和 [Normal()](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html#mindspore.common.initializer.Normal)。\n\n  - `shape`: 支持传入 `list`、`tuple`、 `int`。\n\n  - `dtype`: 支持传入[mindspore.dtype](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.dtype.html#mindspore.dtype)。\n\n4. 继承张量并形成新的张量\n\n```python\nfrom mindspore import ops\n\nx_ones = ops.ones_like(x_data)\nprint(f\"Ones Tensor: \\n {x_ones} \\n\")\n\nx_zeros = ops.zeros_like(x_data)\nprint(f\"Zeros Tensor: \\n {x_zeros} \\n\")\n```\n\n### 张量的属性\n\n- 张量的属性包括形状、数据类型、转置张量、单个元素大小、占用字节数量、维数、元素个数和每一维步长。\n  - 形状（shape）：`Tensor`的shape，是一个tuple（元组，python中的数据类型标签）。\n  - 数据类型（dtype）：`Tensor`的dtype，是MindSpore的一个数据类型。\n  - 单个元素大小（itemsize）： `Tensor`中每一个元素占用字节数，是一个整数。\n  - 占用字节数量（nbytes）： `Tensor`占用的总字节数，是一个整数。\n  - 维数（ndim）： `Tensor`的秩，也就是len(tensor.shape)，是一个整数。\n  - 元素个数（size）： `Tensor`中所有元素的个数，是一个整数。\n  - 每一维步长（strides）： `Tensor`每一维所需要的字节数，是一个tuple。\n\n为更简单的理解shape的含义，我修改了一下官方文档中的x张量\n\n```python\nx = Tensor(np.array([[1, 2], [3, 4], [5, 6]]), mindspore.int32)\n\nprint(\"x_shape:\", x.shape)\nprint(\"x_dtype:\", x.dtype)\nprint(\"x_itemsize:\", x.itemsize)\nprint(\"x_nbytes:\", x.nbytes)\nprint(\"x_ndim:\", x.ndim)\nprint(\"x_size:\", x.size)\nprint(\"x_strides:\", x.strides)\n```\n\n> x_shape: (3, 2)\n> x_dtype: Int32\n> x_itemsize: 4\n> x_nbytes: 24\n> x_ndim: 2\n> x_size: 6\n> x_strides: (8, 4)\n\n### 张量的下标索引\n\nTensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号`:`和 `...`用于对数据进行切片。切片的意思是后面的参数是按行算的还是按列算的，详细请看代码\n\n```\ntensor = Tensor(np.array([[0, 1], [2, 3]]).astype(np.float32))\n\nprint(\"First row: {}\".format(tensor[0]))\nprint(\"value of bottom right corner: {}\".format(tensor[1, 1]))\nprint(\"Last column: {}\".format(tensor[:, -1]))\nprint(\"First column: {}\".format(tensor[..., 0]))\n```\n\n> First row: [0. 1.]\n> value of bottom right corner: 3.0\n> Last column: [1. 3.]\n> First column: [0. 2.]\n\n### 张量运算\n\n张量之间有很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，张量运算和NumPy的使用方式类似，下面介绍其中几种操作。\n\n> 普通算术运算有：加（+）、减（-）、乘（*）、除（/）、取模（%）、整除（//）。\n\n```python\nx = Tensor(np.array([1, 2, 3]), mindspore.float32)\ny = Tensor(np.array([4, 5, 6]), mindspore.float32)\n\noutput_add = x + y\noutput_sub = x - y\noutput_mul = x * y\noutput_div = y / x\noutput_mod = y % x\noutput_floordiv = y // x\n\nprint(\"add:\", output_add)\nprint(\"sub:\", output_sub)\nprint(\"mul:\", output_mul)\nprint(\"div:\", output_div)\nprint(\"mod:\", output_mod)\nprint(\"floordiv:\", output_floordiv)\n```\n\n> add: [5. 7. 9.]\n> sub: [-3. -3. -3.]\n> mul: [ 4. 10. 18.]\n> div: [4.  2.5 2. ]\n> mod: [0. 1. 0.]\n> floordiv: [4. 2. 2.]\n\n对于一些函数的使用，这里之贴出定义，详细运行库中代码（个人觉得没必要，知道这些函数即可，毕竟到处可见类似函数）\n\n[concat](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.concat.html)() : 将给定维度上的一系列张量连接起来，0表示最高得也就是直接通过`张量名[下标索引]`时的张量名所代表的元组。\n\n[stack](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.stack.html)()：则是从另一个维度上将两个张量合并起来。（新建一个维度）\n\n### Tensor与Numpy之间的相互转化\n\nTensor() : 将ndarray转化为Tensor\n\nasnumpy()：将Tensor转化为ndarray\n\n```python\nt = Tensor([1., 1., 1., 1., 1.])\nprint(f\"t: {t}\", type(t))\nn = t.asnumpy()\nprint(f\"n: {n}\", type(n))\n```\n\n> t: [1. 1. 1. 1. 1.] <class 'mindspore.common.tensor.Tensor'>\n> n: [1. 1. 1. 1. 1.] <class 'numpy.ndarray'>\n\n将NumPy变量转换为Tensor变量同样也不贴出来了，详情请运行本章代码对应部分查看\n\n有一个值得注意的点： \n\n当我们运行代码时调用了`np.add(n, 1, out=n)`函数，该函数**同时改变了我们的Numpy数据和Tensor数据**，这说明当我们进行转化时我们并没有创建新的变量，而是创建了新的变量指针。\n\n## 稀疏张量\n\n稀疏张量是一种特殊张量，其中绝大部分元素的值为零。\n\n在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。\n\n两种常用的稀疏张量格式\n\n1. CRS（Compressed Sparse Row）其中，非零元素的值存储在`values`中，非零元素的位置存储在`indptr`（行）和`indices`（列）中。\n2. COOCoordinate Format）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为`N`，被压缩的张量的维数为`ndims`。\n\n常用稀疏张量的表达形式是`<indices:Tensor, values:Tensor, shape:Tensor>`。其中，`indices`表示非零下标元素， `values`表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。在这个结构下，我们定义了三种稀疏张量结构：`CSRTensor`、`COOTensor`和`RowTensor`。\n\n### CSRTensor\n\n- `indptr`: 一维整数张量, 表示稀疏数据每一行的非零元素在`values`中的起始位置和终止位置, 索引数据类型支持int16、int32、int64。\n- `indices`: 一维整数张量，表示稀疏张量非零元素在列中的位置, 与`values`长度相等，索引数据类型支持int16、int32、int64。\n- `values`: 一维张量，表示`CSRTensor`相对应的非零元素的值，与`indices`长度相等。\n- `shape`: 表示被压缩的稀疏张量的形状，数据类型为`Tuple`，目前仅支持二维`CSRTensor`。\n\n### COOTensor\n\n- `indices`: 二维整数张量，每行代表非零元素下标。形状：`[N, ndims]`， 索引数据类型支持int16、int32、int64。\n- `values`: 一维张量，表示相对应的非零元素的值。形状：`[N]`。\n- `shape`: 表示被压缩的稀疏张量的形状，目前仅支持二维`COOTensor`。\n\n### 使用实例\n\n在源代码最后有CSRTensor、COOTensor的使用实例\n\n这里得给出代码，我做了一些修改，不然不好理解\n\n```python\n# CSRTensor 稀疏张量表实例\nindptr = Tensor([0, 1, 2])\nindices = Tensor([0, 1])\nvalues = Tensor([1, 2], dtype=mindspore.float32)\nshape = (2, 4)\n\n# Make a CSRTensor\ncsr_tensor = CSRTensor(indptr, indices, values, shape)\n\nprint(csr_tensor.astype(mindspore.float64).dtype)\n\nprint(csr_tensor)\n\nindices = Tensor([[0, 1], [1, 2]], dtype=mindspore.int32)\nvalues = Tensor([1, 2], dtype=mindspore.float32)\nshape = (3, 4)\n\n# Make a COOTensor\ncoo_tensor = COOTensor(indices, values, shape)\n\nprint(coo_tensor)\n\n```\n\n> Float64\n> CSRTensor(shape=[2, 4], \n>\n> dtype=Float32,\n>\n>  indptr=Tensor(shape=[3], dtype=Int64, value=[0 1 2]), \n>\n> indices=Tensor(shape=[2], dtype=Int64, value=[0 1]), \n>\n> values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))\n> COOTensor(shape=[3, 4], \n>\n> dtype=Float32, \n>\n> indices=Tensor(shape=[2, 2], dtype=Int32, value=[[0 1] [1 2]]), \n>\n> values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))\n\n其生成实例如下\n\nCSRTensor: \n$$\n\\begin{split}\\left[\n\\begin{matrix}\n  1 & 0 & 0 & 0 \\\\\n  0 & 2 & 0 & 0\n \\end{matrix}\n \\right]\\end{split}\n$$\nCOOTensor:\n$$\n\\begin{split}\\left[\n\\begin{matrix}\n  0 & 1 & 0 & 0 \\\\\n  0 & 0 & 2 & 0 \\\\\n  0 & 0 & 0 & 0\n \\end{matrix}\n \\right]\\end{split}\n$$\n\n- CSRTensor(indptr, indices, values, shape)： 构造一个CSR稀疏张量表\n- COOTensor(indices, values, shape) ：构造一个COO稀疏张量表\n\n理解不了CSR请参考:[MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.CSRTensor.html)\n\n理解不了COO请参考:[MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.COOTensor.html)\n","slug":"special_subject/MindSpore/Chapters/Third_Tensor","published":1,"updated":"2024-08-16T08:59:14.447Z","comments":1,"layout":"post","photos":[],"_id":"clzwonjbk00aclowvhi9o9o3w","content":"<h2 id=\"张量-tensor\">张量 Tensor</h2>\r\n<p>​\r\n张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 <span\r\nclass=\"math inline\">\\(n\\)</span> 维空间内，有 <span\r\nclass=\"math inline\">\\(n^r\\)</span>\r\n个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。<span\r\nclass=\"math inline\">\\(r\\)</span>\r\n称为该张量的秩或阶（与矩阵的秩和阶均无关系）。</p>\r\n<span id=\"more\"></span>\r\n<p>​\r\n张量是一种特殊的数据结构，与数组和矩阵非常相似，他表示的是一种多维的“矩阵”的集合。张量（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuVGVuc29yLmh0bWw=\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。</p>\r\n<p>​\r\n<em>矩阵的秩或阶是人工智能中基础且常考的考点：一般形式是求矩阵秩是多少</em></p>\r\n<p>下面是对张量在MindSpore中的实践</p>\r\n<h3 id=\"创建张量\">创建张量</h3>\r\n<ol type=\"1\">\r\n<li><strong>根据数据直接生成</strong></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">x_data = Tensor(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_data, x_data.shape, x_data.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[1 0 1 0] (4,) Int64</p>\r\n</blockquote>\r\n<ol start=\"2\" type=\"1\">\r\n<li><strong>从NumPy数组生成</strong></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np_array = np.array(data)</span><br><span class=\"line\">x_np = Tensor(np_array)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_np, x_np.shape, x_np.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[1 0 1 0] (4,) Int64</p>\r\n</blockquote>\r\n<ol start=\"3\" type=\"1\">\r\n<li><strong>使用init初始化器构造张量</strong></li>\r\n</ol>\r\n<p>​\r\n当使用<code>init</code>初始化器对张量进行初始化时，支持传入的参数有<code>init</code>、<code>shape</code>、<code>dtype</code>。</p>\r\n<ul>\r\n<li><p><code>init</code>: 支持传入<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbA==\">initializer<i class=\"fa fa-external-link-alt\"></i></span>的子类。如：下方示例中的\r\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbCNtaW5kc3BvcmUuY29tbW9uLmluaXRpYWxpemVyLk9uZQ==\">One()<i class=\"fa fa-external-link-alt\"></i></span>\r\n和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbCNtaW5kc3BvcmUuY29tbW9uLmluaXRpYWxpemVyLk5vcm1hbA==\">Normal()<i class=\"fa fa-external-link-alt\"></i></span>。</p></li>\r\n<li><p><code>shape</code>: 支持传入\r\n<code>list</code>、<code>tuple</code>、 <code>int</code>。</p></li>\r\n<li><p><code>dtype</code>: 支持传入<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZHR5cGUuaHRtbCNtaW5kc3BvcmUuZHR5cGU=\">mindspore.dtype<i class=\"fa fa-external-link-alt\"></i></span>。</p></li>\r\n</ul>\r\n<ol start=\"4\" type=\"1\">\r\n<li>继承张量并形成新的张量</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> mindspore <span class=\"keyword\">import</span> ops</span><br><span class=\"line\"></span><br><span class=\"line\">x_ones = ops.ones_like(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Ones Tensor: \\n <span class=\"subst\">&#123;x_ones&#125;</span> \\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">x_zeros = ops.zeros_like(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Zeros Tensor: \\n <span class=\"subst\">&#123;x_zeros&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"张量的属性\">张量的属性</h3>\r\n<ul>\r\n<li>张量的属性包括形状、数据类型、转置张量、单个元素大小、占用字节数量、维数、元素个数和每一维步长。\r\n<ul>\r\n<li>形状（shape）：<code>Tensor</code>的shape，是一个tuple（元组，python中的数据类型标签）。</li>\r\n<li>数据类型（dtype）：<code>Tensor</code>的dtype，是MindSpore的一个数据类型。</li>\r\n<li>单个元素大小（itemsize）：\r\n<code>Tensor</code>中每一个元素占用字节数，是一个整数。</li>\r\n<li>占用字节数量（nbytes）：\r\n<code>Tensor</code>占用的总字节数，是一个整数。</li>\r\n<li>维数（ndim）：\r\n<code>Tensor</code>的秩，也就是len(tensor.shape)，是一个整数。</li>\r\n<li>元素个数（size）：\r\n<code>Tensor</code>中所有元素的个数，是一个整数。</li>\r\n<li>每一维步长（strides）：\r\n<code>Tensor</code>每一维所需要的字节数，是一个tuple。</li>\r\n</ul></li>\r\n</ul>\r\n<p>为更简单的理解shape的含义，我修改了一下官方文档中的x张量</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = Tensor(np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">5</span>, <span class=\"number\">6</span>]]), mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_shape:&quot;</span>, x.shape)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_dtype:&quot;</span>, x.dtype)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_itemsize:&quot;</span>, x.itemsize)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_nbytes:&quot;</span>, x.nbytes)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_ndim:&quot;</span>, x.ndim)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_size:&quot;</span>, x.size)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_strides:&quot;</span>, x.strides)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>x_shape: (3, 2) x_dtype: Int32 x_itemsize: 4 x_nbytes: 24 x_ndim: 2\r\nx_size: 6 x_strides: (8, 4)</p>\r\n</blockquote>\r\n<h3 id=\"张量的下标索引\">张量的下标索引</h3>\r\n<p>Tensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号<code>:</code>和\r\n<code>...</code>用于对数据进行切片。切片的意思是后面的参数是按行算的还是按列算的，详细请看代码</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tensor = Tensor(np.array([[0, 1], [2, 3]]).astype(np.float32))</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;First row: &#123;&#125;&quot;.format(tensor[0]))</span><br><span class=\"line\">print(&quot;value of bottom right corner: &#123;&#125;&quot;.format(tensor[1, 1]))</span><br><span class=\"line\">print(&quot;Last column: &#123;&#125;&quot;.format(tensor[:, -1]))</span><br><span class=\"line\">print(&quot;First column: &#123;&#125;&quot;.format(tensor[..., 0]))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>First row: [0. 1.] value of bottom right corner: 3.0 Last column: [1.\r\n3.] First column: [0. 2.]</p>\r\n</blockquote>\r\n<h3 id=\"张量运算\">张量运算</h3>\r\n<p>张量之间有很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，张量运算和NumPy的使用方式类似，下面介绍其中几种操作。</p>\r\n<blockquote>\r\n<p>普通算术运算有：加（+）、减（-）、乘（*）、除（/）、取模（%）、整除（//）。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = Tensor(np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]), mindspore.float32)</span><br><span class=\"line\">y = Tensor(np.array([<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]), mindspore.float32)</span><br><span class=\"line\"></span><br><span class=\"line\">output_add = x + y</span><br><span class=\"line\">output_sub = x - y</span><br><span class=\"line\">output_mul = x * y</span><br><span class=\"line\">output_div = y / x</span><br><span class=\"line\">output_mod = y % x</span><br><span class=\"line\">output_floordiv = y // x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;add:&quot;</span>, output_add)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;sub:&quot;</span>, output_sub)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;mul:&quot;</span>, output_mul)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;div:&quot;</span>, output_div)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;mod:&quot;</span>, output_mod)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;floordiv:&quot;</span>, output_floordiv)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>add: [5. 7. 9.] sub: [-3. -3. -3.] mul: [ 4. 10. 18.] div: [4. 2.5 2.\r\n] mod: [0. 1. 0.] floordiv: [4. 2. 2.]</p>\r\n</blockquote>\r\n<p>对于一些函数的使用，这里之贴出定义，详细运行库中代码（个人觉得没必要，知道这些函数即可，毕竟到处可见类似函数）</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLmNvbmNhdC5odG1s\">concat<i class=\"fa fa-external-link-alt\"></i></span>()\r\n:\r\n将给定维度上的一系列张量连接起来，0表示最高得也就是直接通过<code>张量名[下标索引]</code>时的张量名所代表的元组。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLnN0YWNrLmh0bWw=\">stack<i class=\"fa fa-external-link-alt\"></i></span>()：则是从另一个维度上将两个张量合并起来。（新建一个维度）</p>\r\n<h3 id=\"tensor与numpy之间的相互转化\">Tensor与Numpy之间的相互转化</h3>\r\n<p>Tensor() : 将ndarray转化为Tensor</p>\r\n<p>asnumpy()：将Tensor转化为ndarray</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = Tensor([<span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;t: <span class=\"subst\">&#123;t&#125;</span>&quot;</span>, <span class=\"built_in\">type</span>(t))</span><br><span class=\"line\">n = t.asnumpy()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;n: <span class=\"subst\">&#123;n&#125;</span>&quot;</span>, <span class=\"built_in\">type</span>(n))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>t: [1. 1. 1. 1. 1.] &lt;class 'mindspore.common.tensor.Tensor'&gt; n:\r\n[1. 1. 1. 1. 1.] &lt;class 'numpy.ndarray'&gt;</p>\r\n</blockquote>\r\n<p>将NumPy变量转换为Tensor变量同样也不贴出来了，详情请运行本章代码对应部分查看</p>\r\n<p>有一个值得注意的点：</p>\r\n<p>当我们运行代码时调用了<code>np.add(n, 1, out=n)</code>函数，该函数<strong>同时改变了我们的Numpy数据和Tensor数据</strong>，这说明当我们进行转化时我们并没有创建新的变量，而是创建了新的变量指针。</p>\r\n<h2 id=\"稀疏张量\">稀疏张量</h2>\r\n<p>稀疏张量是一种特殊张量，其中绝大部分元素的值为零。</p>\r\n<p>在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。</p>\r\n<p>两种常用的稀疏张量格式</p>\r\n<ol type=\"1\">\r\n<li>CRS（Compressed Sparse\r\nRow）其中，非零元素的值存储在<code>values</code>中，非零元素的位置存储在<code>indptr</code>（行）和<code>indices</code>（列）中。</li>\r\n<li>COOCoordinate\r\nFormat）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为<code>N</code>，被压缩的张量的维数为<code>ndims</code>。</li>\r\n</ol>\r\n<p>常用稀疏张量的表达形式是<code>&lt;indices:Tensor, values:Tensor, shape:Tensor&gt;</code>。其中，<code>indices</code>表示非零下标元素，\r\n<code>values</code>表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。在这个结构下，我们定义了三种稀疏张量结构：<code>CSRTensor</code>、<code>COOTensor</code>和<code>RowTensor</code>。</p>\r\n<h3 id=\"csrtensor\">CSRTensor</h3>\r\n<ul>\r\n<li><code>indptr</code>: 一维整数张量,\r\n表示稀疏数据每一行的非零元素在<code>values</code>中的起始位置和终止位置,\r\n索引数据类型支持int16、int32、int64。</li>\r\n<li><code>indices</code>:\r\n一维整数张量，表示稀疏张量非零元素在列中的位置,\r\n与<code>values</code>长度相等，索引数据类型支持int16、int32、int64。</li>\r\n<li><code>values</code>:\r\n一维张量，表示<code>CSRTensor</code>相对应的非零元素的值，与<code>indices</code>长度相等。</li>\r\n<li><code>shape</code>:\r\n表示被压缩的稀疏张量的形状，数据类型为<code>Tuple</code>，目前仅支持二维<code>CSRTensor</code>。</li>\r\n</ul>\r\n<h3 id=\"cootensor\">COOTensor</h3>\r\n<ul>\r\n<li><code>indices</code>:\r\n二维整数张量，每行代表非零元素下标。形状：<code>[N, ndims]</code>，\r\n索引数据类型支持int16、int32、int64。</li>\r\n<li><code>values</code>:\r\n一维张量，表示相对应的非零元素的值。形状：<code>[N]</code>。</li>\r\n<li><code>shape</code>:\r\n表示被压缩的稀疏张量的形状，目前仅支持二维<code>COOTensor</code>。</li>\r\n</ul>\r\n<h3 id=\"使用实例\">使用实例</h3>\r\n<p>在源代码最后有CSRTensor、COOTensor的使用实例</p>\r\n<p>这里得给出代码，我做了一些修改，不然不好理解</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CSRTensor 稀疏张量表实例</span></span><br><span class=\"line\">indptr = Tensor([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\">indices = Tensor([<span class=\"number\">0</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\">values = Tensor([<span class=\"number\">1</span>, <span class=\"number\">2</span>], dtype=mindspore.float32)</span><br><span class=\"line\">shape = (<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Make a CSRTensor</span></span><br><span class=\"line\">csr_tensor = CSRTensor(indptr, indices, values, shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(csr_tensor.astype(mindspore.float64).dtype)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(csr_tensor)</span><br><span class=\"line\"></span><br><span class=\"line\">indices = Tensor([[<span class=\"number\">0</span>, <span class=\"number\">1</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>]], dtype=mindspore.int32)</span><br><span class=\"line\">values = Tensor([<span class=\"number\">1</span>, <span class=\"number\">2</span>], dtype=mindspore.float32)</span><br><span class=\"line\">shape = (<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Make a COOTensor</span></span><br><span class=\"line\">coo_tensor = COOTensor(indices, values, shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(coo_tensor)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Float64 CSRTensor(shape=[2, 4],</p>\r\n<p>dtype=Float32,</p>\r\n<p>indptr=Tensor(shape=[3], dtype=Int64, value=[0 1 2]),</p>\r\n<p>indices=Tensor(shape=[2], dtype=Int64, value=[0 1]),</p>\r\n<p>values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00\r\n2.00000000e+00])) COOTensor(shape=[3, 4],</p>\r\n<p>dtype=Float32,</p>\r\n<p>indices=Tensor(shape=[2, 2], dtype=Int32, value=[[0 1] [1 2]]),</p>\r\n<p>values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00\r\n2.00000000e+00]))</p>\r\n</blockquote>\r\n<p>其生成实例如下</p>\r\n<p>CSRTensor: <span class=\"math display\">\\[\r\n\\begin{split}\\left[\r\n\\begin{matrix}\r\n  1 &amp; 0 &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 2 &amp; 0 &amp; 0\r\n\\end{matrix}\r\n\\right]\\end{split}\r\n\\]</span> COOTensor: <span class=\"math display\">\\[\r\n\\begin{split}\\left[\r\n\\begin{matrix}\r\n  0 &amp; 1 &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 2 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 0 &amp; 0\r\n\\end{matrix}\r\n\\right]\\end{split}\r\n\\]</span></p>\r\n<ul>\r\n<li>CSRTensor(indptr, indices, values, shape)：\r\n构造一个CSR稀疏张量表</li>\r\n<li>COOTensor(indices, values, shape) ：构造一个COO稀疏张量表</li>\r\n</ul>\r\n<p>理解不了CSR请参考:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuQ1NSVGVuc29yLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>理解不了COO请参考:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuQ09PVGVuc29yLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n","length":2017,"excerpt":"<h2 id=\"张量-tensor\">张量 Tensor</h2>\r\n<p>​\r\n张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 <span\r\nclass=\"math inline\">\\(n\\)</span> 维空间内，有 <span\r\nclass=\"math inline\">\\(n^r\\)</span>\r\n个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。<span\r\nclass=\"math inline\">\\(r\\)</span>\r\n称为该张量的秩或阶（与矩阵的秩和阶均无关系）。</p>","more":"<p>​\r\n张量是一种特殊的数据结构，与数组和矩阵非常相似，他表示的是一种多维的“矩阵”的集合。张量（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuVGVuc29yLmh0bWw=\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。</p>\r\n<p>​\r\n<em>矩阵的秩或阶是人工智能中基础且常考的考点：一般形式是求矩阵秩是多少</em></p>\r\n<p>下面是对张量在MindSpore中的实践</p>\r\n<h3 id=\"创建张量\">创建张量</h3>\r\n<ol type=\"1\">\r\n<li><strong>根据数据直接生成</strong></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">x_data = Tensor(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_data, x_data.shape, x_data.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[1 0 1 0] (4,) Int64</p>\r\n</blockquote>\r\n<ol start=\"2\" type=\"1\">\r\n<li><strong>从NumPy数组生成</strong></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np_array = np.array(data)</span><br><span class=\"line\">x_np = Tensor(np_array)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_np, x_np.shape, x_np.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[1 0 1 0] (4,) Int64</p>\r\n</blockquote>\r\n<ol start=\"3\" type=\"1\">\r\n<li><strong>使用init初始化器构造张量</strong></li>\r\n</ol>\r\n<p>​\r\n当使用<code>init</code>初始化器对张量进行初始化时，支持传入的参数有<code>init</code>、<code>shape</code>、<code>dtype</code>。</p>\r\n<ul>\r\n<li><p><code>init</code>: 支持传入<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbA==\">initializer<i class=\"fa fa-external-link-alt\"></i></span>的子类。如：下方示例中的\r\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbCNtaW5kc3BvcmUuY29tbW9uLmluaXRpYWxpemVyLk9uZQ==\">One()<i class=\"fa fa-external-link-alt\"></i></span>\r\n和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbCNtaW5kc3BvcmUuY29tbW9uLmluaXRpYWxpemVyLk5vcm1hbA==\">Normal()<i class=\"fa fa-external-link-alt\"></i></span>。</p></li>\r\n<li><p><code>shape</code>: 支持传入\r\n<code>list</code>、<code>tuple</code>、 <code>int</code>。</p></li>\r\n<li><p><code>dtype</code>: 支持传入<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZHR5cGUuaHRtbCNtaW5kc3BvcmUuZHR5cGU=\">mindspore.dtype<i class=\"fa fa-external-link-alt\"></i></span>。</p></li>\r\n</ul>\r\n<ol start=\"4\" type=\"1\">\r\n<li>继承张量并形成新的张量</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> mindspore <span class=\"keyword\">import</span> ops</span><br><span class=\"line\"></span><br><span class=\"line\">x_ones = ops.ones_like(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Ones Tensor: \\n <span class=\"subst\">&#123;x_ones&#125;</span> \\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">x_zeros = ops.zeros_like(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Zeros Tensor: \\n <span class=\"subst\">&#123;x_zeros&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"张量的属性\">张量的属性</h3>\r\n<ul>\r\n<li>张量的属性包括形状、数据类型、转置张量、单个元素大小、占用字节数量、维数、元素个数和每一维步长。\r\n<ul>\r\n<li>形状（shape）：<code>Tensor</code>的shape，是一个tuple（元组，python中的数据类型标签）。</li>\r\n<li>数据类型（dtype）：<code>Tensor</code>的dtype，是MindSpore的一个数据类型。</li>\r\n<li>单个元素大小（itemsize）：\r\n<code>Tensor</code>中每一个元素占用字节数，是一个整数。</li>\r\n<li>占用字节数量（nbytes）：\r\n<code>Tensor</code>占用的总字节数，是一个整数。</li>\r\n<li>维数（ndim）：\r\n<code>Tensor</code>的秩，也就是len(tensor.shape)，是一个整数。</li>\r\n<li>元素个数（size）：\r\n<code>Tensor</code>中所有元素的个数，是一个整数。</li>\r\n<li>每一维步长（strides）：\r\n<code>Tensor</code>每一维所需要的字节数，是一个tuple。</li>\r\n</ul></li>\r\n</ul>\r\n<p>为更简单的理解shape的含义，我修改了一下官方文档中的x张量</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = Tensor(np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">5</span>, <span class=\"number\">6</span>]]), mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_shape:&quot;</span>, x.shape)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_dtype:&quot;</span>, x.dtype)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_itemsize:&quot;</span>, x.itemsize)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_nbytes:&quot;</span>, x.nbytes)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_ndim:&quot;</span>, x.ndim)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_size:&quot;</span>, x.size)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_strides:&quot;</span>, x.strides)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>x_shape: (3, 2) x_dtype: Int32 x_itemsize: 4 x_nbytes: 24 x_ndim: 2\r\nx_size: 6 x_strides: (8, 4)</p>\r\n</blockquote>\r\n<h3 id=\"张量的下标索引\">张量的下标索引</h3>\r\n<p>Tensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号<code>:</code>和\r\n<code>...</code>用于对数据进行切片。切片的意思是后面的参数是按行算的还是按列算的，详细请看代码</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tensor = Tensor(np.array([[0, 1], [2, 3]]).astype(np.float32))</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;First row: &#123;&#125;&quot;.format(tensor[0]))</span><br><span class=\"line\">print(&quot;value of bottom right corner: &#123;&#125;&quot;.format(tensor[1, 1]))</span><br><span class=\"line\">print(&quot;Last column: &#123;&#125;&quot;.format(tensor[:, -1]))</span><br><span class=\"line\">print(&quot;First column: &#123;&#125;&quot;.format(tensor[..., 0]))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>First row: [0. 1.] value of bottom right corner: 3.0 Last column: [1.\r\n3.] First column: [0. 2.]</p>\r\n</blockquote>\r\n<h3 id=\"张量运算\">张量运算</h3>\r\n<p>张量之间有很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，张量运算和NumPy的使用方式类似，下面介绍其中几种操作。</p>\r\n<blockquote>\r\n<p>普通算术运算有：加（+）、减（-）、乘（*）、除（/）、取模（%）、整除（//）。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = Tensor(np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]), mindspore.float32)</span><br><span class=\"line\">y = Tensor(np.array([<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]), mindspore.float32)</span><br><span class=\"line\"></span><br><span class=\"line\">output_add = x + y</span><br><span class=\"line\">output_sub = x - y</span><br><span class=\"line\">output_mul = x * y</span><br><span class=\"line\">output_div = y / x</span><br><span class=\"line\">output_mod = y % x</span><br><span class=\"line\">output_floordiv = y // x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;add:&quot;</span>, output_add)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;sub:&quot;</span>, output_sub)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;mul:&quot;</span>, output_mul)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;div:&quot;</span>, output_div)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;mod:&quot;</span>, output_mod)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;floordiv:&quot;</span>, output_floordiv)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>add: [5. 7. 9.] sub: [-3. -3. -3.] mul: [ 4. 10. 18.] div: [4. 2.5 2.\r\n] mod: [0. 1. 0.] floordiv: [4. 2. 2.]</p>\r\n</blockquote>\r\n<p>对于一些函数的使用，这里之贴出定义，详细运行库中代码（个人觉得没必要，知道这些函数即可，毕竟到处可见类似函数）</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLmNvbmNhdC5odG1s\">concat<i class=\"fa fa-external-link-alt\"></i></span>()\r\n:\r\n将给定维度上的一系列张量连接起来，0表示最高得也就是直接通过<code>张量名[下标索引]</code>时的张量名所代表的元组。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLnN0YWNrLmh0bWw=\">stack<i class=\"fa fa-external-link-alt\"></i></span>()：则是从另一个维度上将两个张量合并起来。（新建一个维度）</p>\r\n<h3 id=\"tensor与numpy之间的相互转化\">Tensor与Numpy之间的相互转化</h3>\r\n<p>Tensor() : 将ndarray转化为Tensor</p>\r\n<p>asnumpy()：将Tensor转化为ndarray</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = Tensor([<span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;t: <span class=\"subst\">&#123;t&#125;</span>&quot;</span>, <span class=\"built_in\">type</span>(t))</span><br><span class=\"line\">n = t.asnumpy()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;n: <span class=\"subst\">&#123;n&#125;</span>&quot;</span>, <span class=\"built_in\">type</span>(n))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>t: [1. 1. 1. 1. 1.] &lt;class 'mindspore.common.tensor.Tensor'&gt; n:\r\n[1. 1. 1. 1. 1.] &lt;class 'numpy.ndarray'&gt;</p>\r\n</blockquote>\r\n<p>将NumPy变量转换为Tensor变量同样也不贴出来了，详情请运行本章代码对应部分查看</p>\r\n<p>有一个值得注意的点：</p>\r\n<p>当我们运行代码时调用了<code>np.add(n, 1, out=n)</code>函数，该函数<strong>同时改变了我们的Numpy数据和Tensor数据</strong>，这说明当我们进行转化时我们并没有创建新的变量，而是创建了新的变量指针。</p>\r\n<h2 id=\"稀疏张量\">稀疏张量</h2>\r\n<p>稀疏张量是一种特殊张量，其中绝大部分元素的值为零。</p>\r\n<p>在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。</p>\r\n<p>两种常用的稀疏张量格式</p>\r\n<ol type=\"1\">\r\n<li>CRS（Compressed Sparse\r\nRow）其中，非零元素的值存储在<code>values</code>中，非零元素的位置存储在<code>indptr</code>（行）和<code>indices</code>（列）中。</li>\r\n<li>COOCoordinate\r\nFormat）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为<code>N</code>，被压缩的张量的维数为<code>ndims</code>。</li>\r\n</ol>\r\n<p>常用稀疏张量的表达形式是<code>&lt;indices:Tensor, values:Tensor, shape:Tensor&gt;</code>。其中，<code>indices</code>表示非零下标元素，\r\n<code>values</code>表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。在这个结构下，我们定义了三种稀疏张量结构：<code>CSRTensor</code>、<code>COOTensor</code>和<code>RowTensor</code>。</p>\r\n<h3 id=\"csrtensor\">CSRTensor</h3>\r\n<ul>\r\n<li><code>indptr</code>: 一维整数张量,\r\n表示稀疏数据每一行的非零元素在<code>values</code>中的起始位置和终止位置,\r\n索引数据类型支持int16、int32、int64。</li>\r\n<li><code>indices</code>:\r\n一维整数张量，表示稀疏张量非零元素在列中的位置,\r\n与<code>values</code>长度相等，索引数据类型支持int16、int32、int64。</li>\r\n<li><code>values</code>:\r\n一维张量，表示<code>CSRTensor</code>相对应的非零元素的值，与<code>indices</code>长度相等。</li>\r\n<li><code>shape</code>:\r\n表示被压缩的稀疏张量的形状，数据类型为<code>Tuple</code>，目前仅支持二维<code>CSRTensor</code>。</li>\r\n</ul>\r\n<h3 id=\"cootensor\">COOTensor</h3>\r\n<ul>\r\n<li><code>indices</code>:\r\n二维整数张量，每行代表非零元素下标。形状：<code>[N, ndims]</code>，\r\n索引数据类型支持int16、int32、int64。</li>\r\n<li><code>values</code>:\r\n一维张量，表示相对应的非零元素的值。形状：<code>[N]</code>。</li>\r\n<li><code>shape</code>:\r\n表示被压缩的稀疏张量的形状，目前仅支持二维<code>COOTensor</code>。</li>\r\n</ul>\r\n<h3 id=\"使用实例\">使用实例</h3>\r\n<p>在源代码最后有CSRTensor、COOTensor的使用实例</p>\r\n<p>这里得给出代码，我做了一些修改，不然不好理解</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CSRTensor 稀疏张量表实例</span></span><br><span class=\"line\">indptr = Tensor([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\">indices = Tensor([<span class=\"number\">0</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\">values = Tensor([<span class=\"number\">1</span>, <span class=\"number\">2</span>], dtype=mindspore.float32)</span><br><span class=\"line\">shape = (<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Make a CSRTensor</span></span><br><span class=\"line\">csr_tensor = CSRTensor(indptr, indices, values, shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(csr_tensor.astype(mindspore.float64).dtype)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(csr_tensor)</span><br><span class=\"line\"></span><br><span class=\"line\">indices = Tensor([[<span class=\"number\">0</span>, <span class=\"number\">1</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>]], dtype=mindspore.int32)</span><br><span class=\"line\">values = Tensor([<span class=\"number\">1</span>, <span class=\"number\">2</span>], dtype=mindspore.float32)</span><br><span class=\"line\">shape = (<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Make a COOTensor</span></span><br><span class=\"line\">coo_tensor = COOTensor(indices, values, shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(coo_tensor)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Float64 CSRTensor(shape=[2, 4],</p>\r\n<p>dtype=Float32,</p>\r\n<p>indptr=Tensor(shape=[3], dtype=Int64, value=[0 1 2]),</p>\r\n<p>indices=Tensor(shape=[2], dtype=Int64, value=[0 1]),</p>\r\n<p>values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00\r\n2.00000000e+00])) COOTensor(shape=[3, 4],</p>\r\n<p>dtype=Float32,</p>\r\n<p>indices=Tensor(shape=[2, 2], dtype=Int32, value=[[0 1] [1 2]]),</p>\r\n<p>values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00\r\n2.00000000e+00]))</p>\r\n</blockquote>\r\n<p>其生成实例如下</p>\r\n<p>CSRTensor: <span class=\"math display\">\\[\r\n\\begin{split}\\left[\r\n\\begin{matrix}\r\n  1 &amp; 0 &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 2 &amp; 0 &amp; 0\r\n\\end{matrix}\r\n\\right]\\end{split}\r\n\\]</span> COOTensor: <span class=\"math display\">\\[\r\n\\begin{split}\\left[\r\n\\begin{matrix}\r\n  0 &amp; 1 &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 2 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 0 &amp; 0\r\n\\end{matrix}\r\n\\right]\\end{split}\r\n\\]</span></p>\r\n<ul>\r\n<li>CSRTensor(indptr, indices, values, shape)：\r\n构造一个CSR稀疏张量表</li>\r\n<li>COOTensor(indices, values, shape) ：构造一个COO稀疏张量表</li>\r\n</ul>\r\n<p>理解不了CSR请参考:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuQ1NSVGVuc29yLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>理解不了COO请参考:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuQ09PVGVuc29yLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>"},{"title":"408复习目录","date":"2024-08-14T11:47:58.000Z","_content":"# 介绍\n这是专题，408考研科目复习的目录，主要包含专业课的复习笔记，该目录下的所有文章截至12/28日前都仍在更新，并且将不会索引到网站当中。博主暂未决定去向，但决定尽己所能复习基础科目。\n感谢各位能阅读到这里。\n\n***注：专业课由于我校大三课程刚刚学过操作系统，以及笔者的ACM经历，操作系统与数据结构这两门课程，仅作补充与复习，并不再次进行系统学习***\n\n## 专业课\n### 计算机网络\n [补充](ProfessionalCources\\ComputerNetwork\\补充\\article.html) \n\n [概要以及杂项](ProfessionalCources\\ComputerNetwork\\概要以及杂项\\article.html) \n\n [计算机网络的分层结构](ProfessionalCources\\ComputerNetwork\\计算机网络的分层结构\\article.html) \n\n [奈氏定理与香农法则](ProfessionalCources\\ComputerNetwork\\奈氏定理与香农法则\\article.html) \n\n [三种交换方式](ProfessionalCources\\ComputerNetwork\\三种交换方式\\article.html)  \n\n[三种可靠传输协议](ProfessionalCources\\ComputerNetwork\\三种可靠传输协议\\article.html) \n\n [数据链路层](ProfessionalCources\\ComputerNetwork\\数据链路层\\article.html) \n\n [网络层](ProfessionalCources\\ComputerNetwork\\网络层\\article.html) \n\n [物理层](ProfessionalCources\\ComputerNetwork\\物理层\\article.html) \n\n [运输层](ProfessionalCources\\ComputerNetwork\\运输层\\article.html) \n\n### 计算机组成原理\n\n [补充](ProfessionalCources\\ComputerStructure\\补充\\article.html)\n\n [第一章](ProfessionalCources\\ComputerStructure\\第一章\\article.html) \n\n [第二章](ProfessionalCources\\ComputerStructure\\第二章\\article.html)  \n\n [第三章](ProfessionalCources\\ComputerStructure\\第三章\\article.html) \n\n [各个硬件及其相关工作原理](ProfessionalCources\\ComputerStructure\\各个硬件及其相关工作原理\\article.html) \n\n [IO](ProfessionalCources\\ComputerStructure\\IO\\article.html) \n\n### 数据结构\n\n [补充](ProfessionalCources\\DataStructure\\补充\\article.html) \n\n [FirstRoundReview](ProfessionalCources\\DataStructure\\FirstRoundReview\\article.html) \n\n### 操作系统\n\n [补充](ProfessionalCources\\OperationSystem\\补充\\article.html) \n\n### 错题篇\n\n [错题汇总草案-计网篇](ProfessionalCources\\错题汇总草案-计网篇\\article.html) \n\n [错题汇总草案-计组篇](ProfessionalCources\\错题汇总草案-计组篇\\article.html) \n\n [错题汇总草案-数构篇](ProfessionalCources\\错题汇总草案-数构篇\\article.html) \n\n [错题汇总草案-系统篇](ProfessionalCources\\错题汇总草案-系统篇\\article.html) \n\n [RecordNote](ProfessionalCources\\RecordNote\\article.html) ","source":"_posts/special_subject/NationalPGExamination/catelogue.md","raw":"---\ntitle: 408复习目录\ndate: 2024-08-14 19:47:58\ntags: [数学, 英语, 计算机网络, 计算机组成原理, 操作系统, 考研, 目录]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 目录\n---\n# 介绍\n这是专题，408考研科目复习的目录，主要包含专业课的复习笔记，该目录下的所有文章截至12/28日前都仍在更新，并且将不会索引到网站当中。博主暂未决定去向，但决定尽己所能复习基础科目。\n感谢各位能阅读到这里。\n\n***注：专业课由于我校大三课程刚刚学过操作系统，以及笔者的ACM经历，操作系统与数据结构这两门课程，仅作补充与复习，并不再次进行系统学习***\n\n## 专业课\n### 计算机网络\n [补充](ProfessionalCources\\ComputerNetwork\\补充\\article.html) \n\n [概要以及杂项](ProfessionalCources\\ComputerNetwork\\概要以及杂项\\article.html) \n\n [计算机网络的分层结构](ProfessionalCources\\ComputerNetwork\\计算机网络的分层结构\\article.html) \n\n [奈氏定理与香农法则](ProfessionalCources\\ComputerNetwork\\奈氏定理与香农法则\\article.html) \n\n [三种交换方式](ProfessionalCources\\ComputerNetwork\\三种交换方式\\article.html)  \n\n[三种可靠传输协议](ProfessionalCources\\ComputerNetwork\\三种可靠传输协议\\article.html) \n\n [数据链路层](ProfessionalCources\\ComputerNetwork\\数据链路层\\article.html) \n\n [网络层](ProfessionalCources\\ComputerNetwork\\网络层\\article.html) \n\n [物理层](ProfessionalCources\\ComputerNetwork\\物理层\\article.html) \n\n [运输层](ProfessionalCources\\ComputerNetwork\\运输层\\article.html) \n\n### 计算机组成原理\n\n [补充](ProfessionalCources\\ComputerStructure\\补充\\article.html)\n\n [第一章](ProfessionalCources\\ComputerStructure\\第一章\\article.html) \n\n [第二章](ProfessionalCources\\ComputerStructure\\第二章\\article.html)  \n\n [第三章](ProfessionalCources\\ComputerStructure\\第三章\\article.html) \n\n [各个硬件及其相关工作原理](ProfessionalCources\\ComputerStructure\\各个硬件及其相关工作原理\\article.html) \n\n [IO](ProfessionalCources\\ComputerStructure\\IO\\article.html) \n\n### 数据结构\n\n [补充](ProfessionalCources\\DataStructure\\补充\\article.html) \n\n [FirstRoundReview](ProfessionalCources\\DataStructure\\FirstRoundReview\\article.html) \n\n### 操作系统\n\n [补充](ProfessionalCources\\OperationSystem\\补充\\article.html) \n\n### 错题篇\n\n [错题汇总草案-计网篇](ProfessionalCources\\错题汇总草案-计网篇\\article.html) \n\n [错题汇总草案-计组篇](ProfessionalCources\\错题汇总草案-计组篇\\article.html) \n\n [错题汇总草案-数构篇](ProfessionalCources\\错题汇总草案-数构篇\\article.html) \n\n [错题汇总草案-系统篇](ProfessionalCources\\错题汇总草案-系统篇\\article.html) \n\n [RecordNote](ProfessionalCources\\RecordNote\\article.html) ","slug":"special_subject/NationalPGExamination/catelogue","published":1,"updated":"2024-08-17T13:15:11.323Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qpo0000m8wv3ui74yiq","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>这是专题，408考研科目复习的目录，主要包含专业课的复习笔记，该目录下的所有文章截至12/28日前都仍在更新，并且将不会索引到网站当中。博主暂未决定去向，但决定尽己所能复习基础科目。<br>感谢各位能阅读到这里。</p>\n<p><strong><em>注：专业课由于我校大三课程刚刚学过操作系统，以及笔者的ACM经历，操作系统与数据结构这两门课程，仅作补充与复习，并不再次进行系统学习</em></strong></p>\n<h2 id=\"专业课\"><a href=\"#专业课\" class=\"headerlink\" title=\"专业课\"></a>专业课</h2><h3 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><p> <a href=\"ProfessionalCources\\ComputerNetwork\\补充\\article.html\">补充</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\概要以及杂项\\article.html\">概要以及杂项</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\计算机网络的分层结构\\article.html\">计算机网络的分层结构</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\奈氏定理与香农法则\\article.html\">奈氏定理与香农法则</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\三种交换方式\\article.html\">三种交换方式</a>  </p>\n<p><a href=\"ProfessionalCources\\ComputerNetwork\\三种可靠传输协议\\article.html\">三种可靠传输协议</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\数据链路层\\article.html\">数据链路层</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\网络层\\article.html\">网络层</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\物理层\\article.html\">物理层</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\运输层\\article.html\">运输层</a> </p>\n<h3 id=\"计算机组成原理\"><a href=\"#计算机组成原理\" class=\"headerlink\" title=\"计算机组成原理\"></a>计算机组成原理</h3><p> <a href=\"ProfessionalCources\\ComputerStructure\\补充\\article.html\">补充</a></p>\n<p> <a href=\"ProfessionalCources\\ComputerStructure\\第一章\\article.html\">第一章</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerStructure\\第二章\\article.html\">第二章</a>  </p>\n<p> <a href=\"ProfessionalCources\\ComputerStructure\\第三章\\article.html\">第三章</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerStructure\\各个硬件及其相关工作原理\\article.html\">各个硬件及其相关工作原理</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerStructure\\IO\\article.html\">IO</a> </p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p> <a href=\"ProfessionalCources\\DataStructure\\补充\\article.html\">补充</a> </p>\n<p> <a href=\"ProfessionalCources\\DataStructure\\FirstRoundReview\\article.html\">FirstRoundReview</a> </p>\n<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><p> <a href=\"ProfessionalCources\\OperationSystem\\补充\\article.html\">补充</a> </p>\n<h3 id=\"错题篇\"><a href=\"#错题篇\" class=\"headerlink\" title=\"错题篇\"></a>错题篇</h3><p> <a href=\"ProfessionalCources\\错题汇总草案-计网篇\\article.html\">错题汇总草案-计网篇</a> </p>\n<p> <a href=\"ProfessionalCources\\错题汇总草案-计组篇\\article.html\">错题汇总草案-计组篇</a> </p>\n<p> <a href=\"ProfessionalCources\\错题汇总草案-数构篇\\article.html\">错题汇总草案-数构篇</a> </p>\n<p> <a href=\"ProfessionalCources\\错题汇总草案-系统篇\\article.html\">错题汇总草案-系统篇</a> </p>\n<p> <a href=\"ProfessionalCources\\RecordNote\\article.html\">RecordNote</a> </p>\n","length":297,"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>这是专题，408考研科目复习的目录，主要包含专业课的复习笔记，该目录下的所有文章截至12/28日前都仍在更新，并且将不会索引到网站当中。博主暂未决定去向，但决定尽己所能复习基础科目。<br>感谢各位能阅读到这里。</p>\n<p><strong><em>注：专业课由于我校大三课程刚刚学过操作系统，以及笔者的ACM经历，操作系统与数据结构这两门课程，仅作补充与复习，并不再次进行系统学习</em></strong></p>\n<h2 id=\"专业课\"><a href=\"#专业课\" class=\"headerlink\" title=\"专业课\"></a>专业课</h2><h3 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><p> <a href=\"ProfessionalCources\\ComputerNetwork\\补充\\article.html\">补充</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\概要以及杂项\\article.html\">概要以及杂项</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\计算机网络的分层结构\\article.html\">计算机网络的分层结构</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\奈氏定理与香农法则\\article.html\">奈氏定理与香农法则</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\三种交换方式\\article.html\">三种交换方式</a>  </p>\n<p><a href=\"ProfessionalCources\\ComputerNetwork\\三种可靠传输协议\\article.html\">三种可靠传输协议</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\数据链路层\\article.html\">数据链路层</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\网络层\\article.html\">网络层</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\物理层\\article.html\">物理层</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerNetwork\\运输层\\article.html\">运输层</a> </p>\n<h3 id=\"计算机组成原理\"><a href=\"#计算机组成原理\" class=\"headerlink\" title=\"计算机组成原理\"></a>计算机组成原理</h3><p> <a href=\"ProfessionalCources\\ComputerStructure\\补充\\article.html\">补充</a></p>\n<p> <a href=\"ProfessionalCources\\ComputerStructure\\第一章\\article.html\">第一章</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerStructure\\第二章\\article.html\">第二章</a>  </p>\n<p> <a href=\"ProfessionalCources\\ComputerStructure\\第三章\\article.html\">第三章</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerStructure\\各个硬件及其相关工作原理\\article.html\">各个硬件及其相关工作原理</a> </p>\n<p> <a href=\"ProfessionalCources\\ComputerStructure\\IO\\article.html\">IO</a> </p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p> <a href=\"ProfessionalCources\\DataStructure\\补充\\article.html\">补充</a> </p>\n<p> <a href=\"ProfessionalCources\\DataStructure\\FirstRoundReview\\article.html\">FirstRoundReview</a> </p>\n<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><p> <a href=\"ProfessionalCources\\OperationSystem\\补充\\article.html\">补充</a> </p>\n<h3 id=\"错题篇\"><a href=\"#错题篇\" class=\"headerlink\" title=\"错题篇\"></a>错题篇</h3><p> <a href=\"ProfessionalCources\\错题汇总草案-计网篇\\article.html\">错题汇总草案-计网篇</a> </p>\n<p> <a href=\"ProfessionalCources\\错题汇总草案-计组篇\\article.html\">错题汇总草案-计组篇</a> </p>\n<p> <a href=\"ProfessionalCources\\错题汇总草案-数构篇\\article.html\">错题汇总草案-数构篇</a> </p>\n<p> <a href=\"ProfessionalCources\\错题汇总草案-系统篇\\article.html\">错题汇总草案-系统篇</a> </p>\n<p> <a href=\"ProfessionalCources\\RecordNote\\article.html\">RecordNote</a> </p>\n"},{"_content":"## 2024/7/23 12:00:50 记\n\n今日每日一题暴露了大量的计组和计网结构缺失\n\n计组集中于硬件相关的概念\n\n计网集中于各种协议的概念\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/RecordNote.md","raw":"## 2024/7/23 12:00:50 记\n\n今日每日一题暴露了大量的计组和计网结构缺失\n\n计组集中于硬件相关的概念\n\n计网集中于各种协议的概念\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/RecordNote","published":1,"date":"2024-08-17T13:01:01.006Z","updated":"2024-07-23T04:04:40.000Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clzy68qpu0001m8wv19kodu1t","content":"<h2 id=\"2024-7-23-12-00-50-记\"><a href=\"#2024-7-23-12-00-50-记\" class=\"headerlink\" title=\"2024/7/23 12:00:50 记\"></a>2024/7/23 12:00:50 记</h2><p>今日每日一题暴露了大量的计组和计网结构缺失</p>\n<p>计组集中于硬件相关的概念</p>\n<p>计网集中于各种协议的概念</p>\n","length":52,"excerpt":"","more":"<h2 id=\"2024-7-23-12-00-50-记\"><a href=\"#2024-7-23-12-00-50-记\" class=\"headerlink\" title=\"2024/7/23 12:00:50 记\"></a>2024/7/23 12:00:50 记</h2><p>今日每日一题暴露了大量的计组和计网结构缺失</p>\n<p>计组集中于硬件相关的概念</p>\n<p>计网集中于各种协议的概念</p>\n"},{"title":"错题汇总草案-数构篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"左子树为空的二叉树在先序线索化后，空的链域数量为（  ）。\n\nA.1\n\nB.2\n\nC.3\n\nD.0\n\n<details>\n    解析：B。\n\t本题考查线索二叉树中线索数量。对于左子树为空的二叉树来说，其只能是右单支树，根结点是前序序列的第一个结点，故根结点没有前序的前驱，其左指针链域就是空的。最右边的结点是前序序列的最后一个结点，没有前序的后继，故其右指针链域也是空的，故总共有两个空链域。\n</details>\n---\n\n(启航3月考)若线性表中总的元素个数基本稳定，但经常要在表头删除元素，在表尾插入元素，那么最好采用（ ）实现该线性表。\n\nA.带头指针的单链表；B.双向循环链表；C.循环顺序队列；D.顺序表\n\n<details>\n    <p>【解析】C。</p>\n    <p>\n       首先对时间复杂度考虑，显然我们直接排除A,他在尾插入时出现O(n)的时间复杂度。在考虑空间，对D而言，我们一般需要考虑顺序表中的空间问题，但存在头删除尾插入时通常会出现空间问题，最后考虑时间常数，因此我们选C。题面中也有一个显然的提示<b>元素个数基本稳定</b>\n    </p>\n</details>\n\n---\n\n(启航3月考)8.最大容量为n的循环队列，队尾指针是 Cear. ，对头指针是 Tfont,/ 贝 则队空的条件是（)。\nA. (rear+ 1)mod n\\==front      B. rear\\==front\nC. rear+1 \\==front         D. (rear-1)mod n\\==front。\n\n<details>\n    <p>【解析】B。</p>\n    <p>\n        很简单，对循环队列而言，队满(rear+ 1)mod n==front\n        队空 rear==front\n    </p>\n</details>\n\n---\n\n(启航3月考)若将存有 (18个无素的有序表存放在一维数组A[19]中，第一个元素存放在 中\n进行分查找 当找到A[3]的时候，查找顺序为（ )。\n\nA.1.2, 3  B. 9, 5, 2, 3 C.9. 5. 3  D. 9, 4, 2, 3\n\n<details>\n    <p>\n        【解析】D。\n    </p>\n    <p>\n        每次判掉flag就是D\n    </p>\n</details>\n\n---\n\n(启航3月考)二维数组 A\\[m][n]中，A\\[0][0]的存放位置是在 644(10)，A\\[2][2]在 676(10)，每个元素\n占一个空间，请问A\\[3][3]在( ），其中脚注(10)表示十进制。\nA.688    B.678     C.692     D.686\n\n<details>\n    <p>\n        【解析】C。\n    </p>\n    <p>\n        这种题一定要认真算一遍\n        2*n+2 = 32/k\n        假定k等于1，n=15，说明每行占15个字节\n        n*3+3=48\n        结果就是C\n    </p>\n</details>\n\n---\n\n有一个长度为12的有序表R[0.11]，按二分查找法对该表进行查找，在表内各元素等概率情况下查找成功所需的平均比较次数是（）\n\nA.３\nB. 37/12\nC. 19/6\nD. 39/12\n\n<details>\n    【解析】B。\n    <br>\n    解析：构造相应的判定树，第一层1个节点，\n第二层两个节点，第三层4个节点，第四层\n5个节点，则：ASL=（1x1+2x2+3X4+4X5)\n/12 = 37/12\n</details>\n---\n\n下列说法正确的是\n\nA. 如果表示图的邻接矩阵是对称矩阵，则该图一定是无向图。\nB. 连通图的生成树包含了图中所有顶点。\nC. 对n个顶点的连通图G来说，如果其中的某个子图有n个顶点、n-1条边，则该子图一定是G的生成树。\nD. 最小生成树是指边数最少的生成树。\n\n<details>\n    【解析】B。 <br>\n    A: 如完全有向图的邻接矩阵也是对称\n矩阵。<br>\nC: 这样的子图不一定是连通图，而连通图的\n生成树一定是连通的。<br>\nD：图的所有生成树的边数是相同的，其中数值之和最小的生成树为最小生成树。\n</details>\n\n---\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-数构篇.md","raw":"---\ntitle: 错题汇总草案-数构篇\ndate: 2024-08-14 19:47:58\ntags: [数据结构, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 错题本\nhidden: true\n---\n左子树为空的二叉树在先序线索化后，空的链域数量为（  ）。\n\nA.1\n\nB.2\n\nC.3\n\nD.0\n\n<details>\n    解析：B。\n\t本题考查线索二叉树中线索数量。对于左子树为空的二叉树来说，其只能是右单支树，根结点是前序序列的第一个结点，故根结点没有前序的前驱，其左指针链域就是空的。最右边的结点是前序序列的最后一个结点，没有前序的后继，故其右指针链域也是空的，故总共有两个空链域。\n</details>\n---\n\n(启航3月考)若线性表中总的元素个数基本稳定，但经常要在表头删除元素，在表尾插入元素，那么最好采用（ ）实现该线性表。\n\nA.带头指针的单链表；B.双向循环链表；C.循环顺序队列；D.顺序表\n\n<details>\n    <p>【解析】C。</p>\n    <p>\n       首先对时间复杂度考虑，显然我们直接排除A,他在尾插入时出现O(n)的时间复杂度。在考虑空间，对D而言，我们一般需要考虑顺序表中的空间问题，但存在头删除尾插入时通常会出现空间问题，最后考虑时间常数，因此我们选C。题面中也有一个显然的提示<b>元素个数基本稳定</b>\n    </p>\n</details>\n\n---\n\n(启航3月考)8.最大容量为n的循环队列，队尾指针是 Cear. ，对头指针是 Tfont,/ 贝 则队空的条件是（)。\nA. (rear+ 1)mod n\\==front      B. rear\\==front\nC. rear+1 \\==front         D. (rear-1)mod n\\==front。\n\n<details>\n    <p>【解析】B。</p>\n    <p>\n        很简单，对循环队列而言，队满(rear+ 1)mod n==front\n        队空 rear==front\n    </p>\n</details>\n\n---\n\n(启航3月考)若将存有 (18个无素的有序表存放在一维数组A[19]中，第一个元素存放在 中\n进行分查找 当找到A[3]的时候，查找顺序为（ )。\n\nA.1.2, 3  B. 9, 5, 2, 3 C.9. 5. 3  D. 9, 4, 2, 3\n\n<details>\n    <p>\n        【解析】D。\n    </p>\n    <p>\n        每次判掉flag就是D\n    </p>\n</details>\n\n---\n\n(启航3月考)二维数组 A\\[m][n]中，A\\[0][0]的存放位置是在 644(10)，A\\[2][2]在 676(10)，每个元素\n占一个空间，请问A\\[3][3]在( ），其中脚注(10)表示十进制。\nA.688    B.678     C.692     D.686\n\n<details>\n    <p>\n        【解析】C。\n    </p>\n    <p>\n        这种题一定要认真算一遍\n        2*n+2 = 32/k\n        假定k等于1，n=15，说明每行占15个字节\n        n*3+3=48\n        结果就是C\n    </p>\n</details>\n\n---\n\n有一个长度为12的有序表R[0.11]，按二分查找法对该表进行查找，在表内各元素等概率情况下查找成功所需的平均比较次数是（）\n\nA.３\nB. 37/12\nC. 19/6\nD. 39/12\n\n<details>\n    【解析】B。\n    <br>\n    解析：构造相应的判定树，第一层1个节点，\n第二层两个节点，第三层4个节点，第四层\n5个节点，则：ASL=（1x1+2x2+3X4+4X5)\n/12 = 37/12\n</details>\n---\n\n下列说法正确的是\n\nA. 如果表示图的邻接矩阵是对称矩阵，则该图一定是无向图。\nB. 连通图的生成树包含了图中所有顶点。\nC. 对n个顶点的连通图G来说，如果其中的某个子图有n个顶点、n-1条边，则该子图一定是G的生成树。\nD. 最小生成树是指边数最少的生成树。\n\n<details>\n    【解析】B。 <br>\n    A: 如完全有向图的邻接矩阵也是对称\n矩阵。<br>\nC: 这样的子图不一定是连通图，而连通图的\n生成树一定是连通的。<br>\nD：图的所有生成树的边数是相同的，其中数值之和最小的生成树为最小生成树。\n</details>\n\n---\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-数构篇","published":1,"updated":"2024-08-17T13:19:17.073Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qpz0003m8wv1qcgg0p7","content":"<p>左子树为空的二叉树在先序线索化后，空的链域数量为（  ）。</p>\n<p>A.1</p>\n<p>B.2</p>\n<p>C.3</p>\n<p>D.0</p>\n<details>\n    解析：B。\n    本题考查线索二叉树中线索数量。对于左子树为空的二叉树来说，其只能是右单支树，根结点是前序序列的第一个结点，故根结点没有前序的前驱，其左指针链域就是空的。最右边的结点是前序序列的最后一个结点，没有前序的后继，故其右指针链域也是空的，故总共有两个空链域。\n</details>\n---\n\n(启航3月考)若线性表中总的元素个数基本稳定，但经常要在表头删除元素，在表尾插入元素，那么最好采用（ ）实现该线性表。\n\nA.带头指针的单链表；B.双向循环链表；C.循环顺序队列；D.顺序表\n\n<details>\n    <p>【解析】C。</p>\n    <p>\n       首先对时间复杂度考虑，显然我们直接排除A,他在尾插入时出现O(n)的时间复杂度。在考虑空间，对D而言，我们一般需要考虑顺序表中的空间问题，但存在头删除尾插入时通常会出现空间问题，最后考虑时间常数，因此我们选C。题面中也有一个显然的提示<b>元素个数基本稳定</b>\n    </p>\n</details>\n\n<hr>\n<p>(启航3月考)8.最大容量为n的循环队列，队尾指针是 Cear. ，对头指针是 Tfont,/ 贝 则队空的条件是（)。<br>A. (rear+ 1)mod n\\==front      B. rear\\==front<br>C. rear+1 \\==front         D. (rear-1)mod n\\==front。</p>\n<details>\n    <p>【解析】B。</p>\n    <p>\n        很简单，对循环队列而言，队满(rear+ 1)mod n==front\n        队空 rear==front\n    </p>\n</details>\n\n<hr>\n<p>(启航3月考)若将存有 (18个无素的有序表存放在一维数组A[19]中，第一个元素存放在 中<br>进行分查找 当找到A[3]的时候，查找顺序为（ )。</p>\n<p>A.1.2, 3  B. 9, 5, 2, 3 C.9. 5. 3  D. 9, 4, 2, 3</p>\n<details>\n    <p>\n        【解析】D。\n    </p>\n    <p>\n        每次判掉flag就是D\n    </p>\n</details>\n\n<hr>\n<p>(启航3月考)二维数组 A[m][n]中，A[0][0]的存放位置是在 644(10)，A[2][2]在 676(10)，每个元素<br>占一个空间，请问A[3][3]在( ），其中脚注(10)表示十进制。<br>A.688    B.678     C.692     D.686</p>\n<details>\n    <p>\n        【解析】C。\n    </p>\n    <p>\n        这种题一定要认真算一遍\n        2*n+2 = 32/k\n        假定k等于1，n=15，说明每行占15个字节\n        n*3+3=48\n        结果就是C\n    </p>\n</details>\n\n<hr>\n<p>有一个长度为12的有序表R[0.11]，按二分查找法对该表进行查找，在表内各元素等概率情况下查找成功所需的平均比较次数是（）</p>\n<p>A.３<br>B. 37/12<br>C. 19/6<br>D. 39/12</p>\n<details>\n    【解析】B。\n    <br>\n    解析：构造相应的判定树，第一层1个节点，\n第二层两个节点，第三层4个节点，第四层\n5个节点，则：ASL=（1x1+2x2+3X4+4X5)\n/12 = 37/12\n</details>\n---\n\n下列说法正确的是\n\nA. 如果表示图的邻接矩阵是对称矩阵，则该图一定是无向图。\nB. 连通图的生成树包含了图中所有顶点。\nC. 对n个顶点的连通图G来说，如果其中的某个子图有n个顶点、n-1条边，则该子图一定是G的生成树。\nD. 最小生成树是指边数最少的生成树。\n\n<details>\n    【解析】B。 <br>\n    A: 如完全有向图的邻接矩阵也是对称\n矩阵。<br>\nC: 这样的子图不一定是连通图，而连通图的\n生成树一定是连通的。<br>\nD：图的所有生成树的边数是相同的，其中数值之和最小的生成树为最小生成树。\n</details>\n\n<hr>\n<!-- flag of hidden posts -->","length":953,"excerpt":"","more":"<p>左子树为空的二叉树在先序线索化后，空的链域数量为（  ）。</p>\n<p>A.1</p>\n<p>B.2</p>\n<p>C.3</p>\n<p>D.0</p>\n<details>\n    解析：B。\n    本题考查线索二叉树中线索数量。对于左子树为空的二叉树来说，其只能是右单支树，根结点是前序序列的第一个结点，故根结点没有前序的前驱，其左指针链域就是空的。最右边的结点是前序序列的最后一个结点，没有前序的后继，故其右指针链域也是空的，故总共有两个空链域。\n</details>\n---\n\n(启航3月考)若线性表中总的元素个数基本稳定，但经常要在表头删除元素，在表尾插入元素，那么最好采用（ ）实现该线性表。\n\nA.带头指针的单链表；B.双向循环链表；C.循环顺序队列；D.顺序表\n\n<details>\n    <p>【解析】C。</p>\n    <p>\n       首先对时间复杂度考虑，显然我们直接排除A,他在尾插入时出现O(n)的时间复杂度。在考虑空间，对D而言，我们一般需要考虑顺序表中的空间问题，但存在头删除尾插入时通常会出现空间问题，最后考虑时间常数，因此我们选C。题面中也有一个显然的提示<b>元素个数基本稳定</b>\n    </p>\n</details>\n\n<hr>\n<p>(启航3月考)8.最大容量为n的循环队列，队尾指针是 Cear. ，对头指针是 Tfont,/ 贝 则队空的条件是（)。<br>A. (rear+ 1)mod n\\==front      B. rear\\==front<br>C. rear+1 \\==front         D. (rear-1)mod n\\==front。</p>\n<details>\n    <p>【解析】B。</p>\n    <p>\n        很简单，对循环队列而言，队满(rear+ 1)mod n==front\n        队空 rear==front\n    </p>\n</details>\n\n<hr>\n<p>(启航3月考)若将存有 (18个无素的有序表存放在一维数组A[19]中，第一个元素存放在 中<br>进行分查找 当找到A[3]的时候，查找顺序为（ )。</p>\n<p>A.1.2, 3  B. 9, 5, 2, 3 C.9. 5. 3  D. 9, 4, 2, 3</p>\n<details>\n    <p>\n        【解析】D。\n    </p>\n    <p>\n        每次判掉flag就是D\n    </p>\n</details>\n\n<hr>\n<p>(启航3月考)二维数组 A[m][n]中，A[0][0]的存放位置是在 644(10)，A[2][2]在 676(10)，每个元素<br>占一个空间，请问A[3][3]在( ），其中脚注(10)表示十进制。<br>A.688    B.678     C.692     D.686</p>\n<details>\n    <p>\n        【解析】C。\n    </p>\n    <p>\n        这种题一定要认真算一遍\n        2*n+2 = 32/k\n        假定k等于1，n=15，说明每行占15个字节\n        n*3+3=48\n        结果就是C\n    </p>\n</details>\n\n<hr>\n<p>有一个长度为12的有序表R[0.11]，按二分查找法对该表进行查找，在表内各元素等概率情况下查找成功所需的平均比较次数是（）</p>\n<p>A.３<br>B. 37/12<br>C. 19/6<br>D. 39/12</p>\n<details>\n    【解析】B。\n    <br>\n    解析：构造相应的判定树，第一层1个节点，\n第二层两个节点，第三层4个节点，第四层\n5个节点，则：ASL=（1x1+2x2+3X4+4X5)\n/12 = 37/12\n</details>\n---\n\n下列说法正确的是\n\nA. 如果表示图的邻接矩阵是对称矩阵，则该图一定是无向图。\nB. 连通图的生成树包含了图中所有顶点。\nC. 对n个顶点的连通图G来说，如果其中的某个子图有n个顶点、n-1条边，则该子图一定是G的生成树。\nD. 最小生成树是指边数最少的生成树。\n\n<details>\n    【解析】B。 <br>\n    A: 如完全有向图的邻接矩阵也是对称\n矩阵。<br>\nC: 这样的子图不一定是连通图，而连通图的\n生成树一定是连通的。<br>\nD：图的所有生成树的边数是相同的，其中数值之和最小的生成树为最小生成树。\n</details>\n\n<hr>\n"},{"title":"错题汇总草案-计网篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"<a href=\"#example\">0.例题</a>\n\n<a href=\"#tcp-protocol\">1.tcp协议</a>\n\n---\n\n无错误但觉得经典的例题\n\n<a id=\"example\"></a>\n\n## 例题\n\n### 调制与奈氏香农\n\n【2009年题34】在无噪声情况下，若某通信链路的带宽为3kHz，采用4个相位，每个相位具有4种振幅\n的QAM调制技术，则该通信链路的最大数据传输速率是\nA.12kbps   B. 24 kbps   C. 48 kbps   D.96kbps\n\n<details>\n    【解析】B<br>\n（1）根据奈氏准则可知，该通信链路的最高码元传输速率=2×3k=6k（Baud）=6k（码元/秒);<br>\n（2）采用4个相位，每个相位4种振幅的QAM调制技术，可以调制出4×4=16个不同的基本波形（码元）；<br>\n采用二进制对这16个不同的码元进行编码，需要使用4个比特（log216=4）。换句话说，每个码元可以携带的\n信息量为4比特；<br>\n综合（1）和（2）可知，该通信链路的最大数据传输速率=6k（码元/秒）×4（比特/码元）=24k（比特/秒）=24kbps\n</details>\n【2011年题34】若某通信链路的数据传输速率为2400bps，采用4相位调制，则该链路的波特率是\nA.600波特   B.1200波特  C.4800波特  D.9600波特\n\n<details>\n    【解析】B<br>\n（1）采用4相位调制，可以调制出4种相位不同的基本波形（码元）。采用二进制对这4个不同的码元进行编码，\n需要使用2个比特（log24=2）。换句话说，每个码元可以携带的信息量为2比特；<br>\n    （2）数据传输速率=波特率（码元传输速率）X每个码元所携带的信息量\n2400（比特/秒）=波特率X2（比特/码元）\n</details>\n【2016年题34】若连接R2和R3链路的频率带宽为8kHz，信噪比为30dB，该链路实际数据传输速率约\n为理论最大数据传输速率的50%，则该链路的实际数据传输速率约是 \nA.8kbps   B.20 kbps   C. 40kbps   D.80kbps\n\n<details>\n    【解析】C<br>\n    <img src=\"https://s2.loli.net/2024/07/27/d7z5UXxmhicbRTo.png\" alt=\"香农公式计算\" />\n</details>\n\n【2017年题34】若信道在无噪声情况下的极限数据传输速率不小于信噪比为30dB条件下的极限数据传\n输速率，则信号状态数至少是\nA.4    B.8    c.16    D.32\n\n<details>\n    【解析】D.<br>\n    <img src=\"https://s2.loli.net/2024/07/27/Zb4Dm3ELWJnXyI2.png\" alt=\"image-20240727174430576\" />\n</details>\n---\n\n当收发窗口的大小都为1时，滑动窗口协议成为（)协议。\nA.连续 ARQ\nB.选择重传 ARQ\nC.停止-等待\nD.BSC\n\n<details>\n    【解析】C。\n\t收发窗口都变成1，滑动窗口就变成了停止-等待协议；发送窗口和接收窗口都大于1时，就是选择重传ARQ。\n</details>\n---\n\n以下网络设备中, 可能引起广播风暴的是(  )\n\nA.网关\n\nB.网桥\n\nC.防火墙\n\nD.路由器\n\n<details>\n    【解析】B。\n广播风暴是指在网络中由于某种原因导致一个广播包被无限循环地复制和传播，从而导致网络性能下降，甚至网络瘫痪的现象。在给定的选项中：对于 A， 网关通常是不同网络之间的接口，它可以根据需要转发数据包。一个不当配置的网关可能会导致广播风暴，但这并不是最常见的情况。对于 B，网桥工作在数据链路层，用于连接两个局域网段。如果网桥的过滤机制失效，可能会导致广播风暴。对于 C，防火墙主要用于控制进出网络的数据包，一个配置不正确的防火墙可能会允许不当的广播流量，但通常不会直接引起广播风暴。对于 D 路由器工作在网络层，能够有效地隔离网络广播域。因此，路由器不太可能引起广播风暴。综上所述，选 B。\n</details>\n---\n\n关于 UDP伪首部的描述正确的是（  ）\n\nA.伪首部不是报文首部而是数据\n\nB.伪首部字段的内容放在 UDP 首部的后面\n\nC.伪首部是逻辑上的字段，不会占用 UDP额外的报文空间\n\nD.伪首部的作用是标识 UDP 报文的目的和源地址\n\n\n<details>\n    【解析】C。\nUDP的伪首部不是数据，A错。伪首部是放在UDP首部的前面的，B错。伪首部是用来计算校验和的，D错。\n</details>\n---\n\n在OSI模型中，自下而上第一个提供端到端服务的层次是：\n\nA.数据链路层  B.传输层  C.会话层  D.应用层\n\n<details>\n    【解析】B。\n    <img src=\"https://s2.loli.net/2024/07/27/jKd1qDLO582YaCr.png\" alt=\"image-20240727155052525\" />\n    <img src=\"https://s2.loli.net/2024/07/27/k4gSFR8Pb7LdiY9.png\" alt=\"image-20240727155209743\" />\n</details>    \n\n---\n\n【2010年题33】下列选项中，不属于网络体系结构所描述的内容是\nA.网络的层次      B.每一层使用的协议\nC.协议的内部实现细节    D.每一层必须完成的功能\n\n<details>\n    【解析】C。\n    送分题，计算机网络的实现细节不是体系结构本身所描述的问题\n</details>\n\n---\n\ntcp/ip体系结构中协议内容的一些题目\n\n<a id=\"tcp-protocol\"></a>\n\n【2011年题33】TCP/IP参考模型的网络层提供的是\nA.无连接不可靠的数据报服务   B.无连接可靠的数据报服务\nC.有连接不可靠的虚电路服务   D.有连接可靠的虚电路服务\n\n【2012年题33】在TCP/IP体系结构中，直接为ICMP提供服务的协议是 \nA.PPP    B.IP    C.UDP   D.TCP\n\n【2015年题33】通过POP3协议接收邮件时，使用的传输层服务类型是 \nA.无连接不可靠的数据传输服务  B.无连接可靠的数据传输服务\nC.有连接不可靠的数据传输服务  D.有连接可靠的数据传输服务\n\n【2018年题33】下列TCP/IP应用层协议中，可以使用传输层无连接服务的是 \nA.FTP   B. DNS     C. SMTP   D. HTTP\n\n<details>\n    【解析】ABDB。<br>\n    <img src=\"https://s2.loli.net/2024/07/27/VYKJMa7uLmv3if2.png\" alt=\"image-20240727155835246\" />\n    <img src=\"https://s2.loli.net/2024/07/27/lakMwQU5b6mYtF8.png\" alt=\"image-20240727161604974\" />\n</details>\n\n---\n\n主机甲通过1个路由器（存储转发方式）与主机乙互联，两段链路的数据传输速率均为10Mbps，主机甲分\n别采用报文交换和分组大小为10Kb的分组交换向主机乙发送1个大小为8Mb（1M=1e6）的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间分别为\nA.800ms、1600ms        B.801ms、1600ms\nC.1600ms、800ms        D.1600ms、801ms\n\n<details>\n    【解析】D。<br>\n    理解分组交换与报文交换之间的区别。且注意此处如果没有1M=1e6，我们应该将信息量中的M视为2^20。\n    <img src=\"https://s2.loli.net/2024/07/27/b7RZqnmhuPQKtfB.png\" alt=\"image-20240727162908194\" />\n</details>\n\n---\n\n【2014年题35】下列因素中，不会影响信道数据传输速率的是\nA.信噪比   B.频率带宽  C.调制速度  D.信号传播速度\n\n<details>\n    【解析】D <br>\n    由香农定理排除前两项，由奈氏准则可知，调制是指将数据转化为码元，会直接限制码元的船速速率。<br>\n    码元传输速率也叫调制速率.\n</details>\n---\n\n【2015年题36】下列关于CSMA/CD协议的叙述中，错误的是 \nA.边发送数据顿，边检测是否发生冲突\nB.适用于无线网络，以实现无线链路共享\nC.需要根据网络跨距和数据传输速率限定最小长\nD.当信号传播延迟趋近于0时，信道利用率趋近100%\n\n<details>\n    【解析】B。\n    适用于无线网络的碰撞避免协议是CSMA/CA\n</details>\n---\n\n以太网交换机地址表是通过以下方式学习到的( )\n\nA.利用进入交换机的帧的源 MAC 地址和进入端口学到的\n\nB.利用进入交换机的帧的源 MAC 地址和离开端口学到的\n\nC.利用进入交换机的帧的目的 MAC 地址和进入端口学到的\n\nD.利用进入交换机的帧的目的 MAC 地址和离开端口学到的\n\n<details>\n    【解析】B.\n    <br>\n    交换机通过检查进入其端口的以太网帧的源MAC地址来学习MAC地址。当一个帧到达交换机时，交换机会读取该帧的<b>源MAC地址，并将这个地址与其进入的端口号关联起来</b>。这样，交换机就可以建立一个MAC地址表，记录每个MAC地址对应的端口。这个过程称为自学习（self-learning）或MAC地址学习。\n</details>\n---\n\n（多选）关于HUB以下说法正确的是（  ）\n\nA.HUB可以用来构建局域网\n\nB.一般HUB都具有路由功能\n\nC.HUB通常也叫集线器,一般可以作为地址翻译设备\n\nD.一台共享式以太网HUB下的所有PC属于同一个冲突域\n\n<details>\n    【解析】AD<br>\n    集线器（Hub）是一种用于将多个网络设备连接在一起的网络设备。它属于OSI模型中的物理层设备，主要功能是将接收到的数据帧广播到所有连接的端口上。相比交换机，集线器的功能较为简单，它不会对数据帧进行过滤或转发，而是简单地将数据帧从一个端口复制到其他所有端口。不具备路由和地址转换功能。\n</details>\n---\n\n【2017年题37】直接封装RIP、OSPF、BGP报文的协议分别是 \nA. TCP、UDP、IP  B. TCP、IP、UDP  C. UDP、TCP、IP  D. UDP、IP、TCP\n\n<details> \n    【解析】D.如下图所示<br><img src=\"https://s2.loli.net/2024/08/07/epMFGOImXTNKzZi.png\" alt=\"image-20240807211847648\" />\n</details>\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-计网篇.md","raw":"---\ntitle: 错题汇总草案-计网篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 错题本\nhidden: true\n---\n<a href=\"#example\">0.例题</a>\n\n<a href=\"#tcp-protocol\">1.tcp协议</a>\n\n---\n\n无错误但觉得经典的例题\n\n<a id=\"example\"></a>\n\n## 例题\n\n### 调制与奈氏香农\n\n【2009年题34】在无噪声情况下，若某通信链路的带宽为3kHz，采用4个相位，每个相位具有4种振幅\n的QAM调制技术，则该通信链路的最大数据传输速率是\nA.12kbps   B. 24 kbps   C. 48 kbps   D.96kbps\n\n<details>\n    【解析】B<br>\n（1）根据奈氏准则可知，该通信链路的最高码元传输速率=2×3k=6k（Baud）=6k（码元/秒);<br>\n（2）采用4个相位，每个相位4种振幅的QAM调制技术，可以调制出4×4=16个不同的基本波形（码元）；<br>\n采用二进制对这16个不同的码元进行编码，需要使用4个比特（log216=4）。换句话说，每个码元可以携带的\n信息量为4比特；<br>\n综合（1）和（2）可知，该通信链路的最大数据传输速率=6k（码元/秒）×4（比特/码元）=24k（比特/秒）=24kbps\n</details>\n【2011年题34】若某通信链路的数据传输速率为2400bps，采用4相位调制，则该链路的波特率是\nA.600波特   B.1200波特  C.4800波特  D.9600波特\n\n<details>\n    【解析】B<br>\n（1）采用4相位调制，可以调制出4种相位不同的基本波形（码元）。采用二进制对这4个不同的码元进行编码，\n需要使用2个比特（log24=2）。换句话说，每个码元可以携带的信息量为2比特；<br>\n    （2）数据传输速率=波特率（码元传输速率）X每个码元所携带的信息量\n2400（比特/秒）=波特率X2（比特/码元）\n</details>\n【2016年题34】若连接R2和R3链路的频率带宽为8kHz，信噪比为30dB，该链路实际数据传输速率约\n为理论最大数据传输速率的50%，则该链路的实际数据传输速率约是 \nA.8kbps   B.20 kbps   C. 40kbps   D.80kbps\n\n<details>\n    【解析】C<br>\n    <img src=\"https://s2.loli.net/2024/07/27/d7z5UXxmhicbRTo.png\" alt=\"香农公式计算\" />\n</details>\n\n【2017年题34】若信道在无噪声情况下的极限数据传输速率不小于信噪比为30dB条件下的极限数据传\n输速率，则信号状态数至少是\nA.4    B.8    c.16    D.32\n\n<details>\n    【解析】D.<br>\n    <img src=\"https://s2.loli.net/2024/07/27/Zb4Dm3ELWJnXyI2.png\" alt=\"image-20240727174430576\" />\n</details>\n---\n\n当收发窗口的大小都为1时，滑动窗口协议成为（)协议。\nA.连续 ARQ\nB.选择重传 ARQ\nC.停止-等待\nD.BSC\n\n<details>\n    【解析】C。\n\t收发窗口都变成1，滑动窗口就变成了停止-等待协议；发送窗口和接收窗口都大于1时，就是选择重传ARQ。\n</details>\n---\n\n以下网络设备中, 可能引起广播风暴的是(  )\n\nA.网关\n\nB.网桥\n\nC.防火墙\n\nD.路由器\n\n<details>\n    【解析】B。\n广播风暴是指在网络中由于某种原因导致一个广播包被无限循环地复制和传播，从而导致网络性能下降，甚至网络瘫痪的现象。在给定的选项中：对于 A， 网关通常是不同网络之间的接口，它可以根据需要转发数据包。一个不当配置的网关可能会导致广播风暴，但这并不是最常见的情况。对于 B，网桥工作在数据链路层，用于连接两个局域网段。如果网桥的过滤机制失效，可能会导致广播风暴。对于 C，防火墙主要用于控制进出网络的数据包，一个配置不正确的防火墙可能会允许不当的广播流量，但通常不会直接引起广播风暴。对于 D 路由器工作在网络层，能够有效地隔离网络广播域。因此，路由器不太可能引起广播风暴。综上所述，选 B。\n</details>\n---\n\n关于 UDP伪首部的描述正确的是（  ）\n\nA.伪首部不是报文首部而是数据\n\nB.伪首部字段的内容放在 UDP 首部的后面\n\nC.伪首部是逻辑上的字段，不会占用 UDP额外的报文空间\n\nD.伪首部的作用是标识 UDP 报文的目的和源地址\n\n\n<details>\n    【解析】C。\nUDP的伪首部不是数据，A错。伪首部是放在UDP首部的前面的，B错。伪首部是用来计算校验和的，D错。\n</details>\n---\n\n在OSI模型中，自下而上第一个提供端到端服务的层次是：\n\nA.数据链路层  B.传输层  C.会话层  D.应用层\n\n<details>\n    【解析】B。\n    <img src=\"https://s2.loli.net/2024/07/27/jKd1qDLO582YaCr.png\" alt=\"image-20240727155052525\" />\n    <img src=\"https://s2.loli.net/2024/07/27/k4gSFR8Pb7LdiY9.png\" alt=\"image-20240727155209743\" />\n</details>    \n\n---\n\n【2010年题33】下列选项中，不属于网络体系结构所描述的内容是\nA.网络的层次      B.每一层使用的协议\nC.协议的内部实现细节    D.每一层必须完成的功能\n\n<details>\n    【解析】C。\n    送分题，计算机网络的实现细节不是体系结构本身所描述的问题\n</details>\n\n---\n\ntcp/ip体系结构中协议内容的一些题目\n\n<a id=\"tcp-protocol\"></a>\n\n【2011年题33】TCP/IP参考模型的网络层提供的是\nA.无连接不可靠的数据报服务   B.无连接可靠的数据报服务\nC.有连接不可靠的虚电路服务   D.有连接可靠的虚电路服务\n\n【2012年题33】在TCP/IP体系结构中，直接为ICMP提供服务的协议是 \nA.PPP    B.IP    C.UDP   D.TCP\n\n【2015年题33】通过POP3协议接收邮件时，使用的传输层服务类型是 \nA.无连接不可靠的数据传输服务  B.无连接可靠的数据传输服务\nC.有连接不可靠的数据传输服务  D.有连接可靠的数据传输服务\n\n【2018年题33】下列TCP/IP应用层协议中，可以使用传输层无连接服务的是 \nA.FTP   B. DNS     C. SMTP   D. HTTP\n\n<details>\n    【解析】ABDB。<br>\n    <img src=\"https://s2.loli.net/2024/07/27/VYKJMa7uLmv3if2.png\" alt=\"image-20240727155835246\" />\n    <img src=\"https://s2.loli.net/2024/07/27/lakMwQU5b6mYtF8.png\" alt=\"image-20240727161604974\" />\n</details>\n\n---\n\n主机甲通过1个路由器（存储转发方式）与主机乙互联，两段链路的数据传输速率均为10Mbps，主机甲分\n别采用报文交换和分组大小为10Kb的分组交换向主机乙发送1个大小为8Mb（1M=1e6）的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间分别为\nA.800ms、1600ms        B.801ms、1600ms\nC.1600ms、800ms        D.1600ms、801ms\n\n<details>\n    【解析】D。<br>\n    理解分组交换与报文交换之间的区别。且注意此处如果没有1M=1e6，我们应该将信息量中的M视为2^20。\n    <img src=\"https://s2.loli.net/2024/07/27/b7RZqnmhuPQKtfB.png\" alt=\"image-20240727162908194\" />\n</details>\n\n---\n\n【2014年题35】下列因素中，不会影响信道数据传输速率的是\nA.信噪比   B.频率带宽  C.调制速度  D.信号传播速度\n\n<details>\n    【解析】D <br>\n    由香农定理排除前两项，由奈氏准则可知，调制是指将数据转化为码元，会直接限制码元的船速速率。<br>\n    码元传输速率也叫调制速率.\n</details>\n---\n\n【2015年题36】下列关于CSMA/CD协议的叙述中，错误的是 \nA.边发送数据顿，边检测是否发生冲突\nB.适用于无线网络，以实现无线链路共享\nC.需要根据网络跨距和数据传输速率限定最小长\nD.当信号传播延迟趋近于0时，信道利用率趋近100%\n\n<details>\n    【解析】B。\n    适用于无线网络的碰撞避免协议是CSMA/CA\n</details>\n---\n\n以太网交换机地址表是通过以下方式学习到的( )\n\nA.利用进入交换机的帧的源 MAC 地址和进入端口学到的\n\nB.利用进入交换机的帧的源 MAC 地址和离开端口学到的\n\nC.利用进入交换机的帧的目的 MAC 地址和进入端口学到的\n\nD.利用进入交换机的帧的目的 MAC 地址和离开端口学到的\n\n<details>\n    【解析】B.\n    <br>\n    交换机通过检查进入其端口的以太网帧的源MAC地址来学习MAC地址。当一个帧到达交换机时，交换机会读取该帧的<b>源MAC地址，并将这个地址与其进入的端口号关联起来</b>。这样，交换机就可以建立一个MAC地址表，记录每个MAC地址对应的端口。这个过程称为自学习（self-learning）或MAC地址学习。\n</details>\n---\n\n（多选）关于HUB以下说法正确的是（  ）\n\nA.HUB可以用来构建局域网\n\nB.一般HUB都具有路由功能\n\nC.HUB通常也叫集线器,一般可以作为地址翻译设备\n\nD.一台共享式以太网HUB下的所有PC属于同一个冲突域\n\n<details>\n    【解析】AD<br>\n    集线器（Hub）是一种用于将多个网络设备连接在一起的网络设备。它属于OSI模型中的物理层设备，主要功能是将接收到的数据帧广播到所有连接的端口上。相比交换机，集线器的功能较为简单，它不会对数据帧进行过滤或转发，而是简单地将数据帧从一个端口复制到其他所有端口。不具备路由和地址转换功能。\n</details>\n---\n\n【2017年题37】直接封装RIP、OSPF、BGP报文的协议分别是 \nA. TCP、UDP、IP  B. TCP、IP、UDP  C. UDP、TCP、IP  D. UDP、IP、TCP\n\n<details> \n    【解析】D.如下图所示<br><img src=\"https://s2.loli.net/2024/08/07/epMFGOImXTNKzZi.png\" alt=\"image-20240807211847648\" />\n</details>\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-计网篇","published":1,"updated":"2024-08-17T13:18:43.531Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qq10005m8wvd2esgs1r","content":"<p><a href=\"#example\">0.例题</a></p>\n<p><a href=\"#tcp-protocol\">1.tcp协议</a></p>\n<hr>\n<p>无错误但觉得经典的例题</p>\n<p><a id=\"example\"></a></p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><h3 id=\"调制与奈氏香农\"><a href=\"#调制与奈氏香农\" class=\"headerlink\" title=\"调制与奈氏香农\"></a>调制与奈氏香农</h3><p>【2009年题34】在无噪声情况下，若某通信链路的带宽为3kHz，采用4个相位，每个相位具有4种振幅<br>的QAM调制技术，则该通信链路的最大数据传输速率是<br>A.12kbps   B. 24 kbps   C. 48 kbps   D.96kbps</p>\n<details>\n    【解析】B<br>\n（1）根据奈氏准则可知，该通信链路的最高码元传输速率=2×3k=6k（Baud）=6k（码元/秒);<br>\n（2）采用4个相位，每个相位4种振幅的QAM调制技术，可以调制出4×4=16个不同的基本波形（码元）；<br>\n采用二进制对这16个不同的码元进行编码，需要使用4个比特（log216=4）。换句话说，每个码元可以携带的\n信息量为4比特；<br>\n综合（1）和（2）可知，该通信链路的最大数据传输速率=6k（码元/秒）×4（比特/码元）=24k（比特/秒）=24kbps\n</details>\n【2011年题34】若某通信链路的数据传输速率为2400bps，采用4相位调制，则该链路的波特率是\nA.600波特   B.1200波特  C.4800波特  D.9600波特\n\n<details>\n    【解析】B<br>\n（1）采用4相位调制，可以调制出4种相位不同的基本波形（码元）。采用二进制对这4个不同的码元进行编码，\n需要使用2个比特（log24=2）。换句话说，每个码元可以携带的信息量为2比特；<br>\n    （2）数据传输速率=波特率（码元传输速率）X每个码元所携带的信息量\n2400（比特/秒）=波特率X2（比特/码元）\n</details>\n【2016年题34】若连接R2和R3链路的频率带宽为8kHz，信噪比为30dB，该链路实际数据传输速率约\n为理论最大数据传输速率的50%，则该链路的实际数据传输速率约是 \nA.8kbps   B.20 kbps   C. 40kbps   D.80kbps\n\n<details>\n    【解析】C<br>\n    <img src=\"https://s2.loli.net/2024/07/27/d7z5UXxmhicbRTo.png\" alt=\"香农公式计算\" />\n</details>\n\n<p>【2017年题34】若信道在无噪声情况下的极限数据传输速率不小于信噪比为30dB条件下的极限数据传<br>输速率，则信号状态数至少是<br>A.4    B.8    c.16    D.32</p>\n<details>\n    【解析】D.<br>\n    <img src=\"https://s2.loli.net/2024/07/27/Zb4Dm3ELWJnXyI2.png\" alt=\"image-20240727174430576\" />\n</details>\n---\n\n当收发窗口的大小都为1时，滑动窗口协议成为（)协议。\nA.连续 ARQ\nB.选择重传 ARQ\nC.停止-等待\nD.BSC\n\n<details>\n    【解析】C。\n    收发窗口都变成1，滑动窗口就变成了停止-等待协议；发送窗口和接收窗口都大于1时，就是选择重传ARQ。\n</details>\n---\n\n以下网络设备中, 可能引起广播风暴的是(  )\n\nA.网关\n\nB.网桥\n\nC.防火墙\n\nD.路由器\n\n<details>\n    【解析】B。\n广播风暴是指在网络中由于某种原因导致一个广播包被无限循环地复制和传播，从而导致网络性能下降，甚至网络瘫痪的现象。在给定的选项中：对于 A， 网关通常是不同网络之间的接口，它可以根据需要转发数据包。一个不当配置的网关可能会导致广播风暴，但这并不是最常见的情况。对于 B，网桥工作在数据链路层，用于连接两个局域网段。如果网桥的过滤机制失效，可能会导致广播风暴。对于 C，防火墙主要用于控制进出网络的数据包，一个配置不正确的防火墙可能会允许不当的广播流量，但通常不会直接引起广播风暴。对于 D 路由器工作在网络层，能够有效地隔离网络广播域。因此，路由器不太可能引起广播风暴。综上所述，选 B。\n</details>\n---\n\n关于 UDP伪首部的描述正确的是（  ）\n\nA.伪首部不是报文首部而是数据\n\nB.伪首部字段的内容放在 UDP 首部的后面\n\nC.伪首部是逻辑上的字段，不会占用 UDP额外的报文空间\n\nD.伪首部的作用是标识 UDP 报文的目的和源地址\n\n\n<details>\n    【解析】C。\nUDP的伪首部不是数据，A错。伪首部是放在UDP首部的前面的，B错。伪首部是用来计算校验和的，D错。\n</details>\n---\n\n在OSI模型中，自下而上第一个提供端到端服务的层次是：\n\nA.数据链路层  B.传输层  C.会话层  D.应用层\n\n<details>\n    【解析】B。\n    <img src=\"https://s2.loli.net/2024/07/27/jKd1qDLO582YaCr.png\" alt=\"image-20240727155052525\" />\n    <img src=\"https://s2.loli.net/2024/07/27/k4gSFR8Pb7LdiY9.png\" alt=\"image-20240727155209743\" />\n</details>    \n\n<hr>\n<p>【2010年题33】下列选项中，不属于网络体系结构所描述的内容是<br>A.网络的层次      B.每一层使用的协议<br>C.协议的内部实现细节    D.每一层必须完成的功能</p>\n<details>\n    【解析】C。\n    送分题，计算机网络的实现细节不是体系结构本身所描述的问题\n</details>\n\n<hr>\n<p>tcp/ip体系结构中协议内容的一些题目</p>\n<p><a id=\"tcp-protocol\"></a></p>\n<p>【2011年题33】TCP/IP参考模型的网络层提供的是<br>A.无连接不可靠的数据报服务   B.无连接可靠的数据报服务<br>C.有连接不可靠的虚电路服务   D.有连接可靠的虚电路服务</p>\n<p>【2012年题33】在TCP/IP体系结构中，直接为ICMP提供服务的协议是<br>A.PPP    B.IP    C.UDP   D.TCP</p>\n<p>【2015年题33】通过POP3协议接收邮件时，使用的传输层服务类型是<br>A.无连接不可靠的数据传输服务  B.无连接可靠的数据传输服务<br>C.有连接不可靠的数据传输服务  D.有连接可靠的数据传输服务</p>\n<p>【2018年题33】下列TCP/IP应用层协议中，可以使用传输层无连接服务的是<br>A.FTP   B. DNS     C. SMTP   D. HTTP</p>\n<details>\n    【解析】ABDB。<br>\n    <img src=\"https://s2.loli.net/2024/07/27/VYKJMa7uLmv3if2.png\" alt=\"image-20240727155835246\" />\n    <img src=\"https://s2.loli.net/2024/07/27/lakMwQU5b6mYtF8.png\" alt=\"image-20240727161604974\" />\n</details>\n\n<hr>\n<p>主机甲通过1个路由器（存储转发方式）与主机乙互联，两段链路的数据传输速率均为10Mbps，主机甲分<br>别采用报文交换和分组大小为10Kb的分组交换向主机乙发送1个大小为8Mb（1M=1e6）的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间分别为<br>A.800ms、1600ms        B.801ms、1600ms<br>C.1600ms、800ms        D.1600ms、801ms</p>\n<details>\n    【解析】D。<br>\n    理解分组交换与报文交换之间的区别。且注意此处如果没有1M=1e6，我们应该将信息量中的M视为2^20。\n    <img src=\"https://s2.loli.net/2024/07/27/b7RZqnmhuPQKtfB.png\" alt=\"image-20240727162908194\" />\n</details>\n\n<hr>\n<p>【2014年题35】下列因素中，不会影响信道数据传输速率的是<br>A.信噪比   B.频率带宽  C.调制速度  D.信号传播速度</p>\n<details>\n    【解析】D <br>\n    由香农定理排除前两项，由奈氏准则可知，调制是指将数据转化为码元，会直接限制码元的船速速率。<br>\n    码元传输速率也叫调制速率.\n</details>\n---\n\n【2015年题36】下列关于CSMA/CD协议的叙述中，错误的是 \nA.边发送数据顿，边检测是否发生冲突\nB.适用于无线网络，以实现无线链路共享\nC.需要根据网络跨距和数据传输速率限定最小长\nD.当信号传播延迟趋近于0时，信道利用率趋近100%\n\n<details>\n    【解析】B。\n    适用于无线网络的碰撞避免协议是CSMA/CA\n</details>\n---\n\n以太网交换机地址表是通过以下方式学习到的( )\n\nA.利用进入交换机的帧的源 MAC 地址和进入端口学到的\n\nB.利用进入交换机的帧的源 MAC 地址和离开端口学到的\n\nC.利用进入交换机的帧的目的 MAC 地址和进入端口学到的\n\nD.利用进入交换机的帧的目的 MAC 地址和离开端口学到的\n\n<details>\n    【解析】B.\n    <br>\n    交换机通过检查进入其端口的以太网帧的源MAC地址来学习MAC地址。当一个帧到达交换机时，交换机会读取该帧的<b>源MAC地址，并将这个地址与其进入的端口号关联起来</b>。这样，交换机就可以建立一个MAC地址表，记录每个MAC地址对应的端口。这个过程称为自学习（self-learning）或MAC地址学习。\n</details>\n---\n\n（多选）关于HUB以下说法正确的是（  ）\n\nA.HUB可以用来构建局域网\n\nB.一般HUB都具有路由功能\n\nC.HUB通常也叫集线器,一般可以作为地址翻译设备\n\nD.一台共享式以太网HUB下的所有PC属于同一个冲突域\n\n<details>\n    【解析】AD<br>\n    集线器（Hub）是一种用于将多个网络设备连接在一起的网络设备。它属于OSI模型中的物理层设备，主要功能是将接收到的数据帧广播到所有连接的端口上。相比交换机，集线器的功能较为简单，它不会对数据帧进行过滤或转发，而是简单地将数据帧从一个端口复制到其他所有端口。不具备路由和地址转换功能。\n</details>\n---\n\n【2017年题37】直接封装RIP、OSPF、BGP报文的协议分别是 \nA. TCP、UDP、IP  B. TCP、IP、UDP  C. UDP、TCP、IP  D. UDP、IP、TCP\n\n<details> \n    【解析】D.如下图所示<br><img src=\"https://s2.loli.net/2024/08/07/epMFGOImXTNKzZi.png\" alt=\"image-20240807211847648\" />\n</details>\n<!-- flag of hidden posts -->","length":2478,"excerpt":"","more":"<p><a href=\"#example\">0.例题</a></p>\n<p><a href=\"#tcp-protocol\">1.tcp协议</a></p>\n<hr>\n<p>无错误但觉得经典的例题</p>\n<p><a id=\"example\"></a></p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><h3 id=\"调制与奈氏香农\"><a href=\"#调制与奈氏香农\" class=\"headerlink\" title=\"调制与奈氏香农\"></a>调制与奈氏香农</h3><p>【2009年题34】在无噪声情况下，若某通信链路的带宽为3kHz，采用4个相位，每个相位具有4种振幅<br>的QAM调制技术，则该通信链路的最大数据传输速率是<br>A.12kbps   B. 24 kbps   C. 48 kbps   D.96kbps</p>\n<details>\n    【解析】B<br>\n（1）根据奈氏准则可知，该通信链路的最高码元传输速率=2×3k=6k（Baud）=6k（码元/秒);<br>\n（2）采用4个相位，每个相位4种振幅的QAM调制技术，可以调制出4×4=16个不同的基本波形（码元）；<br>\n采用二进制对这16个不同的码元进行编码，需要使用4个比特（log216=4）。换句话说，每个码元可以携带的\n信息量为4比特；<br>\n综合（1）和（2）可知，该通信链路的最大数据传输速率=6k（码元/秒）×4（比特/码元）=24k（比特/秒）=24kbps\n</details>\n【2011年题34】若某通信链路的数据传输速率为2400bps，采用4相位调制，则该链路的波特率是\nA.600波特   B.1200波特  C.4800波特  D.9600波特\n\n<details>\n    【解析】B<br>\n（1）采用4相位调制，可以调制出4种相位不同的基本波形（码元）。采用二进制对这4个不同的码元进行编码，\n需要使用2个比特（log24=2）。换句话说，每个码元可以携带的信息量为2比特；<br>\n    （2）数据传输速率=波特率（码元传输速率）X每个码元所携带的信息量\n2400（比特/秒）=波特率X2（比特/码元）\n</details>\n【2016年题34】若连接R2和R3链路的频率带宽为8kHz，信噪比为30dB，该链路实际数据传输速率约\n为理论最大数据传输速率的50%，则该链路的实际数据传输速率约是 \nA.8kbps   B.20 kbps   C. 40kbps   D.80kbps\n\n<details>\n    【解析】C<br>\n    <img src=\"https://s2.loli.net/2024/07/27/d7z5UXxmhicbRTo.png\" alt=\"香农公式计算\" />\n</details>\n\n<p>【2017年题34】若信道在无噪声情况下的极限数据传输速率不小于信噪比为30dB条件下的极限数据传<br>输速率，则信号状态数至少是<br>A.4    B.8    c.16    D.32</p>\n<details>\n    【解析】D.<br>\n    <img src=\"https://s2.loli.net/2024/07/27/Zb4Dm3ELWJnXyI2.png\" alt=\"image-20240727174430576\" />\n</details>\n---\n\n当收发窗口的大小都为1时，滑动窗口协议成为（)协议。\nA.连续 ARQ\nB.选择重传 ARQ\nC.停止-等待\nD.BSC\n\n<details>\n    【解析】C。\n    收发窗口都变成1，滑动窗口就变成了停止-等待协议；发送窗口和接收窗口都大于1时，就是选择重传ARQ。\n</details>\n---\n\n以下网络设备中, 可能引起广播风暴的是(  )\n\nA.网关\n\nB.网桥\n\nC.防火墙\n\nD.路由器\n\n<details>\n    【解析】B。\n广播风暴是指在网络中由于某种原因导致一个广播包被无限循环地复制和传播，从而导致网络性能下降，甚至网络瘫痪的现象。在给定的选项中：对于 A， 网关通常是不同网络之间的接口，它可以根据需要转发数据包。一个不当配置的网关可能会导致广播风暴，但这并不是最常见的情况。对于 B，网桥工作在数据链路层，用于连接两个局域网段。如果网桥的过滤机制失效，可能会导致广播风暴。对于 C，防火墙主要用于控制进出网络的数据包，一个配置不正确的防火墙可能会允许不当的广播流量，但通常不会直接引起广播风暴。对于 D 路由器工作在网络层，能够有效地隔离网络广播域。因此，路由器不太可能引起广播风暴。综上所述，选 B。\n</details>\n---\n\n关于 UDP伪首部的描述正确的是（  ）\n\nA.伪首部不是报文首部而是数据\n\nB.伪首部字段的内容放在 UDP 首部的后面\n\nC.伪首部是逻辑上的字段，不会占用 UDP额外的报文空间\n\nD.伪首部的作用是标识 UDP 报文的目的和源地址\n\n\n<details>\n    【解析】C。\nUDP的伪首部不是数据，A错。伪首部是放在UDP首部的前面的，B错。伪首部是用来计算校验和的，D错。\n</details>\n---\n\n在OSI模型中，自下而上第一个提供端到端服务的层次是：\n\nA.数据链路层  B.传输层  C.会话层  D.应用层\n\n<details>\n    【解析】B。\n    <img src=\"https://s2.loli.net/2024/07/27/jKd1qDLO582YaCr.png\" alt=\"image-20240727155052525\" />\n    <img src=\"https://s2.loli.net/2024/07/27/k4gSFR8Pb7LdiY9.png\" alt=\"image-20240727155209743\" />\n</details>    \n\n<hr>\n<p>【2010年题33】下列选项中，不属于网络体系结构所描述的内容是<br>A.网络的层次      B.每一层使用的协议<br>C.协议的内部实现细节    D.每一层必须完成的功能</p>\n<details>\n    【解析】C。\n    送分题，计算机网络的实现细节不是体系结构本身所描述的问题\n</details>\n\n<hr>\n<p>tcp/ip体系结构中协议内容的一些题目</p>\n<p><a id=\"tcp-protocol\"></a></p>\n<p>【2011年题33】TCP/IP参考模型的网络层提供的是<br>A.无连接不可靠的数据报服务   B.无连接可靠的数据报服务<br>C.有连接不可靠的虚电路服务   D.有连接可靠的虚电路服务</p>\n<p>【2012年题33】在TCP/IP体系结构中，直接为ICMP提供服务的协议是<br>A.PPP    B.IP    C.UDP   D.TCP</p>\n<p>【2015年题33】通过POP3协议接收邮件时，使用的传输层服务类型是<br>A.无连接不可靠的数据传输服务  B.无连接可靠的数据传输服务<br>C.有连接不可靠的数据传输服务  D.有连接可靠的数据传输服务</p>\n<p>【2018年题33】下列TCP/IP应用层协议中，可以使用传输层无连接服务的是<br>A.FTP   B. DNS     C. SMTP   D. HTTP</p>\n<details>\n    【解析】ABDB。<br>\n    <img src=\"https://s2.loli.net/2024/07/27/VYKJMa7uLmv3if2.png\" alt=\"image-20240727155835246\" />\n    <img src=\"https://s2.loli.net/2024/07/27/lakMwQU5b6mYtF8.png\" alt=\"image-20240727161604974\" />\n</details>\n\n<hr>\n<p>主机甲通过1个路由器（存储转发方式）与主机乙互联，两段链路的数据传输速率均为10Mbps，主机甲分<br>别采用报文交换和分组大小为10Kb的分组交换向主机乙发送1个大小为8Mb（1M=1e6）的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间分别为<br>A.800ms、1600ms        B.801ms、1600ms<br>C.1600ms、800ms        D.1600ms、801ms</p>\n<details>\n    【解析】D。<br>\n    理解分组交换与报文交换之间的区别。且注意此处如果没有1M=1e6，我们应该将信息量中的M视为2^20。\n    <img src=\"https://s2.loli.net/2024/07/27/b7RZqnmhuPQKtfB.png\" alt=\"image-20240727162908194\" />\n</details>\n\n<hr>\n<p>【2014年题35】下列因素中，不会影响信道数据传输速率的是<br>A.信噪比   B.频率带宽  C.调制速度  D.信号传播速度</p>\n<details>\n    【解析】D <br>\n    由香农定理排除前两项，由奈氏准则可知，调制是指将数据转化为码元，会直接限制码元的船速速率。<br>\n    码元传输速率也叫调制速率.\n</details>\n---\n\n【2015年题36】下列关于CSMA/CD协议的叙述中，错误的是 \nA.边发送数据顿，边检测是否发生冲突\nB.适用于无线网络，以实现无线链路共享\nC.需要根据网络跨距和数据传输速率限定最小长\nD.当信号传播延迟趋近于0时，信道利用率趋近100%\n\n<details>\n    【解析】B。\n    适用于无线网络的碰撞避免协议是CSMA/CA\n</details>\n---\n\n以太网交换机地址表是通过以下方式学习到的( )\n\nA.利用进入交换机的帧的源 MAC 地址和进入端口学到的\n\nB.利用进入交换机的帧的源 MAC 地址和离开端口学到的\n\nC.利用进入交换机的帧的目的 MAC 地址和进入端口学到的\n\nD.利用进入交换机的帧的目的 MAC 地址和离开端口学到的\n\n<details>\n    【解析】B.\n    <br>\n    交换机通过检查进入其端口的以太网帧的源MAC地址来学习MAC地址。当一个帧到达交换机时，交换机会读取该帧的<b>源MAC地址，并将这个地址与其进入的端口号关联起来</b>。这样，交换机就可以建立一个MAC地址表，记录每个MAC地址对应的端口。这个过程称为自学习（self-learning）或MAC地址学习。\n</details>\n---\n\n（多选）关于HUB以下说法正确的是（  ）\n\nA.HUB可以用来构建局域网\n\nB.一般HUB都具有路由功能\n\nC.HUB通常也叫集线器,一般可以作为地址翻译设备\n\nD.一台共享式以太网HUB下的所有PC属于同一个冲突域\n\n<details>\n    【解析】AD<br>\n    集线器（Hub）是一种用于将多个网络设备连接在一起的网络设备。它属于OSI模型中的物理层设备，主要功能是将接收到的数据帧广播到所有连接的端口上。相比交换机，集线器的功能较为简单，它不会对数据帧进行过滤或转发，而是简单地将数据帧从一个端口复制到其他所有端口。不具备路由和地址转换功能。\n</details>\n---\n\n【2017年题37】直接封装RIP、OSPF、BGP报文的协议分别是 \nA. TCP、UDP、IP  B. TCP、IP、UDP  C. UDP、TCP、IP  D. UDP、IP、TCP\n\n<details> \n    【解析】D.如下图所示<br><img src=\"https://s2.loli.net/2024/08/07/epMFGOImXTNKzZi.png\" alt=\"image-20240807211847648\" />\n</details>\n"},{"title":"错题汇总草案-系统篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"<a href=\"#process-schedule\">编号1</a>\n\n---\n\n<a id=\"process-schedule\"></a>\n\n若某单处理器多进程系统中有多个就绪态进\n程，则下列关于处理机调度的叙述中，错误\n的是()\n\nA在进程结束时能进行处理机调度\n\nB创建新进程后能进行处理机调度\n\nC在进程处于临界区时不能进行处理机调度\n\nD 在系统调用完成并返回用户态时能进行外理机调度\n\n<details>\n    <p>\n        【解析】C。\n    </p>\n    <p>\n        选项A、B、D显然是可以进行处理机调度\n的情况。对于C，当进程处于临界区时,\n说明进程正在占用处理机，只要不破坏临\n界资源的使用规则，是不会影响处理机调\n度的，比如通常访问临界资源可能是慢速\n的外设（如打印机），如果在进程访问打\n印机时，不能处理机调度，那么系统的性\n能将是非常低的。几种不适合进行处理机\n调度的情况：①在处理中断的过程中；\n②进程在操作系统内核程序临界区中；\n③其他需要完全屏蔽中断的原子操作过程中\n    </p>\n</details>\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-系统篇.md","raw":"---\ntitle: 错题汇总草案-系统篇\ndate: 2024-08-14 19:47:58\ntags: [操作系统, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 错题本\nhidden: true\n---\n<a href=\"#process-schedule\">编号1</a>\n\n---\n\n<a id=\"process-schedule\"></a>\n\n若某单处理器多进程系统中有多个就绪态进\n程，则下列关于处理机调度的叙述中，错误\n的是()\n\nA在进程结束时能进行处理机调度\n\nB创建新进程后能进行处理机调度\n\nC在进程处于临界区时不能进行处理机调度\n\nD 在系统调用完成并返回用户态时能进行外理机调度\n\n<details>\n    <p>\n        【解析】C。\n    </p>\n    <p>\n        选项A、B、D显然是可以进行处理机调度\n的情况。对于C，当进程处于临界区时,\n说明进程正在占用处理机，只要不破坏临\n界资源的使用规则，是不会影响处理机调\n度的，比如通常访问临界资源可能是慢速\n的外设（如打印机），如果在进程访问打\n印机时，不能处理机调度，那么系统的性\n能将是非常低的。几种不适合进行处理机\n调度的情况：①在处理中断的过程中；\n②进程在操作系统内核程序临界区中；\n③其他需要完全屏蔽中断的原子操作过程中\n    </p>\n</details>\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-系统篇","published":1,"updated":"2024-08-17T13:18:35.858Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qq20006m8wvhzav778g","content":"<p><a href=\"#process-schedule\">编号1</a></p>\n<hr>\n<p><a id=\"process-schedule\"></a></p>\n<p>若某单处理器多进程系统中有多个就绪态进<br>程，则下列关于处理机调度的叙述中，错误<br>的是()</p>\n<p>A在进程结束时能进行处理机调度</p>\n<p>B创建新进程后能进行处理机调度</p>\n<p>C在进程处于临界区时不能进行处理机调度</p>\n<p>D 在系统调用完成并返回用户态时能进行外理机调度</p>\n<details>\n    <p>\n        【解析】C。\n    </p>\n    <p>\n        选项A、B、D显然是可以进行处理机调度\n的情况。对于C，当进程处于临界区时,\n说明进程正在占用处理机，只要不破坏临\n界资源的使用规则，是不会影响处理机调\n度的，比如通常访问临界资源可能是慢速\n的外设（如打印机），如果在进程访问打\n印机时，不能处理机调度，那么系统的性\n能将是非常低的。几种不适合进行处理机\n调度的情况：①在处理中断的过程中；\n②进程在操作系统内核程序临界区中；\n③其他需要完全屏蔽中断的原子操作过程中\n    </p>\n</details>\n<!-- flag of hidden posts -->","length":313,"excerpt":"","more":"<p><a href=\"#process-schedule\">编号1</a></p>\n<hr>\n<p><a id=\"process-schedule\"></a></p>\n<p>若某单处理器多进程系统中有多个就绪态进<br>程，则下列关于处理机调度的叙述中，错误<br>的是()</p>\n<p>A在进程结束时能进行处理机调度</p>\n<p>B创建新进程后能进行处理机调度</p>\n<p>C在进程处于临界区时不能进行处理机调度</p>\n<p>D 在系统调用完成并返回用户态时能进行外理机调度</p>\n<details>\n    <p>\n        【解析】C。\n    </p>\n    <p>\n        选项A、B、D显然是可以进行处理机调度\n的情况。对于C，当进程处于临界区时,\n说明进程正在占用处理机，只要不破坏临\n界资源的使用规则，是不会影响处理机调\n度的，比如通常访问临界资源可能是慢速\n的外设（如打印机），如果在进程访问打\n印机时，不能处理机调度，那么系统的性\n能将是非常低的。几种不适合进行处理机\n调度的情况：①在处理中断的过程中；\n②进程在操作系统内核程序临界区中；\n③其他需要完全屏蔽中断的原子操作过程中\n    </p>\n</details>\n"},{"title":"错题汇总草案-计组篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"假设某条指令的一个操作数采用寄存器间接寻址方式，假定指令中给出的寄存器编号\n02 为 8，8 号寄存器的内容为 1200H，地址 1200H 中的内容为 12FCH，地址 12FCH 中\n的内容为 38B8H，地址 38B8H 中的内容为 88F9H，则该操作数的有效地址为（）。\n\tA.1200H\n\tB.12FCH\n\tC.38B8H\n\tD.88F9H\n\n<details>\n<p>\n    【解析】A。\n    采用寄存器间接寻址，指令字中的寄存器给出的不是一个操作数，而是操作数所在的主存单元地址，即 EA =(Ri)，故该操作数的有效地址为 8 号寄存器的内容，即 1200H\n</p>\n</details>\n\n---\n\n在设备管理中，引人缓冲的主要原因不包括 （ ）。\n\nA.缓和处理机和外设之间访问速度不匹配的矛盾\n\nB.缓和处理机和内存之间访问速度不匹配的矛盾\n\nC.减少对处理机的中断频率，放宽对处理机中断响应时间的限制\n\nD.提高处理机和外围设备之间的并行性\n\n<details>\n    <p>\n        【解析】B。\n        缓冲是使用专用硬件缓冲器或在内存中划出一个区域，来暂时存放 I/O 数据的器件。引人缓冲是为了协调速度相差很大的设备之间的数据传输，减少对 CPU 的中断频率，放宽对中断响应时间的限制以及提高 CPU 和 IO 设备之间的并行性。\n    </p>\n</details>\n---\n\n关于相联存储器，下列说法中正确的是（）。\nA.只可以按地址寻址   B.只可以按内容寻址\nC.既可按地址寻址又可按内容寻址 D.以上说法均不完善\n\n<details>\n    【解析】C。\n    有关相联存储器，它既可以按照地址寻址也可按照内容寻址，因此又被称为：内容寻址器\n</details>\n---\n\n下列叙述中，正确的是（）。\nI.实际应用程序的测试结果能够全面代表计算机的性能\nI.系列机的基本特性是指令系统向后兼容\nIII.软件和硬件在逻辑功能上是等价的\nA. II   B. II   c. II和III D. I、II 和 II\n\n<details>\n    【解析】C。\n   全面代表计算机性能的是实际软件的运行情况。向后兼容是指时间上向后兼容，即新机器表\n容使用以前机器的指令系统。软件和硬件在逻辑功能上是等价的，如浮点运算即可以用专门的浮\n点运算器实现，也可以通过编写一段子程序实现。\n</details>\n\n关于编译程序和解释程序，下列说法中错误的是（）。\nA.编译程序和解释程序的作用都是将高级语言程序转换成机器语言程序\nB.编译程序编译时间较长，运行速度较快\nC.解释程序方法较简单，运行速度也较快\nD.解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句\n\n<details>\n    【解析】C。同时出现编译和解释一定要说明解释更慢，并且值得注意的是**解释是一边‘编译’一边运行的**\n</details>\n\n---\n\nCPU寄存器相关三题\n\n1.存放当前执行指令的寄存器是（）。\nA.MAR  B. PC   C. MDR  D. IR\n2.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（）。\nA. PC  B. MAR  C. MDR  D. IR\n3.CPU不包括（)\nA.地址寄存器     B.指令寄存器（IR）\nC.地址译码器     D.通用寄存器\n\n<details>\n    【解析】BAC\n    IR存放当前执行的指令代码，PC存放下一条指令的地址，不要将它们混淆。此外，MAR用\n来存放待访问的存储单元地址，MDR则用来存放取处存储单元的数据。\n    在CPU中，PC用来跟踪下一条要执行的指令在主存储器中的地址。\n    地址译码器是主存储器的构成部分，不属于CPU。地址寄存器虽然一般属于主存储器，但现\n代计算机中绝大多数CPU内集成了地址寄存器。\n</details>\n---\n\n微程序控制器中，机器指令执行周期微程序的入口地址是由（ ）形成的。\n\nA.微指令的地址码字段\n\nB.微指令的操作码字段\n\nC.机器指令的地址码字段\n\nD.机器指令的操作码字段\n\n<details>\n    【解析】D。\n微程序控制器的工作原理是将每条机器指令分解为一系列更小的步骤，称为微指令。这些微指令被组织在一个控制存储器中，控制存储器中的每个条目都包含执行机器指令所需的微操作序列。机器指令的操作码字段决定了需要执行哪些微操作，因此也就确定了微程序的入口地址。控制存储器会根据操作码来查找对应的微程序序列，并开始执行。\n</details>\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-计组篇.md","raw":"---\ntitle: 错题汇总草案-计组篇\ndate: 2024-08-14 19:47:58\ntags: [计算机组成原理, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 错题本\nhidden: true\n---\n假设某条指令的一个操作数采用寄存器间接寻址方式，假定指令中给出的寄存器编号\n02 为 8，8 号寄存器的内容为 1200H，地址 1200H 中的内容为 12FCH，地址 12FCH 中\n的内容为 38B8H，地址 38B8H 中的内容为 88F9H，则该操作数的有效地址为（）。\n\tA.1200H\n\tB.12FCH\n\tC.38B8H\n\tD.88F9H\n\n<details>\n<p>\n    【解析】A。\n    采用寄存器间接寻址，指令字中的寄存器给出的不是一个操作数，而是操作数所在的主存单元地址，即 EA =(Ri)，故该操作数的有效地址为 8 号寄存器的内容，即 1200H\n</p>\n</details>\n\n---\n\n在设备管理中，引人缓冲的主要原因不包括 （ ）。\n\nA.缓和处理机和外设之间访问速度不匹配的矛盾\n\nB.缓和处理机和内存之间访问速度不匹配的矛盾\n\nC.减少对处理机的中断频率，放宽对处理机中断响应时间的限制\n\nD.提高处理机和外围设备之间的并行性\n\n<details>\n    <p>\n        【解析】B。\n        缓冲是使用专用硬件缓冲器或在内存中划出一个区域，来暂时存放 I/O 数据的器件。引人缓冲是为了协调速度相差很大的设备之间的数据传输，减少对 CPU 的中断频率，放宽对中断响应时间的限制以及提高 CPU 和 IO 设备之间的并行性。\n    </p>\n</details>\n---\n\n关于相联存储器，下列说法中正确的是（）。\nA.只可以按地址寻址   B.只可以按内容寻址\nC.既可按地址寻址又可按内容寻址 D.以上说法均不完善\n\n<details>\n    【解析】C。\n    有关相联存储器，它既可以按照地址寻址也可按照内容寻址，因此又被称为：内容寻址器\n</details>\n---\n\n下列叙述中，正确的是（）。\nI.实际应用程序的测试结果能够全面代表计算机的性能\nI.系列机的基本特性是指令系统向后兼容\nIII.软件和硬件在逻辑功能上是等价的\nA. II   B. II   c. II和III D. I、II 和 II\n\n<details>\n    【解析】C。\n   全面代表计算机性能的是实际软件的运行情况。向后兼容是指时间上向后兼容，即新机器表\n容使用以前机器的指令系统。软件和硬件在逻辑功能上是等价的，如浮点运算即可以用专门的浮\n点运算器实现，也可以通过编写一段子程序实现。\n</details>\n\n关于编译程序和解释程序，下列说法中错误的是（）。\nA.编译程序和解释程序的作用都是将高级语言程序转换成机器语言程序\nB.编译程序编译时间较长，运行速度较快\nC.解释程序方法较简单，运行速度也较快\nD.解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句\n\n<details>\n    【解析】C。同时出现编译和解释一定要说明解释更慢，并且值得注意的是**解释是一边‘编译’一边运行的**\n</details>\n\n---\n\nCPU寄存器相关三题\n\n1.存放当前执行指令的寄存器是（）。\nA.MAR  B. PC   C. MDR  D. IR\n2.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（）。\nA. PC  B. MAR  C. MDR  D. IR\n3.CPU不包括（)\nA.地址寄存器     B.指令寄存器（IR）\nC.地址译码器     D.通用寄存器\n\n<details>\n    【解析】BAC\n    IR存放当前执行的指令代码，PC存放下一条指令的地址，不要将它们混淆。此外，MAR用\n来存放待访问的存储单元地址，MDR则用来存放取处存储单元的数据。\n    在CPU中，PC用来跟踪下一条要执行的指令在主存储器中的地址。\n    地址译码器是主存储器的构成部分，不属于CPU。地址寄存器虽然一般属于主存储器，但现\n代计算机中绝大多数CPU内集成了地址寄存器。\n</details>\n---\n\n微程序控制器中，机器指令执行周期微程序的入口地址是由（ ）形成的。\n\nA.微指令的地址码字段\n\nB.微指令的操作码字段\n\nC.机器指令的地址码字段\n\nD.机器指令的操作码字段\n\n<details>\n    【解析】D。\n微程序控制器的工作原理是将每条机器指令分解为一系列更小的步骤，称为微指令。这些微指令被组织在一个控制存储器中，控制存储器中的每个条目都包含执行机器指令所需的微操作序列。机器指令的操作码字段决定了需要执行哪些微操作，因此也就确定了微程序的入口地址。控制存储器会根据操作码来查找对应的微程序序列，并开始执行。\n</details>\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/错题汇总草案-计组篇","published":1,"updated":"2024-08-17T13:18:38.779Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qq50009m8wv0sy5dynu","content":"<p>假设某条指令的一个操作数采用寄存器间接寻址方式，假定指令中给出的寄存器编号<br>02 为 8，8 号寄存器的内容为 1200H，地址 1200H 中的内容为 12FCH，地址 12FCH 中<br>的内容为 38B8H，地址 38B8H 中的内容为 88F9H，则该操作数的有效地址为（）。<br>    A.1200H<br>    B.12FCH<br>    C.38B8H<br>    D.88F9H</p>\n<details>\n<p>\n    【解析】A。\n    采用寄存器间接寻址，指令字中的寄存器给出的不是一个操作数，而是操作数所在的主存单元地址，即 EA =(Ri)，故该操作数的有效地址为 8 号寄存器的内容，即 1200H\n</p>\n</details>\n\n<hr>\n<p>在设备管理中，引人缓冲的主要原因不包括 （ ）。</p>\n<p>A.缓和处理机和外设之间访问速度不匹配的矛盾</p>\n<p>B.缓和处理机和内存之间访问速度不匹配的矛盾</p>\n<p>C.减少对处理机的中断频率，放宽对处理机中断响应时间的限制</p>\n<p>D.提高处理机和外围设备之间的并行性</p>\n<details>\n    <p>\n        【解析】B。\n        缓冲是使用专用硬件缓冲器或在内存中划出一个区域，来暂时存放 I/O 数据的器件。引人缓冲是为了协调速度相差很大的设备之间的数据传输，减少对 CPU 的中断频率，放宽对中断响应时间的限制以及提高 CPU 和 IO 设备之间的并行性。\n    </p>\n</details>\n---\n\n关于相联存储器，下列说法中正确的是（）。\nA.只可以按地址寻址   B.只可以按内容寻址\nC.既可按地址寻址又可按内容寻址 D.以上说法均不完善\n\n<details>\n    【解析】C。\n    有关相联存储器，它既可以按照地址寻址也可按照内容寻址，因此又被称为：内容寻址器\n</details>\n---\n\n下列叙述中，正确的是（）。\nI.实际应用程序的测试结果能够全面代表计算机的性能\nI.系列机的基本特性是指令系统向后兼容\nIII.软件和硬件在逻辑功能上是等价的\nA. II   B. II   c. II和III D. I、II 和 II\n\n<details>\n    【解析】C。\n   全面代表计算机性能的是实际软件的运行情况。向后兼容是指时间上向后兼容，即新机器表\n容使用以前机器的指令系统。软件和硬件在逻辑功能上是等价的，如浮点运算即可以用专门的浮\n点运算器实现，也可以通过编写一段子程序实现。\n</details>\n\n<p>关于编译程序和解释程序，下列说法中错误的是（）。<br>A.编译程序和解释程序的作用都是将高级语言程序转换成机器语言程序<br>B.编译程序编译时间较长，运行速度较快<br>C.解释程序方法较简单，运行速度也较快<br>D.解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句</p>\n<details>\n    【解析】C。同时出现编译和解释一定要说明解释更慢，并且值得注意的是**解释是一边‘编译’一边运行的**\n</details>\n\n<hr>\n<p>CPU寄存器相关三题</p>\n<p>1.存放当前执行指令的寄存器是（）。<br>A.MAR  B. PC   C. MDR  D. IR<br>2.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（）。<br>A. PC  B. MAR  C. MDR  D. IR<br>3.CPU不包括（)<br>A.地址寄存器     B.指令寄存器（IR）<br>C.地址译码器     D.通用寄存器</p>\n<details>\n    【解析】BAC\n    IR存放当前执行的指令代码，PC存放下一条指令的地址，不要将它们混淆。此外，MAR用\n来存放待访问的存储单元地址，MDR则用来存放取处存储单元的数据。\n    在CPU中，PC用来跟踪下一条要执行的指令在主存储器中的地址。\n    地址译码器是主存储器的构成部分，不属于CPU。地址寄存器虽然一般属于主存储器，但现\n代计算机中绝大多数CPU内集成了地址寄存器。\n</details>\n---\n\n微程序控制器中，机器指令执行周期微程序的入口地址是由（ ）形成的。\n\nA.微指令的地址码字段\n\nB.微指令的操作码字段\n\nC.机器指令的地址码字段\n\nD.机器指令的操作码字段\n\n<details>\n    【解析】D。\n微程序控制器的工作原理是将每条机器指令分解为一系列更小的步骤，称为微指令。这些微指令被组织在一个控制存储器中，控制存储器中的每个条目都包含执行机器指令所需的微操作序列。机器指令的操作码字段决定了需要执行哪些微操作，因此也就确定了微程序的入口地址。控制存储器会根据操作码来查找对应的微程序序列，并开始执行。\n</details>\n<!-- flag of hidden posts -->","length":1272,"excerpt":"","more":"<p>假设某条指令的一个操作数采用寄存器间接寻址方式，假定指令中给出的寄存器编号<br>02 为 8，8 号寄存器的内容为 1200H，地址 1200H 中的内容为 12FCH，地址 12FCH 中<br>的内容为 38B8H，地址 38B8H 中的内容为 88F9H，则该操作数的有效地址为（）。<br>    A.1200H<br>    B.12FCH<br>    C.38B8H<br>    D.88F9H</p>\n<details>\n<p>\n    【解析】A。\n    采用寄存器间接寻址，指令字中的寄存器给出的不是一个操作数，而是操作数所在的主存单元地址，即 EA =(Ri)，故该操作数的有效地址为 8 号寄存器的内容，即 1200H\n</p>\n</details>\n\n<hr>\n<p>在设备管理中，引人缓冲的主要原因不包括 （ ）。</p>\n<p>A.缓和处理机和外设之间访问速度不匹配的矛盾</p>\n<p>B.缓和处理机和内存之间访问速度不匹配的矛盾</p>\n<p>C.减少对处理机的中断频率，放宽对处理机中断响应时间的限制</p>\n<p>D.提高处理机和外围设备之间的并行性</p>\n<details>\n    <p>\n        【解析】B。\n        缓冲是使用专用硬件缓冲器或在内存中划出一个区域，来暂时存放 I/O 数据的器件。引人缓冲是为了协调速度相差很大的设备之间的数据传输，减少对 CPU 的中断频率，放宽对中断响应时间的限制以及提高 CPU 和 IO 设备之间的并行性。\n    </p>\n</details>\n---\n\n关于相联存储器，下列说法中正确的是（）。\nA.只可以按地址寻址   B.只可以按内容寻址\nC.既可按地址寻址又可按内容寻址 D.以上说法均不完善\n\n<details>\n    【解析】C。\n    有关相联存储器，它既可以按照地址寻址也可按照内容寻址，因此又被称为：内容寻址器\n</details>\n---\n\n下列叙述中，正确的是（）。\nI.实际应用程序的测试结果能够全面代表计算机的性能\nI.系列机的基本特性是指令系统向后兼容\nIII.软件和硬件在逻辑功能上是等价的\nA. II   B. II   c. II和III D. I、II 和 II\n\n<details>\n    【解析】C。\n   全面代表计算机性能的是实际软件的运行情况。向后兼容是指时间上向后兼容，即新机器表\n容使用以前机器的指令系统。软件和硬件在逻辑功能上是等价的，如浮点运算即可以用专门的浮\n点运算器实现，也可以通过编写一段子程序实现。\n</details>\n\n<p>关于编译程序和解释程序，下列说法中错误的是（）。<br>A.编译程序和解释程序的作用都是将高级语言程序转换成机器语言程序<br>B.编译程序编译时间较长，运行速度较快<br>C.解释程序方法较简单，运行速度也较快<br>D.解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句</p>\n<details>\n    【解析】C。同时出现编译和解释一定要说明解释更慢，并且值得注意的是**解释是一边‘编译’一边运行的**\n</details>\n\n<hr>\n<p>CPU寄存器相关三题</p>\n<p>1.存放当前执行指令的寄存器是（）。<br>A.MAR  B. PC   C. MDR  D. IR<br>2.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（）。<br>A. PC  B. MAR  C. MDR  D. IR<br>3.CPU不包括（)<br>A.地址寄存器     B.指令寄存器（IR）<br>C.地址译码器     D.通用寄存器</p>\n<details>\n    【解析】BAC\n    IR存放当前执行的指令代码，PC存放下一条指令的地址，不要将它们混淆。此外，MAR用\n来存放待访问的存储单元地址，MDR则用来存放取处存储单元的数据。\n    在CPU中，PC用来跟踪下一条要执行的指令在主存储器中的地址。\n    地址译码器是主存储器的构成部分，不属于CPU。地址寄存器虽然一般属于主存储器，但现\n代计算机中绝大多数CPU内集成了地址寄存器。\n</details>\n---\n\n微程序控制器中，机器指令执行周期微程序的入口地址是由（ ）形成的。\n\nA.微指令的地址码字段\n\nB.微指令的操作码字段\n\nC.机器指令的地址码字段\n\nD.机器指令的操作码字段\n\n<details>\n    【解析】D。\n微程序控制器的工作原理是将每条机器指令分解为一系列更小的步骤，称为微指令。这些微指令被组织在一个控制存储器中，控制存储器中的每个条目都包含执行机器指令所需的微操作序列。机器指令的操作码字段决定了需要执行哪些微操作，因此也就确定了微程序的入口地址。控制存储器会根据操作码来查找对应的微程序序列，并开始执行。\n</details>\n"},{"_content":"","source":"_posts/special_subject/NationalPGExamination/Politics/NoteForMY.md","raw":"","slug":"special_subject/NationalPGExamination/Politics/NoteForMY","published":1,"date":"2024-08-17T13:01:00.492Z","updated":"2024-07-08T10:23:05.283Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clzy68qq6000am8wvege3gng6","content":"","length":0,"excerpt":"","more":""},{"title":"计组篇-IO接口篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# IO接口当中的寄存器\n\n**数据寄存器（Data Register, DR）**：\n\n- **功能**：数据寄存器用于在CPU和外设之间传递数据。例如，当CPU需要将数据发送到打印机时，数据首先会被写入数据寄存器，然后从数据寄存器传输到打印机。类似地，当从键盘读取数据时，数据会先存储在数据寄存器中，然后由CPU读取。\n- **必要性**：数据寄存器是必需的，因为它们提供了一个临时存储位置，使得CPU和外设可以同步交换数据。没有数据寄存器，数据传输将变得不可靠和复杂。\n\n**状态寄存器（Status Register, SR）**：\n\n- **功能**：状态寄存器保存外设的当前状态信息，例如是否准备好进行数据传输，是否发生了错误，或者是否有数据可供读取。通过检查状态寄存器，CPU可以了解外设的当前状态并采取相应的行动。\n- **必要性**：状态寄存器是必需的，因为它们提供了CPU了解外设状态的途径。这有助于避免错误操作，例如在外设未准备好时尝试读写数据。\n\n**控制寄存器（Control Register, CR）**：\n\n- **功能**：控制寄存器用于配置和控制外设的操作。例如，CPU可以通过控制寄存器启动或停止外设，设置数据传输模式，或者启用中断。控制寄存器可以设置外设的工作模式和参数。\n- **必要性**：控制寄存器是必需的，因为它们允许CPU控制外设的行为，确保外设按照预期的方式工作。没有控制寄存器，CPU将无法灵活地管理和配置外设。\n\n> 地址寄存器在很多情况，**地址寄存器**被视为CPU内部寄存器，用于存储指令执行期间所需的内存地址，而不是专门用于I/O操作。这些地址寄存器可能包括程序计数器（PC）和段寄存器（Segment Registers），它们主要与CPU执行程序有关，而不是直接与I/O接口相关。\n\n# IO接口设备的常见分类\n\n## 接口数据交换约束的分类\n\n**串行接口（Serial Interface）**\n\n- **分类依据**：数据传输格式。\n- **特点**：通过一根或几根数据线一次传输一位数据。\n- **例子**：UART、SPI、I²C、USB。\n\n**并行接口（Parallel Interface）**\n\n- **分类依据**：数据传输格式。\n- **特点**：通过多根数据线同时传输多个位的数据。\n- **例子**：PCI、IDE、Centronics接口。\n\n**同步接口（Synchronous Interface）**\n\n- **分类依据**：数据传输的时序控制。\n- **特点**：在传输数据时使用时钟信号同步发送方和接收方。\n- **例子**：SPI、I²C。\n\n**异步接口（Asynchronous Interface）**\n\n- **分类依据**：数据传输的时序控制。\n- **特点**：在传输数据时不使用时钟信号，依赖起始位和停止位进行同步。\n- **例子**：UART、RS-232。\n\n**全双工接口（Full Duplex Interface）**\n\n- **分类依据**：数据传输的方向性。\n- **特点**：允许同时进行双向数据传输。\n- **例子**：以太网、USB。\n\n**半双工接口（Half Duplex Interface）**\n\n- **分类依据**：数据传输的方向性。\n- **特点**：允许双向数据传输，但不能同时进行，必须分时传输。\n- **例子**：RS-485、CAN总线。\n\n## 接口数据传输格式的分类\n\n**字符（Character-based or Byte-based）传输接口**：\n\n- 这种接口一次传输一个字符或一个字节的数据，常用于低速设备。\n\n- 例子\n\n  ：\n\n  - **UART（Universal Asynchronous Receiver/Transmitter）**：常用于串行通信，一次传输一个字节。\n  - **RS-232**：一种标准的串行通信接口，通常用于串口通信，一次传输一个字节。\n\n**块（Block-based）传输接口**：\n\n- 这种接口一次传输一块数据，通常用于高速设备，可以提高传输效率。\n\n- 例子\n\n  ：\n\n  - **USB（Universal Serial Bus）**：支持块传输，可以一次传输多个字节的数据。\n  - **SATA（Serial ATA）**：用于连接存储设备，支持块传输。\n\n**流（Stream-based）传输接口**：\n\n- 这种接口以连续的流形式传输数据，通常用于音频、视频等连续数据的传输。\n\n- 例子\n\n  ：\n\n  - **TCP/IP**：用于网络通信的传输协议，支持流数据传输。\n  - **FireWire（IEEE 1394）**：一种高速串行接口，支持流数据传输，常用于视频设备。\n\n**消息（Message-based）传输接口**：\n\n- 这种接口以消息的形式传输数据，每个消息包含一个数据包和相关的控制信息。\n\n- 例子\n\n  ：\n\n  - **CAN（Controller Area Network）**：用于汽车和工业自动化中的网络，支持消息传输。\n  - **Zigbee**：一种无线通信协议，常用于物联网设备，支持消息传输。","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/IO.md","raw":"---\ntitle: 计组篇-IO接口篇\ndate: 2024-08-14 19:47:58\ntags: [计算机组成原理, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# IO接口当中的寄存器\n\n**数据寄存器（Data Register, DR）**：\n\n- **功能**：数据寄存器用于在CPU和外设之间传递数据。例如，当CPU需要将数据发送到打印机时，数据首先会被写入数据寄存器，然后从数据寄存器传输到打印机。类似地，当从键盘读取数据时，数据会先存储在数据寄存器中，然后由CPU读取。\n- **必要性**：数据寄存器是必需的，因为它们提供了一个临时存储位置，使得CPU和外设可以同步交换数据。没有数据寄存器，数据传输将变得不可靠和复杂。\n\n**状态寄存器（Status Register, SR）**：\n\n- **功能**：状态寄存器保存外设的当前状态信息，例如是否准备好进行数据传输，是否发生了错误，或者是否有数据可供读取。通过检查状态寄存器，CPU可以了解外设的当前状态并采取相应的行动。\n- **必要性**：状态寄存器是必需的，因为它们提供了CPU了解外设状态的途径。这有助于避免错误操作，例如在外设未准备好时尝试读写数据。\n\n**控制寄存器（Control Register, CR）**：\n\n- **功能**：控制寄存器用于配置和控制外设的操作。例如，CPU可以通过控制寄存器启动或停止外设，设置数据传输模式，或者启用中断。控制寄存器可以设置外设的工作模式和参数。\n- **必要性**：控制寄存器是必需的，因为它们允许CPU控制外设的行为，确保外设按照预期的方式工作。没有控制寄存器，CPU将无法灵活地管理和配置外设。\n\n> 地址寄存器在很多情况，**地址寄存器**被视为CPU内部寄存器，用于存储指令执行期间所需的内存地址，而不是专门用于I/O操作。这些地址寄存器可能包括程序计数器（PC）和段寄存器（Segment Registers），它们主要与CPU执行程序有关，而不是直接与I/O接口相关。\n\n# IO接口设备的常见分类\n\n## 接口数据交换约束的分类\n\n**串行接口（Serial Interface）**\n\n- **分类依据**：数据传输格式。\n- **特点**：通过一根或几根数据线一次传输一位数据。\n- **例子**：UART、SPI、I²C、USB。\n\n**并行接口（Parallel Interface）**\n\n- **分类依据**：数据传输格式。\n- **特点**：通过多根数据线同时传输多个位的数据。\n- **例子**：PCI、IDE、Centronics接口。\n\n**同步接口（Synchronous Interface）**\n\n- **分类依据**：数据传输的时序控制。\n- **特点**：在传输数据时使用时钟信号同步发送方和接收方。\n- **例子**：SPI、I²C。\n\n**异步接口（Asynchronous Interface）**\n\n- **分类依据**：数据传输的时序控制。\n- **特点**：在传输数据时不使用时钟信号，依赖起始位和停止位进行同步。\n- **例子**：UART、RS-232。\n\n**全双工接口（Full Duplex Interface）**\n\n- **分类依据**：数据传输的方向性。\n- **特点**：允许同时进行双向数据传输。\n- **例子**：以太网、USB。\n\n**半双工接口（Half Duplex Interface）**\n\n- **分类依据**：数据传输的方向性。\n- **特点**：允许双向数据传输，但不能同时进行，必须分时传输。\n- **例子**：RS-485、CAN总线。\n\n## 接口数据传输格式的分类\n\n**字符（Character-based or Byte-based）传输接口**：\n\n- 这种接口一次传输一个字符或一个字节的数据，常用于低速设备。\n\n- 例子\n\n  ：\n\n  - **UART（Universal Asynchronous Receiver/Transmitter）**：常用于串行通信，一次传输一个字节。\n  - **RS-232**：一种标准的串行通信接口，通常用于串口通信，一次传输一个字节。\n\n**块（Block-based）传输接口**：\n\n- 这种接口一次传输一块数据，通常用于高速设备，可以提高传输效率。\n\n- 例子\n\n  ：\n\n  - **USB（Universal Serial Bus）**：支持块传输，可以一次传输多个字节的数据。\n  - **SATA（Serial ATA）**：用于连接存储设备，支持块传输。\n\n**流（Stream-based）传输接口**：\n\n- 这种接口以连续的流形式传输数据，通常用于音频、视频等连续数据的传输。\n\n- 例子\n\n  ：\n\n  - **TCP/IP**：用于网络通信的传输协议，支持流数据传输。\n  - **FireWire（IEEE 1394）**：一种高速串行接口，支持流数据传输，常用于视频设备。\n\n**消息（Message-based）传输接口**：\n\n- 这种接口以消息的形式传输数据，每个消息包含一个数据包和相关的控制信息。\n\n- 例子\n\n  ：\n\n  - **CAN（Controller Area Network）**：用于汽车和工业自动化中的网络，支持消息传输。\n  - **Zigbee**：一种无线通信协议，常用于物联网设备，支持消息传输。","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/IO","published":1,"updated":"2024-08-17T13:21:37.125Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qq7000dm8wvcevb1k37","content":"<h1 id=\"IO接口当中的寄存器\"><a href=\"#IO接口当中的寄存器\" class=\"headerlink\" title=\"IO接口当中的寄存器\"></a>IO接口当中的寄存器</h1><p><strong>数据寄存器（Data Register, DR）</strong>：</p>\n<ul>\n<li><strong>功能</strong>：数据寄存器用于在CPU和外设之间传递数据。例如，当CPU需要将数据发送到打印机时，数据首先会被写入数据寄存器，然后从数据寄存器传输到打印机。类似地，当从键盘读取数据时，数据会先存储在数据寄存器中，然后由CPU读取。</li>\n<li><strong>必要性</strong>：数据寄存器是必需的，因为它们提供了一个临时存储位置，使得CPU和外设可以同步交换数据。没有数据寄存器，数据传输将变得不可靠和复杂。</li>\n</ul>\n<p><strong>状态寄存器（Status Register, SR）</strong>：</p>\n<ul>\n<li><strong>功能</strong>：状态寄存器保存外设的当前状态信息，例如是否准备好进行数据传输，是否发生了错误，或者是否有数据可供读取。通过检查状态寄存器，CPU可以了解外设的当前状态并采取相应的行动。</li>\n<li><strong>必要性</strong>：状态寄存器是必需的，因为它们提供了CPU了解外设状态的途径。这有助于避免错误操作，例如在外设未准备好时尝试读写数据。</li>\n</ul>\n<p><strong>控制寄存器（Control Register, CR）</strong>：</p>\n<ul>\n<li><strong>功能</strong>：控制寄存器用于配置和控制外设的操作。例如，CPU可以通过控制寄存器启动或停止外设，设置数据传输模式，或者启用中断。控制寄存器可以设置外设的工作模式和参数。</li>\n<li><strong>必要性</strong>：控制寄存器是必需的，因为它们允许CPU控制外设的行为，确保外设按照预期的方式工作。没有控制寄存器，CPU将无法灵活地管理和配置外设。</li>\n</ul>\n<blockquote>\n<p>地址寄存器在很多情况，<strong>地址寄存器</strong>被视为CPU内部寄存器，用于存储指令执行期间所需的内存地址，而不是专门用于I/O操作。这些地址寄存器可能包括程序计数器（PC）和段寄存器（Segment Registers），它们主要与CPU执行程序有关，而不是直接与I/O接口相关。</p>\n</blockquote>\n<h1 id=\"IO接口设备的常见分类\"><a href=\"#IO接口设备的常见分类\" class=\"headerlink\" title=\"IO接口设备的常见分类\"></a>IO接口设备的常见分类</h1><h2 id=\"接口数据交换约束的分类\"><a href=\"#接口数据交换约束的分类\" class=\"headerlink\" title=\"接口数据交换约束的分类\"></a>接口数据交换约束的分类</h2><p><strong>串行接口（Serial Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输格式。</li>\n<li><strong>特点</strong>：通过一根或几根数据线一次传输一位数据。</li>\n<li><strong>例子</strong>：UART、SPI、I²C、USB。</li>\n</ul>\n<p><strong>并行接口（Parallel Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输格式。</li>\n<li><strong>特点</strong>：通过多根数据线同时传输多个位的数据。</li>\n<li><strong>例子</strong>：PCI、IDE、Centronics接口。</li>\n</ul>\n<p><strong>同步接口（Synchronous Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输的时序控制。</li>\n<li><strong>特点</strong>：在传输数据时使用时钟信号同步发送方和接收方。</li>\n<li><strong>例子</strong>：SPI、I²C。</li>\n</ul>\n<p><strong>异步接口（Asynchronous Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输的时序控制。</li>\n<li><strong>特点</strong>：在传输数据时不使用时钟信号，依赖起始位和停止位进行同步。</li>\n<li><strong>例子</strong>：UART、RS-232。</li>\n</ul>\n<p><strong>全双工接口（Full Duplex Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输的方向性。</li>\n<li><strong>特点</strong>：允许同时进行双向数据传输。</li>\n<li><strong>例子</strong>：以太网、USB。</li>\n</ul>\n<p><strong>半双工接口（Half Duplex Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输的方向性。</li>\n<li><strong>特点</strong>：允许双向数据传输，但不能同时进行，必须分时传输。</li>\n<li><strong>例子</strong>：RS-485、CAN总线。</li>\n</ul>\n<h2 id=\"接口数据传输格式的分类\"><a href=\"#接口数据传输格式的分类\" class=\"headerlink\" title=\"接口数据传输格式的分类\"></a>接口数据传输格式的分类</h2><p><strong>字符（Character-based or Byte-based）传输接口</strong>：</p>\n<ul>\n<li><p>这种接口一次传输一个字符或一个字节的数据，常用于低速设备。</p>\n</li>\n<li><p>例子</p>\n<p>：</p>\n<ul>\n<li><strong>UART（Universal Asynchronous Receiver/Transmitter）</strong>：常用于串行通信，一次传输一个字节。</li>\n<li><strong>RS-232</strong>：一种标准的串行通信接口，通常用于串口通信，一次传输一个字节。</li>\n</ul>\n</li>\n</ul>\n<p><strong>块（Block-based）传输接口</strong>：</p>\n<ul>\n<li><p>这种接口一次传输一块数据，通常用于高速设备，可以提高传输效率。</p>\n</li>\n<li><p>例子</p>\n<p>：</p>\n<ul>\n<li><strong>USB（Universal Serial Bus）</strong>：支持块传输，可以一次传输多个字节的数据。</li>\n<li><strong>SATA（Serial ATA）</strong>：用于连接存储设备，支持块传输。</li>\n</ul>\n</li>\n</ul>\n<p><strong>流（Stream-based）传输接口</strong>：</p>\n<ul>\n<li><p>这种接口以连续的流形式传输数据，通常用于音频、视频等连续数据的传输。</p>\n</li>\n<li><p>例子</p>\n<p>：</p>\n<ul>\n<li><strong>TCP/IP</strong>：用于网络通信的传输协议，支持流数据传输。</li>\n<li><strong>FireWire（IEEE 1394）</strong>：一种高速串行接口，支持流数据传输，常用于视频设备。</li>\n</ul>\n</li>\n</ul>\n<p><strong>消息（Message-based）传输接口</strong>：</p>\n<ul>\n<li><p>这种接口以消息的形式传输数据，每个消息包含一个数据包和相关的控制信息。</p>\n</li>\n<li><p>例子</p>\n<p>：</p>\n<ul>\n<li><strong>CAN（Controller Area Network）</strong>：用于汽车和工业自动化中的网络，支持消息传输。</li>\n<li><strong>Zigbee</strong>：一种无线通信协议，常用于物联网设备，支持消息传输。</li>\n</ul>\n</li>\n</ul>\n<!-- flag of hidden posts -->","length":1199,"excerpt":"","more":"<h1 id=\"IO接口当中的寄存器\"><a href=\"#IO接口当中的寄存器\" class=\"headerlink\" title=\"IO接口当中的寄存器\"></a>IO接口当中的寄存器</h1><p><strong>数据寄存器（Data Register, DR）</strong>：</p>\n<ul>\n<li><strong>功能</strong>：数据寄存器用于在CPU和外设之间传递数据。例如，当CPU需要将数据发送到打印机时，数据首先会被写入数据寄存器，然后从数据寄存器传输到打印机。类似地，当从键盘读取数据时，数据会先存储在数据寄存器中，然后由CPU读取。</li>\n<li><strong>必要性</strong>：数据寄存器是必需的，因为它们提供了一个临时存储位置，使得CPU和外设可以同步交换数据。没有数据寄存器，数据传输将变得不可靠和复杂。</li>\n</ul>\n<p><strong>状态寄存器（Status Register, SR）</strong>：</p>\n<ul>\n<li><strong>功能</strong>：状态寄存器保存外设的当前状态信息，例如是否准备好进行数据传输，是否发生了错误，或者是否有数据可供读取。通过检查状态寄存器，CPU可以了解外设的当前状态并采取相应的行动。</li>\n<li><strong>必要性</strong>：状态寄存器是必需的，因为它们提供了CPU了解外设状态的途径。这有助于避免错误操作，例如在外设未准备好时尝试读写数据。</li>\n</ul>\n<p><strong>控制寄存器（Control Register, CR）</strong>：</p>\n<ul>\n<li><strong>功能</strong>：控制寄存器用于配置和控制外设的操作。例如，CPU可以通过控制寄存器启动或停止外设，设置数据传输模式，或者启用中断。控制寄存器可以设置外设的工作模式和参数。</li>\n<li><strong>必要性</strong>：控制寄存器是必需的，因为它们允许CPU控制外设的行为，确保外设按照预期的方式工作。没有控制寄存器，CPU将无法灵活地管理和配置外设。</li>\n</ul>\n<blockquote>\n<p>地址寄存器在很多情况，<strong>地址寄存器</strong>被视为CPU内部寄存器，用于存储指令执行期间所需的内存地址，而不是专门用于I/O操作。这些地址寄存器可能包括程序计数器（PC）和段寄存器（Segment Registers），它们主要与CPU执行程序有关，而不是直接与I/O接口相关。</p>\n</blockquote>\n<h1 id=\"IO接口设备的常见分类\"><a href=\"#IO接口设备的常见分类\" class=\"headerlink\" title=\"IO接口设备的常见分类\"></a>IO接口设备的常见分类</h1><h2 id=\"接口数据交换约束的分类\"><a href=\"#接口数据交换约束的分类\" class=\"headerlink\" title=\"接口数据交换约束的分类\"></a>接口数据交换约束的分类</h2><p><strong>串行接口（Serial Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输格式。</li>\n<li><strong>特点</strong>：通过一根或几根数据线一次传输一位数据。</li>\n<li><strong>例子</strong>：UART、SPI、I²C、USB。</li>\n</ul>\n<p><strong>并行接口（Parallel Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输格式。</li>\n<li><strong>特点</strong>：通过多根数据线同时传输多个位的数据。</li>\n<li><strong>例子</strong>：PCI、IDE、Centronics接口。</li>\n</ul>\n<p><strong>同步接口（Synchronous Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输的时序控制。</li>\n<li><strong>特点</strong>：在传输数据时使用时钟信号同步发送方和接收方。</li>\n<li><strong>例子</strong>：SPI、I²C。</li>\n</ul>\n<p><strong>异步接口（Asynchronous Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输的时序控制。</li>\n<li><strong>特点</strong>：在传输数据时不使用时钟信号，依赖起始位和停止位进行同步。</li>\n<li><strong>例子</strong>：UART、RS-232。</li>\n</ul>\n<p><strong>全双工接口（Full Duplex Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输的方向性。</li>\n<li><strong>特点</strong>：允许同时进行双向数据传输。</li>\n<li><strong>例子</strong>：以太网、USB。</li>\n</ul>\n<p><strong>半双工接口（Half Duplex Interface）</strong></p>\n<ul>\n<li><strong>分类依据</strong>：数据传输的方向性。</li>\n<li><strong>特点</strong>：允许双向数据传输，但不能同时进行，必须分时传输。</li>\n<li><strong>例子</strong>：RS-485、CAN总线。</li>\n</ul>\n<h2 id=\"接口数据传输格式的分类\"><a href=\"#接口数据传输格式的分类\" class=\"headerlink\" title=\"接口数据传输格式的分类\"></a>接口数据传输格式的分类</h2><p><strong>字符（Character-based or Byte-based）传输接口</strong>：</p>\n<ul>\n<li><p>这种接口一次传输一个字符或一个字节的数据，常用于低速设备。</p>\n</li>\n<li><p>例子</p>\n<p>：</p>\n<ul>\n<li><strong>UART（Universal Asynchronous Receiver/Transmitter）</strong>：常用于串行通信，一次传输一个字节。</li>\n<li><strong>RS-232</strong>：一种标准的串行通信接口，通常用于串口通信，一次传输一个字节。</li>\n</ul>\n</li>\n</ul>\n<p><strong>块（Block-based）传输接口</strong>：</p>\n<ul>\n<li><p>这种接口一次传输一块数据，通常用于高速设备，可以提高传输效率。</p>\n</li>\n<li><p>例子</p>\n<p>：</p>\n<ul>\n<li><strong>USB（Universal Serial Bus）</strong>：支持块传输，可以一次传输多个字节的数据。</li>\n<li><strong>SATA（Serial ATA）</strong>：用于连接存储设备，支持块传输。</li>\n</ul>\n</li>\n</ul>\n<p><strong>流（Stream-based）传输接口</strong>：</p>\n<ul>\n<li><p>这种接口以连续的流形式传输数据，通常用于音频、视频等连续数据的传输。</p>\n</li>\n<li><p>例子</p>\n<p>：</p>\n<ul>\n<li><strong>TCP/IP</strong>：用于网络通信的传输协议，支持流数据传输。</li>\n<li><strong>FireWire（IEEE 1394）</strong>：一种高速串行接口，支持流数据传输，常用于视频设备。</li>\n</ul>\n</li>\n</ul>\n<p><strong>消息（Message-based）传输接口</strong>：</p>\n<ul>\n<li><p>这种接口以消息的形式传输数据，每个消息包含一个数据包和相关的控制信息。</p>\n</li>\n<li><p>例子</p>\n<p>：</p>\n<ul>\n<li><strong>CAN（Controller Area Network）</strong>：用于汽车和工业自动化中的网络，支持消息传输。</li>\n<li><strong>Zigbee</strong>：一种无线通信协议，常用于物联网设备，支持消息传输。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"计组篇-硬件篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"![计算机硬件总览](https://s2.loli.net/2024/07/16/5X38RE1wmzks2LV.png)\n\n## 控制器\n\n按照实现方式划分为\n\n1. 硬线控制布局\n2. 微程序控制布局\n\n## 存储器\n\n### 存储器的组成部分\n\nMAR（Memory Address Register 存储地址寄存器）\n\nMDR（Memory Data Register 存储数据寄存器）\n\n![存储器](https://s2.loli.net/2024/07/16/hti5mp7SBqGoAfW.png)\n\n## 运算器\n\n![总览图](https://s2.loli.net/2024/07/21/zoFkcqC5dxtejXy.png)\n\nACC（Accumulator 累加器）：累加器，用于存放操作数，或运算结果。\nMQ: (Mutiple-Quotient Register乘商寄存器):在乘、除运算时，用于存放操作数或运算结果。\nX： 通用的操作数寄存器，用于存放操作数\nALU:(Arithmetic and Logic Unit 算术逻辑单元): 通过内部复杂的电路实现算数运算、逻辑运算\n\n![运算器组成的比较](https://s2.loli.net/2024/07/21/9uf4zSVIFBKEqdi.png)\n\n## 控制器的基本组成\n\n![总览图](https://s2.loli.net/2024/07/21/vuH2Q1ENR4iJnW6.png)\n\nCU（Control Unit）：控制单元，分析指令，；给出控制信号\nIR （Instrument Resiger）：指令寄存器，存放当前执行的指令\nPC (Process Counter)：程序计数器，存放下一条指令地址，有自动加1功能","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/各个硬件及其相关工作原理.md","raw":"---\ntitle: 计组篇-硬件篇\ndate: 2024-08-14 19:47:58\ntags: [计算机组成原理, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n![计算机硬件总览](https://s2.loli.net/2024/07/16/5X38RE1wmzks2LV.png)\n\n## 控制器\n\n按照实现方式划分为\n\n1. 硬线控制布局\n2. 微程序控制布局\n\n## 存储器\n\n### 存储器的组成部分\n\nMAR（Memory Address Register 存储地址寄存器）\n\nMDR（Memory Data Register 存储数据寄存器）\n\n![存储器](https://s2.loli.net/2024/07/16/hti5mp7SBqGoAfW.png)\n\n## 运算器\n\n![总览图](https://s2.loli.net/2024/07/21/zoFkcqC5dxtejXy.png)\n\nACC（Accumulator 累加器）：累加器，用于存放操作数，或运算结果。\nMQ: (Mutiple-Quotient Register乘商寄存器):在乘、除运算时，用于存放操作数或运算结果。\nX： 通用的操作数寄存器，用于存放操作数\nALU:(Arithmetic and Logic Unit 算术逻辑单元): 通过内部复杂的电路实现算数运算、逻辑运算\n\n![运算器组成的比较](https://s2.loli.net/2024/07/21/9uf4zSVIFBKEqdi.png)\n\n## 控制器的基本组成\n\n![总览图](https://s2.loli.net/2024/07/21/vuH2Q1ENR4iJnW6.png)\n\nCU（Control Unit）：控制单元，分析指令，；给出控制信号\nIR （Instrument Resiger）：指令寄存器，存放当前执行的指令\nPC (Process Counter)：程序计数器，存放下一条指令地址，有自动加1功能","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/各个硬件及其相关工作原理","published":1,"updated":"2024-08-17T13:21:48.999Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qq7000em8wvc54rf8yc","content":"<p><img src=\"https://s2.loli.net/2024/07/16/5X38RE1wmzks2LV.png\" alt=\"计算机硬件总览\"></p>\n<h2 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h2><p>按照实现方式划分为</p>\n<ol>\n<li>硬线控制布局</li>\n<li>微程序控制布局</li>\n</ol>\n<h2 id=\"存储器\"><a href=\"#存储器\" class=\"headerlink\" title=\"存储器\"></a>存储器</h2><h3 id=\"存储器的组成部分\"><a href=\"#存储器的组成部分\" class=\"headerlink\" title=\"存储器的组成部分\"></a>存储器的组成部分</h3><p>MAR（Memory Address Register 存储地址寄存器）</p>\n<p>MDR（Memory Data Register 存储数据寄存器）</p>\n<p><img src=\"https://s2.loli.net/2024/07/16/hti5mp7SBqGoAfW.png\" alt=\"存储器\"></p>\n<h2 id=\"运算器\"><a href=\"#运算器\" class=\"headerlink\" title=\"运算器\"></a>运算器</h2><p><img src=\"https://s2.loli.net/2024/07/21/zoFkcqC5dxtejXy.png\" alt=\"总览图\"></p>\n<p>ACC（Accumulator 累加器）：累加器，用于存放操作数，或运算结果。<br>MQ: (Mutiple-Quotient Register乘商寄存器):在乘、除运算时，用于存放操作数或运算结果。<br>X： 通用的操作数寄存器，用于存放操作数<br>ALU:(Arithmetic and Logic Unit 算术逻辑单元): 通过内部复杂的电路实现算数运算、逻辑运算</p>\n<p><img src=\"https://s2.loli.net/2024/07/21/9uf4zSVIFBKEqdi.png\" alt=\"运算器组成的比较\"></p>\n<h2 id=\"控制器的基本组成\"><a href=\"#控制器的基本组成\" class=\"headerlink\" title=\"控制器的基本组成\"></a>控制器的基本组成</h2><p><img src=\"https://s2.loli.net/2024/07/21/vuH2Q1ENR4iJnW6.png\" alt=\"总览图\"></p>\n<p>CU（Control Unit）：控制单元，分析指令，；给出控制信号<br>IR （Instrument Resiger）：指令寄存器，存放当前执行的指令<br>PC (Process Counter)：程序计数器，存放下一条指令地址，有自动加1功能</p>\n<!-- flag of hidden posts -->","length":247,"excerpt":"","more":"<p><img src=\"https://s2.loli.net/2024/07/16/5X38RE1wmzks2LV.png\" alt=\"计算机硬件总览\"></p>\n<h2 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h2><p>按照实现方式划分为</p>\n<ol>\n<li>硬线控制布局</li>\n<li>微程序控制布局</li>\n</ol>\n<h2 id=\"存储器\"><a href=\"#存储器\" class=\"headerlink\" title=\"存储器\"></a>存储器</h2><h3 id=\"存储器的组成部分\"><a href=\"#存储器的组成部分\" class=\"headerlink\" title=\"存储器的组成部分\"></a>存储器的组成部分</h3><p>MAR（Memory Address Register 存储地址寄存器）</p>\n<p>MDR（Memory Data Register 存储数据寄存器）</p>\n<p><img src=\"https://s2.loli.net/2024/07/16/hti5mp7SBqGoAfW.png\" alt=\"存储器\"></p>\n<h2 id=\"运算器\"><a href=\"#运算器\" class=\"headerlink\" title=\"运算器\"></a>运算器</h2><p><img src=\"https://s2.loli.net/2024/07/21/zoFkcqC5dxtejXy.png\" alt=\"总览图\"></p>\n<p>ACC（Accumulator 累加器）：累加器，用于存放操作数，或运算结果。<br>MQ: (Mutiple-Quotient Register乘商寄存器):在乘、除运算时，用于存放操作数或运算结果。<br>X： 通用的操作数寄存器，用于存放操作数<br>ALU:(Arithmetic and Logic Unit 算术逻辑单元): 通过内部复杂的电路实现算数运算、逻辑运算</p>\n<p><img src=\"https://s2.loli.net/2024/07/21/9uf4zSVIFBKEqdi.png\" alt=\"运算器组成的比较\"></p>\n<h2 id=\"控制器的基本组成\"><a href=\"#控制器的基本组成\" class=\"headerlink\" title=\"控制器的基本组成\"></a>控制器的基本组成</h2><p><img src=\"https://s2.loli.net/2024/07/21/vuH2Q1ENR4iJnW6.png\" alt=\"总览图\"></p>\n<p>CU（Control Unit）：控制单元，分析指令，；给出控制信号<br>IR （Instrument Resiger）：指令寄存器，存放当前执行的指令<br>PC (Process Counter)：程序计数器，存放下一条指令地址，有自动加1功能</p>\n"},{"title":"计组篇-存储系统篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# 第三章、存储系统\n\n## 对存储器的分类\n\n- 按在计算机中的层次分\n  - 主存储器\n  - 辅助存储器\n  - 高速缓冲存储器（高速 Cache）\n- 按存储介质分\n  - 半导体存储器（TTL、CMOS） **易失** 性存储器\n  - 磁表面存储器 （磁头，载磁体） **非易失** 性存储器\n  - 磁芯存储器 （硬磁材料、环状元件） **非易失** 性存储器\n  - 光盘存储器 （激光、磁光材料）**非易失** 性存储器\n- 按存取方式分类\n  - 存取时间与物理地址无关（随机访问）\n    - 随机存储器  在程序的执行过程中 **可读可写**\n    - 只读存储器 在程序的执行过程中 **只读**\n  - 存取时间与物理地址有关（串行访问）\n    - 顺序存取存储器    磁带\n    - 直接存取存储器    磁盘\n- 按信息的可保存性分类\n  - 易失性存储器\n  - 非易失性存储器\n  - 破坏性读出\n  - 非破坏性读出\n\n### 存储器的性能指标\n\n目标：**大容量、低成本、高速度**\n\n- 存储容量\n- 存储速度 \n  - 存取时间 \n  - 存取周期 \n  - 主存带宽 \n- 单位成本\n\n![存取时间与存取周期的关系](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725132223932.png)\n\n### 存储器的层次结构\n\n![层次结构](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725133021624.png)\n\n## SRAM 与 DRAM（主存储器）\n\n### SRAM 与 DRAM\n\n主存储器 **由 DRAM 实现**，**靠处理器的那一层(Cache)则由 SRAM 实现**，它们都属于 **易失性存储器**，只要电源被切断，原来保存的信息便会丢失。**DRAM 的每位价格低于 SRAM，速度也慢于 SRAM**，价格差异主要是因为制造 SRAM 需要更多的硅。ROM 属于非易失性存储器。\n\nStatic random-access memory and Dynamic random-access memory\n\n### 主存储器的构成与两者基本性质\n\n主存储器 **由 DRAM 实现**，**靠处理器的那一层(Cache)则由 SRAM 实现**，它们都属于 **易失性存储器**，只要电源被切断，原来保存的信息便会丢失。**DRAM 的每位价格低于 SRAM，速度也慢于 SRAM**，价格差异主要是因为制造 SRAM 需要更多的硅。**ROM 属于非易失性存储器**。\n\n### DRAM 的工作原理\n\n与 SRAM 的存储原理不同，动态随机存储器（DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的，**DRAM 的基本存储元通常只使用一个晶体管**，所以它比 SRAM 的密度要高很 多。相对于 SRAM 来说，**DRAM 具有容易集成、位价低、容量大和功耗低等优点**，但 DRAM 的 **存取速度比 SRAM 的慢**，一般用于大容量的主存系统 DRAM 电容上的电荷一般只能维持 1~2ms，因此即使电源不断电，信息也会自动消失。为此， 每隔一定时间必须 **刷新，通常取 2ms**，称为 **刷新周期**。常用的刷新方式有 3 种 \n\n- **集中刷新**: 指在一个刷新周期内，利用一段固定的时间, 依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区 \"。**优点是读写操作时不受刷新工作的影响; 缺点是在集中刷新期间（死区）不能访问存储器**。\n- **分散刷新**: 把对每行的刷新分散到各个工作周期中。这样一个存储器的系统工作周期分为两 部分: 前半部分用于正常读、写或保持; 后半部分用于刷新。这种刷新方式增加了系统的存 取周期，如存储芯片的存取周期为 0.5us，则系统的存取周期为 1us。**优点是没有死区; 缺点是加长了系统的存取周期, 降低了整机的速度**\n- **异步刷新**: 异步刷新是前两种方法的结合，它既可缩短“死时间”，又能充分利用最大刷新 间隔为 2ms 的特点。具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔 t，利用逻辑电路每隔时间 t 产生一次刷新请求。这样可以避免使 CPU 连续等待过长的时间， 而且减少了刷新次数，从根本上提高了整机的工作效率。\n\nDRAM 的刷新需注意以下问题:\n\n1. 刷新对 CPU 是透明的，即刷新不依赖于外部访问;\n2. DRAM 的 **刷新单位是行**，由芯片内部自行生成行地址; 刷新操作类似于读操作，但又有所不同。 另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。\n\n![DRAM 的读周期时序图](https://s2.loli.net/2024/07/25/MQT2AwpzFDWjcqY.png)\n\n\n\n### SRAM 与 DRAM 的比较\n\n![SRAM 与 DRAM 的比较](https://s2.loli.net/2024/07/25/3o7nQ5J4xftvWug.png)\n\n![SRAM与DRAM的比较](https://s2.loli.net/2024/07/25/RnobEUTscQkmLiZ.png)\n\n### 存储器芯片的内部结构\n\n![存储器芯片的内部结构](https://s2.loli.net/2024/07/25/sxaK7kA8pyrq5Yn.png)\n\n- **存储体（存储矩阵)**。存储体是存储单元的集合， 它由 **行选择线(X）和列选择线(Y)来选择所访问单元**，存储体的相同行、列上的位同时被读出或写入。\n- **地址译码器。** 用来将地址转换为译码输出线上的 高电平，以便驱动相应的读写电路。IO 控制电路。 用以控制被选中的单元的读出或写入，**具有放大信息的作用**。\n- **片选控制信号。** 单个芯片容量太小，往往满足不 了计算机对存储器容量的要求，因此需用一定数量的芯片进行存储器的扩展。在访问某个字时， 必须 **“选中”该存储字所在的芯片**，而 **其他芯片 不被“选中”**，因此需要有片选控制信号。\n\n## 只读存储器\n\n### ROM 的类型\n\n根据制造工艺的不同，ROM 可分为 **掩模式只读存储器（MROM)**、**一次可编程只读存储器(PROM)**、**可擦除可编程只读存储器（EPROM)**、**Flash 有储器** 和 **固态硬盘 SSD**。\n\n- 掩模式只读存储器（MROM Mask Read-Only Memory)：MROM 的内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写 入 **写入以后任何人都无法改变其内容**。优点是可靠性高, 集成度高，价格便宜; 缺点是灵活性差。\n- 一次可编程只读存储器（PROM Programmable ROM）：允许用户 利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变。\n- 可擦除可编程只读存储器（EPROM Erasable Programmable ROM）：EPROM 不仅可以 **由用户利用编程器写入信息，而且可以对其内容进行多次改写**。 EPROM 虽然既可读又可写，但它不能取代 RAM，因为 EPROM 的 **编程次数有限，且写入时间过长**。\n- Flash 存储器：Flash 存储器是在 EPROM 与 EPROM 的基础上发展起来的，其主要特点是既可在不加电的 情况下长期保存信息，又能在线进行快速擦除与重写。**Flash 存储器既有 EPROM 的价格 便宜、集成度高的优点，又有 EPROM 电可擦除重写的特点，且擦除重写的速度快**。\n- 固态硬盘（Solid State Drives，SSD)：基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元 (Flash 芯片）组成。保留了 Flash 存储器 **长期保存信息、快速擦除与重写** 的特性。对比传 统硬盘也具有 **读写速度快、低功耗的特性, 缺点是价格较高**。\n\n## 主存储器\n\n### 基本构成\n\n![主存储器基本构成图](https://s2.loli.net/2024/07/25/J5MVyIFiZHDUtWm.png)\n\n​\t指令执行过程中需要访问主存时，**CPU 首先把被访问单元的地址送到 MAR 中**，然后 **通过地址线将主存地址送到主存中的地址寄存器**，以便地址译码器进行译码选中相应单元，**同时 CPU 将读写信号通过控制线送到主存的读写控制电路。如果是写操作，那么 CPU 同时将要写的信 息送到 MDR 中，在读写控制电路的控制经数据线将信号写入选中的单元，如果是读操作，那 么主存读出选中单元的内容送到数据线，然后送到 MDR 中**。**数据线的宽度与 MDR 的宽度相 同，地址线的宽度与 MAR 的宽度相同。**\n\n​\t图采用 64 位数据线, 所以在按字节编址方式下，每 次最多可以存取 8 个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。例 如，36 位地址的最大寻址范围为 0~2^36-1，即地址从 0 开始编号。DRAM 芯片容量较大，地址位数较多，**为了减少芯片的地址引脚数，通常采用地址引脚复用技术，行地址和列地址通 过相同的引脚分先后两次输入这样地址引脚数可减少一半**。\n\n### 多模块存储器\n\n1. 单体多字存储器\n\n   单体多字系统的特点是 **存储器中只有一个存储体**，每个存储单元存储 m 个字，总线宽度也为 m 个字。一次并行读出 m 个字，地址必须顺序排列并处于同一存储单元。 单体多字系统在一个存取周期内，从同一地址取出 m 条指令，然后将指令逐条送至 CPU 执 行，即每隔 1/m 存取周期，CPU 向主存取一条指令。这显然提高了单体存储器的工作速度。 缺点: **指令和数据在主存内必须是连续存放的**，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显。\n\n2. 多体并行存储器\n\n   多体并行存储器 **由多体模块组成**。每个模块都有相同的容量和存取速度，各模块都有独立 的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。 多体并行存储器分为 **高位交叉编址和低位交叉编址两种。**\n\n   1. 高位交叉编址（顺序方式)**高位地址表示体号，低位地址为体内地址**。如图所示， 存储器共有 4 个模块 M0~M3,, 每个模块有 n 个单元, 各模块的地址范围如图中所示。\n\n      ![高位交叉编址的多体寄存器](https://s2.loli.net/2024/07/25/koL79yOQ236aDBV.png)\n\n      高位交叉方式下，**总是把低位的体内地址送到由高位体号确定的模块内进行译码**。访问一个 连续主存块时，**总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问**，CPU **总是按顺序访问存储模块，各模块不能被并行访问待因而不能提高存储器的吞吐率**\n\n   2. 低位交叉编址（交叉方式)． **低位地址为体号，高位地址为体内地址**。如图所示，每个 模块按“模 m”交叉编址，模块号 = 单元地址%m，假定有 m 个模块，每个模块有 k 个单元， 则 0，m,…, (k -1)m 单元位于 M; 第 1, m+ 1,…, (k -1)m+1 单元位于 M; 以此类推。\n\n      ![低位交叉编址的多体存储器](https://s2.loli.net/2024/07/25/olqgfhEKPAV8uvD.png)\n\n      低位交叉方式下，总是把 **高位的体内地址送到由低位体号确定的模块内进行译码**。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。采用低位交叉编址后， 可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。 设模块字长等于数据总线宽度，模块存取一个字的存取周期为 T，总线传送周期为 r，为实现 流水线方式存取，存储器交叉模块数应大于等于\n      $$\n      m = T/r\n      $$\n      式中，m 称为交叉存取度。每经过 r 时间延迟后启动下一个模块，交叉存储器要 求其模块数必须大于等于 m，以保证启动某模块后经过 m*r 的时间后再次启动 该模块时，其上次的存取操作已经完成（即流水线不间断)。这样, 连续存取 m 个 字所需的时间为 $t1=T+(m-1)r$\n\n      ![低位交叉编址方式流水线方式存取示意图](https://s2.loli.net/2024/07/25/u8gX2cp9nZ6tjB3.png)\n\n### 主存储器与 CPU 之间的连接\n\n此处的图都很重要，要会画\n\n![主存储器与 CPU 之间的连接](https://s2.loli.net/2024/07/25/CqFIRleH7ydkpWb.png)\n\n![位扩展连接示意图](https://s2.loli.net/2024/07/25/sHMowxIzEADOf2n.png)\n\n![子扩展连接示意图](https://s2.loli.net/2024/07/25/fer45njNyEuqTxp.png)\n\n![同时扩展连接示意图](https://s2.loli.net/2024/07/25/JKe3nt9CpbWq5BA.png)\n\n### 外部存储器\n\n#### 磁盘存储器\n\n1. 磁盘存储器 \n\n   1. 磁盘设备的组成硬盘存储器的组成。硬盘存储器由磁盘驱动器、磁盘控制器和盘片组 成。 \n\n      1. 磁盘驱动器。核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动磁头固定 盘片的硬盘存储器。\n      2. 磁盘控制器。硬盘存储器和主机的接口，主流的标准有 IDE、SCSI、SATA.等。\n\n   2. 存储区域。一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划 分为若干扇区，扇区（也称块）是磁盘读写的最小单位, 即磁盘按块存取。\n\n      1. 磁头数（Heads): 即记录面数，表示硬盘共有多少个磁头，磁头用于读取/写入盘片 上记录面的信息，一个记录面对应一个磁头。\n      2. 柱面数(Cylinders): 表示硬盘每面盘片上有多少条磁道。在一个盘组中，不同记录 面的相同编号（位置）的诸磁道构成一个圆柱面。\n      3. 扇区数(Sectors): 表示每条磁道上有多少个扇区。 磁盘存储器\n      4. 磁记录原理\n         1. 原理: 磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作。\n         2. 编码方法: 按某种方案（规律)，把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列， 并使读/写控制电路容易、可靠地实现转换。 磁记录方式: 通常采用调频制（FM）和改进型调频制（(MFM）的记录方式。\n\n   3. 磁盘的性能指标 \n\n      1. 记录密度。记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。 道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数， 面密度是位密度和道密度的乘积。\n      2. 磁盘的容量。磁盘容量有非格式化容量和格式化容量之分。非格式化容量是指磁记录表面可利用的磁 化单元总数，它由道密度和位密度计算而来; 格式化容量是指按照某种特定的记录格式所能存储信息的 总量。格式化后的容量比非格式化容量要小。\n      3. 平均存取时间。平均存取时间由寻道时间（磁头移动到目的磁道的时间)、旋转延迟时间（磁头定位到 要读写扇区的时间）和传输时间(传输数据所花费的时间）三部构成。由于寻道和找扇区的距离远近不 一，故寻道时间和旋转延迟时间通常取平均值, 数据传输率。磁盘存储器在单位时间内向主机传送数据 的字节数，称为数据传输率。假设磁盘转数为 r 转/秒，每条磁道容量为 N 字节, 则数据传输率为 D = rN\n\n   4. 磁盘地址\n\n      ![磁盘地址](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725140804949.png)\n\n       若系统中有 4 个驱动器，每个驱动器带一个磁盘，每个磁盘 256 个磁道、16 个盘面，每个盘面划分为 16 个扇区，则每个扇区地址要 18 位二进制代码，其格式如夏图所示。\n\n      ![磁盘地址格式示例](https://s2.loli.net/2024/07/25/Kq2UT5vba9undcB.png)\n\n   5. 硬盘的工作过程 硬盘的主要操作是寻址、读盘、写盘。\n\n      每个操作都对应一个控制字，硬盘工作时，第一步是取控制 字，第二步是执行控制字。\n\n       硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读 两组数据或写两组数据。\n\n2. 磁盘阵列\n\n   RAID（独立冗余磁盘阵列 Redundant Array of Independent Disks）\n\n   指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分 割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。\n\n    RAID 的分级如下所示。在 RAID1~RAID5 几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘 再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。\n\n   1. RAID0: 无冗余和无校验的磁盘阵列。 \n   2. RAID1: 镜像磁盘阵列。 \n   3. RAID2: 采用**纠错的海明码**的磁盘阵列。\n   4. RAID3: **位交叉奇偶校验**的磁盘阵列。\n   5. RAID4: **块交叉奇偶校验**的磁盘阵列。\n   6. RAID5: **无独立校验的奇偶校验**磁盘阵列。 \n\n   RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储 容量，而且提高了磁盘数据存取速度，但 RAID0 没有容错能力。为了提高可靠性, RAID1 使两个磁盘同时 进行读写, 互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味 着容量减少一半。\n\n   总之，RAID 通过同时使用多个磁盘，提高了传输率通过在多个磁盘上并行存取来大幅提高存储系统的数据吞 吐量; 通过镜像功能，提高安全可靠性; 通过数据校验，提供容错能力\n\n#### 固态硬盘\n\n它与 u 盘没有本质区别，通过平均读写频率演唱闪存块的寿命\n\n![SSD](https://s2.loli.net/2024/07/25/UchYg21zlbtFmw9.png)\n\n## 高速缓冲存储器\n\n程序访问的局部性原理包括 **时间局部性** 和 **空间局部性**。\n\n- 时间局部性是指在最近的未来要用到 的信息，很可能是现在正在使用的信息，因为程序中存在循环。\n- 空间局部性是指在最近的未 来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺 序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。\n\n**高速缓冲技术就是利用局部性原理**，把程序中正在使用的部分数据存放在一个高速的、容量较小的 Cache 中，使 CPU 的访存操作大多数针对 Cache 进行，从而提高程序的执行速度。\n\n### Cache 的结构与原理\n\n1. 位于存储结构的顶层\n2. 由 SRAM 组成\n3. Cache 和主存都被划分为相等的块，Cache 块又称 Cache 行，块的长度称为块长(Cache 行长)。\n4. 具有置换策略交换与主存的数据\n\n![Cache 结构](https://s2.loli.net/2024/07/25/2wrbRCYtdcKqVxa.png)\n\nCPU欲访问的信息已在Cache 中的比率称为Cache的命中率。设一个程序执行期间，Cache 的总命中次数为Nc，访问主存的总次数为Nm，则命中率H为\n$$\nH =Nc/(Nc+Nm)\n$$\n可见为提高访问效率，命中率H越接近1越好。设t为命中时的Cache访问时间，t.为未命中时 的访问时间，1-H表示未命中率，则Cache-主存系统的平均访问时间T为 \n$$\nT =Ht+(1- H)t\n$$\n\n> eg:\n>\n> ![Cache相关题目](https://s2.loli.net/2024/07/25/tRkudvhojwYBnDU.png)\n\n根据 Cache的读、写流程,实现Cache时需解决以下关键问题:\n\n1. 数据查找。如何快速判断数据是否在Cache 中。\n2. 地址映射。主存块如何存放在Cache中，如何将主存地址转换为Cache地址。\n3. 替换策略。Cache满后，使用何种策略对Cache块进行替换或淘汰。\n4. 写入策略。如何既保证主存块和Cache块的数据一致性，又尽量提升效率。\n\n### Cache与主存之间的映射方式\n\n地址映射是指把主存地址空间映射到Cache地址空间，即把 存放在主存中的信息按照某种规则装入。\n\nCache 由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在Cache 中，因此在Cache中 要为每块加一个标记，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明 Cache行中的信息是否有效，每个Cache行需要一个有效位。\n\n地址映射由以下三种方式\n\n1. 直接映射\n\n   主存中的每一块只能装入Cache 中的唯一位置。若这个位置己有内容，则产生块冲突，原来的块将 无条件地被替换出去（无须使用替换算法)。直接映射实现简单，但不够灵活，即使Cache的其他许 多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。**直接映射的关系可 定义为**\n   $$\n   \\text{Cache行号}=\\text{主存块号}\\ mod\\ \\text{Cache总行数}\n   $$\n   ![Cache和主存之间的直接映射关系](https://s2.loli.net/2024/07/25/cMYdAUeFltRSKH1.png)\n   \n   ![直接映射关系标记](https://s2.loli.net/2024/07/25/OYc9RM3uyfjnSzs.png)\n   \n2. 全相联映射\n\n   主存中的每一块可以装入Cache 中的任何位置，**每行的标记用于指出该行取自主存的哪一块**，所以 CPU访存时需要与所有Cache 行的标记进行比较。全相联映射方式的优点是比较灵活，Cache块的冲突 概率低，空间利用率高，命中率也高;缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的 按内容寻址的相联存储器进行地址映射，如图所示\n\n   ![全相联映射](https://s2.loli.net/2024/07/25/T5kIAShiUe7R4al.png)\n\n   ![全相联映射标记](https://s2.loli.net/2024/07/25/MndRsahJABKgiVf.png)\n\n   \n\n3. 组相联映射\n\n   **将Cache分成个大小相等的组**，每个主存块可以装入固定组中的任意一行，即**组间采用直接映射、而组内采用全相联映射的方式**，如图3.20 所示。它是对直接映射和全相联映射的一种折中，当Q=1时变为全相联映射，当Q=Cache行数时变为直接映射。假设**每组有r个Cache行，则称之为r路组相联**，图中每组有2个Cache行，因此称为二路组相联。\n\n   ![组相联映射](https://s2.loli.net/2024/07/25/SYcaQiMq59NDKCn.png)\n\n   ![组相联映射标记](https://s2.loli.net/2024/07/25/IONYfzUgnxFld8i.png)\n\n### 交换算法\n\n详见操作系统\n\n![交换算法](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725143458051.png)\n\n### Cache 写策略\n\n1. 全写法（写直通法、write-through)。**当CPU对 Cache写命中时，必须把数据同时写入Cache 和主存**。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。这种方法实现简 单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache的效率。写缓冲:为减少 全写法直接写入主存的时间损耗，在 Cache和主存之间加一个写缓冲（Write Buffer)，如下图所示。 CPU同时写数据到Cache 和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，写 缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。\n2. 回写法（ write-back) 。**当CPU对Cache 写命中时，只把数据写入Cache，而不立即写入主存**，只 有当此块被换出时才写回主存。这种方法减少了访存次数，但存在不一致的隐患。为了减少写回主存的开销，**每个Cache 行设置一个修改位（脏位)**。若修改位为1，则说明对应Cache行中的块被修 改过，替换时需要写回主存;若修改位为0，则说明对应Cache行中的块未被修改过，替换时无须写 回主存。\n\n1. 写分配法（write-allocate)。加载主存中的块到Cache中，然后更新这个Cache 块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。\n2. 非写分配法（not-write-allocate）法。只写入主存，不进行调块。 非写分配法通常与全写法合用，写分配法通常和回写法合用。\n\n## 虚拟存储器\n\n过多图片，且清晰度不高，详见\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第三章.md","raw":"---\ntitle: 计组篇-存储系统篇\ndate: 2024-08-14 19:47:58\ntags: [计算机组成原理, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# 第三章、存储系统\n\n## 对存储器的分类\n\n- 按在计算机中的层次分\n  - 主存储器\n  - 辅助存储器\n  - 高速缓冲存储器（高速 Cache）\n- 按存储介质分\n  - 半导体存储器（TTL、CMOS） **易失** 性存储器\n  - 磁表面存储器 （磁头，载磁体） **非易失** 性存储器\n  - 磁芯存储器 （硬磁材料、环状元件） **非易失** 性存储器\n  - 光盘存储器 （激光、磁光材料）**非易失** 性存储器\n- 按存取方式分类\n  - 存取时间与物理地址无关（随机访问）\n    - 随机存储器  在程序的执行过程中 **可读可写**\n    - 只读存储器 在程序的执行过程中 **只读**\n  - 存取时间与物理地址有关（串行访问）\n    - 顺序存取存储器    磁带\n    - 直接存取存储器    磁盘\n- 按信息的可保存性分类\n  - 易失性存储器\n  - 非易失性存储器\n  - 破坏性读出\n  - 非破坏性读出\n\n### 存储器的性能指标\n\n目标：**大容量、低成本、高速度**\n\n- 存储容量\n- 存储速度 \n  - 存取时间 \n  - 存取周期 \n  - 主存带宽 \n- 单位成本\n\n![存取时间与存取周期的关系](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725132223932.png)\n\n### 存储器的层次结构\n\n![层次结构](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725133021624.png)\n\n## SRAM 与 DRAM（主存储器）\n\n### SRAM 与 DRAM\n\n主存储器 **由 DRAM 实现**，**靠处理器的那一层(Cache)则由 SRAM 实现**，它们都属于 **易失性存储器**，只要电源被切断，原来保存的信息便会丢失。**DRAM 的每位价格低于 SRAM，速度也慢于 SRAM**，价格差异主要是因为制造 SRAM 需要更多的硅。ROM 属于非易失性存储器。\n\nStatic random-access memory and Dynamic random-access memory\n\n### 主存储器的构成与两者基本性质\n\n主存储器 **由 DRAM 实现**，**靠处理器的那一层(Cache)则由 SRAM 实现**，它们都属于 **易失性存储器**，只要电源被切断，原来保存的信息便会丢失。**DRAM 的每位价格低于 SRAM，速度也慢于 SRAM**，价格差异主要是因为制造 SRAM 需要更多的硅。**ROM 属于非易失性存储器**。\n\n### DRAM 的工作原理\n\n与 SRAM 的存储原理不同，动态随机存储器（DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的，**DRAM 的基本存储元通常只使用一个晶体管**，所以它比 SRAM 的密度要高很 多。相对于 SRAM 来说，**DRAM 具有容易集成、位价低、容量大和功耗低等优点**，但 DRAM 的 **存取速度比 SRAM 的慢**，一般用于大容量的主存系统 DRAM 电容上的电荷一般只能维持 1~2ms，因此即使电源不断电，信息也会自动消失。为此， 每隔一定时间必须 **刷新，通常取 2ms**，称为 **刷新周期**。常用的刷新方式有 3 种 \n\n- **集中刷新**: 指在一个刷新周期内，利用一段固定的时间, 依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区 \"。**优点是读写操作时不受刷新工作的影响; 缺点是在集中刷新期间（死区）不能访问存储器**。\n- **分散刷新**: 把对每行的刷新分散到各个工作周期中。这样一个存储器的系统工作周期分为两 部分: 前半部分用于正常读、写或保持; 后半部分用于刷新。这种刷新方式增加了系统的存 取周期，如存储芯片的存取周期为 0.5us，则系统的存取周期为 1us。**优点是没有死区; 缺点是加长了系统的存取周期, 降低了整机的速度**\n- **异步刷新**: 异步刷新是前两种方法的结合，它既可缩短“死时间”，又能充分利用最大刷新 间隔为 2ms 的特点。具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔 t，利用逻辑电路每隔时间 t 产生一次刷新请求。这样可以避免使 CPU 连续等待过长的时间， 而且减少了刷新次数，从根本上提高了整机的工作效率。\n\nDRAM 的刷新需注意以下问题:\n\n1. 刷新对 CPU 是透明的，即刷新不依赖于外部访问;\n2. DRAM 的 **刷新单位是行**，由芯片内部自行生成行地址; 刷新操作类似于读操作，但又有所不同。 另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。\n\n![DRAM 的读周期时序图](https://s2.loli.net/2024/07/25/MQT2AwpzFDWjcqY.png)\n\n\n\n### SRAM 与 DRAM 的比较\n\n![SRAM 与 DRAM 的比较](https://s2.loli.net/2024/07/25/3o7nQ5J4xftvWug.png)\n\n![SRAM与DRAM的比较](https://s2.loli.net/2024/07/25/RnobEUTscQkmLiZ.png)\n\n### 存储器芯片的内部结构\n\n![存储器芯片的内部结构](https://s2.loli.net/2024/07/25/sxaK7kA8pyrq5Yn.png)\n\n- **存储体（存储矩阵)**。存储体是存储单元的集合， 它由 **行选择线(X）和列选择线(Y)来选择所访问单元**，存储体的相同行、列上的位同时被读出或写入。\n- **地址译码器。** 用来将地址转换为译码输出线上的 高电平，以便驱动相应的读写电路。IO 控制电路。 用以控制被选中的单元的读出或写入，**具有放大信息的作用**。\n- **片选控制信号。** 单个芯片容量太小，往往满足不 了计算机对存储器容量的要求，因此需用一定数量的芯片进行存储器的扩展。在访问某个字时， 必须 **“选中”该存储字所在的芯片**，而 **其他芯片 不被“选中”**，因此需要有片选控制信号。\n\n## 只读存储器\n\n### ROM 的类型\n\n根据制造工艺的不同，ROM 可分为 **掩模式只读存储器（MROM)**、**一次可编程只读存储器(PROM)**、**可擦除可编程只读存储器（EPROM)**、**Flash 有储器** 和 **固态硬盘 SSD**。\n\n- 掩模式只读存储器（MROM Mask Read-Only Memory)：MROM 的内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写 入 **写入以后任何人都无法改变其内容**。优点是可靠性高, 集成度高，价格便宜; 缺点是灵活性差。\n- 一次可编程只读存储器（PROM Programmable ROM）：允许用户 利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变。\n- 可擦除可编程只读存储器（EPROM Erasable Programmable ROM）：EPROM 不仅可以 **由用户利用编程器写入信息，而且可以对其内容进行多次改写**。 EPROM 虽然既可读又可写，但它不能取代 RAM，因为 EPROM 的 **编程次数有限，且写入时间过长**。\n- Flash 存储器：Flash 存储器是在 EPROM 与 EPROM 的基础上发展起来的，其主要特点是既可在不加电的 情况下长期保存信息，又能在线进行快速擦除与重写。**Flash 存储器既有 EPROM 的价格 便宜、集成度高的优点，又有 EPROM 电可擦除重写的特点，且擦除重写的速度快**。\n- 固态硬盘（Solid State Drives，SSD)：基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元 (Flash 芯片）组成。保留了 Flash 存储器 **长期保存信息、快速擦除与重写** 的特性。对比传 统硬盘也具有 **读写速度快、低功耗的特性, 缺点是价格较高**。\n\n## 主存储器\n\n### 基本构成\n\n![主存储器基本构成图](https://s2.loli.net/2024/07/25/J5MVyIFiZHDUtWm.png)\n\n​\t指令执行过程中需要访问主存时，**CPU 首先把被访问单元的地址送到 MAR 中**，然后 **通过地址线将主存地址送到主存中的地址寄存器**，以便地址译码器进行译码选中相应单元，**同时 CPU 将读写信号通过控制线送到主存的读写控制电路。如果是写操作，那么 CPU 同时将要写的信 息送到 MDR 中，在读写控制电路的控制经数据线将信号写入选中的单元，如果是读操作，那 么主存读出选中单元的内容送到数据线，然后送到 MDR 中**。**数据线的宽度与 MDR 的宽度相 同，地址线的宽度与 MAR 的宽度相同。**\n\n​\t图采用 64 位数据线, 所以在按字节编址方式下，每 次最多可以存取 8 个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。例 如，36 位地址的最大寻址范围为 0~2^36-1，即地址从 0 开始编号。DRAM 芯片容量较大，地址位数较多，**为了减少芯片的地址引脚数，通常采用地址引脚复用技术，行地址和列地址通 过相同的引脚分先后两次输入这样地址引脚数可减少一半**。\n\n### 多模块存储器\n\n1. 单体多字存储器\n\n   单体多字系统的特点是 **存储器中只有一个存储体**，每个存储单元存储 m 个字，总线宽度也为 m 个字。一次并行读出 m 个字，地址必须顺序排列并处于同一存储单元。 单体多字系统在一个存取周期内，从同一地址取出 m 条指令，然后将指令逐条送至 CPU 执 行，即每隔 1/m 存取周期，CPU 向主存取一条指令。这显然提高了单体存储器的工作速度。 缺点: **指令和数据在主存内必须是连续存放的**，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显。\n\n2. 多体并行存储器\n\n   多体并行存储器 **由多体模块组成**。每个模块都有相同的容量和存取速度，各模块都有独立 的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。 多体并行存储器分为 **高位交叉编址和低位交叉编址两种。**\n\n   1. 高位交叉编址（顺序方式)**高位地址表示体号，低位地址为体内地址**。如图所示， 存储器共有 4 个模块 M0~M3,, 每个模块有 n 个单元, 各模块的地址范围如图中所示。\n\n      ![高位交叉编址的多体寄存器](https://s2.loli.net/2024/07/25/koL79yOQ236aDBV.png)\n\n      高位交叉方式下，**总是把低位的体内地址送到由高位体号确定的模块内进行译码**。访问一个 连续主存块时，**总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问**，CPU **总是按顺序访问存储模块，各模块不能被并行访问待因而不能提高存储器的吞吐率**\n\n   2. 低位交叉编址（交叉方式)． **低位地址为体号，高位地址为体内地址**。如图所示，每个 模块按“模 m”交叉编址，模块号 = 单元地址%m，假定有 m 个模块，每个模块有 k 个单元， 则 0，m,…, (k -1)m 单元位于 M; 第 1, m+ 1,…, (k -1)m+1 单元位于 M; 以此类推。\n\n      ![低位交叉编址的多体存储器](https://s2.loli.net/2024/07/25/olqgfhEKPAV8uvD.png)\n\n      低位交叉方式下，总是把 **高位的体内地址送到由低位体号确定的模块内进行译码**。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。采用低位交叉编址后， 可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。 设模块字长等于数据总线宽度，模块存取一个字的存取周期为 T，总线传送周期为 r，为实现 流水线方式存取，存储器交叉模块数应大于等于\n      $$\n      m = T/r\n      $$\n      式中，m 称为交叉存取度。每经过 r 时间延迟后启动下一个模块，交叉存储器要 求其模块数必须大于等于 m，以保证启动某模块后经过 m*r 的时间后再次启动 该模块时，其上次的存取操作已经完成（即流水线不间断)。这样, 连续存取 m 个 字所需的时间为 $t1=T+(m-1)r$\n\n      ![低位交叉编址方式流水线方式存取示意图](https://s2.loli.net/2024/07/25/u8gX2cp9nZ6tjB3.png)\n\n### 主存储器与 CPU 之间的连接\n\n此处的图都很重要，要会画\n\n![主存储器与 CPU 之间的连接](https://s2.loli.net/2024/07/25/CqFIRleH7ydkpWb.png)\n\n![位扩展连接示意图](https://s2.loli.net/2024/07/25/sHMowxIzEADOf2n.png)\n\n![子扩展连接示意图](https://s2.loli.net/2024/07/25/fer45njNyEuqTxp.png)\n\n![同时扩展连接示意图](https://s2.loli.net/2024/07/25/JKe3nt9CpbWq5BA.png)\n\n### 外部存储器\n\n#### 磁盘存储器\n\n1. 磁盘存储器 \n\n   1. 磁盘设备的组成硬盘存储器的组成。硬盘存储器由磁盘驱动器、磁盘控制器和盘片组 成。 \n\n      1. 磁盘驱动器。核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动磁头固定 盘片的硬盘存储器。\n      2. 磁盘控制器。硬盘存储器和主机的接口，主流的标准有 IDE、SCSI、SATA.等。\n\n   2. 存储区域。一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划 分为若干扇区，扇区（也称块）是磁盘读写的最小单位, 即磁盘按块存取。\n\n      1. 磁头数（Heads): 即记录面数，表示硬盘共有多少个磁头，磁头用于读取/写入盘片 上记录面的信息，一个记录面对应一个磁头。\n      2. 柱面数(Cylinders): 表示硬盘每面盘片上有多少条磁道。在一个盘组中，不同记录 面的相同编号（位置）的诸磁道构成一个圆柱面。\n      3. 扇区数(Sectors): 表示每条磁道上有多少个扇区。 磁盘存储器\n      4. 磁记录原理\n         1. 原理: 磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作。\n         2. 编码方法: 按某种方案（规律)，把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列， 并使读/写控制电路容易、可靠地实现转换。 磁记录方式: 通常采用调频制（FM）和改进型调频制（(MFM）的记录方式。\n\n   3. 磁盘的性能指标 \n\n      1. 记录密度。记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。 道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数， 面密度是位密度和道密度的乘积。\n      2. 磁盘的容量。磁盘容量有非格式化容量和格式化容量之分。非格式化容量是指磁记录表面可利用的磁 化单元总数，它由道密度和位密度计算而来; 格式化容量是指按照某种特定的记录格式所能存储信息的 总量。格式化后的容量比非格式化容量要小。\n      3. 平均存取时间。平均存取时间由寻道时间（磁头移动到目的磁道的时间)、旋转延迟时间（磁头定位到 要读写扇区的时间）和传输时间(传输数据所花费的时间）三部构成。由于寻道和找扇区的距离远近不 一，故寻道时间和旋转延迟时间通常取平均值, 数据传输率。磁盘存储器在单位时间内向主机传送数据 的字节数，称为数据传输率。假设磁盘转数为 r 转/秒，每条磁道容量为 N 字节, 则数据传输率为 D = rN\n\n   4. 磁盘地址\n\n      ![磁盘地址](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725140804949.png)\n\n       若系统中有 4 个驱动器，每个驱动器带一个磁盘，每个磁盘 256 个磁道、16 个盘面，每个盘面划分为 16 个扇区，则每个扇区地址要 18 位二进制代码，其格式如夏图所示。\n\n      ![磁盘地址格式示例](https://s2.loli.net/2024/07/25/Kq2UT5vba9undcB.png)\n\n   5. 硬盘的工作过程 硬盘的主要操作是寻址、读盘、写盘。\n\n      每个操作都对应一个控制字，硬盘工作时，第一步是取控制 字，第二步是执行控制字。\n\n       硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读 两组数据或写两组数据。\n\n2. 磁盘阵列\n\n   RAID（独立冗余磁盘阵列 Redundant Array of Independent Disks）\n\n   指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分 割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。\n\n    RAID 的分级如下所示。在 RAID1~RAID5 几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘 再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。\n\n   1. RAID0: 无冗余和无校验的磁盘阵列。 \n   2. RAID1: 镜像磁盘阵列。 \n   3. RAID2: 采用**纠错的海明码**的磁盘阵列。\n   4. RAID3: **位交叉奇偶校验**的磁盘阵列。\n   5. RAID4: **块交叉奇偶校验**的磁盘阵列。\n   6. RAID5: **无独立校验的奇偶校验**磁盘阵列。 \n\n   RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储 容量，而且提高了磁盘数据存取速度，但 RAID0 没有容错能力。为了提高可靠性, RAID1 使两个磁盘同时 进行读写, 互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味 着容量减少一半。\n\n   总之，RAID 通过同时使用多个磁盘，提高了传输率通过在多个磁盘上并行存取来大幅提高存储系统的数据吞 吐量; 通过镜像功能，提高安全可靠性; 通过数据校验，提供容错能力\n\n#### 固态硬盘\n\n它与 u 盘没有本质区别，通过平均读写频率演唱闪存块的寿命\n\n![SSD](https://s2.loli.net/2024/07/25/UchYg21zlbtFmw9.png)\n\n## 高速缓冲存储器\n\n程序访问的局部性原理包括 **时间局部性** 和 **空间局部性**。\n\n- 时间局部性是指在最近的未来要用到 的信息，很可能是现在正在使用的信息，因为程序中存在循环。\n- 空间局部性是指在最近的未 来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺 序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。\n\n**高速缓冲技术就是利用局部性原理**，把程序中正在使用的部分数据存放在一个高速的、容量较小的 Cache 中，使 CPU 的访存操作大多数针对 Cache 进行，从而提高程序的执行速度。\n\n### Cache 的结构与原理\n\n1. 位于存储结构的顶层\n2. 由 SRAM 组成\n3. Cache 和主存都被划分为相等的块，Cache 块又称 Cache 行，块的长度称为块长(Cache 行长)。\n4. 具有置换策略交换与主存的数据\n\n![Cache 结构](https://s2.loli.net/2024/07/25/2wrbRCYtdcKqVxa.png)\n\nCPU欲访问的信息已在Cache 中的比率称为Cache的命中率。设一个程序执行期间，Cache 的总命中次数为Nc，访问主存的总次数为Nm，则命中率H为\n$$\nH =Nc/(Nc+Nm)\n$$\n可见为提高访问效率，命中率H越接近1越好。设t为命中时的Cache访问时间，t.为未命中时 的访问时间，1-H表示未命中率，则Cache-主存系统的平均访问时间T为 \n$$\nT =Ht+(1- H)t\n$$\n\n> eg:\n>\n> ![Cache相关题目](https://s2.loli.net/2024/07/25/tRkudvhojwYBnDU.png)\n\n根据 Cache的读、写流程,实现Cache时需解决以下关键问题:\n\n1. 数据查找。如何快速判断数据是否在Cache 中。\n2. 地址映射。主存块如何存放在Cache中，如何将主存地址转换为Cache地址。\n3. 替换策略。Cache满后，使用何种策略对Cache块进行替换或淘汰。\n4. 写入策略。如何既保证主存块和Cache块的数据一致性，又尽量提升效率。\n\n### Cache与主存之间的映射方式\n\n地址映射是指把主存地址空间映射到Cache地址空间，即把 存放在主存中的信息按照某种规则装入。\n\nCache 由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在Cache 中，因此在Cache中 要为每块加一个标记，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明 Cache行中的信息是否有效，每个Cache行需要一个有效位。\n\n地址映射由以下三种方式\n\n1. 直接映射\n\n   主存中的每一块只能装入Cache 中的唯一位置。若这个位置己有内容，则产生块冲突，原来的块将 无条件地被替换出去（无须使用替换算法)。直接映射实现简单，但不够灵活，即使Cache的其他许 多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。**直接映射的关系可 定义为**\n   $$\n   \\text{Cache行号}=\\text{主存块号}\\ mod\\ \\text{Cache总行数}\n   $$\n   ![Cache和主存之间的直接映射关系](https://s2.loli.net/2024/07/25/cMYdAUeFltRSKH1.png)\n   \n   ![直接映射关系标记](https://s2.loli.net/2024/07/25/OYc9RM3uyfjnSzs.png)\n   \n2. 全相联映射\n\n   主存中的每一块可以装入Cache 中的任何位置，**每行的标记用于指出该行取自主存的哪一块**，所以 CPU访存时需要与所有Cache 行的标记进行比较。全相联映射方式的优点是比较灵活，Cache块的冲突 概率低，空间利用率高，命中率也高;缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的 按内容寻址的相联存储器进行地址映射，如图所示\n\n   ![全相联映射](https://s2.loli.net/2024/07/25/T5kIAShiUe7R4al.png)\n\n   ![全相联映射标记](https://s2.loli.net/2024/07/25/MndRsahJABKgiVf.png)\n\n   \n\n3. 组相联映射\n\n   **将Cache分成个大小相等的组**，每个主存块可以装入固定组中的任意一行，即**组间采用直接映射、而组内采用全相联映射的方式**，如图3.20 所示。它是对直接映射和全相联映射的一种折中，当Q=1时变为全相联映射，当Q=Cache行数时变为直接映射。假设**每组有r个Cache行，则称之为r路组相联**，图中每组有2个Cache行，因此称为二路组相联。\n\n   ![组相联映射](https://s2.loli.net/2024/07/25/SYcaQiMq59NDKCn.png)\n\n   ![组相联映射标记](https://s2.loli.net/2024/07/25/IONYfzUgnxFld8i.png)\n\n### 交换算法\n\n详见操作系统\n\n![交换算法](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725143458051.png)\n\n### Cache 写策略\n\n1. 全写法（写直通法、write-through)。**当CPU对 Cache写命中时，必须把数据同时写入Cache 和主存**。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。这种方法实现简 单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache的效率。写缓冲:为减少 全写法直接写入主存的时间损耗，在 Cache和主存之间加一个写缓冲（Write Buffer)，如下图所示。 CPU同时写数据到Cache 和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，写 缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。\n2. 回写法（ write-back) 。**当CPU对Cache 写命中时，只把数据写入Cache，而不立即写入主存**，只 有当此块被换出时才写回主存。这种方法减少了访存次数，但存在不一致的隐患。为了减少写回主存的开销，**每个Cache 行设置一个修改位（脏位)**。若修改位为1，则说明对应Cache行中的块被修 改过，替换时需要写回主存;若修改位为0，则说明对应Cache行中的块未被修改过，替换时无须写 回主存。\n\n1. 写分配法（write-allocate)。加载主存中的块到Cache中，然后更新这个Cache 块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。\n2. 非写分配法（not-write-allocate）法。只写入主存，不进行调块。 非写分配法通常与全写法合用，写分配法通常和回写法合用。\n\n## 虚拟存储器\n\n过多图片，且清晰度不高，详见\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第三章","published":1,"updated":"2024-08-17T13:22:24.464Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qq9000hm8wv9a2wg8nj","content":"<h1 id=\"第三章、存储系统\"><a href=\"#第三章、存储系统\" class=\"headerlink\" title=\"第三章、存储系统\"></a>第三章、存储系统</h1><h2 id=\"对存储器的分类\"><a href=\"#对存储器的分类\" class=\"headerlink\" title=\"对存储器的分类\"></a>对存储器的分类</h2><ul>\n<li>按在计算机中的层次分<ul>\n<li>主存储器</li>\n<li>辅助存储器</li>\n<li>高速缓冲存储器（高速 Cache）</li>\n</ul>\n</li>\n<li>按存储介质分<ul>\n<li>半导体存储器（TTL、CMOS） <strong>易失</strong> 性存储器</li>\n<li>磁表面存储器 （磁头，载磁体） <strong>非易失</strong> 性存储器</li>\n<li>磁芯存储器 （硬磁材料、环状元件） <strong>非易失</strong> 性存储器</li>\n<li>光盘存储器 （激光、磁光材料）<strong>非易失</strong> 性存储器</li>\n</ul>\n</li>\n<li>按存取方式分类<ul>\n<li>存取时间与物理地址无关（随机访问）<ul>\n<li>随机存储器  在程序的执行过程中 <strong>可读可写</strong></li>\n<li>只读存储器 在程序的执行过程中 <strong>只读</strong></li>\n</ul>\n</li>\n<li>存取时间与物理地址有关（串行访问）<ul>\n<li>顺序存取存储器    磁带</li>\n<li>直接存取存储器    磁盘</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>按信息的可保存性分类<ul>\n<li>易失性存储器</li>\n<li>非易失性存储器</li>\n<li>破坏性读出</li>\n<li>非破坏性读出</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"存储器的性能指标\"><a href=\"#存储器的性能指标\" class=\"headerlink\" title=\"存储器的性能指标\"></a>存储器的性能指标</h3><p>目标：<strong>大容量、低成本、高速度</strong></p>\n<ul>\n<li>存储容量</li>\n<li>存储速度 <ul>\n<li>存取时间 </li>\n<li>存取周期 </li>\n<li>主存带宽 </li>\n</ul>\n</li>\n<li>单位成本</li>\n</ul>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725132223932.png\" alt=\"存取时间与存取周期的关系\"></p>\n<h3 id=\"存储器的层次结构\"><a href=\"#存储器的层次结构\" class=\"headerlink\" title=\"存储器的层次结构\"></a>存储器的层次结构</h3><p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725133021624.png\" alt=\"层次结构\"></p>\n<h2 id=\"SRAM-与-DRAM（主存储器）\"><a href=\"#SRAM-与-DRAM（主存储器）\" class=\"headerlink\" title=\"SRAM 与 DRAM（主存储器）\"></a>SRAM 与 DRAM（主存储器）</h2><h3 id=\"SRAM-与-DRAM\"><a href=\"#SRAM-与-DRAM\" class=\"headerlink\" title=\"SRAM 与 DRAM\"></a>SRAM 与 DRAM</h3><p>主存储器 <strong>由 DRAM 实现</strong>，<strong>靠处理器的那一层(Cache)则由 SRAM 实现</strong>，它们都属于 <strong>易失性存储器</strong>，只要电源被切断，原来保存的信息便会丢失。<strong>DRAM 的每位价格低于 SRAM，速度也慢于 SRAM</strong>，价格差异主要是因为制造 SRAM 需要更多的硅。ROM 属于非易失性存储器。</p>\n<p>Static random-access memory and Dynamic random-access memory</p>\n<h3 id=\"主存储器的构成与两者基本性质\"><a href=\"#主存储器的构成与两者基本性质\" class=\"headerlink\" title=\"主存储器的构成与两者基本性质\"></a>主存储器的构成与两者基本性质</h3><p>主存储器 <strong>由 DRAM 实现</strong>，<strong>靠处理器的那一层(Cache)则由 SRAM 实现</strong>，它们都属于 <strong>易失性存储器</strong>，只要电源被切断，原来保存的信息便会丢失。<strong>DRAM 的每位价格低于 SRAM，速度也慢于 SRAM</strong>，价格差异主要是因为制造 SRAM 需要更多的硅。<strong>ROM 属于非易失性存储器</strong>。</p>\n<h3 id=\"DRAM-的工作原理\"><a href=\"#DRAM-的工作原理\" class=\"headerlink\" title=\"DRAM 的工作原理\"></a>DRAM 的工作原理</h3><p>与 SRAM 的存储原理不同，动态随机存储器（DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的，<strong>DRAM 的基本存储元通常只使用一个晶体管</strong>，所以它比 SRAM 的密度要高很 多。相对于 SRAM 来说，<strong>DRAM 具有容易集成、位价低、容量大和功耗低等优点</strong>，但 DRAM 的 <strong>存取速度比 SRAM 的慢</strong>，一般用于大容量的主存系统 DRAM 电容上的电荷一般只能维持 1~2ms，因此即使电源不断电，信息也会自动消失。为此， 每隔一定时间必须 <strong>刷新，通常取 2ms</strong>，称为 <strong>刷新周期</strong>。常用的刷新方式有 3 种 </p>\n<ul>\n<li><strong>集中刷新</strong>: 指在一个刷新周期内，利用一段固定的时间, 依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区 “。<strong>优点是读写操作时不受刷新工作的影响; 缺点是在集中刷新期间（死区）不能访问存储器</strong>。</li>\n<li><strong>分散刷新</strong>: 把对每行的刷新分散到各个工作周期中。这样一个存储器的系统工作周期分为两 部分: 前半部分用于正常读、写或保持; 后半部分用于刷新。这种刷新方式增加了系统的存 取周期，如存储芯片的存取周期为 0.5us，则系统的存取周期为 1us。<strong>优点是没有死区; 缺点是加长了系统的存取周期, 降低了整机的速度</strong></li>\n<li><strong>异步刷新</strong>: 异步刷新是前两种方法的结合，它既可缩短“死时间”，又能充分利用最大刷新 间隔为 2ms 的特点。具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔 t，利用逻辑电路每隔时间 t 产生一次刷新请求。这样可以避免使 CPU 连续等待过长的时间， 而且减少了刷新次数，从根本上提高了整机的工作效率。</li>\n</ul>\n<p>DRAM 的刷新需注意以下问题:</p>\n<ol>\n<li>刷新对 CPU 是透明的，即刷新不依赖于外部访问;</li>\n<li>DRAM 的 <strong>刷新单位是行</strong>，由芯片内部自行生成行地址; 刷新操作类似于读操作，但又有所不同。 另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/25/MQT2AwpzFDWjcqY.png\" alt=\"DRAM 的读周期时序图\"></p>\n<h3 id=\"SRAM-与-DRAM-的比较\"><a href=\"#SRAM-与-DRAM-的比较\" class=\"headerlink\" title=\"SRAM 与 DRAM 的比较\"></a>SRAM 与 DRAM 的比较</h3><p><img src=\"https://s2.loli.net/2024/07/25/3o7nQ5J4xftvWug.png\" alt=\"SRAM 与 DRAM 的比较\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/RnobEUTscQkmLiZ.png\" alt=\"SRAM与DRAM的比较\"></p>\n<h3 id=\"存储器芯片的内部结构\"><a href=\"#存储器芯片的内部结构\" class=\"headerlink\" title=\"存储器芯片的内部结构\"></a>存储器芯片的内部结构</h3><p><img src=\"https://s2.loli.net/2024/07/25/sxaK7kA8pyrq5Yn.png\" alt=\"存储器芯片的内部结构\"></p>\n<ul>\n<li><strong>存储体（存储矩阵)</strong>。存储体是存储单元的集合， 它由 <strong>行选择线(X）和列选择线(Y)来选择所访问单元</strong>，存储体的相同行、列上的位同时被读出或写入。</li>\n<li><strong>地址译码器。</strong> 用来将地址转换为译码输出线上的 高电平，以便驱动相应的读写电路。IO 控制电路。 用以控制被选中的单元的读出或写入，<strong>具有放大信息的作用</strong>。</li>\n<li><strong>片选控制信号。</strong> 单个芯片容量太小，往往满足不 了计算机对存储器容量的要求，因此需用一定数量的芯片进行存储器的扩展。在访问某个字时， 必须 <strong>“选中”该存储字所在的芯片</strong>，而 <strong>其他芯片 不被“选中”</strong>，因此需要有片选控制信号。</li>\n</ul>\n<h2 id=\"只读存储器\"><a href=\"#只读存储器\" class=\"headerlink\" title=\"只读存储器\"></a>只读存储器</h2><h3 id=\"ROM-的类型\"><a href=\"#ROM-的类型\" class=\"headerlink\" title=\"ROM 的类型\"></a>ROM 的类型</h3><p>根据制造工艺的不同，ROM 可分为 <strong>掩模式只读存储器（MROM)</strong>、<strong>一次可编程只读存储器(PROM)</strong>、<strong>可擦除可编程只读存储器（EPROM)</strong>、<strong>Flash 有储器</strong> 和 <strong>固态硬盘 SSD</strong>。</p>\n<ul>\n<li>掩模式只读存储器（MROM Mask Read-Only Memory)：MROM 的内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写 入 <strong>写入以后任何人都无法改变其内容</strong>。优点是可靠性高, 集成度高，价格便宜; 缺点是灵活性差。</li>\n<li>一次可编程只读存储器（PROM Programmable ROM）：允许用户 利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变。</li>\n<li>可擦除可编程只读存储器（EPROM Erasable Programmable ROM）：EPROM 不仅可以 <strong>由用户利用编程器写入信息，而且可以对其内容进行多次改写</strong>。 EPROM 虽然既可读又可写，但它不能取代 RAM，因为 EPROM 的 <strong>编程次数有限，且写入时间过长</strong>。</li>\n<li>Flash 存储器：Flash 存储器是在 EPROM 与 EPROM 的基础上发展起来的，其主要特点是既可在不加电的 情况下长期保存信息，又能在线进行快速擦除与重写。<strong>Flash 存储器既有 EPROM 的价格 便宜、集成度高的优点，又有 EPROM 电可擦除重写的特点，且擦除重写的速度快</strong>。</li>\n<li>固态硬盘（Solid State Drives，SSD)：基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元 (Flash 芯片）组成。保留了 Flash 存储器 <strong>长期保存信息、快速擦除与重写</strong> 的特性。对比传 统硬盘也具有 <strong>读写速度快、低功耗的特性, 缺点是价格较高</strong>。</li>\n</ul>\n<h2 id=\"主存储器\"><a href=\"#主存储器\" class=\"headerlink\" title=\"主存储器\"></a>主存储器</h2><h3 id=\"基本构成\"><a href=\"#基本构成\" class=\"headerlink\" title=\"基本构成\"></a>基本构成</h3><p><img src=\"https://s2.loli.net/2024/07/25/J5MVyIFiZHDUtWm.png\" alt=\"主存储器基本构成图\"></p>\n<p>​    指令执行过程中需要访问主存时，<strong>CPU 首先把被访问单元的地址送到 MAR 中</strong>，然后 <strong>通过地址线将主存地址送到主存中的地址寄存器</strong>，以便地址译码器进行译码选中相应单元，<strong>同时 CPU 将读写信号通过控制线送到主存的读写控制电路。如果是写操作，那么 CPU 同时将要写的信 息送到 MDR 中，在读写控制电路的控制经数据线将信号写入选中的单元，如果是读操作，那 么主存读出选中单元的内容送到数据线，然后送到 MDR 中</strong>。<strong>数据线的宽度与 MDR 的宽度相 同，地址线的宽度与 MAR 的宽度相同。</strong></p>\n<p>​    图采用 64 位数据线, 所以在按字节编址方式下，每 次最多可以存取 8 个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。例 如，36 位地址的最大寻址范围为 0~2^36-1，即地址从 0 开始编号。DRAM 芯片容量较大，地址位数较多，<strong>为了减少芯片的地址引脚数，通常采用地址引脚复用技术，行地址和列地址通 过相同的引脚分先后两次输入这样地址引脚数可减少一半</strong>。</p>\n<h3 id=\"多模块存储器\"><a href=\"#多模块存储器\" class=\"headerlink\" title=\"多模块存储器\"></a>多模块存储器</h3><ol>\n<li><p>单体多字存储器</p>\n<p>单体多字系统的特点是 <strong>存储器中只有一个存储体</strong>，每个存储单元存储 m 个字，总线宽度也为 m 个字。一次并行读出 m 个字，地址必须顺序排列并处于同一存储单元。 单体多字系统在一个存取周期内，从同一地址取出 m 条指令，然后将指令逐条送至 CPU 执 行，即每隔 1/m 存取周期，CPU 向主存取一条指令。这显然提高了单体存储器的工作速度。 缺点: <strong>指令和数据在主存内必须是连续存放的</strong>，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显。</p>\n</li>\n<li><p>多体并行存储器</p>\n<p>多体并行存储器 <strong>由多体模块组成</strong>。每个模块都有相同的容量和存取速度，各模块都有独立 的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。 多体并行存储器分为 <strong>高位交叉编址和低位交叉编址两种。</strong></p>\n<ol>\n<li><p>高位交叉编址（顺序方式)<strong>高位地址表示体号，低位地址为体内地址</strong>。如图所示， 存储器共有 4 个模块 M0~M3,, 每个模块有 n 个单元, 各模块的地址范围如图中所示。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/koL79yOQ236aDBV.png\" alt=\"高位交叉编址的多体寄存器\"></p>\n<p>高位交叉方式下，<strong>总是把低位的体内地址送到由高位体号确定的模块内进行译码</strong>。访问一个 连续主存块时，<strong>总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问</strong>，CPU <strong>总是按顺序访问存储模块，各模块不能被并行访问待因而不能提高存储器的吞吐率</strong></p>\n</li>\n<li><p>低位交叉编址（交叉方式)． <strong>低位地址为体号，高位地址为体内地址</strong>。如图所示，每个 模块按“模 m”交叉编址，模块号 = 单元地址%m，假定有 m 个模块，每个模块有 k 个单元， 则 0，m,…, (k -1)m 单元位于 M; 第 1, m+ 1,…, (k -1)m+1 单元位于 M; 以此类推。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/olqgfhEKPAV8uvD.png\" alt=\"低位交叉编址的多体存储器\"></p>\n<p>低位交叉方式下，总是把 <strong>高位的体内地址送到由低位体号确定的模块内进行译码</strong>。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。采用低位交叉编址后， 可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。 设模块字长等于数据总线宽度，模块存取一个字的存取周期为 T，总线传送周期为 r，为实现 流水线方式存取，存储器交叉模块数应大于等于</p>\n<script type=\"math/tex; mode=display\">\nm = T/r</script><p>式中，m 称为交叉存取度。每经过 r 时间延迟后启动下一个模块，交叉存储器要 求其模块数必须大于等于 m，以保证启动某模块后经过 m*r 的时间后再次启动 该模块时，其上次的存取操作已经完成（即流水线不间断)。这样, 连续存取 m 个 字所需的时间为 $t1=T+(m-1)r$</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/u8gX2cp9nZ6tjB3.png\" alt=\"低位交叉编址方式流水线方式存取示意图\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"主存储器与-CPU-之间的连接\"><a href=\"#主存储器与-CPU-之间的连接\" class=\"headerlink\" title=\"主存储器与 CPU 之间的连接\"></a>主存储器与 CPU 之间的连接</h3><p>此处的图都很重要，要会画</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/CqFIRleH7ydkpWb.png\" alt=\"主存储器与 CPU 之间的连接\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/sHMowxIzEADOf2n.png\" alt=\"位扩展连接示意图\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/fer45njNyEuqTxp.png\" alt=\"子扩展连接示意图\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/JKe3nt9CpbWq5BA.png\" alt=\"同时扩展连接示意图\"></p>\n<h3 id=\"外部存储器\"><a href=\"#外部存储器\" class=\"headerlink\" title=\"外部存储器\"></a>外部存储器</h3><h4 id=\"磁盘存储器\"><a href=\"#磁盘存储器\" class=\"headerlink\" title=\"磁盘存储器\"></a>磁盘存储器</h4><ol>\n<li><p>磁盘存储器 </p>\n<ol>\n<li><p>磁盘设备的组成硬盘存储器的组成。硬盘存储器由磁盘驱动器、磁盘控制器和盘片组 成。 </p>\n<ol>\n<li>磁盘驱动器。核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动磁头固定 盘片的硬盘存储器。</li>\n<li>磁盘控制器。硬盘存储器和主机的接口，主流的标准有 IDE、SCSI、SATA.等。</li>\n</ol>\n</li>\n<li><p>存储区域。一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划 分为若干扇区，扇区（也称块）是磁盘读写的最小单位, 即磁盘按块存取。</p>\n<ol>\n<li>磁头数（Heads): 即记录面数，表示硬盘共有多少个磁头，磁头用于读取/写入盘片 上记录面的信息，一个记录面对应一个磁头。</li>\n<li>柱面数(Cylinders): 表示硬盘每面盘片上有多少条磁道。在一个盘组中，不同记录 面的相同编号（位置）的诸磁道构成一个圆柱面。</li>\n<li>扇区数(Sectors): 表示每条磁道上有多少个扇区。 磁盘存储器</li>\n<li>磁记录原理<ol>\n<li>原理: 磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作。</li>\n<li>编码方法: 按某种方案（规律)，把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列， 并使读/写控制电路容易、可靠地实现转换。 磁记录方式: 通常采用调频制（FM）和改进型调频制（(MFM）的记录方式。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>磁盘的性能指标 </p>\n<ol>\n<li>记录密度。记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。 道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数， 面密度是位密度和道密度的乘积。</li>\n<li>磁盘的容量。磁盘容量有非格式化容量和格式化容量之分。非格式化容量是指磁记录表面可利用的磁 化单元总数，它由道密度和位密度计算而来; 格式化容量是指按照某种特定的记录格式所能存储信息的 总量。格式化后的容量比非格式化容量要小。</li>\n<li>平均存取时间。平均存取时间由寻道时间（磁头移动到目的磁道的时间)、旋转延迟时间（磁头定位到 要读写扇区的时间）和传输时间(传输数据所花费的时间）三部构成。由于寻道和找扇区的距离远近不 一，故寻道时间和旋转延迟时间通常取平均值, 数据传输率。磁盘存储器在单位时间内向主机传送数据 的字节数，称为数据传输率。假设磁盘转数为 r 转/秒，每条磁道容量为 N 字节, 则数据传输率为 D = rN</li>\n</ol>\n</li>\n<li><p>磁盘地址</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725140804949.png\" alt=\"磁盘地址\"></p>\n<p> 若系统中有 4 个驱动器，每个驱动器带一个磁盘，每个磁盘 256 个磁道、16 个盘面，每个盘面划分为 16 个扇区，则每个扇区地址要 18 位二进制代码，其格式如夏图所示。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/Kq2UT5vba9undcB.png\" alt=\"磁盘地址格式示例\"></p>\n</li>\n<li><p>硬盘的工作过程 硬盘的主要操作是寻址、读盘、写盘。</p>\n<p>每个操作都对应一个控制字，硬盘工作时，第一步是取控制 字，第二步是执行控制字。</p>\n<p> 硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读 两组数据或写两组数据。</p>\n</li>\n</ol>\n</li>\n<li><p>磁盘阵列</p>\n<p>RAID（独立冗余磁盘阵列 Redundant Array of Independent Disks）</p>\n<p>指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分 割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</p>\n<p> RAID 的分级如下所示。在 RAID1~RAID5 几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘 再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。</p>\n<ol>\n<li>RAID0: 无冗余和无校验的磁盘阵列。 </li>\n<li>RAID1: 镜像磁盘阵列。 </li>\n<li>RAID2: 采用<strong>纠错的海明码</strong>的磁盘阵列。</li>\n<li>RAID3: <strong>位交叉奇偶校验</strong>的磁盘阵列。</li>\n<li>RAID4: <strong>块交叉奇偶校验</strong>的磁盘阵列。</li>\n<li>RAID5: <strong>无独立校验的奇偶校验</strong>磁盘阵列。 </li>\n</ol>\n<p>RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储 容量，而且提高了磁盘数据存取速度，但 RAID0 没有容错能力。为了提高可靠性, RAID1 使两个磁盘同时 进行读写, 互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味 着容量减少一半。</p>\n<p>总之，RAID 通过同时使用多个磁盘，提高了传输率通过在多个磁盘上并行存取来大幅提高存储系统的数据吞 吐量; 通过镜像功能，提高安全可靠性; 通过数据校验，提供容错能力</p>\n</li>\n</ol>\n<h4 id=\"固态硬盘\"><a href=\"#固态硬盘\" class=\"headerlink\" title=\"固态硬盘\"></a>固态硬盘</h4><p>它与 u 盘没有本质区别，通过平均读写频率演唱闪存块的寿命</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/UchYg21zlbtFmw9.png\" alt=\"SSD\"></p>\n<h2 id=\"高速缓冲存储器\"><a href=\"#高速缓冲存储器\" class=\"headerlink\" title=\"高速缓冲存储器\"></a>高速缓冲存储器</h2><p>程序访问的局部性原理包括 <strong>时间局部性</strong> 和 <strong>空间局部性</strong>。</p>\n<ul>\n<li>时间局部性是指在最近的未来要用到 的信息，很可能是现在正在使用的信息，因为程序中存在循环。</li>\n<li>空间局部性是指在最近的未 来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺 序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。</li>\n</ul>\n<p><strong>高速缓冲技术就是利用局部性原理</strong>，把程序中正在使用的部分数据存放在一个高速的、容量较小的 Cache 中，使 CPU 的访存操作大多数针对 Cache 进行，从而提高程序的执行速度。</p>\n<h3 id=\"Cache-的结构与原理\"><a href=\"#Cache-的结构与原理\" class=\"headerlink\" title=\"Cache 的结构与原理\"></a>Cache 的结构与原理</h3><ol>\n<li>位于存储结构的顶层</li>\n<li>由 SRAM 组成</li>\n<li>Cache 和主存都被划分为相等的块，Cache 块又称 Cache 行，块的长度称为块长(Cache 行长)。</li>\n<li>具有置换策略交换与主存的数据</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/25/2wrbRCYtdcKqVxa.png\" alt=\"Cache 结构\"></p>\n<p>CPU欲访问的信息已在Cache 中的比率称为Cache的命中率。设一个程序执行期间，Cache 的总命中次数为Nc，访问主存的总次数为Nm，则命中率H为</p>\n<script type=\"math/tex; mode=display\">\nH =Nc/(Nc+Nm)</script><p>可见为提高访问效率，命中率H越接近1越好。设t为命中时的Cache访问时间，t.为未命中时 的访问时间，1-H表示未命中率，则Cache-主存系统的平均访问时间T为 </p>\n<script type=\"math/tex; mode=display\">\nT =Ht+(1- H)t</script><blockquote>\n<p>eg:</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/tRkudvhojwYBnDU.png\" alt=\"Cache相关题目\"></p>\n</blockquote>\n<p>根据 Cache的读、写流程,实现Cache时需解决以下关键问题:</p>\n<ol>\n<li>数据查找。如何快速判断数据是否在Cache 中。</li>\n<li>地址映射。主存块如何存放在Cache中，如何将主存地址转换为Cache地址。</li>\n<li>替换策略。Cache满后，使用何种策略对Cache块进行替换或淘汰。</li>\n<li>写入策略。如何既保证主存块和Cache块的数据一致性，又尽量提升效率。</li>\n</ol>\n<h3 id=\"Cache与主存之间的映射方式\"><a href=\"#Cache与主存之间的映射方式\" class=\"headerlink\" title=\"Cache与主存之间的映射方式\"></a>Cache与主存之间的映射方式</h3><p>地址映射是指把主存地址空间映射到Cache地址空间，即把 存放在主存中的信息按照某种规则装入。</p>\n<p>Cache 由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在Cache 中，因此在Cache中 要为每块加一个标记，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明 Cache行中的信息是否有效，每个Cache行需要一个有效位。</p>\n<p>地址映射由以下三种方式</p>\n<ol>\n<li><p>直接映射</p>\n<p>主存中的每一块只能装入Cache 中的唯一位置。若这个位置己有内容，则产生块冲突，原来的块将 无条件地被替换出去（无须使用替换算法)。直接映射实现简单，但不够灵活，即使Cache的其他许 多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。<strong>直接映射的关系可 定义为</strong></p>\n<script type=\"math/tex; mode=display\">\n\\text{Cache行号}=\\text{主存块号}\\ mod\\ \\text{Cache总行数}</script><p><img src=\"https://s2.loli.net/2024/07/25/cMYdAUeFltRSKH1.png\" alt=\"Cache和主存之间的直接映射关系\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/OYc9RM3uyfjnSzs.png\" alt=\"直接映射关系标记\"></p>\n</li>\n<li><p>全相联映射</p>\n<p>主存中的每一块可以装入Cache 中的任何位置，<strong>每行的标记用于指出该行取自主存的哪一块</strong>，所以 CPU访存时需要与所有Cache 行的标记进行比较。全相联映射方式的优点是比较灵活，Cache块的冲突 概率低，空间利用率高，命中率也高;缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的 按内容寻址的相联存储器进行地址映射，如图所示</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/T5kIAShiUe7R4al.png\" alt=\"全相联映射\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/MndRsahJABKgiVf.png\" alt=\"全相联映射标记\"></p>\n</li>\n</ol>\n<ol>\n<li><p>组相联映射</p>\n<p><strong>将Cache分成个大小相等的组</strong>，每个主存块可以装入固定组中的任意一行，即<strong>组间采用直接映射、而组内采用全相联映射的方式</strong>，如图3.20 所示。它是对直接映射和全相联映射的一种折中，当Q=1时变为全相联映射，当Q=Cache行数时变为直接映射。假设<strong>每组有r个Cache行，则称之为r路组相联</strong>，图中每组有2个Cache行，因此称为二路组相联。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/SYcaQiMq59NDKCn.png\" alt=\"组相联映射\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/IONYfzUgnxFld8i.png\" alt=\"组相联映射标记\"></p>\n</li>\n</ol>\n<h3 id=\"交换算法\"><a href=\"#交换算法\" class=\"headerlink\" title=\"交换算法\"></a>交换算法</h3><p>详见操作系统</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725143458051.png\" alt=\"交换算法\"></p>\n<h3 id=\"Cache-写策略\"><a href=\"#Cache-写策略\" class=\"headerlink\" title=\"Cache 写策略\"></a>Cache 写策略</h3><ol>\n<li>全写法（写直通法、write-through)。<strong>当CPU对 Cache写命中时，必须把数据同时写入Cache 和主存</strong>。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。这种方法实现简 单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache的效率。写缓冲:为减少 全写法直接写入主存的时间损耗，在 Cache和主存之间加一个写缓冲（Write Buffer)，如下图所示。 CPU同时写数据到Cache 和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，写 缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。</li>\n<li><p>回写法（ write-back) 。<strong>当CPU对Cache 写命中时，只把数据写入Cache，而不立即写入主存</strong>，只 有当此块被换出时才写回主存。这种方法减少了访存次数，但存在不一致的隐患。为了减少写回主存的开销，<strong>每个Cache 行设置一个修改位（脏位)</strong>。若修改位为1，则说明对应Cache行中的块被修 改过，替换时需要写回主存;若修改位为0，则说明对应Cache行中的块未被修改过，替换时无须写 回主存。</p>\n</li>\n<li><p>写分配法（write-allocate)。加载主存中的块到Cache中，然后更新这个Cache 块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。</p>\n</li>\n<li>非写分配法（not-write-allocate）法。只写入主存，不进行调块。 非写分配法通常与全写法合用，写分配法通常和回写法合用。</li>\n</ol>\n<h2 id=\"虚拟存储器\"><a href=\"#虚拟存储器\" class=\"headerlink\" title=\"虚拟存储器\"></a>虚拟存储器</h2><p>过多图片，且清晰度不高，详见</p>\n<!-- flag of hidden posts -->","length":6315,"excerpt":"","more":"<h1 id=\"第三章、存储系统\"><a href=\"#第三章、存储系统\" class=\"headerlink\" title=\"第三章、存储系统\"></a>第三章、存储系统</h1><h2 id=\"对存储器的分类\"><a href=\"#对存储器的分类\" class=\"headerlink\" title=\"对存储器的分类\"></a>对存储器的分类</h2><ul>\n<li>按在计算机中的层次分<ul>\n<li>主存储器</li>\n<li>辅助存储器</li>\n<li>高速缓冲存储器（高速 Cache）</li>\n</ul>\n</li>\n<li>按存储介质分<ul>\n<li>半导体存储器（TTL、CMOS） <strong>易失</strong> 性存储器</li>\n<li>磁表面存储器 （磁头，载磁体） <strong>非易失</strong> 性存储器</li>\n<li>磁芯存储器 （硬磁材料、环状元件） <strong>非易失</strong> 性存储器</li>\n<li>光盘存储器 （激光、磁光材料）<strong>非易失</strong> 性存储器</li>\n</ul>\n</li>\n<li>按存取方式分类<ul>\n<li>存取时间与物理地址无关（随机访问）<ul>\n<li>随机存储器  在程序的执行过程中 <strong>可读可写</strong></li>\n<li>只读存储器 在程序的执行过程中 <strong>只读</strong></li>\n</ul>\n</li>\n<li>存取时间与物理地址有关（串行访问）<ul>\n<li>顺序存取存储器    磁带</li>\n<li>直接存取存储器    磁盘</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>按信息的可保存性分类<ul>\n<li>易失性存储器</li>\n<li>非易失性存储器</li>\n<li>破坏性读出</li>\n<li>非破坏性读出</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"存储器的性能指标\"><a href=\"#存储器的性能指标\" class=\"headerlink\" title=\"存储器的性能指标\"></a>存储器的性能指标</h3><p>目标：<strong>大容量、低成本、高速度</strong></p>\n<ul>\n<li>存储容量</li>\n<li>存储速度 <ul>\n<li>存取时间 </li>\n<li>存取周期 </li>\n<li>主存带宽 </li>\n</ul>\n</li>\n<li>单位成本</li>\n</ul>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725132223932.png\" alt=\"存取时间与存取周期的关系\"></p>\n<h3 id=\"存储器的层次结构\"><a href=\"#存储器的层次结构\" class=\"headerlink\" title=\"存储器的层次结构\"></a>存储器的层次结构</h3><p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725133021624.png\" alt=\"层次结构\"></p>\n<h2 id=\"SRAM-与-DRAM（主存储器）\"><a href=\"#SRAM-与-DRAM（主存储器）\" class=\"headerlink\" title=\"SRAM 与 DRAM（主存储器）\"></a>SRAM 与 DRAM（主存储器）</h2><h3 id=\"SRAM-与-DRAM\"><a href=\"#SRAM-与-DRAM\" class=\"headerlink\" title=\"SRAM 与 DRAM\"></a>SRAM 与 DRAM</h3><p>主存储器 <strong>由 DRAM 实现</strong>，<strong>靠处理器的那一层(Cache)则由 SRAM 实现</strong>，它们都属于 <strong>易失性存储器</strong>，只要电源被切断，原来保存的信息便会丢失。<strong>DRAM 的每位价格低于 SRAM，速度也慢于 SRAM</strong>，价格差异主要是因为制造 SRAM 需要更多的硅。ROM 属于非易失性存储器。</p>\n<p>Static random-access memory and Dynamic random-access memory</p>\n<h3 id=\"主存储器的构成与两者基本性质\"><a href=\"#主存储器的构成与两者基本性质\" class=\"headerlink\" title=\"主存储器的构成与两者基本性质\"></a>主存储器的构成与两者基本性质</h3><p>主存储器 <strong>由 DRAM 实现</strong>，<strong>靠处理器的那一层(Cache)则由 SRAM 实现</strong>，它们都属于 <strong>易失性存储器</strong>，只要电源被切断，原来保存的信息便会丢失。<strong>DRAM 的每位价格低于 SRAM，速度也慢于 SRAM</strong>，价格差异主要是因为制造 SRAM 需要更多的硅。<strong>ROM 属于非易失性存储器</strong>。</p>\n<h3 id=\"DRAM-的工作原理\"><a href=\"#DRAM-的工作原理\" class=\"headerlink\" title=\"DRAM 的工作原理\"></a>DRAM 的工作原理</h3><p>与 SRAM 的存储原理不同，动态随机存储器（DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的，<strong>DRAM 的基本存储元通常只使用一个晶体管</strong>，所以它比 SRAM 的密度要高很 多。相对于 SRAM 来说，<strong>DRAM 具有容易集成、位价低、容量大和功耗低等优点</strong>，但 DRAM 的 <strong>存取速度比 SRAM 的慢</strong>，一般用于大容量的主存系统 DRAM 电容上的电荷一般只能维持 1~2ms，因此即使电源不断电，信息也会自动消失。为此， 每隔一定时间必须 <strong>刷新，通常取 2ms</strong>，称为 <strong>刷新周期</strong>。常用的刷新方式有 3 种 </p>\n<ul>\n<li><strong>集中刷新</strong>: 指在一个刷新周期内，利用一段固定的时间, 依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区 “。<strong>优点是读写操作时不受刷新工作的影响; 缺点是在集中刷新期间（死区）不能访问存储器</strong>。</li>\n<li><strong>分散刷新</strong>: 把对每行的刷新分散到各个工作周期中。这样一个存储器的系统工作周期分为两 部分: 前半部分用于正常读、写或保持; 后半部分用于刷新。这种刷新方式增加了系统的存 取周期，如存储芯片的存取周期为 0.5us，则系统的存取周期为 1us。<strong>优点是没有死区; 缺点是加长了系统的存取周期, 降低了整机的速度</strong></li>\n<li><strong>异步刷新</strong>: 异步刷新是前两种方法的结合，它既可缩短“死时间”，又能充分利用最大刷新 间隔为 2ms 的特点。具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔 t，利用逻辑电路每隔时间 t 产生一次刷新请求。这样可以避免使 CPU 连续等待过长的时间， 而且减少了刷新次数，从根本上提高了整机的工作效率。</li>\n</ul>\n<p>DRAM 的刷新需注意以下问题:</p>\n<ol>\n<li>刷新对 CPU 是透明的，即刷新不依赖于外部访问;</li>\n<li>DRAM 的 <strong>刷新单位是行</strong>，由芯片内部自行生成行地址; 刷新操作类似于读操作，但又有所不同。 另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/25/MQT2AwpzFDWjcqY.png\" alt=\"DRAM 的读周期时序图\"></p>\n<h3 id=\"SRAM-与-DRAM-的比较\"><a href=\"#SRAM-与-DRAM-的比较\" class=\"headerlink\" title=\"SRAM 与 DRAM 的比较\"></a>SRAM 与 DRAM 的比较</h3><p><img src=\"https://s2.loli.net/2024/07/25/3o7nQ5J4xftvWug.png\" alt=\"SRAM 与 DRAM 的比较\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/RnobEUTscQkmLiZ.png\" alt=\"SRAM与DRAM的比较\"></p>\n<h3 id=\"存储器芯片的内部结构\"><a href=\"#存储器芯片的内部结构\" class=\"headerlink\" title=\"存储器芯片的内部结构\"></a>存储器芯片的内部结构</h3><p><img src=\"https://s2.loli.net/2024/07/25/sxaK7kA8pyrq5Yn.png\" alt=\"存储器芯片的内部结构\"></p>\n<ul>\n<li><strong>存储体（存储矩阵)</strong>。存储体是存储单元的集合， 它由 <strong>行选择线(X）和列选择线(Y)来选择所访问单元</strong>，存储体的相同行、列上的位同时被读出或写入。</li>\n<li><strong>地址译码器。</strong> 用来将地址转换为译码输出线上的 高电平，以便驱动相应的读写电路。IO 控制电路。 用以控制被选中的单元的读出或写入，<strong>具有放大信息的作用</strong>。</li>\n<li><strong>片选控制信号。</strong> 单个芯片容量太小，往往满足不 了计算机对存储器容量的要求，因此需用一定数量的芯片进行存储器的扩展。在访问某个字时， 必须 <strong>“选中”该存储字所在的芯片</strong>，而 <strong>其他芯片 不被“选中”</strong>，因此需要有片选控制信号。</li>\n</ul>\n<h2 id=\"只读存储器\"><a href=\"#只读存储器\" class=\"headerlink\" title=\"只读存储器\"></a>只读存储器</h2><h3 id=\"ROM-的类型\"><a href=\"#ROM-的类型\" class=\"headerlink\" title=\"ROM 的类型\"></a>ROM 的类型</h3><p>根据制造工艺的不同，ROM 可分为 <strong>掩模式只读存储器（MROM)</strong>、<strong>一次可编程只读存储器(PROM)</strong>、<strong>可擦除可编程只读存储器（EPROM)</strong>、<strong>Flash 有储器</strong> 和 <strong>固态硬盘 SSD</strong>。</p>\n<ul>\n<li>掩模式只读存储器（MROM Mask Read-Only Memory)：MROM 的内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写 入 <strong>写入以后任何人都无法改变其内容</strong>。优点是可靠性高, 集成度高，价格便宜; 缺点是灵活性差。</li>\n<li>一次可编程只读存储器（PROM Programmable ROM）：允许用户 利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变。</li>\n<li>可擦除可编程只读存储器（EPROM Erasable Programmable ROM）：EPROM 不仅可以 <strong>由用户利用编程器写入信息，而且可以对其内容进行多次改写</strong>。 EPROM 虽然既可读又可写，但它不能取代 RAM，因为 EPROM 的 <strong>编程次数有限，且写入时间过长</strong>。</li>\n<li>Flash 存储器：Flash 存储器是在 EPROM 与 EPROM 的基础上发展起来的，其主要特点是既可在不加电的 情况下长期保存信息，又能在线进行快速擦除与重写。<strong>Flash 存储器既有 EPROM 的价格 便宜、集成度高的优点，又有 EPROM 电可擦除重写的特点，且擦除重写的速度快</strong>。</li>\n<li>固态硬盘（Solid State Drives，SSD)：基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元 (Flash 芯片）组成。保留了 Flash 存储器 <strong>长期保存信息、快速擦除与重写</strong> 的特性。对比传 统硬盘也具有 <strong>读写速度快、低功耗的特性, 缺点是价格较高</strong>。</li>\n</ul>\n<h2 id=\"主存储器\"><a href=\"#主存储器\" class=\"headerlink\" title=\"主存储器\"></a>主存储器</h2><h3 id=\"基本构成\"><a href=\"#基本构成\" class=\"headerlink\" title=\"基本构成\"></a>基本构成</h3><p><img src=\"https://s2.loli.net/2024/07/25/J5MVyIFiZHDUtWm.png\" alt=\"主存储器基本构成图\"></p>\n<p>​    指令执行过程中需要访问主存时，<strong>CPU 首先把被访问单元的地址送到 MAR 中</strong>，然后 <strong>通过地址线将主存地址送到主存中的地址寄存器</strong>，以便地址译码器进行译码选中相应单元，<strong>同时 CPU 将读写信号通过控制线送到主存的读写控制电路。如果是写操作，那么 CPU 同时将要写的信 息送到 MDR 中，在读写控制电路的控制经数据线将信号写入选中的单元，如果是读操作，那 么主存读出选中单元的内容送到数据线，然后送到 MDR 中</strong>。<strong>数据线的宽度与 MDR 的宽度相 同，地址线的宽度与 MAR 的宽度相同。</strong></p>\n<p>​    图采用 64 位数据线, 所以在按字节编址方式下，每 次最多可以存取 8 个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。例 如，36 位地址的最大寻址范围为 0~2^36-1，即地址从 0 开始编号。DRAM 芯片容量较大，地址位数较多，<strong>为了减少芯片的地址引脚数，通常采用地址引脚复用技术，行地址和列地址通 过相同的引脚分先后两次输入这样地址引脚数可减少一半</strong>。</p>\n<h3 id=\"多模块存储器\"><a href=\"#多模块存储器\" class=\"headerlink\" title=\"多模块存储器\"></a>多模块存储器</h3><ol>\n<li><p>单体多字存储器</p>\n<p>单体多字系统的特点是 <strong>存储器中只有一个存储体</strong>，每个存储单元存储 m 个字，总线宽度也为 m 个字。一次并行读出 m 个字，地址必须顺序排列并处于同一存储单元。 单体多字系统在一个存取周期内，从同一地址取出 m 条指令，然后将指令逐条送至 CPU 执 行，即每隔 1/m 存取周期，CPU 向主存取一条指令。这显然提高了单体存储器的工作速度。 缺点: <strong>指令和数据在主存内必须是连续存放的</strong>，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显。</p>\n</li>\n<li><p>多体并行存储器</p>\n<p>多体并行存储器 <strong>由多体模块组成</strong>。每个模块都有相同的容量和存取速度，各模块都有独立 的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。 多体并行存储器分为 <strong>高位交叉编址和低位交叉编址两种。</strong></p>\n<ol>\n<li><p>高位交叉编址（顺序方式)<strong>高位地址表示体号，低位地址为体内地址</strong>。如图所示， 存储器共有 4 个模块 M0~M3,, 每个模块有 n 个单元, 各模块的地址范围如图中所示。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/koL79yOQ236aDBV.png\" alt=\"高位交叉编址的多体寄存器\"></p>\n<p>高位交叉方式下，<strong>总是把低位的体内地址送到由高位体号确定的模块内进行译码</strong>。访问一个 连续主存块时，<strong>总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问</strong>，CPU <strong>总是按顺序访问存储模块，各模块不能被并行访问待因而不能提高存储器的吞吐率</strong></p>\n</li>\n<li><p>低位交叉编址（交叉方式)． <strong>低位地址为体号，高位地址为体内地址</strong>。如图所示，每个 模块按“模 m”交叉编址，模块号 = 单元地址%m，假定有 m 个模块，每个模块有 k 个单元， 则 0，m,…, (k -1)m 单元位于 M; 第 1, m+ 1,…, (k -1)m+1 单元位于 M; 以此类推。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/olqgfhEKPAV8uvD.png\" alt=\"低位交叉编址的多体存储器\"></p>\n<p>低位交叉方式下，总是把 <strong>高位的体内地址送到由低位体号确定的模块内进行译码</strong>。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。采用低位交叉编址后， 可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。 设模块字长等于数据总线宽度，模块存取一个字的存取周期为 T，总线传送周期为 r，为实现 流水线方式存取，存储器交叉模块数应大于等于</p>\n<script type=\"math/tex; mode=display\">\nm = T/r</script><p>式中，m 称为交叉存取度。每经过 r 时间延迟后启动下一个模块，交叉存储器要 求其模块数必须大于等于 m，以保证启动某模块后经过 m*r 的时间后再次启动 该模块时，其上次的存取操作已经完成（即流水线不间断)。这样, 连续存取 m 个 字所需的时间为 $t1=T+(m-1)r$</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/u8gX2cp9nZ6tjB3.png\" alt=\"低位交叉编址方式流水线方式存取示意图\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"主存储器与-CPU-之间的连接\"><a href=\"#主存储器与-CPU-之间的连接\" class=\"headerlink\" title=\"主存储器与 CPU 之间的连接\"></a>主存储器与 CPU 之间的连接</h3><p>此处的图都很重要，要会画</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/CqFIRleH7ydkpWb.png\" alt=\"主存储器与 CPU 之间的连接\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/sHMowxIzEADOf2n.png\" alt=\"位扩展连接示意图\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/fer45njNyEuqTxp.png\" alt=\"子扩展连接示意图\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/JKe3nt9CpbWq5BA.png\" alt=\"同时扩展连接示意图\"></p>\n<h3 id=\"外部存储器\"><a href=\"#外部存储器\" class=\"headerlink\" title=\"外部存储器\"></a>外部存储器</h3><h4 id=\"磁盘存储器\"><a href=\"#磁盘存储器\" class=\"headerlink\" title=\"磁盘存储器\"></a>磁盘存储器</h4><ol>\n<li><p>磁盘存储器 </p>\n<ol>\n<li><p>磁盘设备的组成硬盘存储器的组成。硬盘存储器由磁盘驱动器、磁盘控制器和盘片组 成。 </p>\n<ol>\n<li>磁盘驱动器。核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动磁头固定 盘片的硬盘存储器。</li>\n<li>磁盘控制器。硬盘存储器和主机的接口，主流的标准有 IDE、SCSI、SATA.等。</li>\n</ol>\n</li>\n<li><p>存储区域。一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划 分为若干扇区，扇区（也称块）是磁盘读写的最小单位, 即磁盘按块存取。</p>\n<ol>\n<li>磁头数（Heads): 即记录面数，表示硬盘共有多少个磁头，磁头用于读取/写入盘片 上记录面的信息，一个记录面对应一个磁头。</li>\n<li>柱面数(Cylinders): 表示硬盘每面盘片上有多少条磁道。在一个盘组中，不同记录 面的相同编号（位置）的诸磁道构成一个圆柱面。</li>\n<li>扇区数(Sectors): 表示每条磁道上有多少个扇区。 磁盘存储器</li>\n<li>磁记录原理<ol>\n<li>原理: 磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作。</li>\n<li>编码方法: 按某种方案（规律)，把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列， 并使读/写控制电路容易、可靠地实现转换。 磁记录方式: 通常采用调频制（FM）和改进型调频制（(MFM）的记录方式。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>磁盘的性能指标 </p>\n<ol>\n<li>记录密度。记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。 道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数， 面密度是位密度和道密度的乘积。</li>\n<li>磁盘的容量。磁盘容量有非格式化容量和格式化容量之分。非格式化容量是指磁记录表面可利用的磁 化单元总数，它由道密度和位密度计算而来; 格式化容量是指按照某种特定的记录格式所能存储信息的 总量。格式化后的容量比非格式化容量要小。</li>\n<li>平均存取时间。平均存取时间由寻道时间（磁头移动到目的磁道的时间)、旋转延迟时间（磁头定位到 要读写扇区的时间）和传输时间(传输数据所花费的时间）三部构成。由于寻道和找扇区的距离远近不 一，故寻道时间和旋转延迟时间通常取平均值, 数据传输率。磁盘存储器在单位时间内向主机传送数据 的字节数，称为数据传输率。假设磁盘转数为 r 转/秒，每条磁道容量为 N 字节, 则数据传输率为 D = rN</li>\n</ol>\n</li>\n<li><p>磁盘地址</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725140804949.png\" alt=\"磁盘地址\"></p>\n<p> 若系统中有 4 个驱动器，每个驱动器带一个磁盘，每个磁盘 256 个磁道、16 个盘面，每个盘面划分为 16 个扇区，则每个扇区地址要 18 位二进制代码，其格式如夏图所示。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/Kq2UT5vba9undcB.png\" alt=\"磁盘地址格式示例\"></p>\n</li>\n<li><p>硬盘的工作过程 硬盘的主要操作是寻址、读盘、写盘。</p>\n<p>每个操作都对应一个控制字，硬盘工作时，第一步是取控制 字，第二步是执行控制字。</p>\n<p> 硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读 两组数据或写两组数据。</p>\n</li>\n</ol>\n</li>\n<li><p>磁盘阵列</p>\n<p>RAID（独立冗余磁盘阵列 Redundant Array of Independent Disks）</p>\n<p>指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分 割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</p>\n<p> RAID 的分级如下所示。在 RAID1~RAID5 几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘 再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。</p>\n<ol>\n<li>RAID0: 无冗余和无校验的磁盘阵列。 </li>\n<li>RAID1: 镜像磁盘阵列。 </li>\n<li>RAID2: 采用<strong>纠错的海明码</strong>的磁盘阵列。</li>\n<li>RAID3: <strong>位交叉奇偶校验</strong>的磁盘阵列。</li>\n<li>RAID4: <strong>块交叉奇偶校验</strong>的磁盘阵列。</li>\n<li>RAID5: <strong>无独立校验的奇偶校验</strong>磁盘阵列。 </li>\n</ol>\n<p>RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储 容量，而且提高了磁盘数据存取速度，但 RAID0 没有容错能力。为了提高可靠性, RAID1 使两个磁盘同时 进行读写, 互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味 着容量减少一半。</p>\n<p>总之，RAID 通过同时使用多个磁盘，提高了传输率通过在多个磁盘上并行存取来大幅提高存储系统的数据吞 吐量; 通过镜像功能，提高安全可靠性; 通过数据校验，提供容错能力</p>\n</li>\n</ol>\n<h4 id=\"固态硬盘\"><a href=\"#固态硬盘\" class=\"headerlink\" title=\"固态硬盘\"></a>固态硬盘</h4><p>它与 u 盘没有本质区别，通过平均读写频率演唱闪存块的寿命</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/UchYg21zlbtFmw9.png\" alt=\"SSD\"></p>\n<h2 id=\"高速缓冲存储器\"><a href=\"#高速缓冲存储器\" class=\"headerlink\" title=\"高速缓冲存储器\"></a>高速缓冲存储器</h2><p>程序访问的局部性原理包括 <strong>时间局部性</strong> 和 <strong>空间局部性</strong>。</p>\n<ul>\n<li>时间局部性是指在最近的未来要用到 的信息，很可能是现在正在使用的信息，因为程序中存在循环。</li>\n<li>空间局部性是指在最近的未 来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺 序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。</li>\n</ul>\n<p><strong>高速缓冲技术就是利用局部性原理</strong>，把程序中正在使用的部分数据存放在一个高速的、容量较小的 Cache 中，使 CPU 的访存操作大多数针对 Cache 进行，从而提高程序的执行速度。</p>\n<h3 id=\"Cache-的结构与原理\"><a href=\"#Cache-的结构与原理\" class=\"headerlink\" title=\"Cache 的结构与原理\"></a>Cache 的结构与原理</h3><ol>\n<li>位于存储结构的顶层</li>\n<li>由 SRAM 组成</li>\n<li>Cache 和主存都被划分为相等的块，Cache 块又称 Cache 行，块的长度称为块长(Cache 行长)。</li>\n<li>具有置换策略交换与主存的数据</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/25/2wrbRCYtdcKqVxa.png\" alt=\"Cache 结构\"></p>\n<p>CPU欲访问的信息已在Cache 中的比率称为Cache的命中率。设一个程序执行期间，Cache 的总命中次数为Nc，访问主存的总次数为Nm，则命中率H为</p>\n<script type=\"math/tex; mode=display\">\nH =Nc/(Nc+Nm)</script><p>可见为提高访问效率，命中率H越接近1越好。设t为命中时的Cache访问时间，t.为未命中时 的访问时间，1-H表示未命中率，则Cache-主存系统的平均访问时间T为 </p>\n<script type=\"math/tex; mode=display\">\nT =Ht+(1- H)t</script><blockquote>\n<p>eg:</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/tRkudvhojwYBnDU.png\" alt=\"Cache相关题目\"></p>\n</blockquote>\n<p>根据 Cache的读、写流程,实现Cache时需解决以下关键问题:</p>\n<ol>\n<li>数据查找。如何快速判断数据是否在Cache 中。</li>\n<li>地址映射。主存块如何存放在Cache中，如何将主存地址转换为Cache地址。</li>\n<li>替换策略。Cache满后，使用何种策略对Cache块进行替换或淘汰。</li>\n<li>写入策略。如何既保证主存块和Cache块的数据一致性，又尽量提升效率。</li>\n</ol>\n<h3 id=\"Cache与主存之间的映射方式\"><a href=\"#Cache与主存之间的映射方式\" class=\"headerlink\" title=\"Cache与主存之间的映射方式\"></a>Cache与主存之间的映射方式</h3><p>地址映射是指把主存地址空间映射到Cache地址空间，即把 存放在主存中的信息按照某种规则装入。</p>\n<p>Cache 由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在Cache 中，因此在Cache中 要为每块加一个标记，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明 Cache行中的信息是否有效，每个Cache行需要一个有效位。</p>\n<p>地址映射由以下三种方式</p>\n<ol>\n<li><p>直接映射</p>\n<p>主存中的每一块只能装入Cache 中的唯一位置。若这个位置己有内容，则产生块冲突，原来的块将 无条件地被替换出去（无须使用替换算法)。直接映射实现简单，但不够灵活，即使Cache的其他许 多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。<strong>直接映射的关系可 定义为</strong></p>\n<script type=\"math/tex; mode=display\">\n\\text{Cache行号}=\\text{主存块号}\\ mod\\ \\text{Cache总行数}</script><p><img src=\"https://s2.loli.net/2024/07/25/cMYdAUeFltRSKH1.png\" alt=\"Cache和主存之间的直接映射关系\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/OYc9RM3uyfjnSzs.png\" alt=\"直接映射关系标记\"></p>\n</li>\n<li><p>全相联映射</p>\n<p>主存中的每一块可以装入Cache 中的任何位置，<strong>每行的标记用于指出该行取自主存的哪一块</strong>，所以 CPU访存时需要与所有Cache 行的标记进行比较。全相联映射方式的优点是比较灵活，Cache块的冲突 概率低，空间利用率高，命中率也高;缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的 按内容寻址的相联存储器进行地址映射，如图所示</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/T5kIAShiUe7R4al.png\" alt=\"全相联映射\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/MndRsahJABKgiVf.png\" alt=\"全相联映射标记\"></p>\n</li>\n</ol>\n<ol>\n<li><p>组相联映射</p>\n<p><strong>将Cache分成个大小相等的组</strong>，每个主存块可以装入固定组中的任意一行，即<strong>组间采用直接映射、而组内采用全相联映射的方式</strong>，如图3.20 所示。它是对直接映射和全相联映射的一种折中，当Q=1时变为全相联映射，当Q=Cache行数时变为直接映射。假设<strong>每组有r个Cache行，则称之为r路组相联</strong>，图中每组有2个Cache行，因此称为二路组相联。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/SYcaQiMq59NDKCn.png\" alt=\"组相联映射\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/IONYfzUgnxFld8i.png\" alt=\"组相联映射标记\"></p>\n</li>\n</ol>\n<h3 id=\"交换算法\"><a href=\"#交换算法\" class=\"headerlink\" title=\"交换算法\"></a>交换算法</h3><p>详见操作系统</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725143458051.png\" alt=\"交换算法\"></p>\n<h3 id=\"Cache-写策略\"><a href=\"#Cache-写策略\" class=\"headerlink\" title=\"Cache 写策略\"></a>Cache 写策略</h3><ol>\n<li>全写法（写直通法、write-through)。<strong>当CPU对 Cache写命中时，必须把数据同时写入Cache 和主存</strong>。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。这种方法实现简 单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache的效率。写缓冲:为减少 全写法直接写入主存的时间损耗，在 Cache和主存之间加一个写缓冲（Write Buffer)，如下图所示。 CPU同时写数据到Cache 和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，写 缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。</li>\n<li><p>回写法（ write-back) 。<strong>当CPU对Cache 写命中时，只把数据写入Cache，而不立即写入主存</strong>，只 有当此块被换出时才写回主存。这种方法减少了访存次数，但存在不一致的隐患。为了减少写回主存的开销，<strong>每个Cache 行设置一个修改位（脏位)</strong>。若修改位为1，则说明对应Cache行中的块被修 改过，替换时需要写回主存;若修改位为0，则说明对应Cache行中的块未被修改过，替换时无须写 回主存。</p>\n</li>\n<li><p>写分配法（write-allocate)。加载主存中的块到Cache中，然后更新这个Cache 块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。</p>\n</li>\n<li>非写分配法（not-write-allocate）法。只写入主存，不进行调块。 非写分配法通常与全写法合用，写分配法通常和回写法合用。</li>\n</ol>\n<h2 id=\"虚拟存储器\"><a href=\"#虚拟存储器\" class=\"headerlink\" title=\"虚拟存储器\"></a>虚拟存储器</h2><p>过多图片，且清晰度不高，详见</p>\n"},{"title":"计组篇-系统大观篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# 第一章\n\n## 计算机系统总览\n\n![计算机系统](https://s2.loli.net/2024/07/16/ZmVMlK8a62QyRfg.png)\n\n计算机系统由软件与硬件构成\n\n**软件**分为\n\n1. 系统软件\n2. 应用软件\n\n**硬件**分为\n\n1. 存储器\n2. 运算器（CPU部件）\n3. 控制器（CPU部件）\n4. 输入设备I\n5. 输出设备O\n\n## 计算机硬件结构\n\n一些基本的计算机概念\n\n1. 硬件和软件在逻辑功能上是等效的——如Linux环境下的硬件文件\n2. 只有机械语言是能够被计算机直接执行的\n\n### 冯-偌伊曼机\n\n“**存储程序**” 的概念是指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。\n\n![冯偌伊曼机概念图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240716234029843.png)\n\n冯偌伊曼机的重要特点：\n\n1. **以运算器为中心**\n\n### 现代计算机基本结构\n\n![现代计算机基本结构](https://s2.loli.net/2024/07/16/dkTaHsC3JZWDp7b.png)\n\n现代计算机的重要特点：**以存储器为中心**\n\n## 数据驱动方式\n\n![数据驱动方式](https://s2.loli.net/2024/07/16/Hf17SOxtpdKFr3G.png)\n\n所谓数据驱动方式即计算机是以指令到数据的还是数据到指令的\n\n![按照驱动方式不同对计算机的划分](https://s2.loli.net/2024/07/16/5k68G7iMBEZycfh.png)\n\n## 计算机软件\n\n### 系统软件和应用软件\n\n**应用软件**是为了解决某个应用领域的问题而编制的程序\n**系统软件**负责管理硬件资源，并向上层应用程序提供基础服务\n\n### 三种级别的语言\n\n**机器语言**：二进制代码\n**汇编语言**：助记符\n**高级语言**：C/C++、Java、Python\n\n**编译程序**：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次)\n\n**解释程序**：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句 (每次执行都要翻译)，典型的代表如：js、Py、latex\n\n- 注意编译程序和解释程序的区别，编译程序时只需翻译一次的，解释程序是每次都需要翻译的\n\n### 软件和硬件的逻辑等价性\n\n**软件和硬件的逻辑功能等价性**：同一个功能，既可以用硬件实现（性能高成本高），也可以用软件实现（性能低成本也低）\n\n- ISA： Instrument System Architecture 指令体系结构，软件和硬件之间的界面。设计计算机系统的ISA，就是要定义一台计算机可以支持哪些指令，以及每条指令的作用是什么、每条指令的用法是什么。\n\n## 计算机的层次结构\n\n```mermaid\ngraph LR;\n\t计算机的层次结构-->M4:高级语言机器-执行高级语言;\n\t计算机的层次结构-->M3:汇编语言机器-执行汇编语言;\n\t计算机的层次结构-->M2:操作系统机器-向上提供广义指令;\n\t计算机的层次结构-->M1:传统机器-执行机器语言指令;\n\t计算机的层次结构-->MO:微程序机器-执行微指令;\n```\n\n- 计算机体系结构（如何设计硬件与软件之间的接口）——机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性(指令系统、数据类型、寻址技术、I/O机理)\n\n- 计算机组成原理（如何用硬件实现所定义的接口）一一实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）\n\n## 计算机系统的工作原理\n\n### 从C语言源程序到可执行文件\n\n![C编译](https://s2.loli.net/2024/07/21/JE4rN9RkWPI5sC8.png)\n\n1. 预处理过程：对开头的命令进行处理(#define 等)\n2. 编译过程：翻译高级语言为汇编语言\n3. 汇编过程：翻译汇编语言为二进制机器语言\n4. 链接过程：通过连接器链接库\n\n### 计算机工作原理\n\n1. 大观\n\n![计算机系统工作大观](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240721123259521.png)\n\n![存储程序工作方式](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240721123416974.png)\n\n## 计算机性能指标\n\n### 存储器的性能指标\n\nMAR（Membery Address Register）存储地址寄存器：MAR位数反映存储单元的个数（最多支持多少个)\n\nMDR（Membery Data Register）存储地址寄存器：位数=存储字长=每个存储单元的大小\n\n### CPU的性能指标\n\nCPU主频：CPU内数字脉冲信号振荡的频率。$ CPU主频=\\frac{1}{CLK}$\n\nCLK（CLOCK） 表示的是CPU时钟周期\n\nCPI（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数\n\n执行一条指令的耗时=CPI$\\times$CPU时钟周期（CLK）\n\nKIPS、MIPS、IPS（Instrument Per Second）：每秒执行多少条指令 IPS= 主频$\\times$平均CPI\n\nKFLOPS、MFLOPs、FLOPs（Floating-point Operations Per Second）：每秒执行多少次浮点运算\n\nZ = 1e3E = 1e9P\n\n### 系统整体的性能指标\n\n数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）\n\n![数据通路大观](https://s2.loli.net/2024/07/21/vNFnm6SXjk7o9sd.png)\n\n吞吐量：指系统在单位时问内处理请求的数量。\n\n> 它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。\n\n响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需\n要的结果的等待时问。\n\n> 通常包括CPU时问（运行一个程序所花费的时问）与等待时问（用于磁盘访问、存储\n> 器访问、I/O操作、操作系统开销等时问）。\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第一章.md","raw":"---\ntitle: 计组篇-系统大观篇\ndate: 2024-08-14 19:47:58\ntags: [计算机组成原理, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# 第一章\n\n## 计算机系统总览\n\n![计算机系统](https://s2.loli.net/2024/07/16/ZmVMlK8a62QyRfg.png)\n\n计算机系统由软件与硬件构成\n\n**软件**分为\n\n1. 系统软件\n2. 应用软件\n\n**硬件**分为\n\n1. 存储器\n2. 运算器（CPU部件）\n3. 控制器（CPU部件）\n4. 输入设备I\n5. 输出设备O\n\n## 计算机硬件结构\n\n一些基本的计算机概念\n\n1. 硬件和软件在逻辑功能上是等效的——如Linux环境下的硬件文件\n2. 只有机械语言是能够被计算机直接执行的\n\n### 冯-偌伊曼机\n\n“**存储程序**” 的概念是指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。\n\n![冯偌伊曼机概念图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240716234029843.png)\n\n冯偌伊曼机的重要特点：\n\n1. **以运算器为中心**\n\n### 现代计算机基本结构\n\n![现代计算机基本结构](https://s2.loli.net/2024/07/16/dkTaHsC3JZWDp7b.png)\n\n现代计算机的重要特点：**以存储器为中心**\n\n## 数据驱动方式\n\n![数据驱动方式](https://s2.loli.net/2024/07/16/Hf17SOxtpdKFr3G.png)\n\n所谓数据驱动方式即计算机是以指令到数据的还是数据到指令的\n\n![按照驱动方式不同对计算机的划分](https://s2.loli.net/2024/07/16/5k68G7iMBEZycfh.png)\n\n## 计算机软件\n\n### 系统软件和应用软件\n\n**应用软件**是为了解决某个应用领域的问题而编制的程序\n**系统软件**负责管理硬件资源，并向上层应用程序提供基础服务\n\n### 三种级别的语言\n\n**机器语言**：二进制代码\n**汇编语言**：助记符\n**高级语言**：C/C++、Java、Python\n\n**编译程序**：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次)\n\n**解释程序**：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句 (每次执行都要翻译)，典型的代表如：js、Py、latex\n\n- 注意编译程序和解释程序的区别，编译程序时只需翻译一次的，解释程序是每次都需要翻译的\n\n### 软件和硬件的逻辑等价性\n\n**软件和硬件的逻辑功能等价性**：同一个功能，既可以用硬件实现（性能高成本高），也可以用软件实现（性能低成本也低）\n\n- ISA： Instrument System Architecture 指令体系结构，软件和硬件之间的界面。设计计算机系统的ISA，就是要定义一台计算机可以支持哪些指令，以及每条指令的作用是什么、每条指令的用法是什么。\n\n## 计算机的层次结构\n\n```mermaid\ngraph LR;\n\t计算机的层次结构-->M4:高级语言机器-执行高级语言;\n\t计算机的层次结构-->M3:汇编语言机器-执行汇编语言;\n\t计算机的层次结构-->M2:操作系统机器-向上提供广义指令;\n\t计算机的层次结构-->M1:传统机器-执行机器语言指令;\n\t计算机的层次结构-->MO:微程序机器-执行微指令;\n```\n\n- 计算机体系结构（如何设计硬件与软件之间的接口）——机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性(指令系统、数据类型、寻址技术、I/O机理)\n\n- 计算机组成原理（如何用硬件实现所定义的接口）一一实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）\n\n## 计算机系统的工作原理\n\n### 从C语言源程序到可执行文件\n\n![C编译](https://s2.loli.net/2024/07/21/JE4rN9RkWPI5sC8.png)\n\n1. 预处理过程：对开头的命令进行处理(#define 等)\n2. 编译过程：翻译高级语言为汇编语言\n3. 汇编过程：翻译汇编语言为二进制机器语言\n4. 链接过程：通过连接器链接库\n\n### 计算机工作原理\n\n1. 大观\n\n![计算机系统工作大观](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240721123259521.png)\n\n![存储程序工作方式](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240721123416974.png)\n\n## 计算机性能指标\n\n### 存储器的性能指标\n\nMAR（Membery Address Register）存储地址寄存器：MAR位数反映存储单元的个数（最多支持多少个)\n\nMDR（Membery Data Register）存储地址寄存器：位数=存储字长=每个存储单元的大小\n\n### CPU的性能指标\n\nCPU主频：CPU内数字脉冲信号振荡的频率。$ CPU主频=\\frac{1}{CLK}$\n\nCLK（CLOCK） 表示的是CPU时钟周期\n\nCPI（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数\n\n执行一条指令的耗时=CPI$\\times$CPU时钟周期（CLK）\n\nKIPS、MIPS、IPS（Instrument Per Second）：每秒执行多少条指令 IPS= 主频$\\times$平均CPI\n\nKFLOPS、MFLOPs、FLOPs（Floating-point Operations Per Second）：每秒执行多少次浮点运算\n\nZ = 1e3E = 1e9P\n\n### 系统整体的性能指标\n\n数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）\n\n![数据通路大观](https://s2.loli.net/2024/07/21/vNFnm6SXjk7o9sd.png)\n\n吞吐量：指系统在单位时问内处理请求的数量。\n\n> 它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。\n\n响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需\n要的结果的等待时问。\n\n> 通常包括CPU时问（运行一个程序所花费的时问）与等待时问（用于磁盘访问、存储\n> 器访问、I/O操作、操作系统开销等时问）。\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第一章","published":1,"updated":"2024-08-17T13:22:12.197Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qq9000im8wveaip8uma","content":"<h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><h2 id=\"计算机系统总览\"><a href=\"#计算机系统总览\" class=\"headerlink\" title=\"计算机系统总览\"></a>计算机系统总览</h2><p><img src=\"https://s2.loli.net/2024/07/16/ZmVMlK8a62QyRfg.png\" alt=\"计算机系统\"></p>\n<p>计算机系统由软件与硬件构成</p>\n<p><strong>软件</strong>分为</p>\n<ol>\n<li>系统软件</li>\n<li>应用软件</li>\n</ol>\n<p><strong>硬件</strong>分为</p>\n<ol>\n<li>存储器</li>\n<li>运算器（CPU部件）</li>\n<li>控制器（CPU部件）</li>\n<li>输入设备I</li>\n<li>输出设备O</li>\n</ol>\n<h2 id=\"计算机硬件结构\"><a href=\"#计算机硬件结构\" class=\"headerlink\" title=\"计算机硬件结构\"></a>计算机硬件结构</h2><p>一些基本的计算机概念</p>\n<ol>\n<li>硬件和软件在逻辑功能上是等效的——如Linux环境下的硬件文件</li>\n<li>只有机械语言是能够被计算机直接执行的</li>\n</ol>\n<h3 id=\"冯-偌伊曼机\"><a href=\"#冯-偌伊曼机\" class=\"headerlink\" title=\"冯-偌伊曼机\"></a>冯-偌伊曼机</h3><p>“<strong>存储程序</strong>” 的概念是指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240716234029843.png\" alt=\"冯偌伊曼机概念图\"></p>\n<p>冯偌伊曼机的重要特点：</p>\n<ol>\n<li><strong>以运算器为中心</strong></li>\n</ol>\n<h3 id=\"现代计算机基本结构\"><a href=\"#现代计算机基本结构\" class=\"headerlink\" title=\"现代计算机基本结构\"></a>现代计算机基本结构</h3><p><img src=\"https://s2.loli.net/2024/07/16/dkTaHsC3JZWDp7b.png\" alt=\"现代计算机基本结构\"></p>\n<p>现代计算机的重要特点：<strong>以存储器为中心</strong></p>\n<h2 id=\"数据驱动方式\"><a href=\"#数据驱动方式\" class=\"headerlink\" title=\"数据驱动方式\"></a>数据驱动方式</h2><p><img src=\"https://s2.loli.net/2024/07/16/Hf17SOxtpdKFr3G.png\" alt=\"数据驱动方式\"></p>\n<p>所谓数据驱动方式即计算机是以指令到数据的还是数据到指令的</p>\n<p><img src=\"https://s2.loli.net/2024/07/16/5k68G7iMBEZycfh.png\" alt=\"按照驱动方式不同对计算机的划分\"></p>\n<h2 id=\"计算机软件\"><a href=\"#计算机软件\" class=\"headerlink\" title=\"计算机软件\"></a>计算机软件</h2><h3 id=\"系统软件和应用软件\"><a href=\"#系统软件和应用软件\" class=\"headerlink\" title=\"系统软件和应用软件\"></a>系统软件和应用软件</h3><p><strong>应用软件</strong>是为了解决某个应用领域的问题而编制的程序<br><strong>系统软件</strong>负责管理硬件资源，并向上层应用程序提供基础服务</p>\n<h3 id=\"三种级别的语言\"><a href=\"#三种级别的语言\" class=\"headerlink\" title=\"三种级别的语言\"></a>三种级别的语言</h3><p><strong>机器语言</strong>：二进制代码<br><strong>汇编语言</strong>：助记符<br><strong>高级语言</strong>：C/C++、Java、Python</p>\n<p><strong>编译程序</strong>：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次)</p>\n<p><strong>解释程序</strong>：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句 (每次执行都要翻译)，典型的代表如：js、Py、latex</p>\n<ul>\n<li>注意编译程序和解释程序的区别，编译程序时只需翻译一次的，解释程序是每次都需要翻译的</li>\n</ul>\n<h3 id=\"软件和硬件的逻辑等价性\"><a href=\"#软件和硬件的逻辑等价性\" class=\"headerlink\" title=\"软件和硬件的逻辑等价性\"></a>软件和硬件的逻辑等价性</h3><p><strong>软件和硬件的逻辑功能等价性</strong>：同一个功能，既可以用硬件实现（性能高成本高），也可以用软件实现（性能低成本也低）</p>\n<ul>\n<li>ISA： Instrument System Architecture 指令体系结构，软件和硬件之间的界面。设计计算机系统的ISA，就是要定义一台计算机可以支持哪些指令，以及每条指令的作用是什么、每条指令的用法是什么。</li>\n</ul>\n<h2 id=\"计算机的层次结构\"><a href=\"#计算机的层次结构\" class=\"headerlink\" title=\"计算机的层次结构\"></a>计算机的层次结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">\t计算机的层次结构--&gt;M4:高级语言机器-执行高级语言;</span><br><span class=\"line\">\t计算机的层次结构--&gt;M3:汇编语言机器-执行汇编语言;</span><br><span class=\"line\">\t计算机的层次结构--&gt;M2:操作系统机器-向上提供广义指令;</span><br><span class=\"line\">\t计算机的层次结构--&gt;M1:传统机器-执行机器语言指令;</span><br><span class=\"line\">\t计算机的层次结构--&gt;MO:微程序机器-执行微指令;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>计算机体系结构（如何设计硬件与软件之间的接口）——机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性(指令系统、数据类型、寻址技术、I/O机理)</p>\n</li>\n<li><p>计算机组成原理（如何用硬件实现所定义的接口）一一实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p>\n</li>\n</ul>\n<h2 id=\"计算机系统的工作原理\"><a href=\"#计算机系统的工作原理\" class=\"headerlink\" title=\"计算机系统的工作原理\"></a>计算机系统的工作原理</h2><h3 id=\"从C语言源程序到可执行文件\"><a href=\"#从C语言源程序到可执行文件\" class=\"headerlink\" title=\"从C语言源程序到可执行文件\"></a>从C语言源程序到可执行文件</h3><p><img src=\"https://s2.loli.net/2024/07/21/JE4rN9RkWPI5sC8.png\" alt=\"C编译\"></p>\n<ol>\n<li>预处理过程：对开头的命令进行处理(#define 等)</li>\n<li>编译过程：翻译高级语言为汇编语言</li>\n<li>汇编过程：翻译汇编语言为二进制机器语言</li>\n<li>链接过程：通过连接器链接库</li>\n</ol>\n<h3 id=\"计算机工作原理\"><a href=\"#计算机工作原理\" class=\"headerlink\" title=\"计算机工作原理\"></a>计算机工作原理</h3><ol>\n<li>大观</li>\n</ol>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240721123259521.png\" alt=\"计算机系统工作大观\"></p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240721123416974.png\" alt=\"存储程序工作方式\"></p>\n<h2 id=\"计算机性能指标\"><a href=\"#计算机性能指标\" class=\"headerlink\" title=\"计算机性能指标\"></a>计算机性能指标</h2><h3 id=\"存储器的性能指标\"><a href=\"#存储器的性能指标\" class=\"headerlink\" title=\"存储器的性能指标\"></a>存储器的性能指标</h3><p>MAR（Membery Address Register）存储地址寄存器：MAR位数反映存储单元的个数（最多支持多少个)</p>\n<p>MDR（Membery Data Register）存储地址寄存器：位数=存储字长=每个存储单元的大小</p>\n<h3 id=\"CPU的性能指标\"><a href=\"#CPU的性能指标\" class=\"headerlink\" title=\"CPU的性能指标\"></a>CPU的性能指标</h3><p>CPU主频：CPU内数字脉冲信号振荡的频率。$ CPU主频=\\frac{1}{CLK}$</p>\n<p>CLK（CLOCK） 表示的是CPU时钟周期</p>\n<p>CPI（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数</p>\n<p>执行一条指令的耗时=CPI$\\times$CPU时钟周期（CLK）</p>\n<p>KIPS、MIPS、IPS（Instrument Per Second）：每秒执行多少条指令 IPS= 主频$\\times$平均CPI</p>\n<p>KFLOPS、MFLOPs、FLOPs（Floating-point Operations Per Second）：每秒执行多少次浮点运算</p>\n<p>Z = 1e3E = 1e9P</p>\n<h3 id=\"系统整体的性能指标\"><a href=\"#系统整体的性能指标\" class=\"headerlink\" title=\"系统整体的性能指标\"></a>系统整体的性能指标</h3><p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p>\n<p><img src=\"https://s2.loli.net/2024/07/21/vNFnm6SXjk7o9sd.png\" alt=\"数据通路大观\"></p>\n<p>吞吐量：指系统在单位时问内处理请求的数量。</p>\n<blockquote>\n<p>它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。</p>\n</blockquote>\n<p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需<br>要的结果的等待时问。</p>\n<blockquote>\n<p>通常包括CPU时问（运行一个程序所花费的时问）与等待时问（用于磁盘访问、存储<br>器访问、I/O操作、操作系统开销等时问）。</p>\n</blockquote>\n<!-- flag of hidden posts -->","length":1505,"excerpt":"","more":"<h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><h2 id=\"计算机系统总览\"><a href=\"#计算机系统总览\" class=\"headerlink\" title=\"计算机系统总览\"></a>计算机系统总览</h2><p><img src=\"https://s2.loli.net/2024/07/16/ZmVMlK8a62QyRfg.png\" alt=\"计算机系统\"></p>\n<p>计算机系统由软件与硬件构成</p>\n<p><strong>软件</strong>分为</p>\n<ol>\n<li>系统软件</li>\n<li>应用软件</li>\n</ol>\n<p><strong>硬件</strong>分为</p>\n<ol>\n<li>存储器</li>\n<li>运算器（CPU部件）</li>\n<li>控制器（CPU部件）</li>\n<li>输入设备I</li>\n<li>输出设备O</li>\n</ol>\n<h2 id=\"计算机硬件结构\"><a href=\"#计算机硬件结构\" class=\"headerlink\" title=\"计算机硬件结构\"></a>计算机硬件结构</h2><p>一些基本的计算机概念</p>\n<ol>\n<li>硬件和软件在逻辑功能上是等效的——如Linux环境下的硬件文件</li>\n<li>只有机械语言是能够被计算机直接执行的</li>\n</ol>\n<h3 id=\"冯-偌伊曼机\"><a href=\"#冯-偌伊曼机\" class=\"headerlink\" title=\"冯-偌伊曼机\"></a>冯-偌伊曼机</h3><p>“<strong>存储程序</strong>” 的概念是指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240716234029843.png\" alt=\"冯偌伊曼机概念图\"></p>\n<p>冯偌伊曼机的重要特点：</p>\n<ol>\n<li><strong>以运算器为中心</strong></li>\n</ol>\n<h3 id=\"现代计算机基本结构\"><a href=\"#现代计算机基本结构\" class=\"headerlink\" title=\"现代计算机基本结构\"></a>现代计算机基本结构</h3><p><img src=\"https://s2.loli.net/2024/07/16/dkTaHsC3JZWDp7b.png\" alt=\"现代计算机基本结构\"></p>\n<p>现代计算机的重要特点：<strong>以存储器为中心</strong></p>\n<h2 id=\"数据驱动方式\"><a href=\"#数据驱动方式\" class=\"headerlink\" title=\"数据驱动方式\"></a>数据驱动方式</h2><p><img src=\"https://s2.loli.net/2024/07/16/Hf17SOxtpdKFr3G.png\" alt=\"数据驱动方式\"></p>\n<p>所谓数据驱动方式即计算机是以指令到数据的还是数据到指令的</p>\n<p><img src=\"https://s2.loli.net/2024/07/16/5k68G7iMBEZycfh.png\" alt=\"按照驱动方式不同对计算机的划分\"></p>\n<h2 id=\"计算机软件\"><a href=\"#计算机软件\" class=\"headerlink\" title=\"计算机软件\"></a>计算机软件</h2><h3 id=\"系统软件和应用软件\"><a href=\"#系统软件和应用软件\" class=\"headerlink\" title=\"系统软件和应用软件\"></a>系统软件和应用软件</h3><p><strong>应用软件</strong>是为了解决某个应用领域的问题而编制的程序<br><strong>系统软件</strong>负责管理硬件资源，并向上层应用程序提供基础服务</p>\n<h3 id=\"三种级别的语言\"><a href=\"#三种级别的语言\" class=\"headerlink\" title=\"三种级别的语言\"></a>三种级别的语言</h3><p><strong>机器语言</strong>：二进制代码<br><strong>汇编语言</strong>：助记符<br><strong>高级语言</strong>：C/C++、Java、Python</p>\n<p><strong>编译程序</strong>：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次)</p>\n<p><strong>解释程序</strong>：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句 (每次执行都要翻译)，典型的代表如：js、Py、latex</p>\n<ul>\n<li>注意编译程序和解释程序的区别，编译程序时只需翻译一次的，解释程序是每次都需要翻译的</li>\n</ul>\n<h3 id=\"软件和硬件的逻辑等价性\"><a href=\"#软件和硬件的逻辑等价性\" class=\"headerlink\" title=\"软件和硬件的逻辑等价性\"></a>软件和硬件的逻辑等价性</h3><p><strong>软件和硬件的逻辑功能等价性</strong>：同一个功能，既可以用硬件实现（性能高成本高），也可以用软件实现（性能低成本也低）</p>\n<ul>\n<li>ISA： Instrument System Architecture 指令体系结构，软件和硬件之间的界面。设计计算机系统的ISA，就是要定义一台计算机可以支持哪些指令，以及每条指令的作用是什么、每条指令的用法是什么。</li>\n</ul>\n<h2 id=\"计算机的层次结构\"><a href=\"#计算机的层次结构\" class=\"headerlink\" title=\"计算机的层次结构\"></a>计算机的层次结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">\t计算机的层次结构--&gt;M4:高级语言机器-执行高级语言;</span><br><span class=\"line\">\t计算机的层次结构--&gt;M3:汇编语言机器-执行汇编语言;</span><br><span class=\"line\">\t计算机的层次结构--&gt;M2:操作系统机器-向上提供广义指令;</span><br><span class=\"line\">\t计算机的层次结构--&gt;M1:传统机器-执行机器语言指令;</span><br><span class=\"line\">\t计算机的层次结构--&gt;MO:微程序机器-执行微指令;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>计算机体系结构（如何设计硬件与软件之间的接口）——机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性(指令系统、数据类型、寻址技术、I/O机理)</p>\n</li>\n<li><p>计算机组成原理（如何用硬件实现所定义的接口）一一实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p>\n</li>\n</ul>\n<h2 id=\"计算机系统的工作原理\"><a href=\"#计算机系统的工作原理\" class=\"headerlink\" title=\"计算机系统的工作原理\"></a>计算机系统的工作原理</h2><h3 id=\"从C语言源程序到可执行文件\"><a href=\"#从C语言源程序到可执行文件\" class=\"headerlink\" title=\"从C语言源程序到可执行文件\"></a>从C语言源程序到可执行文件</h3><p><img src=\"https://s2.loli.net/2024/07/21/JE4rN9RkWPI5sC8.png\" alt=\"C编译\"></p>\n<ol>\n<li>预处理过程：对开头的命令进行处理(#define 等)</li>\n<li>编译过程：翻译高级语言为汇编语言</li>\n<li>汇编过程：翻译汇编语言为二进制机器语言</li>\n<li>链接过程：通过连接器链接库</li>\n</ol>\n<h3 id=\"计算机工作原理\"><a href=\"#计算机工作原理\" class=\"headerlink\" title=\"计算机工作原理\"></a>计算机工作原理</h3><ol>\n<li>大观</li>\n</ol>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240721123259521.png\" alt=\"计算机系统工作大观\"></p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240721123416974.png\" alt=\"存储程序工作方式\"></p>\n<h2 id=\"计算机性能指标\"><a href=\"#计算机性能指标\" class=\"headerlink\" title=\"计算机性能指标\"></a>计算机性能指标</h2><h3 id=\"存储器的性能指标\"><a href=\"#存储器的性能指标\" class=\"headerlink\" title=\"存储器的性能指标\"></a>存储器的性能指标</h3><p>MAR（Membery Address Register）存储地址寄存器：MAR位数反映存储单元的个数（最多支持多少个)</p>\n<p>MDR（Membery Data Register）存储地址寄存器：位数=存储字长=每个存储单元的大小</p>\n<h3 id=\"CPU的性能指标\"><a href=\"#CPU的性能指标\" class=\"headerlink\" title=\"CPU的性能指标\"></a>CPU的性能指标</h3><p>CPU主频：CPU内数字脉冲信号振荡的频率。$ CPU主频=\\frac{1}{CLK}$</p>\n<p>CLK（CLOCK） 表示的是CPU时钟周期</p>\n<p>CPI（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数</p>\n<p>执行一条指令的耗时=CPI$\\times$CPU时钟周期（CLK）</p>\n<p>KIPS、MIPS、IPS（Instrument Per Second）：每秒执行多少条指令 IPS= 主频$\\times$平均CPI</p>\n<p>KFLOPS、MFLOPs、FLOPs（Floating-point Operations Per Second）：每秒执行多少次浮点运算</p>\n<p>Z = 1e3E = 1e9P</p>\n<h3 id=\"系统整体的性能指标\"><a href=\"#系统整体的性能指标\" class=\"headerlink\" title=\"系统整体的性能指标\"></a>系统整体的性能指标</h3><p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p>\n<p><img src=\"https://s2.loli.net/2024/07/21/vNFnm6SXjk7o9sd.png\" alt=\"数据通路大观\"></p>\n<p>吞吐量：指系统在单位时问内处理请求的数量。</p>\n<blockquote>\n<p>它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。</p>\n</blockquote>\n<p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需<br>要的结果的等待时问。</p>\n<blockquote>\n<p>通常包括CPU时问（运行一个程序所花费的时问）与等待时问（用于磁盘访问、存储<br>器访问、I/O操作、操作系统开销等时问）。</p>\n</blockquote>\n"},{"title":"计网篇-交换方式篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# 三种交换方式的性能对比\n\n1. 电路交换\n2. 报文交换\n3. 分组交换\n\n## 三种交换方式\n\n## 图示\n\n电路交换过程中的概念图如下\n\n![电路交换传播示意图](https://s2.loli.net/2024/07/08/qrWTb6KvaplNxA2.png)\n\n根据时序形成的数据交换图\n\n![image-20240715223759746](https://s2.loli.net/2024/07/15/IHZgFvET9jbqz8N.png)\n\n## 对比\n\n![对比表格](https://s2.loli.net/2024/07/15/KUyPDvbo3I24hw6.png)","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/三种交换方式.md","raw":"---\ntitle: 计网篇-交换方式篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# 三种交换方式的性能对比\n\n1. 电路交换\n2. 报文交换\n3. 分组交换\n\n## 三种交换方式\n\n## 图示\n\n电路交换过程中的概念图如下\n\n![电路交换传播示意图](https://s2.loli.net/2024/07/08/qrWTb6KvaplNxA2.png)\n\n根据时序形成的数据交换图\n\n![image-20240715223759746](https://s2.loli.net/2024/07/15/IHZgFvET9jbqz8N.png)\n\n## 对比\n\n![对比表格](https://s2.loli.net/2024/07/15/KUyPDvbo3I24hw6.png)","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/三种交换方式","published":1,"updated":"2024-08-17T13:23:20.086Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqa000mm8wv33osa11v","content":"<h1 id=\"三种交换方式的性能对比\"><a href=\"#三种交换方式的性能对比\" class=\"headerlink\" title=\"三种交换方式的性能对比\"></a>三种交换方式的性能对比</h1><ol>\n<li>电路交换</li>\n<li>报文交换</li>\n<li>分组交换</li>\n</ol>\n<h2 id=\"三种交换方式\"><a href=\"#三种交换方式\" class=\"headerlink\" title=\"三种交换方式\"></a>三种交换方式</h2><h2 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h2><p>电路交换过程中的概念图如下</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/qrWTb6KvaplNxA2.png\" alt=\"电路交换传播示意图\"></p>\n<p>根据时序形成的数据交换图</p>\n<p><img src=\"https://s2.loli.net/2024/07/15/IHZgFvET9jbqz8N.png\" alt=\"image-20240715223759746\"></p>\n<h2 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h2><p><img src=\"https://s2.loli.net/2024/07/15/KUyPDvbo3I24hw6.png\" alt=\"对比表格\"></p>\n<!-- flag of hidden posts -->","length":76,"excerpt":"","more":"<h1 id=\"三种交换方式的性能对比\"><a href=\"#三种交换方式的性能对比\" class=\"headerlink\" title=\"三种交换方式的性能对比\"></a>三种交换方式的性能对比</h1><ol>\n<li>电路交换</li>\n<li>报文交换</li>\n<li>分组交换</li>\n</ol>\n<h2 id=\"三种交换方式\"><a href=\"#三种交换方式\" class=\"headerlink\" title=\"三种交换方式\"></a>三种交换方式</h2><h2 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h2><p>电路交换过程中的概念图如下</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/qrWTb6KvaplNxA2.png\" alt=\"电路交换传播示意图\"></p>\n<p>根据时序形成的数据交换图</p>\n<p><img src=\"https://s2.loli.net/2024/07/15/IHZgFvET9jbqz8N.png\" alt=\"image-20240715223759746\"></p>\n<h2 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h2><p><img src=\"https://s2.loli.net/2024/07/15/KUyPDvbo3I24hw6.png\" alt=\"对比表格\"></p>\n"},{"title":"计组篇-补充篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"## 数据寻址方式\n\n六种基本寻址方式\n\n1. 隐含寻址：一般是将地址存储在寄存器中，通过寄存器寻址（隐含的含义是通过寄存器名而非是地址）\n2. 立即寻址：通过地址立即数寻址\n3. 直接寻址：对应的数据存储在主存中\n4. 简介寻址：两次访问主存，第一次访存地址，第二次访问数据\n5. 寄存器寻址：直接指明寄存器的编号，地址码存储在寄存器中\n6. 寄存器间接寻址：先访问寄存器，再通过寄存器中的地址码访问主存\n\n四种延申寻址方式，以下四种方式都是将数据存储在主存中，其地址需要经过一定的处理\n\n1. 相对寻址：相对当前地址惊醒寻址\n2. 基址寻址：通过整体的基址与偏移量访问地址\n3. 变址寻址：其地址是不断变化的\n4. 堆栈寻址：地址存储在堆栈中\n\n任何一种寻址方式，访问的数据都在主存当中，对地址经过（或少部分不用）处理后得到主存中的目标地址（EA enabled address 有效地址）\n\n> 有效地址EA是虚拟地址（VA visual address）还是物理地址（PA physical address）？\n>\n> **是VA。**这是因为在IR访问地址的时候，都是在CPU的PC与IR主导下进行的，而在CPU与主存间提供了一系列的内存管理机制来虚拟映射地址。\n>\n> ---\n>\n> MMU memery manage unit 内存管理单元，该单元将$\\text{VA}\\to \\text{PA}$，并且将$\\text{PA}$送入MAR（memery address register 主存地址寄存器）访问主存。\n\n\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/补充.md","raw":"---\ntitle: 计组篇-补充篇\ndate: 2024-08-14 19:47:58\ntags: [计算机组成原理, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n## 数据寻址方式\n\n六种基本寻址方式\n\n1. 隐含寻址：一般是将地址存储在寄存器中，通过寄存器寻址（隐含的含义是通过寄存器名而非是地址）\n2. 立即寻址：通过地址立即数寻址\n3. 直接寻址：对应的数据存储在主存中\n4. 简介寻址：两次访问主存，第一次访存地址，第二次访问数据\n5. 寄存器寻址：直接指明寄存器的编号，地址码存储在寄存器中\n6. 寄存器间接寻址：先访问寄存器，再通过寄存器中的地址码访问主存\n\n四种延申寻址方式，以下四种方式都是将数据存储在主存中，其地址需要经过一定的处理\n\n1. 相对寻址：相对当前地址惊醒寻址\n2. 基址寻址：通过整体的基址与偏移量访问地址\n3. 变址寻址：其地址是不断变化的\n4. 堆栈寻址：地址存储在堆栈中\n\n任何一种寻址方式，访问的数据都在主存当中，对地址经过（或少部分不用）处理后得到主存中的目标地址（EA enabled address 有效地址）\n\n> 有效地址EA是虚拟地址（VA visual address）还是物理地址（PA physical address）？\n>\n> **是VA。**这是因为在IR访问地址的时候，都是在CPU的PC与IR主导下进行的，而在CPU与主存间提供了一系列的内存管理机制来虚拟映射地址。\n>\n> ---\n>\n> MMU memery manage unit 内存管理单元，该单元将$\\text{VA}\\to \\text{PA}$，并且将$\\text{PA}$送入MAR（memery address register 主存地址寄存器）访问主存。\n\n\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/补充","published":1,"updated":"2024-08-17T13:22:53.907Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqb000om8wv8r9q0rg1","content":"<h2 id=\"数据寻址方式\"><a href=\"#数据寻址方式\" class=\"headerlink\" title=\"数据寻址方式\"></a>数据寻址方式</h2><p>六种基本寻址方式</p>\n<ol>\n<li>隐含寻址：一般是将地址存储在寄存器中，通过寄存器寻址（隐含的含义是通过寄存器名而非是地址）</li>\n<li>立即寻址：通过地址立即数寻址</li>\n<li>直接寻址：对应的数据存储在主存中</li>\n<li>简介寻址：两次访问主存，第一次访存地址，第二次访问数据</li>\n<li>寄存器寻址：直接指明寄存器的编号，地址码存储在寄存器中</li>\n<li>寄存器间接寻址：先访问寄存器，再通过寄存器中的地址码访问主存</li>\n</ol>\n<p>四种延申寻址方式，以下四种方式都是将数据存储在主存中，其地址需要经过一定的处理</p>\n<ol>\n<li>相对寻址：相对当前地址惊醒寻址</li>\n<li>基址寻址：通过整体的基址与偏移量访问地址</li>\n<li>变址寻址：其地址是不断变化的</li>\n<li>堆栈寻址：地址存储在堆栈中</li>\n</ol>\n<p>任何一种寻址方式，访问的数据都在主存当中，对地址经过（或少部分不用）处理后得到主存中的目标地址（EA enabled address 有效地址）</p>\n<blockquote>\n<p>有效地址EA是虚拟地址（VA visual address）还是物理地址（PA physical address）？</p>\n<p><strong>是VA。</strong>这是因为在IR访问地址的时候，都是在CPU的PC与IR主导下进行的，而在CPU与主存间提供了一系列的内存管理机制来虚拟映射地址。</p>\n<hr>\n<p>MMU memery manage unit 内存管理单元，该单元将$\\text{VA}\\to \\text{PA}$，并且将$\\text{PA}$送入MAR（memery address register 主存地址寄存器）访问主存。</p>\n</blockquote>\n<!-- flag of hidden posts -->","length":434,"excerpt":"","more":"<h2 id=\"数据寻址方式\"><a href=\"#数据寻址方式\" class=\"headerlink\" title=\"数据寻址方式\"></a>数据寻址方式</h2><p>六种基本寻址方式</p>\n<ol>\n<li>隐含寻址：一般是将地址存储在寄存器中，通过寄存器寻址（隐含的含义是通过寄存器名而非是地址）</li>\n<li>立即寻址：通过地址立即数寻址</li>\n<li>直接寻址：对应的数据存储在主存中</li>\n<li>简介寻址：两次访问主存，第一次访存地址，第二次访问数据</li>\n<li>寄存器寻址：直接指明寄存器的编号，地址码存储在寄存器中</li>\n<li>寄存器间接寻址：先访问寄存器，再通过寄存器中的地址码访问主存</li>\n</ol>\n<p>四种延申寻址方式，以下四种方式都是将数据存储在主存中，其地址需要经过一定的处理</p>\n<ol>\n<li>相对寻址：相对当前地址惊醒寻址</li>\n<li>基址寻址：通过整体的基址与偏移量访问地址</li>\n<li>变址寻址：其地址是不断变化的</li>\n<li>堆栈寻址：地址存储在堆栈中</li>\n</ol>\n<p>任何一种寻址方式，访问的数据都在主存当中，对地址经过（或少部分不用）处理后得到主存中的目标地址（EA enabled address 有效地址）</p>\n<blockquote>\n<p>有效地址EA是虚拟地址（VA visual address）还是物理地址（PA physical address）？</p>\n<p><strong>是VA。</strong>这是因为在IR访问地址的时候，都是在CPU的PC与IR主导下进行的，而在CPU与主存间提供了一系列的内存管理机制来虚拟映射地址。</p>\n<hr>\n<p>MMU memery manage unit 内存管理单元，该单元将$\\text{VA}\\to \\text{PA}$，并且将$\\text{PA}$送入MAR（memery address register 主存地址寄存器）访问主存。</p>\n</blockquote>\n"},{"title":"计网篇-数据链路层篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# 数据链路层\n\n数据链路层分为两个子层\n\n- 逻辑链路控制子层\n- 介质访问控制子层\n\n## 数据链路层概述\n\n**链路（Link）**就是从一个结点到相邻结点的一段物理线路，而**中间没有任何其他的交换结点**。\n\n**数据链路 （DataLink）**是指**把实现通信协议的硬件和软件加到链路上**，就构成了数据链路。\n\n数据链路层以**帧为单位**传输和处理数据。\n\n### 数据链路重要作用\n\n### 端到端情况\n\n1. 封装成帧\n\n   需要添加一个帧头和帧尾实现数据链路层的功能\n\n2. 差错检测\n\n   通过帧尾的检测码检查收到的帧是否存在差错\n\n3. 可靠传输\n\n   不一定使用，取决于上层要求\n\n   尽管误码是无法避免的，但保证发送发收什么接收方就接受什么就是可靠传输。\n\n### 广播情况\n\n![广播信道下的碰撞](https://s2.loli.net/2024/07/27/WKwRgfU8YzOt67k.png)\n\n碰撞检测与碰撞避免协议\n\n## 帧\n\n### 封装成帧\n\n封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。\n\n### 帧头帧尾的功能\n\n1. 头和帧尾中包含有重要的控制信息。\n2. 头和帧尾的作用之一就是帧定界。\n\n> 对帧定界符，如果数据本身存在帧，为了透明传输的实现，有一些特别的实现方式\n>\n> 1. 通过插入转义字符的方式实现\n> 2. 通过bit填充的方式每n个1填充0，实现不可能出现帧定界符flag\n\n### 帧长度\n\n为提高帧的传输效率，尽可能提高帧数据段长度，但也有最大帧长**MTU**\n\n## 差错检测\n\nBER（Bit Error Rate 误码率）：传输错误的比特占所传输比特总数的比率称为BER\n\n### 奇偶校验\n\n在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中“1”的个数为奇数（奇校验）或偶数（偶校验）。\n\n### 循环冗余校验\n\n循环亢余校验CRC(CyclicRedundancyCheck)\n\n1. 收发双方约定好一个生成多项式G(X)；\n2. 发送方基于待发送的数据和生成多项式计算出差错检测码（亢余码），将其添加到待传输数据的后面一起传输\n3. 接收方通过生成多项式来计算收到的数据是否产生了误码；\n\n![CRC原理图](https://s2.loli.net/2024/07/27/Gd4RPnw3JK8qHgk.png)\n\n#### 注意项\n\n1. 算法要求生成多项式必须包含0次项（常数）\n2. 除法过程中为模2减法即异或\n\n### 海明码\n\n海明码（也叫汉明码）具有一位纠错能力。本文以1010110这个二进制数为例解释海明码的编码和校验方法。\n\n#### 编码\n\n确定校验码的位数x\n\n设数据有n位，校验码有x位。则校验码一共有2x种取值方式。其中需要一种取值方式表示数据正确，剩下2x-1种取值方式表示有一位数据出错。因为编码后的二进制串有n+x位，因此x应该满足\n\n$2^x-1\\ge n+x$\n\n使不等式成立的x的最小值就是校验码的位数。在本例中，n=7，解得x=4。\n\n确定校验码的位置\n\n校验码在二进制串中的位置为2的整数幂。剩下的位置为数据。如图所示。\n\n| 位   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 内容 | x1   | x2   | 1    | x3   | 0    | 1    | 0    | x4   | 1    | 1    | 0    |\n\n上面这个位数太多了，了解结构之后还是用下面这个\n\n| 位   | 1    | 2    | 3    | 4    | 5    | 6    | 7    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 内容 | x1   | x2   | 1    | x3   | 0    | 1    | 1    |\n\n并且海明码满足以下关系（注意二进制之间的关系，很简单）\n$$\nP1（H1） = H3 ⊕ H5 ⊕ H7 \\\\\nP2（H2） = H3 ⊕ H6 ⊕ H7\\\\\nP3（H4） = H5 ⊕ H6 ⊕ H7\n$$\n\n$$\nS1 = P1 ⊕ H3 ⊕ H5 ⊕ H7；\\\\\nS2 = P2 ⊕ H3 ⊕ H6 ⊕ H7；\\\\\nS3 = P3 ⊕ H5 ⊕ H6 ⊕ H7；\\\\\nS1=S2=S3=0\n$$\n\n#### 纠错方式\n\n1. 海明码只能检测出2位错，纠1位错。\n2. 海明码默认进行偶校验(除非特殊说明使用奇校验)。\n\n当S1,S2,S3或非零时则说明数据出错，那么如何定位错误\n\n![纠错码覆盖图](https://s2.loli.net/2024/07/27/liFZ2tOf1BDbwVv.png)\n\n上图很好的说明了海明码中的纠错负责范围，请联系上面给出的方程组，推导出这个图像是充分的。\n\n若我们发现$S1 \\not = 0$ 则集合{1，3，5，7}中有一个出错，若S2,S3均为0，则1出错，同理。。。可推出任意单个错误。\n\n如何发现出两个错误呢？ 实际上，对任意集合区域的两个更改（不同位），显然无法保持S1，S2，S3均为0，对更多错误我们不做考虑。这里其实是一道有点意思的容斥证明题。\n\n## 可靠传输的基本概念\n\n### 基本概念\n\n- 使用差错检测技术（例如循环亢余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码 （ （比特错误）。\n- 数据链路层向上层提供的服务类型\n  - 不可靠传输服务： ： 仅仅丢弃有误码的帧，其他什么也不做；\n  - 可靠传输服务： 想办法实现发送端发送什么，接收端就收到什么。\n- 一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。\n- **无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务**。\n- 比特差错只是传输差错中的一种。\n- 从整个计算机网络体系结构来看，传输差错还包括**分组丢失、分组失序以及分组重复。**\n- 分组丢失、分组失序以及分组重复这些传输差错**，一般不会出现在数据链路层**，而会出现在其上层。\n- **可靠传输服务并不仅局限于数据链路层**，其他各层均可选择实现可靠传输\n\n### 三种实现可靠传输的机制协议\n\n见三种可靠传输协议[三种可靠传输协议](三种可靠传输协议.md)\n\n### 点对点PPP协议\n\n点对点协议PPP(Point-to-Point Protocol)是**目前使用最广泛的点对点数据链路层协议**。\n\nPPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：\n\n- 对各种协议数据报的封装方法（封装成顿）\n- 链路控制协议LCP——用于建立、配置以及测试数据链路的连接\n- 一套网络控制协议NCPs——其中的每一个协议支持不同的网络层协议\n\n![PPP协议](https://s2.loli.net/2024/07/28/fuZG6W5MI8sabz7.png)\n\n#### 帧格式\n\n![image-20240728233633520](https://s2.loli.net/2024/07/28/2rRwgMLKkhQuW4S.png)\n\n#### 实现透明传输的方式\n\n![透明传输方法](https://s2.loli.net/2024/07/28/1cu2qVM6GsWJgrk.png)\n\n就是前文的\n\n字节填充法\n\n1. 对每个flag7E转换为两字节(7D5E)\n2. 出现的每一个转义字符7D转换为两字节(7D5D)\n3. 每个出现ASCII的控制字符（数值小于0x2D）,则在该字符前面插入一个7D，同时将该字符的编码加上0x2f\n\n与比特0填充法。\n\n1. flag为0111110\n2. 发现五个连续的1，则填充零\n3. 只要发现五个连续的bit1就删除0\n\n#### PPP差错检测\n\nFCS，循环冗余差错检测，循环冗余检测所使用的多项式如下\n\n![FCS循环检验多项式](https://s2.loli.net/2024/07/28/FojLO4ABQmlHRaJ.png)\n\n## 媒体介入控制\n\n共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC(MediumAccess Control)\n\n![媒体介入控制](https://s2.loli.net/2024/07/28/EokcKbysS3IiUNM.png)\n\n随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局或网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。\n\n### 静态划分信号\n\nFDM，TDM，WDM，CMD\n\n频分复用，时分复用，波分复用，码分复用\n\n![FDM](https://s2.loli.net/2024/07/28/TLFHbRIdyza6Aqe.png)\n\n![TDM](https://s2.loli.net/2024/07/28/j8INQv32kMlVs6D.png)\n\nWDM波分复用实际就是光的频分复用\n\n![WDM](https://s2.loli.net/2024/07/28/dWb3hfvz75aROi4.png)\n\n码分复用CDM是另一种共享信道的方法。实际上，由于该技术主要用于多址接入型人们更常用的名词是码分多址CDMA(Code Division Multiple Access)。  \n\n同理，频分复用FDM和时分复用TDM同样可用于多址接入，相应的名词是频分多址FDMA(Frequency Division Multiple Access)和时分多址TDMA(Time Division Multiple Access)。\n\n- 复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。\n- 多址（更确切地应该称为多点接入）处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户的应用中，多址是不需要的（对于无线广播或电视广播站就是这样）。\n\n与FDM和TDM不同，**CDM的每一个用户可以在同样的时间使用同样的频带进行通信**。\n由于各用户使用经过特殊挑选的不同码型， 因此各用户之间**不会造成干扰**。\n\n使用CDMA的每一个站被指派一个唯一的mbit码片序列 J (Chip Sequence)。\n\n- 一个站如果要发送比特1，则发送它自己的mbit码片序列；\n- 一个站如果要发送比特0，则发送它自己的mbit码片序列的二进制反码；\n  码片序列的挑选原则如下：\n  1. 分配给每个站的**码片序列必须各不相同**， 实际常采用伪随机码序列。\n  2. 分配给每个站的码片序列**必须相互正交** （规格化内积为0）。\n\n> ![码分复用例题](https://s2.loli.net/2024/07/28/YvrLpEjD1hwZolu.png)\n>\n> ![码分复用例题2](https://s2.loli.net/2024/07/28/ChBnOvWeI4LpJ3Z.png)\n\n### 动态接入——随机接入\n\n### CSMA/CD 载波监听多址接入/碰撞检测\n\nCarrier Sense Multiple Access/Collision Detection\n\n![MA、CS、CD](https://s2.loli.net/2024/07/28/eFri49uRAnVmzSb.png)\n\n#### 争用期\n\n![争用期示例](https://s2.loli.net/2024/07/29/SeQaRPKi3EZzGYn.png)\n\n- 可以类比争用期与RTT的概念\n\n- 争用期的概念限制了共享式以太网中的总线长度\n\n  - 10Mb/s限制为2500ms（RTT）\n\n- 以太网规定最小**帧长为64字节**，即512bit时间为争用期\n\n  >![一个标准的MAC帧长](https://s2.loli.net/2024/07/29/w3Ty7OhWdjZ9qKJ.png)\n  >\n  >显然也是有最长帧长的\n\n- 最小顿长确保了主机可在顿发送完成之前就检测到该顿的发送过程中是否遭遇了碰撞\n\n#### 截断二进制指数退避算法\n\n![截断二进制指数退避算法](https://s2.loli.net/2024/07/29/KG6QB5onPk2C3cF.png)\n\n> ![退避示例](https://s2.loli.net/2024/07/29/4HsmKAzikS59tFw.png)\n\n- 若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述**退避算法可使重传需要推迟的平均时间随重传次数而增大**（这也称为**动态退避**），因而减小发生碰撞的概率，有利于整个系统的稳定。\n- 当重传达**16次仍**不能成功时，表明同时打算发送顿的主机太多，以至于连续发生碰撞，则丢奔该顿，并向高层报告。\n\n#### 信道利用率\n\n![定义发送帧平均时间](https://s2.loli.net/2024/07/29/eZ2CBMlKDs7Ii8Q.png)\n\n#### 整体流程图\n\n![CSMA-CD发送](https://s2.loli.net/2024/07/29/pUY9IniDLkEM3z2.png)\n\n![CSMA/CD接收](https://s2.loli.net/2024/07/29/q5ls8bxfeIMQXaN.png)\n\n### CSMA/CA 载波监听多址接入/碰撞避免\n\nCSMA/CA(Carrier Sense Multiple Access/Collision Avoidance)\n\n在无线局域网中，仍然可以使用载波监听多址接入CSMA，即在发送顿之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞。\n在无线局域网中，不能使用碰撞检测CD，原因如下：\n\n- 由于无线信道的传输条件特殊，**其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高**。\n- 即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），进行碰撞检测的意义也不大。\n\n由于不可能避免所有的碰撞 重，并且无线信道误码率较高 802.11标准还使用了**==数据链路层==****确认机制（停止-等待协议） 来保证数据被正确接收。**\n\n#### 帧间间隔IFS\n\nIFS (InterFrame Space)\n\n802.11标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送顺， 这段时间称为帧间间隔IFS。\n侦间间隔的长短取决于该站点要发送的帧的类型：\n\n- 高优先级帧需要等待的时间较短，因此可优先获得发送权；\n- 低优先级帧需要等待的时间较长。若某个站的低优先级还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级顿就只能再推迟发送了。这样就减少了发生碰撞的机会。\n\n常用的两种顺间间隔如下：\n\n- 短帧间间隔SIFS(28μs)，是最短的顿间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方切换到接收方，使用SIFS的帧类型有ACK、CTS\n- DCF帧间间隔DIFS（128$\\mu s$）：用于发送数据帧和管理帧\n\n#### 退避算法\n\n![CA](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240729002326209.png)\n\n当站点检测到信道是空闲的，并且所发送的数据顿不是成功发送完上一个数据顿之后立即连续发送的数据顿，则不使用退避算法。\n\n以下情况必须使用退避算法：\n\n- 在发送数据顿之前检测到信道处于忙状态时；\n- 在每一次重传一个数据顿时；\n- 在每一次成功发送后要连续发送下一个顿时（这是为了避免一个站点长时间占用信道）\n\n在执行退避算法时，站点为退避计时器设置一个随机的退避时间： \n\n- 当退避计时器的时间减小到零时，就开始发送数据\n- 当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间DIFS后，继续启动退避计时器。\n\n在进行第i次退避时，退避时间在时隙编号(0.1，…2^i+2^-1)中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时（对应于第6次退避）就不再增加了。\n\n![CA退避时间图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240729002759290.png)\n\n#### RTS与CTS\n\n- 除源站和目的站以外的其他各站，在收到CTS赖（或数据赖）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。\n\n- 如果RTS赖发生碰撞，**源站就收不到CTS顿，需执行退避算法重传RTS顿。**\n\n- **由于RTS帧和CTS帧很短**，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一股的数据赖，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据顿重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往**是值得的**\n\n- 使用RTS与CTS的情况\n\n  - 可以使用也可以不使用\n  - 仅仅只在帧很长时使用\n\n  >![RTS、CTS](https://s2.loli.net/2024/07/29/WLX4NRYKUkqhvzm.png)\n\n#### 隐蔽站\n\nRTS、CTS会携带通信所需时间，这称为802.11的虚拟载波监听\n\n![隐蔽站概念](https://s2.loli.net/2024/07/29/HJmPlfhaQByKCOV.png)\n\n虚拟载波监听能减少隐蔽站带来的碰撞问题\n\n![简单例题](https://s2.loli.net/2024/07/29/H51LzOEXN8ah9B2.png)\n\n![例题2](https://s2.loli.net/2024/07/29/75GdWwsSRg1etJ8.png)\n\n## MAC\\IP\\ARP\n\n- MAC地址是以太网的MAC子层所使用的地址；在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制MAC(MediaAccessControl)，因此这类地址被称为MAC地址;==数据链路层==\n\n  - MAC地址一般存储在EPROM中，因此也称为硬件地址\n\n  - 有时也被称为物理地址，但他属于==数据链路层==\n\n  - 严格来说MAC地址是对**网络上各接口的唯一标识**而不是对网络上各设备的唯一标识\n\n  - 由6个字节48个位组成\n\n  - bit 发送顺序，由第一字节发送至第六字节\n\n  - 不具备区分不同网络的功能\n\n    ![MAC](https://s2.loli.net/2024/07/29/NrdYQmELIpsGKVO.png)\n\n    00-00-00-00-00-00/00:00:00:00:00:00\n\n- IP地址是TCP/IP体系结构网际层所使用的地址；==网络层==\n\n  - 网络编号： ： 标识因特网上数以百万计的网络\n  - 主机编号： 标识同一网络上不同主机(或路由器各接口) \n\n  ![MAC与IP](https://s2.loli.net/2024/07/29/qSw6lhVGkEZij2N.png)\n\n  - 数据包转发过程中源IP地址和目的IP地址保持不变；\n  - 数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变;\n\n- ARP协议(地址解析协议Address Resolute Potrol)属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址；==网络层==\n\n  ARP 高速缓存\n\n  - 动态：自动获取，两种生命周期\n  - 静态，手工设置，不同状态下设置不同生命周期\n  - ARP无法跨网络使用\n\n- 尽管**IP地址和ARP协议属于TCP/IP体系结构的网际层**（而不属于数据链路层），但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议。因此，我们将这三者放在一起讨论。\n\n## 交换器与集线器的区别\n\n- 使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA/CD协议；\n- 集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）；\n- 集线器一般都有**少量的容错能力和网络管理功能**。例如，若网络中某个网卡出了故障，不停地发送顿。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作。\n- 以太网交换机通常都有多个接口。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在**全双工方式**。\n- 以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA/CD协议）。\n- 以太网交换机**工作在数据链路层**（也包括物理层），它收到帧后，在顿交换表中查找顿的目的MAC地址所对应的接口号，然后通过该接口转发顿。\n\n![交换器与集线器](https://s2.loli.net/2024/07/29/Yb31GxuD6jnZqcw.png)\n\n### 交换机如何自学习帧交换表\n\n- 交换机的学习过程是记录**来源MAC与对应的接口**\n- 若交换表中不存在地址则盲目泛洪\n- 对同一交换机下的主机，同样会记录帧交换表\n- 帧交换表中每条记录都有自己的有效时间\n- **明确丢弃**：交换机知道不应该转发该帧，将其丢弃\n\n### 交换机的生成树STP\n\n- 冗余链路的概念，对生成树添加额外的边，使其存在环\n- 广播风暴：在网络环路中存在的循环转发帧\n  1. 大量消耗网络资源\n  2. 大量消耗主机资源\n  3. 帧交换表震荡（漂移）\n\nSpanning Tree Protocol生成树协议。\n\n- 计算构建一个逻辑上无环路网络\n- 物理拓扑发生变化时，生成树将重新计算\n\n## VLAN虚拟局域网\n\nVirtual Local Area Network\n\n虚拟局域网VLAN(VirtualLocalAreaNetwork)是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术 这些逻辑组具有某些共同的需求\n\n- 以太网交换机工作在数据链路层（也包括物理层）\n\n- 使用一个或多个以太网交换机互联的站点都属于一个广播域\n- 分割广播域的方式\n  - 使用路由器\n\n### 实现方式\n\n#### IEEE 802.1Q帧\n\n它对以太网的MAC帧格式进行了扩展，插入了4字节的VLAN标记\n\n![IEEE 802.1Q帧](./../../../../SelfLreaning/AddtionalBlog/xjTRstbzHfKWgZ5.png)\n\n- VLAN标记的最后12bit称为VLAN标识符VID，其唯一地标识了以太网帧属于哪一个VLAN\n  - VID地取值范围位0-2^12^-1,0与2^12^都不用来表示VLAN，因此有效VID不包含0，与4095\n- 801.1Q帧是由交换机处理的，而非用户主机处理的\n  - 当交换机收到普通地以太网帧时，插入4字节地VLAN标记称为“打标签”\n  - 当转发801.1Q帧时，可能会删除其4字节地VLAN标记称为“去标签”\n\n### 交换机地端口类型\n\n交换机端口类型有以下三种：\n\n- Access\n  - 一般用于连接用户计算机\n  - 只能属于一个VLAN\n  - PVID与端口所属VLAN的ID相同（默认为1）\n  - 发送处理方法：若帧中的VID与端口的PVID相等，则“去标签”并转发该帧；否则不转发\n  - 接受处理方法：一般只接受“未打标签”的普通MAC帧然后”打标签“\n\n  ![Access端口](https://s2.loli.net/2024/08/01/z72sfcOmaRCSZyE.png)\n  \n- Trunk\n  - Trunk端口一般用于交换机之间或交换机与路由器之间的互连\n  \n  - Trunk端口可以属于多个VLAN\n  \n  - 用户可以设置Trunk端口的PVID值，默认情况下，Trunk端口的PVID值为1\n\n  - 发送处理方法：\n  \n    对VID等于PVID的帧，“去标签”再转发；\n  \n    对VID不等于PVID的帧，直接转发\n  \n  - 接受处理方法：\n  \n    接受“未打标签”的帧，根据接受帧的端口的PVID给帧“打标签”\n  \n    接受已打标签的帧\n  \n  ![Trunk端口](https://s2.loli.net/2024/08/01/YcP7rCpRhOqgi9k.png)\n  \n- Hybrid华为专用端口\n\n  - 既可用于与主机的连接，也可用于交换机之间的互联\n\n  - Hybrid端口可以属于多个VLAN（同Trun端口)\n\n  - 用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1(同Trun端口)\n\n  - 发送处理方法（与Trunk端口不同）：查看顿的VID是否在端口的 “去标签”列表中：\n\n    若存在，则“去标签”后再转发；\n\n    若不存在，则直接转发；\n\n  - 端口接收处理方法（同Trunk端口)\n\n    接收“未打标签”的帧，根据接收帧的端口的PVID给顿“打标签”\n\n    接收“已打标签的帧”\n\n  ![Hybrid端口](https://s2.loli.net/2024/08/01/h57WjMaSuAnPwiq.png)\n\n交换端口缺省VLAN ID\n\n- 思科交换机上称为Native VLAN，即本征VLAN\n- 华为交换机上称为Port VLAN ID,即端口VLAN ID，简称位PVID\n\n\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/数据链路层.md","raw":"---\ntitle: 计网篇-数据链路层篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# 数据链路层\n\n数据链路层分为两个子层\n\n- 逻辑链路控制子层\n- 介质访问控制子层\n\n## 数据链路层概述\n\n**链路（Link）**就是从一个结点到相邻结点的一段物理线路，而**中间没有任何其他的交换结点**。\n\n**数据链路 （DataLink）**是指**把实现通信协议的硬件和软件加到链路上**，就构成了数据链路。\n\n数据链路层以**帧为单位**传输和处理数据。\n\n### 数据链路重要作用\n\n### 端到端情况\n\n1. 封装成帧\n\n   需要添加一个帧头和帧尾实现数据链路层的功能\n\n2. 差错检测\n\n   通过帧尾的检测码检查收到的帧是否存在差错\n\n3. 可靠传输\n\n   不一定使用，取决于上层要求\n\n   尽管误码是无法避免的，但保证发送发收什么接收方就接受什么就是可靠传输。\n\n### 广播情况\n\n![广播信道下的碰撞](https://s2.loli.net/2024/07/27/WKwRgfU8YzOt67k.png)\n\n碰撞检测与碰撞避免协议\n\n## 帧\n\n### 封装成帧\n\n封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。\n\n### 帧头帧尾的功能\n\n1. 头和帧尾中包含有重要的控制信息。\n2. 头和帧尾的作用之一就是帧定界。\n\n> 对帧定界符，如果数据本身存在帧，为了透明传输的实现，有一些特别的实现方式\n>\n> 1. 通过插入转义字符的方式实现\n> 2. 通过bit填充的方式每n个1填充0，实现不可能出现帧定界符flag\n\n### 帧长度\n\n为提高帧的传输效率，尽可能提高帧数据段长度，但也有最大帧长**MTU**\n\n## 差错检测\n\nBER（Bit Error Rate 误码率）：传输错误的比特占所传输比特总数的比率称为BER\n\n### 奇偶校验\n\n在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中“1”的个数为奇数（奇校验）或偶数（偶校验）。\n\n### 循环冗余校验\n\n循环亢余校验CRC(CyclicRedundancyCheck)\n\n1. 收发双方约定好一个生成多项式G(X)；\n2. 发送方基于待发送的数据和生成多项式计算出差错检测码（亢余码），将其添加到待传输数据的后面一起传输\n3. 接收方通过生成多项式来计算收到的数据是否产生了误码；\n\n![CRC原理图](https://s2.loli.net/2024/07/27/Gd4RPnw3JK8qHgk.png)\n\n#### 注意项\n\n1. 算法要求生成多项式必须包含0次项（常数）\n2. 除法过程中为模2减法即异或\n\n### 海明码\n\n海明码（也叫汉明码）具有一位纠错能力。本文以1010110这个二进制数为例解释海明码的编码和校验方法。\n\n#### 编码\n\n确定校验码的位数x\n\n设数据有n位，校验码有x位。则校验码一共有2x种取值方式。其中需要一种取值方式表示数据正确，剩下2x-1种取值方式表示有一位数据出错。因为编码后的二进制串有n+x位，因此x应该满足\n\n$2^x-1\\ge n+x$\n\n使不等式成立的x的最小值就是校验码的位数。在本例中，n=7，解得x=4。\n\n确定校验码的位置\n\n校验码在二进制串中的位置为2的整数幂。剩下的位置为数据。如图所示。\n\n| 位   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 内容 | x1   | x2   | 1    | x3   | 0    | 1    | 0    | x4   | 1    | 1    | 0    |\n\n上面这个位数太多了，了解结构之后还是用下面这个\n\n| 位   | 1    | 2    | 3    | 4    | 5    | 6    | 7    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 内容 | x1   | x2   | 1    | x3   | 0    | 1    | 1    |\n\n并且海明码满足以下关系（注意二进制之间的关系，很简单）\n$$\nP1（H1） = H3 ⊕ H5 ⊕ H7 \\\\\nP2（H2） = H3 ⊕ H6 ⊕ H7\\\\\nP3（H4） = H5 ⊕ H6 ⊕ H7\n$$\n\n$$\nS1 = P1 ⊕ H3 ⊕ H5 ⊕ H7；\\\\\nS2 = P2 ⊕ H3 ⊕ H6 ⊕ H7；\\\\\nS3 = P3 ⊕ H5 ⊕ H6 ⊕ H7；\\\\\nS1=S2=S3=0\n$$\n\n#### 纠错方式\n\n1. 海明码只能检测出2位错，纠1位错。\n2. 海明码默认进行偶校验(除非特殊说明使用奇校验)。\n\n当S1,S2,S3或非零时则说明数据出错，那么如何定位错误\n\n![纠错码覆盖图](https://s2.loli.net/2024/07/27/liFZ2tOf1BDbwVv.png)\n\n上图很好的说明了海明码中的纠错负责范围，请联系上面给出的方程组，推导出这个图像是充分的。\n\n若我们发现$S1 \\not = 0$ 则集合{1，3，5，7}中有一个出错，若S2,S3均为0，则1出错，同理。。。可推出任意单个错误。\n\n如何发现出两个错误呢？ 实际上，对任意集合区域的两个更改（不同位），显然无法保持S1，S2，S3均为0，对更多错误我们不做考虑。这里其实是一道有点意思的容斥证明题。\n\n## 可靠传输的基本概念\n\n### 基本概念\n\n- 使用差错检测技术（例如循环亢余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码 （ （比特错误）。\n- 数据链路层向上层提供的服务类型\n  - 不可靠传输服务： ： 仅仅丢弃有误码的帧，其他什么也不做；\n  - 可靠传输服务： 想办法实现发送端发送什么，接收端就收到什么。\n- 一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。\n- **无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务**。\n- 比特差错只是传输差错中的一种。\n- 从整个计算机网络体系结构来看，传输差错还包括**分组丢失、分组失序以及分组重复。**\n- 分组丢失、分组失序以及分组重复这些传输差错**，一般不会出现在数据链路层**，而会出现在其上层。\n- **可靠传输服务并不仅局限于数据链路层**，其他各层均可选择实现可靠传输\n\n### 三种实现可靠传输的机制协议\n\n见三种可靠传输协议[三种可靠传输协议](三种可靠传输协议.md)\n\n### 点对点PPP协议\n\n点对点协议PPP(Point-to-Point Protocol)是**目前使用最广泛的点对点数据链路层协议**。\n\nPPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：\n\n- 对各种协议数据报的封装方法（封装成顿）\n- 链路控制协议LCP——用于建立、配置以及测试数据链路的连接\n- 一套网络控制协议NCPs——其中的每一个协议支持不同的网络层协议\n\n![PPP协议](https://s2.loli.net/2024/07/28/fuZG6W5MI8sabz7.png)\n\n#### 帧格式\n\n![image-20240728233633520](https://s2.loli.net/2024/07/28/2rRwgMLKkhQuW4S.png)\n\n#### 实现透明传输的方式\n\n![透明传输方法](https://s2.loli.net/2024/07/28/1cu2qVM6GsWJgrk.png)\n\n就是前文的\n\n字节填充法\n\n1. 对每个flag7E转换为两字节(7D5E)\n2. 出现的每一个转义字符7D转换为两字节(7D5D)\n3. 每个出现ASCII的控制字符（数值小于0x2D）,则在该字符前面插入一个7D，同时将该字符的编码加上0x2f\n\n与比特0填充法。\n\n1. flag为0111110\n2. 发现五个连续的1，则填充零\n3. 只要发现五个连续的bit1就删除0\n\n#### PPP差错检测\n\nFCS，循环冗余差错检测，循环冗余检测所使用的多项式如下\n\n![FCS循环检验多项式](https://s2.loli.net/2024/07/28/FojLO4ABQmlHRaJ.png)\n\n## 媒体介入控制\n\n共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC(MediumAccess Control)\n\n![媒体介入控制](https://s2.loli.net/2024/07/28/EokcKbysS3IiUNM.png)\n\n随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局或网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。\n\n### 静态划分信号\n\nFDM，TDM，WDM，CMD\n\n频分复用，时分复用，波分复用，码分复用\n\n![FDM](https://s2.loli.net/2024/07/28/TLFHbRIdyza6Aqe.png)\n\n![TDM](https://s2.loli.net/2024/07/28/j8INQv32kMlVs6D.png)\n\nWDM波分复用实际就是光的频分复用\n\n![WDM](https://s2.loli.net/2024/07/28/dWb3hfvz75aROi4.png)\n\n码分复用CDM是另一种共享信道的方法。实际上，由于该技术主要用于多址接入型人们更常用的名词是码分多址CDMA(Code Division Multiple Access)。  \n\n同理，频分复用FDM和时分复用TDM同样可用于多址接入，相应的名词是频分多址FDMA(Frequency Division Multiple Access)和时分多址TDMA(Time Division Multiple Access)。\n\n- 复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。\n- 多址（更确切地应该称为多点接入）处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户的应用中，多址是不需要的（对于无线广播或电视广播站就是这样）。\n\n与FDM和TDM不同，**CDM的每一个用户可以在同样的时间使用同样的频带进行通信**。\n由于各用户使用经过特殊挑选的不同码型， 因此各用户之间**不会造成干扰**。\n\n使用CDMA的每一个站被指派一个唯一的mbit码片序列 J (Chip Sequence)。\n\n- 一个站如果要发送比特1，则发送它自己的mbit码片序列；\n- 一个站如果要发送比特0，则发送它自己的mbit码片序列的二进制反码；\n  码片序列的挑选原则如下：\n  1. 分配给每个站的**码片序列必须各不相同**， 实际常采用伪随机码序列。\n  2. 分配给每个站的码片序列**必须相互正交** （规格化内积为0）。\n\n> ![码分复用例题](https://s2.loli.net/2024/07/28/YvrLpEjD1hwZolu.png)\n>\n> ![码分复用例题2](https://s2.loli.net/2024/07/28/ChBnOvWeI4LpJ3Z.png)\n\n### 动态接入——随机接入\n\n### CSMA/CD 载波监听多址接入/碰撞检测\n\nCarrier Sense Multiple Access/Collision Detection\n\n![MA、CS、CD](https://s2.loli.net/2024/07/28/eFri49uRAnVmzSb.png)\n\n#### 争用期\n\n![争用期示例](https://s2.loli.net/2024/07/29/SeQaRPKi3EZzGYn.png)\n\n- 可以类比争用期与RTT的概念\n\n- 争用期的概念限制了共享式以太网中的总线长度\n\n  - 10Mb/s限制为2500ms（RTT）\n\n- 以太网规定最小**帧长为64字节**，即512bit时间为争用期\n\n  >![一个标准的MAC帧长](https://s2.loli.net/2024/07/29/w3Ty7OhWdjZ9qKJ.png)\n  >\n  >显然也是有最长帧长的\n\n- 最小顿长确保了主机可在顿发送完成之前就检测到该顿的发送过程中是否遭遇了碰撞\n\n#### 截断二进制指数退避算法\n\n![截断二进制指数退避算法](https://s2.loli.net/2024/07/29/KG6QB5onPk2C3cF.png)\n\n> ![退避示例](https://s2.loli.net/2024/07/29/4HsmKAzikS59tFw.png)\n\n- 若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述**退避算法可使重传需要推迟的平均时间随重传次数而增大**（这也称为**动态退避**），因而减小发生碰撞的概率，有利于整个系统的稳定。\n- 当重传达**16次仍**不能成功时，表明同时打算发送顿的主机太多，以至于连续发生碰撞，则丢奔该顿，并向高层报告。\n\n#### 信道利用率\n\n![定义发送帧平均时间](https://s2.loli.net/2024/07/29/eZ2CBMlKDs7Ii8Q.png)\n\n#### 整体流程图\n\n![CSMA-CD发送](https://s2.loli.net/2024/07/29/pUY9IniDLkEM3z2.png)\n\n![CSMA/CD接收](https://s2.loli.net/2024/07/29/q5ls8bxfeIMQXaN.png)\n\n### CSMA/CA 载波监听多址接入/碰撞避免\n\nCSMA/CA(Carrier Sense Multiple Access/Collision Avoidance)\n\n在无线局域网中，仍然可以使用载波监听多址接入CSMA，即在发送顿之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞。\n在无线局域网中，不能使用碰撞检测CD，原因如下：\n\n- 由于无线信道的传输条件特殊，**其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高**。\n- 即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），进行碰撞检测的意义也不大。\n\n由于不可能避免所有的碰撞 重，并且无线信道误码率较高 802.11标准还使用了**==数据链路层==****确认机制（停止-等待协议） 来保证数据被正确接收。**\n\n#### 帧间间隔IFS\n\nIFS (InterFrame Space)\n\n802.11标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送顺， 这段时间称为帧间间隔IFS。\n侦间间隔的长短取决于该站点要发送的帧的类型：\n\n- 高优先级帧需要等待的时间较短，因此可优先获得发送权；\n- 低优先级帧需要等待的时间较长。若某个站的低优先级还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级顿就只能再推迟发送了。这样就减少了发生碰撞的机会。\n\n常用的两种顺间间隔如下：\n\n- 短帧间间隔SIFS(28μs)，是最短的顿间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方切换到接收方，使用SIFS的帧类型有ACK、CTS\n- DCF帧间间隔DIFS（128$\\mu s$）：用于发送数据帧和管理帧\n\n#### 退避算法\n\n![CA](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240729002326209.png)\n\n当站点检测到信道是空闲的，并且所发送的数据顿不是成功发送完上一个数据顿之后立即连续发送的数据顿，则不使用退避算法。\n\n以下情况必须使用退避算法：\n\n- 在发送数据顿之前检测到信道处于忙状态时；\n- 在每一次重传一个数据顿时；\n- 在每一次成功发送后要连续发送下一个顿时（这是为了避免一个站点长时间占用信道）\n\n在执行退避算法时，站点为退避计时器设置一个随机的退避时间： \n\n- 当退避计时器的时间减小到零时，就开始发送数据\n- 当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间DIFS后，继续启动退避计时器。\n\n在进行第i次退避时，退避时间在时隙编号(0.1，…2^i+2^-1)中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时（对应于第6次退避）就不再增加了。\n\n![CA退避时间图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240729002759290.png)\n\n#### RTS与CTS\n\n- 除源站和目的站以外的其他各站，在收到CTS赖（或数据赖）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。\n\n- 如果RTS赖发生碰撞，**源站就收不到CTS顿，需执行退避算法重传RTS顿。**\n\n- **由于RTS帧和CTS帧很短**，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一股的数据赖，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据顿重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往**是值得的**\n\n- 使用RTS与CTS的情况\n\n  - 可以使用也可以不使用\n  - 仅仅只在帧很长时使用\n\n  >![RTS、CTS](https://s2.loli.net/2024/07/29/WLX4NRYKUkqhvzm.png)\n\n#### 隐蔽站\n\nRTS、CTS会携带通信所需时间，这称为802.11的虚拟载波监听\n\n![隐蔽站概念](https://s2.loli.net/2024/07/29/HJmPlfhaQByKCOV.png)\n\n虚拟载波监听能减少隐蔽站带来的碰撞问题\n\n![简单例题](https://s2.loli.net/2024/07/29/H51LzOEXN8ah9B2.png)\n\n![例题2](https://s2.loli.net/2024/07/29/75GdWwsSRg1etJ8.png)\n\n## MAC\\IP\\ARP\n\n- MAC地址是以太网的MAC子层所使用的地址；在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制MAC(MediaAccessControl)，因此这类地址被称为MAC地址;==数据链路层==\n\n  - MAC地址一般存储在EPROM中，因此也称为硬件地址\n\n  - 有时也被称为物理地址，但他属于==数据链路层==\n\n  - 严格来说MAC地址是对**网络上各接口的唯一标识**而不是对网络上各设备的唯一标识\n\n  - 由6个字节48个位组成\n\n  - bit 发送顺序，由第一字节发送至第六字节\n\n  - 不具备区分不同网络的功能\n\n    ![MAC](https://s2.loli.net/2024/07/29/NrdYQmELIpsGKVO.png)\n\n    00-00-00-00-00-00/00:00:00:00:00:00\n\n- IP地址是TCP/IP体系结构网际层所使用的地址；==网络层==\n\n  - 网络编号： ： 标识因特网上数以百万计的网络\n  - 主机编号： 标识同一网络上不同主机(或路由器各接口) \n\n  ![MAC与IP](https://s2.loli.net/2024/07/29/qSw6lhVGkEZij2N.png)\n\n  - 数据包转发过程中源IP地址和目的IP地址保持不变；\n  - 数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变;\n\n- ARP协议(地址解析协议Address Resolute Potrol)属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址；==网络层==\n\n  ARP 高速缓存\n\n  - 动态：自动获取，两种生命周期\n  - 静态，手工设置，不同状态下设置不同生命周期\n  - ARP无法跨网络使用\n\n- 尽管**IP地址和ARP协议属于TCP/IP体系结构的网际层**（而不属于数据链路层），但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议。因此，我们将这三者放在一起讨论。\n\n## 交换器与集线器的区别\n\n- 使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA/CD协议；\n- 集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）；\n- 集线器一般都有**少量的容错能力和网络管理功能**。例如，若网络中某个网卡出了故障，不停地发送顿。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作。\n- 以太网交换机通常都有多个接口。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在**全双工方式**。\n- 以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA/CD协议）。\n- 以太网交换机**工作在数据链路层**（也包括物理层），它收到帧后，在顿交换表中查找顿的目的MAC地址所对应的接口号，然后通过该接口转发顿。\n\n![交换器与集线器](https://s2.loli.net/2024/07/29/Yb31GxuD6jnZqcw.png)\n\n### 交换机如何自学习帧交换表\n\n- 交换机的学习过程是记录**来源MAC与对应的接口**\n- 若交换表中不存在地址则盲目泛洪\n- 对同一交换机下的主机，同样会记录帧交换表\n- 帧交换表中每条记录都有自己的有效时间\n- **明确丢弃**：交换机知道不应该转发该帧，将其丢弃\n\n### 交换机的生成树STP\n\n- 冗余链路的概念，对生成树添加额外的边，使其存在环\n- 广播风暴：在网络环路中存在的循环转发帧\n  1. 大量消耗网络资源\n  2. 大量消耗主机资源\n  3. 帧交换表震荡（漂移）\n\nSpanning Tree Protocol生成树协议。\n\n- 计算构建一个逻辑上无环路网络\n- 物理拓扑发生变化时，生成树将重新计算\n\n## VLAN虚拟局域网\n\nVirtual Local Area Network\n\n虚拟局域网VLAN(VirtualLocalAreaNetwork)是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术 这些逻辑组具有某些共同的需求\n\n- 以太网交换机工作在数据链路层（也包括物理层）\n\n- 使用一个或多个以太网交换机互联的站点都属于一个广播域\n- 分割广播域的方式\n  - 使用路由器\n\n### 实现方式\n\n#### IEEE 802.1Q帧\n\n它对以太网的MAC帧格式进行了扩展，插入了4字节的VLAN标记\n\n![IEEE 802.1Q帧](./../../../../SelfLreaning/AddtionalBlog/xjTRstbzHfKWgZ5.png)\n\n- VLAN标记的最后12bit称为VLAN标识符VID，其唯一地标识了以太网帧属于哪一个VLAN\n  - VID地取值范围位0-2^12^-1,0与2^12^都不用来表示VLAN，因此有效VID不包含0，与4095\n- 801.1Q帧是由交换机处理的，而非用户主机处理的\n  - 当交换机收到普通地以太网帧时，插入4字节地VLAN标记称为“打标签”\n  - 当转发801.1Q帧时，可能会删除其4字节地VLAN标记称为“去标签”\n\n### 交换机地端口类型\n\n交换机端口类型有以下三种：\n\n- Access\n  - 一般用于连接用户计算机\n  - 只能属于一个VLAN\n  - PVID与端口所属VLAN的ID相同（默认为1）\n  - 发送处理方法：若帧中的VID与端口的PVID相等，则“去标签”并转发该帧；否则不转发\n  - 接受处理方法：一般只接受“未打标签”的普通MAC帧然后”打标签“\n\n  ![Access端口](https://s2.loli.net/2024/08/01/z72sfcOmaRCSZyE.png)\n  \n- Trunk\n  - Trunk端口一般用于交换机之间或交换机与路由器之间的互连\n  \n  - Trunk端口可以属于多个VLAN\n  \n  - 用户可以设置Trunk端口的PVID值，默认情况下，Trunk端口的PVID值为1\n\n  - 发送处理方法：\n  \n    对VID等于PVID的帧，“去标签”再转发；\n  \n    对VID不等于PVID的帧，直接转发\n  \n  - 接受处理方法：\n  \n    接受“未打标签”的帧，根据接受帧的端口的PVID给帧“打标签”\n  \n    接受已打标签的帧\n  \n  ![Trunk端口](https://s2.loli.net/2024/08/01/YcP7rCpRhOqgi9k.png)\n  \n- Hybrid华为专用端口\n\n  - 既可用于与主机的连接，也可用于交换机之间的互联\n\n  - Hybrid端口可以属于多个VLAN（同Trun端口)\n\n  - 用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1(同Trun端口)\n\n  - 发送处理方法（与Trunk端口不同）：查看顿的VID是否在端口的 “去标签”列表中：\n\n    若存在，则“去标签”后再转发；\n\n    若不存在，则直接转发；\n\n  - 端口接收处理方法（同Trunk端口)\n\n    接收“未打标签”的帧，根据接收帧的端口的PVID给顿“打标签”\n\n    接收“已打标签的帧”\n\n  ![Hybrid端口](https://s2.loli.net/2024/08/01/h57WjMaSuAnPwiq.png)\n\n交换端口缺省VLAN ID\n\n- 思科交换机上称为Native VLAN，即本征VLAN\n- 华为交换机上称为Port VLAN ID,即端口VLAN ID，简称位PVID\n\n\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/数据链路层","published":1,"updated":"2024-08-17T13:24:05.623Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqc000rm8wv9528acht","content":"<h1 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h1><p>数据链路层分为两个子层</p>\n<ul>\n<li>逻辑链路控制子层</li>\n<li>介质访问控制子层</li>\n</ul>\n<h2 id=\"数据链路层概述\"><a href=\"#数据链路层概述\" class=\"headerlink\" title=\"数据链路层概述\"></a>数据链路层概述</h2><p><strong>链路（Link）</strong>就是从一个结点到相邻结点的一段物理线路，而<strong>中间没有任何其他的交换结点</strong>。</p>\n<p><strong>数据链路 （DataLink）</strong>是指<strong>把实现通信协议的硬件和软件加到链路上</strong>，就构成了数据链路。</p>\n<p>数据链路层以<strong>帧为单位</strong>传输和处理数据。</p>\n<h3 id=\"数据链路重要作用\"><a href=\"#数据链路重要作用\" class=\"headerlink\" title=\"数据链路重要作用\"></a>数据链路重要作用</h3><h3 id=\"端到端情况\"><a href=\"#端到端情况\" class=\"headerlink\" title=\"端到端情况\"></a>端到端情况</h3><ol>\n<li><p>封装成帧</p>\n<p>需要添加一个帧头和帧尾实现数据链路层的功能</p>\n</li>\n<li><p>差错检测</p>\n<p>通过帧尾的检测码检查收到的帧是否存在差错</p>\n</li>\n<li><p>可靠传输</p>\n<p>不一定使用，取决于上层要求</p>\n<p>尽管误码是无法避免的，但保证发送发收什么接收方就接受什么就是可靠传输。</p>\n</li>\n</ol>\n<h3 id=\"广播情况\"><a href=\"#广播情况\" class=\"headerlink\" title=\"广播情况\"></a>广播情况</h3><p><img src=\"https://s2.loli.net/2024/07/27/WKwRgfU8YzOt67k.png\" alt=\"广播信道下的碰撞\"></p>\n<p>碰撞检测与碰撞避免协议</p>\n<h2 id=\"帧\"><a href=\"#帧\" class=\"headerlink\" title=\"帧\"></a>帧</h2><h3 id=\"封装成帧\"><a href=\"#封装成帧\" class=\"headerlink\" title=\"封装成帧\"></a>封装成帧</h3><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。</p>\n<h3 id=\"帧头帧尾的功能\"><a href=\"#帧头帧尾的功能\" class=\"headerlink\" title=\"帧头帧尾的功能\"></a>帧头帧尾的功能</h3><ol>\n<li>头和帧尾中包含有重要的控制信息。</li>\n<li>头和帧尾的作用之一就是帧定界。</li>\n</ol>\n<blockquote>\n<p>对帧定界符，如果数据本身存在帧，为了透明传输的实现，有一些特别的实现方式</p>\n<ol>\n<li>通过插入转义字符的方式实现</li>\n<li>通过bit填充的方式每n个1填充0，实现不可能出现帧定界符flag</li>\n</ol>\n</blockquote>\n<h3 id=\"帧长度\"><a href=\"#帧长度\" class=\"headerlink\" title=\"帧长度\"></a>帧长度</h3><p>为提高帧的传输效率，尽可能提高帧数据段长度，但也有最大帧长<strong>MTU</strong></p>\n<h2 id=\"差错检测\"><a href=\"#差错检测\" class=\"headerlink\" title=\"差错检测\"></a>差错检测</h2><p>BER（Bit Error Rate 误码率）：传输错误的比特占所传输比特总数的比率称为BER</p>\n<h3 id=\"奇偶校验\"><a href=\"#奇偶校验\" class=\"headerlink\" title=\"奇偶校验\"></a>奇偶校验</h3><p>在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中“1”的个数为奇数（奇校验）或偶数（偶校验）。</p>\n<h3 id=\"循环冗余校验\"><a href=\"#循环冗余校验\" class=\"headerlink\" title=\"循环冗余校验\"></a>循环冗余校验</h3><p>循环亢余校验CRC(CyclicRedundancyCheck)</p>\n<ol>\n<li>收发双方约定好一个生成多项式G(X)；</li>\n<li>发送方基于待发送的数据和生成多项式计算出差错检测码（亢余码），将其添加到待传输数据的后面一起传输</li>\n<li>接收方通过生成多项式来计算收到的数据是否产生了误码；</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/27/Gd4RPnw3JK8qHgk.png\" alt=\"CRC原理图\"></p>\n<h4 id=\"注意项\"><a href=\"#注意项\" class=\"headerlink\" title=\"注意项\"></a>注意项</h4><ol>\n<li>算法要求生成多项式必须包含0次项（常数）</li>\n<li>除法过程中为模2减法即异或</li>\n</ol>\n<h3 id=\"海明码\"><a href=\"#海明码\" class=\"headerlink\" title=\"海明码\"></a>海明码</h3><p>海明码（也叫汉明码）具有一位纠错能力。本文以1010110这个二进制数为例解释海明码的编码和校验方法。</p>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><p>确定校验码的位数x</p>\n<p>设数据有n位，校验码有x位。则校验码一共有2x种取值方式。其中需要一种取值方式表示数据正确，剩下2x-1种取值方式表示有一位数据出错。因为编码后的二进制串有n+x位，因此x应该满足</p>\n<p>$2^x-1\\ge n+x$</p>\n<p>使不等式成立的x的最小值就是校验码的位数。在本例中，n=7，解得x=4。</p>\n<p>确定校验码的位置</p>\n<p>校验码在二进制串中的位置为2的整数幂。剩下的位置为数据。如图所示。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>位</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内容</td>\n<td>x1</td>\n<td>x2</td>\n<td>1</td>\n<td>x3</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>x4</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>上面这个位数太多了，了解结构之后还是用下面这个</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>位</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内容</td>\n<td>x1</td>\n<td>x2</td>\n<td>1</td>\n<td>x3</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>并且海明码满足以下关系（注意二进制之间的关系，很简单）</p>\n<script type=\"math/tex; mode=display\">\nP1（H1） = H3 ⊕ H5 ⊕ H7 \\\\\nP2（H2） = H3 ⊕ H6 ⊕ H7\\\\\nP3（H4） = H5 ⊕ H6 ⊕ H7</script><script type=\"math/tex; mode=display\">\nS1 = P1 ⊕ H3 ⊕ H5 ⊕ H7；\\\\\nS2 = P2 ⊕ H3 ⊕ H6 ⊕ H7；\\\\\nS3 = P3 ⊕ H5 ⊕ H6 ⊕ H7；\\\\\nS1=S2=S3=0</script><h4 id=\"纠错方式\"><a href=\"#纠错方式\" class=\"headerlink\" title=\"纠错方式\"></a>纠错方式</h4><ol>\n<li>海明码只能检测出2位错，纠1位错。</li>\n<li>海明码默认进行偶校验(除非特殊说明使用奇校验)。</li>\n</ol>\n<p>当S1,S2,S3或非零时则说明数据出错，那么如何定位错误</p>\n<p><img src=\"https://s2.loli.net/2024/07/27/liFZ2tOf1BDbwVv.png\" alt=\"纠错码覆盖图\"></p>\n<p>上图很好的说明了海明码中的纠错负责范围，请联系上面给出的方程组，推导出这个图像是充分的。</p>\n<p>若我们发现$S1 \\not = 0$ 则集合{1，3，5，7}中有一个出错，若S2,S3均为0，则1出错，同理。。。可推出任意单个错误。</p>\n<p>如何发现出两个错误呢？ 实际上，对任意集合区域的两个更改（不同位），显然无法保持S1，S2，S3均为0，对更多错误我们不做考虑。这里其实是一道有点意思的容斥证明题。</p>\n<h2 id=\"可靠传输的基本概念\"><a href=\"#可靠传输的基本概念\" class=\"headerlink\" title=\"可靠传输的基本概念\"></a>可靠传输的基本概念</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>使用差错检测技术（例如循环亢余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码 （ （比特错误）。</li>\n<li>数据链路层向上层提供的服务类型<ul>\n<li>不可靠传输服务： ： 仅仅丢弃有误码的帧，其他什么也不做；</li>\n<li>可靠传输服务： 想办法实现发送端发送什么，接收端就收到什么。</li>\n</ul>\n</li>\n<li>一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。</li>\n<li><strong>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务</strong>。</li>\n<li>比特差错只是传输差错中的一种。</li>\n<li>从整个计算机网络体系结构来看，传输差错还包括<strong>分组丢失、分组失序以及分组重复。</strong></li>\n<li>分组丢失、分组失序以及分组重复这些传输差错<strong>，一般不会出现在数据链路层</strong>，而会出现在其上层。</li>\n<li><strong>可靠传输服务并不仅局限于数据链路层</strong>，其他各层均可选择实现可靠传输</li>\n</ul>\n<h3 id=\"三种实现可靠传输的机制协议\"><a href=\"#三种实现可靠传输的机制协议\" class=\"headerlink\" title=\"三种实现可靠传输的机制协议\"></a>三种实现可靠传输的机制协议</h3><p>见三种可靠传输协议<a href=\"三种可靠传输协议.md\">三种可靠传输协议</a></p>\n<h3 id=\"点对点PPP协议\"><a href=\"#点对点PPP协议\" class=\"headerlink\" title=\"点对点PPP协议\"></a>点对点PPP协议</h3><p>点对点协议PPP(Point-to-Point Protocol)是<strong>目前使用最广泛的点对点数据链路层协议</strong>。</p>\n<p>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</p>\n<ul>\n<li>对各种协议数据报的封装方法（封装成顿）</li>\n<li>链路控制协议LCP——用于建立、配置以及测试数据链路的连接</li>\n<li>一套网络控制协议NCPs——其中的每一个协议支持不同的网络层协议</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/07/28/fuZG6W5MI8sabz7.png\" alt=\"PPP协议\"></p>\n<h4 id=\"帧格式\"><a href=\"#帧格式\" class=\"headerlink\" title=\"帧格式\"></a>帧格式</h4><p><img src=\"https://s2.loli.net/2024/07/28/2rRwgMLKkhQuW4S.png\" alt=\"image-20240728233633520\"></p>\n<h4 id=\"实现透明传输的方式\"><a href=\"#实现透明传输的方式\" class=\"headerlink\" title=\"实现透明传输的方式\"></a>实现透明传输的方式</h4><p><img src=\"https://s2.loli.net/2024/07/28/1cu2qVM6GsWJgrk.png\" alt=\"透明传输方法\"></p>\n<p>就是前文的</p>\n<p>字节填充法</p>\n<ol>\n<li>对每个flag7E转换为两字节(7D5E)</li>\n<li>出现的每一个转义字符7D转换为两字节(7D5D)</li>\n<li>每个出现ASCII的控制字符（数值小于0x2D）,则在该字符前面插入一个7D，同时将该字符的编码加上0x2f</li>\n</ol>\n<p>与比特0填充法。</p>\n<ol>\n<li>flag为0111110</li>\n<li>发现五个连续的1，则填充零</li>\n<li>只要发现五个连续的bit1就删除0</li>\n</ol>\n<h4 id=\"PPP差错检测\"><a href=\"#PPP差错检测\" class=\"headerlink\" title=\"PPP差错检测\"></a>PPP差错检测</h4><p>FCS，循环冗余差错检测，循环冗余检测所使用的多项式如下</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/FojLO4ABQmlHRaJ.png\" alt=\"FCS循环检验多项式\"></p>\n<h2 id=\"媒体介入控制\"><a href=\"#媒体介入控制\" class=\"headerlink\" title=\"媒体介入控制\"></a>媒体介入控制</h2><p>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC(MediumAccess Control)</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/EokcKbysS3IiUNM.png\" alt=\"媒体介入控制\"></p>\n<p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局或网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</p>\n<h3 id=\"静态划分信号\"><a href=\"#静态划分信号\" class=\"headerlink\" title=\"静态划分信号\"></a>静态划分信号</h3><p>FDM，TDM，WDM，CMD</p>\n<p>频分复用，时分复用，波分复用，码分复用</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/TLFHbRIdyza6Aqe.png\" alt=\"FDM\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/28/j8INQv32kMlVs6D.png\" alt=\"TDM\"></p>\n<p>WDM波分复用实际就是光的频分复用</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/dWb3hfvz75aROi4.png\" alt=\"WDM\"></p>\n<p>码分复用CDM是另一种共享信道的方法。实际上，由于该技术主要用于多址接入型人们更常用的名词是码分多址CDMA(Code Division Multiple Access)。  </p>\n<p>同理，频分复用FDM和时分复用TDM同样可用于多址接入，相应的名词是频分多址FDMA(Frequency Division Multiple Access)和时分多址TDMA(Time Division Multiple Access)。</p>\n<ul>\n<li>复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。</li>\n<li>多址（更确切地应该称为多点接入）处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户的应用中，多址是不需要的（对于无线广播或电视广播站就是这样）。</li>\n</ul>\n<p>与FDM和TDM不同，<strong>CDM的每一个用户可以在同样的时间使用同样的频带进行通信</strong>。<br>由于各用户使用经过特殊挑选的不同码型， 因此各用户之间<strong>不会造成干扰</strong>。</p>\n<p>使用CDMA的每一个站被指派一个唯一的mbit码片序列 J (Chip Sequence)。</p>\n<ul>\n<li>一个站如果要发送比特1，则发送它自己的mbit码片序列；</li>\n<li>一个站如果要发送比特0，则发送它自己的mbit码片序列的二进制反码；<br>码片序列的挑选原则如下：<ol>\n<li>分配给每个站的<strong>码片序列必须各不相同</strong>， 实际常采用伪随机码序列。</li>\n<li>分配给每个站的码片序列<strong>必须相互正交</strong> （规格化内积为0）。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/07/28/YvrLpEjD1hwZolu.png\" alt=\"码分复用例题\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/28/ChBnOvWeI4LpJ3Z.png\" alt=\"码分复用例题2\"></p>\n</blockquote>\n<h3 id=\"动态接入——随机接入\"><a href=\"#动态接入——随机接入\" class=\"headerlink\" title=\"动态接入——随机接入\"></a>动态接入——随机接入</h3><h3 id=\"CSMA-CD-载波监听多址接入-碰撞检测\"><a href=\"#CSMA-CD-载波监听多址接入-碰撞检测\" class=\"headerlink\" title=\"CSMA/CD 载波监听多址接入/碰撞检测\"></a>CSMA/CD 载波监听多址接入/碰撞检测</h3><p>Carrier Sense Multiple Access/Collision Detection</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/eFri49uRAnVmzSb.png\" alt=\"MA、CS、CD\"></p>\n<h4 id=\"争用期\"><a href=\"#争用期\" class=\"headerlink\" title=\"争用期\"></a>争用期</h4><p><img src=\"https://s2.loli.net/2024/07/29/SeQaRPKi3EZzGYn.png\" alt=\"争用期示例\"></p>\n<ul>\n<li><p>可以类比争用期与RTT的概念</p>\n</li>\n<li><p>争用期的概念限制了共享式以太网中的总线长度</p>\n<ul>\n<li>10Mb/s限制为2500ms（RTT）</li>\n</ul>\n</li>\n<li><p>以太网规定最小<strong>帧长为64字节</strong>，即512bit时间为争用期</p>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/07/29/w3Ty7OhWdjZ9qKJ.png\" alt=\"一个标准的MAC帧长\"></p>\n<p>显然也是有最长帧长的</p>\n</blockquote>\n</li>\n<li><p>最小顿长确保了主机可在顿发送完成之前就检测到该顿的发送过程中是否遭遇了碰撞</p>\n</li>\n</ul>\n<h4 id=\"截断二进制指数退避算法\"><a href=\"#截断二进制指数退避算法\" class=\"headerlink\" title=\"截断二进制指数退避算法\"></a>截断二进制指数退避算法</h4><p><img src=\"https://s2.loli.net/2024/07/29/KG6QB5onPk2C3cF.png\" alt=\"截断二进制指数退避算法\"></p>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/07/29/4HsmKAzikS59tFw.png\" alt=\"退避示例\"></p>\n</blockquote>\n<ul>\n<li>若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述<strong>退避算法可使重传需要推迟的平均时间随重传次数而增大</strong>（这也称为<strong>动态退避</strong>），因而减小发生碰撞的概率，有利于整个系统的稳定。</li>\n<li>当重传达<strong>16次仍</strong>不能成功时，表明同时打算发送顿的主机太多，以至于连续发生碰撞，则丢奔该顿，并向高层报告。</li>\n</ul>\n<h4 id=\"信道利用率\"><a href=\"#信道利用率\" class=\"headerlink\" title=\"信道利用率\"></a>信道利用率</h4><p><img src=\"https://s2.loli.net/2024/07/29/eZ2CBMlKDs7Ii8Q.png\" alt=\"定义发送帧平均时间\"></p>\n<h4 id=\"整体流程图\"><a href=\"#整体流程图\" class=\"headerlink\" title=\"整体流程图\"></a>整体流程图</h4><p><img src=\"https://s2.loli.net/2024/07/29/pUY9IniDLkEM3z2.png\" alt=\"CSMA-CD发送\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/29/q5ls8bxfeIMQXaN.png\" alt=\"CSMA/CD接收\"></p>\n<h3 id=\"CSMA-CA-载波监听多址接入-碰撞避免\"><a href=\"#CSMA-CA-载波监听多址接入-碰撞避免\" class=\"headerlink\" title=\"CSMA/CA 载波监听多址接入/碰撞避免\"></a>CSMA/CA 载波监听多址接入/碰撞避免</h3><p>CSMA/CA(Carrier Sense Multiple Access/Collision Avoidance)</p>\n<p>在无线局域网中，仍然可以使用载波监听多址接入CSMA，即在发送顿之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞。<br>在无线局域网中，不能使用碰撞检测CD，原因如下：</p>\n<ul>\n<li>由于无线信道的传输条件特殊，<strong>其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高</strong>。</li>\n<li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），进行碰撞检测的意义也不大。</li>\n</ul>\n<p>由于不可能避免所有的碰撞 重，并且无线信道误码率较高 802.11标准还使用了<strong>==数据链路层==**</strong>确认机制（停止-等待协议） 来保证数据被正确接收。**</p>\n<h4 id=\"帧间间隔IFS\"><a href=\"#帧间间隔IFS\" class=\"headerlink\" title=\"帧间间隔IFS\"></a>帧间间隔IFS</h4><p>IFS (InterFrame Space)</p>\n<p>802.11标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送顺， 这段时间称为帧间间隔IFS。<br>侦间间隔的长短取决于该站点要发送的帧的类型：</p>\n<ul>\n<li>高优先级帧需要等待的时间较短，因此可优先获得发送权；</li>\n<li>低优先级帧需要等待的时间较长。若某个站的低优先级还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级顿就只能再推迟发送了。这样就减少了发生碰撞的机会。</li>\n</ul>\n<p>常用的两种顺间间隔如下：</p>\n<ul>\n<li>短帧间间隔SIFS(28μs)，是最短的顿间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方切换到接收方，使用SIFS的帧类型有ACK、CTS</li>\n<li>DCF帧间间隔DIFS（128$\\mu s$）：用于发送数据帧和管理帧</li>\n</ul>\n<h4 id=\"退避算法\"><a href=\"#退避算法\" class=\"headerlink\" title=\"退避算法\"></a>退避算法</h4><p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240729002326209.png\" alt=\"CA\"></p>\n<p>当站点检测到信道是空闲的，并且所发送的数据顿不是成功发送完上一个数据顿之后立即连续发送的数据顿，则不使用退避算法。</p>\n<p>以下情况必须使用退避算法：</p>\n<ul>\n<li>在发送数据顿之前检测到信道处于忙状态时；</li>\n<li>在每一次重传一个数据顿时；</li>\n<li>在每一次成功发送后要连续发送下一个顿时（这是为了避免一个站点长时间占用信道）</li>\n</ul>\n<p>在执行退避算法时，站点为退避计时器设置一个随机的退避时间： </p>\n<ul>\n<li>当退避计时器的时间减小到零时，就开始发送数据</li>\n<li>当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间DIFS后，继续启动退避计时器。</li>\n</ul>\n<p>在进行第i次退避时，退避时间在时隙编号(0.1，…2^i+2^-1)中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时（对应于第6次退避）就不再增加了。</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240729002759290.png\" alt=\"CA退避时间图\"></p>\n<h4 id=\"RTS与CTS\"><a href=\"#RTS与CTS\" class=\"headerlink\" title=\"RTS与CTS\"></a>RTS与CTS</h4><ul>\n<li><p>除源站和目的站以外的其他各站，在收到CTS赖（或数据赖）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。</p>\n</li>\n<li><p>如果RTS赖发生碰撞，<strong>源站就收不到CTS顿，需执行退避算法重传RTS顿。</strong></p>\n</li>\n<li><p><strong>由于RTS帧和CTS帧很短</strong>，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一股的数据赖，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据顿重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往<strong>是值得的</strong></p>\n</li>\n<li><p>使用RTS与CTS的情况</p>\n<ul>\n<li>可以使用也可以不使用</li>\n<li>仅仅只在帧很长时使用</li>\n</ul>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/07/29/WLX4NRYKUkqhvzm.png\" alt=\"RTS、CTS\"></p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"隐蔽站\"><a href=\"#隐蔽站\" class=\"headerlink\" title=\"隐蔽站\"></a>隐蔽站</h4><p>RTS、CTS会携带通信所需时间，这称为802.11的虚拟载波监听</p>\n<p><img src=\"https://s2.loli.net/2024/07/29/HJmPlfhaQByKCOV.png\" alt=\"隐蔽站概念\"></p>\n<p>虚拟载波监听能减少隐蔽站带来的碰撞问题</p>\n<p><img src=\"https://s2.loli.net/2024/07/29/H51LzOEXN8ah9B2.png\" alt=\"简单例题\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/29/75GdWwsSRg1etJ8.png\" alt=\"例题2\"></p>\n<h2 id=\"MAC-IP-ARP\"><a href=\"#MAC-IP-ARP\" class=\"headerlink\" title=\"MAC\\IP\\ARP\"></a>MAC\\IP\\ARP</h2><ul>\n<li><p>MAC地址是以太网的MAC子层所使用的地址；在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制MAC(MediaAccessControl)，因此这类地址被称为MAC地址;==数据链路层==</p>\n<ul>\n<li><p>MAC地址一般存储在EPROM中，因此也称为硬件地址</p>\n</li>\n<li><p>有时也被称为物理地址，但他属于==数据链路层==</p>\n</li>\n<li><p>严格来说MAC地址是对<strong>网络上各接口的唯一标识</strong>而不是对网络上各设备的唯一标识</p>\n</li>\n<li><p>由6个字节48个位组成</p>\n</li>\n<li><p>bit 发送顺序，由第一字节发送至第六字节</p>\n</li>\n<li><p>不具备区分不同网络的功能</p>\n<p><img src=\"https://s2.loli.net/2024/07/29/NrdYQmELIpsGKVO.png\" alt=\"MAC\"></p>\n<p>00-00-00-00-00-00/00:00:00:00:00:00</p>\n</li>\n</ul>\n</li>\n<li><p>IP地址是TCP/IP体系结构网际层所使用的地址；==网络层==</p>\n<ul>\n<li>网络编号： ： 标识因特网上数以百万计的网络</li>\n<li>主机编号： 标识同一网络上不同主机(或路由器各接口) </li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/07/29/qSw6lhVGkEZij2N.png\" alt=\"MAC与IP\"></p>\n<ul>\n<li>数据包转发过程中源IP地址和目的IP地址保持不变；</li>\n<li>数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变;</li>\n</ul>\n</li>\n<li><p>ARP协议(地址解析协议Address Resolute Potrol)属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址；==网络层==</p>\n<p>ARP 高速缓存</p>\n<ul>\n<li>动态：自动获取，两种生命周期</li>\n<li>静态，手工设置，不同状态下设置不同生命周期</li>\n<li>ARP无法跨网络使用</li>\n</ul>\n</li>\n<li><p>尽管<strong>IP地址和ARP协议属于TCP/IP体系结构的网际层</strong>（而不属于数据链路层），但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议。因此，我们将这三者放在一起讨论。</p>\n</li>\n</ul>\n<h2 id=\"交换器与集线器的区别\"><a href=\"#交换器与集线器的区别\" class=\"headerlink\" title=\"交换器与集线器的区别\"></a>交换器与集线器的区别</h2><ul>\n<li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA/CD协议；</li>\n<li>集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）；</li>\n<li>集线器一般都有<strong>少量的容错能力和网络管理功能</strong>。例如，若网络中某个网卡出了故障，不停地发送顿。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作。</li>\n<li>以太网交换机通常都有多个接口。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在<strong>全双工方式</strong>。</li>\n<li>以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA/CD协议）。</li>\n<li>以太网交换机<strong>工作在数据链路层</strong>（也包括物理层），它收到帧后，在顿交换表中查找顿的目的MAC地址所对应的接口号，然后通过该接口转发顿。</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/07/29/Yb31GxuD6jnZqcw.png\" alt=\"交换器与集线器\"></p>\n<h3 id=\"交换机如何自学习帧交换表\"><a href=\"#交换机如何自学习帧交换表\" class=\"headerlink\" title=\"交换机如何自学习帧交换表\"></a>交换机如何自学习帧交换表</h3><ul>\n<li>交换机的学习过程是记录<strong>来源MAC与对应的接口</strong></li>\n<li>若交换表中不存在地址则盲目泛洪</li>\n<li>对同一交换机下的主机，同样会记录帧交换表</li>\n<li>帧交换表中每条记录都有自己的有效时间</li>\n<li><strong>明确丢弃</strong>：交换机知道不应该转发该帧，将其丢弃</li>\n</ul>\n<h3 id=\"交换机的生成树STP\"><a href=\"#交换机的生成树STP\" class=\"headerlink\" title=\"交换机的生成树STP\"></a>交换机的生成树STP</h3><ul>\n<li>冗余链路的概念，对生成树添加额外的边，使其存在环</li>\n<li>广播风暴：在网络环路中存在的循环转发帧<ol>\n<li>大量消耗网络资源</li>\n<li>大量消耗主机资源</li>\n<li>帧交换表震荡（漂移）</li>\n</ol>\n</li>\n</ul>\n<p>Spanning Tree Protocol生成树协议。</p>\n<ul>\n<li>计算构建一个逻辑上无环路网络</li>\n<li>物理拓扑发生变化时，生成树将重新计算</li>\n</ul>\n<h2 id=\"VLAN虚拟局域网\"><a href=\"#VLAN虚拟局域网\" class=\"headerlink\" title=\"VLAN虚拟局域网\"></a>VLAN虚拟局域网</h2><p>Virtual Local Area Network</p>\n<p>虚拟局域网VLAN(VirtualLocalAreaNetwork)是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术 这些逻辑组具有某些共同的需求</p>\n<ul>\n<li><p>以太网交换机工作在数据链路层（也包括物理层）</p>\n</li>\n<li><p>使用一个或多个以太网交换机互联的站点都属于一个广播域</p>\n</li>\n<li>分割广播域的方式<ul>\n<li>使用路由器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><h4 id=\"IEEE-802-1Q帧\"><a href=\"#IEEE-802-1Q帧\" class=\"headerlink\" title=\"IEEE 802.1Q帧\"></a>IEEE 802.1Q帧</h4><p>它对以太网的MAC帧格式进行了扩展，插入了4字节的VLAN标记</p>\n<p><img src=\"./../../../../SelfLreaning/AddtionalBlog/xjTRstbzHfKWgZ5.png\" alt=\"IEEE 802.1Q帧\"></p>\n<ul>\n<li>VLAN标记的最后12bit称为VLAN标识符VID，其唯一地标识了以太网帧属于哪一个VLAN<ul>\n<li>VID地取值范围位0-2^12^-1,0与2^12^都不用来表示VLAN，因此有效VID不包含0，与4095</li>\n</ul>\n</li>\n<li>801.1Q帧是由交换机处理的，而非用户主机处理的<ul>\n<li>当交换机收到普通地以太网帧时，插入4字节地VLAN标记称为“打标签”</li>\n<li>当转发801.1Q帧时，可能会删除其4字节地VLAN标记称为“去标签”</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"交换机地端口类型\"><a href=\"#交换机地端口类型\" class=\"headerlink\" title=\"交换机地端口类型\"></a>交换机地端口类型</h3><p>交换机端口类型有以下三种：</p>\n<ul>\n<li><p>Access</p>\n<ul>\n<li>一般用于连接用户计算机</li>\n<li>只能属于一个VLAN</li>\n<li>PVID与端口所属VLAN的ID相同（默认为1）</li>\n<li>发送处理方法：若帧中的VID与端口的PVID相等，则“去标签”并转发该帧；否则不转发</li>\n<li>接受处理方法：一般只接受“未打标签”的普通MAC帧然后”打标签“</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/01/z72sfcOmaRCSZyE.png\" alt=\"Access端口\"></p>\n</li>\n<li><p>Trunk</p>\n<ul>\n<li><p>Trunk端口一般用于交换机之间或交换机与路由器之间的互连</p>\n</li>\n<li><p>Trunk端口可以属于多个VLAN</p>\n</li>\n<li><p>用户可以设置Trunk端口的PVID值，默认情况下，Trunk端口的PVID值为1</p>\n</li>\n<li><p>发送处理方法：</p>\n<p>对VID等于PVID的帧，“去标签”再转发；</p>\n<p>对VID不等于PVID的帧，直接转发</p>\n</li>\n<li><p>接受处理方法：</p>\n<p>接受“未打标签”的帧，根据接受帧的端口的PVID给帧“打标签”</p>\n<p>接受已打标签的帧</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/01/YcP7rCpRhOqgi9k.png\" alt=\"Trunk端口\"></p>\n</li>\n<li><p>Hybrid华为专用端口</p>\n<ul>\n<li><p>既可用于与主机的连接，也可用于交换机之间的互联</p>\n</li>\n<li><p>Hybrid端口可以属于多个VLAN（同Trun端口)</p>\n</li>\n<li><p>用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1(同Trun端口)</p>\n</li>\n<li><p>发送处理方法（与Trunk端口不同）：查看顿的VID是否在端口的 “去标签”列表中：</p>\n<p>若存在，则“去标签”后再转发；</p>\n<p>若不存在，则直接转发；</p>\n</li>\n<li><p>端口接收处理方法（同Trunk端口)</p>\n<p>接收“未打标签”的帧，根据接收帧的端口的PVID给顿“打标签”</p>\n<p>接收“已打标签的帧”</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/01/h57WjMaSuAnPwiq.png\" alt=\"Hybrid端口\"></p>\n</li>\n</ul>\n<p>交换端口缺省VLAN ID</p>\n<ul>\n<li>思科交换机上称为Native VLAN，即本征VLAN</li>\n<li>华为交换机上称为Port VLAN ID,即端口VLAN ID，简称位PVID</li>\n</ul>\n<!-- flag of hidden posts -->","length":5984,"excerpt":"","more":"<h1 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h1><p>数据链路层分为两个子层</p>\n<ul>\n<li>逻辑链路控制子层</li>\n<li>介质访问控制子层</li>\n</ul>\n<h2 id=\"数据链路层概述\"><a href=\"#数据链路层概述\" class=\"headerlink\" title=\"数据链路层概述\"></a>数据链路层概述</h2><p><strong>链路（Link）</strong>就是从一个结点到相邻结点的一段物理线路，而<strong>中间没有任何其他的交换结点</strong>。</p>\n<p><strong>数据链路 （DataLink）</strong>是指<strong>把实现通信协议的硬件和软件加到链路上</strong>，就构成了数据链路。</p>\n<p>数据链路层以<strong>帧为单位</strong>传输和处理数据。</p>\n<h3 id=\"数据链路重要作用\"><a href=\"#数据链路重要作用\" class=\"headerlink\" title=\"数据链路重要作用\"></a>数据链路重要作用</h3><h3 id=\"端到端情况\"><a href=\"#端到端情况\" class=\"headerlink\" title=\"端到端情况\"></a>端到端情况</h3><ol>\n<li><p>封装成帧</p>\n<p>需要添加一个帧头和帧尾实现数据链路层的功能</p>\n</li>\n<li><p>差错检测</p>\n<p>通过帧尾的检测码检查收到的帧是否存在差错</p>\n</li>\n<li><p>可靠传输</p>\n<p>不一定使用，取决于上层要求</p>\n<p>尽管误码是无法避免的，但保证发送发收什么接收方就接受什么就是可靠传输。</p>\n</li>\n</ol>\n<h3 id=\"广播情况\"><a href=\"#广播情况\" class=\"headerlink\" title=\"广播情况\"></a>广播情况</h3><p><img src=\"https://s2.loli.net/2024/07/27/WKwRgfU8YzOt67k.png\" alt=\"广播信道下的碰撞\"></p>\n<p>碰撞检测与碰撞避免协议</p>\n<h2 id=\"帧\"><a href=\"#帧\" class=\"headerlink\" title=\"帧\"></a>帧</h2><h3 id=\"封装成帧\"><a href=\"#封装成帧\" class=\"headerlink\" title=\"封装成帧\"></a>封装成帧</h3><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。</p>\n<h3 id=\"帧头帧尾的功能\"><a href=\"#帧头帧尾的功能\" class=\"headerlink\" title=\"帧头帧尾的功能\"></a>帧头帧尾的功能</h3><ol>\n<li>头和帧尾中包含有重要的控制信息。</li>\n<li>头和帧尾的作用之一就是帧定界。</li>\n</ol>\n<blockquote>\n<p>对帧定界符，如果数据本身存在帧，为了透明传输的实现，有一些特别的实现方式</p>\n<ol>\n<li>通过插入转义字符的方式实现</li>\n<li>通过bit填充的方式每n个1填充0，实现不可能出现帧定界符flag</li>\n</ol>\n</blockquote>\n<h3 id=\"帧长度\"><a href=\"#帧长度\" class=\"headerlink\" title=\"帧长度\"></a>帧长度</h3><p>为提高帧的传输效率，尽可能提高帧数据段长度，但也有最大帧长<strong>MTU</strong></p>\n<h2 id=\"差错检测\"><a href=\"#差错检测\" class=\"headerlink\" title=\"差错检测\"></a>差错检测</h2><p>BER（Bit Error Rate 误码率）：传输错误的比特占所传输比特总数的比率称为BER</p>\n<h3 id=\"奇偶校验\"><a href=\"#奇偶校验\" class=\"headerlink\" title=\"奇偶校验\"></a>奇偶校验</h3><p>在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中“1”的个数为奇数（奇校验）或偶数（偶校验）。</p>\n<h3 id=\"循环冗余校验\"><a href=\"#循环冗余校验\" class=\"headerlink\" title=\"循环冗余校验\"></a>循环冗余校验</h3><p>循环亢余校验CRC(CyclicRedundancyCheck)</p>\n<ol>\n<li>收发双方约定好一个生成多项式G(X)；</li>\n<li>发送方基于待发送的数据和生成多项式计算出差错检测码（亢余码），将其添加到待传输数据的后面一起传输</li>\n<li>接收方通过生成多项式来计算收到的数据是否产生了误码；</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/27/Gd4RPnw3JK8qHgk.png\" alt=\"CRC原理图\"></p>\n<h4 id=\"注意项\"><a href=\"#注意项\" class=\"headerlink\" title=\"注意项\"></a>注意项</h4><ol>\n<li>算法要求生成多项式必须包含0次项（常数）</li>\n<li>除法过程中为模2减法即异或</li>\n</ol>\n<h3 id=\"海明码\"><a href=\"#海明码\" class=\"headerlink\" title=\"海明码\"></a>海明码</h3><p>海明码（也叫汉明码）具有一位纠错能力。本文以1010110这个二进制数为例解释海明码的编码和校验方法。</p>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><p>确定校验码的位数x</p>\n<p>设数据有n位，校验码有x位。则校验码一共有2x种取值方式。其中需要一种取值方式表示数据正确，剩下2x-1种取值方式表示有一位数据出错。因为编码后的二进制串有n+x位，因此x应该满足</p>\n<p>$2^x-1\\ge n+x$</p>\n<p>使不等式成立的x的最小值就是校验码的位数。在本例中，n=7，解得x=4。</p>\n<p>确定校验码的位置</p>\n<p>校验码在二进制串中的位置为2的整数幂。剩下的位置为数据。如图所示。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>位</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内容</td>\n<td>x1</td>\n<td>x2</td>\n<td>1</td>\n<td>x3</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>x4</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>上面这个位数太多了，了解结构之后还是用下面这个</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>位</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内容</td>\n<td>x1</td>\n<td>x2</td>\n<td>1</td>\n<td>x3</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>并且海明码满足以下关系（注意二进制之间的关系，很简单）</p>\n<script type=\"math/tex; mode=display\">\nP1（H1） = H3 ⊕ H5 ⊕ H7 \\\\\nP2（H2） = H3 ⊕ H6 ⊕ H7\\\\\nP3（H4） = H5 ⊕ H6 ⊕ H7</script><script type=\"math/tex; mode=display\">\nS1 = P1 ⊕ H3 ⊕ H5 ⊕ H7；\\\\\nS2 = P2 ⊕ H3 ⊕ H6 ⊕ H7；\\\\\nS3 = P3 ⊕ H5 ⊕ H6 ⊕ H7；\\\\\nS1=S2=S3=0</script><h4 id=\"纠错方式\"><a href=\"#纠错方式\" class=\"headerlink\" title=\"纠错方式\"></a>纠错方式</h4><ol>\n<li>海明码只能检测出2位错，纠1位错。</li>\n<li>海明码默认进行偶校验(除非特殊说明使用奇校验)。</li>\n</ol>\n<p>当S1,S2,S3或非零时则说明数据出错，那么如何定位错误</p>\n<p><img src=\"https://s2.loli.net/2024/07/27/liFZ2tOf1BDbwVv.png\" alt=\"纠错码覆盖图\"></p>\n<p>上图很好的说明了海明码中的纠错负责范围，请联系上面给出的方程组，推导出这个图像是充分的。</p>\n<p>若我们发现$S1 \\not = 0$ 则集合{1，3，5，7}中有一个出错，若S2,S3均为0，则1出错，同理。。。可推出任意单个错误。</p>\n<p>如何发现出两个错误呢？ 实际上，对任意集合区域的两个更改（不同位），显然无法保持S1，S2，S3均为0，对更多错误我们不做考虑。这里其实是一道有点意思的容斥证明题。</p>\n<h2 id=\"可靠传输的基本概念\"><a href=\"#可靠传输的基本概念\" class=\"headerlink\" title=\"可靠传输的基本概念\"></a>可靠传输的基本概念</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>使用差错检测技术（例如循环亢余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码 （ （比特错误）。</li>\n<li>数据链路层向上层提供的服务类型<ul>\n<li>不可靠传输服务： ： 仅仅丢弃有误码的帧，其他什么也不做；</li>\n<li>可靠传输服务： 想办法实现发送端发送什么，接收端就收到什么。</li>\n</ul>\n</li>\n<li>一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。</li>\n<li><strong>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务</strong>。</li>\n<li>比特差错只是传输差错中的一种。</li>\n<li>从整个计算机网络体系结构来看，传输差错还包括<strong>分组丢失、分组失序以及分组重复。</strong></li>\n<li>分组丢失、分组失序以及分组重复这些传输差错<strong>，一般不会出现在数据链路层</strong>，而会出现在其上层。</li>\n<li><strong>可靠传输服务并不仅局限于数据链路层</strong>，其他各层均可选择实现可靠传输</li>\n</ul>\n<h3 id=\"三种实现可靠传输的机制协议\"><a href=\"#三种实现可靠传输的机制协议\" class=\"headerlink\" title=\"三种实现可靠传输的机制协议\"></a>三种实现可靠传输的机制协议</h3><p>见三种可靠传输协议<a href=\"三种可靠传输协议.md\">三种可靠传输协议</a></p>\n<h3 id=\"点对点PPP协议\"><a href=\"#点对点PPP协议\" class=\"headerlink\" title=\"点对点PPP协议\"></a>点对点PPP协议</h3><p>点对点协议PPP(Point-to-Point Protocol)是<strong>目前使用最广泛的点对点数据链路层协议</strong>。</p>\n<p>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</p>\n<ul>\n<li>对各种协议数据报的封装方法（封装成顿）</li>\n<li>链路控制协议LCP——用于建立、配置以及测试数据链路的连接</li>\n<li>一套网络控制协议NCPs——其中的每一个协议支持不同的网络层协议</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/07/28/fuZG6W5MI8sabz7.png\" alt=\"PPP协议\"></p>\n<h4 id=\"帧格式\"><a href=\"#帧格式\" class=\"headerlink\" title=\"帧格式\"></a>帧格式</h4><p><img src=\"https://s2.loli.net/2024/07/28/2rRwgMLKkhQuW4S.png\" alt=\"image-20240728233633520\"></p>\n<h4 id=\"实现透明传输的方式\"><a href=\"#实现透明传输的方式\" class=\"headerlink\" title=\"实现透明传输的方式\"></a>实现透明传输的方式</h4><p><img src=\"https://s2.loli.net/2024/07/28/1cu2qVM6GsWJgrk.png\" alt=\"透明传输方法\"></p>\n<p>就是前文的</p>\n<p>字节填充法</p>\n<ol>\n<li>对每个flag7E转换为两字节(7D5E)</li>\n<li>出现的每一个转义字符7D转换为两字节(7D5D)</li>\n<li>每个出现ASCII的控制字符（数值小于0x2D）,则在该字符前面插入一个7D，同时将该字符的编码加上0x2f</li>\n</ol>\n<p>与比特0填充法。</p>\n<ol>\n<li>flag为0111110</li>\n<li>发现五个连续的1，则填充零</li>\n<li>只要发现五个连续的bit1就删除0</li>\n</ol>\n<h4 id=\"PPP差错检测\"><a href=\"#PPP差错检测\" class=\"headerlink\" title=\"PPP差错检测\"></a>PPP差错检测</h4><p>FCS，循环冗余差错检测，循环冗余检测所使用的多项式如下</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/FojLO4ABQmlHRaJ.png\" alt=\"FCS循环检验多项式\"></p>\n<h2 id=\"媒体介入控制\"><a href=\"#媒体介入控制\" class=\"headerlink\" title=\"媒体介入控制\"></a>媒体介入控制</h2><p>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC(MediumAccess Control)</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/EokcKbysS3IiUNM.png\" alt=\"媒体介入控制\"></p>\n<p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局或网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</p>\n<h3 id=\"静态划分信号\"><a href=\"#静态划分信号\" class=\"headerlink\" title=\"静态划分信号\"></a>静态划分信号</h3><p>FDM，TDM，WDM，CMD</p>\n<p>频分复用，时分复用，波分复用，码分复用</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/TLFHbRIdyza6Aqe.png\" alt=\"FDM\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/28/j8INQv32kMlVs6D.png\" alt=\"TDM\"></p>\n<p>WDM波分复用实际就是光的频分复用</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/dWb3hfvz75aROi4.png\" alt=\"WDM\"></p>\n<p>码分复用CDM是另一种共享信道的方法。实际上，由于该技术主要用于多址接入型人们更常用的名词是码分多址CDMA(Code Division Multiple Access)。  </p>\n<p>同理，频分复用FDM和时分复用TDM同样可用于多址接入，相应的名词是频分多址FDMA(Frequency Division Multiple Access)和时分多址TDMA(Time Division Multiple Access)。</p>\n<ul>\n<li>复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。</li>\n<li>多址（更确切地应该称为多点接入）处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户的应用中，多址是不需要的（对于无线广播或电视广播站就是这样）。</li>\n</ul>\n<p>与FDM和TDM不同，<strong>CDM的每一个用户可以在同样的时间使用同样的频带进行通信</strong>。<br>由于各用户使用经过特殊挑选的不同码型， 因此各用户之间<strong>不会造成干扰</strong>。</p>\n<p>使用CDMA的每一个站被指派一个唯一的mbit码片序列 J (Chip Sequence)。</p>\n<ul>\n<li>一个站如果要发送比特1，则发送它自己的mbit码片序列；</li>\n<li>一个站如果要发送比特0，则发送它自己的mbit码片序列的二进制反码；<br>码片序列的挑选原则如下：<ol>\n<li>分配给每个站的<strong>码片序列必须各不相同</strong>， 实际常采用伪随机码序列。</li>\n<li>分配给每个站的码片序列<strong>必须相互正交</strong> （规格化内积为0）。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/07/28/YvrLpEjD1hwZolu.png\" alt=\"码分复用例题\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/28/ChBnOvWeI4LpJ3Z.png\" alt=\"码分复用例题2\"></p>\n</blockquote>\n<h3 id=\"动态接入——随机接入\"><a href=\"#动态接入——随机接入\" class=\"headerlink\" title=\"动态接入——随机接入\"></a>动态接入——随机接入</h3><h3 id=\"CSMA-CD-载波监听多址接入-碰撞检测\"><a href=\"#CSMA-CD-载波监听多址接入-碰撞检测\" class=\"headerlink\" title=\"CSMA/CD 载波监听多址接入/碰撞检测\"></a>CSMA/CD 载波监听多址接入/碰撞检测</h3><p>Carrier Sense Multiple Access/Collision Detection</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/eFri49uRAnVmzSb.png\" alt=\"MA、CS、CD\"></p>\n<h4 id=\"争用期\"><a href=\"#争用期\" class=\"headerlink\" title=\"争用期\"></a>争用期</h4><p><img src=\"https://s2.loli.net/2024/07/29/SeQaRPKi3EZzGYn.png\" alt=\"争用期示例\"></p>\n<ul>\n<li><p>可以类比争用期与RTT的概念</p>\n</li>\n<li><p>争用期的概念限制了共享式以太网中的总线长度</p>\n<ul>\n<li>10Mb/s限制为2500ms（RTT）</li>\n</ul>\n</li>\n<li><p>以太网规定最小<strong>帧长为64字节</strong>，即512bit时间为争用期</p>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/07/29/w3Ty7OhWdjZ9qKJ.png\" alt=\"一个标准的MAC帧长\"></p>\n<p>显然也是有最长帧长的</p>\n</blockquote>\n</li>\n<li><p>最小顿长确保了主机可在顿发送完成之前就检测到该顿的发送过程中是否遭遇了碰撞</p>\n</li>\n</ul>\n<h4 id=\"截断二进制指数退避算法\"><a href=\"#截断二进制指数退避算法\" class=\"headerlink\" title=\"截断二进制指数退避算法\"></a>截断二进制指数退避算法</h4><p><img src=\"https://s2.loli.net/2024/07/29/KG6QB5onPk2C3cF.png\" alt=\"截断二进制指数退避算法\"></p>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/07/29/4HsmKAzikS59tFw.png\" alt=\"退避示例\"></p>\n</blockquote>\n<ul>\n<li>若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述<strong>退避算法可使重传需要推迟的平均时间随重传次数而增大</strong>（这也称为<strong>动态退避</strong>），因而减小发生碰撞的概率，有利于整个系统的稳定。</li>\n<li>当重传达<strong>16次仍</strong>不能成功时，表明同时打算发送顿的主机太多，以至于连续发生碰撞，则丢奔该顿，并向高层报告。</li>\n</ul>\n<h4 id=\"信道利用率\"><a href=\"#信道利用率\" class=\"headerlink\" title=\"信道利用率\"></a>信道利用率</h4><p><img src=\"https://s2.loli.net/2024/07/29/eZ2CBMlKDs7Ii8Q.png\" alt=\"定义发送帧平均时间\"></p>\n<h4 id=\"整体流程图\"><a href=\"#整体流程图\" class=\"headerlink\" title=\"整体流程图\"></a>整体流程图</h4><p><img src=\"https://s2.loli.net/2024/07/29/pUY9IniDLkEM3z2.png\" alt=\"CSMA-CD发送\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/29/q5ls8bxfeIMQXaN.png\" alt=\"CSMA/CD接收\"></p>\n<h3 id=\"CSMA-CA-载波监听多址接入-碰撞避免\"><a href=\"#CSMA-CA-载波监听多址接入-碰撞避免\" class=\"headerlink\" title=\"CSMA/CA 载波监听多址接入/碰撞避免\"></a>CSMA/CA 载波监听多址接入/碰撞避免</h3><p>CSMA/CA(Carrier Sense Multiple Access/Collision Avoidance)</p>\n<p>在无线局域网中，仍然可以使用载波监听多址接入CSMA，即在发送顿之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞。<br>在无线局域网中，不能使用碰撞检测CD，原因如下：</p>\n<ul>\n<li>由于无线信道的传输条件特殊，<strong>其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高</strong>。</li>\n<li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），进行碰撞检测的意义也不大。</li>\n</ul>\n<p>由于不可能避免所有的碰撞 重，并且无线信道误码率较高 802.11标准还使用了<strong>==数据链路层==**</strong>确认机制（停止-等待协议） 来保证数据被正确接收。**</p>\n<h4 id=\"帧间间隔IFS\"><a href=\"#帧间间隔IFS\" class=\"headerlink\" title=\"帧间间隔IFS\"></a>帧间间隔IFS</h4><p>IFS (InterFrame Space)</p>\n<p>802.11标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送顺， 这段时间称为帧间间隔IFS。<br>侦间间隔的长短取决于该站点要发送的帧的类型：</p>\n<ul>\n<li>高优先级帧需要等待的时间较短，因此可优先获得发送权；</li>\n<li>低优先级帧需要等待的时间较长。若某个站的低优先级还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级顿就只能再推迟发送了。这样就减少了发生碰撞的机会。</li>\n</ul>\n<p>常用的两种顺间间隔如下：</p>\n<ul>\n<li>短帧间间隔SIFS(28μs)，是最短的顿间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方切换到接收方，使用SIFS的帧类型有ACK、CTS</li>\n<li>DCF帧间间隔DIFS（128$\\mu s$）：用于发送数据帧和管理帧</li>\n</ul>\n<h4 id=\"退避算法\"><a href=\"#退避算法\" class=\"headerlink\" title=\"退避算法\"></a>退避算法</h4><p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240729002326209.png\" alt=\"CA\"></p>\n<p>当站点检测到信道是空闲的，并且所发送的数据顿不是成功发送完上一个数据顿之后立即连续发送的数据顿，则不使用退避算法。</p>\n<p>以下情况必须使用退避算法：</p>\n<ul>\n<li>在发送数据顿之前检测到信道处于忙状态时；</li>\n<li>在每一次重传一个数据顿时；</li>\n<li>在每一次成功发送后要连续发送下一个顿时（这是为了避免一个站点长时间占用信道）</li>\n</ul>\n<p>在执行退避算法时，站点为退避计时器设置一个随机的退避时间： </p>\n<ul>\n<li>当退避计时器的时间减小到零时，就开始发送数据</li>\n<li>当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间DIFS后，继续启动退避计时器。</li>\n</ul>\n<p>在进行第i次退避时，退避时间在时隙编号(0.1，…2^i+2^-1)中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时（对应于第6次退避）就不再增加了。</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240729002759290.png\" alt=\"CA退避时间图\"></p>\n<h4 id=\"RTS与CTS\"><a href=\"#RTS与CTS\" class=\"headerlink\" title=\"RTS与CTS\"></a>RTS与CTS</h4><ul>\n<li><p>除源站和目的站以外的其他各站，在收到CTS赖（或数据赖）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。</p>\n</li>\n<li><p>如果RTS赖发生碰撞，<strong>源站就收不到CTS顿，需执行退避算法重传RTS顿。</strong></p>\n</li>\n<li><p><strong>由于RTS帧和CTS帧很短</strong>，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一股的数据赖，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据顿重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往<strong>是值得的</strong></p>\n</li>\n<li><p>使用RTS与CTS的情况</p>\n<ul>\n<li>可以使用也可以不使用</li>\n<li>仅仅只在帧很长时使用</li>\n</ul>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/07/29/WLX4NRYKUkqhvzm.png\" alt=\"RTS、CTS\"></p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"隐蔽站\"><a href=\"#隐蔽站\" class=\"headerlink\" title=\"隐蔽站\"></a>隐蔽站</h4><p>RTS、CTS会携带通信所需时间，这称为802.11的虚拟载波监听</p>\n<p><img src=\"https://s2.loli.net/2024/07/29/HJmPlfhaQByKCOV.png\" alt=\"隐蔽站概念\"></p>\n<p>虚拟载波监听能减少隐蔽站带来的碰撞问题</p>\n<p><img src=\"https://s2.loli.net/2024/07/29/H51LzOEXN8ah9B2.png\" alt=\"简单例题\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/29/75GdWwsSRg1etJ8.png\" alt=\"例题2\"></p>\n<h2 id=\"MAC-IP-ARP\"><a href=\"#MAC-IP-ARP\" class=\"headerlink\" title=\"MAC\\IP\\ARP\"></a>MAC\\IP\\ARP</h2><ul>\n<li><p>MAC地址是以太网的MAC子层所使用的地址；在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制MAC(MediaAccessControl)，因此这类地址被称为MAC地址;==数据链路层==</p>\n<ul>\n<li><p>MAC地址一般存储在EPROM中，因此也称为硬件地址</p>\n</li>\n<li><p>有时也被称为物理地址，但他属于==数据链路层==</p>\n</li>\n<li><p>严格来说MAC地址是对<strong>网络上各接口的唯一标识</strong>而不是对网络上各设备的唯一标识</p>\n</li>\n<li><p>由6个字节48个位组成</p>\n</li>\n<li><p>bit 发送顺序，由第一字节发送至第六字节</p>\n</li>\n<li><p>不具备区分不同网络的功能</p>\n<p><img src=\"https://s2.loli.net/2024/07/29/NrdYQmELIpsGKVO.png\" alt=\"MAC\"></p>\n<p>00-00-00-00-00-00/00:00:00:00:00:00</p>\n</li>\n</ul>\n</li>\n<li><p>IP地址是TCP/IP体系结构网际层所使用的地址；==网络层==</p>\n<ul>\n<li>网络编号： ： 标识因特网上数以百万计的网络</li>\n<li>主机编号： 标识同一网络上不同主机(或路由器各接口) </li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/07/29/qSw6lhVGkEZij2N.png\" alt=\"MAC与IP\"></p>\n<ul>\n<li>数据包转发过程中源IP地址和目的IP地址保持不变；</li>\n<li>数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变;</li>\n</ul>\n</li>\n<li><p>ARP协议(地址解析协议Address Resolute Potrol)属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址；==网络层==</p>\n<p>ARP 高速缓存</p>\n<ul>\n<li>动态：自动获取，两种生命周期</li>\n<li>静态，手工设置，不同状态下设置不同生命周期</li>\n<li>ARP无法跨网络使用</li>\n</ul>\n</li>\n<li><p>尽管<strong>IP地址和ARP协议属于TCP/IP体系结构的网际层</strong>（而不属于数据链路层），但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议。因此，我们将这三者放在一起讨论。</p>\n</li>\n</ul>\n<h2 id=\"交换器与集线器的区别\"><a href=\"#交换器与集线器的区别\" class=\"headerlink\" title=\"交换器与集线器的区别\"></a>交换器与集线器的区别</h2><ul>\n<li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA/CD协议；</li>\n<li>集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）；</li>\n<li>集线器一般都有<strong>少量的容错能力和网络管理功能</strong>。例如，若网络中某个网卡出了故障，不停地发送顿。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作。</li>\n<li>以太网交换机通常都有多个接口。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在<strong>全双工方式</strong>。</li>\n<li>以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA/CD协议）。</li>\n<li>以太网交换机<strong>工作在数据链路层</strong>（也包括物理层），它收到帧后，在顿交换表中查找顿的目的MAC地址所对应的接口号，然后通过该接口转发顿。</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/07/29/Yb31GxuD6jnZqcw.png\" alt=\"交换器与集线器\"></p>\n<h3 id=\"交换机如何自学习帧交换表\"><a href=\"#交换机如何自学习帧交换表\" class=\"headerlink\" title=\"交换机如何自学习帧交换表\"></a>交换机如何自学习帧交换表</h3><ul>\n<li>交换机的学习过程是记录<strong>来源MAC与对应的接口</strong></li>\n<li>若交换表中不存在地址则盲目泛洪</li>\n<li>对同一交换机下的主机，同样会记录帧交换表</li>\n<li>帧交换表中每条记录都有自己的有效时间</li>\n<li><strong>明确丢弃</strong>：交换机知道不应该转发该帧，将其丢弃</li>\n</ul>\n<h3 id=\"交换机的生成树STP\"><a href=\"#交换机的生成树STP\" class=\"headerlink\" title=\"交换机的生成树STP\"></a>交换机的生成树STP</h3><ul>\n<li>冗余链路的概念，对生成树添加额外的边，使其存在环</li>\n<li>广播风暴：在网络环路中存在的循环转发帧<ol>\n<li>大量消耗网络资源</li>\n<li>大量消耗主机资源</li>\n<li>帧交换表震荡（漂移）</li>\n</ol>\n</li>\n</ul>\n<p>Spanning Tree Protocol生成树协议。</p>\n<ul>\n<li>计算构建一个逻辑上无环路网络</li>\n<li>物理拓扑发生变化时，生成树将重新计算</li>\n</ul>\n<h2 id=\"VLAN虚拟局域网\"><a href=\"#VLAN虚拟局域网\" class=\"headerlink\" title=\"VLAN虚拟局域网\"></a>VLAN虚拟局域网</h2><p>Virtual Local Area Network</p>\n<p>虚拟局域网VLAN(VirtualLocalAreaNetwork)是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术 这些逻辑组具有某些共同的需求</p>\n<ul>\n<li><p>以太网交换机工作在数据链路层（也包括物理层）</p>\n</li>\n<li><p>使用一个或多个以太网交换机互联的站点都属于一个广播域</p>\n</li>\n<li>分割广播域的方式<ul>\n<li>使用路由器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><h4 id=\"IEEE-802-1Q帧\"><a href=\"#IEEE-802-1Q帧\" class=\"headerlink\" title=\"IEEE 802.1Q帧\"></a>IEEE 802.1Q帧</h4><p>它对以太网的MAC帧格式进行了扩展，插入了4字节的VLAN标记</p>\n<p><img src=\"./../../../../SelfLreaning/AddtionalBlog/xjTRstbzHfKWgZ5.png\" alt=\"IEEE 802.1Q帧\"></p>\n<ul>\n<li>VLAN标记的最后12bit称为VLAN标识符VID，其唯一地标识了以太网帧属于哪一个VLAN<ul>\n<li>VID地取值范围位0-2^12^-1,0与2^12^都不用来表示VLAN，因此有效VID不包含0，与4095</li>\n</ul>\n</li>\n<li>801.1Q帧是由交换机处理的，而非用户主机处理的<ul>\n<li>当交换机收到普通地以太网帧时，插入4字节地VLAN标记称为“打标签”</li>\n<li>当转发801.1Q帧时，可能会删除其4字节地VLAN标记称为“去标签”</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"交换机地端口类型\"><a href=\"#交换机地端口类型\" class=\"headerlink\" title=\"交换机地端口类型\"></a>交换机地端口类型</h3><p>交换机端口类型有以下三种：</p>\n<ul>\n<li><p>Access</p>\n<ul>\n<li>一般用于连接用户计算机</li>\n<li>只能属于一个VLAN</li>\n<li>PVID与端口所属VLAN的ID相同（默认为1）</li>\n<li>发送处理方法：若帧中的VID与端口的PVID相等，则“去标签”并转发该帧；否则不转发</li>\n<li>接受处理方法：一般只接受“未打标签”的普通MAC帧然后”打标签“</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/01/z72sfcOmaRCSZyE.png\" alt=\"Access端口\"></p>\n</li>\n<li><p>Trunk</p>\n<ul>\n<li><p>Trunk端口一般用于交换机之间或交换机与路由器之间的互连</p>\n</li>\n<li><p>Trunk端口可以属于多个VLAN</p>\n</li>\n<li><p>用户可以设置Trunk端口的PVID值，默认情况下，Trunk端口的PVID值为1</p>\n</li>\n<li><p>发送处理方法：</p>\n<p>对VID等于PVID的帧，“去标签”再转发；</p>\n<p>对VID不等于PVID的帧，直接转发</p>\n</li>\n<li><p>接受处理方法：</p>\n<p>接受“未打标签”的帧，根据接受帧的端口的PVID给帧“打标签”</p>\n<p>接受已打标签的帧</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/01/YcP7rCpRhOqgi9k.png\" alt=\"Trunk端口\"></p>\n</li>\n<li><p>Hybrid华为专用端口</p>\n<ul>\n<li><p>既可用于与主机的连接，也可用于交换机之间的互联</p>\n</li>\n<li><p>Hybrid端口可以属于多个VLAN（同Trun端口)</p>\n</li>\n<li><p>用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1(同Trun端口)</p>\n</li>\n<li><p>发送处理方法（与Trunk端口不同）：查看顿的VID是否在端口的 “去标签”列表中：</p>\n<p>若存在，则“去标签”后再转发；</p>\n<p>若不存在，则直接转发；</p>\n</li>\n<li><p>端口接收处理方法（同Trunk端口)</p>\n<p>接收“未打标签”的帧，根据接收帧的端口的PVID给顿“打标签”</p>\n<p>接收“已打标签的帧”</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/01/h57WjMaSuAnPwiq.png\" alt=\"Hybrid端口\"></p>\n</li>\n</ul>\n<p>交换端口缺省VLAN ID</p>\n<ul>\n<li>思科交换机上称为Native VLAN，即本征VLAN</li>\n<li>华为交换机上称为Port VLAN ID,即端口VLAN ID，简称位PVID</li>\n</ul>\n"},{"title":"计网篇-可靠传输协议篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"## 停止等待协议SW\n\n![SW](https://s2.loli.net/2024/07/27/63VQK5xO1mkWbZq.png)\n\n1. 每次发送都有一段停止等待时间\n2. 接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组\n3. 对数据分组和ATK分组都有编号，防止1. ack丢失2. ack超时，由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。\n4. 由于数据链路层时间非常固定 ack可以不做编号\n5. 超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。\n\n![SW流程图](https://s2.loli.net/2024/07/27/MbfkCjgcpUGaZKE.png)\n$$\nU = \\frac{T_D}{T_D + RTT + T_A}（\\text{$T_A$远小于$T_D$，常常忽略}）\n$$\n\n## 回退N帧协议GBN\n\n1. 利用额外的T bit位为发出分组编序号\n2. 发送窗口的尺寸取值范围$1 < W_T \\le 2^{t - 1}$\n3. 接收窗口的尺寸$W_R = 1$\n\n接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后（由具体实现决定）对按序到达的最后一个数据分组发送确认。**ACKn表示序号为n及以前的所有数据分组都已正确接收**。\n\n**即使确认分组丢失，发送方也可能不必重传**\n\n当发送的发送窗口超过当前的取值范围时，会导致接收方无法辨析新旧分组导致无限重传。\n\n![GBN](https://s2.loli.net/2024/07/28/5bhdlrqIPpZosLu.png)\n\n## 选择重传协议SR\n\n1. 利用额外的T bit位为发出分组编序号\n2. 发送窗口的尺寸取值范围$1 < W_T \\le 2^{t - 1}$\n3. 接收窗口的尺寸$W_R = W_T$\n\n当发送的发送窗口超过当前的取值范围时，会导致接收方无法辨析新旧分组导致无限重传。\n\n![SR](https://s2.loli.net/2024/07/28/kajXNorU6QnczM2.png)\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/三种可靠传输协议.md","raw":"---\ntitle: 计网篇-可靠传输协议篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n## 停止等待协议SW\n\n![SW](https://s2.loli.net/2024/07/27/63VQK5xO1mkWbZq.png)\n\n1. 每次发送都有一段停止等待时间\n2. 接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组\n3. 对数据分组和ATK分组都有编号，防止1. ack丢失2. ack超时，由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。\n4. 由于数据链路层时间非常固定 ack可以不做编号\n5. 超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。\n\n![SW流程图](https://s2.loli.net/2024/07/27/MbfkCjgcpUGaZKE.png)\n$$\nU = \\frac{T_D}{T_D + RTT + T_A}（\\text{$T_A$远小于$T_D$，常常忽略}）\n$$\n\n## 回退N帧协议GBN\n\n1. 利用额外的T bit位为发出分组编序号\n2. 发送窗口的尺寸取值范围$1 < W_T \\le 2^{t - 1}$\n3. 接收窗口的尺寸$W_R = 1$\n\n接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后（由具体实现决定）对按序到达的最后一个数据分组发送确认。**ACKn表示序号为n及以前的所有数据分组都已正确接收**。\n\n**即使确认分组丢失，发送方也可能不必重传**\n\n当发送的发送窗口超过当前的取值范围时，会导致接收方无法辨析新旧分组导致无限重传。\n\n![GBN](https://s2.loli.net/2024/07/28/5bhdlrqIPpZosLu.png)\n\n## 选择重传协议SR\n\n1. 利用额外的T bit位为发出分组编序号\n2. 发送窗口的尺寸取值范围$1 < W_T \\le 2^{t - 1}$\n3. 接收窗口的尺寸$W_R = W_T$\n\n当发送的发送窗口超过当前的取值范围时，会导致接收方无法辨析新旧分组导致无限重传。\n\n![SR](https://s2.loli.net/2024/07/28/kajXNorU6QnczM2.png)\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/三种可靠传输协议","published":1,"updated":"2024-08-17T13:23:44.574Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqd000vm8wvcjfccckr","content":"<h2 id=\"停止等待协议SW\"><a href=\"#停止等待协议SW\" class=\"headerlink\" title=\"停止等待协议SW\"></a>停止等待协议SW</h2><p><img src=\"https://s2.loli.net/2024/07/27/63VQK5xO1mkWbZq.png\" alt=\"SW\"></p>\n<ol>\n<li>每次发送都有一段停止等待时间</li>\n<li>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组</li>\n<li>对数据分组和ATK分组都有编号，防止1. ack丢失2. ack超时，由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。</li>\n<li>由于数据链路层时间非常固定 ack可以不做编号</li>\n<li>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/27/MbfkCjgcpUGaZKE.png\" alt=\"SW流程图\"></p>\n<script type=\"math/tex; mode=display\">\nU = \\frac{T_D}{T_D + RTT + T_A}（\\text{$T_A$远小于$T_D$，常常忽略}）</script><h2 id=\"回退N帧协议GBN\"><a href=\"#回退N帧协议GBN\" class=\"headerlink\" title=\"回退N帧协议GBN\"></a>回退N帧协议GBN</h2><ol>\n<li>利用额外的T bit位为发出分组编序号</li>\n<li>发送窗口的尺寸取值范围$1 &lt; W_T \\le 2^{t - 1}$</li>\n<li>接收窗口的尺寸$W_R = 1$</li>\n</ol>\n<p>接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后（由具体实现决定）对按序到达的最后一个数据分组发送确认。<strong>ACKn表示序号为n及以前的所有数据分组都已正确接收</strong>。</p>\n<p><strong>即使确认分组丢失，发送方也可能不必重传</strong></p>\n<p>当发送的发送窗口超过当前的取值范围时，会导致接收方无法辨析新旧分组导致无限重传。</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/5bhdlrqIPpZosLu.png\" alt=\"GBN\"></p>\n<h2 id=\"选择重传协议SR\"><a href=\"#选择重传协议SR\" class=\"headerlink\" title=\"选择重传协议SR\"></a>选择重传协议SR</h2><ol>\n<li>利用额外的T bit位为发出分组编序号</li>\n<li>发送窗口的尺寸取值范围$1 &lt; W_T \\le 2^{t - 1}$</li>\n<li>接收窗口的尺寸$W_R = W_T$</li>\n</ol>\n<p>当发送的发送窗口超过当前的取值范围时，会导致接收方无法辨析新旧分组导致无限重传。</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/kajXNorU6QnczM2.png\" alt=\"SR\"></p>\n<!-- flag of hidden posts -->","length":511,"excerpt":"","more":"<h2 id=\"停止等待协议SW\"><a href=\"#停止等待协议SW\" class=\"headerlink\" title=\"停止等待协议SW\"></a>停止等待协议SW</h2><p><img src=\"https://s2.loli.net/2024/07/27/63VQK5xO1mkWbZq.png\" alt=\"SW\"></p>\n<ol>\n<li>每次发送都有一段停止等待时间</li>\n<li>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组</li>\n<li>对数据分组和ATK分组都有编号，防止1. ack丢失2. ack超时，由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。</li>\n<li>由于数据链路层时间非常固定 ack可以不做编号</li>\n<li>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/27/MbfkCjgcpUGaZKE.png\" alt=\"SW流程图\"></p>\n<script type=\"math/tex; mode=display\">\nU = \\frac{T_D}{T_D + RTT + T_A}（\\text{$T_A$远小于$T_D$，常常忽略}）</script><h2 id=\"回退N帧协议GBN\"><a href=\"#回退N帧协议GBN\" class=\"headerlink\" title=\"回退N帧协议GBN\"></a>回退N帧协议GBN</h2><ol>\n<li>利用额外的T bit位为发出分组编序号</li>\n<li>发送窗口的尺寸取值范围$1 &lt; W_T \\le 2^{t - 1}$</li>\n<li>接收窗口的尺寸$W_R = 1$</li>\n</ol>\n<p>接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后（由具体实现决定）对按序到达的最后一个数据分组发送确认。<strong>ACKn表示序号为n及以前的所有数据分组都已正确接收</strong>。</p>\n<p><strong>即使确认分组丢失，发送方也可能不必重传</strong></p>\n<p>当发送的发送窗口超过当前的取值范围时，会导致接收方无法辨析新旧分组导致无限重传。</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/5bhdlrqIPpZosLu.png\" alt=\"GBN\"></p>\n<h2 id=\"选择重传协议SR\"><a href=\"#选择重传协议SR\" class=\"headerlink\" title=\"选择重传协议SR\"></a>选择重传协议SR</h2><ol>\n<li>利用额外的T bit位为发出分组编序号</li>\n<li>发送窗口的尺寸取值范围$1 &lt; W_T \\le 2^{t - 1}$</li>\n<li>接收窗口的尺寸$W_R = W_T$</li>\n</ol>\n<p>当发送的发送窗口超过当前的取值范围时，会导致接收方无法辨析新旧分组导致无限重传。</p>\n<p><img src=\"https://s2.loli.net/2024/07/28/kajXNorU6QnczM2.png\" alt=\"SR\"></p>\n"},{"title":"计组篇-数据的表示和运算篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# 第二章、数据的表示和运算\n\n## 进位计算制\n\n大体略\n\n有一些值得注意截至 24/7/22 不太熟悉的一些不同进制的性质如下\n\n1. 在原码当中符号位 **1** 为负数，补码当中也是，移码则是相反，补码与原码的替换公式为，符号位不变，数值位取反加 1。\n\n![编码数值分布图](https://s2.loli.net/2024/07/22/VpUcyOEfx837aTS.jpg)\n\n## 定点与浮点数\n\n### 定点数\n\n1. 无符号数\n\n   原码表示数的绝对值 $$0\\to2^n-1$$\n\n   通常**只有无符号整数而没有无符号小数**\n\n2. 有符号数的表示\n\n   ![定点有符号小数](https://s2.loli.net/2024/07/22/YedauQjKrJHRlvD.png)\n\n   ![有符号书的定点表示](https://s2.loli.net/2024/07/22/MJEYtDvpLbOzq5k.png)\n\n   通常第二种有符号定点数更常见，因为很容易理解的，对不同数，无关大小，其转化为准确二进制小数的所占位数是难以简单估量的。\n\n   而且值得注意的是：**移码只能用于表示整数**\n\n| 原码和反码 | —整数表示范围 $$-2^n≤x≤2^n$$ | 小数表示范围 $$-(1-2^n）≤x≤1-2^n$$ |\n| ---------- | --------------------------- | --------------------------------- |\n| 补码       | —整数表示范围-2n ≤x≤2n-1    | 小数表示范围 $$-1≤x≤1-2^n$$        |\n| 移码       | 一整数表示范围-2n≤x≤2n-1    | 移码全 0 真值最小，移码全 1 真值最大  |\n\n​\t对于小数的表示，是截至目前不熟悉的\n\n​\t下面是有关运算方法的运算电路，首先，回顾一下数字电路基础知识\n\n## 数字电路基础知识\n\n### 逻辑门电路\n\n![基础逻辑门电路](https://s2.loli.net/2024/07/22/kmZjxtEcLVUJh7I.png)\n\n![运算规律](https://s2.loli.net/2024/07/22/HEbIwLGh3PfVtiW.png)\n\n![运算规律](https://s2.loli.net/2024/07/22/79Llp3h1z2BZqJV.png)\n\n其中反演律又称德摩根律\n\n### 加法器\n\n![加法器的分类](https://s2.loli.net/2024/07/22/Eh1HJaXjw52zfT6.png)\n\n立！即！推！\n\n![推导](https://s2.loli.net/2024/07/23/d3hQLfZOjMaKPbz.png)\n\n#### 串行定位加法器\n\n**定义**：输入端允许并行输入nbit，因此这种加法器属于：并行加法器，由于进位信息是串行产生的，因此从“进位方式”看，这种加法器属于：串行进位加法器。\n\n综上，很多教材把这种加法器称为“**串行进位的并行加法器**\n\n![逻辑功能示意图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240723224744562.png)\n\n#### 并行进位的并行加法器\n\n并行进位的并行加法器：所有进位信息都是同时产生的，几乎没有延迟。\n**特点：运算速度比“申行进位的并行加法器”更快。**\n\n![并行进位加法器示意图](https://s2.loli.net/2024/07/23/rVE6L7YH8K2zCfF.png)\n\n#### 带标志器的加法器\n\n![带标志器的加法器示意图](https://s2.loli.net/2024/07/23/q2k1uFLtfieITan.png)\n\n四种标志\n\n1. OF（Overflow Flag)溢出标志，用于判断带符号数加减运算是否溢出。OF=1 溢出；OF=O 未溢出\n2. SF（Sign Flag）符号标志，用于判断带符号数加减运算结果的正负性。SF=1 结果为负；SF=O 结果为正\n3. ZF（Zero Flag)零标志，用于判断加减运算结果是否为O。ZF=1表示结果为O；ZF= 表示结果不为0\n4. CF（Carry Flag)进位/借位标志，用于判断无符号数加减运算是否溢出。CF=1 溢出；CF=0 未溢出\n\n> 引入汇编中的标志寄存器：\n>\n> ![汇编标志寄存器](https://s2.loli.net/2024/07/23/KoyEjTGda3mlfXb.png)\n>\n> 该图中绿色区域为奇偶校验码\n>\n> 0,2,4,6,7,8,9,10,11为标志，分别为CF进位标志，PF奇偶标志，AF辅助进位标志，ZF零标志，SF符号标志，TF单步标志，IF中断使能标志，DF方向标志，OF溢出标志\n>\n> 补充上面的五种分别为\n>\n> - **奇偶标志（Parity Flag）**\n>\n> 由于反应运算结果中(转化为二进制)，**\"1\"的奇偶性，也就是个数**。\"1\"的个数为偶数，PF为1。个数为奇数，PF为0.\n> 补充：只包含最低位的一个字节(二进制的后八位)\n>\n> - **辅助进位标志AF(Auxiliary Carry Flag)**\n>\n> 在发生下列情况时，AF的值为1，否则其值为0\n> (1)、在字操作时，发生低字节向高字节进位或错位时；\n> (2)、在字节操作时，发生低4位向高4位进位或错位时；\n>\n> - **中断使能标志位**\n>\n> **是否处于中断中，处于则为一**\n>\n> - **方向标志位**\n>\n> 方向标志位（DF）是Intel 8086/8088 CPU程序状态标志寄存器的一个标志位，用来控制数据串操作指令的步进方向。当设置DF=1时，将以递减顺序对数据串中的数据进行处理；当设置DF=0时，递增\n>\n> - **单步标志位Trap flag**\n>\n> 是否处于debug状态，该标志位为1则单步调试\n\n#### 标志位的生成\n\n立即推！首先注意到是否溢出是很独特的。\n\n通过基础的学习可以知道，判断是否溢出有很多方式。。\n\n首先看一下如何出现溢出？\n\n首先看无符号数？\n\n对无符号数而言，均表示绝对值，溢出后相当于$$mod2^n$$，这在很多情况下是很自然地，因此通常我们讲**无符号数不存在溢出**\n\n对有符号数而言\n\n1. 两个正数相加\n2. 两个负数相加\n\n显然异号数相加是不会影响到加法器的正常运行的。\n\n第一种情况，我们发现实际上他并没有真正的溢出，而是**变成了一个负数！**，第二种情况，实际上真的有1进位出去了，而且此时的情况还是比较复杂的。\n\n写一下最高位下的真值表\n\n| A    | B    | C_in | C_out | S    |\n| ---- | ---- | ---- | ----- | ---- |\n| ..   | ..   | ..   | ..    | ..   |\n| 1    | 1    | 0    | 1     | 0    |\n| 0    | 0    | 1    | 0     | 1    |\n| ..   | ..   | ..   | ..    | ..   |\n\n可以发现，当进位与当前位进位，即运算后的高两位进位不同时即可判断发生溢出\n\n谈及溢出，这里就温习一下所有的判断溢出方法\n\n1. 朴素符号法\n\nXf、Yf分别两个数的符号位,Zf为运算结果符号位。\n当Xf =Yf =0（两数同为正）,而Zf=1(结果为负)时,负溢出；\n当出现Xf =Yf =1（两数同为负）,而Zf=0（结果为正），正溢出.\n\n2. 上文提到的加法器\n\n$$OF=Cn \\oplus Cn-1$$\n\n3. 双符号法\n\n用变形补码进行双符号位运算（正数符为00,负数符号以11）\n若运算结果的符号位为\"01\",则正溢；\n若结果双符号为10,则负溢出；\n若结果的双符号位为00或11，无溢出\n\n解决了加法器的问题，剩下的就很简单了\n\n$$OF = C \\oplus Cn-1 $$ -即最高位的进位④次高位的进位。反映带符号数加减运算是否溢出。\n$$SF=S$$,一一也就是取运算结果的最高位（符号位）。反映带符号数加减运算的正负性。\n$$ZF= \\overline{Sn+…+S2+S1}$$ 一一仅当运算结果所有 bit 全0时，ZF才为1，此时表示运算结果为O。\n$$CF=Cout \\oplus Cin=Cn \\oplus C_0$$一一反映无符号数加减运算是否溢出。\n\n### 并行加法运算器\n\n回顾串行进位\n\n![逻辑电路图](https://s2.loli.net/2024/07/23/nMocZ4N68s2rYKP.png)\n\n![并行进位示意图](https://s2.loli.net/2024/07/23/jaKcwoJBqD7xFLi.png)\n\n### 多路选择器（MUX）\n\n![选择器示意图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240723235506535.png)\n\n### 三态门\n\n![三态门电路示意](https://s2.loli.net/2024/07/23/H1MaprNRSyGxihK.png)\n\n### 算术逻辑单元ALU\n\n1. ALU是运算器的核心\n2. 加法器是运算器的核心\n\n![功能图](https://s2.loli.net/2024/07/23/eFRBuMEJaojYGwy.png)\n\n3. **若ALU有k种功能，那么控制信号位数$$m \\ge \\left\\lfloor log_2k\\right\\rfloor$$**\n\n4. ALU的运算数、运算结果位数与计算机的机器字长相同\n\n![ALU](https://s2.loli.net/2024/07/24/FuklLJyCnUwqEh5.png)\n\n## 运算\n\n### 定点数的移位运算\n\n计算机的移位操作分为**算数移位**和**逻辑移位**\n\n![算术移位规则图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210022980.png)\n\n![算术移位与逻辑一味的区别](https://s2.loli.net/2024/07/24/6ua5YAKiTjEmtL1.png)\n\n>eg: 对 10110010\n>\n>逻辑左移 10100110\t逻辑右移 01011001\n>\n>算数左移 00100110\t算数右移 11011001（只有**补码在算术移位下才添1**）\n\n### 循环移位\n\n​\t循环移位分为**带进位标志位CF的循环移位（大循环）**和**不带进位标志位的循环**\n**移位（小循环)**，过程如图2.9所示。循环移位的主要特点是，移出的数位又被\n移入数据中，而**是否带进位则要看是否将进位标志加入循环位移**。例如，带进\n位位的循环左移，如图2.9(d)所示，就是数据位连同进位标志位一起左移，数\n据的最高位移入进位标志位CF，而进位位则依次移入数据的最低位。\n\n![循环移位](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210332086.png)\n\n### 定点数的加减运算\n\n补码加减运算公式\n\n1. 加法\n\n整数 [Al补+[Bl补=[A+Bl补 (mod 2n+1)\n小数 [Al补+[Bl补=[A+B补 (mod 2)\n\n2. 减法\n\nA-B = A+(-B)\n整数 [A- B补=[A+(-B)]补=[Al补+[-Bl补 (mod 21)\n小数[A- B补=[A+(-B)]补=[Al补+[-Bl补 (mod 2)\n**连同符号位一起相加**，符号位产生的进位自然丢掉\n\n> 例如：\n>\n> ![定点小数的加减运算](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210643710.png)\n\n3. 溢出判断\n\n这里再温习一遍溢出，判断溢出很重要，是这一章的重点\n\n​\t3.1.一位符号位判溢出\n\n最高有效位的进位与符号位进位的异或判断溢出\n\n​\t3.2. 两位符号位盘一处\n\n设置双符号位，当双符号位中的数字不相同时说明溢出，值得注意的是：最高符号位代表真正的符号\n\n### 原码的加减法\n加法规则:先判符号位，若相同，则绝对值相加，结果符号位不变;若不同，则做减法，绝对值大数减去绝对值小的数，结果符号位与绝对值大的数相同。\n\n减法规则:两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。\n\n原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位“异或”形成，而乖积的数值部分则是两个数的绝对值相乘之积。\n\n### 一位乘法\n\n- 原码一位乘法\n\n原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位“异或”形成，而乖积的数值部分则是两个数的绝对值相乘之积。\n\n> eg:\n>\n> ![原码一位乘法](https://s2.loli.net/2024/07/24/PDMs83BTeInfUcK.jpg)\n\n- 补码一位乘法\n\nBooth乘法是考的较多的乘法，该方法通过对\n\n1. 符号位参与运算\n2. 累加0，x，-x，避免了符号判断\n\n对于每次加0，x还是加-x，有一个简明概要的方法\n\n1. 每次加法判断当前舍去的位和地位的值\n\n如下表所示：\n\n| y_n  | y_n+1 |      |\n| ---- | ----- | ---- |\n| 0    | 0     | 0    |\n| 0    | 1     | x    |\n| 1    | 0     | -x   |\n| 1    | 1     | 0    |\n\n> eg :\n>\n> ![9e5cd1bad2f699a15d1e404b2d8b3186](https://s2.loli.net/2024/07/24/YGI7qERHlydshmt.jpg)\n\n#### 番外：二位乘法\n\n| yn-1yn yn+1 | 操作                      |\n| ----------- | ------------------------- |\n| 000         | 部分积直接右移两位        |\n| 000         | 部分积加[x]补，右移两位   |\n| 010         | 部分积加[x]补，右移两位   |\n| 011         | 部分积加2[x]补，右移两位  |\n| 100         | 部分积加2[-x]补，右移两位 |\n| 101         | 部分积加[-x]补，右移两位  |\n| 110         | 部分积加[-x]补，右移两位  |\n| 111         | 部分积直接右移两位        |\n\n除了每次移动两位并且多了几种加数外与一位相差不大，也很好记：后三位3就加二倍，4就减二倍，其他类似一位乘。\n\n### 除法——加减交替法\n\n几乎不考，考了就正常手算即可，丢掉符号位算绝对值就行\n\n### 浮点数的表示和运算\n\n重点在于：\n\n1. 表现形式是怎么样的\n2. 表示范围是多少\n3. 浮点数是如何规范化的\n4. 规范化中的精度缺失与舍入方法\n\n$$\nN=S\\times r^j(S为尾数，j是阶码，r是基数/基值)\\\\\n通常在计算机中r取2、4、6、8、16等\\\\\nS为小数，可正可负\nj为整数、可正可负\n$$\n\n1. ***有的地方也将阶码表示为E，未码表示为M***\n\n![浮点数表示形式](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724215312602.png)\n\n![浮点数表示范围](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724215247688.png)\n\n![浮点数的规格化](https://s2.loli.net/2024/07/24/ICp2HrMYElTbtK5.png)\n\n![image-20240724220243190](https://s2.loli.net/2024/07/24/WIoqe4PzGsjOY5a.png)\n\n#### 详细探讨浮点数的规范化与舍入\n\n1. 规格化的：E所有位既不全为0也不全为1。\n\n在IEEE的标准中实际上有四种种舍入方式\n\n　舍入一共有四种方式，分别是**向偶数舍入、向零舍入、向上舍入以及向下舍入。**\n\n1. 就近舍入：即十进制下的“四舍五入”，例如有效数字超出规定数位的多余数字是1001，它大于超出规定最低位的一半（即0.5），故最低位进1。如果多余数字是0111，它小于最低位的一半，则舍掉多余数字（截断尾数、截尾）即可。对于多余数字是1000、正好是最低位一半的特殊情况，最低位为0则舍掉多余位，最低位为1则进位1、使得最低位仍为0（偶数）。\n\n注意这里说明的数位都是指二进制数。\n\n举例：要求保留小数点后3位。\n\n对于1.0011001，舍入处理后为1.010（去掉多余的4位，加0.001）\n对于1.0010111，舍入处理后为1.001（去掉多余的4位）\n对于1.0011000，舍入处理后为1.010（去掉多余的4位，加0.001，使得最低位为0）\n\n对于1.1001001，舍入处理后为1.101（去掉多余的4位，加0.001）\n对于1.1000111，舍入处理后为1.100（去掉多余的4位）\n对于1.1001000，舍入处理后为1.100（去掉多余的4位，不加，因为最低位已经为0）\n\n对于1.01011，舍入处理后为1.011（去掉多余的2位，加0.001）\n对于1.01001，舍入处理后为1.010（去掉多余的2位）\n对于1.01010，舍入处理后为1.010（去掉多余的2位，不加）\n\n对于1.01111，舍入处理后为1.100（去掉多余的2位，加0.001）\n对于1.01101，舍入处理后为1.011（去掉多余的2位）\n对于1.01110，舍入处理后为1.100（去掉多余的2位，加0.001）\n\n2.朝0舍入：即朝数轴零点方向舍入，即直接截尾。\n3.朝正无穷舍入：对正数而言，只要多余位不全为0则向最低有效位进1；负数则直接截尾。\n4.朝负无穷舍入：对负数而言，向最低有效位进1；正数若多余位不全部为0则简单截尾。\n\n但这些舍入方式太过复杂,在不同数字下有不同表现,涉及概率论,具体的两种方式如下\n\n1. “0舍1入法”：右移时被丢掉的最高位是0则直接舍去（包括0之后的）；如果是1则舍去并在最低有效位上加1；\n2. “恒置1”法：只要数位被丢掉，一律在最低有效位上加1.\n\n## 数据的存储方式\n\n### 大端存储和小端存储\n\n数据的“大端方式”和“小端方式”存储现代计算机基本上都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字节数不同，int 和 float型数据占4字节，double型数据占8字节等，而程序中对每个数据只给定一个地址。\n\n假设变量i的地址为08 00H，字节01H、23H、 45H、67H应该各有一个内存地址，那么地址08 00H对应4字节中哪字节的地址呢?这就是字节排列顺序问题。\n\n![大端小端存储](https://s2.loli.net/2024/07/24/2tUcrYiEI1ZNjDQ.png)\n\n### 边界对齐存储\n\n假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。\n\n假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。\n\n![边界对齐](https://s2.loli.net/2024/07/24/fqguQIoOzU4Fp7x.png)\n\n\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第二章.md","raw":"---\ntitle: 计组篇-数据的表示和运算篇\ndate: 2024-08-14 19:47:58\ntags: [计算机组成原理, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# 第二章、数据的表示和运算\n\n## 进位计算制\n\n大体略\n\n有一些值得注意截至 24/7/22 不太熟悉的一些不同进制的性质如下\n\n1. 在原码当中符号位 **1** 为负数，补码当中也是，移码则是相反，补码与原码的替换公式为，符号位不变，数值位取反加 1。\n\n![编码数值分布图](https://s2.loli.net/2024/07/22/VpUcyOEfx837aTS.jpg)\n\n## 定点与浮点数\n\n### 定点数\n\n1. 无符号数\n\n   原码表示数的绝对值 $$0\\to2^n-1$$\n\n   通常**只有无符号整数而没有无符号小数**\n\n2. 有符号数的表示\n\n   ![定点有符号小数](https://s2.loli.net/2024/07/22/YedauQjKrJHRlvD.png)\n\n   ![有符号书的定点表示](https://s2.loli.net/2024/07/22/MJEYtDvpLbOzq5k.png)\n\n   通常第二种有符号定点数更常见，因为很容易理解的，对不同数，无关大小，其转化为准确二进制小数的所占位数是难以简单估量的。\n\n   而且值得注意的是：**移码只能用于表示整数**\n\n| 原码和反码 | —整数表示范围 $$-2^n≤x≤2^n$$ | 小数表示范围 $$-(1-2^n）≤x≤1-2^n$$ |\n| ---------- | --------------------------- | --------------------------------- |\n| 补码       | —整数表示范围-2n ≤x≤2n-1    | 小数表示范围 $$-1≤x≤1-2^n$$        |\n| 移码       | 一整数表示范围-2n≤x≤2n-1    | 移码全 0 真值最小，移码全 1 真值最大  |\n\n​\t对于小数的表示，是截至目前不熟悉的\n\n​\t下面是有关运算方法的运算电路，首先，回顾一下数字电路基础知识\n\n## 数字电路基础知识\n\n### 逻辑门电路\n\n![基础逻辑门电路](https://s2.loli.net/2024/07/22/kmZjxtEcLVUJh7I.png)\n\n![运算规律](https://s2.loli.net/2024/07/22/HEbIwLGh3PfVtiW.png)\n\n![运算规律](https://s2.loli.net/2024/07/22/79Llp3h1z2BZqJV.png)\n\n其中反演律又称德摩根律\n\n### 加法器\n\n![加法器的分类](https://s2.loli.net/2024/07/22/Eh1HJaXjw52zfT6.png)\n\n立！即！推！\n\n![推导](https://s2.loli.net/2024/07/23/d3hQLfZOjMaKPbz.png)\n\n#### 串行定位加法器\n\n**定义**：输入端允许并行输入nbit，因此这种加法器属于：并行加法器，由于进位信息是串行产生的，因此从“进位方式”看，这种加法器属于：串行进位加法器。\n\n综上，很多教材把这种加法器称为“**串行进位的并行加法器**\n\n![逻辑功能示意图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240723224744562.png)\n\n#### 并行进位的并行加法器\n\n并行进位的并行加法器：所有进位信息都是同时产生的，几乎没有延迟。\n**特点：运算速度比“申行进位的并行加法器”更快。**\n\n![并行进位加法器示意图](https://s2.loli.net/2024/07/23/rVE6L7YH8K2zCfF.png)\n\n#### 带标志器的加法器\n\n![带标志器的加法器示意图](https://s2.loli.net/2024/07/23/q2k1uFLtfieITan.png)\n\n四种标志\n\n1. OF（Overflow Flag)溢出标志，用于判断带符号数加减运算是否溢出。OF=1 溢出；OF=O 未溢出\n2. SF（Sign Flag）符号标志，用于判断带符号数加减运算结果的正负性。SF=1 结果为负；SF=O 结果为正\n3. ZF（Zero Flag)零标志，用于判断加减运算结果是否为O。ZF=1表示结果为O；ZF= 表示结果不为0\n4. CF（Carry Flag)进位/借位标志，用于判断无符号数加减运算是否溢出。CF=1 溢出；CF=0 未溢出\n\n> 引入汇编中的标志寄存器：\n>\n> ![汇编标志寄存器](https://s2.loli.net/2024/07/23/KoyEjTGda3mlfXb.png)\n>\n> 该图中绿色区域为奇偶校验码\n>\n> 0,2,4,6,7,8,9,10,11为标志，分别为CF进位标志，PF奇偶标志，AF辅助进位标志，ZF零标志，SF符号标志，TF单步标志，IF中断使能标志，DF方向标志，OF溢出标志\n>\n> 补充上面的五种分别为\n>\n> - **奇偶标志（Parity Flag）**\n>\n> 由于反应运算结果中(转化为二进制)，**\"1\"的奇偶性，也就是个数**。\"1\"的个数为偶数，PF为1。个数为奇数，PF为0.\n> 补充：只包含最低位的一个字节(二进制的后八位)\n>\n> - **辅助进位标志AF(Auxiliary Carry Flag)**\n>\n> 在发生下列情况时，AF的值为1，否则其值为0\n> (1)、在字操作时，发生低字节向高字节进位或错位时；\n> (2)、在字节操作时，发生低4位向高4位进位或错位时；\n>\n> - **中断使能标志位**\n>\n> **是否处于中断中，处于则为一**\n>\n> - **方向标志位**\n>\n> 方向标志位（DF）是Intel 8086/8088 CPU程序状态标志寄存器的一个标志位，用来控制数据串操作指令的步进方向。当设置DF=1时，将以递减顺序对数据串中的数据进行处理；当设置DF=0时，递增\n>\n> - **单步标志位Trap flag**\n>\n> 是否处于debug状态，该标志位为1则单步调试\n\n#### 标志位的生成\n\n立即推！首先注意到是否溢出是很独特的。\n\n通过基础的学习可以知道，判断是否溢出有很多方式。。\n\n首先看一下如何出现溢出？\n\n首先看无符号数？\n\n对无符号数而言，均表示绝对值，溢出后相当于$$mod2^n$$，这在很多情况下是很自然地，因此通常我们讲**无符号数不存在溢出**\n\n对有符号数而言\n\n1. 两个正数相加\n2. 两个负数相加\n\n显然异号数相加是不会影响到加法器的正常运行的。\n\n第一种情况，我们发现实际上他并没有真正的溢出，而是**变成了一个负数！**，第二种情况，实际上真的有1进位出去了，而且此时的情况还是比较复杂的。\n\n写一下最高位下的真值表\n\n| A    | B    | C_in | C_out | S    |\n| ---- | ---- | ---- | ----- | ---- |\n| ..   | ..   | ..   | ..    | ..   |\n| 1    | 1    | 0    | 1     | 0    |\n| 0    | 0    | 1    | 0     | 1    |\n| ..   | ..   | ..   | ..    | ..   |\n\n可以发现，当进位与当前位进位，即运算后的高两位进位不同时即可判断发生溢出\n\n谈及溢出，这里就温习一下所有的判断溢出方法\n\n1. 朴素符号法\n\nXf、Yf分别两个数的符号位,Zf为运算结果符号位。\n当Xf =Yf =0（两数同为正）,而Zf=1(结果为负)时,负溢出；\n当出现Xf =Yf =1（两数同为负）,而Zf=0（结果为正），正溢出.\n\n2. 上文提到的加法器\n\n$$OF=Cn \\oplus Cn-1$$\n\n3. 双符号法\n\n用变形补码进行双符号位运算（正数符为00,负数符号以11）\n若运算结果的符号位为\"01\",则正溢；\n若结果双符号为10,则负溢出；\n若结果的双符号位为00或11，无溢出\n\n解决了加法器的问题，剩下的就很简单了\n\n$$OF = C \\oplus Cn-1 $$ -即最高位的进位④次高位的进位。反映带符号数加减运算是否溢出。\n$$SF=S$$,一一也就是取运算结果的最高位（符号位）。反映带符号数加减运算的正负性。\n$$ZF= \\overline{Sn+…+S2+S1}$$ 一一仅当运算结果所有 bit 全0时，ZF才为1，此时表示运算结果为O。\n$$CF=Cout \\oplus Cin=Cn \\oplus C_0$$一一反映无符号数加减运算是否溢出。\n\n### 并行加法运算器\n\n回顾串行进位\n\n![逻辑电路图](https://s2.loli.net/2024/07/23/nMocZ4N68s2rYKP.png)\n\n![并行进位示意图](https://s2.loli.net/2024/07/23/jaKcwoJBqD7xFLi.png)\n\n### 多路选择器（MUX）\n\n![选择器示意图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240723235506535.png)\n\n### 三态门\n\n![三态门电路示意](https://s2.loli.net/2024/07/23/H1MaprNRSyGxihK.png)\n\n### 算术逻辑单元ALU\n\n1. ALU是运算器的核心\n2. 加法器是运算器的核心\n\n![功能图](https://s2.loli.net/2024/07/23/eFRBuMEJaojYGwy.png)\n\n3. **若ALU有k种功能，那么控制信号位数$$m \\ge \\left\\lfloor log_2k\\right\\rfloor$$**\n\n4. ALU的运算数、运算结果位数与计算机的机器字长相同\n\n![ALU](https://s2.loli.net/2024/07/24/FuklLJyCnUwqEh5.png)\n\n## 运算\n\n### 定点数的移位运算\n\n计算机的移位操作分为**算数移位**和**逻辑移位**\n\n![算术移位规则图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210022980.png)\n\n![算术移位与逻辑一味的区别](https://s2.loli.net/2024/07/24/6ua5YAKiTjEmtL1.png)\n\n>eg: 对 10110010\n>\n>逻辑左移 10100110\t逻辑右移 01011001\n>\n>算数左移 00100110\t算数右移 11011001（只有**补码在算术移位下才添1**）\n\n### 循环移位\n\n​\t循环移位分为**带进位标志位CF的循环移位（大循环）**和**不带进位标志位的循环**\n**移位（小循环)**，过程如图2.9所示。循环移位的主要特点是，移出的数位又被\n移入数据中，而**是否带进位则要看是否将进位标志加入循环位移**。例如，带进\n位位的循环左移，如图2.9(d)所示，就是数据位连同进位标志位一起左移，数\n据的最高位移入进位标志位CF，而进位位则依次移入数据的最低位。\n\n![循环移位](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210332086.png)\n\n### 定点数的加减运算\n\n补码加减运算公式\n\n1. 加法\n\n整数 [Al补+[Bl补=[A+Bl补 (mod 2n+1)\n小数 [Al补+[Bl补=[A+B补 (mod 2)\n\n2. 减法\n\nA-B = A+(-B)\n整数 [A- B补=[A+(-B)]补=[Al补+[-Bl补 (mod 21)\n小数[A- B补=[A+(-B)]补=[Al补+[-Bl补 (mod 2)\n**连同符号位一起相加**，符号位产生的进位自然丢掉\n\n> 例如：\n>\n> ![定点小数的加减运算](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210643710.png)\n\n3. 溢出判断\n\n这里再温习一遍溢出，判断溢出很重要，是这一章的重点\n\n​\t3.1.一位符号位判溢出\n\n最高有效位的进位与符号位进位的异或判断溢出\n\n​\t3.2. 两位符号位盘一处\n\n设置双符号位，当双符号位中的数字不相同时说明溢出，值得注意的是：最高符号位代表真正的符号\n\n### 原码的加减法\n加法规则:先判符号位，若相同，则绝对值相加，结果符号位不变;若不同，则做减法，绝对值大数减去绝对值小的数，结果符号位与绝对值大的数相同。\n\n减法规则:两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。\n\n原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位“异或”形成，而乖积的数值部分则是两个数的绝对值相乘之积。\n\n### 一位乘法\n\n- 原码一位乘法\n\n原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位“异或”形成，而乖积的数值部分则是两个数的绝对值相乘之积。\n\n> eg:\n>\n> ![原码一位乘法](https://s2.loli.net/2024/07/24/PDMs83BTeInfUcK.jpg)\n\n- 补码一位乘法\n\nBooth乘法是考的较多的乘法，该方法通过对\n\n1. 符号位参与运算\n2. 累加0，x，-x，避免了符号判断\n\n对于每次加0，x还是加-x，有一个简明概要的方法\n\n1. 每次加法判断当前舍去的位和地位的值\n\n如下表所示：\n\n| y_n  | y_n+1 |      |\n| ---- | ----- | ---- |\n| 0    | 0     | 0    |\n| 0    | 1     | x    |\n| 1    | 0     | -x   |\n| 1    | 1     | 0    |\n\n> eg :\n>\n> ![9e5cd1bad2f699a15d1e404b2d8b3186](https://s2.loli.net/2024/07/24/YGI7qERHlydshmt.jpg)\n\n#### 番外：二位乘法\n\n| yn-1yn yn+1 | 操作                      |\n| ----------- | ------------------------- |\n| 000         | 部分积直接右移两位        |\n| 000         | 部分积加[x]补，右移两位   |\n| 010         | 部分积加[x]补，右移两位   |\n| 011         | 部分积加2[x]补，右移两位  |\n| 100         | 部分积加2[-x]补，右移两位 |\n| 101         | 部分积加[-x]补，右移两位  |\n| 110         | 部分积加[-x]补，右移两位  |\n| 111         | 部分积直接右移两位        |\n\n除了每次移动两位并且多了几种加数外与一位相差不大，也很好记：后三位3就加二倍，4就减二倍，其他类似一位乘。\n\n### 除法——加减交替法\n\n几乎不考，考了就正常手算即可，丢掉符号位算绝对值就行\n\n### 浮点数的表示和运算\n\n重点在于：\n\n1. 表现形式是怎么样的\n2. 表示范围是多少\n3. 浮点数是如何规范化的\n4. 规范化中的精度缺失与舍入方法\n\n$$\nN=S\\times r^j(S为尾数，j是阶码，r是基数/基值)\\\\\n通常在计算机中r取2、4、6、8、16等\\\\\nS为小数，可正可负\nj为整数、可正可负\n$$\n\n1. ***有的地方也将阶码表示为E，未码表示为M***\n\n![浮点数表示形式](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724215312602.png)\n\n![浮点数表示范围](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724215247688.png)\n\n![浮点数的规格化](https://s2.loli.net/2024/07/24/ICp2HrMYElTbtK5.png)\n\n![image-20240724220243190](https://s2.loli.net/2024/07/24/WIoqe4PzGsjOY5a.png)\n\n#### 详细探讨浮点数的规范化与舍入\n\n1. 规格化的：E所有位既不全为0也不全为1。\n\n在IEEE的标准中实际上有四种种舍入方式\n\n　舍入一共有四种方式，分别是**向偶数舍入、向零舍入、向上舍入以及向下舍入。**\n\n1. 就近舍入：即十进制下的“四舍五入”，例如有效数字超出规定数位的多余数字是1001，它大于超出规定最低位的一半（即0.5），故最低位进1。如果多余数字是0111，它小于最低位的一半，则舍掉多余数字（截断尾数、截尾）即可。对于多余数字是1000、正好是最低位一半的特殊情况，最低位为0则舍掉多余位，最低位为1则进位1、使得最低位仍为0（偶数）。\n\n注意这里说明的数位都是指二进制数。\n\n举例：要求保留小数点后3位。\n\n对于1.0011001，舍入处理后为1.010（去掉多余的4位，加0.001）\n对于1.0010111，舍入处理后为1.001（去掉多余的4位）\n对于1.0011000，舍入处理后为1.010（去掉多余的4位，加0.001，使得最低位为0）\n\n对于1.1001001，舍入处理后为1.101（去掉多余的4位，加0.001）\n对于1.1000111，舍入处理后为1.100（去掉多余的4位）\n对于1.1001000，舍入处理后为1.100（去掉多余的4位，不加，因为最低位已经为0）\n\n对于1.01011，舍入处理后为1.011（去掉多余的2位，加0.001）\n对于1.01001，舍入处理后为1.010（去掉多余的2位）\n对于1.01010，舍入处理后为1.010（去掉多余的2位，不加）\n\n对于1.01111，舍入处理后为1.100（去掉多余的2位，加0.001）\n对于1.01101，舍入处理后为1.011（去掉多余的2位）\n对于1.01110，舍入处理后为1.100（去掉多余的2位，加0.001）\n\n2.朝0舍入：即朝数轴零点方向舍入，即直接截尾。\n3.朝正无穷舍入：对正数而言，只要多余位不全为0则向最低有效位进1；负数则直接截尾。\n4.朝负无穷舍入：对负数而言，向最低有效位进1；正数若多余位不全部为0则简单截尾。\n\n但这些舍入方式太过复杂,在不同数字下有不同表现,涉及概率论,具体的两种方式如下\n\n1. “0舍1入法”：右移时被丢掉的最高位是0则直接舍去（包括0之后的）；如果是1则舍去并在最低有效位上加1；\n2. “恒置1”法：只要数位被丢掉，一律在最低有效位上加1.\n\n## 数据的存储方式\n\n### 大端存储和小端存储\n\n数据的“大端方式”和“小端方式”存储现代计算机基本上都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字节数不同，int 和 float型数据占4字节，double型数据占8字节等，而程序中对每个数据只给定一个地址。\n\n假设变量i的地址为08 00H，字节01H、23H、 45H、67H应该各有一个内存地址，那么地址08 00H对应4字节中哪字节的地址呢?这就是字节排列顺序问题。\n\n![大端小端存储](https://s2.loli.net/2024/07/24/2tUcrYiEI1ZNjDQ.png)\n\n### 边界对齐存储\n\n假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。\n\n假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。\n\n![边界对齐](https://s2.loli.net/2024/07/24/fqguQIoOzU4Fp7x.png)\n\n\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerStructure/第二章","published":1,"updated":"2024-08-17T13:22:38.164Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqe000zm8wv46cb0fgy","content":"<h1 id=\"第二章、数据的表示和运算\"><a href=\"#第二章、数据的表示和运算\" class=\"headerlink\" title=\"第二章、数据的表示和运算\"></a>第二章、数据的表示和运算</h1><h2 id=\"进位计算制\"><a href=\"#进位计算制\" class=\"headerlink\" title=\"进位计算制\"></a>进位计算制</h2><p>大体略</p>\n<p>有一些值得注意截至 24/7/22 不太熟悉的一些不同进制的性质如下</p>\n<ol>\n<li>在原码当中符号位 <strong>1</strong> 为负数，补码当中也是，移码则是相反，补码与原码的替换公式为，符号位不变，数值位取反加 1。</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/22/VpUcyOEfx837aTS.jpg\" alt=\"编码数值分布图\"></p>\n<h2 id=\"定点与浮点数\"><a href=\"#定点与浮点数\" class=\"headerlink\" title=\"定点与浮点数\"></a>定点与浮点数</h2><h3 id=\"定点数\"><a href=\"#定点数\" class=\"headerlink\" title=\"定点数\"></a>定点数</h3><ol>\n<li><p>无符号数</p>\n<p>原码表示数的绝对值 <script type=\"math/tex\">0\\to2^n-1</script></p>\n<p>通常<strong>只有无符号整数而没有无符号小数</strong></p>\n</li>\n<li><p>有符号数的表示</p>\n<p><img src=\"https://s2.loli.net/2024/07/22/YedauQjKrJHRlvD.png\" alt=\"定点有符号小数\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/22/MJEYtDvpLbOzq5k.png\" alt=\"有符号书的定点表示\"></p>\n<p>通常第二种有符号定点数更常见，因为很容易理解的，对不同数，无关大小，其转化为准确二进制小数的所占位数是难以简单估量的。</p>\n<p>而且值得注意的是：<strong>移码只能用于表示整数</strong></p>\n</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>原码和反码</th>\n<th>—整数表示范围 <script type=\"math/tex\">-2^n≤x≤2^n</script></th>\n<th>小数表示范围 <script type=\"math/tex\">-(1-2^n）≤x≤1-2^n</script></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>补码</td>\n<td>—整数表示范围-2n ≤x≤2n-1</td>\n<td>小数表示范围 <script type=\"math/tex\">-1≤x≤1-2^n</script></td>\n</tr>\n<tr>\n<td>移码</td>\n<td>一整数表示范围-2n≤x≤2n-1</td>\n<td>移码全 0 真值最小，移码全 1 真值最大</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>​    对于小数的表示，是截至目前不熟悉的</p>\n<p>​    下面是有关运算方法的运算电路，首先，回顾一下数字电路基础知识</p>\n<h2 id=\"数字电路基础知识\"><a href=\"#数字电路基础知识\" class=\"headerlink\" title=\"数字电路基础知识\"></a>数字电路基础知识</h2><h3 id=\"逻辑门电路\"><a href=\"#逻辑门电路\" class=\"headerlink\" title=\"逻辑门电路\"></a>逻辑门电路</h3><p><img src=\"https://s2.loli.net/2024/07/22/kmZjxtEcLVUJh7I.png\" alt=\"基础逻辑门电路\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/22/HEbIwLGh3PfVtiW.png\" alt=\"运算规律\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/22/79Llp3h1z2BZqJV.png\" alt=\"运算规律\"></p>\n<p>其中反演律又称德摩根律</p>\n<h3 id=\"加法器\"><a href=\"#加法器\" class=\"headerlink\" title=\"加法器\"></a>加法器</h3><p><img src=\"https://s2.loli.net/2024/07/22/Eh1HJaXjw52zfT6.png\" alt=\"加法器的分类\"></p>\n<p>立！即！推！</p>\n<p><img src=\"https://s2.loli.net/2024/07/23/d3hQLfZOjMaKPbz.png\" alt=\"推导\"></p>\n<h4 id=\"串行定位加法器\"><a href=\"#串行定位加法器\" class=\"headerlink\" title=\"串行定位加法器\"></a>串行定位加法器</h4><p><strong>定义</strong>：输入端允许并行输入nbit，因此这种加法器属于：并行加法器，由于进位信息是串行产生的，因此从“进位方式”看，这种加法器属于：串行进位加法器。</p>\n<p>综上，很多教材把这种加法器称为“<strong>串行进位的并行加法器</strong></p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240723224744562.png\" alt=\"逻辑功能示意图\"></p>\n<h4 id=\"并行进位的并行加法器\"><a href=\"#并行进位的并行加法器\" class=\"headerlink\" title=\"并行进位的并行加法器\"></a>并行进位的并行加法器</h4><p>并行进位的并行加法器：所有进位信息都是同时产生的，几乎没有延迟。<br><strong>特点：运算速度比“申行进位的并行加法器”更快。</strong></p>\n<p><img src=\"https://s2.loli.net/2024/07/23/rVE6L7YH8K2zCfF.png\" alt=\"并行进位加法器示意图\"></p>\n<h4 id=\"带标志器的加法器\"><a href=\"#带标志器的加法器\" class=\"headerlink\" title=\"带标志器的加法器\"></a>带标志器的加法器</h4><p><img src=\"https://s2.loli.net/2024/07/23/q2k1uFLtfieITan.png\" alt=\"带标志器的加法器示意图\"></p>\n<p>四种标志</p>\n<ol>\n<li>OF（Overflow Flag)溢出标志，用于判断带符号数加减运算是否溢出。OF=1 溢出；OF=O 未溢出</li>\n<li>SF（Sign Flag）符号标志，用于判断带符号数加减运算结果的正负性。SF=1 结果为负；SF=O 结果为正</li>\n<li>ZF（Zero Flag)零标志，用于判断加减运算结果是否为O。ZF=1表示结果为O；ZF= 表示结果不为0</li>\n<li>CF（Carry Flag)进位/借位标志，用于判断无符号数加减运算是否溢出。CF=1 溢出；CF=0 未溢出</li>\n</ol>\n<blockquote>\n<p>引入汇编中的标志寄存器：</p>\n<p><img src=\"https://s2.loli.net/2024/07/23/KoyEjTGda3mlfXb.png\" alt=\"汇编标志寄存器\"></p>\n<p>该图中绿色区域为奇偶校验码</p>\n<p>0,2,4,6,7,8,9,10,11为标志，分别为CF进位标志，PF奇偶标志，AF辅助进位标志，ZF零标志，SF符号标志，TF单步标志，IF中断使能标志，DF方向标志，OF溢出标志</p>\n<p>补充上面的五种分别为</p>\n<ul>\n<li><strong>奇偶标志（Parity Flag）</strong></li>\n</ul>\n<p>由于反应运算结果中(转化为二进制)，<strong>“1”的奇偶性，也就是个数</strong>。”1”的个数为偶数，PF为1。个数为奇数，PF为0.<br>补充：只包含最低位的一个字节(二进制的后八位)</p>\n<ul>\n<li><strong>辅助进位标志AF(Auxiliary Carry Flag)</strong></li>\n</ul>\n<p>在发生下列情况时，AF的值为1，否则其值为0<br>(1)、在字操作时，发生低字节向高字节进位或错位时；<br>(2)、在字节操作时，发生低4位向高4位进位或错位时；</p>\n<ul>\n<li><strong>中断使能标志位</strong></li>\n</ul>\n<p><strong>是否处于中断中，处于则为一</strong></p>\n<ul>\n<li><strong>方向标志位</strong></li>\n</ul>\n<p>方向标志位（DF）是Intel 8086/8088 CPU程序状态标志寄存器的一个标志位，用来控制数据串操作指令的步进方向。当设置DF=1时，将以递减顺序对数据串中的数据进行处理；当设置DF=0时，递增</p>\n<ul>\n<li><strong>单步标志位Trap flag</strong></li>\n</ul>\n<p>是否处于debug状态，该标志位为1则单步调试</p>\n</blockquote>\n<h4 id=\"标志位的生成\"><a href=\"#标志位的生成\" class=\"headerlink\" title=\"标志位的生成\"></a>标志位的生成</h4><p>立即推！首先注意到是否溢出是很独特的。</p>\n<p>通过基础的学习可以知道，判断是否溢出有很多方式。。</p>\n<p>首先看一下如何出现溢出？</p>\n<p>首先看无符号数？</p>\n<p>对无符号数而言，均表示绝对值，溢出后相当于<script type=\"math/tex\">mod2^n</script>，这在很多情况下是很自然地，因此通常我们讲<strong>无符号数不存在溢出</strong></p>\n<p>对有符号数而言</p>\n<ol>\n<li>两个正数相加</li>\n<li>两个负数相加</li>\n</ol>\n<p>显然异号数相加是不会影响到加法器的正常运行的。</p>\n<p>第一种情况，我们发现实际上他并没有真正的溢出，而是<strong>变成了一个负数！</strong>，第二种情况，实际上真的有1进位出去了，而且此时的情况还是比较复杂的。</p>\n<p>写一下最高位下的真值表</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>A</th>\n<th>B</th>\n<th>C_in</th>\n<th>C_out</th>\n<th>S</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>可以发现，当进位与当前位进位，即运算后的高两位进位不同时即可判断发生溢出</p>\n<p>谈及溢出，这里就温习一下所有的判断溢出方法</p>\n<ol>\n<li>朴素符号法</li>\n</ol>\n<p>Xf、Yf分别两个数的符号位,Zf为运算结果符号位。<br>当Xf =Yf =0（两数同为正）,而Zf=1(结果为负)时,负溢出；<br>当出现Xf =Yf =1（两数同为负）,而Zf=0（结果为正），正溢出.</p>\n<ol>\n<li>上文提到的加法器</li>\n</ol>\n<script type=\"math/tex; mode=display\">OF=Cn \\oplus Cn-1</script><ol>\n<li>双符号法</li>\n</ol>\n<p>用变形补码进行双符号位运算（正数符为00,负数符号以11）<br>若运算结果的符号位为”01”,则正溢；<br>若结果双符号为10,则负溢出；<br>若结果的双符号位为00或11，无溢出</p>\n<p>解决了加法器的问题，剩下的就很简单了</p>\n<script type=\"math/tex; mode=display\">OF = C \\oplus Cn-1 $$ -即最高位的进位④次高位的进位。反映带符号数加减运算是否溢出。\n$$SF=S$$,一一也就是取运算结果的最高位（符号位）。反映带符号数加减运算的正负性。\n$$ZF= \\overline{Sn+…+S2+S1}$$ 一一仅当运算结果所有 bit 全0时，ZF才为1，此时表示运算结果为O。\n$$CF=Cout \\oplus Cin=Cn \\oplus C_0$$一一反映无符号数加减运算是否溢出。\n\n### 并行加法运算器\n\n回顾串行进位\n\n![逻辑电路图](https://s2.loli.net/2024/07/23/nMocZ4N68s2rYKP.png)\n\n![并行进位示意图](https://s2.loli.net/2024/07/23/jaKcwoJBqD7xFLi.png)\n\n### 多路选择器（MUX）\n\n![选择器示意图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240723235506535.png)\n\n### 三态门\n\n![三态门电路示意](https://s2.loli.net/2024/07/23/H1MaprNRSyGxihK.png)\n\n### 算术逻辑单元ALU\n\n1. ALU是运算器的核心\n2. 加法器是运算器的核心\n\n![功能图](https://s2.loli.net/2024/07/23/eFRBuMEJaojYGwy.png)\n\n3. **若ALU有k种功能，那么控制信号位数$$m \\ge \\left\\lfloor log_2k\\right\\rfloor$$**\n\n4. ALU的运算数、运算结果位数与计算机的机器字长相同\n\n![ALU](https://s2.loli.net/2024/07/24/FuklLJyCnUwqEh5.png)\n\n## 运算\n\n### 定点数的移位运算\n\n计算机的移位操作分为**算数移位**和**逻辑移位**\n\n![算术移位规则图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210022980.png)\n\n![算术移位与逻辑一味的区别](https://s2.loli.net/2024/07/24/6ua5YAKiTjEmtL1.png)\n\n>eg: 对 10110010\n>\n>逻辑左移 10100110    逻辑右移 01011001\n>\n>算数左移 00100110    算数右移 11011001（只有**补码在算术移位下才添1**）\n\n### 循环移位\n\n​    循环移位分为**带进位标志位CF的循环移位（大循环）**和**不带进位标志位的循环**\n**移位（小循环)**，过程如图2.9所示。循环移位的主要特点是，移出的数位又被\n移入数据中，而**是否带进位则要看是否将进位标志加入循环位移**。例如，带进\n位位的循环左移，如图2.9(d)所示，就是数据位连同进位标志位一起左移，数\n据的最高位移入进位标志位CF，而进位位则依次移入数据的最低位。\n\n![循环移位](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210332086.png)\n\n### 定点数的加减运算\n\n补码加减运算公式\n\n1. 加法\n\n整数 [Al补+[Bl补=[A+Bl补 (mod 2n+1)\n小数 [Al补+[Bl补=[A+B补 (mod 2)\n\n2. 减法\n\nA-B = A+(-B)\n整数 [A- B补=[A+(-B)]补=[Al补+[-Bl补 (mod 21)\n小数[A- B补=[A+(-B)]补=[Al补+[-Bl补 (mod 2)\n**连同符号位一起相加**，符号位产生的进位自然丢掉\n\n> 例如：\n>\n> ![定点小数的加减运算](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210643710.png)\n\n3. 溢出判断\n\n这里再温习一遍溢出，判断溢出很重要，是这一章的重点\n\n​    3.1.一位符号位判溢出\n\n最高有效位的进位与符号位进位的异或判断溢出\n\n​    3.2. 两位符号位盘一处\n\n设置双符号位，当双符号位中的数字不相同时说明溢出，值得注意的是：最高符号位代表真正的符号\n\n### 原码的加减法\n加法规则:先判符号位，若相同，则绝对值相加，结果符号位不变;若不同，则做减法，绝对值大数减去绝对值小的数，结果符号位与绝对值大的数相同。\n\n减法规则:两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。\n\n原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位“异或”形成，而乖积的数值部分则是两个数的绝对值相乘之积。\n\n### 一位乘法\n\n- 原码一位乘法\n\n原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位“异或”形成，而乖积的数值部分则是两个数的绝对值相乘之积。\n\n> eg:\n>\n> ![原码一位乘法](https://s2.loli.net/2024/07/24/PDMs83BTeInfUcK.jpg)\n\n- 补码一位乘法\n\nBooth乘法是考的较多的乘法，该方法通过对\n\n1. 符号位参与运算\n2. 累加0，x，-x，避免了符号判断\n\n对于每次加0，x还是加-x，有一个简明概要的方法\n\n1. 每次加法判断当前舍去的位和地位的值\n\n如下表所示：\n\n| y_n  | y_n+1 |      |\n| ---- | ----- | ---- |\n| 0    | 0     | 0    |\n| 0    | 1     | x    |\n| 1    | 0     | -x   |\n| 1    | 1     | 0    |\n\n> eg :\n>\n> ![9e5cd1bad2f699a15d1e404b2d8b3186](https://s2.loli.net/2024/07/24/YGI7qERHlydshmt.jpg)\n\n#### 番外：二位乘法\n\n| yn-1yn yn+1 | 操作                      |\n| ----------- | ------------------------- |\n| 000         | 部分积直接右移两位        |\n| 000         | 部分积加[x]补，右移两位   |\n| 010         | 部分积加[x]补，右移两位   |\n| 011         | 部分积加2[x]补，右移两位  |\n| 100         | 部分积加2[-x]补，右移两位 |\n| 101         | 部分积加[-x]补，右移两位  |\n| 110         | 部分积加[-x]补，右移两位  |\n| 111         | 部分积直接右移两位        |\n\n除了每次移动两位并且多了几种加数外与一位相差不大，也很好记：后三位3就加二倍，4就减二倍，其他类似一位乘。\n\n### 除法——加减交替法\n\n几乎不考，考了就正常手算即可，丢掉符号位算绝对值就行\n\n### 浮点数的表示和运算\n\n重点在于：\n\n1. 表现形式是怎么样的\n2. 表示范围是多少\n3. 浮点数是如何规范化的\n4. 规范化中的精度缺失与舍入方法</script><p>N=S\\times r^j(S为尾数，j是阶码，r是基数/基值)\\<br>通常在计算机中r取2、4、6、8、16等\\<br>S为小数，可正可负<br>j为整数、可正可负</p>\n<p>$$</p>\n<ol>\n<li><strong><em>有的地方也将阶码表示为E，未码表示为M</em></strong></li>\n</ol>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724215312602.png\" alt=\"浮点数表示形式\"></p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724215247688.png\" alt=\"浮点数表示范围\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/24/ICp2HrMYElTbtK5.png\" alt=\"浮点数的规格化\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/24/WIoqe4PzGsjOY5a.png\" alt=\"image-20240724220243190\"></p>\n<h4 id=\"详细探讨浮点数的规范化与舍入\"><a href=\"#详细探讨浮点数的规范化与舍入\" class=\"headerlink\" title=\"详细探讨浮点数的规范化与舍入\"></a>详细探讨浮点数的规范化与舍入</h4><ol>\n<li>规格化的：E所有位既不全为0也不全为1。</li>\n</ol>\n<p>在IEEE的标准中实际上有四种种舍入方式</p>\n<p>　舍入一共有四种方式，分别是<strong>向偶数舍入、向零舍入、向上舍入以及向下舍入。</strong></p>\n<ol>\n<li>就近舍入：即十进制下的“四舍五入”，例如有效数字超出规定数位的多余数字是1001，它大于超出规定最低位的一半（即0.5），故最低位进1。如果多余数字是0111，它小于最低位的一半，则舍掉多余数字（截断尾数、截尾）即可。对于多余数字是1000、正好是最低位一半的特殊情况，最低位为0则舍掉多余位，最低位为1则进位1、使得最低位仍为0（偶数）。</li>\n</ol>\n<p>注意这里说明的数位都是指二进制数。</p>\n<p>举例：要求保留小数点后3位。</p>\n<p>对于1.0011001，舍入处理后为1.010（去掉多余的4位，加0.001）<br>对于1.0010111，舍入处理后为1.001（去掉多余的4位）<br>对于1.0011000，舍入处理后为1.010（去掉多余的4位，加0.001，使得最低位为0）</p>\n<p>对于1.1001001，舍入处理后为1.101（去掉多余的4位，加0.001）<br>对于1.1000111，舍入处理后为1.100（去掉多余的4位）<br>对于1.1001000，舍入处理后为1.100（去掉多余的4位，不加，因为最低位已经为0）</p>\n<p>对于1.01011，舍入处理后为1.011（去掉多余的2位，加0.001）<br>对于1.01001，舍入处理后为1.010（去掉多余的2位）<br>对于1.01010，舍入处理后为1.010（去掉多余的2位，不加）</p>\n<p>对于1.01111，舍入处理后为1.100（去掉多余的2位，加0.001）<br>对于1.01101，舍入处理后为1.011（去掉多余的2位）<br>对于1.01110，舍入处理后为1.100（去掉多余的2位，加0.001）</p>\n<p>2.朝0舍入：即朝数轴零点方向舍入，即直接截尾。<br>3.朝正无穷舍入：对正数而言，只要多余位不全为0则向最低有效位进1；负数则直接截尾。<br>4.朝负无穷舍入：对负数而言，向最低有效位进1；正数若多余位不全部为0则简单截尾。</p>\n<p>但这些舍入方式太过复杂,在不同数字下有不同表现,涉及概率论,具体的两种方式如下</p>\n<ol>\n<li>“0舍1入法”：右移时被丢掉的最高位是0则直接舍去（包括0之后的）；如果是1则舍去并在最低有效位上加1；</li>\n<li>“恒置1”法：只要数位被丢掉，一律在最低有效位上加1.</li>\n</ol>\n<h2 id=\"数据的存储方式\"><a href=\"#数据的存储方式\" class=\"headerlink\" title=\"数据的存储方式\"></a>数据的存储方式</h2><h3 id=\"大端存储和小端存储\"><a href=\"#大端存储和小端存储\" class=\"headerlink\" title=\"大端存储和小端存储\"></a>大端存储和小端存储</h3><p>数据的“大端方式”和“小端方式”存储现代计算机基本上都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字节数不同，int 和 float型数据占4字节，double型数据占8字节等，而程序中对每个数据只给定一个地址。</p>\n<p>假设变量i的地址为08 00H，字节01H、23H、 45H、67H应该各有一个内存地址，那么地址08 00H对应4字节中哪字节的地址呢?这就是字节排列顺序问题。</p>\n<p><img src=\"https://s2.loli.net/2024/07/24/2tUcrYiEI1ZNjDQ.png\" alt=\"大端小端存储\"></p>\n<h3 id=\"边界对齐存储\"><a href=\"#边界对齐存储\" class=\"headerlink\" title=\"边界对齐存储\"></a>边界对齐存储</h3><p>假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。</p>\n<p>假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。</p>\n<p><img src=\"https://s2.loli.net/2024/07/24/fqguQIoOzU4Fp7x.png\" alt=\"边界对齐\"></p>\n<!-- flag of hidden posts -->","length":4113,"excerpt":"","more":"<h1 id=\"第二章、数据的表示和运算\"><a href=\"#第二章、数据的表示和运算\" class=\"headerlink\" title=\"第二章、数据的表示和运算\"></a>第二章、数据的表示和运算</h1><h2 id=\"进位计算制\"><a href=\"#进位计算制\" class=\"headerlink\" title=\"进位计算制\"></a>进位计算制</h2><p>大体略</p>\n<p>有一些值得注意截至 24/7/22 不太熟悉的一些不同进制的性质如下</p>\n<ol>\n<li>在原码当中符号位 <strong>1</strong> 为负数，补码当中也是，移码则是相反，补码与原码的替换公式为，符号位不变，数值位取反加 1。</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/22/VpUcyOEfx837aTS.jpg\" alt=\"编码数值分布图\"></p>\n<h2 id=\"定点与浮点数\"><a href=\"#定点与浮点数\" class=\"headerlink\" title=\"定点与浮点数\"></a>定点与浮点数</h2><h3 id=\"定点数\"><a href=\"#定点数\" class=\"headerlink\" title=\"定点数\"></a>定点数</h3><ol>\n<li><p>无符号数</p>\n<p>原码表示数的绝对值 <script type=\"math/tex\">0\\to2^n-1</script></p>\n<p>通常<strong>只有无符号整数而没有无符号小数</strong></p>\n</li>\n<li><p>有符号数的表示</p>\n<p><img src=\"https://s2.loli.net/2024/07/22/YedauQjKrJHRlvD.png\" alt=\"定点有符号小数\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/22/MJEYtDvpLbOzq5k.png\" alt=\"有符号书的定点表示\"></p>\n<p>通常第二种有符号定点数更常见，因为很容易理解的，对不同数，无关大小，其转化为准确二进制小数的所占位数是难以简单估量的。</p>\n<p>而且值得注意的是：<strong>移码只能用于表示整数</strong></p>\n</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>原码和反码</th>\n<th>—整数表示范围 <script type=\"math/tex\">-2^n≤x≤2^n</script></th>\n<th>小数表示范围 <script type=\"math/tex\">-(1-2^n）≤x≤1-2^n</script></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>补码</td>\n<td>—整数表示范围-2n ≤x≤2n-1</td>\n<td>小数表示范围 <script type=\"math/tex\">-1≤x≤1-2^n</script></td>\n</tr>\n<tr>\n<td>移码</td>\n<td>一整数表示范围-2n≤x≤2n-1</td>\n<td>移码全 0 真值最小，移码全 1 真值最大</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>​    对于小数的表示，是截至目前不熟悉的</p>\n<p>​    下面是有关运算方法的运算电路，首先，回顾一下数字电路基础知识</p>\n<h2 id=\"数字电路基础知识\"><a href=\"#数字电路基础知识\" class=\"headerlink\" title=\"数字电路基础知识\"></a>数字电路基础知识</h2><h3 id=\"逻辑门电路\"><a href=\"#逻辑门电路\" class=\"headerlink\" title=\"逻辑门电路\"></a>逻辑门电路</h3><p><img src=\"https://s2.loli.net/2024/07/22/kmZjxtEcLVUJh7I.png\" alt=\"基础逻辑门电路\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/22/HEbIwLGh3PfVtiW.png\" alt=\"运算规律\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/22/79Llp3h1z2BZqJV.png\" alt=\"运算规律\"></p>\n<p>其中反演律又称德摩根律</p>\n<h3 id=\"加法器\"><a href=\"#加法器\" class=\"headerlink\" title=\"加法器\"></a>加法器</h3><p><img src=\"https://s2.loli.net/2024/07/22/Eh1HJaXjw52zfT6.png\" alt=\"加法器的分类\"></p>\n<p>立！即！推！</p>\n<p><img src=\"https://s2.loli.net/2024/07/23/d3hQLfZOjMaKPbz.png\" alt=\"推导\"></p>\n<h4 id=\"串行定位加法器\"><a href=\"#串行定位加法器\" class=\"headerlink\" title=\"串行定位加法器\"></a>串行定位加法器</h4><p><strong>定义</strong>：输入端允许并行输入nbit，因此这种加法器属于：并行加法器，由于进位信息是串行产生的，因此从“进位方式”看，这种加法器属于：串行进位加法器。</p>\n<p>综上，很多教材把这种加法器称为“<strong>串行进位的并行加法器</strong></p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240723224744562.png\" alt=\"逻辑功能示意图\"></p>\n<h4 id=\"并行进位的并行加法器\"><a href=\"#并行进位的并行加法器\" class=\"headerlink\" title=\"并行进位的并行加法器\"></a>并行进位的并行加法器</h4><p>并行进位的并行加法器：所有进位信息都是同时产生的，几乎没有延迟。<br><strong>特点：运算速度比“申行进位的并行加法器”更快。</strong></p>\n<p><img src=\"https://s2.loli.net/2024/07/23/rVE6L7YH8K2zCfF.png\" alt=\"并行进位加法器示意图\"></p>\n<h4 id=\"带标志器的加法器\"><a href=\"#带标志器的加法器\" class=\"headerlink\" title=\"带标志器的加法器\"></a>带标志器的加法器</h4><p><img src=\"https://s2.loli.net/2024/07/23/q2k1uFLtfieITan.png\" alt=\"带标志器的加法器示意图\"></p>\n<p>四种标志</p>\n<ol>\n<li>OF（Overflow Flag)溢出标志，用于判断带符号数加减运算是否溢出。OF=1 溢出；OF=O 未溢出</li>\n<li>SF（Sign Flag）符号标志，用于判断带符号数加减运算结果的正负性。SF=1 结果为负；SF=O 结果为正</li>\n<li>ZF（Zero Flag)零标志，用于判断加减运算结果是否为O。ZF=1表示结果为O；ZF= 表示结果不为0</li>\n<li>CF（Carry Flag)进位/借位标志，用于判断无符号数加减运算是否溢出。CF=1 溢出；CF=0 未溢出</li>\n</ol>\n<blockquote>\n<p>引入汇编中的标志寄存器：</p>\n<p><img src=\"https://s2.loli.net/2024/07/23/KoyEjTGda3mlfXb.png\" alt=\"汇编标志寄存器\"></p>\n<p>该图中绿色区域为奇偶校验码</p>\n<p>0,2,4,6,7,8,9,10,11为标志，分别为CF进位标志，PF奇偶标志，AF辅助进位标志，ZF零标志，SF符号标志，TF单步标志，IF中断使能标志，DF方向标志，OF溢出标志</p>\n<p>补充上面的五种分别为</p>\n<ul>\n<li><strong>奇偶标志（Parity Flag）</strong></li>\n</ul>\n<p>由于反应运算结果中(转化为二进制)，<strong>“1”的奇偶性，也就是个数</strong>。”1”的个数为偶数，PF为1。个数为奇数，PF为0.<br>补充：只包含最低位的一个字节(二进制的后八位)</p>\n<ul>\n<li><strong>辅助进位标志AF(Auxiliary Carry Flag)</strong></li>\n</ul>\n<p>在发生下列情况时，AF的值为1，否则其值为0<br>(1)、在字操作时，发生低字节向高字节进位或错位时；<br>(2)、在字节操作时，发生低4位向高4位进位或错位时；</p>\n<ul>\n<li><strong>中断使能标志位</strong></li>\n</ul>\n<p><strong>是否处于中断中，处于则为一</strong></p>\n<ul>\n<li><strong>方向标志位</strong></li>\n</ul>\n<p>方向标志位（DF）是Intel 8086/8088 CPU程序状态标志寄存器的一个标志位，用来控制数据串操作指令的步进方向。当设置DF=1时，将以递减顺序对数据串中的数据进行处理；当设置DF=0时，递增</p>\n<ul>\n<li><strong>单步标志位Trap flag</strong></li>\n</ul>\n<p>是否处于debug状态，该标志位为1则单步调试</p>\n</blockquote>\n<h4 id=\"标志位的生成\"><a href=\"#标志位的生成\" class=\"headerlink\" title=\"标志位的生成\"></a>标志位的生成</h4><p>立即推！首先注意到是否溢出是很独特的。</p>\n<p>通过基础的学习可以知道，判断是否溢出有很多方式。。</p>\n<p>首先看一下如何出现溢出？</p>\n<p>首先看无符号数？</p>\n<p>对无符号数而言，均表示绝对值，溢出后相当于<script type=\"math/tex\">mod2^n</script>，这在很多情况下是很自然地，因此通常我们讲<strong>无符号数不存在溢出</strong></p>\n<p>对有符号数而言</p>\n<ol>\n<li>两个正数相加</li>\n<li>两个负数相加</li>\n</ol>\n<p>显然异号数相加是不会影响到加法器的正常运行的。</p>\n<p>第一种情况，我们发现实际上他并没有真正的溢出，而是<strong>变成了一个负数！</strong>，第二种情况，实际上真的有1进位出去了，而且此时的情况还是比较复杂的。</p>\n<p>写一下最高位下的真值表</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>A</th>\n<th>B</th>\n<th>C_in</th>\n<th>C_out</th>\n<th>S</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>可以发现，当进位与当前位进位，即运算后的高两位进位不同时即可判断发生溢出</p>\n<p>谈及溢出，这里就温习一下所有的判断溢出方法</p>\n<ol>\n<li>朴素符号法</li>\n</ol>\n<p>Xf、Yf分别两个数的符号位,Zf为运算结果符号位。<br>当Xf =Yf =0（两数同为正）,而Zf=1(结果为负)时,负溢出；<br>当出现Xf =Yf =1（两数同为负）,而Zf=0（结果为正），正溢出.</p>\n<ol>\n<li>上文提到的加法器</li>\n</ol>\n<script type=\"math/tex; mode=display\">OF=Cn \\oplus Cn-1</script><ol>\n<li>双符号法</li>\n</ol>\n<p>用变形补码进行双符号位运算（正数符为00,负数符号以11）<br>若运算结果的符号位为”01”,则正溢；<br>若结果双符号为10,则负溢出；<br>若结果的双符号位为00或11，无溢出</p>\n<p>解决了加法器的问题，剩下的就很简单了</p>\n<script type=\"math/tex; mode=display\">OF = C \\oplus Cn-1 $$ -即最高位的进位④次高位的进位。反映带符号数加减运算是否溢出。\n$$SF=S$$,一一也就是取运算结果的最高位（符号位）。反映带符号数加减运算的正负性。\n$$ZF= \\overline{Sn+…+S2+S1}$$ 一一仅当运算结果所有 bit 全0时，ZF才为1，此时表示运算结果为O。\n$$CF=Cout \\oplus Cin=Cn \\oplus C_0$$一一反映无符号数加减运算是否溢出。\n\n### 并行加法运算器\n\n回顾串行进位\n\n![逻辑电路图](https://s2.loli.net/2024/07/23/nMocZ4N68s2rYKP.png)\n\n![并行进位示意图](https://s2.loli.net/2024/07/23/jaKcwoJBqD7xFLi.png)\n\n### 多路选择器（MUX）\n\n![选择器示意图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240723235506535.png)\n\n### 三态门\n\n![三态门电路示意](https://s2.loli.net/2024/07/23/H1MaprNRSyGxihK.png)\n\n### 算术逻辑单元ALU\n\n1. ALU是运算器的核心\n2. 加法器是运算器的核心\n\n![功能图](https://s2.loli.net/2024/07/23/eFRBuMEJaojYGwy.png)\n\n3. **若ALU有k种功能，那么控制信号位数$$m \\ge \\left\\lfloor log_2k\\right\\rfloor$$**\n\n4. ALU的运算数、运算结果位数与计算机的机器字长相同\n\n![ALU](https://s2.loli.net/2024/07/24/FuklLJyCnUwqEh5.png)\n\n## 运算\n\n### 定点数的移位运算\n\n计算机的移位操作分为**算数移位**和**逻辑移位**\n\n![算术移位规则图](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210022980.png)\n\n![算术移位与逻辑一味的区别](https://s2.loli.net/2024/07/24/6ua5YAKiTjEmtL1.png)\n\n>eg: 对 10110010\n>\n>逻辑左移 10100110    逻辑右移 01011001\n>\n>算数左移 00100110    算数右移 11011001（只有**补码在算术移位下才添1**）\n\n### 循环移位\n\n​    循环移位分为**带进位标志位CF的循环移位（大循环）**和**不带进位标志位的循环**\n**移位（小循环)**，过程如图2.9所示。循环移位的主要特点是，移出的数位又被\n移入数据中，而**是否带进位则要看是否将进位标志加入循环位移**。例如，带进\n位位的循环左移，如图2.9(d)所示，就是数据位连同进位标志位一起左移，数\n据的最高位移入进位标志位CF，而进位位则依次移入数据的最低位。\n\n![循环移位](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210332086.png)\n\n### 定点数的加减运算\n\n补码加减运算公式\n\n1. 加法\n\n整数 [Al补+[Bl补=[A+Bl补 (mod 2n+1)\n小数 [Al补+[Bl补=[A+B补 (mod 2)\n\n2. 减法\n\nA-B = A+(-B)\n整数 [A- B补=[A+(-B)]补=[Al补+[-Bl补 (mod 21)\n小数[A- B补=[A+(-B)]补=[Al补+[-Bl补 (mod 2)\n**连同符号位一起相加**，符号位产生的进位自然丢掉\n\n> 例如：\n>\n> ![定点小数的加减运算](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724210643710.png)\n\n3. 溢出判断\n\n这里再温习一遍溢出，判断溢出很重要，是这一章的重点\n\n​    3.1.一位符号位判溢出\n\n最高有效位的进位与符号位进位的异或判断溢出\n\n​    3.2. 两位符号位盘一处\n\n设置双符号位，当双符号位中的数字不相同时说明溢出，值得注意的是：最高符号位代表真正的符号\n\n### 原码的加减法\n加法规则:先判符号位，若相同，则绝对值相加，结果符号位不变;若不同，则做减法，绝对值大数减去绝对值小的数，结果符号位与绝对值大的数相同。\n\n减法规则:两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。\n\n原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位“异或”形成，而乖积的数值部分则是两个数的绝对值相乘之积。\n\n### 一位乘法\n\n- 原码一位乘法\n\n原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位“异或”形成，而乖积的数值部分则是两个数的绝对值相乘之积。\n\n> eg:\n>\n> ![原码一位乘法](https://s2.loli.net/2024/07/24/PDMs83BTeInfUcK.jpg)\n\n- 补码一位乘法\n\nBooth乘法是考的较多的乘法，该方法通过对\n\n1. 符号位参与运算\n2. 累加0，x，-x，避免了符号判断\n\n对于每次加0，x还是加-x，有一个简明概要的方法\n\n1. 每次加法判断当前舍去的位和地位的值\n\n如下表所示：\n\n| y_n  | y_n+1 |      |\n| ---- | ----- | ---- |\n| 0    | 0     | 0    |\n| 0    | 1     | x    |\n| 1    | 0     | -x   |\n| 1    | 1     | 0    |\n\n> eg :\n>\n> ![9e5cd1bad2f699a15d1e404b2d8b3186](https://s2.loli.net/2024/07/24/YGI7qERHlydshmt.jpg)\n\n#### 番外：二位乘法\n\n| yn-1yn yn+1 | 操作                      |\n| ----------- | ------------------------- |\n| 000         | 部分积直接右移两位        |\n| 000         | 部分积加[x]补，右移两位   |\n| 010         | 部分积加[x]补，右移两位   |\n| 011         | 部分积加2[x]补，右移两位  |\n| 100         | 部分积加2[-x]补，右移两位 |\n| 101         | 部分积加[-x]补，右移两位  |\n| 110         | 部分积加[-x]补，右移两位  |\n| 111         | 部分积直接右移两位        |\n\n除了每次移动两位并且多了几种加数外与一位相差不大，也很好记：后三位3就加二倍，4就减二倍，其他类似一位乘。\n\n### 除法——加减交替法\n\n几乎不考，考了就正常手算即可，丢掉符号位算绝对值就行\n\n### 浮点数的表示和运算\n\n重点在于：\n\n1. 表现形式是怎么样的\n2. 表示范围是多少\n3. 浮点数是如何规范化的\n4. 规范化中的精度缺失与舍入方法</script><p>N=S\\times r^j(S为尾数，j是阶码，r是基数/基值)\\<br>通常在计算机中r取2、4、6、8、16等\\<br>S为小数，可正可负<br>j为整数、可正可负</p>\n<p>$$</p>\n<ol>\n<li><strong><em>有的地方也将阶码表示为E，未码表示为M</em></strong></li>\n</ol>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724215312602.png\" alt=\"浮点数表示形式\"></p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724215247688.png\" alt=\"浮点数表示范围\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/24/ICp2HrMYElTbtK5.png\" alt=\"浮点数的规格化\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/24/WIoqe4PzGsjOY5a.png\" alt=\"image-20240724220243190\"></p>\n<h4 id=\"详细探讨浮点数的规范化与舍入\"><a href=\"#详细探讨浮点数的规范化与舍入\" class=\"headerlink\" title=\"详细探讨浮点数的规范化与舍入\"></a>详细探讨浮点数的规范化与舍入</h4><ol>\n<li>规格化的：E所有位既不全为0也不全为1。</li>\n</ol>\n<p>在IEEE的标准中实际上有四种种舍入方式</p>\n<p>　舍入一共有四种方式，分别是<strong>向偶数舍入、向零舍入、向上舍入以及向下舍入。</strong></p>\n<ol>\n<li>就近舍入：即十进制下的“四舍五入”，例如有效数字超出规定数位的多余数字是1001，它大于超出规定最低位的一半（即0.5），故最低位进1。如果多余数字是0111，它小于最低位的一半，则舍掉多余数字（截断尾数、截尾）即可。对于多余数字是1000、正好是最低位一半的特殊情况，最低位为0则舍掉多余位，最低位为1则进位1、使得最低位仍为0（偶数）。</li>\n</ol>\n<p>注意这里说明的数位都是指二进制数。</p>\n<p>举例：要求保留小数点后3位。</p>\n<p>对于1.0011001，舍入处理后为1.010（去掉多余的4位，加0.001）<br>对于1.0010111，舍入处理后为1.001（去掉多余的4位）<br>对于1.0011000，舍入处理后为1.010（去掉多余的4位，加0.001，使得最低位为0）</p>\n<p>对于1.1001001，舍入处理后为1.101（去掉多余的4位，加0.001）<br>对于1.1000111，舍入处理后为1.100（去掉多余的4位）<br>对于1.1001000，舍入处理后为1.100（去掉多余的4位，不加，因为最低位已经为0）</p>\n<p>对于1.01011，舍入处理后为1.011（去掉多余的2位，加0.001）<br>对于1.01001，舍入处理后为1.010（去掉多余的2位）<br>对于1.01010，舍入处理后为1.010（去掉多余的2位，不加）</p>\n<p>对于1.01111，舍入处理后为1.100（去掉多余的2位，加0.001）<br>对于1.01101，舍入处理后为1.011（去掉多余的2位）<br>对于1.01110，舍入处理后为1.100（去掉多余的2位，加0.001）</p>\n<p>2.朝0舍入：即朝数轴零点方向舍入，即直接截尾。<br>3.朝正无穷舍入：对正数而言，只要多余位不全为0则向最低有效位进1；负数则直接截尾。<br>4.朝负无穷舍入：对负数而言，向最低有效位进1；正数若多余位不全部为0则简单截尾。</p>\n<p>但这些舍入方式太过复杂,在不同数字下有不同表现,涉及概率论,具体的两种方式如下</p>\n<ol>\n<li>“0舍1入法”：右移时被丢掉的最高位是0则直接舍去（包括0之后的）；如果是1则舍去并在最低有效位上加1；</li>\n<li>“恒置1”法：只要数位被丢掉，一律在最低有效位上加1.</li>\n</ol>\n<h2 id=\"数据的存储方式\"><a href=\"#数据的存储方式\" class=\"headerlink\" title=\"数据的存储方式\"></a>数据的存储方式</h2><h3 id=\"大端存储和小端存储\"><a href=\"#大端存储和小端存储\" class=\"headerlink\" title=\"大端存储和小端存储\"></a>大端存储和小端存储</h3><p>数据的“大端方式”和“小端方式”存储现代计算机基本上都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字节数不同，int 和 float型数据占4字节，double型数据占8字节等，而程序中对每个数据只给定一个地址。</p>\n<p>假设变量i的地址为08 00H，字节01H、23H、 45H、67H应该各有一个内存地址，那么地址08 00H对应4字节中哪字节的地址呢?这就是字节排列顺序问题。</p>\n<p><img src=\"https://s2.loli.net/2024/07/24/2tUcrYiEI1ZNjDQ.png\" alt=\"大端小端存储\"></p>\n<h3 id=\"边界对齐存储\"><a href=\"#边界对齐存储\" class=\"headerlink\" title=\"边界对齐存储\"></a>边界对齐存储</h3><p>假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。</p>\n<p>假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。</p>\n<p><img src=\"https://s2.loli.net/2024/07/24/fqguQIoOzU4Fp7x.png\" alt=\"边界对齐\"></p>\n"},{"title":"计网篇-奈氏准则篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"## 奈氏准则\n\n**数据传输速率 = 波特率（码元传输速率）X 每个码元所携带的信息量**\n\n理想低通信道的最高码元传输速率=2W Baud=2W 码元/秒\n\n理想带通信道的最高码元传输速率=W Baud=W 码元/秒\n\n**W**：信道带宽（单位为Hz）\n\n**Baud**：波特，即码元/秒\n\n在假定的理想条件下，为了避免码间串扰， 码元传输速率是有上限的。\n\n- 码元传输速率又称为波特率、调制速率、波形速率或符号速率。它与比特率有一定关系：\n  - 当1个码元只携带1比特的信息量时，则波特率（码元/秒）与比特率（比特/秒）在数值上是相等的\n  - 当1个码元携带n比特的信息量时，则波特率转换成比特率时，数值要乘以n\n- 要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量。这需要采用多元制。实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个上限数值。\n\n## 香农公式\n\n### 定义\n\n带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。\n$$\nc = W \\times log_2\\left( 1 + \\frac{S}{N} \\right)\n$$\n**C**：信道的极限信息传输速率（单位：b/s)\n\nW：信道带宽（单位：Hz)\n\n**S**：信道内所传信号的平均功率\n\n**N**：信道内的高斯噪声功率\n\n**S/N**：信噪比，使用分贝（dB）作为度量单位 信噪$(dB) = 10 \\times log_{10}\\left(\\frac{S}{N}\\right) (dB)$\n\n实际上，香农公式也是现实情况的近似，对脉冲干扰，衰减和失真并未考虑。\n\n### 一些基本性质\n\n1. 信道带宽或信道中的信噪比越大，信息的极限传输速率就越高\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/奈氏定理与香农法则.md","raw":"---\ntitle: 计网篇-奈氏准则篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n## 奈氏准则\n\n**数据传输速率 = 波特率（码元传输速率）X 每个码元所携带的信息量**\n\n理想低通信道的最高码元传输速率=2W Baud=2W 码元/秒\n\n理想带通信道的最高码元传输速率=W Baud=W 码元/秒\n\n**W**：信道带宽（单位为Hz）\n\n**Baud**：波特，即码元/秒\n\n在假定的理想条件下，为了避免码间串扰， 码元传输速率是有上限的。\n\n- 码元传输速率又称为波特率、调制速率、波形速率或符号速率。它与比特率有一定关系：\n  - 当1个码元只携带1比特的信息量时，则波特率（码元/秒）与比特率（比特/秒）在数值上是相等的\n  - 当1个码元携带n比特的信息量时，则波特率转换成比特率时，数值要乘以n\n- 要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量。这需要采用多元制。实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个上限数值。\n\n## 香农公式\n\n### 定义\n\n带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。\n$$\nc = W \\times log_2\\left( 1 + \\frac{S}{N} \\right)\n$$\n**C**：信道的极限信息传输速率（单位：b/s)\n\nW：信道带宽（单位：Hz)\n\n**S**：信道内所传信号的平均功率\n\n**N**：信道内的高斯噪声功率\n\n**S/N**：信噪比，使用分贝（dB）作为度量单位 信噪$(dB) = 10 \\times log_{10}\\left(\\frac{S}{N}\\right) (dB)$\n\n实际上，香农公式也是现实情况的近似，对脉冲干扰，衰减和失真并未考虑。\n\n### 一些基本性质\n\n1. 信道带宽或信道中的信噪比越大，信息的极限传输速率就越高\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/奈氏定理与香农法则","published":1,"updated":"2024-08-17T13:23:54.192Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqr003hm8wv42ub7ko5","content":"<h2 id=\"奈氏准则\"><a href=\"#奈氏准则\" class=\"headerlink\" title=\"奈氏准则\"></a>奈氏准则</h2><p><strong>数据传输速率 = 波特率（码元传输速率）X 每个码元所携带的信息量</strong></p>\n<p>理想低通信道的最高码元传输速率=2W Baud=2W 码元/秒</p>\n<p>理想带通信道的最高码元传输速率=W Baud=W 码元/秒</p>\n<p><strong>W</strong>：信道带宽（单位为Hz）</p>\n<p><strong>Baud</strong>：波特，即码元/秒</p>\n<p>在假定的理想条件下，为了避免码间串扰， 码元传输速率是有上限的。</p>\n<ul>\n<li>码元传输速率又称为波特率、调制速率、波形速率或符号速率。它与比特率有一定关系：<ul>\n<li>当1个码元只携带1比特的信息量时，则波特率（码元/秒）与比特率（比特/秒）在数值上是相等的</li>\n<li>当1个码元携带n比特的信息量时，则波特率转换成比特率时，数值要乘以n</li>\n</ul>\n</li>\n<li>要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量。这需要采用多元制。实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个上限数值。</li>\n</ul>\n<h2 id=\"香农公式\"><a href=\"#香农公式\" class=\"headerlink\" title=\"香农公式\"></a>香农公式</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</p>\n<script type=\"math/tex; mode=display\">\nc = W \\times log_2\\left( 1 + \\frac{S}{N} \\right)</script><p><strong>C</strong>：信道的极限信息传输速率（单位：b/s)</p>\n<p>W：信道带宽（单位：Hz)</p>\n<p><strong>S</strong>：信道内所传信号的平均功率</p>\n<p><strong>N</strong>：信道内的高斯噪声功率</p>\n<p><strong>S/N</strong>：信噪比，使用分贝（dB）作为度量单位 信噪$(dB) = 10 \\times log_{10}\\left(\\frac{S}{N}\\right) (dB)$</p>\n<p>实际上，香农公式也是现实情况的近似，对脉冲干扰，衰减和失真并未考虑。</p>\n<h3 id=\"一些基本性质\"><a href=\"#一些基本性质\" class=\"headerlink\" title=\"一些基本性质\"></a>一些基本性质</h3><ol>\n<li>信道带宽或信道中的信噪比越大，信息的极限传输速率就越高</li>\n</ol>\n<!-- flag of hidden posts -->","length":480,"excerpt":"","more":"<h2 id=\"奈氏准则\"><a href=\"#奈氏准则\" class=\"headerlink\" title=\"奈氏准则\"></a>奈氏准则</h2><p><strong>数据传输速率 = 波特率（码元传输速率）X 每个码元所携带的信息量</strong></p>\n<p>理想低通信道的最高码元传输速率=2W Baud=2W 码元/秒</p>\n<p>理想带通信道的最高码元传输速率=W Baud=W 码元/秒</p>\n<p><strong>W</strong>：信道带宽（单位为Hz）</p>\n<p><strong>Baud</strong>：波特，即码元/秒</p>\n<p>在假定的理想条件下，为了避免码间串扰， 码元传输速率是有上限的。</p>\n<ul>\n<li>码元传输速率又称为波特率、调制速率、波形速率或符号速率。它与比特率有一定关系：<ul>\n<li>当1个码元只携带1比特的信息量时，则波特率（码元/秒）与比特率（比特/秒）在数值上是相等的</li>\n<li>当1个码元携带n比特的信息量时，则波特率转换成比特率时，数值要乘以n</li>\n</ul>\n</li>\n<li>要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量。这需要采用多元制。实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个上限数值。</li>\n</ul>\n<h2 id=\"香农公式\"><a href=\"#香农公式\" class=\"headerlink\" title=\"香农公式\"></a>香农公式</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</p>\n<script type=\"math/tex; mode=display\">\nc = W \\times log_2\\left( 1 + \\frac{S}{N} \\right)</script><p><strong>C</strong>：信道的极限信息传输速率（单位：b/s)</p>\n<p>W：信道带宽（单位：Hz)</p>\n<p><strong>S</strong>：信道内所传信号的平均功率</p>\n<p><strong>N</strong>：信道内的高斯噪声功率</p>\n<p><strong>S/N</strong>：信噪比，使用分贝（dB）作为度量单位 信噪$(dB) = 10 \\times log_{10}\\left(\\frac{S}{N}\\right) (dB)$</p>\n<p>实际上，香农公式也是现实情况的近似，对脉冲干扰，衰减和失真并未考虑。</p>\n<h3 id=\"一些基本性质\"><a href=\"#一些基本性质\" class=\"headerlink\" title=\"一些基本性质\"></a>一些基本性质</h3><ol>\n<li>信道带宽或信道中的信噪比越大，信息的极限传输速率就越高</li>\n</ol>\n"},{"title":"计网篇-概要以及杂项篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# 计算机网络绪论\n\n## 总体概览\n\n![从组成部分看计算机网络](https://s2.loli.net/2024/07/08/Md1xyNKFUSgIVH3.png)\n\n![从逻辑功能看计算机网络](https://s2.loli.net/2024/07/08/quae3k9ZV1IgThr.png)\n\n## 功能阐述\n\n![计算机网络功能](https://s2.loli.net/2024/07/08/KN65Wg1ZnYcQECf.png)\n\n总结一下上图的计算机网络具体功能\n\n1. 硬件资源的共享，如： AI服务器的算力共享\n2. 软件资源共享，如： web服务器上的一些内容共享\n3. 数据资源共享，如： windows，andorid和一些开源项目等\n\n## 分类方式\n\n1. 交换方式\n   1. 分组交换\n   2. 电路交换\n   3. 报文交换\n2. 使用者\n   1. 公用网络\n   2. 专用网络\n3. 传输介质\n   1. 有线网\n   2. 无线网\n4. 覆盖范围\n   1. WAN广域网\n   2. MAN城域网\n   3. LAN局域网\n   4. PAN个域网\n5. 拓扑结构\n   1. 总线型\n   2. 星型\n   3. 环型\n   4. 网状型\n      计算机网络的性能指标\n\n## 计算机网络性能指标\n\n### 速率\n\n1. 比特 bit b 即是一个位\n2. 数据量常用的单位 B 1B=8bits\n3. （bit/s / bps） 、kbps、 gbps、 tpbs\n\n简而言之，在计算机网络中，对不同的速率进制一般为10进制，而在计组操作系统中通常为2进制，也就造成了网上常常会售卖比实际内存“小”的硬盘。\n\n值得注意的是，b与B之间也有区别，8倍关系\n\n### 带宽\n\n很好理解，即IPS与EndComsumer的链接\n\n在《计算机网络》中：0\n\n- 0带宽（bandwidth）：表示某信道沂能通过的 “最高数据率”\n\n在《通信原理》（ （通信领域的一门基础学科）中：\n\n- 带宽（bandwidth）：表示某信道允许通过的信号频带范围\n\n这两种定义本质上是一致的。\n\n单位bps，注意MB与Mbps之间的8倍关系\n\n### 吞吐量\n\n吞吐量（Throughput）：指单位时间内通过某个网络（或信道、接口）的实际数据量。\n吞吐量受带宽限制、受复杂的网络负载情况影响。\n\n### 时延\n\n时延(Delay)：指数据(一个报文或分组，甚至比特)从网络（或链路）的一端传送到另一端所\n需的时间。有时也称为延迟或迟延。\n\n$$总时延=发送时延+传播时延+处理时延+排队时延$$\n\n![时延的计算方法](https://s2.loli.net/2024/07/15/ejpyAX8H1GBOMrF.png)\n\n### 时延带宽积\n\n$$时延带宽积 = 传播时延\\times 带宽$$\n\n时延带宽积的含义：一条链路中，已从发送端发出但尚未到达接收端的最大比特数\n\n[tag] 时延带宽积用于设计最短帧长\n\n### 往返时延 \n\n往返时延TT(Round-Trip Time):表示从发送方**发送完数据**，到发送方**收到来自接收方的确认**总共经历的时间。\n\n所谓游戏延迟就是反应的RTT\n\n### 信道利用率\n\n信道利用率：某个信道有百分之多少的时间是有数据通过的。\n$$信道利用率=\\frac{\n有数据通过的时间}\n{有数据通过的时间+没有数据通过的时间}$$\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/概要以及杂项.md","raw":"---\ntitle: 计网篇-概要以及杂项篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# 计算机网络绪论\n\n## 总体概览\n\n![从组成部分看计算机网络](https://s2.loli.net/2024/07/08/Md1xyNKFUSgIVH3.png)\n\n![从逻辑功能看计算机网络](https://s2.loli.net/2024/07/08/quae3k9ZV1IgThr.png)\n\n## 功能阐述\n\n![计算机网络功能](https://s2.loli.net/2024/07/08/KN65Wg1ZnYcQECf.png)\n\n总结一下上图的计算机网络具体功能\n\n1. 硬件资源的共享，如： AI服务器的算力共享\n2. 软件资源共享，如： web服务器上的一些内容共享\n3. 数据资源共享，如： windows，andorid和一些开源项目等\n\n## 分类方式\n\n1. 交换方式\n   1. 分组交换\n   2. 电路交换\n   3. 报文交换\n2. 使用者\n   1. 公用网络\n   2. 专用网络\n3. 传输介质\n   1. 有线网\n   2. 无线网\n4. 覆盖范围\n   1. WAN广域网\n   2. MAN城域网\n   3. LAN局域网\n   4. PAN个域网\n5. 拓扑结构\n   1. 总线型\n   2. 星型\n   3. 环型\n   4. 网状型\n      计算机网络的性能指标\n\n## 计算机网络性能指标\n\n### 速率\n\n1. 比特 bit b 即是一个位\n2. 数据量常用的单位 B 1B=8bits\n3. （bit/s / bps） 、kbps、 gbps、 tpbs\n\n简而言之，在计算机网络中，对不同的速率进制一般为10进制，而在计组操作系统中通常为2进制，也就造成了网上常常会售卖比实际内存“小”的硬盘。\n\n值得注意的是，b与B之间也有区别，8倍关系\n\n### 带宽\n\n很好理解，即IPS与EndComsumer的链接\n\n在《计算机网络》中：0\n\n- 0带宽（bandwidth）：表示某信道沂能通过的 “最高数据率”\n\n在《通信原理》（ （通信领域的一门基础学科）中：\n\n- 带宽（bandwidth）：表示某信道允许通过的信号频带范围\n\n这两种定义本质上是一致的。\n\n单位bps，注意MB与Mbps之间的8倍关系\n\n### 吞吐量\n\n吞吐量（Throughput）：指单位时间内通过某个网络（或信道、接口）的实际数据量。\n吞吐量受带宽限制、受复杂的网络负载情况影响。\n\n### 时延\n\n时延(Delay)：指数据(一个报文或分组，甚至比特)从网络（或链路）的一端传送到另一端所\n需的时间。有时也称为延迟或迟延。\n\n$$总时延=发送时延+传播时延+处理时延+排队时延$$\n\n![时延的计算方法](https://s2.loli.net/2024/07/15/ejpyAX8H1GBOMrF.png)\n\n### 时延带宽积\n\n$$时延带宽积 = 传播时延\\times 带宽$$\n\n时延带宽积的含义：一条链路中，已从发送端发出但尚未到达接收端的最大比特数\n\n[tag] 时延带宽积用于设计最短帧长\n\n### 往返时延 \n\n往返时延TT(Round-Trip Time):表示从发送方**发送完数据**，到发送方**收到来自接收方的确认**总共经历的时间。\n\n所谓游戏延迟就是反应的RTT\n\n### 信道利用率\n\n信道利用率：某个信道有百分之多少的时间是有数据通过的。\n$$信道利用率=\\frac{\n有数据通过的时间}\n{有数据通过的时间+没有数据通过的时间}$$\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/概要以及杂项","published":1,"updated":"2024-08-17T13:24:27.182Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqs003im8wv6yqd3bmn","content":"<h1 id=\"计算机网络绪论\"><a href=\"#计算机网络绪论\" class=\"headerlink\" title=\"计算机网络绪论\"></a>计算机网络绪论</h1><h2 id=\"总体概览\"><a href=\"#总体概览\" class=\"headerlink\" title=\"总体概览\"></a>总体概览</h2><p><img src=\"https://s2.loli.net/2024/07/08/Md1xyNKFUSgIVH3.png\" alt=\"从组成部分看计算机网络\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/quae3k9ZV1IgThr.png\" alt=\"从逻辑功能看计算机网络\"></p>\n<h2 id=\"功能阐述\"><a href=\"#功能阐述\" class=\"headerlink\" title=\"功能阐述\"></a>功能阐述</h2><p><img src=\"https://s2.loli.net/2024/07/08/KN65Wg1ZnYcQECf.png\" alt=\"计算机网络功能\"></p>\n<p>总结一下上图的计算机网络具体功能</p>\n<ol>\n<li>硬件资源的共享，如： AI服务器的算力共享</li>\n<li>软件资源共享，如： web服务器上的一些内容共享</li>\n<li>数据资源共享，如： windows，andorid和一些开源项目等</li>\n</ol>\n<h2 id=\"分类方式\"><a href=\"#分类方式\" class=\"headerlink\" title=\"分类方式\"></a>分类方式</h2><ol>\n<li>交换方式<ol>\n<li>分组交换</li>\n<li>电路交换</li>\n<li>报文交换</li>\n</ol>\n</li>\n<li>使用者<ol>\n<li>公用网络</li>\n<li>专用网络</li>\n</ol>\n</li>\n<li>传输介质<ol>\n<li>有线网</li>\n<li>无线网</li>\n</ol>\n</li>\n<li>覆盖范围<ol>\n<li>WAN广域网</li>\n<li>MAN城域网</li>\n<li>LAN局域网</li>\n<li>PAN个域网</li>\n</ol>\n</li>\n<li>拓扑结构<ol>\n<li>总线型</li>\n<li>星型</li>\n<li>环型</li>\n<li>网状型<br>计算机网络的性能指标</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"计算机网络性能指标\"><a href=\"#计算机网络性能指标\" class=\"headerlink\" title=\"计算机网络性能指标\"></a>计算机网络性能指标</h2><h3 id=\"速率\"><a href=\"#速率\" class=\"headerlink\" title=\"速率\"></a>速率</h3><ol>\n<li>比特 bit b 即是一个位</li>\n<li>数据量常用的单位 B 1B=8bits</li>\n<li>（bit/s / bps） 、kbps、 gbps、 tpbs</li>\n</ol>\n<p>简而言之，在计算机网络中，对不同的速率进制一般为10进制，而在计组操作系统中通常为2进制，也就造成了网上常常会售卖比实际内存“小”的硬盘。</p>\n<p>值得注意的是，b与B之间也有区别，8倍关系</p>\n<h3 id=\"带宽\"><a href=\"#带宽\" class=\"headerlink\" title=\"带宽\"></a>带宽</h3><p>很好理解，即IPS与EndComsumer的链接</p>\n<p>在《计算机网络》中：0</p>\n<ul>\n<li>0带宽（bandwidth）：表示某信道沂能通过的 “最高数据率”</li>\n</ul>\n<p>在《通信原理》（ （通信领域的一门基础学科）中：</p>\n<ul>\n<li>带宽（bandwidth）：表示某信道允许通过的信号频带范围</li>\n</ul>\n<p>这两种定义本质上是一致的。</p>\n<p>单位bps，注意MB与Mbps之间的8倍关系</p>\n<h3 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h3><p>吞吐量（Throughput）：指单位时间内通过某个网络（或信道、接口）的实际数据量。<br>吞吐量受带宽限制、受复杂的网络负载情况影响。</p>\n<h3 id=\"时延\"><a href=\"#时延\" class=\"headerlink\" title=\"时延\"></a>时延</h3><p>时延(Delay)：指数据(一个报文或分组，甚至比特)从网络（或链路）的一端传送到另一端所<br>需的时间。有时也称为延迟或迟延。</p>\n<script type=\"math/tex; mode=display\">总时延=发送时延+传播时延+处理时延+排队时延</script><p><img src=\"https://s2.loli.net/2024/07/15/ejpyAX8H1GBOMrF.png\" alt=\"时延的计算方法\"></p>\n<h3 id=\"时延带宽积\"><a href=\"#时延带宽积\" class=\"headerlink\" title=\"时延带宽积\"></a>时延带宽积</h3><script type=\"math/tex; mode=display\">时延带宽积 = 传播时延\\times 带宽</script><p>时延带宽积的含义：一条链路中，已从发送端发出但尚未到达接收端的最大比特数</p>\n<p>[tag] 时延带宽积用于设计最短帧长</p>\n<h3 id=\"往返时延\"><a href=\"#往返时延\" class=\"headerlink\" title=\"往返时延\"></a>往返时延</h3><p>往返时延TT(Round-Trip Time):表示从发送方<strong>发送完数据</strong>，到发送方<strong>收到来自接收方的确认</strong>总共经历的时间。</p>\n<p>所谓游戏延迟就是反应的RTT</p>\n<h3 id=\"信道利用率\"><a href=\"#信道利用率\" class=\"headerlink\" title=\"信道利用率\"></a>信道利用率</h3><p>信道利用率：某个信道有百分之多少的时间是有数据通过的。</p>\n<script type=\"math/tex; mode=display\">信道利用率=\\frac{\n有数据通过的时间}\n{有数据通过的时间+没有数据通过的时间}</script><!-- flag of hidden posts -->","length":751,"excerpt":"","more":"<h1 id=\"计算机网络绪论\"><a href=\"#计算机网络绪论\" class=\"headerlink\" title=\"计算机网络绪论\"></a>计算机网络绪论</h1><h2 id=\"总体概览\"><a href=\"#总体概览\" class=\"headerlink\" title=\"总体概览\"></a>总体概览</h2><p><img src=\"https://s2.loli.net/2024/07/08/Md1xyNKFUSgIVH3.png\" alt=\"从组成部分看计算机网络\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/quae3k9ZV1IgThr.png\" alt=\"从逻辑功能看计算机网络\"></p>\n<h2 id=\"功能阐述\"><a href=\"#功能阐述\" class=\"headerlink\" title=\"功能阐述\"></a>功能阐述</h2><p><img src=\"https://s2.loli.net/2024/07/08/KN65Wg1ZnYcQECf.png\" alt=\"计算机网络功能\"></p>\n<p>总结一下上图的计算机网络具体功能</p>\n<ol>\n<li>硬件资源的共享，如： AI服务器的算力共享</li>\n<li>软件资源共享，如： web服务器上的一些内容共享</li>\n<li>数据资源共享，如： windows，andorid和一些开源项目等</li>\n</ol>\n<h2 id=\"分类方式\"><a href=\"#分类方式\" class=\"headerlink\" title=\"分类方式\"></a>分类方式</h2><ol>\n<li>交换方式<ol>\n<li>分组交换</li>\n<li>电路交换</li>\n<li>报文交换</li>\n</ol>\n</li>\n<li>使用者<ol>\n<li>公用网络</li>\n<li>专用网络</li>\n</ol>\n</li>\n<li>传输介质<ol>\n<li>有线网</li>\n<li>无线网</li>\n</ol>\n</li>\n<li>覆盖范围<ol>\n<li>WAN广域网</li>\n<li>MAN城域网</li>\n<li>LAN局域网</li>\n<li>PAN个域网</li>\n</ol>\n</li>\n<li>拓扑结构<ol>\n<li>总线型</li>\n<li>星型</li>\n<li>环型</li>\n<li>网状型<br>计算机网络的性能指标</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"计算机网络性能指标\"><a href=\"#计算机网络性能指标\" class=\"headerlink\" title=\"计算机网络性能指标\"></a>计算机网络性能指标</h2><h3 id=\"速率\"><a href=\"#速率\" class=\"headerlink\" title=\"速率\"></a>速率</h3><ol>\n<li>比特 bit b 即是一个位</li>\n<li>数据量常用的单位 B 1B=8bits</li>\n<li>（bit/s / bps） 、kbps、 gbps、 tpbs</li>\n</ol>\n<p>简而言之，在计算机网络中，对不同的速率进制一般为10进制，而在计组操作系统中通常为2进制，也就造成了网上常常会售卖比实际内存“小”的硬盘。</p>\n<p>值得注意的是，b与B之间也有区别，8倍关系</p>\n<h3 id=\"带宽\"><a href=\"#带宽\" class=\"headerlink\" title=\"带宽\"></a>带宽</h3><p>很好理解，即IPS与EndComsumer的链接</p>\n<p>在《计算机网络》中：0</p>\n<ul>\n<li>0带宽（bandwidth）：表示某信道沂能通过的 “最高数据率”</li>\n</ul>\n<p>在《通信原理》（ （通信领域的一门基础学科）中：</p>\n<ul>\n<li>带宽（bandwidth）：表示某信道允许通过的信号频带范围</li>\n</ul>\n<p>这两种定义本质上是一致的。</p>\n<p>单位bps，注意MB与Mbps之间的8倍关系</p>\n<h3 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h3><p>吞吐量（Throughput）：指单位时间内通过某个网络（或信道、接口）的实际数据量。<br>吞吐量受带宽限制、受复杂的网络负载情况影响。</p>\n<h3 id=\"时延\"><a href=\"#时延\" class=\"headerlink\" title=\"时延\"></a>时延</h3><p>时延(Delay)：指数据(一个报文或分组，甚至比特)从网络（或链路）的一端传送到另一端所<br>需的时间。有时也称为延迟或迟延。</p>\n<script type=\"math/tex; mode=display\">总时延=发送时延+传播时延+处理时延+排队时延</script><p><img src=\"https://s2.loli.net/2024/07/15/ejpyAX8H1GBOMrF.png\" alt=\"时延的计算方法\"></p>\n<h3 id=\"时延带宽积\"><a href=\"#时延带宽积\" class=\"headerlink\" title=\"时延带宽积\"></a>时延带宽积</h3><script type=\"math/tex; mode=display\">时延带宽积 = 传播时延\\times 带宽</script><p>时延带宽积的含义：一条链路中，已从发送端发出但尚未到达接收端的最大比特数</p>\n<p>[tag] 时延带宽积用于设计最短帧长</p>\n<h3 id=\"往返时延\"><a href=\"#往返时延\" class=\"headerlink\" title=\"往返时延\"></a>往返时延</h3><p>往返时延TT(Round-Trip Time):表示从发送方<strong>发送完数据</strong>，到发送方<strong>收到来自接收方的确认</strong>总共经历的时间。</p>\n<p>所谓游戏延迟就是反应的RTT</p>\n<h3 id=\"信道利用率\"><a href=\"#信道利用率\" class=\"headerlink\" title=\"信道利用率\"></a>信道利用率</h3><p>信道利用率：某个信道有百分之多少的时间是有数据通过的。</p>\n<script type=\"math/tex; mode=display\">信道利用率=\\frac{\n有数据通过的时间}\n{有数据通过的时间+没有数据通过的时间}</script>"},{"title":"计网篇-物理层篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# 物理层\n\n## 物理层的基本概念\n\n- 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。\n- 物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议\n  和服务，而不必考虑网络具体的传输媒体是什么。\n\n## 物理层下的传输媒体\n\n### 物联网接口特性\n\n1. 机械特性：指明结构的标准\n2. 功能特性：指定电压意义\n3. 过程特性：指明可能功能顺序\n4. 电气特性：指明电压范围\n\n这四种特性记得即可，基本都是送分题\n\n### 传输媒体\n\n导引型传输媒体\n\n1. 同轴线缆\n\n   1. 较贵，适用范围较窄\n\n2. 双绞线\n\n   1. 使用最为广泛的线缆\n\n3. 光纤\n\n   1. 通信容量大\n   2. 传输损耗小\n   3. 抗雷电和电磁干扰好\n\n   ![光纤内部结构](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727163726712.png)\n\n   光纤传输的原理即：全反射\n\n   ![两种不同的光缆](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727163843713.png)\n\n4. 电力线\n\n   1. 落后且功能简单的网络布局方式\n\n非导引型的传输媒体\n\n1. 无线电波\n\n2. 微波\n\n   ![无线电波与微波对频率的划分](https://s2.loli.net/2024/07/27/l9HkLIyxKEr3jmp.png)\n\n   微波在空间中是直线传播的，通常通过高信号站和电离层反射\n\n3. 红外通信\n\n   1. 点对点无线传输\n   2. 直线传输，中间不能有障碍物，传输距离短\n   3. 传输速率低（4Mb/s~16Mb/s)\n\n4. 可见光通信技术\n\n   1. LIFI：可见光WIFI技术\n\n## 传输方式\n\n1. 按传输方式分类\n\n   1. 串行传输\n\n   2. 并行传输\n\n   3. 同步传输\n\n      在信号传输过程中需要对比传输的顺序判断，同步传输方式需要对收发方式进行时钟同步\n\n      - 内同步\n\n        发送端将时钟同步编码到发送数据中一起传输，如曼切斯特编码\n\n      - 外同步\n\n        在收发双方添加一条单独的时钟信号线\n\n   4. 异步传输\n\n      - 字节之间异步（字节之间的时间间隔不固定）\n      - 字节中的每个比特仍然要同步（各个bit的持续时间是相同的）\n\n   ![同步异步](https://s2.loli.net/2024/07/27/UHGm14ehKABkCEV.png)\n\n2. 传播的功能\n\n   1. 单工\n   2. 双工\n   3. 半双工\n\n   ![通信方式](https://s2.loli.net/2024/07/27/rpXlAiILbWCN4Fn.png)\n\n \n\n## 编码与调制\n\n### 码元\n在使用时间域的波形表示数字信号时**代表不同离散数值的基本波形。**\n\n![image-20240727165919011](https://s2.loli.net/2024/07/27/ZPzp9E1sTxYtgry.png)\n\n### 常用编码\n\n#### 归零与非归零编码RZ，NRZ\n\n1. 不归零编码\n\n![不归零编码](https://s2.loli.net/2024/07/27/s2NOedUrPBpuoaD.png)\n\n不归零编码存在同步问题\n\n![归零编码](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727170129033.png)\n\n归零编码是自同步编码，但存在信道浪费问题\n\n#### 曼彻斯特与差分曼彻斯特编码\n\n![曼彻斯特与差分曼彻斯特编码](https://s2.loli.net/2024/07/27/QtSjc7bNvd2FEpg.png)\n\n曼彻斯特编码**正跳变表示0，负跳变表示1**，差分曼彻斯特编码则是对码元开始处是否变化表示0，1，差分，曼彻斯特编码的变化比曼彻斯特少，传输效率更高，如果码元**开始时发生变化这是0，不变则是1，对第一位的编码，若是负跳变则是1，正跳变则是0.**\n\n有时也可以交换0，1\n\n#### 一些特殊的编码\n\n- **NRZI，反向不归零编码**\n\n反向不归零编码NRZI，在码元时间内不会出现零电平。若后一个码元时间内所持续的电平与前一个码元时间内所持续的电平不同（也称为电平反转）则表示0，若电平保持不变则表示1。\n\n### 基本调制方法\n\n#### AM,FM,PM\n\n![AM、FM、PM](https://s2.loli.net/2024/07/27/YT1gdh9RxnoylSU.png)\n\n因为**频率和相位**是相关的，即**频率是相位随时间的变化率**。所以**一次只能调制频率和相位两个中的一个**。\n\n#### QAM\n\n通常情况下，**相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。**\n\n![QAM-16](https://s2.loli.net/2024/07/27/IeMxbAGtuSnDoLQ.png)\n\n这里的码元表示bit采用格雷码以减少数据传输错误时的误差。\n\n> **格雷码**\n>\n> 格雷码的基本性质是任意两个**相邻的代码只有一位二进制数**不同，则称这种编码为格雷码（Gray Code），另外由于**最大数与最小数之间也仅一位数不同**，即“首尾相连”，因此又称循环码或反射码。\n>\n> 格雷码的编码机制是：\n>\n> 1. 第一步，改变最右边的位元值；\n> 2. 第二步，改变右起第一个为1的位元的左边位元；\n> 3. 第三步，第四步重复第一步和第二步，直到所有的格雷码产生完毕（换句话说，已经走了(2^n) - 1 步）。\n>\n> ```\n> 0000、0001、0011、0010、0110、0111、0101、0100、\n> 1100、1101、1111、1110、1010、1011、1001、1000\n> ```\n\n## 信道的极限容量\n\n见奈氏准则与香农定理章节[奈氏定理与香农法则.md](./奈氏定理与香农法则.md)\n\n### 信道的极限容量\n\n- 在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必\n  须采用多元制（更好的调制方法）和努力提高信道中的信噪比。\n- 自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽\n  可能地接近香农公式给出的传输速率极限\n\n见[错题本](..\\错题汇总草案-计网篇.md)中奈氏香农例题\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/物理层.md","raw":"---\ntitle: 计网篇-物理层篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# 物理层\n\n## 物理层的基本概念\n\n- 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。\n- 物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议\n  和服务，而不必考虑网络具体的传输媒体是什么。\n\n## 物理层下的传输媒体\n\n### 物联网接口特性\n\n1. 机械特性：指明结构的标准\n2. 功能特性：指定电压意义\n3. 过程特性：指明可能功能顺序\n4. 电气特性：指明电压范围\n\n这四种特性记得即可，基本都是送分题\n\n### 传输媒体\n\n导引型传输媒体\n\n1. 同轴线缆\n\n   1. 较贵，适用范围较窄\n\n2. 双绞线\n\n   1. 使用最为广泛的线缆\n\n3. 光纤\n\n   1. 通信容量大\n   2. 传输损耗小\n   3. 抗雷电和电磁干扰好\n\n   ![光纤内部结构](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727163726712.png)\n\n   光纤传输的原理即：全反射\n\n   ![两种不同的光缆](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727163843713.png)\n\n4. 电力线\n\n   1. 落后且功能简单的网络布局方式\n\n非导引型的传输媒体\n\n1. 无线电波\n\n2. 微波\n\n   ![无线电波与微波对频率的划分](https://s2.loli.net/2024/07/27/l9HkLIyxKEr3jmp.png)\n\n   微波在空间中是直线传播的，通常通过高信号站和电离层反射\n\n3. 红外通信\n\n   1. 点对点无线传输\n   2. 直线传输，中间不能有障碍物，传输距离短\n   3. 传输速率低（4Mb/s~16Mb/s)\n\n4. 可见光通信技术\n\n   1. LIFI：可见光WIFI技术\n\n## 传输方式\n\n1. 按传输方式分类\n\n   1. 串行传输\n\n   2. 并行传输\n\n   3. 同步传输\n\n      在信号传输过程中需要对比传输的顺序判断，同步传输方式需要对收发方式进行时钟同步\n\n      - 内同步\n\n        发送端将时钟同步编码到发送数据中一起传输，如曼切斯特编码\n\n      - 外同步\n\n        在收发双方添加一条单独的时钟信号线\n\n   4. 异步传输\n\n      - 字节之间异步（字节之间的时间间隔不固定）\n      - 字节中的每个比特仍然要同步（各个bit的持续时间是相同的）\n\n   ![同步异步](https://s2.loli.net/2024/07/27/UHGm14ehKABkCEV.png)\n\n2. 传播的功能\n\n   1. 单工\n   2. 双工\n   3. 半双工\n\n   ![通信方式](https://s2.loli.net/2024/07/27/rpXlAiILbWCN4Fn.png)\n\n \n\n## 编码与调制\n\n### 码元\n在使用时间域的波形表示数字信号时**代表不同离散数值的基本波形。**\n\n![image-20240727165919011](https://s2.loli.net/2024/07/27/ZPzp9E1sTxYtgry.png)\n\n### 常用编码\n\n#### 归零与非归零编码RZ，NRZ\n\n1. 不归零编码\n\n![不归零编码](https://s2.loli.net/2024/07/27/s2NOedUrPBpuoaD.png)\n\n不归零编码存在同步问题\n\n![归零编码](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727170129033.png)\n\n归零编码是自同步编码，但存在信道浪费问题\n\n#### 曼彻斯特与差分曼彻斯特编码\n\n![曼彻斯特与差分曼彻斯特编码](https://s2.loli.net/2024/07/27/QtSjc7bNvd2FEpg.png)\n\n曼彻斯特编码**正跳变表示0，负跳变表示1**，差分曼彻斯特编码则是对码元开始处是否变化表示0，1，差分，曼彻斯特编码的变化比曼彻斯特少，传输效率更高，如果码元**开始时发生变化这是0，不变则是1，对第一位的编码，若是负跳变则是1，正跳变则是0.**\n\n有时也可以交换0，1\n\n#### 一些特殊的编码\n\n- **NRZI，反向不归零编码**\n\n反向不归零编码NRZI，在码元时间内不会出现零电平。若后一个码元时间内所持续的电平与前一个码元时间内所持续的电平不同（也称为电平反转）则表示0，若电平保持不变则表示1。\n\n### 基本调制方法\n\n#### AM,FM,PM\n\n![AM、FM、PM](https://s2.loli.net/2024/07/27/YT1gdh9RxnoylSU.png)\n\n因为**频率和相位**是相关的，即**频率是相位随时间的变化率**。所以**一次只能调制频率和相位两个中的一个**。\n\n#### QAM\n\n通常情况下，**相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。**\n\n![QAM-16](https://s2.loli.net/2024/07/27/IeMxbAGtuSnDoLQ.png)\n\n这里的码元表示bit采用格雷码以减少数据传输错误时的误差。\n\n> **格雷码**\n>\n> 格雷码的基本性质是任意两个**相邻的代码只有一位二进制数**不同，则称这种编码为格雷码（Gray Code），另外由于**最大数与最小数之间也仅一位数不同**，即“首尾相连”，因此又称循环码或反射码。\n>\n> 格雷码的编码机制是：\n>\n> 1. 第一步，改变最右边的位元值；\n> 2. 第二步，改变右起第一个为1的位元的左边位元；\n> 3. 第三步，第四步重复第一步和第二步，直到所有的格雷码产生完毕（换句话说，已经走了(2^n) - 1 步）。\n>\n> ```\n> 0000、0001、0011、0010、0110、0111、0101、0100、\n> 1100、1101、1111、1110、1010、1011、1001、1000\n> ```\n\n## 信道的极限容量\n\n见奈氏准则与香农定理章节[奈氏定理与香农法则.md](./奈氏定理与香农法则.md)\n\n### 信道的极限容量\n\n- 在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必\n  须采用多元制（更好的调制方法）和努力提高信道中的信噪比。\n- 自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽\n  可能地接近香农公式给出的传输速率极限\n\n见[错题本](..\\错题汇总草案-计网篇.md)中奈氏香农例题\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/物理层","published":1,"updated":"2024-08-17T13:24:40.068Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqt003km8wvay5ubjyh","content":"<h1 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h1><h2 id=\"物理层的基本概念\"><a href=\"#物理层的基本概念\" class=\"headerlink\" title=\"物理层的基本概念\"></a>物理层的基本概念</h2><ul>\n<li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li>\n<li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议<br>和服务，而不必考虑网络具体的传输媒体是什么。</li>\n</ul>\n<h2 id=\"物理层下的传输媒体\"><a href=\"#物理层下的传输媒体\" class=\"headerlink\" title=\"物理层下的传输媒体\"></a>物理层下的传输媒体</h2><h3 id=\"物联网接口特性\"><a href=\"#物联网接口特性\" class=\"headerlink\" title=\"物联网接口特性\"></a>物联网接口特性</h3><ol>\n<li>机械特性：指明结构的标准</li>\n<li>功能特性：指定电压意义</li>\n<li>过程特性：指明可能功能顺序</li>\n<li>电气特性：指明电压范围</li>\n</ol>\n<p>这四种特性记得即可，基本都是送分题</p>\n<h3 id=\"传输媒体\"><a href=\"#传输媒体\" class=\"headerlink\" title=\"传输媒体\"></a>传输媒体</h3><p>导引型传输媒体</p>\n<ol>\n<li><p>同轴线缆</p>\n<ol>\n<li>较贵，适用范围较窄</li>\n</ol>\n</li>\n<li><p>双绞线</p>\n<ol>\n<li>使用最为广泛的线缆</li>\n</ol>\n</li>\n<li><p>光纤</p>\n<ol>\n<li>通信容量大</li>\n<li>传输损耗小</li>\n<li>抗雷电和电磁干扰好</li>\n</ol>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727163726712.png\" alt=\"光纤内部结构\"></p>\n<p>光纤传输的原理即：全反射</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727163843713.png\" alt=\"两种不同的光缆\"></p>\n</li>\n<li><p>电力线</p>\n<ol>\n<li>落后且功能简单的网络布局方式</li>\n</ol>\n</li>\n</ol>\n<p>非导引型的传输媒体</p>\n<ol>\n<li><p>无线电波</p>\n</li>\n<li><p>微波</p>\n<p><img src=\"https://s2.loli.net/2024/07/27/l9HkLIyxKEr3jmp.png\" alt=\"无线电波与微波对频率的划分\"></p>\n<p>微波在空间中是直线传播的，通常通过高信号站和电离层反射</p>\n</li>\n<li><p>红外通信</p>\n<ol>\n<li>点对点无线传输</li>\n<li>直线传输，中间不能有障碍物，传输距离短</li>\n<li>传输速率低（4Mb/s~16Mb/s)</li>\n</ol>\n</li>\n<li><p>可见光通信技术</p>\n<ol>\n<li>LIFI：可见光WIFI技术</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"传输方式\"><a href=\"#传输方式\" class=\"headerlink\" title=\"传输方式\"></a>传输方式</h2><ol>\n<li><p>按传输方式分类</p>\n<ol>\n<li><p>串行传输</p>\n</li>\n<li><p>并行传输</p>\n</li>\n<li><p>同步传输</p>\n<p>在信号传输过程中需要对比传输的顺序判断，同步传输方式需要对收发方式进行时钟同步</p>\n<ul>\n<li><p>内同步</p>\n<p>发送端将时钟同步编码到发送数据中一起传输，如曼切斯特编码</p>\n</li>\n<li><p>外同步</p>\n<p>在收发双方添加一条单独的时钟信号线</p>\n</li>\n</ul>\n</li>\n<li><p>异步传输</p>\n<ul>\n<li>字节之间异步（字节之间的时间间隔不固定）</li>\n<li>字节中的每个比特仍然要同步（各个bit的持续时间是相同的）</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/27/UHGm14ehKABkCEV.png\" alt=\"同步异步\"></p>\n</li>\n<li><p>传播的功能</p>\n<ol>\n<li>单工</li>\n<li>双工</li>\n<li>半双工</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/27/rpXlAiILbWCN4Fn.png\" alt=\"通信方式\"></p>\n</li>\n</ol>\n<h2 id=\"编码与调制\"><a href=\"#编码与调制\" class=\"headerlink\" title=\"编码与调制\"></a>编码与调制</h2><h3 id=\"码元\"><a href=\"#码元\" class=\"headerlink\" title=\"码元\"></a>码元</h3><p>在使用时间域的波形表示数字信号时<strong>代表不同离散数值的基本波形。</strong></p>\n<p><img src=\"https://s2.loli.net/2024/07/27/ZPzp9E1sTxYtgry.png\" alt=\"image-20240727165919011\"></p>\n<h3 id=\"常用编码\"><a href=\"#常用编码\" class=\"headerlink\" title=\"常用编码\"></a>常用编码</h3><h4 id=\"归零与非归零编码RZ，NRZ\"><a href=\"#归零与非归零编码RZ，NRZ\" class=\"headerlink\" title=\"归零与非归零编码RZ，NRZ\"></a>归零与非归零编码RZ，NRZ</h4><ol>\n<li>不归零编码</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/27/s2NOedUrPBpuoaD.png\" alt=\"不归零编码\"></p>\n<p>不归零编码存在同步问题</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727170129033.png\" alt=\"归零编码\"></p>\n<p>归零编码是自同步编码，但存在信道浪费问题</p>\n<h4 id=\"曼彻斯特与差分曼彻斯特编码\"><a href=\"#曼彻斯特与差分曼彻斯特编码\" class=\"headerlink\" title=\"曼彻斯特与差分曼彻斯特编码\"></a>曼彻斯特与差分曼彻斯特编码</h4><p><img src=\"https://s2.loli.net/2024/07/27/QtSjc7bNvd2FEpg.png\" alt=\"曼彻斯特与差分曼彻斯特编码\"></p>\n<p>曼彻斯特编码<strong>正跳变表示0，负跳变表示1</strong>，差分曼彻斯特编码则是对码元开始处是否变化表示0，1，差分，曼彻斯特编码的变化比曼彻斯特少，传输效率更高，如果码元<strong>开始时发生变化这是0，不变则是1，对第一位的编码，若是负跳变则是1，正跳变则是0.</strong></p>\n<p>有时也可以交换0，1</p>\n<h4 id=\"一些特殊的编码\"><a href=\"#一些特殊的编码\" class=\"headerlink\" title=\"一些特殊的编码\"></a>一些特殊的编码</h4><ul>\n<li><strong>NRZI，反向不归零编码</strong></li>\n</ul>\n<p>反向不归零编码NRZI，在码元时间内不会出现零电平。若后一个码元时间内所持续的电平与前一个码元时间内所持续的电平不同（也称为电平反转）则表示0，若电平保持不变则表示1。</p>\n<h3 id=\"基本调制方法\"><a href=\"#基本调制方法\" class=\"headerlink\" title=\"基本调制方法\"></a>基本调制方法</h3><h4 id=\"AM-FM-PM\"><a href=\"#AM-FM-PM\" class=\"headerlink\" title=\"AM,FM,PM\"></a>AM,FM,PM</h4><p><img src=\"https://s2.loli.net/2024/07/27/YT1gdh9RxnoylSU.png\" alt=\"AM、FM、PM\"></p>\n<p>因为<strong>频率和相位</strong>是相关的，即<strong>频率是相位随时间的变化率</strong>。所以<strong>一次只能调制频率和相位两个中的一个</strong>。</p>\n<h4 id=\"QAM\"><a href=\"#QAM\" class=\"headerlink\" title=\"QAM\"></a>QAM</h4><p>通常情况下，<strong>相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。</strong></p>\n<p><img src=\"https://s2.loli.net/2024/07/27/IeMxbAGtuSnDoLQ.png\" alt=\"QAM-16\"></p>\n<p>这里的码元表示bit采用格雷码以减少数据传输错误时的误差。</p>\n<blockquote>\n<p><strong>格雷码</strong></p>\n<p>格雷码的基本性质是任意两个<strong>相邻的代码只有一位二进制数</strong>不同，则称这种编码为格雷码（Gray Code），另外由于<strong>最大数与最小数之间也仅一位数不同</strong>，即“首尾相连”，因此又称循环码或反射码。</p>\n<p>格雷码的编码机制是：</p>\n<ol>\n<li>第一步，改变最右边的位元值；</li>\n<li>第二步，改变右起第一个为1的位元的左边位元；</li>\n<li>第三步，第四步重复第一步和第二步，直到所有的格雷码产生完毕（换句话说，已经走了(2^n) - 1 步）。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000、0001、0011、0010、0110、0111、0101、0100、</span><br><span class=\"line\">1100、1101、1111、1110、1010、1011、1001、1000</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"信道的极限容量\"><a href=\"#信道的极限容量\" class=\"headerlink\" title=\"信道的极限容量\"></a>信道的极限容量</h2><p>见奈氏准则与香农定理章节<a href=\"./奈氏定理与香农法则.md\">奈氏定理与香农法则.md</a></p>\n<h3 id=\"信道的极限容量-1\"><a href=\"#信道的极限容量-1\" class=\"headerlink\" title=\"信道的极限容量\"></a>信道的极限容量</h3><ul>\n<li>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必<br>须采用多元制（更好的调制方法）和努力提高信道中的信噪比。</li>\n<li>自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽<br>可能地接近香农公式给出的传输速率极限</li>\n</ul>\n<p>见<a href=\"..\\错题汇总草案-计网篇.md\">错题本</a>中奈氏香农例题</p>\n<!-- flag of hidden posts -->","length":1366,"excerpt":"","more":"<h1 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h1><h2 id=\"物理层的基本概念\"><a href=\"#物理层的基本概念\" class=\"headerlink\" title=\"物理层的基本概念\"></a>物理层的基本概念</h2><ul>\n<li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li>\n<li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议<br>和服务，而不必考虑网络具体的传输媒体是什么。</li>\n</ul>\n<h2 id=\"物理层下的传输媒体\"><a href=\"#物理层下的传输媒体\" class=\"headerlink\" title=\"物理层下的传输媒体\"></a>物理层下的传输媒体</h2><h3 id=\"物联网接口特性\"><a href=\"#物联网接口特性\" class=\"headerlink\" title=\"物联网接口特性\"></a>物联网接口特性</h3><ol>\n<li>机械特性：指明结构的标准</li>\n<li>功能特性：指定电压意义</li>\n<li>过程特性：指明可能功能顺序</li>\n<li>电气特性：指明电压范围</li>\n</ol>\n<p>这四种特性记得即可，基本都是送分题</p>\n<h3 id=\"传输媒体\"><a href=\"#传输媒体\" class=\"headerlink\" title=\"传输媒体\"></a>传输媒体</h3><p>导引型传输媒体</p>\n<ol>\n<li><p>同轴线缆</p>\n<ol>\n<li>较贵，适用范围较窄</li>\n</ol>\n</li>\n<li><p>双绞线</p>\n<ol>\n<li>使用最为广泛的线缆</li>\n</ol>\n</li>\n<li><p>光纤</p>\n<ol>\n<li>通信容量大</li>\n<li>传输损耗小</li>\n<li>抗雷电和电磁干扰好</li>\n</ol>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727163726712.png\" alt=\"光纤内部结构\"></p>\n<p>光纤传输的原理即：全反射</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727163843713.png\" alt=\"两种不同的光缆\"></p>\n</li>\n<li><p>电力线</p>\n<ol>\n<li>落后且功能简单的网络布局方式</li>\n</ol>\n</li>\n</ol>\n<p>非导引型的传输媒体</p>\n<ol>\n<li><p>无线电波</p>\n</li>\n<li><p>微波</p>\n<p><img src=\"https://s2.loli.net/2024/07/27/l9HkLIyxKEr3jmp.png\" alt=\"无线电波与微波对频率的划分\"></p>\n<p>微波在空间中是直线传播的，通常通过高信号站和电离层反射</p>\n</li>\n<li><p>红外通信</p>\n<ol>\n<li>点对点无线传输</li>\n<li>直线传输，中间不能有障碍物，传输距离短</li>\n<li>传输速率低（4Mb/s~16Mb/s)</li>\n</ol>\n</li>\n<li><p>可见光通信技术</p>\n<ol>\n<li>LIFI：可见光WIFI技术</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"传输方式\"><a href=\"#传输方式\" class=\"headerlink\" title=\"传输方式\"></a>传输方式</h2><ol>\n<li><p>按传输方式分类</p>\n<ol>\n<li><p>串行传输</p>\n</li>\n<li><p>并行传输</p>\n</li>\n<li><p>同步传输</p>\n<p>在信号传输过程中需要对比传输的顺序判断，同步传输方式需要对收发方式进行时钟同步</p>\n<ul>\n<li><p>内同步</p>\n<p>发送端将时钟同步编码到发送数据中一起传输，如曼切斯特编码</p>\n</li>\n<li><p>外同步</p>\n<p>在收发双方添加一条单独的时钟信号线</p>\n</li>\n</ul>\n</li>\n<li><p>异步传输</p>\n<ul>\n<li>字节之间异步（字节之间的时间间隔不固定）</li>\n<li>字节中的每个比特仍然要同步（各个bit的持续时间是相同的）</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/27/UHGm14ehKABkCEV.png\" alt=\"同步异步\"></p>\n</li>\n<li><p>传播的功能</p>\n<ol>\n<li>单工</li>\n<li>双工</li>\n<li>半双工</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/27/rpXlAiILbWCN4Fn.png\" alt=\"通信方式\"></p>\n</li>\n</ol>\n<h2 id=\"编码与调制\"><a href=\"#编码与调制\" class=\"headerlink\" title=\"编码与调制\"></a>编码与调制</h2><h3 id=\"码元\"><a href=\"#码元\" class=\"headerlink\" title=\"码元\"></a>码元</h3><p>在使用时间域的波形表示数字信号时<strong>代表不同离散数值的基本波形。</strong></p>\n<p><img src=\"https://s2.loli.net/2024/07/27/ZPzp9E1sTxYtgry.png\" alt=\"image-20240727165919011\"></p>\n<h3 id=\"常用编码\"><a href=\"#常用编码\" class=\"headerlink\" title=\"常用编码\"></a>常用编码</h3><h4 id=\"归零与非归零编码RZ，NRZ\"><a href=\"#归零与非归零编码RZ，NRZ\" class=\"headerlink\" title=\"归零与非归零编码RZ，NRZ\"></a>归零与非归零编码RZ，NRZ</h4><ol>\n<li>不归零编码</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/27/s2NOedUrPBpuoaD.png\" alt=\"不归零编码\"></p>\n<p>不归零编码存在同步问题</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240727170129033.png\" alt=\"归零编码\"></p>\n<p>归零编码是自同步编码，但存在信道浪费问题</p>\n<h4 id=\"曼彻斯特与差分曼彻斯特编码\"><a href=\"#曼彻斯特与差分曼彻斯特编码\" class=\"headerlink\" title=\"曼彻斯特与差分曼彻斯特编码\"></a>曼彻斯特与差分曼彻斯特编码</h4><p><img src=\"https://s2.loli.net/2024/07/27/QtSjc7bNvd2FEpg.png\" alt=\"曼彻斯特与差分曼彻斯特编码\"></p>\n<p>曼彻斯特编码<strong>正跳变表示0，负跳变表示1</strong>，差分曼彻斯特编码则是对码元开始处是否变化表示0，1，差分，曼彻斯特编码的变化比曼彻斯特少，传输效率更高，如果码元<strong>开始时发生变化这是0，不变则是1，对第一位的编码，若是负跳变则是1，正跳变则是0.</strong></p>\n<p>有时也可以交换0，1</p>\n<h4 id=\"一些特殊的编码\"><a href=\"#一些特殊的编码\" class=\"headerlink\" title=\"一些特殊的编码\"></a>一些特殊的编码</h4><ul>\n<li><strong>NRZI，反向不归零编码</strong></li>\n</ul>\n<p>反向不归零编码NRZI，在码元时间内不会出现零电平。若后一个码元时间内所持续的电平与前一个码元时间内所持续的电平不同（也称为电平反转）则表示0，若电平保持不变则表示1。</p>\n<h3 id=\"基本调制方法\"><a href=\"#基本调制方法\" class=\"headerlink\" title=\"基本调制方法\"></a>基本调制方法</h3><h4 id=\"AM-FM-PM\"><a href=\"#AM-FM-PM\" class=\"headerlink\" title=\"AM,FM,PM\"></a>AM,FM,PM</h4><p><img src=\"https://s2.loli.net/2024/07/27/YT1gdh9RxnoylSU.png\" alt=\"AM、FM、PM\"></p>\n<p>因为<strong>频率和相位</strong>是相关的，即<strong>频率是相位随时间的变化率</strong>。所以<strong>一次只能调制频率和相位两个中的一个</strong>。</p>\n<h4 id=\"QAM\"><a href=\"#QAM\" class=\"headerlink\" title=\"QAM\"></a>QAM</h4><p>通常情况下，<strong>相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。</strong></p>\n<p><img src=\"https://s2.loli.net/2024/07/27/IeMxbAGtuSnDoLQ.png\" alt=\"QAM-16\"></p>\n<p>这里的码元表示bit采用格雷码以减少数据传输错误时的误差。</p>\n<blockquote>\n<p><strong>格雷码</strong></p>\n<p>格雷码的基本性质是任意两个<strong>相邻的代码只有一位二进制数</strong>不同，则称这种编码为格雷码（Gray Code），另外由于<strong>最大数与最小数之间也仅一位数不同</strong>，即“首尾相连”，因此又称循环码或反射码。</p>\n<p>格雷码的编码机制是：</p>\n<ol>\n<li>第一步，改变最右边的位元值；</li>\n<li>第二步，改变右起第一个为1的位元的左边位元；</li>\n<li>第三步，第四步重复第一步和第二步，直到所有的格雷码产生完毕（换句话说，已经走了(2^n) - 1 步）。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000、0001、0011、0010、0110、0111、0101、0100、</span><br><span class=\"line\">1100、1101、1111、1110、1010、1011、1001、1000</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"信道的极限容量\"><a href=\"#信道的极限容量\" class=\"headerlink\" title=\"信道的极限容量\"></a>信道的极限容量</h2><p>见奈氏准则与香农定理章节<a href=\"./奈氏定理与香农法则.md\">奈氏定理与香农法则.md</a></p>\n<h3 id=\"信道的极限容量-1\"><a href=\"#信道的极限容量-1\" class=\"headerlink\" title=\"信道的极限容量\"></a>信道的极限容量</h3><ul>\n<li>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必<br>须采用多元制（更好的调制方法）和努力提高信道中的信噪比。</li>\n<li>自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽<br>可能地接近香农公式给出的传输速率极限</li>\n</ul>\n<p>见<a href=\"..\\错题汇总草案-计网篇.md\">错题本</a>中奈氏香农例题</p>\n"},{"title":"计网篇-运输层篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# 运输层\n\n## 概述\n\n- 负责主机中**进程之间**的通信，又称端到端之间的通信\n\n![运输层服务逻辑大观](https://s2.loli.net/2024/08/08/LCXOwYnHu1WGZyi.png)\n\n- 两种重要的运输协议，面向连接的TCP与面向报文的UDP\n\n## 端口号、复用、分用\n\n**端口号**\n\n---\n\n不同的操作系统对进程的标识不同\n\n- TCP/IP体系的运输层采用**端口号**来区分应用层的不同应用\n\n  - 端口号采用16bits来标识\n\n  - 端口号有以下分类\n\n    1. 熟知端口号：0-1023，IANA将这些端口号指派给了TCP/IP体系中最重要的一些应用协议\n\n       ![常见协议的熟知端口号](https://s2.loli.net/2024/08/08/OL1jlmc5UMiWHBR.png)\n\n       > 就提及较少的协议说明补充\n       >\n       > TFTP：Trivial File Transfer Protocol 简单文件传送协议，又指小文件传送协议\n       >\n       > SNMP：Simple Network Manage Protocol 简单网络管理协议\n       >\n       > DHCP：Dynamical Host Configuration 动态主机配置协议\n\n    2. 登记端口号：1024-49151，为没有熟知端口号的应用程序使用，这些端口号必须在IANA的规定手续下登记，以防止重复。\n\n    3. 短暂端口号：49152-65535：留给临时使用\n\n  - 端口号只具有本地意义\n\n---\n\n**复用与分用**\n\n---\n\n![复用与分用图解](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240808215240620.png)\n\n## UDP 与 TCP\n\nUDP User Datagram Protocol 用户数据报\n\nTCP Transmission Control Protocol 传输控制协议\n\n1. UDP支持单播，多播与广播\n\n2. TCP仅支持单播\n\n3. UDP是面向报文的\n\n4. TCP是面向字节的\n\n   ![UDP、TCP的实现逻辑](https://s2.loli.net/2024/08/08/bRIqX5TF92LkmH7.png)\n\n5. UDP的首部格式较为简单，总共只有8个字节\n\n   1. 源端口 2字节\n   2. 目的端口 2字节\n   3. 长度 2字节\n   4. 检验和 2字节\n\n6. TCP的首部则要复杂的多，最小长度是20字节，最大长度是60字节。\n\n  ![image-20240808221145067](https://s2.loli.net/2024/08/08/UWzIZLgDF76am3B.png)\n\n---\n\n对比总结\n\n---\n\n![TCP、UDP对比总结](https://s2.loli.net/2024/08/08/U1iK3bDMAVeHRyp.png)\n\n## TCP\n\n### TCP的流量控制\n\n- 使用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制\n\n> ![TCP滑动窗口1](https://s2.loli.net/2024/08/08/1WbpJ5Yhxyvfa8E.png)\n>\n> ![TCP滑动窗口2](https://s2.loli.net/2024/08/08/teuLpOSa8JgXrIB.png)\n>\n> ![TCP拥塞控制习题](https://s2.loli.net/2024/08/08/S9EqfcrjWAZlnYJ.png)\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/运输层.md","raw":"---\ntitle: 计网篇-运输层篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# 运输层\n\n## 概述\n\n- 负责主机中**进程之间**的通信，又称端到端之间的通信\n\n![运输层服务逻辑大观](https://s2.loli.net/2024/08/08/LCXOwYnHu1WGZyi.png)\n\n- 两种重要的运输协议，面向连接的TCP与面向报文的UDP\n\n## 端口号、复用、分用\n\n**端口号**\n\n---\n\n不同的操作系统对进程的标识不同\n\n- TCP/IP体系的运输层采用**端口号**来区分应用层的不同应用\n\n  - 端口号采用16bits来标识\n\n  - 端口号有以下分类\n\n    1. 熟知端口号：0-1023，IANA将这些端口号指派给了TCP/IP体系中最重要的一些应用协议\n\n       ![常见协议的熟知端口号](https://s2.loli.net/2024/08/08/OL1jlmc5UMiWHBR.png)\n\n       > 就提及较少的协议说明补充\n       >\n       > TFTP：Trivial File Transfer Protocol 简单文件传送协议，又指小文件传送协议\n       >\n       > SNMP：Simple Network Manage Protocol 简单网络管理协议\n       >\n       > DHCP：Dynamical Host Configuration 动态主机配置协议\n\n    2. 登记端口号：1024-49151，为没有熟知端口号的应用程序使用，这些端口号必须在IANA的规定手续下登记，以防止重复。\n\n    3. 短暂端口号：49152-65535：留给临时使用\n\n  - 端口号只具有本地意义\n\n---\n\n**复用与分用**\n\n---\n\n![复用与分用图解](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240808215240620.png)\n\n## UDP 与 TCP\n\nUDP User Datagram Protocol 用户数据报\n\nTCP Transmission Control Protocol 传输控制协议\n\n1. UDP支持单播，多播与广播\n\n2. TCP仅支持单播\n\n3. UDP是面向报文的\n\n4. TCP是面向字节的\n\n   ![UDP、TCP的实现逻辑](https://s2.loli.net/2024/08/08/bRIqX5TF92LkmH7.png)\n\n5. UDP的首部格式较为简单，总共只有8个字节\n\n   1. 源端口 2字节\n   2. 目的端口 2字节\n   3. 长度 2字节\n   4. 检验和 2字节\n\n6. TCP的首部则要复杂的多，最小长度是20字节，最大长度是60字节。\n\n  ![image-20240808221145067](https://s2.loli.net/2024/08/08/UWzIZLgDF76am3B.png)\n\n---\n\n对比总结\n\n---\n\n![TCP、UDP对比总结](https://s2.loli.net/2024/08/08/U1iK3bDMAVeHRyp.png)\n\n## TCP\n\n### TCP的流量控制\n\n- 使用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制\n\n> ![TCP滑动窗口1](https://s2.loli.net/2024/08/08/1WbpJ5Yhxyvfa8E.png)\n>\n> ![TCP滑动窗口2](https://s2.loli.net/2024/08/08/teuLpOSa8JgXrIB.png)\n>\n> ![TCP拥塞控制习题](https://s2.loli.net/2024/08/08/S9EqfcrjWAZlnYJ.png)\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/运输层","published":1,"updated":"2024-08-17T13:25:37.159Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqt003mm8wv4gascd73","content":"<h1 id=\"运输层\"><a href=\"#运输层\" class=\"headerlink\" title=\"运输层\"></a>运输层</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li>负责主机中<strong>进程之间</strong>的通信，又称端到端之间的通信</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/08/LCXOwYnHu1WGZyi.png\" alt=\"运输层服务逻辑大观\"></p>\n<ul>\n<li>两种重要的运输协议，面向连接的TCP与面向报文的UDP</li>\n</ul>\n<h2 id=\"端口号、复用、分用\"><a href=\"#端口号、复用、分用\" class=\"headerlink\" title=\"端口号、复用、分用\"></a>端口号、复用、分用</h2><p><strong>端口号</strong></p>\n<hr>\n<p>不同的操作系统对进程的标识不同</p>\n<ul>\n<li><p>TCP/IP体系的运输层采用<strong>端口号</strong>来区分应用层的不同应用</p>\n<ul>\n<li><p>端口号采用16bits来标识</p>\n</li>\n<li><p>端口号有以下分类</p>\n<ol>\n<li><p>熟知端口号：0-1023，IANA将这些端口号指派给了TCP/IP体系中最重要的一些应用协议</p>\n<p><img src=\"https://s2.loli.net/2024/08/08/OL1jlmc5UMiWHBR.png\" alt=\"常见协议的熟知端口号\"></p>\n<blockquote>\n<p>就提及较少的协议说明补充</p>\n<p>TFTP：Trivial File Transfer Protocol 简单文件传送协议，又指小文件传送协议</p>\n<p>SNMP：Simple Network Manage Protocol 简单网络管理协议</p>\n<p>DHCP：Dynamical Host Configuration 动态主机配置协议</p>\n</blockquote>\n</li>\n<li><p>登记端口号：1024-49151，为没有熟知端口号的应用程序使用，这些端口号必须在IANA的规定手续下登记，以防止重复。</p>\n</li>\n<li><p>短暂端口号：49152-65535：留给临时使用</p>\n</li>\n</ol>\n</li>\n<li><p>端口号只具有本地意义</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>复用与分用</strong></p>\n<hr>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240808215240620.png\" alt=\"复用与分用图解\"></p>\n<h2 id=\"UDP-与-TCP\"><a href=\"#UDP-与-TCP\" class=\"headerlink\" title=\"UDP 与 TCP\"></a>UDP 与 TCP</h2><p>UDP User Datagram Protocol 用户数据报</p>\n<p>TCP Transmission Control Protocol 传输控制协议</p>\n<ol>\n<li><p>UDP支持单播，多播与广播</p>\n</li>\n<li><p>TCP仅支持单播</p>\n</li>\n<li><p>UDP是面向报文的</p>\n</li>\n<li><p>TCP是面向字节的</p>\n<p><img src=\"https://s2.loli.net/2024/08/08/bRIqX5TF92LkmH7.png\" alt=\"UDP、TCP的实现逻辑\"></p>\n</li>\n<li><p>UDP的首部格式较为简单，总共只有8个字节</p>\n<ol>\n<li>源端口 2字节</li>\n<li>目的端口 2字节</li>\n<li>长度 2字节</li>\n<li>检验和 2字节</li>\n</ol>\n</li>\n<li><p>TCP的首部则要复杂的多，最小长度是20字节，最大长度是60字节。</p>\n<p><img src=\"https://s2.loli.net/2024/08/08/UWzIZLgDF76am3B.png\" alt=\"image-20240808221145067\"></p>\n</li>\n</ol>\n<hr>\n<p>对比总结</p>\n<hr>\n<p><img src=\"https://s2.loli.net/2024/08/08/U1iK3bDMAVeHRyp.png\" alt=\"TCP、UDP对比总结\"></p>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><h3 id=\"TCP的流量控制\"><a href=\"#TCP的流量控制\" class=\"headerlink\" title=\"TCP的流量控制\"></a>TCP的流量控制</h3><ul>\n<li>使用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制</li>\n</ul>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/08/08/1WbpJ5Yhxyvfa8E.png\" alt=\"TCP滑动窗口1\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/08/teuLpOSa8JgXrIB.png\" alt=\"TCP滑动窗口2\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/08/S9EqfcrjWAZlnYJ.png\" alt=\"TCP拥塞控制习题\"></p>\n</blockquote>\n<!-- flag of hidden posts -->","length":510,"excerpt":"","more":"<h1 id=\"运输层\"><a href=\"#运输层\" class=\"headerlink\" title=\"运输层\"></a>运输层</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li>负责主机中<strong>进程之间</strong>的通信，又称端到端之间的通信</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/08/LCXOwYnHu1WGZyi.png\" alt=\"运输层服务逻辑大观\"></p>\n<ul>\n<li>两种重要的运输协议，面向连接的TCP与面向报文的UDP</li>\n</ul>\n<h2 id=\"端口号、复用、分用\"><a href=\"#端口号、复用、分用\" class=\"headerlink\" title=\"端口号、复用、分用\"></a>端口号、复用、分用</h2><p><strong>端口号</strong></p>\n<hr>\n<p>不同的操作系统对进程的标识不同</p>\n<ul>\n<li><p>TCP/IP体系的运输层采用<strong>端口号</strong>来区分应用层的不同应用</p>\n<ul>\n<li><p>端口号采用16bits来标识</p>\n</li>\n<li><p>端口号有以下分类</p>\n<ol>\n<li><p>熟知端口号：0-1023，IANA将这些端口号指派给了TCP/IP体系中最重要的一些应用协议</p>\n<p><img src=\"https://s2.loli.net/2024/08/08/OL1jlmc5UMiWHBR.png\" alt=\"常见协议的熟知端口号\"></p>\n<blockquote>\n<p>就提及较少的协议说明补充</p>\n<p>TFTP：Trivial File Transfer Protocol 简单文件传送协议，又指小文件传送协议</p>\n<p>SNMP：Simple Network Manage Protocol 简单网络管理协议</p>\n<p>DHCP：Dynamical Host Configuration 动态主机配置协议</p>\n</blockquote>\n</li>\n<li><p>登记端口号：1024-49151，为没有熟知端口号的应用程序使用，这些端口号必须在IANA的规定手续下登记，以防止重复。</p>\n</li>\n<li><p>短暂端口号：49152-65535：留给临时使用</p>\n</li>\n</ol>\n</li>\n<li><p>端口号只具有本地意义</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>复用与分用</strong></p>\n<hr>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240808215240620.png\" alt=\"复用与分用图解\"></p>\n<h2 id=\"UDP-与-TCP\"><a href=\"#UDP-与-TCP\" class=\"headerlink\" title=\"UDP 与 TCP\"></a>UDP 与 TCP</h2><p>UDP User Datagram Protocol 用户数据报</p>\n<p>TCP Transmission Control Protocol 传输控制协议</p>\n<ol>\n<li><p>UDP支持单播，多播与广播</p>\n</li>\n<li><p>TCP仅支持单播</p>\n</li>\n<li><p>UDP是面向报文的</p>\n</li>\n<li><p>TCP是面向字节的</p>\n<p><img src=\"https://s2.loli.net/2024/08/08/bRIqX5TF92LkmH7.png\" alt=\"UDP、TCP的实现逻辑\"></p>\n</li>\n<li><p>UDP的首部格式较为简单，总共只有8个字节</p>\n<ol>\n<li>源端口 2字节</li>\n<li>目的端口 2字节</li>\n<li>长度 2字节</li>\n<li>检验和 2字节</li>\n</ol>\n</li>\n<li><p>TCP的首部则要复杂的多，最小长度是20字节，最大长度是60字节。</p>\n<p><img src=\"https://s2.loli.net/2024/08/08/UWzIZLgDF76am3B.png\" alt=\"image-20240808221145067\"></p>\n</li>\n</ol>\n<hr>\n<p>对比总结</p>\n<hr>\n<p><img src=\"https://s2.loli.net/2024/08/08/U1iK3bDMAVeHRyp.png\" alt=\"TCP、UDP对比总结\"></p>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><h3 id=\"TCP的流量控制\"><a href=\"#TCP的流量控制\" class=\"headerlink\" title=\"TCP的流量控制\"></a>TCP的流量控制</h3><ul>\n<li>使用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制</li>\n</ul>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/08/08/1WbpJ5Yhxyvfa8E.png\" alt=\"TCP滑动窗口1\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/08/teuLpOSa8JgXrIB.png\" alt=\"TCP滑动窗口2\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/08/S9EqfcrjWAZlnYJ.png\" alt=\"TCP拥塞控制习题\"></p>\n</blockquote>\n"},{"title":"计网篇-网络层篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# 网络层\n\n- 网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输\n\n- 功能\n\n  - 提供怎样的服务：是：“可靠传输” 还是 “不可靠传输服务” \n  - 网络层寻址问题\n  - 路由选择问题\n\n- 由于因特网是目前用户数量最多的互联网，其使用 **TCP\\IP 协议栈**\n\n- 由于TCP/IP协议栈的网络层使用**网际协议IP**，它是整个**协议栈的核心协议**，因此在TCP/IP协议栈中网络层常称为网际层。\n\n  ![TCP/IP协议栈](https://s2.loli.net/2024/08/01/WECiKvsUhFgbqBz.png)\n\n## 网络层提供的两种服务\n\n### 面向连接的虚电路服务\n\n- 可靠通信应由网络来保证\n- 必须建立网络层的连接——虚电路（VC Virtual Circuit）\n- 通信双方沿着已建立的虚电路发送分组\n- 目的地址尽在连接建立阶段使用，分组的首部**只携带一条虚电路编号**\n- 通信方式如果再使用可靠传输的网络协议就可使所发送的分组最终正确到达接收方\n- 很多广域分组交换网都是用**面向连接的虚电路服务**，例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等\n\n### 无连接的数据报服务\n\n- 可靠通信应当由用户主机来保证\n- 不需要建立网络层连接\n- 每个分组可走不同的路径\n- 每个分组的首部必须携带目的主机的完整地址\n- 这种通信方式所传送的分组可能误码、 丢失、重复和失序。\n- 由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。\n- 因特网采用了这种设计思想，也就是**将复杂的网络处理功能置于因特网的边缘** （用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心\n\n### 虚电路服务与数据报服务的比较\n\n![虚电路服务与数据报服务的比较](https://s2.loli.net/2024/08/01/W7YLyi3OCGNPfE4.png)\n\n## IPv4地址\n\n- IPv4地址就是给因特网（Internet）上的每一台主机 （或路由器）白 的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。\n- IPv4 地址经历了以下三个历史阶段\n  - 分类编址 1981\n  - 划分子网 1985\n  - 无分类编址 1993\n\n### IPv4地址的表示方式\n\n#### 点分十进制\n\n如：192.168.0.1\n\n### 分类编址的IP地址\n\n1. IP地址分类一共为5类A,B,C,D,E类地址\n\n2. A类地址：8位网络号、24位主机号 前缀为0\n\n   ![A类地址](https://s2.loli.net/2024/08/01/yX1wCpHvDY7MQG4.png)\n\n3. B类地址：16位网络号，16位主机号 前缀为10\n\n   ![B类地址](https://s2.loli.net/2024/08/01/mGpHuiInxsK1dSh.png)\n\n4. C类地址：24位网络号，8位主机号 前缀为110\n\n   ![C类地址](https://s2.loli.net/2024/08/01/TZOaBqxonp1bhI9.png)\n\n5. D类地址：多播地址 前缀为1110\n\n   ![D类地址](https://s2.loli.net/2024/08/01/tYnxsPgz7wiQ5uU.png)\n\n6. E类地址：保留为今后使用 前缀为1111\n\n   ![E类地址](https://s2.loli.net/2024/08/01/prloD5Q6MwkfWun.png)\n\n- 只有**A类、B类和C类地址**可分配给网络中的主机或路由器的各接口\n- 主机号为“全0”的地址是**网络地址**，不能分配给主机或路由器的各接口（表示本地地址，只能作为**源地址使用**）\n- 主机号为“全1”的地址是**广播地址**，不能分配给主机或路由器的各接口（表示只在本网络上广播，各路由器均不转发，只能作为**目的地址使用**）\n\n#### A类网络\n\n- 最小网络号为0，保留不指派（表示本地地址，只能作为**源地址使用**）\n- 第一个可指派的网络号为1，网络地址为1.0.0.0\n- 最大网络号为127,作为本地环回地址，不指派\n  - 最小的环回地址为127.0.0.1\n  - 最后一个127.255.255.254\n- 最后一个可指派的网络号为126 网络地址为126.0.0.0\n\n可指派的网络号为$2^{8-1}-2=126$\n\n每个网络中可分配的IP地址的数量为$2^{24-1}-2=16777214$（减2的原因是除去主机号全为0和主机号全为1的地址）\n\n#### B类地址\n\n- 最小网络号也是第一个可指派的网络号128.0，网络地址为128.0.0.0\n- 最大网络号也是最后一个可指派的网络号191.255 网络地址为191.255.0.0\n\n可指派的网络数量为 $2^{16-2} = 16384$\n\n每个网络中可分配的IP地址的数量为$2^{16-1}-2=65534$（减2的原因是除去主机号全为0和主机号全为1的地址）\n\n#### C类地址\n\n- C类网络地址最小网络号也是第一个可指派的网络号192.0.0最小网络地址为 192.0.0.0\n- 最大网络号也是最后一个可指派的网络号223.255.255 网络地址为223.255.255.0\n\n可指派的网络数量为 $2^{24-3} = 2097152$\n\n每个网络中可分配的IP地址的数量为$2^{8-1}-2=254$（减2的原因是除去主机号全为0和主机号全为1的地址）\n\n> ![IPv4练习](https://s2.loli.net/2024/08/01/SqkYFDVNMzE43J8.png)\n>\n> ![IPv4练习2](https://s2.loli.net/2024/08/01/mJ6SGIrMyPvunXa.png)\n\n### 划分子网的IPv4地址\n\n- 为新增网络申请新的网络号会带来以下弊端：\n  - 需要等待时间和花费更多的费用\n  - 会增加其他路由器中路由表记录的数量\n  - 浪费原有网络中剩余的大量IP地址\n- 32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号\n  - 子网掩码使用连续的比特1来对应网络号和子网号\n  - 子网掩码使用连续的比特0来对应主机号\n  - 将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址\n- 默认子网掩码位数\n  - A类8位\n  - B类16位\n  - C类24位\n\n### 无分类编址的IPv4地址\n\n- 1993年，IETF发布了**无分类域间路由选择CIDR(Classless Inter-Domain Routing)**的RFC\n  文档：RFC1517~1519和1520。\n\n  - CIDR消除了传统的A类、 B类和C类地址， 以及划分子网的概念；\n  - CIDR可以更加有效地分配IPv4的地址空间， 并且可以在新的IPv6使用之前允许因特网的规模继续增长。\n\n- CIDR使用“斜线记法”，或称CIDR记法。即在IPv4地址后面加上斜线\"/\"，在斜线后面写上网络前缀所占的比特数量。\n\n  ![CIDR斜线记法](https://s2.loli.net/2024/08/01/APtvulNOwGKz2ds.png)\n\n> ![CIDR练习](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240801155624791.png)\n\n#### 路由聚合\n\n- 网络前缀越长， 地址块越小，足 路由越具体；\n- 若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配。因为这样的路由更具体。 \n- 聚合策略：找最长公共前缀\n- 表示方法：每个聚合的地址都是公共前缀的网络地址形式\n\n### IPv4地址的应用规划\n\n- 定长的子网掩码（FLSM Fixed Length Subnet Mask）\n\n  - 使用同一个子网掩码来划分子网\n  - 每个子网所分配的IP地址数量相同，造成IP地址的浪费\n\n  ![FLSM 划分示例](https://s2.loli.net/2024/08/01/RF6mUJOSD1EAl3s.png)\n\n- 变长的子网掩码（VLSM Variable Length Subnet Mask）\n\n  - 使用不同的子网掩码来划分网络\n  - 每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费\n\n  ![VLSM 划分示例](https://s2.loli.net/2024/08/01/BHMspwIxC4myrWk.png)\n\n## IP数据报的发送和转发过程\n\nIP数据报的发送和转发过程包含以下两部分：\n\n- 主机发送IP数据报\n\n  - 对跨子网的通信，需要间接交互，对任意子网主机，都需要指定默认网关执行这样的通信\n  - 如果再同一个网络则直接交付\n\n- 路由器转发IP数据报\n\n  - 检查IP数据报首部是否出错：\n\n    若出错，则直接丢弃该IP数据报并通告源主机；\n\n    若没有出错，则进行转发；\n\n  - 根据IP数据报的目的地址在路由表中查找匹配的条目\n\n    若找到匹配的条目，则转发给条目中指示的下一跳；\n\n    若找不到，则丢弃该IP数据报并通告源主机；\n\n## 路由选择协议\n\n### 静态路由选择协议\n\n- 静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表\n  - 这种人工配置方式简单、开销小。但不能及时适应网络状态 (流量、拓扑等）的变化。\n  - 一般只在小规模网络中采用。\n- 使用静态路由配置可能出现以下导致产生路由环路的错误\n  - 配置错误\n  - 聚合了不存在的网络（这样产生路由环路可能产生广播风暴）\n  - 网络故障\n- 特殊类型\n  - 以0.0.0.0/0为目标地址的默认路由\n  - 以特定主机地址为目的地址的特殊主机路由\n  - 人工配置的聚合路由\n  - 黑洞路由 下一条为null/0吞掉对应目标地址的报文 \n\n### 概述\n\n- 静态路由选择\n  - 由人工配置的网络路由、默认路由、特定主机路由，黑洞路由等都属于静态路由。\n  - 这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化\n  - 一般只在小规模网络中采用。\n- 动态路由协议\n  - 路由器通过路由选择协议自动获取路由信息。\n  - 比较复杂、开销比较大。\n  - 适用于大规模网络。\n\n因特网分层次路由选择协议\n\n- AS (Autonomous System)自治系统\n- IGP(Interior Gateway Protocol)如RIP(Routing Information Protocol)路由信息协议、OSPF(Open Shortest Path First)开放式最短路径优先\n- EGP(Exterior Gateway Protocol)如BGP(Border Gateway Protocol)边界网关协议\n\n![image-20240807193738255](https://s2.loli.net/2024/08/07/pjiNn2wF7LV1EDs.png)\n\n### 因特网所采用的路由选择协议的主要特点\n\n- 自适应：动态路由选择， 能较好地适应网络状态的变化\n- 分布式：路由器之间交换路由信息\n- 分层次：将整个因特网划分为许多较小的自治系统AS(Autonomous Sy stem)\n\n### 常见的路由选择协议\n\n- 内部网关协议\n  - RIP routing information protocol 路由信息协议：最早在因特网上使用，是一种基于距离向量的协议\n  - IGRP Interior Gateway Routing Protocol 是思科早期私有的协议，已被EIFGRP协议取代，是一种基于距离向量的协议\n  - EIGRP Enhanced Interior Gateway Routing Protocol 是思科私有，结合距离向量与链路状态的混合型路由协议\n  - OSPF Open Shortest Path First 开放式最短路径优先 在各种网络中广泛使用\n  - IS-SI Interal System to Interal System 中间系统到中间系统这是一种ISP骨干网上最常用的IGP Interal Gateway Protocol 内部网关协议\n\n![路由选择协议](https://s2.loli.net/2024/08/07/61eUuOqofScP9QK.png)\n\n### 路由器逻辑结构\n\n![路由器逻辑结构](https://s2.loli.net/2024/08/07/DCrviYOuMEJhNGx.png)\n\n- 路由表\n  - 路由表一般仅包含从目标网络到下一跳的映射\n  - 路由表需要对网络拓扑变化的计算最优化\n- 转发表\n  - 转发表是由路由表得出的\n  - 转发表的结构应当是查找过程最优化\n\n### RIP Routing Information Protocol\n\n- RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，**称为“距离向量D-V(Distance-Vector)”。**\n\n- RIP最大D-V为15，16相当于不可达，只适用于小型互联网\n- RIP认为好的路由就是D-V距离最小的路由\n- 如果有“多条距离相等”情况，可以进行等价负载均衡\n- RIP存在”坏消息传播的慢”这一缺点，又称路由环路或距离无穷计数问题，这一问题时距离向量算法的一个固有危害\n  - 解决方法为\n    1. 限制最大路由距离\n    2. 当路由表发生变化时就立即发送更新报文(**触发更新**)\n    3. 让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送(即：**水平切割**)\n\n![RIP实现方式](https://s2.loli.net/2024/08/07/KCZvYLc67bywzhO.png)\n\n> 【2016年题37】假设R1、R2、R3采用RIP协议交换路由信息，且均已收敛。若R3检测到网络201.1.2.0/25不可达，并向R2通告一次新的距离向量，则R2更新后，其到达该网络的距离是 \n>\n> A. 2 B. 3 C. 16 D. 17\n>\n> <details>\n>     【解析】B.\n>     <img src=\"https://s2.loli.net/2024/08/07/PjLR5qhJ7dbsvaH.png\" alt=\"image-20240807204500023\" />\n>     R3检测到网络201.1.2.0/25不可达，并向R2通告一次新的距离向量\n>     R2更新后，这里的题意是指，R1周期更新R2的路由表\n> </details>\n\n### OSPF Open Shortest Path First\n\n- OSPF协议是一种基于链路状态的协议\n- 采用Spfa算法进行路由计算，算法上保证不会产生环形路由\n- OPSF不限制网络规模，更新效率高，并且收敛速度快\n- 链路状态表示和哪些路由器相邻，以及相应链路的“代价”\n  - “代价” 是人为规定的，eg: 100Mbps / 链路带宽\n\n#### 工作原理\n\n- 通过“问候Hello分组”建立与维护邻居关系\n\n  ![Hello分组](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240807205258647.png)\n\n- LSA Link State Advertisement 链路状态通告\n\n  - 直连网络的链路状态信息\n  - 邻居路由器的链路状态信息\n\n- LSA被封装在链路状态更新分组LSU Link State Unit 中，采用洪泛法发送\n\n- LSDB Link Statu Data Base 链路状态分组，用于存储 LSA\n\n  - 各个路由器都有LSDB，并且最终将达到一致\n\n![OSPF的五种分组](https://s2.loli.net/2024/08/07/Tq13cHsl5XkMnJW.png)![OSPF的工作流程](https://s2.loli.net/2024/08/07/xnzZJrCasBlvcbq.png)\n\n#### OPSF特定问题的解决\n\n多点接入问题中过多状态报文的解决\n\n- 选举**指定路由器**DR Designaged router与备用的指定路由器BDR Backup designated router\n- 所有的非DR/BDR只与DR/BDR建立邻居关系\n- 非DR/BDR之间通过DR/BDR交换信息\n\n解决大网络结构的问题\n\n- 缩点成块：提出AS AutonumousSystem \n- 基于此，将路由器划分为区域内路由器IR与区域边界路由器ABR\n\n### BGP Border Gateway Protocol\n\nBGP是 外部网关协议，其对应的是在外部网关的外部网关协议EGP\n\n![BGP的度量标准问题](https://s2.loli.net/2024/08/07/FJPB5qA2zSZbg9C.png)\n\n因此，BPG无固定标准，一般只要可联通并且无环即可。\n\n- BGP发言人：AS的administer 必须选择至少一个路由器作为“BGP发言人”\n- 不同自治系统的BGP发言人要交换路由信息，首先必须**建立TCP连接，端口号为179**\n  - 此TCP连接上交换BGP报文以建立**BGP会话**\n  - 用BGP会话**交换路由信息**（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）\n  - 用TCP连接交换路由信息的两个BGP发言人，彼此称为**对方的邻站（neighbor）或对等站（peer)**\n- BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP。\n\n当BGP发言人相互交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由，即构造树形无回路的自治系统连通分量\n\nBGP-4有以下四种报文\n\n- OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化。\n- UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由。\n- KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性。\n- NOTIFICATION(通知)报文：用来发送检测到的差错。\n\n## IPv4数据报及其首部格式\n\n![IPv4首部格式——首部长度](https://s2.loli.net/2024/08/07/LuSr9CqFpQ1nKmi.png)\n\n![IPv4首部格式——区分服务](https://s2.loli.net/2024/08/07/4VvrNTH2Gg6OJ39.png)\n\n![IPv4首部格式——总长度](https://s2.loli.net/2024/08/07/5YNa6QJsLfSEhIj.png)\n\n- 总长度= 首部长度+数据载荷长度\n- 首部长度为固定长度加上可变部分的长度\n- 总长度以一个字节为一个单位，首部长度以4个字节为一个单位\n- 这里有三个特殊的部分\n  - 标识，在分帧中标识分帧的同步顺序\n  - 标志，DF,MF,保留位\n  - 片偏移：标志报文数据在数据包中的便宜位置\n\n![IPv4首部格式——TTL](https://s2.loli.net/2024/08/07/COd9UkApcxBXyb3.png)\n\n![IPv4首部格式——协议字段](https://s2.loli.net/2024/08/07/lJO8VpN4A3esRXG.png)\n\n![IPv4首部格式——首部检验和](https://s2.loli.net/2024/08/07/eRyabMc8sl3QDi4.png)\n\n### IPv4数据报的分帧\n\n对数据链路层而言，有最大传输单元MTU MAximum Transmission Unit的限制。\n\n对一个IP数据报分片的三个字段\n\n1. 标识字段\n   - 占16比特属于同一个IP数据报则具有相同表示\n   - IP软件维持一个计数器，每产生一个数据包，计数器加一并将此值赋给标识字段\n2. 标志\n   - 占3比特\n   - DF Divide Flag位：1 允许分片 0 不允许分片\n   - MF More Flag位：1 后面还有分片 0 这是最后一个分片\n   - 保留位： 必须为1\n3. 片位移\n   - 占13bit 指出分片数据包的数据载荷部分在原数据包的位置\n   - 以8个字节为单位\n\n> ![数据报分片示例](https://s2.loli.net/2024/08/07/OTlgh9X4CwWEIx5.png)\n\n## ICMP Internet Control Message Protocol\n\nICMP 网际控制报文协议\n\n- 主机或路由器使用ICMP来发送差错报告报文和询问报文\n- ICMP报文被封装在IP数据报中发送\n\n### ICMP差错报告告文\n\n1. 终点不可达\n\n2. 源点抑制\n\n   指出现拥塞，向源点发送的抑制发送速率的报文\n\n3. 时间超过\n\n   当发生TTL为0时向源点发送的时间超过报文\n\n   另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点时间超过报文\n\n4. 参数问题\n\n   首部出现误码\n\n5. 改变路由（重定向）\n\n   通知主机有更好的路由\n\n不应该发送差错报文的情况\n\n- 不会对ICMP报文发送ICMP差错报告报文\n- 对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文\n- 对具有多播地址的数据报都不发送ICMP差错报告报文\n- 对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文\n\n### ICMP询问报文\n\n- 回送请求和回答\n\n  ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。\n\n  这种询问报文用来**测试目的站是否可达及了解其有关状态**。\n\n- 时间戳请求和回答\n\n  ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。\n  在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。\n  这种询问报文用来**进行时钟同步和测量时间**。\n\n### 应用举例\n\n![分组网间探测Ping Packet InterNet Groper](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240807220717796.png)\n\n![跟踪路由 TraceRoute](https://s2.loli.net/2024/08/07/I8QajykHzx1t6JV.png)跟踪路由 TraceRoute实现原理为设置不同TTL的数据报\n\n## 虚拟网VPN 与 网络地址转换 NAT\n\n### VPN\n\n内联网VPN，外联网VPN，远程接入VPN\n\n- **内联网VPN**指同一机构的不同部门内部网络所组成的虚拟专用网\n- 外联网指有某些外部机构（通常是合作伙伴）参加进来的VPN，指**外联网VPN**\n- 通过运行软件建立隧道访问专有网络资源的行为称为远程接入VPN\n\n### NAT\n\nNAT是用于内部专用网络的专用网络用户使用少量外部全球地址来访问因特网上的主机和资源\n\n- NAT是一种缓解IPv4地址耗尽的网络地址转换技术\n\n- NAT路由器将内部地址转化为全球地址，记录专用地址与公开地址之间的对应关系\n\n- **NAPT Network Address add Port Translation**：网络地址与端口号转换技术指将端口号与IP地址一起进行转换的技术。\n\n  ![NATP转换表](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240808214140162.png)\n\n\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/网络层.md","raw":"---\ntitle: 计网篇-网络层篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# 网络层\n\n- 网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输\n\n- 功能\n\n  - 提供怎样的服务：是：“可靠传输” 还是 “不可靠传输服务” \n  - 网络层寻址问题\n  - 路由选择问题\n\n- 由于因特网是目前用户数量最多的互联网，其使用 **TCP\\IP 协议栈**\n\n- 由于TCP/IP协议栈的网络层使用**网际协议IP**，它是整个**协议栈的核心协议**，因此在TCP/IP协议栈中网络层常称为网际层。\n\n  ![TCP/IP协议栈](https://s2.loli.net/2024/08/01/WECiKvsUhFgbqBz.png)\n\n## 网络层提供的两种服务\n\n### 面向连接的虚电路服务\n\n- 可靠通信应由网络来保证\n- 必须建立网络层的连接——虚电路（VC Virtual Circuit）\n- 通信双方沿着已建立的虚电路发送分组\n- 目的地址尽在连接建立阶段使用，分组的首部**只携带一条虚电路编号**\n- 通信方式如果再使用可靠传输的网络协议就可使所发送的分组最终正确到达接收方\n- 很多广域分组交换网都是用**面向连接的虚电路服务**，例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等\n\n### 无连接的数据报服务\n\n- 可靠通信应当由用户主机来保证\n- 不需要建立网络层连接\n- 每个分组可走不同的路径\n- 每个分组的首部必须携带目的主机的完整地址\n- 这种通信方式所传送的分组可能误码、 丢失、重复和失序。\n- 由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。\n- 因特网采用了这种设计思想，也就是**将复杂的网络处理功能置于因特网的边缘** （用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心\n\n### 虚电路服务与数据报服务的比较\n\n![虚电路服务与数据报服务的比较](https://s2.loli.net/2024/08/01/W7YLyi3OCGNPfE4.png)\n\n## IPv4地址\n\n- IPv4地址就是给因特网（Internet）上的每一台主机 （或路由器）白 的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。\n- IPv4 地址经历了以下三个历史阶段\n  - 分类编址 1981\n  - 划分子网 1985\n  - 无分类编址 1993\n\n### IPv4地址的表示方式\n\n#### 点分十进制\n\n如：192.168.0.1\n\n### 分类编址的IP地址\n\n1. IP地址分类一共为5类A,B,C,D,E类地址\n\n2. A类地址：8位网络号、24位主机号 前缀为0\n\n   ![A类地址](https://s2.loli.net/2024/08/01/yX1wCpHvDY7MQG4.png)\n\n3. B类地址：16位网络号，16位主机号 前缀为10\n\n   ![B类地址](https://s2.loli.net/2024/08/01/mGpHuiInxsK1dSh.png)\n\n4. C类地址：24位网络号，8位主机号 前缀为110\n\n   ![C类地址](https://s2.loli.net/2024/08/01/TZOaBqxonp1bhI9.png)\n\n5. D类地址：多播地址 前缀为1110\n\n   ![D类地址](https://s2.loli.net/2024/08/01/tYnxsPgz7wiQ5uU.png)\n\n6. E类地址：保留为今后使用 前缀为1111\n\n   ![E类地址](https://s2.loli.net/2024/08/01/prloD5Q6MwkfWun.png)\n\n- 只有**A类、B类和C类地址**可分配给网络中的主机或路由器的各接口\n- 主机号为“全0”的地址是**网络地址**，不能分配给主机或路由器的各接口（表示本地地址，只能作为**源地址使用**）\n- 主机号为“全1”的地址是**广播地址**，不能分配给主机或路由器的各接口（表示只在本网络上广播，各路由器均不转发，只能作为**目的地址使用**）\n\n#### A类网络\n\n- 最小网络号为0，保留不指派（表示本地地址，只能作为**源地址使用**）\n- 第一个可指派的网络号为1，网络地址为1.0.0.0\n- 最大网络号为127,作为本地环回地址，不指派\n  - 最小的环回地址为127.0.0.1\n  - 最后一个127.255.255.254\n- 最后一个可指派的网络号为126 网络地址为126.0.0.0\n\n可指派的网络号为$2^{8-1}-2=126$\n\n每个网络中可分配的IP地址的数量为$2^{24-1}-2=16777214$（减2的原因是除去主机号全为0和主机号全为1的地址）\n\n#### B类地址\n\n- 最小网络号也是第一个可指派的网络号128.0，网络地址为128.0.0.0\n- 最大网络号也是最后一个可指派的网络号191.255 网络地址为191.255.0.0\n\n可指派的网络数量为 $2^{16-2} = 16384$\n\n每个网络中可分配的IP地址的数量为$2^{16-1}-2=65534$（减2的原因是除去主机号全为0和主机号全为1的地址）\n\n#### C类地址\n\n- C类网络地址最小网络号也是第一个可指派的网络号192.0.0最小网络地址为 192.0.0.0\n- 最大网络号也是最后一个可指派的网络号223.255.255 网络地址为223.255.255.0\n\n可指派的网络数量为 $2^{24-3} = 2097152$\n\n每个网络中可分配的IP地址的数量为$2^{8-1}-2=254$（减2的原因是除去主机号全为0和主机号全为1的地址）\n\n> ![IPv4练习](https://s2.loli.net/2024/08/01/SqkYFDVNMzE43J8.png)\n>\n> ![IPv4练习2](https://s2.loli.net/2024/08/01/mJ6SGIrMyPvunXa.png)\n\n### 划分子网的IPv4地址\n\n- 为新增网络申请新的网络号会带来以下弊端：\n  - 需要等待时间和花费更多的费用\n  - 会增加其他路由器中路由表记录的数量\n  - 浪费原有网络中剩余的大量IP地址\n- 32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号\n  - 子网掩码使用连续的比特1来对应网络号和子网号\n  - 子网掩码使用连续的比特0来对应主机号\n  - 将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址\n- 默认子网掩码位数\n  - A类8位\n  - B类16位\n  - C类24位\n\n### 无分类编址的IPv4地址\n\n- 1993年，IETF发布了**无分类域间路由选择CIDR(Classless Inter-Domain Routing)**的RFC\n  文档：RFC1517~1519和1520。\n\n  - CIDR消除了传统的A类、 B类和C类地址， 以及划分子网的概念；\n  - CIDR可以更加有效地分配IPv4的地址空间， 并且可以在新的IPv6使用之前允许因特网的规模继续增长。\n\n- CIDR使用“斜线记法”，或称CIDR记法。即在IPv4地址后面加上斜线\"/\"，在斜线后面写上网络前缀所占的比特数量。\n\n  ![CIDR斜线记法](https://s2.loli.net/2024/08/01/APtvulNOwGKz2ds.png)\n\n> ![CIDR练习](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240801155624791.png)\n\n#### 路由聚合\n\n- 网络前缀越长， 地址块越小，足 路由越具体；\n- 若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配。因为这样的路由更具体。 \n- 聚合策略：找最长公共前缀\n- 表示方法：每个聚合的地址都是公共前缀的网络地址形式\n\n### IPv4地址的应用规划\n\n- 定长的子网掩码（FLSM Fixed Length Subnet Mask）\n\n  - 使用同一个子网掩码来划分子网\n  - 每个子网所分配的IP地址数量相同，造成IP地址的浪费\n\n  ![FLSM 划分示例](https://s2.loli.net/2024/08/01/RF6mUJOSD1EAl3s.png)\n\n- 变长的子网掩码（VLSM Variable Length Subnet Mask）\n\n  - 使用不同的子网掩码来划分网络\n  - 每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费\n\n  ![VLSM 划分示例](https://s2.loli.net/2024/08/01/BHMspwIxC4myrWk.png)\n\n## IP数据报的发送和转发过程\n\nIP数据报的发送和转发过程包含以下两部分：\n\n- 主机发送IP数据报\n\n  - 对跨子网的通信，需要间接交互，对任意子网主机，都需要指定默认网关执行这样的通信\n  - 如果再同一个网络则直接交付\n\n- 路由器转发IP数据报\n\n  - 检查IP数据报首部是否出错：\n\n    若出错，则直接丢弃该IP数据报并通告源主机；\n\n    若没有出错，则进行转发；\n\n  - 根据IP数据报的目的地址在路由表中查找匹配的条目\n\n    若找到匹配的条目，则转发给条目中指示的下一跳；\n\n    若找不到，则丢弃该IP数据报并通告源主机；\n\n## 路由选择协议\n\n### 静态路由选择协议\n\n- 静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表\n  - 这种人工配置方式简单、开销小。但不能及时适应网络状态 (流量、拓扑等）的变化。\n  - 一般只在小规模网络中采用。\n- 使用静态路由配置可能出现以下导致产生路由环路的错误\n  - 配置错误\n  - 聚合了不存在的网络（这样产生路由环路可能产生广播风暴）\n  - 网络故障\n- 特殊类型\n  - 以0.0.0.0/0为目标地址的默认路由\n  - 以特定主机地址为目的地址的特殊主机路由\n  - 人工配置的聚合路由\n  - 黑洞路由 下一条为null/0吞掉对应目标地址的报文 \n\n### 概述\n\n- 静态路由选择\n  - 由人工配置的网络路由、默认路由、特定主机路由，黑洞路由等都属于静态路由。\n  - 这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化\n  - 一般只在小规模网络中采用。\n- 动态路由协议\n  - 路由器通过路由选择协议自动获取路由信息。\n  - 比较复杂、开销比较大。\n  - 适用于大规模网络。\n\n因特网分层次路由选择协议\n\n- AS (Autonomous System)自治系统\n- IGP(Interior Gateway Protocol)如RIP(Routing Information Protocol)路由信息协议、OSPF(Open Shortest Path First)开放式最短路径优先\n- EGP(Exterior Gateway Protocol)如BGP(Border Gateway Protocol)边界网关协议\n\n![image-20240807193738255](https://s2.loli.net/2024/08/07/pjiNn2wF7LV1EDs.png)\n\n### 因特网所采用的路由选择协议的主要特点\n\n- 自适应：动态路由选择， 能较好地适应网络状态的变化\n- 分布式：路由器之间交换路由信息\n- 分层次：将整个因特网划分为许多较小的自治系统AS(Autonomous Sy stem)\n\n### 常见的路由选择协议\n\n- 内部网关协议\n  - RIP routing information protocol 路由信息协议：最早在因特网上使用，是一种基于距离向量的协议\n  - IGRP Interior Gateway Routing Protocol 是思科早期私有的协议，已被EIFGRP协议取代，是一种基于距离向量的协议\n  - EIGRP Enhanced Interior Gateway Routing Protocol 是思科私有，结合距离向量与链路状态的混合型路由协议\n  - OSPF Open Shortest Path First 开放式最短路径优先 在各种网络中广泛使用\n  - IS-SI Interal System to Interal System 中间系统到中间系统这是一种ISP骨干网上最常用的IGP Interal Gateway Protocol 内部网关协议\n\n![路由选择协议](https://s2.loli.net/2024/08/07/61eUuOqofScP9QK.png)\n\n### 路由器逻辑结构\n\n![路由器逻辑结构](https://s2.loli.net/2024/08/07/DCrviYOuMEJhNGx.png)\n\n- 路由表\n  - 路由表一般仅包含从目标网络到下一跳的映射\n  - 路由表需要对网络拓扑变化的计算最优化\n- 转发表\n  - 转发表是由路由表得出的\n  - 转发表的结构应当是查找过程最优化\n\n### RIP Routing Information Protocol\n\n- RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，**称为“距离向量D-V(Distance-Vector)”。**\n\n- RIP最大D-V为15，16相当于不可达，只适用于小型互联网\n- RIP认为好的路由就是D-V距离最小的路由\n- 如果有“多条距离相等”情况，可以进行等价负载均衡\n- RIP存在”坏消息传播的慢”这一缺点，又称路由环路或距离无穷计数问题，这一问题时距离向量算法的一个固有危害\n  - 解决方法为\n    1. 限制最大路由距离\n    2. 当路由表发生变化时就立即发送更新报文(**触发更新**)\n    3. 让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送(即：**水平切割**)\n\n![RIP实现方式](https://s2.loli.net/2024/08/07/KCZvYLc67bywzhO.png)\n\n> 【2016年题37】假设R1、R2、R3采用RIP协议交换路由信息，且均已收敛。若R3检测到网络201.1.2.0/25不可达，并向R2通告一次新的距离向量，则R2更新后，其到达该网络的距离是 \n>\n> A. 2 B. 3 C. 16 D. 17\n>\n> <details>\n>     【解析】B.\n>     <img src=\"https://s2.loli.net/2024/08/07/PjLR5qhJ7dbsvaH.png\" alt=\"image-20240807204500023\" />\n>     R3检测到网络201.1.2.0/25不可达，并向R2通告一次新的距离向量\n>     R2更新后，这里的题意是指，R1周期更新R2的路由表\n> </details>\n\n### OSPF Open Shortest Path First\n\n- OSPF协议是一种基于链路状态的协议\n- 采用Spfa算法进行路由计算，算法上保证不会产生环形路由\n- OPSF不限制网络规模，更新效率高，并且收敛速度快\n- 链路状态表示和哪些路由器相邻，以及相应链路的“代价”\n  - “代价” 是人为规定的，eg: 100Mbps / 链路带宽\n\n#### 工作原理\n\n- 通过“问候Hello分组”建立与维护邻居关系\n\n  ![Hello分组](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240807205258647.png)\n\n- LSA Link State Advertisement 链路状态通告\n\n  - 直连网络的链路状态信息\n  - 邻居路由器的链路状态信息\n\n- LSA被封装在链路状态更新分组LSU Link State Unit 中，采用洪泛法发送\n\n- LSDB Link Statu Data Base 链路状态分组，用于存储 LSA\n\n  - 各个路由器都有LSDB，并且最终将达到一致\n\n![OSPF的五种分组](https://s2.loli.net/2024/08/07/Tq13cHsl5XkMnJW.png)![OSPF的工作流程](https://s2.loli.net/2024/08/07/xnzZJrCasBlvcbq.png)\n\n#### OPSF特定问题的解决\n\n多点接入问题中过多状态报文的解决\n\n- 选举**指定路由器**DR Designaged router与备用的指定路由器BDR Backup designated router\n- 所有的非DR/BDR只与DR/BDR建立邻居关系\n- 非DR/BDR之间通过DR/BDR交换信息\n\n解决大网络结构的问题\n\n- 缩点成块：提出AS AutonumousSystem \n- 基于此，将路由器划分为区域内路由器IR与区域边界路由器ABR\n\n### BGP Border Gateway Protocol\n\nBGP是 外部网关协议，其对应的是在外部网关的外部网关协议EGP\n\n![BGP的度量标准问题](https://s2.loli.net/2024/08/07/FJPB5qA2zSZbg9C.png)\n\n因此，BPG无固定标准，一般只要可联通并且无环即可。\n\n- BGP发言人：AS的administer 必须选择至少一个路由器作为“BGP发言人”\n- 不同自治系统的BGP发言人要交换路由信息，首先必须**建立TCP连接，端口号为179**\n  - 此TCP连接上交换BGP报文以建立**BGP会话**\n  - 用BGP会话**交换路由信息**（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）\n  - 用TCP连接交换路由信息的两个BGP发言人，彼此称为**对方的邻站（neighbor）或对等站（peer)**\n- BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP。\n\n当BGP发言人相互交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由，即构造树形无回路的自治系统连通分量\n\nBGP-4有以下四种报文\n\n- OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化。\n- UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由。\n- KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性。\n- NOTIFICATION(通知)报文：用来发送检测到的差错。\n\n## IPv4数据报及其首部格式\n\n![IPv4首部格式——首部长度](https://s2.loli.net/2024/08/07/LuSr9CqFpQ1nKmi.png)\n\n![IPv4首部格式——区分服务](https://s2.loli.net/2024/08/07/4VvrNTH2Gg6OJ39.png)\n\n![IPv4首部格式——总长度](https://s2.loli.net/2024/08/07/5YNa6QJsLfSEhIj.png)\n\n- 总长度= 首部长度+数据载荷长度\n- 首部长度为固定长度加上可变部分的长度\n- 总长度以一个字节为一个单位，首部长度以4个字节为一个单位\n- 这里有三个特殊的部分\n  - 标识，在分帧中标识分帧的同步顺序\n  - 标志，DF,MF,保留位\n  - 片偏移：标志报文数据在数据包中的便宜位置\n\n![IPv4首部格式——TTL](https://s2.loli.net/2024/08/07/COd9UkApcxBXyb3.png)\n\n![IPv4首部格式——协议字段](https://s2.loli.net/2024/08/07/lJO8VpN4A3esRXG.png)\n\n![IPv4首部格式——首部检验和](https://s2.loli.net/2024/08/07/eRyabMc8sl3QDi4.png)\n\n### IPv4数据报的分帧\n\n对数据链路层而言，有最大传输单元MTU MAximum Transmission Unit的限制。\n\n对一个IP数据报分片的三个字段\n\n1. 标识字段\n   - 占16比特属于同一个IP数据报则具有相同表示\n   - IP软件维持一个计数器，每产生一个数据包，计数器加一并将此值赋给标识字段\n2. 标志\n   - 占3比特\n   - DF Divide Flag位：1 允许分片 0 不允许分片\n   - MF More Flag位：1 后面还有分片 0 这是最后一个分片\n   - 保留位： 必须为1\n3. 片位移\n   - 占13bit 指出分片数据包的数据载荷部分在原数据包的位置\n   - 以8个字节为单位\n\n> ![数据报分片示例](https://s2.loli.net/2024/08/07/OTlgh9X4CwWEIx5.png)\n\n## ICMP Internet Control Message Protocol\n\nICMP 网际控制报文协议\n\n- 主机或路由器使用ICMP来发送差错报告报文和询问报文\n- ICMP报文被封装在IP数据报中发送\n\n### ICMP差错报告告文\n\n1. 终点不可达\n\n2. 源点抑制\n\n   指出现拥塞，向源点发送的抑制发送速率的报文\n\n3. 时间超过\n\n   当发生TTL为0时向源点发送的时间超过报文\n\n   另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点时间超过报文\n\n4. 参数问题\n\n   首部出现误码\n\n5. 改变路由（重定向）\n\n   通知主机有更好的路由\n\n不应该发送差错报文的情况\n\n- 不会对ICMP报文发送ICMP差错报告报文\n- 对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文\n- 对具有多播地址的数据报都不发送ICMP差错报告报文\n- 对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文\n\n### ICMP询问报文\n\n- 回送请求和回答\n\n  ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。\n\n  这种询问报文用来**测试目的站是否可达及了解其有关状态**。\n\n- 时间戳请求和回答\n\n  ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。\n  在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。\n  这种询问报文用来**进行时钟同步和测量时间**。\n\n### 应用举例\n\n![分组网间探测Ping Packet InterNet Groper](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240807220717796.png)\n\n![跟踪路由 TraceRoute](https://s2.loli.net/2024/08/07/I8QajykHzx1t6JV.png)跟踪路由 TraceRoute实现原理为设置不同TTL的数据报\n\n## 虚拟网VPN 与 网络地址转换 NAT\n\n### VPN\n\n内联网VPN，外联网VPN，远程接入VPN\n\n- **内联网VPN**指同一机构的不同部门内部网络所组成的虚拟专用网\n- 外联网指有某些外部机构（通常是合作伙伴）参加进来的VPN，指**外联网VPN**\n- 通过运行软件建立隧道访问专有网络资源的行为称为远程接入VPN\n\n### NAT\n\nNAT是用于内部专用网络的专用网络用户使用少量外部全球地址来访问因特网上的主机和资源\n\n- NAT是一种缓解IPv4地址耗尽的网络地址转换技术\n\n- NAT路由器将内部地址转化为全球地址，记录专用地址与公开地址之间的对应关系\n\n- **NAPT Network Address add Port Translation**：网络地址与端口号转换技术指将端口号与IP地址一起进行转换的技术。\n\n  ![NATP转换表](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240808214140162.png)\n\n\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/网络层","published":1,"updated":"2024-08-17T13:24:51.481Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqu003pm8wvd8h27zpm","content":"<h1 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h1><ul>\n<li><p>网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输</p>\n</li>\n<li><p>功能</p>\n<ul>\n<li>提供怎样的服务：是：“可靠传输” 还是 “不可靠传输服务” </li>\n<li>网络层寻址问题</li>\n<li>路由选择问题</li>\n</ul>\n</li>\n<li><p>由于因特网是目前用户数量最多的互联网，其使用 <strong>TCP\\IP 协议栈</strong></p>\n</li>\n<li><p>由于TCP/IP协议栈的网络层使用<strong>网际协议IP</strong>，它是整个<strong>协议栈的核心协议</strong>，因此在TCP/IP协议栈中网络层常称为网际层。</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/WECiKvsUhFgbqBz.png\" alt=\"TCP/IP协议栈\"></p>\n</li>\n</ul>\n<h2 id=\"网络层提供的两种服务\"><a href=\"#网络层提供的两种服务\" class=\"headerlink\" title=\"网络层提供的两种服务\"></a>网络层提供的两种服务</h2><h3 id=\"面向连接的虚电路服务\"><a href=\"#面向连接的虚电路服务\" class=\"headerlink\" title=\"面向连接的虚电路服务\"></a>面向连接的虚电路服务</h3><ul>\n<li>可靠通信应由网络来保证</li>\n<li>必须建立网络层的连接——虚电路（VC Virtual Circuit）</li>\n<li>通信双方沿着已建立的虚电路发送分组</li>\n<li>目的地址尽在连接建立阶段使用，分组的首部<strong>只携带一条虚电路编号</strong></li>\n<li>通信方式如果再使用可靠传输的网络协议就可使所发送的分组最终正确到达接收方</li>\n<li>很多广域分组交换网都是用<strong>面向连接的虚电路服务</strong>，例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等</li>\n</ul>\n<h3 id=\"无连接的数据报服务\"><a href=\"#无连接的数据报服务\" class=\"headerlink\" title=\"无连接的数据报服务\"></a>无连接的数据报服务</h3><ul>\n<li>可靠通信应当由用户主机来保证</li>\n<li>不需要建立网络层连接</li>\n<li>每个分组可走不同的路径</li>\n<li>每个分组的首部必须携带目的主机的完整地址</li>\n<li>这种通信方式所传送的分组可能误码、 丢失、重复和失序。</li>\n<li>由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li>\n<li>因特网采用了这种设计思想，也就是<strong>将复杂的网络处理功能置于因特网的边缘</strong> （用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心</li>\n</ul>\n<h3 id=\"虚电路服务与数据报服务的比较\"><a href=\"#虚电路服务与数据报服务的比较\" class=\"headerlink\" title=\"虚电路服务与数据报服务的比较\"></a>虚电路服务与数据报服务的比较</h3><p><img src=\"https://s2.loli.net/2024/08/01/W7YLyi3OCGNPfE4.png\" alt=\"虚电路服务与数据报服务的比较\"></p>\n<h2 id=\"IPv4地址\"><a href=\"#IPv4地址\" class=\"headerlink\" title=\"IPv4地址\"></a>IPv4地址</h2><ul>\n<li>IPv4地址就是给因特网（Internet）上的每一台主机 （或路由器）白 的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</li>\n<li>IPv4 地址经历了以下三个历史阶段<ul>\n<li>分类编址 1981</li>\n<li>划分子网 1985</li>\n<li>无分类编址 1993</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IPv4地址的表示方式\"><a href=\"#IPv4地址的表示方式\" class=\"headerlink\" title=\"IPv4地址的表示方式\"></a>IPv4地址的表示方式</h3><h4 id=\"点分十进制\"><a href=\"#点分十进制\" class=\"headerlink\" title=\"点分十进制\"></a>点分十进制</h4><p>如：192.168.0.1</p>\n<h3 id=\"分类编址的IP地址\"><a href=\"#分类编址的IP地址\" class=\"headerlink\" title=\"分类编址的IP地址\"></a>分类编址的IP地址</h3><ol>\n<li><p>IP地址分类一共为5类A,B,C,D,E类地址</p>\n</li>\n<li><p>A类地址：8位网络号、24位主机号 前缀为0</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/yX1wCpHvDY7MQG4.png\" alt=\"A类地址\"></p>\n</li>\n<li><p>B类地址：16位网络号，16位主机号 前缀为10</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/mGpHuiInxsK1dSh.png\" alt=\"B类地址\"></p>\n</li>\n<li><p>C类地址：24位网络号，8位主机号 前缀为110</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/TZOaBqxonp1bhI9.png\" alt=\"C类地址\"></p>\n</li>\n<li><p>D类地址：多播地址 前缀为1110</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/tYnxsPgz7wiQ5uU.png\" alt=\"D类地址\"></p>\n</li>\n<li><p>E类地址：保留为今后使用 前缀为1111</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/prloD5Q6MwkfWun.png\" alt=\"E类地址\"></p>\n</li>\n</ol>\n<ul>\n<li>只有<strong>A类、B类和C类地址</strong>可分配给网络中的主机或路由器的各接口</li>\n<li>主机号为“全0”的地址是<strong>网络地址</strong>，不能分配给主机或路由器的各接口（表示本地地址，只能作为<strong>源地址使用</strong>）</li>\n<li>主机号为“全1”的地址是<strong>广播地址</strong>，不能分配给主机或路由器的各接口（表示只在本网络上广播，各路由器均不转发，只能作为<strong>目的地址使用</strong>）</li>\n</ul>\n<h4 id=\"A类网络\"><a href=\"#A类网络\" class=\"headerlink\" title=\"A类网络\"></a>A类网络</h4><ul>\n<li>最小网络号为0，保留不指派（表示本地地址，只能作为<strong>源地址使用</strong>）</li>\n<li>第一个可指派的网络号为1，网络地址为1.0.0.0</li>\n<li>最大网络号为127,作为本地环回地址，不指派<ul>\n<li>最小的环回地址为127.0.0.1</li>\n<li>最后一个127.255.255.254</li>\n</ul>\n</li>\n<li>最后一个可指派的网络号为126 网络地址为126.0.0.0</li>\n</ul>\n<p>可指派的网络号为$2^{8-1}-2=126$</p>\n<p>每个网络中可分配的IP地址的数量为$2^{24-1}-2=16777214$（减2的原因是除去主机号全为0和主机号全为1的地址）</p>\n<h4 id=\"B类地址\"><a href=\"#B类地址\" class=\"headerlink\" title=\"B类地址\"></a>B类地址</h4><ul>\n<li>最小网络号也是第一个可指派的网络号128.0，网络地址为128.0.0.0</li>\n<li>最大网络号也是最后一个可指派的网络号191.255 网络地址为191.255.0.0</li>\n</ul>\n<p>可指派的网络数量为 $2^{16-2} = 16384$</p>\n<p>每个网络中可分配的IP地址的数量为$2^{16-1}-2=65534$（减2的原因是除去主机号全为0和主机号全为1的地址）</p>\n<h4 id=\"C类地址\"><a href=\"#C类地址\" class=\"headerlink\" title=\"C类地址\"></a>C类地址</h4><ul>\n<li>C类网络地址最小网络号也是第一个可指派的网络号192.0.0最小网络地址为 192.0.0.0</li>\n<li>最大网络号也是最后一个可指派的网络号223.255.255 网络地址为223.255.255.0</li>\n</ul>\n<p>可指派的网络数量为 $2^{24-3} = 2097152$</p>\n<p>每个网络中可分配的IP地址的数量为$2^{8-1}-2=254$（减2的原因是除去主机号全为0和主机号全为1的地址）</p>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/08/01/SqkYFDVNMzE43J8.png\" alt=\"IPv4练习\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/01/mJ6SGIrMyPvunXa.png\" alt=\"IPv4练习2\"></p>\n</blockquote>\n<h3 id=\"划分子网的IPv4地址\"><a href=\"#划分子网的IPv4地址\" class=\"headerlink\" title=\"划分子网的IPv4地址\"></a>划分子网的IPv4地址</h3><ul>\n<li>为新增网络申请新的网络号会带来以下弊端：<ul>\n<li>需要等待时间和花费更多的费用</li>\n<li>会增加其他路由器中路由表记录的数量</li>\n<li>浪费原有网络中剩余的大量IP地址</li>\n</ul>\n</li>\n<li>32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号<ul>\n<li>子网掩码使用连续的比特1来对应网络号和子网号</li>\n<li>子网掩码使用连续的比特0来对应主机号</li>\n<li>将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址</li>\n</ul>\n</li>\n<li>默认子网掩码位数<ul>\n<li>A类8位</li>\n<li>B类16位</li>\n<li>C类24位</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"无分类编址的IPv4地址\"><a href=\"#无分类编址的IPv4地址\" class=\"headerlink\" title=\"无分类编址的IPv4地址\"></a>无分类编址的IPv4地址</h3><ul>\n<li><p>1993年，IETF发布了<strong>无分类域间路由选择CIDR(Classless Inter-Domain Routing)</strong>的RFC<br>文档：RFC1517~1519和1520。</p>\n<ul>\n<li>CIDR消除了传统的A类、 B类和C类地址， 以及划分子网的概念；</li>\n<li>CIDR可以更加有效地分配IPv4的地址空间， 并且可以在新的IPv6使用之前允许因特网的规模继续增长。</li>\n</ul>\n</li>\n<li><p>CIDR使用“斜线记法”，或称CIDR记法。即在IPv4地址后面加上斜线”/“，在斜线后面写上网络前缀所占的比特数量。</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/APtvulNOwGKz2ds.png\" alt=\"CIDR斜线记法\"></p>\n</li>\n</ul>\n<blockquote>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240801155624791.png\" alt=\"CIDR练习\"></p>\n</blockquote>\n<h4 id=\"路由聚合\"><a href=\"#路由聚合\" class=\"headerlink\" title=\"路由聚合\"></a>路由聚合</h4><ul>\n<li>网络前缀越长， 地址块越小，足 路由越具体；</li>\n<li>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配。因为这样的路由更具体。 </li>\n<li>聚合策略：找最长公共前缀</li>\n<li>表示方法：每个聚合的地址都是公共前缀的网络地址形式</li>\n</ul>\n<h3 id=\"IPv4地址的应用规划\"><a href=\"#IPv4地址的应用规划\" class=\"headerlink\" title=\"IPv4地址的应用规划\"></a>IPv4地址的应用规划</h3><ul>\n<li><p>定长的子网掩码（FLSM Fixed Length Subnet Mask）</p>\n<ul>\n<li>使用同一个子网掩码来划分子网</li>\n<li>每个子网所分配的IP地址数量相同，造成IP地址的浪费</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/01/RF6mUJOSD1EAl3s.png\" alt=\"FLSM 划分示例\"></p>\n</li>\n<li><p>变长的子网掩码（VLSM Variable Length Subnet Mask）</p>\n<ul>\n<li>使用不同的子网掩码来划分网络</li>\n<li>每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/01/BHMspwIxC4myrWk.png\" alt=\"VLSM 划分示例\"></p>\n</li>\n</ul>\n<h2 id=\"IP数据报的发送和转发过程\"><a href=\"#IP数据报的发送和转发过程\" class=\"headerlink\" title=\"IP数据报的发送和转发过程\"></a>IP数据报的发送和转发过程</h2><p>IP数据报的发送和转发过程包含以下两部分：</p>\n<ul>\n<li><p>主机发送IP数据报</p>\n<ul>\n<li>对跨子网的通信，需要间接交互，对任意子网主机，都需要指定默认网关执行这样的通信</li>\n<li>如果再同一个网络则直接交付</li>\n</ul>\n</li>\n<li><p>路由器转发IP数据报</p>\n<ul>\n<li><p>检查IP数据报首部是否出错：</p>\n<p>若出错，则直接丢弃该IP数据报并通告源主机；</p>\n<p>若没有出错，则进行转发；</p>\n</li>\n<li><p>根据IP数据报的目的地址在路由表中查找匹配的条目</p>\n<p>若找到匹配的条目，则转发给条目中指示的下一跳；</p>\n<p>若找不到，则丢弃该IP数据报并通告源主机；</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"路由选择协议\"><a href=\"#路由选择协议\" class=\"headerlink\" title=\"路由选择协议\"></a>路由选择协议</h2><h3 id=\"静态路由选择协议\"><a href=\"#静态路由选择协议\" class=\"headerlink\" title=\"静态路由选择协议\"></a>静态路由选择协议</h3><ul>\n<li>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表<ul>\n<li>这种人工配置方式简单、开销小。但不能及时适应网络状态 (流量、拓扑等）的变化。</li>\n<li>一般只在小规模网络中采用。</li>\n</ul>\n</li>\n<li>使用静态路由配置可能出现以下导致产生路由环路的错误<ul>\n<li>配置错误</li>\n<li>聚合了不存在的网络（这样产生路由环路可能产生广播风暴）</li>\n<li>网络故障</li>\n</ul>\n</li>\n<li>特殊类型<ul>\n<li>以0.0.0.0/0为目标地址的默认路由</li>\n<li>以特定主机地址为目的地址的特殊主机路由</li>\n<li>人工配置的聚合路由</li>\n<li>黑洞路由 下一条为null/0吞掉对应目标地址的报文 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ul>\n<li>静态路由选择<ul>\n<li>由人工配置的网络路由、默认路由、特定主机路由，黑洞路由等都属于静态路由。</li>\n<li>这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化</li>\n<li>一般只在小规模网络中采用。</li>\n</ul>\n</li>\n<li>动态路由协议<ul>\n<li>路由器通过路由选择协议自动获取路由信息。</li>\n<li>比较复杂、开销比较大。</li>\n<li>适用于大规模网络。</li>\n</ul>\n</li>\n</ul>\n<p>因特网分层次路由选择协议</p>\n<ul>\n<li>AS (Autonomous System)自治系统</li>\n<li>IGP(Interior Gateway Protocol)如RIP(Routing Information Protocol)路由信息协议、OSPF(Open Shortest Path First)开放式最短路径优先</li>\n<li>EGP(Exterior Gateway Protocol)如BGP(Border Gateway Protocol)边界网关协议</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/07/pjiNn2wF7LV1EDs.png\" alt=\"image-20240807193738255\"></p>\n<h3 id=\"因特网所采用的路由选择协议的主要特点\"><a href=\"#因特网所采用的路由选择协议的主要特点\" class=\"headerlink\" title=\"因特网所采用的路由选择协议的主要特点\"></a>因特网所采用的路由选择协议的主要特点</h3><ul>\n<li>自适应：动态路由选择， 能较好地适应网络状态的变化</li>\n<li>分布式：路由器之间交换路由信息</li>\n<li>分层次：将整个因特网划分为许多较小的自治系统AS(Autonomous Sy stem)</li>\n</ul>\n<h3 id=\"常见的路由选择协议\"><a href=\"#常见的路由选择协议\" class=\"headerlink\" title=\"常见的路由选择协议\"></a>常见的路由选择协议</h3><ul>\n<li>内部网关协议<ul>\n<li>RIP routing information protocol 路由信息协议：最早在因特网上使用，是一种基于距离向量的协议</li>\n<li>IGRP Interior Gateway Routing Protocol 是思科早期私有的协议，已被EIFGRP协议取代，是一种基于距离向量的协议</li>\n<li>EIGRP Enhanced Interior Gateway Routing Protocol 是思科私有，结合距离向量与链路状态的混合型路由协议</li>\n<li>OSPF Open Shortest Path First 开放式最短路径优先 在各种网络中广泛使用</li>\n<li>IS-SI Interal System to Interal System 中间系统到中间系统这是一种ISP骨干网上最常用的IGP Interal Gateway Protocol 内部网关协议</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/07/61eUuOqofScP9QK.png\" alt=\"路由选择协议\"></p>\n<h3 id=\"路由器逻辑结构\"><a href=\"#路由器逻辑结构\" class=\"headerlink\" title=\"路由器逻辑结构\"></a>路由器逻辑结构</h3><p><img src=\"https://s2.loli.net/2024/08/07/DCrviYOuMEJhNGx.png\" alt=\"路由器逻辑结构\"></p>\n<ul>\n<li>路由表<ul>\n<li>路由表一般仅包含从目标网络到下一跳的映射</li>\n<li>路由表需要对网络拓扑变化的计算最优化</li>\n</ul>\n</li>\n<li>转发表<ul>\n<li>转发表是由路由表得出的</li>\n<li>转发表的结构应当是查找过程最优化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RIP-Routing-Information-Protocol\"><a href=\"#RIP-Routing-Information-Protocol\" class=\"headerlink\" title=\"RIP Routing Information Protocol\"></a>RIP Routing Information Protocol</h3><ul>\n<li><p>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，<strong>称为“距离向量D-V(Distance-Vector)”。</strong></p>\n</li>\n<li><p>RIP最大D-V为15，16相当于不可达，只适用于小型互联网</p>\n</li>\n<li>RIP认为好的路由就是D-V距离最小的路由</li>\n<li>如果有“多条距离相等”情况，可以进行等价负载均衡</li>\n<li>RIP存在”坏消息传播的慢”这一缺点，又称路由环路或距离无穷计数问题，这一问题时距离向量算法的一个固有危害<ul>\n<li>解决方法为<ol>\n<li>限制最大路由距离</li>\n<li>当路由表发生变化时就立即发送更新报文(<strong>触发更新</strong>)</li>\n<li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送(即：<strong>水平切割</strong>)</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/07/KCZvYLc67bywzhO.png\" alt=\"RIP实现方式\"></p>\n<blockquote>\n<p>【2016年题37】假设R1、R2、R3采用RIP协议交换路由信息，且均已收敛。若R3检测到网络201.1.2.0/25不可达，并向R2通告一次新的距离向量，则R2更新后，其到达该网络的距离是 </p>\n<p>A. 2 B. 3 C. 16 D. 17</p>\n<details>\n    【解析】B.\n    <img src=\"https://s2.loli.net/2024/08/07/PjLR5qhJ7dbsvaH.png\" alt=\"image-20240807204500023\" />\n    R3检测到网络201.1.2.0/25不可达，并向R2通告一次新的距离向量\n    R2更新后，这里的题意是指，R1周期更新R2的路由表\n</details>\n\n</blockquote>\n<h3 id=\"OSPF-Open-Shortest-Path-First\"><a href=\"#OSPF-Open-Shortest-Path-First\" class=\"headerlink\" title=\"OSPF Open Shortest Path First\"></a>OSPF Open Shortest Path First</h3><ul>\n<li>OSPF协议是一种基于链路状态的协议</li>\n<li>采用Spfa算法进行路由计算，算法上保证不会产生环形路由</li>\n<li>OPSF不限制网络规模，更新效率高，并且收敛速度快</li>\n<li>链路状态表示和哪些路由器相邻，以及相应链路的“代价”<ul>\n<li>“代价” 是人为规定的，eg: 100Mbps / 链路带宽</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><ul>\n<li><p>通过“问候Hello分组”建立与维护邻居关系</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240807205258647.png\" alt=\"Hello分组\"></p>\n</li>\n<li><p>LSA Link State Advertisement 链路状态通告</p>\n<ul>\n<li>直连网络的链路状态信息</li>\n<li>邻居路由器的链路状态信息</li>\n</ul>\n</li>\n<li><p>LSA被封装在链路状态更新分组LSU Link State Unit 中，采用洪泛法发送</p>\n</li>\n<li><p>LSDB Link Statu Data Base 链路状态分组，用于存储 LSA</p>\n<ul>\n<li>各个路由器都有LSDB，并且最终将达到一致</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/07/Tq13cHsl5XkMnJW.png\" alt=\"OSPF的五种分组\"><img src=\"https://s2.loli.net/2024/08/07/xnzZJrCasBlvcbq.png\" alt=\"OSPF的工作流程\"></p>\n<h4 id=\"OPSF特定问题的解决\"><a href=\"#OPSF特定问题的解决\" class=\"headerlink\" title=\"OPSF特定问题的解决\"></a>OPSF特定问题的解决</h4><p>多点接入问题中过多状态报文的解决</p>\n<ul>\n<li>选举<strong>指定路由器</strong>DR Designaged router与备用的指定路由器BDR Backup designated router</li>\n<li>所有的非DR/BDR只与DR/BDR建立邻居关系</li>\n<li>非DR/BDR之间通过DR/BDR交换信息</li>\n</ul>\n<p>解决大网络结构的问题</p>\n<ul>\n<li>缩点成块：提出AS AutonumousSystem </li>\n<li>基于此，将路由器划分为区域内路由器IR与区域边界路由器ABR</li>\n</ul>\n<h3 id=\"BGP-Border-Gateway-Protocol\"><a href=\"#BGP-Border-Gateway-Protocol\" class=\"headerlink\" title=\"BGP Border Gateway Protocol\"></a>BGP Border Gateway Protocol</h3><p>BGP是 外部网关协议，其对应的是在外部网关的外部网关协议EGP</p>\n<p><img src=\"https://s2.loli.net/2024/08/07/FJPB5qA2zSZbg9C.png\" alt=\"BGP的度量标准问题\"></p>\n<p>因此，BPG无固定标准，一般只要可联通并且无环即可。</p>\n<ul>\n<li>BGP发言人：AS的administer 必须选择至少一个路由器作为“BGP发言人”</li>\n<li>不同自治系统的BGP发言人要交换路由信息，首先必须<strong>建立TCP连接，端口号为179</strong><ul>\n<li>此TCP连接上交换BGP报文以建立<strong>BGP会话</strong></li>\n<li>用BGP会话<strong>交换路由信息</strong>（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）</li>\n<li>用TCP连接交换路由信息的两个BGP发言人，彼此称为<strong>对方的邻站（neighbor）或对等站（peer)</strong></li>\n</ul>\n</li>\n<li>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP。</li>\n</ul>\n<p>当BGP发言人相互交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由，即构造树形无回路的自治系统连通分量</p>\n<p>BGP-4有以下四种报文</p>\n<ul>\n<li>OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化。</li>\n<li>UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由。</li>\n<li>KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性。</li>\n<li>NOTIFICATION(通知)报文：用来发送检测到的差错。</li>\n</ul>\n<h2 id=\"IPv4数据报及其首部格式\"><a href=\"#IPv4数据报及其首部格式\" class=\"headerlink\" title=\"IPv4数据报及其首部格式\"></a>IPv4数据报及其首部格式</h2><p><img src=\"https://s2.loli.net/2024/08/07/LuSr9CqFpQ1nKmi.png\" alt=\"IPv4首部格式——首部长度\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/07/4VvrNTH2Gg6OJ39.png\" alt=\"IPv4首部格式——区分服务\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/07/5YNa6QJsLfSEhIj.png\" alt=\"IPv4首部格式——总长度\"></p>\n<ul>\n<li>总长度= 首部长度+数据载荷长度</li>\n<li>首部长度为固定长度加上可变部分的长度</li>\n<li>总长度以一个字节为一个单位，首部长度以4个字节为一个单位</li>\n<li>这里有三个特殊的部分<ul>\n<li>标识，在分帧中标识分帧的同步顺序</li>\n<li>标志，DF,MF,保留位</li>\n<li>片偏移：标志报文数据在数据包中的便宜位置</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/07/COd9UkApcxBXyb3.png\" alt=\"IPv4首部格式——TTL\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/07/lJO8VpN4A3esRXG.png\" alt=\"IPv4首部格式——协议字段\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/07/eRyabMc8sl3QDi4.png\" alt=\"IPv4首部格式——首部检验和\"></p>\n<h3 id=\"IPv4数据报的分帧\"><a href=\"#IPv4数据报的分帧\" class=\"headerlink\" title=\"IPv4数据报的分帧\"></a>IPv4数据报的分帧</h3><p>对数据链路层而言，有最大传输单元MTU MAximum Transmission Unit的限制。</p>\n<p>对一个IP数据报分片的三个字段</p>\n<ol>\n<li>标识字段<ul>\n<li>占16比特属于同一个IP数据报则具有相同表示</li>\n<li>IP软件维持一个计数器，每产生一个数据包，计数器加一并将此值赋给标识字段</li>\n</ul>\n</li>\n<li>标志<ul>\n<li>占3比特</li>\n<li>DF Divide Flag位：1 允许分片 0 不允许分片</li>\n<li>MF More Flag位：1 后面还有分片 0 这是最后一个分片</li>\n<li>保留位： 必须为1</li>\n</ul>\n</li>\n<li>片位移<ul>\n<li>占13bit 指出分片数据包的数据载荷部分在原数据包的位置</li>\n<li>以8个字节为单位</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/08/07/OTlgh9X4CwWEIx5.png\" alt=\"数据报分片示例\"></p>\n</blockquote>\n<h2 id=\"ICMP-Internet-Control-Message-Protocol\"><a href=\"#ICMP-Internet-Control-Message-Protocol\" class=\"headerlink\" title=\"ICMP Internet Control Message Protocol\"></a>ICMP Internet Control Message Protocol</h2><p>ICMP 网际控制报文协议</p>\n<ul>\n<li>主机或路由器使用ICMP来发送差错报告报文和询问报文</li>\n<li>ICMP报文被封装在IP数据报中发送</li>\n</ul>\n<h3 id=\"ICMP差错报告告文\"><a href=\"#ICMP差错报告告文\" class=\"headerlink\" title=\"ICMP差错报告告文\"></a>ICMP差错报告告文</h3><ol>\n<li><p>终点不可达</p>\n</li>\n<li><p>源点抑制</p>\n<p>指出现拥塞，向源点发送的抑制发送速率的报文</p>\n</li>\n<li><p>时间超过</p>\n<p>当发生TTL为0时向源点发送的时间超过报文</p>\n<p>另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点时间超过报文</p>\n</li>\n<li><p>参数问题</p>\n<p>首部出现误码</p>\n</li>\n<li><p>改变路由（重定向）</p>\n<p>通知主机有更好的路由</p>\n</li>\n</ol>\n<p>不应该发送差错报文的情况</p>\n<ul>\n<li>不会对ICMP报文发送ICMP差错报告报文</li>\n<li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li>\n<li>对具有多播地址的数据报都不发送ICMP差错报告报文</li>\n<li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</li>\n</ul>\n<h3 id=\"ICMP询问报文\"><a href=\"#ICMP询问报文\" class=\"headerlink\" title=\"ICMP询问报文\"></a>ICMP询问报文</h3><ul>\n<li><p>回送请求和回答</p>\n<p>ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。</p>\n<p>这种询问报文用来<strong>测试目的站是否可达及了解其有关状态</strong>。</p>\n</li>\n<li><p>时间戳请求和回答</p>\n<p>ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。<br>在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。<br>这种询问报文用来<strong>进行时钟同步和测量时间</strong>。</p>\n</li>\n</ul>\n<h3 id=\"应用举例\"><a href=\"#应用举例\" class=\"headerlink\" title=\"应用举例\"></a>应用举例</h3><p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240807220717796.png\" alt=\"分组网间探测Ping Packet InterNet Groper\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/07/I8QajykHzx1t6JV.png\" alt=\"跟踪路由 TraceRoute\">跟踪路由 TraceRoute实现原理为设置不同TTL的数据报</p>\n<h2 id=\"虚拟网VPN-与-网络地址转换-NAT\"><a href=\"#虚拟网VPN-与-网络地址转换-NAT\" class=\"headerlink\" title=\"虚拟网VPN 与 网络地址转换 NAT\"></a>虚拟网VPN 与 网络地址转换 NAT</h2><h3 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h3><p>内联网VPN，外联网VPN，远程接入VPN</p>\n<ul>\n<li><strong>内联网VPN</strong>指同一机构的不同部门内部网络所组成的虚拟专用网</li>\n<li>外联网指有某些外部机构（通常是合作伙伴）参加进来的VPN，指<strong>外联网VPN</strong></li>\n<li>通过运行软件建立隧道访问专有网络资源的行为称为远程接入VPN</li>\n</ul>\n<h3 id=\"NAT\"><a href=\"#NAT\" class=\"headerlink\" title=\"NAT\"></a>NAT</h3><p>NAT是用于内部专用网络的专用网络用户使用少量外部全球地址来访问因特网上的主机和资源</p>\n<ul>\n<li><p>NAT是一种缓解IPv4地址耗尽的网络地址转换技术</p>\n</li>\n<li><p>NAT路由器将内部地址转化为全球地址，记录专用地址与公开地址之间的对应关系</p>\n</li>\n<li><p><strong>NAPT Network Address add Port Translation</strong>：网络地址与端口号转换技术指将端口号与IP地址一起进行转换的技术。</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240808214140162.png\" alt=\"NATP转换表\"></p>\n</li>\n</ul>\n<!-- flag of hidden posts -->","length":5154,"excerpt":"","more":"<h1 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h1><ul>\n<li><p>网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输</p>\n</li>\n<li><p>功能</p>\n<ul>\n<li>提供怎样的服务：是：“可靠传输” 还是 “不可靠传输服务” </li>\n<li>网络层寻址问题</li>\n<li>路由选择问题</li>\n</ul>\n</li>\n<li><p>由于因特网是目前用户数量最多的互联网，其使用 <strong>TCP\\IP 协议栈</strong></p>\n</li>\n<li><p>由于TCP/IP协议栈的网络层使用<strong>网际协议IP</strong>，它是整个<strong>协议栈的核心协议</strong>，因此在TCP/IP协议栈中网络层常称为网际层。</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/WECiKvsUhFgbqBz.png\" alt=\"TCP/IP协议栈\"></p>\n</li>\n</ul>\n<h2 id=\"网络层提供的两种服务\"><a href=\"#网络层提供的两种服务\" class=\"headerlink\" title=\"网络层提供的两种服务\"></a>网络层提供的两种服务</h2><h3 id=\"面向连接的虚电路服务\"><a href=\"#面向连接的虚电路服务\" class=\"headerlink\" title=\"面向连接的虚电路服务\"></a>面向连接的虚电路服务</h3><ul>\n<li>可靠通信应由网络来保证</li>\n<li>必须建立网络层的连接——虚电路（VC Virtual Circuit）</li>\n<li>通信双方沿着已建立的虚电路发送分组</li>\n<li>目的地址尽在连接建立阶段使用，分组的首部<strong>只携带一条虚电路编号</strong></li>\n<li>通信方式如果再使用可靠传输的网络协议就可使所发送的分组最终正确到达接收方</li>\n<li>很多广域分组交换网都是用<strong>面向连接的虚电路服务</strong>，例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等</li>\n</ul>\n<h3 id=\"无连接的数据报服务\"><a href=\"#无连接的数据报服务\" class=\"headerlink\" title=\"无连接的数据报服务\"></a>无连接的数据报服务</h3><ul>\n<li>可靠通信应当由用户主机来保证</li>\n<li>不需要建立网络层连接</li>\n<li>每个分组可走不同的路径</li>\n<li>每个分组的首部必须携带目的主机的完整地址</li>\n<li>这种通信方式所传送的分组可能误码、 丢失、重复和失序。</li>\n<li>由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li>\n<li>因特网采用了这种设计思想，也就是<strong>将复杂的网络处理功能置于因特网的边缘</strong> （用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心</li>\n</ul>\n<h3 id=\"虚电路服务与数据报服务的比较\"><a href=\"#虚电路服务与数据报服务的比较\" class=\"headerlink\" title=\"虚电路服务与数据报服务的比较\"></a>虚电路服务与数据报服务的比较</h3><p><img src=\"https://s2.loli.net/2024/08/01/W7YLyi3OCGNPfE4.png\" alt=\"虚电路服务与数据报服务的比较\"></p>\n<h2 id=\"IPv4地址\"><a href=\"#IPv4地址\" class=\"headerlink\" title=\"IPv4地址\"></a>IPv4地址</h2><ul>\n<li>IPv4地址就是给因特网（Internet）上的每一台主机 （或路由器）白 的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</li>\n<li>IPv4 地址经历了以下三个历史阶段<ul>\n<li>分类编址 1981</li>\n<li>划分子网 1985</li>\n<li>无分类编址 1993</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IPv4地址的表示方式\"><a href=\"#IPv4地址的表示方式\" class=\"headerlink\" title=\"IPv4地址的表示方式\"></a>IPv4地址的表示方式</h3><h4 id=\"点分十进制\"><a href=\"#点分十进制\" class=\"headerlink\" title=\"点分十进制\"></a>点分十进制</h4><p>如：192.168.0.1</p>\n<h3 id=\"分类编址的IP地址\"><a href=\"#分类编址的IP地址\" class=\"headerlink\" title=\"分类编址的IP地址\"></a>分类编址的IP地址</h3><ol>\n<li><p>IP地址分类一共为5类A,B,C,D,E类地址</p>\n</li>\n<li><p>A类地址：8位网络号、24位主机号 前缀为0</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/yX1wCpHvDY7MQG4.png\" alt=\"A类地址\"></p>\n</li>\n<li><p>B类地址：16位网络号，16位主机号 前缀为10</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/mGpHuiInxsK1dSh.png\" alt=\"B类地址\"></p>\n</li>\n<li><p>C类地址：24位网络号，8位主机号 前缀为110</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/TZOaBqxonp1bhI9.png\" alt=\"C类地址\"></p>\n</li>\n<li><p>D类地址：多播地址 前缀为1110</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/tYnxsPgz7wiQ5uU.png\" alt=\"D类地址\"></p>\n</li>\n<li><p>E类地址：保留为今后使用 前缀为1111</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/prloD5Q6MwkfWun.png\" alt=\"E类地址\"></p>\n</li>\n</ol>\n<ul>\n<li>只有<strong>A类、B类和C类地址</strong>可分配给网络中的主机或路由器的各接口</li>\n<li>主机号为“全0”的地址是<strong>网络地址</strong>，不能分配给主机或路由器的各接口（表示本地地址，只能作为<strong>源地址使用</strong>）</li>\n<li>主机号为“全1”的地址是<strong>广播地址</strong>，不能分配给主机或路由器的各接口（表示只在本网络上广播，各路由器均不转发，只能作为<strong>目的地址使用</strong>）</li>\n</ul>\n<h4 id=\"A类网络\"><a href=\"#A类网络\" class=\"headerlink\" title=\"A类网络\"></a>A类网络</h4><ul>\n<li>最小网络号为0，保留不指派（表示本地地址，只能作为<strong>源地址使用</strong>）</li>\n<li>第一个可指派的网络号为1，网络地址为1.0.0.0</li>\n<li>最大网络号为127,作为本地环回地址，不指派<ul>\n<li>最小的环回地址为127.0.0.1</li>\n<li>最后一个127.255.255.254</li>\n</ul>\n</li>\n<li>最后一个可指派的网络号为126 网络地址为126.0.0.0</li>\n</ul>\n<p>可指派的网络号为$2^{8-1}-2=126$</p>\n<p>每个网络中可分配的IP地址的数量为$2^{24-1}-2=16777214$（减2的原因是除去主机号全为0和主机号全为1的地址）</p>\n<h4 id=\"B类地址\"><a href=\"#B类地址\" class=\"headerlink\" title=\"B类地址\"></a>B类地址</h4><ul>\n<li>最小网络号也是第一个可指派的网络号128.0，网络地址为128.0.0.0</li>\n<li>最大网络号也是最后一个可指派的网络号191.255 网络地址为191.255.0.0</li>\n</ul>\n<p>可指派的网络数量为 $2^{16-2} = 16384$</p>\n<p>每个网络中可分配的IP地址的数量为$2^{16-1}-2=65534$（减2的原因是除去主机号全为0和主机号全为1的地址）</p>\n<h4 id=\"C类地址\"><a href=\"#C类地址\" class=\"headerlink\" title=\"C类地址\"></a>C类地址</h4><ul>\n<li>C类网络地址最小网络号也是第一个可指派的网络号192.0.0最小网络地址为 192.0.0.0</li>\n<li>最大网络号也是最后一个可指派的网络号223.255.255 网络地址为223.255.255.0</li>\n</ul>\n<p>可指派的网络数量为 $2^{24-3} = 2097152$</p>\n<p>每个网络中可分配的IP地址的数量为$2^{8-1}-2=254$（减2的原因是除去主机号全为0和主机号全为1的地址）</p>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/08/01/SqkYFDVNMzE43J8.png\" alt=\"IPv4练习\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/01/mJ6SGIrMyPvunXa.png\" alt=\"IPv4练习2\"></p>\n</blockquote>\n<h3 id=\"划分子网的IPv4地址\"><a href=\"#划分子网的IPv4地址\" class=\"headerlink\" title=\"划分子网的IPv4地址\"></a>划分子网的IPv4地址</h3><ul>\n<li>为新增网络申请新的网络号会带来以下弊端：<ul>\n<li>需要等待时间和花费更多的费用</li>\n<li>会增加其他路由器中路由表记录的数量</li>\n<li>浪费原有网络中剩余的大量IP地址</li>\n</ul>\n</li>\n<li>32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号<ul>\n<li>子网掩码使用连续的比特1来对应网络号和子网号</li>\n<li>子网掩码使用连续的比特0来对应主机号</li>\n<li>将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址</li>\n</ul>\n</li>\n<li>默认子网掩码位数<ul>\n<li>A类8位</li>\n<li>B类16位</li>\n<li>C类24位</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"无分类编址的IPv4地址\"><a href=\"#无分类编址的IPv4地址\" class=\"headerlink\" title=\"无分类编址的IPv4地址\"></a>无分类编址的IPv4地址</h3><ul>\n<li><p>1993年，IETF发布了<strong>无分类域间路由选择CIDR(Classless Inter-Domain Routing)</strong>的RFC<br>文档：RFC1517~1519和1520。</p>\n<ul>\n<li>CIDR消除了传统的A类、 B类和C类地址， 以及划分子网的概念；</li>\n<li>CIDR可以更加有效地分配IPv4的地址空间， 并且可以在新的IPv6使用之前允许因特网的规模继续增长。</li>\n</ul>\n</li>\n<li><p>CIDR使用“斜线记法”，或称CIDR记法。即在IPv4地址后面加上斜线”/“，在斜线后面写上网络前缀所占的比特数量。</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/APtvulNOwGKz2ds.png\" alt=\"CIDR斜线记法\"></p>\n</li>\n</ul>\n<blockquote>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240801155624791.png\" alt=\"CIDR练习\"></p>\n</blockquote>\n<h4 id=\"路由聚合\"><a href=\"#路由聚合\" class=\"headerlink\" title=\"路由聚合\"></a>路由聚合</h4><ul>\n<li>网络前缀越长， 地址块越小，足 路由越具体；</li>\n<li>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配。因为这样的路由更具体。 </li>\n<li>聚合策略：找最长公共前缀</li>\n<li>表示方法：每个聚合的地址都是公共前缀的网络地址形式</li>\n</ul>\n<h3 id=\"IPv4地址的应用规划\"><a href=\"#IPv4地址的应用规划\" class=\"headerlink\" title=\"IPv4地址的应用规划\"></a>IPv4地址的应用规划</h3><ul>\n<li><p>定长的子网掩码（FLSM Fixed Length Subnet Mask）</p>\n<ul>\n<li>使用同一个子网掩码来划分子网</li>\n<li>每个子网所分配的IP地址数量相同，造成IP地址的浪费</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/01/RF6mUJOSD1EAl3s.png\" alt=\"FLSM 划分示例\"></p>\n</li>\n<li><p>变长的子网掩码（VLSM Variable Length Subnet Mask）</p>\n<ul>\n<li>使用不同的子网掩码来划分网络</li>\n<li>每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/01/BHMspwIxC4myrWk.png\" alt=\"VLSM 划分示例\"></p>\n</li>\n</ul>\n<h2 id=\"IP数据报的发送和转发过程\"><a href=\"#IP数据报的发送和转发过程\" class=\"headerlink\" title=\"IP数据报的发送和转发过程\"></a>IP数据报的发送和转发过程</h2><p>IP数据报的发送和转发过程包含以下两部分：</p>\n<ul>\n<li><p>主机发送IP数据报</p>\n<ul>\n<li>对跨子网的通信，需要间接交互，对任意子网主机，都需要指定默认网关执行这样的通信</li>\n<li>如果再同一个网络则直接交付</li>\n</ul>\n</li>\n<li><p>路由器转发IP数据报</p>\n<ul>\n<li><p>检查IP数据报首部是否出错：</p>\n<p>若出错，则直接丢弃该IP数据报并通告源主机；</p>\n<p>若没有出错，则进行转发；</p>\n</li>\n<li><p>根据IP数据报的目的地址在路由表中查找匹配的条目</p>\n<p>若找到匹配的条目，则转发给条目中指示的下一跳；</p>\n<p>若找不到，则丢弃该IP数据报并通告源主机；</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"路由选择协议\"><a href=\"#路由选择协议\" class=\"headerlink\" title=\"路由选择协议\"></a>路由选择协议</h2><h3 id=\"静态路由选择协议\"><a href=\"#静态路由选择协议\" class=\"headerlink\" title=\"静态路由选择协议\"></a>静态路由选择协议</h3><ul>\n<li>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表<ul>\n<li>这种人工配置方式简单、开销小。但不能及时适应网络状态 (流量、拓扑等）的变化。</li>\n<li>一般只在小规模网络中采用。</li>\n</ul>\n</li>\n<li>使用静态路由配置可能出现以下导致产生路由环路的错误<ul>\n<li>配置错误</li>\n<li>聚合了不存在的网络（这样产生路由环路可能产生广播风暴）</li>\n<li>网络故障</li>\n</ul>\n</li>\n<li>特殊类型<ul>\n<li>以0.0.0.0/0为目标地址的默认路由</li>\n<li>以特定主机地址为目的地址的特殊主机路由</li>\n<li>人工配置的聚合路由</li>\n<li>黑洞路由 下一条为null/0吞掉对应目标地址的报文 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ul>\n<li>静态路由选择<ul>\n<li>由人工配置的网络路由、默认路由、特定主机路由，黑洞路由等都属于静态路由。</li>\n<li>这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化</li>\n<li>一般只在小规模网络中采用。</li>\n</ul>\n</li>\n<li>动态路由协议<ul>\n<li>路由器通过路由选择协议自动获取路由信息。</li>\n<li>比较复杂、开销比较大。</li>\n<li>适用于大规模网络。</li>\n</ul>\n</li>\n</ul>\n<p>因特网分层次路由选择协议</p>\n<ul>\n<li>AS (Autonomous System)自治系统</li>\n<li>IGP(Interior Gateway Protocol)如RIP(Routing Information Protocol)路由信息协议、OSPF(Open Shortest Path First)开放式最短路径优先</li>\n<li>EGP(Exterior Gateway Protocol)如BGP(Border Gateway Protocol)边界网关协议</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/07/pjiNn2wF7LV1EDs.png\" alt=\"image-20240807193738255\"></p>\n<h3 id=\"因特网所采用的路由选择协议的主要特点\"><a href=\"#因特网所采用的路由选择协议的主要特点\" class=\"headerlink\" title=\"因特网所采用的路由选择协议的主要特点\"></a>因特网所采用的路由选择协议的主要特点</h3><ul>\n<li>自适应：动态路由选择， 能较好地适应网络状态的变化</li>\n<li>分布式：路由器之间交换路由信息</li>\n<li>分层次：将整个因特网划分为许多较小的自治系统AS(Autonomous Sy stem)</li>\n</ul>\n<h3 id=\"常见的路由选择协议\"><a href=\"#常见的路由选择协议\" class=\"headerlink\" title=\"常见的路由选择协议\"></a>常见的路由选择协议</h3><ul>\n<li>内部网关协议<ul>\n<li>RIP routing information protocol 路由信息协议：最早在因特网上使用，是一种基于距离向量的协议</li>\n<li>IGRP Interior Gateway Routing Protocol 是思科早期私有的协议，已被EIFGRP协议取代，是一种基于距离向量的协议</li>\n<li>EIGRP Enhanced Interior Gateway Routing Protocol 是思科私有，结合距离向量与链路状态的混合型路由协议</li>\n<li>OSPF Open Shortest Path First 开放式最短路径优先 在各种网络中广泛使用</li>\n<li>IS-SI Interal System to Interal System 中间系统到中间系统这是一种ISP骨干网上最常用的IGP Interal Gateway Protocol 内部网关协议</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/07/61eUuOqofScP9QK.png\" alt=\"路由选择协议\"></p>\n<h3 id=\"路由器逻辑结构\"><a href=\"#路由器逻辑结构\" class=\"headerlink\" title=\"路由器逻辑结构\"></a>路由器逻辑结构</h3><p><img src=\"https://s2.loli.net/2024/08/07/DCrviYOuMEJhNGx.png\" alt=\"路由器逻辑结构\"></p>\n<ul>\n<li>路由表<ul>\n<li>路由表一般仅包含从目标网络到下一跳的映射</li>\n<li>路由表需要对网络拓扑变化的计算最优化</li>\n</ul>\n</li>\n<li>转发表<ul>\n<li>转发表是由路由表得出的</li>\n<li>转发表的结构应当是查找过程最优化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RIP-Routing-Information-Protocol\"><a href=\"#RIP-Routing-Information-Protocol\" class=\"headerlink\" title=\"RIP Routing Information Protocol\"></a>RIP Routing Information Protocol</h3><ul>\n<li><p>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，<strong>称为“距离向量D-V(Distance-Vector)”。</strong></p>\n</li>\n<li><p>RIP最大D-V为15，16相当于不可达，只适用于小型互联网</p>\n</li>\n<li>RIP认为好的路由就是D-V距离最小的路由</li>\n<li>如果有“多条距离相等”情况，可以进行等价负载均衡</li>\n<li>RIP存在”坏消息传播的慢”这一缺点，又称路由环路或距离无穷计数问题，这一问题时距离向量算法的一个固有危害<ul>\n<li>解决方法为<ol>\n<li>限制最大路由距离</li>\n<li>当路由表发生变化时就立即发送更新报文(<strong>触发更新</strong>)</li>\n<li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送(即：<strong>水平切割</strong>)</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/07/KCZvYLc67bywzhO.png\" alt=\"RIP实现方式\"></p>\n<blockquote>\n<p>【2016年题37】假设R1、R2、R3采用RIP协议交换路由信息，且均已收敛。若R3检测到网络201.1.2.0/25不可达，并向R2通告一次新的距离向量，则R2更新后，其到达该网络的距离是 </p>\n<p>A. 2 B. 3 C. 16 D. 17</p>\n<details>\n    【解析】B.\n    <img src=\"https://s2.loli.net/2024/08/07/PjLR5qhJ7dbsvaH.png\" alt=\"image-20240807204500023\" />\n    R3检测到网络201.1.2.0/25不可达，并向R2通告一次新的距离向量\n    R2更新后，这里的题意是指，R1周期更新R2的路由表\n</details>\n\n</blockquote>\n<h3 id=\"OSPF-Open-Shortest-Path-First\"><a href=\"#OSPF-Open-Shortest-Path-First\" class=\"headerlink\" title=\"OSPF Open Shortest Path First\"></a>OSPF Open Shortest Path First</h3><ul>\n<li>OSPF协议是一种基于链路状态的协议</li>\n<li>采用Spfa算法进行路由计算，算法上保证不会产生环形路由</li>\n<li>OPSF不限制网络规模，更新效率高，并且收敛速度快</li>\n<li>链路状态表示和哪些路由器相邻，以及相应链路的“代价”<ul>\n<li>“代价” 是人为规定的，eg: 100Mbps / 链路带宽</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><ul>\n<li><p>通过“问候Hello分组”建立与维护邻居关系</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240807205258647.png\" alt=\"Hello分组\"></p>\n</li>\n<li><p>LSA Link State Advertisement 链路状态通告</p>\n<ul>\n<li>直连网络的链路状态信息</li>\n<li>邻居路由器的链路状态信息</li>\n</ul>\n</li>\n<li><p>LSA被封装在链路状态更新分组LSU Link State Unit 中，采用洪泛法发送</p>\n</li>\n<li><p>LSDB Link Statu Data Base 链路状态分组，用于存储 LSA</p>\n<ul>\n<li>各个路由器都有LSDB，并且最终将达到一致</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/07/Tq13cHsl5XkMnJW.png\" alt=\"OSPF的五种分组\"><img src=\"https://s2.loli.net/2024/08/07/xnzZJrCasBlvcbq.png\" alt=\"OSPF的工作流程\"></p>\n<h4 id=\"OPSF特定问题的解决\"><a href=\"#OPSF特定问题的解决\" class=\"headerlink\" title=\"OPSF特定问题的解决\"></a>OPSF特定问题的解决</h4><p>多点接入问题中过多状态报文的解决</p>\n<ul>\n<li>选举<strong>指定路由器</strong>DR Designaged router与备用的指定路由器BDR Backup designated router</li>\n<li>所有的非DR/BDR只与DR/BDR建立邻居关系</li>\n<li>非DR/BDR之间通过DR/BDR交换信息</li>\n</ul>\n<p>解决大网络结构的问题</p>\n<ul>\n<li>缩点成块：提出AS AutonumousSystem </li>\n<li>基于此，将路由器划分为区域内路由器IR与区域边界路由器ABR</li>\n</ul>\n<h3 id=\"BGP-Border-Gateway-Protocol\"><a href=\"#BGP-Border-Gateway-Protocol\" class=\"headerlink\" title=\"BGP Border Gateway Protocol\"></a>BGP Border Gateway Protocol</h3><p>BGP是 外部网关协议，其对应的是在外部网关的外部网关协议EGP</p>\n<p><img src=\"https://s2.loli.net/2024/08/07/FJPB5qA2zSZbg9C.png\" alt=\"BGP的度量标准问题\"></p>\n<p>因此，BPG无固定标准，一般只要可联通并且无环即可。</p>\n<ul>\n<li>BGP发言人：AS的administer 必须选择至少一个路由器作为“BGP发言人”</li>\n<li>不同自治系统的BGP发言人要交换路由信息，首先必须<strong>建立TCP连接，端口号为179</strong><ul>\n<li>此TCP连接上交换BGP报文以建立<strong>BGP会话</strong></li>\n<li>用BGP会话<strong>交换路由信息</strong>（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）</li>\n<li>用TCP连接交换路由信息的两个BGP发言人，彼此称为<strong>对方的邻站（neighbor）或对等站（peer)</strong></li>\n</ul>\n</li>\n<li>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP。</li>\n</ul>\n<p>当BGP发言人相互交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由，即构造树形无回路的自治系统连通分量</p>\n<p>BGP-4有以下四种报文</p>\n<ul>\n<li>OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化。</li>\n<li>UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由。</li>\n<li>KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性。</li>\n<li>NOTIFICATION(通知)报文：用来发送检测到的差错。</li>\n</ul>\n<h2 id=\"IPv4数据报及其首部格式\"><a href=\"#IPv4数据报及其首部格式\" class=\"headerlink\" title=\"IPv4数据报及其首部格式\"></a>IPv4数据报及其首部格式</h2><p><img src=\"https://s2.loli.net/2024/08/07/LuSr9CqFpQ1nKmi.png\" alt=\"IPv4首部格式——首部长度\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/07/4VvrNTH2Gg6OJ39.png\" alt=\"IPv4首部格式——区分服务\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/07/5YNa6QJsLfSEhIj.png\" alt=\"IPv4首部格式——总长度\"></p>\n<ul>\n<li>总长度= 首部长度+数据载荷长度</li>\n<li>首部长度为固定长度加上可变部分的长度</li>\n<li>总长度以一个字节为一个单位，首部长度以4个字节为一个单位</li>\n<li>这里有三个特殊的部分<ul>\n<li>标识，在分帧中标识分帧的同步顺序</li>\n<li>标志，DF,MF,保留位</li>\n<li>片偏移：标志报文数据在数据包中的便宜位置</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/07/COd9UkApcxBXyb3.png\" alt=\"IPv4首部格式——TTL\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/07/lJO8VpN4A3esRXG.png\" alt=\"IPv4首部格式——协议字段\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/07/eRyabMc8sl3QDi4.png\" alt=\"IPv4首部格式——首部检验和\"></p>\n<h3 id=\"IPv4数据报的分帧\"><a href=\"#IPv4数据报的分帧\" class=\"headerlink\" title=\"IPv4数据报的分帧\"></a>IPv4数据报的分帧</h3><p>对数据链路层而言，有最大传输单元MTU MAximum Transmission Unit的限制。</p>\n<p>对一个IP数据报分片的三个字段</p>\n<ol>\n<li>标识字段<ul>\n<li>占16比特属于同一个IP数据报则具有相同表示</li>\n<li>IP软件维持一个计数器，每产生一个数据包，计数器加一并将此值赋给标识字段</li>\n</ul>\n</li>\n<li>标志<ul>\n<li>占3比特</li>\n<li>DF Divide Flag位：1 允许分片 0 不允许分片</li>\n<li>MF More Flag位：1 后面还有分片 0 这是最后一个分片</li>\n<li>保留位： 必须为1</li>\n</ul>\n</li>\n<li>片位移<ul>\n<li>占13bit 指出分片数据包的数据载荷部分在原数据包的位置</li>\n<li>以8个字节为单位</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><img src=\"https://s2.loli.net/2024/08/07/OTlgh9X4CwWEIx5.png\" alt=\"数据报分片示例\"></p>\n</blockquote>\n<h2 id=\"ICMP-Internet-Control-Message-Protocol\"><a href=\"#ICMP-Internet-Control-Message-Protocol\" class=\"headerlink\" title=\"ICMP Internet Control Message Protocol\"></a>ICMP Internet Control Message Protocol</h2><p>ICMP 网际控制报文协议</p>\n<ul>\n<li>主机或路由器使用ICMP来发送差错报告报文和询问报文</li>\n<li>ICMP报文被封装在IP数据报中发送</li>\n</ul>\n<h3 id=\"ICMP差错报告告文\"><a href=\"#ICMP差错报告告文\" class=\"headerlink\" title=\"ICMP差错报告告文\"></a>ICMP差错报告告文</h3><ol>\n<li><p>终点不可达</p>\n</li>\n<li><p>源点抑制</p>\n<p>指出现拥塞，向源点发送的抑制发送速率的报文</p>\n</li>\n<li><p>时间超过</p>\n<p>当发生TTL为0时向源点发送的时间超过报文</p>\n<p>另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点时间超过报文</p>\n</li>\n<li><p>参数问题</p>\n<p>首部出现误码</p>\n</li>\n<li><p>改变路由（重定向）</p>\n<p>通知主机有更好的路由</p>\n</li>\n</ol>\n<p>不应该发送差错报文的情况</p>\n<ul>\n<li>不会对ICMP报文发送ICMP差错报告报文</li>\n<li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li>\n<li>对具有多播地址的数据报都不发送ICMP差错报告报文</li>\n<li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</li>\n</ul>\n<h3 id=\"ICMP询问报文\"><a href=\"#ICMP询问报文\" class=\"headerlink\" title=\"ICMP询问报文\"></a>ICMP询问报文</h3><ul>\n<li><p>回送请求和回答</p>\n<p>ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。</p>\n<p>这种询问报文用来<strong>测试目的站是否可达及了解其有关状态</strong>。</p>\n</li>\n<li><p>时间戳请求和回答</p>\n<p>ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。<br>在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。<br>这种询问报文用来<strong>进行时钟同步和测量时间</strong>。</p>\n</li>\n</ul>\n<h3 id=\"应用举例\"><a href=\"#应用举例\" class=\"headerlink\" title=\"应用举例\"></a>应用举例</h3><p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240807220717796.png\" alt=\"分组网间探测Ping Packet InterNet Groper\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/07/I8QajykHzx1t6JV.png\" alt=\"跟踪路由 TraceRoute\">跟踪路由 TraceRoute实现原理为设置不同TTL的数据报</p>\n<h2 id=\"虚拟网VPN-与-网络地址转换-NAT\"><a href=\"#虚拟网VPN-与-网络地址转换-NAT\" class=\"headerlink\" title=\"虚拟网VPN 与 网络地址转换 NAT\"></a>虚拟网VPN 与 网络地址转换 NAT</h2><h3 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h3><p>内联网VPN，外联网VPN，远程接入VPN</p>\n<ul>\n<li><strong>内联网VPN</strong>指同一机构的不同部门内部网络所组成的虚拟专用网</li>\n<li>外联网指有某些外部机构（通常是合作伙伴）参加进来的VPN，指<strong>外联网VPN</strong></li>\n<li>通过运行软件建立隧道访问专有网络资源的行为称为远程接入VPN</li>\n</ul>\n<h3 id=\"NAT\"><a href=\"#NAT\" class=\"headerlink\" title=\"NAT\"></a>NAT</h3><p>NAT是用于内部专用网络的专用网络用户使用少量外部全球地址来访问因特网上的主机和资源</p>\n<ul>\n<li><p>NAT是一种缓解IPv4地址耗尽的网络地址转换技术</p>\n</li>\n<li><p>NAT路由器将内部地址转化为全球地址，记录专用地址与公开地址之间的对应关系</p>\n</li>\n<li><p><strong>NAPT Network Address add Port Translation</strong>：网络地址与端口号转换技术指将端口号与IP地址一起进行转换的技术。</p>\n<p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240808214140162.png\" alt=\"NATP转换表\"></p>\n</li>\n</ul>\n"},{"title":"计网篇-分层结构篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"## 分层结构概要\n\n​\t在计算机网络中ISO提出参考模型OSI规定了七个层次，是法律上的标准，而现代常见的计算机网络设计实际上构成了更为普遍的四层结构TCP/IP结构，是事实上的标准，在教育中我们规定有五种结构，这种结构更加理想。\n\n### 最常见的五层结构\n\n1. 应用层\n2. 传输层\n3. 网络层\n4. 数据链路层\n5. 物理层\n\n差分的看，对TCP/IP模型无传输层，对OSI参考模型在传输层变为了表示层，会话层，传输层。\n\n![层次结构](https://s2.loli.net/2024/07/15/MWy6rl9ADYzUcS3.png)\n\n### 各层次之间的关系\n\n#### 水平关系\n\n实体：在计算机网络的分层结构中，第n层中的活动元素(软件+硬件)通常称为第n层实体。**不**\n**同机器上的同一层称为对等层**，同一层的实体称为对等实体。\n协议：即网络协议(Network Protocol)，是**控制对等实体**之间进行通信的规则的集合，是水平的\n\n![水平关系](https://s2.loli.net/2024/07/15/LdIgb3wFEC4hVDW.png)\n\n#### 垂直关系\n\n接口：即同一节点内**相邻两层的实体交换信息**的**逻辑接口**，又称为服务访问点（Service Access Point,SAP)\n服务：服务**是指下层为紧邻的上层提供的功能调用，它是垂直**的。\n\n![垂直关系](https://s2.loli.net/2024/07/15/6sJHoQxY2WP3hR8.png)\n\n首部，尾部：标注各个层次的状态信息\n\n![层次状态信息](https://s2.loli.net/2024/07/15/Wi4j9LPfUZ2JyBX.png)\n\n#### PDU、SDU、PCI\n\n协议数据单元(PDU)：对等层次之间份传送的数据单位。第n层的PDU记为n-PDU\n服务数据单元(SDU)：为完成上一层实体所要求的功能而传送的数据。第n层的SDU记为n-SDU。\n协议控制信息(PCI)：控制协议操作的信息。第n层的PCI记为n-PCl。\n\n三者关系：$$ \\text{n-SDU} +  \\text{n-PCI}=\\text{n-PDU}=\\text{(n-1)-SDU}$$\n\n#### 协议的三要素\n\n协议由**语法、语义和同步**三部分组成（协议的三要素）：\n\n1) 语法，**数据与控制信息的格式**。例如，协议控制信息（首部）部分占几个字节、每\n   个字节是什么含义协议的数据部分最多由多少学节。\n2) 语义，**即需要发出何种控制信息**、完成何种动作及做出何种应答。例如，协议中需\n   要明确规定：发送方完数据后，接收方是否需要“应答”，以及应答的种类有哪些（如：\n   传输成功、传输失败）\n3) 同步（或顺序），执行各种操作的条件、时序关系等，即**事件实现顺序的详细说明**。\n   例如，发送方发完数据后，接收方需要立即应答。如果发送方在10秒内未收到“传输成\n   功”应答，则发送方会再次发送数据。\n\n## 常见物理设备的层次结构\n\n主机具有所有层次\n\n集线器仅具有物理层和数据链路层\n\n路由器具有到网络层即三层\n\n## OSI模型的各层次功能结构\n\n### 物理层\n\n物理层任务：实现想邻节点之间比特(0或1)的传输\n①需定义电路接口参数(如：形状、尺寸、引脚数等)\n②需定义传输信号的含义、电气特征（如：5V表示1,1V表示0;\n每比特电信号持续时间0.1ms。\n\n### 链路层\n\n链路层任务：确保相邻节点之间的链路逻辑上无差错。包含以下功能\n\n1. 差错控制：检错+纠错；或检错+丢弃+重传\n2. 流量控制：协调两个结点的速率\n\n单位：**帧**\n\n### 网络层\n\n网络层任务：把“分组”从源结点转发到目的结点。包含以下功能\n\n1. 路由选择：构造并维护路由表，决定分组到达目的节点的最佳路径\n2. 分组转发：将“分组”从合适的端口转发出去\n3. 拥塞控制：发现网络拥塞，并采取措施缓解拥塞\n4. 网际互联：实现异构网络互联\n5. 其他功能：差错控制、流量控制、连接建立与释放、可靠传输管理\n\n单位： **分组为单位**\n\n### 传输层\n\n传输层任务：**实现端到端通信**(即实现进程到进程的通信，“端”指“端口”)。包含以下功能\n\n1. 复用和分用：发送端几个高层实体复用一条低层的连接，在接收端再进行分用。\n2. 其他功能：差错制、流量控制、连接建立与释放、可靠传输管理\n\n单位：**报文段、报文为单位**\n\n### 更高层次\n\n![层次作用](https://s2.loli.net/2024/07/15/V2fhDpvXCkLMbn7.png)\n\n### 总体概览\n\n\n\n![OSI](https://s2.loli.net/2024/07/15/N8vEWiRjmwPnak6.png)\n\n![TCP](https://s2.loli.net/2024/07/15/VWdE4r5g9LHZwx8.png)\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/计算机网络的分层结构.md","raw":"---\ntitle: 计网篇-分层结构篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n## 分层结构概要\n\n​\t在计算机网络中ISO提出参考模型OSI规定了七个层次，是法律上的标准，而现代常见的计算机网络设计实际上构成了更为普遍的四层结构TCP/IP结构，是事实上的标准，在教育中我们规定有五种结构，这种结构更加理想。\n\n### 最常见的五层结构\n\n1. 应用层\n2. 传输层\n3. 网络层\n4. 数据链路层\n5. 物理层\n\n差分的看，对TCP/IP模型无传输层，对OSI参考模型在传输层变为了表示层，会话层，传输层。\n\n![层次结构](https://s2.loli.net/2024/07/15/MWy6rl9ADYzUcS3.png)\n\n### 各层次之间的关系\n\n#### 水平关系\n\n实体：在计算机网络的分层结构中，第n层中的活动元素(软件+硬件)通常称为第n层实体。**不**\n**同机器上的同一层称为对等层**，同一层的实体称为对等实体。\n协议：即网络协议(Network Protocol)，是**控制对等实体**之间进行通信的规则的集合，是水平的\n\n![水平关系](https://s2.loli.net/2024/07/15/LdIgb3wFEC4hVDW.png)\n\n#### 垂直关系\n\n接口：即同一节点内**相邻两层的实体交换信息**的**逻辑接口**，又称为服务访问点（Service Access Point,SAP)\n服务：服务**是指下层为紧邻的上层提供的功能调用，它是垂直**的。\n\n![垂直关系](https://s2.loli.net/2024/07/15/6sJHoQxY2WP3hR8.png)\n\n首部，尾部：标注各个层次的状态信息\n\n![层次状态信息](https://s2.loli.net/2024/07/15/Wi4j9LPfUZ2JyBX.png)\n\n#### PDU、SDU、PCI\n\n协议数据单元(PDU)：对等层次之间份传送的数据单位。第n层的PDU记为n-PDU\n服务数据单元(SDU)：为完成上一层实体所要求的功能而传送的数据。第n层的SDU记为n-SDU。\n协议控制信息(PCI)：控制协议操作的信息。第n层的PCI记为n-PCl。\n\n三者关系：$$ \\text{n-SDU} +  \\text{n-PCI}=\\text{n-PDU}=\\text{(n-1)-SDU}$$\n\n#### 协议的三要素\n\n协议由**语法、语义和同步**三部分组成（协议的三要素）：\n\n1) 语法，**数据与控制信息的格式**。例如，协议控制信息（首部）部分占几个字节、每\n   个字节是什么含义协议的数据部分最多由多少学节。\n2) 语义，**即需要发出何种控制信息**、完成何种动作及做出何种应答。例如，协议中需\n   要明确规定：发送方完数据后，接收方是否需要“应答”，以及应答的种类有哪些（如：\n   传输成功、传输失败）\n3) 同步（或顺序），执行各种操作的条件、时序关系等，即**事件实现顺序的详细说明**。\n   例如，发送方发完数据后，接收方需要立即应答。如果发送方在10秒内未收到“传输成\n   功”应答，则发送方会再次发送数据。\n\n## 常见物理设备的层次结构\n\n主机具有所有层次\n\n集线器仅具有物理层和数据链路层\n\n路由器具有到网络层即三层\n\n## OSI模型的各层次功能结构\n\n### 物理层\n\n物理层任务：实现想邻节点之间比特(0或1)的传输\n①需定义电路接口参数(如：形状、尺寸、引脚数等)\n②需定义传输信号的含义、电气特征（如：5V表示1,1V表示0;\n每比特电信号持续时间0.1ms。\n\n### 链路层\n\n链路层任务：确保相邻节点之间的链路逻辑上无差错。包含以下功能\n\n1. 差错控制：检错+纠错；或检错+丢弃+重传\n2. 流量控制：协调两个结点的速率\n\n单位：**帧**\n\n### 网络层\n\n网络层任务：把“分组”从源结点转发到目的结点。包含以下功能\n\n1. 路由选择：构造并维护路由表，决定分组到达目的节点的最佳路径\n2. 分组转发：将“分组”从合适的端口转发出去\n3. 拥塞控制：发现网络拥塞，并采取措施缓解拥塞\n4. 网际互联：实现异构网络互联\n5. 其他功能：差错控制、流量控制、连接建立与释放、可靠传输管理\n\n单位： **分组为单位**\n\n### 传输层\n\n传输层任务：**实现端到端通信**(即实现进程到进程的通信，“端”指“端口”)。包含以下功能\n\n1. 复用和分用：发送端几个高层实体复用一条低层的连接，在接收端再进行分用。\n2. 其他功能：差错制、流量控制、连接建立与释放、可靠传输管理\n\n单位：**报文段、报文为单位**\n\n### 更高层次\n\n![层次作用](https://s2.loli.net/2024/07/15/V2fhDpvXCkLMbn7.png)\n\n### 总体概览\n\n\n\n![OSI](https://s2.loli.net/2024/07/15/N8vEWiRjmwPnak6.png)\n\n![TCP](https://s2.loli.net/2024/07/15/VWdE4r5g9LHZwx8.png)\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/计算机网络的分层结构","published":1,"updated":"2024-08-17T13:25:23.820Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqu003sm8wv4eqg7vi8","content":"<h2 id=\"分层结构概要\"><a href=\"#分层结构概要\" class=\"headerlink\" title=\"分层结构概要\"></a>分层结构概要</h2><p>​    在计算机网络中ISO提出参考模型OSI规定了七个层次，是法律上的标准，而现代常见的计算机网络设计实际上构成了更为普遍的四层结构TCP/IP结构，是事实上的标准，在教育中我们规定有五种结构，这种结构更加理想。</p>\n<h3 id=\"最常见的五层结构\"><a href=\"#最常见的五层结构\" class=\"headerlink\" title=\"最常见的五层结构\"></a>最常见的五层结构</h3><ol>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>数据链路层</li>\n<li>物理层</li>\n</ol>\n<p>差分的看，对TCP/IP模型无传输层，对OSI参考模型在传输层变为了表示层，会话层，传输层。</p>\n<p><img src=\"https://s2.loli.net/2024/07/15/MWy6rl9ADYzUcS3.png\" alt=\"层次结构\"></p>\n<h3 id=\"各层次之间的关系\"><a href=\"#各层次之间的关系\" class=\"headerlink\" title=\"各层次之间的关系\"></a>各层次之间的关系</h3><h4 id=\"水平关系\"><a href=\"#水平关系\" class=\"headerlink\" title=\"水平关系\"></a>水平关系</h4><p>实体：在计算机网络的分层结构中，第n层中的活动元素(软件+硬件)通常称为第n层实体。<strong>不</strong><br><strong>同机器上的同一层称为对等层</strong>，同一层的实体称为对等实体。<br>协议：即网络协议(Network Protocol)，是<strong>控制对等实体</strong>之间进行通信的规则的集合，是水平的</p>\n<p><img src=\"https://s2.loli.net/2024/07/15/LdIgb3wFEC4hVDW.png\" alt=\"水平关系\"></p>\n<h4 id=\"垂直关系\"><a href=\"#垂直关系\" class=\"headerlink\" title=\"垂直关系\"></a>垂直关系</h4><p>接口：即同一节点内<strong>相邻两层的实体交换信息</strong>的<strong>逻辑接口</strong>，又称为服务访问点（Service Access Point,SAP)<br>服务：服务<strong>是指下层为紧邻的上层提供的功能调用，它是垂直</strong>的。</p>\n<p><img src=\"https://s2.loli.net/2024/07/15/6sJHoQxY2WP3hR8.png\" alt=\"垂直关系\"></p>\n<p>首部，尾部：标注各个层次的状态信息</p>\n<p><img src=\"https://s2.loli.net/2024/07/15/Wi4j9LPfUZ2JyBX.png\" alt=\"层次状态信息\"></p>\n<h4 id=\"PDU、SDU、PCI\"><a href=\"#PDU、SDU、PCI\" class=\"headerlink\" title=\"PDU、SDU、PCI\"></a>PDU、SDU、PCI</h4><p>协议数据单元(PDU)：对等层次之间份传送的数据单位。第n层的PDU记为n-PDU<br>服务数据单元(SDU)：为完成上一层实体所要求的功能而传送的数据。第n层的SDU记为n-SDU。<br>协议控制信息(PCI)：控制协议操作的信息。第n层的PCI记为n-PCl。</p>\n<p>三者关系：<script type=\"math/tex\">\\text{n-SDU} +  \\text{n-PCI}=\\text{n-PDU}=\\text{(n-1)-SDU}</script></p>\n<h4 id=\"协议的三要素\"><a href=\"#协议的三要素\" class=\"headerlink\" title=\"协议的三要素\"></a>协议的三要素</h4><p>协议由<strong>语法、语义和同步</strong>三部分组成（协议的三要素）：</p>\n<p>1) 语法，<strong>数据与控制信息的格式</strong>。例如，协议控制信息（首部）部分占几个字节、每<br>   个字节是什么含义协议的数据部分最多由多少学节。<br>2) 语义，<strong>即需要发出何种控制信息</strong>、完成何种动作及做出何种应答。例如，协议中需<br>   要明确规定：发送方完数据后，接收方是否需要“应答”，以及应答的种类有哪些（如：<br>   传输成功、传输失败）<br>3) 同步（或顺序），执行各种操作的条件、时序关系等，即<strong>事件实现顺序的详细说明</strong>。<br>   例如，发送方发完数据后，接收方需要立即应答。如果发送方在10秒内未收到“传输成<br>   功”应答，则发送方会再次发送数据。</p>\n<h2 id=\"常见物理设备的层次结构\"><a href=\"#常见物理设备的层次结构\" class=\"headerlink\" title=\"常见物理设备的层次结构\"></a>常见物理设备的层次结构</h2><p>主机具有所有层次</p>\n<p>集线器仅具有物理层和数据链路层</p>\n<p>路由器具有到网络层即三层</p>\n<h2 id=\"OSI模型的各层次功能结构\"><a href=\"#OSI模型的各层次功能结构\" class=\"headerlink\" title=\"OSI模型的各层次功能结构\"></a>OSI模型的各层次功能结构</h2><h3 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h3><p>物理层任务：实现想邻节点之间比特(0或1)的传输<br>①需定义电路接口参数(如：形状、尺寸、引脚数等)<br>②需定义传输信号的含义、电气特征（如：5V表示1,1V表示0;<br>每比特电信号持续时间0.1ms。</p>\n<h3 id=\"链路层\"><a href=\"#链路层\" class=\"headerlink\" title=\"链路层\"></a>链路层</h3><p>链路层任务：确保相邻节点之间的链路逻辑上无差错。包含以下功能</p>\n<ol>\n<li>差错控制：检错+纠错；或检错+丢弃+重传</li>\n<li>流量控制：协调两个结点的速率</li>\n</ol>\n<p>单位：<strong>帧</strong></p>\n<h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><p>网络层任务：把“分组”从源结点转发到目的结点。包含以下功能</p>\n<ol>\n<li>路由选择：构造并维护路由表，决定分组到达目的节点的最佳路径</li>\n<li>分组转发：将“分组”从合适的端口转发出去</li>\n<li>拥塞控制：发现网络拥塞，并采取措施缓解拥塞</li>\n<li>网际互联：实现异构网络互联</li>\n<li>其他功能：差错控制、流量控制、连接建立与释放、可靠传输管理</li>\n</ol>\n<p>单位： <strong>分组为单位</strong></p>\n<h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><p>传输层任务：<strong>实现端到端通信</strong>(即实现进程到进程的通信，“端”指“端口”)。包含以下功能</p>\n<ol>\n<li>复用和分用：发送端几个高层实体复用一条低层的连接，在接收端再进行分用。</li>\n<li>其他功能：差错制、流量控制、连接建立与释放、可靠传输管理</li>\n</ol>\n<p>单位：<strong>报文段、报文为单位</strong></p>\n<h3 id=\"更高层次\"><a href=\"#更高层次\" class=\"headerlink\" title=\"更高层次\"></a>更高层次</h3><p><img src=\"https://s2.loli.net/2024/07/15/V2fhDpvXCkLMbn7.png\" alt=\"层次作用\"></p>\n<h3 id=\"总体概览\"><a href=\"#总体概览\" class=\"headerlink\" title=\"总体概览\"></a>总体概览</h3><p><img src=\"https://s2.loli.net/2024/07/15/N8vEWiRjmwPnak6.png\" alt=\"OSI\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/15/VWdE4r5g9LHZwx8.png\" alt=\"TCP\"></p>\n<!-- flag of hidden posts -->","length":1165,"excerpt":"","more":"<h2 id=\"分层结构概要\"><a href=\"#分层结构概要\" class=\"headerlink\" title=\"分层结构概要\"></a>分层结构概要</h2><p>​    在计算机网络中ISO提出参考模型OSI规定了七个层次，是法律上的标准，而现代常见的计算机网络设计实际上构成了更为普遍的四层结构TCP/IP结构，是事实上的标准，在教育中我们规定有五种结构，这种结构更加理想。</p>\n<h3 id=\"最常见的五层结构\"><a href=\"#最常见的五层结构\" class=\"headerlink\" title=\"最常见的五层结构\"></a>最常见的五层结构</h3><ol>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>数据链路层</li>\n<li>物理层</li>\n</ol>\n<p>差分的看，对TCP/IP模型无传输层，对OSI参考模型在传输层变为了表示层，会话层，传输层。</p>\n<p><img src=\"https://s2.loli.net/2024/07/15/MWy6rl9ADYzUcS3.png\" alt=\"层次结构\"></p>\n<h3 id=\"各层次之间的关系\"><a href=\"#各层次之间的关系\" class=\"headerlink\" title=\"各层次之间的关系\"></a>各层次之间的关系</h3><h4 id=\"水平关系\"><a href=\"#水平关系\" class=\"headerlink\" title=\"水平关系\"></a>水平关系</h4><p>实体：在计算机网络的分层结构中，第n层中的活动元素(软件+硬件)通常称为第n层实体。<strong>不</strong><br><strong>同机器上的同一层称为对等层</strong>，同一层的实体称为对等实体。<br>协议：即网络协议(Network Protocol)，是<strong>控制对等实体</strong>之间进行通信的规则的集合，是水平的</p>\n<p><img src=\"https://s2.loli.net/2024/07/15/LdIgb3wFEC4hVDW.png\" alt=\"水平关系\"></p>\n<h4 id=\"垂直关系\"><a href=\"#垂直关系\" class=\"headerlink\" title=\"垂直关系\"></a>垂直关系</h4><p>接口：即同一节点内<strong>相邻两层的实体交换信息</strong>的<strong>逻辑接口</strong>，又称为服务访问点（Service Access Point,SAP)<br>服务：服务<strong>是指下层为紧邻的上层提供的功能调用，它是垂直</strong>的。</p>\n<p><img src=\"https://s2.loli.net/2024/07/15/6sJHoQxY2WP3hR8.png\" alt=\"垂直关系\"></p>\n<p>首部，尾部：标注各个层次的状态信息</p>\n<p><img src=\"https://s2.loli.net/2024/07/15/Wi4j9LPfUZ2JyBX.png\" alt=\"层次状态信息\"></p>\n<h4 id=\"PDU、SDU、PCI\"><a href=\"#PDU、SDU、PCI\" class=\"headerlink\" title=\"PDU、SDU、PCI\"></a>PDU、SDU、PCI</h4><p>协议数据单元(PDU)：对等层次之间份传送的数据单位。第n层的PDU记为n-PDU<br>服务数据单元(SDU)：为完成上一层实体所要求的功能而传送的数据。第n层的SDU记为n-SDU。<br>协议控制信息(PCI)：控制协议操作的信息。第n层的PCI记为n-PCl。</p>\n<p>三者关系：<script type=\"math/tex\">\\text{n-SDU} +  \\text{n-PCI}=\\text{n-PDU}=\\text{(n-1)-SDU}</script></p>\n<h4 id=\"协议的三要素\"><a href=\"#协议的三要素\" class=\"headerlink\" title=\"协议的三要素\"></a>协议的三要素</h4><p>协议由<strong>语法、语义和同步</strong>三部分组成（协议的三要素）：</p>\n<p>1) 语法，<strong>数据与控制信息的格式</strong>。例如，协议控制信息（首部）部分占几个字节、每<br>   个字节是什么含义协议的数据部分最多由多少学节。<br>2) 语义，<strong>即需要发出何种控制信息</strong>、完成何种动作及做出何种应答。例如，协议中需<br>   要明确规定：发送方完数据后，接收方是否需要“应答”，以及应答的种类有哪些（如：<br>   传输成功、传输失败）<br>3) 同步（或顺序），执行各种操作的条件、时序关系等，即<strong>事件实现顺序的详细说明</strong>。<br>   例如，发送方发完数据后，接收方需要立即应答。如果发送方在10秒内未收到“传输成<br>   功”应答，则发送方会再次发送数据。</p>\n<h2 id=\"常见物理设备的层次结构\"><a href=\"#常见物理设备的层次结构\" class=\"headerlink\" title=\"常见物理设备的层次结构\"></a>常见物理设备的层次结构</h2><p>主机具有所有层次</p>\n<p>集线器仅具有物理层和数据链路层</p>\n<p>路由器具有到网络层即三层</p>\n<h2 id=\"OSI模型的各层次功能结构\"><a href=\"#OSI模型的各层次功能结构\" class=\"headerlink\" title=\"OSI模型的各层次功能结构\"></a>OSI模型的各层次功能结构</h2><h3 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h3><p>物理层任务：实现想邻节点之间比特(0或1)的传输<br>①需定义电路接口参数(如：形状、尺寸、引脚数等)<br>②需定义传输信号的含义、电气特征（如：5V表示1,1V表示0;<br>每比特电信号持续时间0.1ms。</p>\n<h3 id=\"链路层\"><a href=\"#链路层\" class=\"headerlink\" title=\"链路层\"></a>链路层</h3><p>链路层任务：确保相邻节点之间的链路逻辑上无差错。包含以下功能</p>\n<ol>\n<li>差错控制：检错+纠错；或检错+丢弃+重传</li>\n<li>流量控制：协调两个结点的速率</li>\n</ol>\n<p>单位：<strong>帧</strong></p>\n<h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><p>网络层任务：把“分组”从源结点转发到目的结点。包含以下功能</p>\n<ol>\n<li>路由选择：构造并维护路由表，决定分组到达目的节点的最佳路径</li>\n<li>分组转发：将“分组”从合适的端口转发出去</li>\n<li>拥塞控制：发现网络拥塞，并采取措施缓解拥塞</li>\n<li>网际互联：实现异构网络互联</li>\n<li>其他功能：差错控制、流量控制、连接建立与释放、可靠传输管理</li>\n</ol>\n<p>单位： <strong>分组为单位</strong></p>\n<h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><p>传输层任务：<strong>实现端到端通信</strong>(即实现进程到进程的通信，“端”指“端口”)。包含以下功能</p>\n<ol>\n<li>复用和分用：发送端几个高层实体复用一条低层的连接，在接收端再进行分用。</li>\n<li>其他功能：差错制、流量控制、连接建立与释放、可靠传输管理</li>\n</ol>\n<p>单位：<strong>报文段、报文为单位</strong></p>\n<h3 id=\"更高层次\"><a href=\"#更高层次\" class=\"headerlink\" title=\"更高层次\"></a>更高层次</h3><p><img src=\"https://s2.loli.net/2024/07/15/V2fhDpvXCkLMbn7.png\" alt=\"层次作用\"></p>\n<h3 id=\"总体概览\"><a href=\"#总体概览\" class=\"headerlink\" title=\"总体概览\"></a>总体概览</h3><p><img src=\"https://s2.loli.net/2024/07/15/N8vEWiRjmwPnak6.png\" alt=\"OSI\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/15/VWdE4r5g9LHZwx8.png\" alt=\"TCP\"></p>\n"},{"title":"计网篇-补充篇","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"## 一些约定的图像与对应关系及其性质\n\n![路由器](https://s2.loli.net/2024/07/27/hO2kfBxgdLoiC5t.png)\n\n上图一般表示路由器，常用字母R代替，它具有三层计算机网络结构，即最高层次为网络层，很好理解，路由器的最常见功能就是不同网络之间的通信管理\n\n![交换机层次结构](https://s2.loli.net/2024/07/27/iTGtc7Ho6syDqlQ.png)\n\n上图一般表示交换机，常用Switch代替，它具有二层计算机网络结构，即最高层次为数据链路层，也比较好记忆，它的作用就是解决网络的转发即分组在一段网络上或线路上的传播问题\n\n![集线器层次结构](https://s2.loli.net/2024/07/27/Rh8HuJ73WPGCiZs.png)\n\n上图一般表示集线器，常用Hub代替，它具有一层计算机网络结构，即最高层次为物理层，也比较好记忆，它的作用就是解决多线到一线，解决的是用何种信号传输的问题","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/补充.md","raw":"---\ntitle: 计网篇-补充篇\ndate: 2024-08-14 19:47:58\ntags: [计算机网络, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n## 一些约定的图像与对应关系及其性质\n\n![路由器](https://s2.loli.net/2024/07/27/hO2kfBxgdLoiC5t.png)\n\n上图一般表示路由器，常用字母R代替，它具有三层计算机网络结构，即最高层次为网络层，很好理解，路由器的最常见功能就是不同网络之间的通信管理\n\n![交换机层次结构](https://s2.loli.net/2024/07/27/iTGtc7Ho6syDqlQ.png)\n\n上图一般表示交换机，常用Switch代替，它具有二层计算机网络结构，即最高层次为数据链路层，也比较好记忆，它的作用就是解决网络的转发即分组在一段网络上或线路上的传播问题\n\n![集线器层次结构](https://s2.loli.net/2024/07/27/Rh8HuJ73WPGCiZs.png)\n\n上图一般表示集线器，常用Hub代替，它具有一层计算机网络结构，即最高层次为物理层，也比较好记忆，它的作用就是解决多线到一线，解决的是用何种信号传输的问题","slug":"special_subject/NationalPGExamination/ProfessionalCources/ComputerNetwork/补充","published":1,"updated":"2024-08-17T13:25:09.188Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqv003vm8wv27d11ut9","content":"<h2 id=\"一些约定的图像与对应关系及其性质\"><a href=\"#一些约定的图像与对应关系及其性质\" class=\"headerlink\" title=\"一些约定的图像与对应关系及其性质\"></a>一些约定的图像与对应关系及其性质</h2><p><img src=\"https://s2.loli.net/2024/07/27/hO2kfBxgdLoiC5t.png\" alt=\"路由器\"></p>\n<p>上图一般表示路由器，常用字母R代替，它具有三层计算机网络结构，即最高层次为网络层，很好理解，路由器的最常见功能就是不同网络之间的通信管理</p>\n<p><img src=\"https://s2.loli.net/2024/07/27/iTGtc7Ho6syDqlQ.png\" alt=\"交换机层次结构\"></p>\n<p>上图一般表示交换机，常用Switch代替，它具有二层计算机网络结构，即最高层次为数据链路层，也比较好记忆，它的作用就是解决网络的转发即分组在一段网络上或线路上的传播问题</p>\n<p><img src=\"https://s2.loli.net/2024/07/27/Rh8HuJ73WPGCiZs.png\" alt=\"集线器层次结构\"></p>\n<p>上图一般表示集线器，常用Hub代替，它具有一层计算机网络结构，即最高层次为物理层，也比较好记忆，它的作用就是解决多线到一线，解决的是用何种信号传输的问题</p>\n<!-- flag of hidden posts -->","length":238,"excerpt":"","more":"<h2 id=\"一些约定的图像与对应关系及其性质\"><a href=\"#一些约定的图像与对应关系及其性质\" class=\"headerlink\" title=\"一些约定的图像与对应关系及其性质\"></a>一些约定的图像与对应关系及其性质</h2><p><img src=\"https://s2.loli.net/2024/07/27/hO2kfBxgdLoiC5t.png\" alt=\"路由器\"></p>\n<p>上图一般表示路由器，常用字母R代替，它具有三层计算机网络结构，即最高层次为网络层，很好理解，路由器的最常见功能就是不同网络之间的通信管理</p>\n<p><img src=\"https://s2.loli.net/2024/07/27/iTGtc7Ho6syDqlQ.png\" alt=\"交换机层次结构\"></p>\n<p>上图一般表示交换机，常用Switch代替，它具有二层计算机网络结构，即最高层次为数据链路层，也比较好记忆，它的作用就是解决网络的转发即分组在一段网络上或线路上的传播问题</p>\n<p><img src=\"https://s2.loli.net/2024/07/27/Rh8HuJ73WPGCiZs.png\" alt=\"集线器层次结构\"></p>\n<p>上图一般表示集线器，常用Hub代替，它具有一层计算机网络结构，即最高层次为物理层，也比较好记忆，它的作用就是解决多线到一线，解决的是用何种信号传输的问题</p>\n"},{"title":"数构篇-又一轮复习大观","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"# 数据结构相关\n\n## 平衡二叉树的旋转\n\n1. 什么时候开始旋转\n\n插入或删除后使得树不平衡\n\n2. 从插入（删除位置从下往上找最小不平衡子树`平衡因子大于1`）\n3. 选出非叶子节点成子树，使得权值居中的节点成为子树的根\n4. 根据中序遍历（权值大小树的中序遍历就是升序），叶子节点的父亲节点即中序中与它最近的非叶子节点\n\n详细的分类讨论旋转（更普遍的解）\n\n1. 分类\n\n四种不平衡状态分别是LL,RR,LR,RL\n\n![LL](https://s2.loli.net/2024/07/08/ysV4joHWkYEup9d.png)\n\n\n\n![RR](https://s2.loli.net/2024/07/08/yJFpo9amCI4VLe7.png)\n\n![RR](https://s2.loli.net/2024/07/08/Diy7M4OPZnU2fGd.png)\n\n![RL](https://s2.loli.net/2024/07/08/IyKam2Nf6QVGlgd.png)\n\n具体的总结措施为，旋转将后两种状态转化为前两种状态，这种旋转的操作一般称其为单旋\n\n![右单旋](https://s2.loli.net/2024/07/08/lOEG6TmVXpkZiMQ.png)\n\n![左单旋](https://s2.loli.net/2024/07/08/IEOuAUBF34GKS7J.png)\n\n## 红黑树\n\n### 红黑树的限制\n\n- 每个结点的颜色只有**红色或黑色**两种；\n- **根结点**的颜色一定是黑色的；\n- 如果某一个结点的颜色是红色的，它的两个孩子结点的颜色一定是黑色（即**不存在两个连续的红色结点**）；\n- 对于任一结点，到叶子结点的任一路径上，**包含的黑色结点的数量**一定**相等**；\n- 叶子结点一定是黑色的（这里的叶子结点指最后的**nullptr**）\n\n### 红黑树有关问题\n\n可见对红黑树，最重要的问题有\n\n- 如何在保证确保从根到任何子节点经过的黑节点数是相同的\n\n由此延申考研中考红黑树插入（删除较为复杂，有时间再看）\n\n1. 红黑树插入\n\n   1. 根节点为空\n\n   直接设置黑色根节点\n\n   2. 父节点为黑色\n\n   直接插入红色节点\n\n   3. 父节点为黑色\n\n      3.1. 父节点的兄弟节点为红色\n\n   将父亲节点及兄弟节点染黑并将爷爷节点染红后旋转平衡树\n\n   ![原红黑树插入后](https://www.helloimg.com/images/2022/08/16/ZQmvuT.png)\n\n   ![染色后](https://s2.loli.net/2024/07/08/aXPMufosBOJt45m.png)\n\n   在此图中，解决方法为右单旋15根节点子树\n\n   ​\t3.2. 父亲节点的兄弟节点为黑色或者为空(LL双红)\n\n   ![插入后](https://s2.loli.net/2024/07/08/aucWSd5ER9OrUnC.png)\n\n   同样的染色\n\n   ![染色后](https://www.helloimg.com/images/2022/08/16/ZQmSNn.png)\n\n   然后单旋即可\n\n   ​\t3.3.父节点在爷爷节点左侧，子节点在父节点右侧（LR双红）\n\n   ![LR双红](https://s2.loli.net/2024/07/08/F63bjkmUvHtXyiS.png)\n\n   对父亲节点左旋\n\n   ![左旋后](https://www.helloimg.com/images/2022/08/16/ZQmlr5.png)\n\n   ​\t3.4. 父节点在爷爷节点右侧，子节点在父节点右侧（RR双红）\n\n   ![img](https://s2.loli.net/2024/07/08/3rNOhnoLS4ECQuH.png)\n\n   染色爷爷并左旋\n\n   ​\t3.5. RL\n\n   ![img](https://www.helloimg.com/images/2022/08/16/ZQmD6S.png)\n\n   类似的步骤\n\n# 数学相关\n\n##卡特兰数(Catalan数列)\n\n适用于DS的问题\n\n- 栈\n  - n个元素入栈，求出栈序列个数\n- 二叉树\n  - n个节点能构成多少种不同形状的二叉树\n- 括号匹配\n  - n对括号有多少种括号匹配序列\n\n### 公式\n\n卡特兰数的地推公式如下\n$$\nH_n = \\left\\{\n\t\t\\begin{array}{cc}\n\t\t\\sum^n_{i=1} H_{i-1}H_{n-i}& n\\ge 2,n\\in N_+\\\\\n\t\t1&n=0,1\\\\\n\t\t\\end{array}\n\\right.\n$$\n\n\n递推关系的通项公式\n$$\nH_n = \\frac{\\binom{2n}{n}}{n+1}(n\\ge 2, n\\in N_+)\n$$\n常见的推广式\n$$\nH_n = \\frac{H_{n-1}(4n-2)}{n+1}\n\\\\\nH_n = \\binom{2n}{n}-\\binom{2n}{n-1}\n$$\n有关卡特兰数通项公式的证明需要用到卷积来构造有关H(x)的方程\n\n如下\n$$\n\\begin{aligned}\nH(x)&=\\sum _{n\\ge0} H_nx^n\\\\\n&=1+\\sum_{n\\ge1}\\sum_{i=0}^{n-1}H_ix^iH_{n-i-1}x^{n-i-1}x\\\\\n&=1+x\\sum_{i\\ge0}H_ix^i\\sum_{n\\ge0}H_nx^n\\\\\n&=1+xH^2(x)\n\\end{aligned}\n$$\n\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/DataStructure/FirstRoundReview.md","raw":"---\ntitle: 数构篇-又一轮复习大观\ndate: 2024-08-14 19:47:58\ntags: [数据结构, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n# 数据结构相关\n\n## 平衡二叉树的旋转\n\n1. 什么时候开始旋转\n\n插入或删除后使得树不平衡\n\n2. 从插入（删除位置从下往上找最小不平衡子树`平衡因子大于1`）\n3. 选出非叶子节点成子树，使得权值居中的节点成为子树的根\n4. 根据中序遍历（权值大小树的中序遍历就是升序），叶子节点的父亲节点即中序中与它最近的非叶子节点\n\n详细的分类讨论旋转（更普遍的解）\n\n1. 分类\n\n四种不平衡状态分别是LL,RR,LR,RL\n\n![LL](https://s2.loli.net/2024/07/08/ysV4joHWkYEup9d.png)\n\n\n\n![RR](https://s2.loli.net/2024/07/08/yJFpo9amCI4VLe7.png)\n\n![RR](https://s2.loli.net/2024/07/08/Diy7M4OPZnU2fGd.png)\n\n![RL](https://s2.loli.net/2024/07/08/IyKam2Nf6QVGlgd.png)\n\n具体的总结措施为，旋转将后两种状态转化为前两种状态，这种旋转的操作一般称其为单旋\n\n![右单旋](https://s2.loli.net/2024/07/08/lOEG6TmVXpkZiMQ.png)\n\n![左单旋](https://s2.loli.net/2024/07/08/IEOuAUBF34GKS7J.png)\n\n## 红黑树\n\n### 红黑树的限制\n\n- 每个结点的颜色只有**红色或黑色**两种；\n- **根结点**的颜色一定是黑色的；\n- 如果某一个结点的颜色是红色的，它的两个孩子结点的颜色一定是黑色（即**不存在两个连续的红色结点**）；\n- 对于任一结点，到叶子结点的任一路径上，**包含的黑色结点的数量**一定**相等**；\n- 叶子结点一定是黑色的（这里的叶子结点指最后的**nullptr**）\n\n### 红黑树有关问题\n\n可见对红黑树，最重要的问题有\n\n- 如何在保证确保从根到任何子节点经过的黑节点数是相同的\n\n由此延申考研中考红黑树插入（删除较为复杂，有时间再看）\n\n1. 红黑树插入\n\n   1. 根节点为空\n\n   直接设置黑色根节点\n\n   2. 父节点为黑色\n\n   直接插入红色节点\n\n   3. 父节点为黑色\n\n      3.1. 父节点的兄弟节点为红色\n\n   将父亲节点及兄弟节点染黑并将爷爷节点染红后旋转平衡树\n\n   ![原红黑树插入后](https://www.helloimg.com/images/2022/08/16/ZQmvuT.png)\n\n   ![染色后](https://s2.loli.net/2024/07/08/aXPMufosBOJt45m.png)\n\n   在此图中，解决方法为右单旋15根节点子树\n\n   ​\t3.2. 父亲节点的兄弟节点为黑色或者为空(LL双红)\n\n   ![插入后](https://s2.loli.net/2024/07/08/aucWSd5ER9OrUnC.png)\n\n   同样的染色\n\n   ![染色后](https://www.helloimg.com/images/2022/08/16/ZQmSNn.png)\n\n   然后单旋即可\n\n   ​\t3.3.父节点在爷爷节点左侧，子节点在父节点右侧（LR双红）\n\n   ![LR双红](https://s2.loli.net/2024/07/08/F63bjkmUvHtXyiS.png)\n\n   对父亲节点左旋\n\n   ![左旋后](https://www.helloimg.com/images/2022/08/16/ZQmlr5.png)\n\n   ​\t3.4. 父节点在爷爷节点右侧，子节点在父节点右侧（RR双红）\n\n   ![img](https://s2.loli.net/2024/07/08/3rNOhnoLS4ECQuH.png)\n\n   染色爷爷并左旋\n\n   ​\t3.5. RL\n\n   ![img](https://www.helloimg.com/images/2022/08/16/ZQmD6S.png)\n\n   类似的步骤\n\n# 数学相关\n\n##卡特兰数(Catalan数列)\n\n适用于DS的问题\n\n- 栈\n  - n个元素入栈，求出栈序列个数\n- 二叉树\n  - n个节点能构成多少种不同形状的二叉树\n- 括号匹配\n  - n对括号有多少种括号匹配序列\n\n### 公式\n\n卡特兰数的地推公式如下\n$$\nH_n = \\left\\{\n\t\t\\begin{array}{cc}\n\t\t\\sum^n_{i=1} H_{i-1}H_{n-i}& n\\ge 2,n\\in N_+\\\\\n\t\t1&n=0,1\\\\\n\t\t\\end{array}\n\\right.\n$$\n\n\n递推关系的通项公式\n$$\nH_n = \\frac{\\binom{2n}{n}}{n+1}(n\\ge 2, n\\in N_+)\n$$\n常见的推广式\n$$\nH_n = \\frac{H_{n-1}(4n-2)}{n+1}\n\\\\\nH_n = \\binom{2n}{n}-\\binom{2n}{n-1}\n$$\n有关卡特兰数通项公式的证明需要用到卷积来构造有关H(x)的方程\n\n如下\n$$\n\\begin{aligned}\nH(x)&=\\sum _{n\\ge0} H_nx^n\\\\\n&=1+\\sum_{n\\ge1}\\sum_{i=0}^{n-1}H_ix^iH_{n-i-1}x^{n-i-1}x\\\\\n&=1+x\\sum_{i\\ge0}H_ix^i\\sum_{n\\ge0}H_nx^n\\\\\n&=1+xH^2(x)\n\\end{aligned}\n$$\n\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/DataStructure/FirstRoundReview","published":1,"updated":"2024-08-17T13:21:00.471Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqw003ym8wvhndseyd1","content":"<h1 id=\"数据结构相关\"><a href=\"#数据结构相关\" class=\"headerlink\" title=\"数据结构相关\"></a>数据结构相关</h1><h2 id=\"平衡二叉树的旋转\"><a href=\"#平衡二叉树的旋转\" class=\"headerlink\" title=\"平衡二叉树的旋转\"></a>平衡二叉树的旋转</h2><ol>\n<li>什么时候开始旋转</li>\n</ol>\n<p>插入或删除后使得树不平衡</p>\n<ol>\n<li>从插入（删除位置从下往上找最小不平衡子树<code>平衡因子大于1</code>）</li>\n<li>选出非叶子节点成子树，使得权值居中的节点成为子树的根</li>\n<li>根据中序遍历（权值大小树的中序遍历就是升序），叶子节点的父亲节点即中序中与它最近的非叶子节点</li>\n</ol>\n<p>详细的分类讨论旋转（更普遍的解）</p>\n<ol>\n<li>分类</li>\n</ol>\n<p>四种不平衡状态分别是LL,RR,LR,RL</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/ysV4joHWkYEup9d.png\" alt=\"LL\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/yJFpo9amCI4VLe7.png\" alt=\"RR\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/Diy7M4OPZnU2fGd.png\" alt=\"RR\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/IyKam2Nf6QVGlgd.png\" alt=\"RL\"></p>\n<p>具体的总结措施为，旋转将后两种状态转化为前两种状态，这种旋转的操作一般称其为单旋</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/lOEG6TmVXpkZiMQ.png\" alt=\"右单旋\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/IEOuAUBF34GKS7J.png\" alt=\"左单旋\"></p>\n<h2 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h2><h3 id=\"红黑树的限制\"><a href=\"#红黑树的限制\" class=\"headerlink\" title=\"红黑树的限制\"></a>红黑树的限制</h3><ul>\n<li>每个结点的颜色只有<strong>红色或黑色</strong>两种；</li>\n<li><strong>根结点</strong>的颜色一定是黑色的；</li>\n<li>如果某一个结点的颜色是红色的，它的两个孩子结点的颜色一定是黑色（即<strong>不存在两个连续的红色结点</strong>）；</li>\n<li>对于任一结点，到叶子结点的任一路径上，<strong>包含的黑色结点的数量</strong>一定<strong>相等</strong>；</li>\n<li>叶子结点一定是黑色的（这里的叶子结点指最后的<strong>nullptr</strong>）</li>\n</ul>\n<h3 id=\"红黑树有关问题\"><a href=\"#红黑树有关问题\" class=\"headerlink\" title=\"红黑树有关问题\"></a>红黑树有关问题</h3><p>可见对红黑树，最重要的问题有</p>\n<ul>\n<li>如何在保证确保从根到任何子节点经过的黑节点数是相同的</li>\n</ul>\n<p>由此延申考研中考红黑树插入（删除较为复杂，有时间再看）</p>\n<ol>\n<li><p>红黑树插入</p>\n<ol>\n<li>根节点为空</li>\n</ol>\n<p>直接设置黑色根节点</p>\n<ol>\n<li>父节点为黑色</li>\n</ol>\n<p>直接插入红色节点</p>\n<ol>\n<li><p>父节点为黑色</p>\n<p>3.1. 父节点的兄弟节点为红色</p>\n</li>\n</ol>\n<p>将父亲节点及兄弟节点染黑并将爷爷节点染红后旋转平衡树</p>\n<p><img src=\"https://www.helloimg.com/images/2022/08/16/ZQmvuT.png\" alt=\"原红黑树插入后\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/aXPMufosBOJt45m.png\" alt=\"染色后\"></p>\n<p>在此图中，解决方法为右单旋15根节点子树</p>\n<p>​    3.2. 父亲节点的兄弟节点为黑色或者为空(LL双红)</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/aucWSd5ER9OrUnC.png\" alt=\"插入后\"></p>\n<p>同样的染色</p>\n<p><img src=\"https://www.helloimg.com/images/2022/08/16/ZQmSNn.png\" alt=\"染色后\"></p>\n<p>然后单旋即可</p>\n<p>​    3.3.父节点在爷爷节点左侧，子节点在父节点右侧（LR双红）</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/F63bjkmUvHtXyiS.png\" alt=\"LR双红\"></p>\n<p>对父亲节点左旋</p>\n<p><img src=\"https://www.helloimg.com/images/2022/08/16/ZQmlr5.png\" alt=\"左旋后\"></p>\n<p>​    3.4. 父节点在爷爷节点右侧，子节点在父节点右侧（RR双红）</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/3rNOhnoLS4ECQuH.png\" alt=\"img\"></p>\n<p>染色爷爷并左旋</p>\n<p>​    3.5. RL</p>\n<p><img src=\"https://www.helloimg.com/images/2022/08/16/ZQmD6S.png\" alt=\"img\"></p>\n<p>类似的步骤</p>\n</li>\n</ol>\n<h1 id=\"数学相关\"><a href=\"#数学相关\" class=\"headerlink\" title=\"数学相关\"></a>数学相关</h1><h2 id=\"卡特兰数-Catalan数列\"><a href=\"#卡特兰数-Catalan数列\" class=\"headerlink\" title=\"卡特兰数(Catalan数列)\"></a>卡特兰数(Catalan数列)</h2><p>适用于DS的问题</p>\n<ul>\n<li>栈<ul>\n<li>n个元素入栈，求出栈序列个数</li>\n</ul>\n</li>\n<li>二叉树<ul>\n<li>n个节点能构成多少种不同形状的二叉树</li>\n</ul>\n</li>\n<li>括号匹配<ul>\n<li>n对括号有多少种括号匹配序列</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"公式\"><a href=\"#公式\" class=\"headerlink\" title=\"公式\"></a>公式</h3><p>卡特兰数的地推公式如下</p>\n<script type=\"math/tex; mode=display\">\nH_n = \\left\\{\n        \\begin{array}{cc}\n        \\sum^n_{i=1} H_{i-1}H_{n-i}& n\\ge 2,n\\in N_+\\\\\n        1&n=0,1\\\\\n        \\end{array}\n\\right.</script><p>递推关系的通项公式</p>\n<script type=\"math/tex; mode=display\">\nH_n = \\frac{\\binom{2n}{n}}{n+1}(n\\ge 2, n\\in N_+)</script><p>常见的推广式</p>\n<script type=\"math/tex; mode=display\">\nH_n = \\frac{H_{n-1}(4n-2)}{n+1}\n\\\\\nH_n = \\binom{2n}{n}-\\binom{2n}{n-1}</script><p>有关卡特兰数通项公式的证明需要用到卷积来构造有关H(x)的方程</p>\n<p>如下</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nH(x)&=\\sum _{n\\ge0} H_nx^n\\\\\n&=1+\\sum_{n\\ge1}\\sum_{i=0}^{n-1}H_ix^iH_{n-i-1}x^{n-i-1}x\\\\\n&=1+x\\sum_{i\\ge0}H_ix^i\\sum_{n\\ge0}H_nx^n\\\\\n&=1+xH^2(x)\n\\end{aligned}</script><!-- flag of hidden posts -->","length":868,"excerpt":"","more":"<h1 id=\"数据结构相关\"><a href=\"#数据结构相关\" class=\"headerlink\" title=\"数据结构相关\"></a>数据结构相关</h1><h2 id=\"平衡二叉树的旋转\"><a href=\"#平衡二叉树的旋转\" class=\"headerlink\" title=\"平衡二叉树的旋转\"></a>平衡二叉树的旋转</h2><ol>\n<li>什么时候开始旋转</li>\n</ol>\n<p>插入或删除后使得树不平衡</p>\n<ol>\n<li>从插入（删除位置从下往上找最小不平衡子树<code>平衡因子大于1</code>）</li>\n<li>选出非叶子节点成子树，使得权值居中的节点成为子树的根</li>\n<li>根据中序遍历（权值大小树的中序遍历就是升序），叶子节点的父亲节点即中序中与它最近的非叶子节点</li>\n</ol>\n<p>详细的分类讨论旋转（更普遍的解）</p>\n<ol>\n<li>分类</li>\n</ol>\n<p>四种不平衡状态分别是LL,RR,LR,RL</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/ysV4joHWkYEup9d.png\" alt=\"LL\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/yJFpo9amCI4VLe7.png\" alt=\"RR\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/Diy7M4OPZnU2fGd.png\" alt=\"RR\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/IyKam2Nf6QVGlgd.png\" alt=\"RL\"></p>\n<p>具体的总结措施为，旋转将后两种状态转化为前两种状态，这种旋转的操作一般称其为单旋</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/lOEG6TmVXpkZiMQ.png\" alt=\"右单旋\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/IEOuAUBF34GKS7J.png\" alt=\"左单旋\"></p>\n<h2 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h2><h3 id=\"红黑树的限制\"><a href=\"#红黑树的限制\" class=\"headerlink\" title=\"红黑树的限制\"></a>红黑树的限制</h3><ul>\n<li>每个结点的颜色只有<strong>红色或黑色</strong>两种；</li>\n<li><strong>根结点</strong>的颜色一定是黑色的；</li>\n<li>如果某一个结点的颜色是红色的，它的两个孩子结点的颜色一定是黑色（即<strong>不存在两个连续的红色结点</strong>）；</li>\n<li>对于任一结点，到叶子结点的任一路径上，<strong>包含的黑色结点的数量</strong>一定<strong>相等</strong>；</li>\n<li>叶子结点一定是黑色的（这里的叶子结点指最后的<strong>nullptr</strong>）</li>\n</ul>\n<h3 id=\"红黑树有关问题\"><a href=\"#红黑树有关问题\" class=\"headerlink\" title=\"红黑树有关问题\"></a>红黑树有关问题</h3><p>可见对红黑树，最重要的问题有</p>\n<ul>\n<li>如何在保证确保从根到任何子节点经过的黑节点数是相同的</li>\n</ul>\n<p>由此延申考研中考红黑树插入（删除较为复杂，有时间再看）</p>\n<ol>\n<li><p>红黑树插入</p>\n<ol>\n<li>根节点为空</li>\n</ol>\n<p>直接设置黑色根节点</p>\n<ol>\n<li>父节点为黑色</li>\n</ol>\n<p>直接插入红色节点</p>\n<ol>\n<li><p>父节点为黑色</p>\n<p>3.1. 父节点的兄弟节点为红色</p>\n</li>\n</ol>\n<p>将父亲节点及兄弟节点染黑并将爷爷节点染红后旋转平衡树</p>\n<p><img src=\"https://www.helloimg.com/images/2022/08/16/ZQmvuT.png\" alt=\"原红黑树插入后\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/08/aXPMufosBOJt45m.png\" alt=\"染色后\"></p>\n<p>在此图中，解决方法为右单旋15根节点子树</p>\n<p>​    3.2. 父亲节点的兄弟节点为黑色或者为空(LL双红)</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/aucWSd5ER9OrUnC.png\" alt=\"插入后\"></p>\n<p>同样的染色</p>\n<p><img src=\"https://www.helloimg.com/images/2022/08/16/ZQmSNn.png\" alt=\"染色后\"></p>\n<p>然后单旋即可</p>\n<p>​    3.3.父节点在爷爷节点左侧，子节点在父节点右侧（LR双红）</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/F63bjkmUvHtXyiS.png\" alt=\"LR双红\"></p>\n<p>对父亲节点左旋</p>\n<p><img src=\"https://www.helloimg.com/images/2022/08/16/ZQmlr5.png\" alt=\"左旋后\"></p>\n<p>​    3.4. 父节点在爷爷节点右侧，子节点在父节点右侧（RR双红）</p>\n<p><img src=\"https://s2.loli.net/2024/07/08/3rNOhnoLS4ECQuH.png\" alt=\"img\"></p>\n<p>染色爷爷并左旋</p>\n<p>​    3.5. RL</p>\n<p><img src=\"https://www.helloimg.com/images/2022/08/16/ZQmD6S.png\" alt=\"img\"></p>\n<p>类似的步骤</p>\n</li>\n</ol>\n<h1 id=\"数学相关\"><a href=\"#数学相关\" class=\"headerlink\" title=\"数学相关\"></a>数学相关</h1><h2 id=\"卡特兰数-Catalan数列\"><a href=\"#卡特兰数-Catalan数列\" class=\"headerlink\" title=\"卡特兰数(Catalan数列)\"></a>卡特兰数(Catalan数列)</h2><p>适用于DS的问题</p>\n<ul>\n<li>栈<ul>\n<li>n个元素入栈，求出栈序列个数</li>\n</ul>\n</li>\n<li>二叉树<ul>\n<li>n个节点能构成多少种不同形状的二叉树</li>\n</ul>\n</li>\n<li>括号匹配<ul>\n<li>n对括号有多少种括号匹配序列</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"公式\"><a href=\"#公式\" class=\"headerlink\" title=\"公式\"></a>公式</h3><p>卡特兰数的地推公式如下</p>\n<script type=\"math/tex; mode=display\">\nH_n = \\left\\{\n        \\begin{array}{cc}\n        \\sum^n_{i=1} H_{i-1}H_{n-i}& n\\ge 2,n\\in N_+\\\\\n        1&n=0,1\\\\\n        \\end{array}\n\\right.</script><p>递推关系的通项公式</p>\n<script type=\"math/tex; mode=display\">\nH_n = \\frac{\\binom{2n}{n}}{n+1}(n\\ge 2, n\\in N_+)</script><p>常见的推广式</p>\n<script type=\"math/tex; mode=display\">\nH_n = \\frac{H_{n-1}(4n-2)}{n+1}\n\\\\\nH_n = \\binom{2n}{n}-\\binom{2n}{n-1}</script><p>有关卡特兰数通项公式的证明需要用到卷积来构造有关H(x)的方程</p>\n<p>如下</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nH(x)&=\\sum _{n\\ge0} H_nx^n\\\\\n&=1+\\sum_{n\\ge1}\\sum_{i=0}^{n-1}H_ix^iH_{n-i-1}x^{n-i-1}x\\\\\n&=1+x\\sum_{i\\ge0}H_ix^i\\sum_{n\\ge0}H_nx^n\\\\\n&=1+xH^2(x)\n\\end{aligned}</script>"},{"title":"系统篇-补充","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"注：本文档中知识点为做题时查资料临时补充所得，若在正式知识复习中有所补充则转到目标位置\n\n---\n\n## 处理器调度\n\n> 题目链接:\n>\n> [编号1](..\\错题汇总草案-系统篇.md)\n\n①在处理中断的过程中；\n②进程在**操作系统内核程序**临界区中；\n③其他需要完全屏蔽中断的原子操作过程中；\n\n当进程处于临界区时,说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理机调度的，比如通常访问临界资源可能是慢速的外设（如打印机），如果在进程访问打印机时，不能处理机调度，那么系统的性能将是非常低的。\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/OperationSystem/补充.md","raw":"---\ntitle: 系统篇-补充\ndate: 2024-08-14 19:47:58\ntags: [操作系统, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n注：本文档中知识点为做题时查资料临时补充所得，若在正式知识复习中有所补充则转到目标位置\n\n---\n\n## 处理器调度\n\n> 题目链接:\n>\n> [编号1](..\\错题汇总草案-系统篇.md)\n\n①在处理中断的过程中；\n②进程在**操作系统内核程序**临界区中；\n③其他需要完全屏蔽中断的原子操作过程中；\n\n当进程处于临界区时,说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理机调度的，比如通常访问临界资源可能是慢速的外设（如打印机），如果在进程访问打印机时，不能处理机调度，那么系统的性能将是非常低的。\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/OperationSystem/补充","published":1,"updated":"2024-08-17T13:20:31.349Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqw0041m8wvc4r37tsc","content":"<p>注：本文档中知识点为做题时查资料临时补充所得，若在正式知识复习中有所补充则转到目标位置</p>\n<hr>\n<h2 id=\"处理器调度\"><a href=\"#处理器调度\" class=\"headerlink\" title=\"处理器调度\"></a>处理器调度</h2><blockquote>\n<p>题目链接:</p>\n<p><a href=\"..\\错题汇总草案-系统篇.md\">编号1</a></p>\n</blockquote>\n<p>①在处理中断的过程中；<br>②进程在<strong>操作系统内核程序</strong>临界区中；<br>③其他需要完全屏蔽中断的原子操作过程中；</p>\n<p>当进程处于临界区时,说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理机调度的，比如通常访问临界资源可能是慢速的外设（如打印机），如果在进程访问打印机时，不能处理机调度，那么系统的性能将是非常低的。</p>\n<!-- flag of hidden posts -->","length":196,"excerpt":"","more":"<p>注：本文档中知识点为做题时查资料临时补充所得，若在正式知识复习中有所补充则转到目标位置</p>\n<hr>\n<h2 id=\"处理器调度\"><a href=\"#处理器调度\" class=\"headerlink\" title=\"处理器调度\"></a>处理器调度</h2><blockquote>\n<p>题目链接:</p>\n<p><a href=\"..\\错题汇总草案-系统篇.md\">编号1</a></p>\n</blockquote>\n<p>①在处理中断的过程中；<br>②进程在<strong>操作系统内核程序</strong>临界区中；<br>③其他需要完全屏蔽中断的原子操作过程中；</p>\n<p>当进程处于临界区时,说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理机调度的，比如通常访问临界资源可能是慢速的外设（如打印机），如果在进程访问打印机时，不能处理机调度，那么系统的性能将是非常低的。</p>\n"},{"title":"数构篇-补充","date":"2024-08-14T11:47:58.000Z","hidden":true,"_content":"注：本文档中知识点为做题时查资料临时补充所得，若在正式知识复习中有所补充则转到目标位置\n\n---\n\n## 线索二叉树\n\n### 线索化\n\n线索化是一种在建立二叉树得同时记录下前驱后继得关系，提升寻找前驱后继节点效率的方法。\n\n现将某结点的空指针域指向该结点的前驱后继，定义规则如下：\n\n- 若结点的左子树为空，则该结点的左孩子指针指向其前驱结点\n- 若结点的右子树为空，则该结点的右孩子指针指向其后继结点\n\n这种指向前驱和后继的 **指针** 称为 **线索**，将一棵普通的二叉树以某种次序遍历，并添加线索的过程称为线索化。\n\n### 线索化的问题与解决方式\n\n区分左右节点与前驱后继节点\n\n通过 **ltag, rtag** 区分\n\n## 二叉树的遍历序\n\n### 先序中序与后序遍历的性质\n\n1. 先序：根，左，右；中序；左，根，右；后序：左、右、根\n\n2. 先序与后序是不能确定一个二叉树的\n\n## 树，森林与二叉树的转换\n\n### 树转换为二叉树\n\n步骤：\n\n1. 加线：在所有兄弟结点之间加一条线。\n2. 去线：对树中每个结点，**只保留它与第一个孩子结点** 的连线，删除它与其他孩子结点之间的连线。\n3. 层次调整：以树的根结点为轴心，将整棵树顺时针旋转一定的角度，将整棵树一定的角度，使之结构层次分明。注意第一个孩子结点是二叉树结点的左孩子，兄弟转换过来的孩子是结点的孩子。\n\n![树到二叉树之间的转换](https://s2.loli.net/2024/07/25/sUzCdIjYmAQfGrZ.png)\n\n### 森林转化为二叉树\n\n森林是由若干棵树组成的，所以完全可以理解为，森林中的每一个树都是兄弟，可以按照兄弟的办法来操作。\n\n1. 把每棵树转换为二叉树。\n2. 第一棵二叉树不动，从第二棵二叉树开始，依次 **把后一颗二叉树的根结点作为前一棵二叉树的根结点的右孩子**，用线连接起来。当所有的二叉树连接起来后，就得到了森林转换来的二叉树\n\n![森林到二叉树](https://s2.loli.net/2024/07/25/n1owABbziHOQcUr.png)\n\n### 二叉树转换为树\n\n二叉树转换为树是是转化为二叉树的逆过程，也就是反过来而已。如图所示。步骤如下\n\n1. 加线：若某结点的左孩子结点存在，则将这个左孩子的右孩子的结点，右孩子的右孩子结点……反正就是左孩子的 n 个右孩子结点都作为此结点的孩子，将结点与这些孩子结点用线连接起来。\n2. 去线：删除原二叉树中所有结点与其右孩子结点的连线。\n3. 层次调整\n\n![二叉树到树](https://s2.loli.net/2024/07/25/lCShs9eEvNcJBpd.png)\n\n### 二叉树到森林\n\n判断一棵二叉树能够转换成一棵树还是森林，标准很简答，那就是只要这课二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。那么如果是转换成森林，步骤如下：\n\n1. 从根结点开始，若右孩子存在，则 **把右孩子结点的连线删除**，在查看分离后的二叉树，若右孩子存在，则连线删除......，直到所有的右孩子连线都删除为止，得到分离后的二叉树。\n2. 在将每棵分离后的二叉树转换为树即可。\n\n## 树的表示方法\n\n这里补充三种对数的表示方法\n\n### 双亲表示法\n\n我们假设以一段连续空间存储树的结点，同时 **在每个结点中，附设一个指示器指示其双亲结点到链表中的位置**。也就是说，每个结点除了直到自己是谁外，还要直到自己的双亲在哪里。如图：![双亲表示法节点图](https://s2.loli.net/2024/07/25/DMvbQVnXydagUEk.png)\n\n实际上这种表示方法与一个数组记录每个节点的父节点相同，根节点的父节点为-1\n\n### 孩子表示法\n\n这种表示法类似邻接表，记录每个节点的所有孩子。\n\n显然，这样的表示方法对数据结构有要求，如何判断每个节点的孩子记录需要多少空间，有三个方法\n\n1. 以树的度作为每个节点的孩子数量\n\n   ![孩子表示法 1](https://s2.loli.net/2024/07/25/vI7Np9Mf2h14YCL.png)\n\n2. 每个结点指针域的个数等于该结点的度，我们专门来取一个位置来存储结点指针域的个数。\n\n   <img src=\"https://s2.loli.net/2024/07/25/WrMLCNsfjcYSOap.pn\" alt=\"孩子表示法2数据结构\"  /> ![孩子表示法 2](https://i-blog.csdnimg.cn/blog_migrate/877d911bcbfb63fdd235137138cfa5b8.png)\n\n3. 真正的邻接表\n\n   ![孩子表示法第三个方法](https://s2.loli.net/2024/07/25/2WtkbVTGIAhLXKR.png)\n\n#### 扩展：双亲孩子表示法\n\n即对每一个节点加一个双亲域。\n\n![双亲孩子表示法](https://s2.loli.net/2024/07/25/Iyj7s6LWoh451RO.png)\n\n### 孩子兄弟表示法\n\n**任何一棵树，它的结点的第一个孩子如果是唯一的，它的右兄弟如果存在也是唯一的，因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。**\n\n![孩子兄弟表示法节点结构](https://s2.loli.net/2024/07/25/j7CT9kvuRAXdQhM.png)\n\n![孩子兄弟表示法树形结构](https://s2.loli.net/2024/07/25/PXI1x6m8DVCcBEg.png)\n\n## 实际算法使用与题目当中的区别\n\n### 二分\n\n直接上例子\n\n对 A1-A18 找目标元素 A3\n\n1. $\\left\\lfloor(1+18)/2\\right\\rfloor = 9$\n2. $A1\\cdots A8 \\to A4$\n3. $A1\\cdots A3 \\to A2$\n4. $A2\\cdots A3 \\to A3$\n\n因此查找顺序为 9,4,2,3，可以注意到每次排除了二分的 flag，这是与实际不同的。\n\n### 排序算法\n\n![排序算法](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725111145849.png)\n\n不稳定排序：**快选希堆**（快速排序，选择排序，希尔排序，堆排序）\n\n快排的时间复杂度是 O(log2n)，归并排序的空间复杂度是 O(n)\n\n快速排序一般选用左端为 flag，且左右指针一般先动右指针\n\n快速排序的速度与序列的关系是\n\n1. **越有序的越慢**\n\n2. 划分越均匀的越快\n\n3. 当前两条相同时我们尝试手动快排一次，然后对左右在应用 1，2 原则\n\n> 例如对：\n>\n> A. 21, 25, 5, 17, 9, 23, 30\tB. 25, 23, 30, 17, 21, 5, 9\n> C.21, 9,17, 30,25, 23,5\t\tD.5,9,17,21,23,25,30\n>\n> 首先根据前两个原则确定 BD 均不快\n>\n> 温习一下快排，手动尝试 AC 分别是\n>\n> 9，17，5，(21)，25，23，30\n>\n> 5，9，17，(21)，25，23，30\n>\n> 这四个序列而言对快排的效率从小到大依次是 D、B、C、A\n\n#### 一些不常用的排序算法\n\n1. 堆排序\n\n排序思想\n\n1. 首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端\n\n2. 将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为 n-1\n\n3. 将剩余的 n-1 个数再构造成大根堆，再将顶端数与 n-1 位置的数交换，如此反复执行，便能得到有序数组\n\n   注意: 升序用大根堆，降序就用小根堆(默认为升序)\n\n4. 希尔排序\n\n{98，36，-9，0，47，23，1，8，10，7}，希尔排序，步长是 4\n\n1. 按照步长分组\n2. 组内简单插入排序\n\n10,7,-9,0,47,23,1,8,98,36\n\n## 二叉判定树\n\n二叉判定树是用于精确判定有限次二分的精确平均比较次数（ASL Average Search Length 平均比较次数）的一种生成式数据结构，对一个 R12 的有序表，有以下二叉判定树\n\n![二叉判定树](https://s2.loli.net/2024/08/01/hEJ9OUcqgIbVimW.png)\n\n## 归并段与最佳归并树与多路平衡归并\n\n**归并段** 顾名思义，其就是一段等待归并的有序字段\n\n最佳归并树的概念依托于最小带权哈夫曼树，最小带权哈夫曼树定义是带权路径和最小的哈夫曼树，哈夫曼树带权路径长度为叶子结点的到根节点的路径长度乘以叶子节点上值得乘积。加权路径长度是归并树的重要属性，其英文全程是 Weighted Path Length WPL。\n\n要理解为何会有最佳归并树的最佳概念，先看一个较简单较劣的算法即多路归并算法。\n\n例如，初始归并段的长度分别为：[9，30，12，18，3，17，2，6，24]，如果使用 3-路归并，则其归并树如下\n\n![3-路归并](https://s2.loli.net/2024/08/02/BjoY4Kksg2HT89n.png)\n\n整个归并需要对外存的读写次数为 484，恰好为 **归并树带权路径长度的四倍**。\n\n而哈夫曼树树就是在多路归并树的基础上采取哈夫曼树的构造方式，与传统的二叉哈夫曼树不同的地方在于，此处的哈夫曼树可以是更高度数的。用标准表述就是 `n路最佳归并树`\n\n**虚段** 的概念源于对 2 度以上哈夫曼树的补充，它将那些度数小于哈夫曼树度的节点补上长度为 0 的段，归一化整体哈夫曼树的结构。\n\n那么到底如何确定添加的虚段的数量呢?\n一般的，假设分段数为 $n$，最佳归并树的路数为 $k$，若 $( m − 1 )\\mod( k − 1 ) = 0$ ，则不用加虚段，否则需要增加 $ k − ( m − 1 )\\mod( k − 1 ) − 1$ 个虚段。(第一次归并为 $( m − 1 )\\mod( k − 1 ) + 1$ 路归并 )。\n\n> 设有 13 个初始归并段，长度分别为 [28,16,37,42,5,9,13,14,20,17,30,12,18]。则 4 路最佳归并树的带权路径长度 WPL 为\n>\n> A 261\n> B 438\n> C 480\n> D 522\n>\n> <details>\n>     【解析】C。\n>      n = 13, k = 4。 (n-1)%(k-1)= 0,\n> 不需加虚段。最佳归并树如图所示。\n> WPL =(5+9+12+13+14+ 16+17+18+20\n> 28+30+37)X2+42 = 480。\n>                               <img src=\"https://s2.loli.net/2024/08/02/o5BS6EJANxeOI9b.png\" alt=\"image-20240802113500129\" />\n>     </details>\n\n\n\n## 外部排序\n\n[数据结构与算法系列——排序(15)_外部排序 - 海米傻傻 - 博客园 (cnblogs.com)](https://www.cnblogs.com/haimishasha/p/10898715.html)\n\n1. 实现外部排序的 **两个过程**：\n   1. 将整个初始文件分为多个初始归并段;\n   2. 将初始归并段进行归并，直至得到一个有序的完整文件；\n\n2. 时间开销构成\n   1. **内部排序** 所需要的时间\n   2. **外存信息读写** 所需要的时间 （关键） \n      - 与归并的趟数有关 \n        - k 要大 —– 传统方法 会引起内部归并时间增大 \n          - 赢者树\n          - 败者树（目的：提高在 k 个归并串中当前值中找到最小值的效率）\n        - m 要小 —– 置换选择排序\n      - Huffman（归并的顺序，对外存的 I/O 次数降到最低）\n   3. **内部归并** 所需要的时间\n3. 为了提高整个外部排序的效率，分别从以上 **两个方面对外部排序** 进行了优化：\n   1. 在实现将初始文件分为 m 个初始归并段时，为了尽量减小 m 的值，**采用置换-选择排序算法(内部使用败者树实现)**，可实现将整个初始文件分为数量较少的长度不等的初始归并段。\n   2. 同时在将初始归并段归并为有序完整文件的过程中，为了尽量减少读写外存的次数，采用 **构建最佳归并树的方式（哈夫曼树实现），对初始归并段进行归并（败者树实现）**，而归并的具体实现方法是采用败者树的方式。\n4. **优化递进顺序：**\n   1. 二路归并【因为硬盘的读写速度比内存要慢的多，按照以上这种方法，每个数据都从硬盘读了三次，写了三次，要花很多时间。考虑 K 路】\n   2. 多路归并【K 不是越大越好，因为 K 越大，在内部排序需要的时间越长，效率低。考虑减少初始顺串的数量 M】\n   3. 置换选择算法【可以用败者树和堆排序实现，得到多个长度不等的初始归并段，如何设置它们的归并顺序，可以使得对外存的访问次数降到最低? 考虑结合哈夫曼树】\n   4. 最佳归并树（置换选择算法+哈夫曼树+多路归并+败者树）\n\n　外部排序算法由两个阶段构成：预处理和合并排序。\n\n1. **预处理产生有序的顺串：** 按照内存大小，将外存上含有 n 个纪录的大文件分成若干长度为 t 的子文件（t 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对子文件的 t 个纪录进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；这样在外存上就得到了 m 个顺串（m = [n/t]）。\n2. **合并序列：** 对得到的顺段进行合并，直至得到整个有序的文件为止。\n\n### k-路平衡归并\n\n![img](https://s2.loli.net/2024/08/02/c8UeXugYZIFbjOl.jpg)\n\n在 2G 内存中排序的时候可以选择合适的 **内部排序**，比如快速排序或归并排序等算法。为了方便，我们把排序好的 2G 有序数据称为有序子串。接着把两个小的有序子串合并成一个大的有序子串。\n\n![img](https://s2.loli.net/2024/08/02/3R8r9YqgAvufFl1.jpg)\n\n假设需要排序的int数有12个，内存一次只能装下3个int数。\n\n![k-路平衡归并1](https://s2.loli.net/2024/08/02/YzvG5B4lec2m9pS.jpg)\n\n 接下来把12个数据分成4份，然后排序成有序子串：\n\n![k-路平衡归并2](https://s2.loli.net/2024/08/02/2alThnoFmOAbvfp.jpg)\n\n 然后把子串进行两两合并：\n\n![k-路平衡归并3](https://s2.loli.net/2024/08/02/tHhCWegpjKd9MJ8.jpg)\n\n  输出哪个元素就在那个元素所在的有序子串再次读入一个元素：\n\n![k-路平衡归并4](https://s2.loli.net/2024/08/02/jwtZ3Emdc7Wilnk.jpg)\n\n![k-路平衡归并5](https://s2.loli.net/2024/08/02/KdEQi3msxPY7cfU.jpg)\n\n重复直到合并成一个包含6个int有序子串，再把两个包含6个int的有序子串合并成一个包含12个int数据的最终有序子串\n\n![k-路平衡归并6](https://s2.loli.net/2024/08/02/tgsRBFyWH7jafVu.jpg)\n\n### 多路归并\n\n**对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多**。8.1 中图中使用的是 2-路平衡归并的方式，举一反三，还可以使用 3-路归并、4-路归并甚至是 10-路归并的方式。\n\n对于 k-路平衡归并中 k 值得选择，**增加 k 可以减少归并的次数**，从而**减少外存读写的次数**，最终达到提高算法效率的目的。除此之外，一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，归并的次数为：**s=⌊logk⁡m ⌋**（其中 s 表示归并次数）。\n\n从公式上可以判断出，想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：\n\n- **增加 k-路平衡归并中的 k 值；[但不能影响内部归并的效率]**\n- **尽量减少初始归并段的数量 m，即增加每个归并段的容量；**\n\n> **其增加 k 值的想法引申出了一种外部排序算法：多路平衡归并算法；增加数量 m 的想法引申出了另一种外部排序算法：置换-选择排序算法。**\n\n### 多路平衡归并排序（胜者树、败者树）\n\n1. 胜者树\n\n   ![胜者二叉树](https://s2.loli.net/2024/08/02/sIUWdA1wTFC3Rmq.png)\n\n   当我们将我们的胜者树的最优值输入到我们的输出缓冲区（**输出缓冲区从内存中额外开辟出来的一段，我们存储当前的归并的结果，缓冲区满写入磁盘**）\n   之后，我们的根节点便出现了空的情况，**我们需要从根节点对应的输入缓冲区中在读入一个数据来充当下一次比较的选手**，然后**从下到上进行维护**，我们的每一次的维护都需要比较兄弟的胜者然后选出新一轮的胜者然后一直优化到我们的根的路径上（从低至上，贯穿整个树)之后我们不断地进行上述的操作，指导我们的所有的输入缓冲区已经为空为止。\n\n**胜者树和败者树的区别就是：胜者树中的非终端结点中存储的是胜利的一方；而败者树中的非终端结点存储的是失败的一方。而在比较过程中，都是拿胜者去比较。**\n\n### 置换选择排序算法\n\n![置换选择排序算法](https://s2.loli.net/2024/08/02/FniZuMpjCGgAySR.png)\n\n![置换选择排序算法2](https://s2.loli.net/2024/08/02/OlN4FT13zHn9yBb.png)\n\n例如已知初始文件中总共有 24 个记录，假设内存工作区最多可容纳 6 个记录，按照之前的选择排序算法最少也只能分为 4 个初始归并段。而如果使用置换—选择排序，可以实现将 24 个记录分为 3 个初始归并段\n\n![置换选择排序算法3](https://s2.loli.net/2024/08/02/zewPVMgiTRXCrEj.png)\n\n　置换—选择排序算法的具体操作过程为：\n\n1. 首先从初始文件中输入 6 个记录到内存工作区中；\n   2. 从内存工作区中选出关键字最小的记录，将其记为 MINIMAX 记录；\n   3. 然后将 MINIMAX 记录输出到归并段文件中；\n   4. 此时内存工作区中还剩余 5 个记录，若初始文件不为空，则从初始文件中输入下一个记录到内存工作区中；\n   5. 从内存工作区中的所有比 MINIMAX 值大的记录中选出值最小的关键字的记录，作为新的 MINIMAX 记录；[使用败者树或者堆排序实现]\n   6. 重复过程 3—5，直至在内存工作区中选不出新的 MINIMAX 记录为止，由此就得到了一个初始归并段；\n   7. 重复 2—6，直至内存工作为空，由此就可以得到全部的初始归并段。\n\n### 胜者树、败者树与堆排序\n\n#### 概念\n\n- **堆**：其实一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后再用孩子节点的最小值和父节点进行比较，所以每调整一层需要比较两次。 \n\n- **胜者树**：这时人们想能否简化比较过程，这时就有了胜者树，这样每次比较只用跟自己的兄弟节点进行比较就好，所以用胜者树可以比堆少一半的比较次数。 而胜者树在节点上升的时候首选需要获得父节点，然后再获得兄弟节点，然后再比较。\n\n- **败者树**：这时人们又想能否再次减少比较次数，于是就有了败者树。在使用败者树的时候，每个新元素上升时，只需要获得父节点并比较即可。 \n\n所以总的来说，减少了访存的时间。 现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了。**在外部排序中通常使用败者树。**\n\n---\n\n胜者树的特点：\n1、胜者树，是一棵完全二叉树\n2、每个叶子节点表示一个选手，记录选手的标号\n3、每个非叶子节点表示一场比赛，记录胜者的标号，而每层也就表示一轮比赛\n\n---\n\n败者树：\n1、败者树，也是一颗完全二叉树\n2、每个叶子节点表示一个选手，记录选手的标号\n3、每个非叶子节点表示一场比赛，记录败者的标号，胜者晋级上一层。并且，因为树根节点记录的是败者的标号，会再新建一个节点记录最终胜者的标号。\n\n---\n\n#### 异同点\n\n三者的相同点在于空间和时间复杂度都是 Ologn)级别的\n\n不同点\n\n- **堆**：所有的节点都是关键字； 每次调整一层需要比较两次（父亲 左孩子| 父亲 右孩子）。 \n- **胜者树**：叶子节点是关键字，非叶子节点保存胜者索引；**每次调整一层需比较 1 次（自己 兄弟），读取两次（父亲| 兄弟）**。\n- **败者树**：叶子节点是关键字，非叶子节点保存败者索引；**每次调整一层需要比较 1 次（自己 父亲），读取一次（父亲），只需要和路径上的节点比较，不需要和兄弟节点比较**，简化了重构的过程。； 新增 B [0] 记录比赛的胜者【在本例子中是 ls [0]】\n\n#### 胜者树败者树重构阐述\n\n1. 胜者树\n\n   ![胜者树结构](https://s2.loli.net/2024/08/02/i4mZ3sOkxlHFBgD.png) 将 b3 替换成 11，胜者树重构示例：\n\n   ![胜者树重构](https://s2.loli.net/2024/08/02/eBYMU2ojSV4fHsQ.png)\n\n   重构过程中，先取到父节点的值，拿到选手对应的标号，然后再根据标号拿到选手的值和新插入选手的值比较，胜者写到父节点。\n\n2. 败者树\n\n   ![败者树结构](https://img2020.cnblogs.com/blog/2499424/202109/2499424-20210918155013278-334692385.png)\n\n   将 b3 替换为 13，败者树重构示例：\n\n   ![败者树重构](https://img2020.cnblogs.com/blog/2499424/202109/2499424-20210918155045828-280607642.png)\n\n   重构上比胜者树有优化，只需要取父节点的值并进行比较\n","source":"_posts/special_subject/NationalPGExamination/ProfessionalCources/DataStructure/补充.md","raw":"---\ntitle: 数构篇-补充\ndate: 2024-08-14 19:47:58\ntags: [数据结构, 考研]\ncategories: \n\t- 专题\n\t- 考研科目复习\n\t- 专业课\nhidden: true\n---\n注：本文档中知识点为做题时查资料临时补充所得，若在正式知识复习中有所补充则转到目标位置\n\n---\n\n## 线索二叉树\n\n### 线索化\n\n线索化是一种在建立二叉树得同时记录下前驱后继得关系，提升寻找前驱后继节点效率的方法。\n\n现将某结点的空指针域指向该结点的前驱后继，定义规则如下：\n\n- 若结点的左子树为空，则该结点的左孩子指针指向其前驱结点\n- 若结点的右子树为空，则该结点的右孩子指针指向其后继结点\n\n这种指向前驱和后继的 **指针** 称为 **线索**，将一棵普通的二叉树以某种次序遍历，并添加线索的过程称为线索化。\n\n### 线索化的问题与解决方式\n\n区分左右节点与前驱后继节点\n\n通过 **ltag, rtag** 区分\n\n## 二叉树的遍历序\n\n### 先序中序与后序遍历的性质\n\n1. 先序：根，左，右；中序；左，根，右；后序：左、右、根\n\n2. 先序与后序是不能确定一个二叉树的\n\n## 树，森林与二叉树的转换\n\n### 树转换为二叉树\n\n步骤：\n\n1. 加线：在所有兄弟结点之间加一条线。\n2. 去线：对树中每个结点，**只保留它与第一个孩子结点** 的连线，删除它与其他孩子结点之间的连线。\n3. 层次调整：以树的根结点为轴心，将整棵树顺时针旋转一定的角度，将整棵树一定的角度，使之结构层次分明。注意第一个孩子结点是二叉树结点的左孩子，兄弟转换过来的孩子是结点的孩子。\n\n![树到二叉树之间的转换](https://s2.loli.net/2024/07/25/sUzCdIjYmAQfGrZ.png)\n\n### 森林转化为二叉树\n\n森林是由若干棵树组成的，所以完全可以理解为，森林中的每一个树都是兄弟，可以按照兄弟的办法来操作。\n\n1. 把每棵树转换为二叉树。\n2. 第一棵二叉树不动，从第二棵二叉树开始，依次 **把后一颗二叉树的根结点作为前一棵二叉树的根结点的右孩子**，用线连接起来。当所有的二叉树连接起来后，就得到了森林转换来的二叉树\n\n![森林到二叉树](https://s2.loli.net/2024/07/25/n1owABbziHOQcUr.png)\n\n### 二叉树转换为树\n\n二叉树转换为树是是转化为二叉树的逆过程，也就是反过来而已。如图所示。步骤如下\n\n1. 加线：若某结点的左孩子结点存在，则将这个左孩子的右孩子的结点，右孩子的右孩子结点……反正就是左孩子的 n 个右孩子结点都作为此结点的孩子，将结点与这些孩子结点用线连接起来。\n2. 去线：删除原二叉树中所有结点与其右孩子结点的连线。\n3. 层次调整\n\n![二叉树到树](https://s2.loli.net/2024/07/25/lCShs9eEvNcJBpd.png)\n\n### 二叉树到森林\n\n判断一棵二叉树能够转换成一棵树还是森林，标准很简答，那就是只要这课二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。那么如果是转换成森林，步骤如下：\n\n1. 从根结点开始，若右孩子存在，则 **把右孩子结点的连线删除**，在查看分离后的二叉树，若右孩子存在，则连线删除......，直到所有的右孩子连线都删除为止，得到分离后的二叉树。\n2. 在将每棵分离后的二叉树转换为树即可。\n\n## 树的表示方法\n\n这里补充三种对数的表示方法\n\n### 双亲表示法\n\n我们假设以一段连续空间存储树的结点，同时 **在每个结点中，附设一个指示器指示其双亲结点到链表中的位置**。也就是说，每个结点除了直到自己是谁外，还要直到自己的双亲在哪里。如图：![双亲表示法节点图](https://s2.loli.net/2024/07/25/DMvbQVnXydagUEk.png)\n\n实际上这种表示方法与一个数组记录每个节点的父节点相同，根节点的父节点为-1\n\n### 孩子表示法\n\n这种表示法类似邻接表，记录每个节点的所有孩子。\n\n显然，这样的表示方法对数据结构有要求，如何判断每个节点的孩子记录需要多少空间，有三个方法\n\n1. 以树的度作为每个节点的孩子数量\n\n   ![孩子表示法 1](https://s2.loli.net/2024/07/25/vI7Np9Mf2h14YCL.png)\n\n2. 每个结点指针域的个数等于该结点的度，我们专门来取一个位置来存储结点指针域的个数。\n\n   <img src=\"https://s2.loli.net/2024/07/25/WrMLCNsfjcYSOap.pn\" alt=\"孩子表示法2数据结构\"  /> ![孩子表示法 2](https://i-blog.csdnimg.cn/blog_migrate/877d911bcbfb63fdd235137138cfa5b8.png)\n\n3. 真正的邻接表\n\n   ![孩子表示法第三个方法](https://s2.loli.net/2024/07/25/2WtkbVTGIAhLXKR.png)\n\n#### 扩展：双亲孩子表示法\n\n即对每一个节点加一个双亲域。\n\n![双亲孩子表示法](https://s2.loli.net/2024/07/25/Iyj7s6LWoh451RO.png)\n\n### 孩子兄弟表示法\n\n**任何一棵树，它的结点的第一个孩子如果是唯一的，它的右兄弟如果存在也是唯一的，因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。**\n\n![孩子兄弟表示法节点结构](https://s2.loli.net/2024/07/25/j7CT9kvuRAXdQhM.png)\n\n![孩子兄弟表示法树形结构](https://s2.loli.net/2024/07/25/PXI1x6m8DVCcBEg.png)\n\n## 实际算法使用与题目当中的区别\n\n### 二分\n\n直接上例子\n\n对 A1-A18 找目标元素 A3\n\n1. $\\left\\lfloor(1+18)/2\\right\\rfloor = 9$\n2. $A1\\cdots A8 \\to A4$\n3. $A1\\cdots A3 \\to A2$\n4. $A2\\cdots A3 \\to A3$\n\n因此查找顺序为 9,4,2,3，可以注意到每次排除了二分的 flag，这是与实际不同的。\n\n### 排序算法\n\n![排序算法](./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725111145849.png)\n\n不稳定排序：**快选希堆**（快速排序，选择排序，希尔排序，堆排序）\n\n快排的时间复杂度是 O(log2n)，归并排序的空间复杂度是 O(n)\n\n快速排序一般选用左端为 flag，且左右指针一般先动右指针\n\n快速排序的速度与序列的关系是\n\n1. **越有序的越慢**\n\n2. 划分越均匀的越快\n\n3. 当前两条相同时我们尝试手动快排一次，然后对左右在应用 1，2 原则\n\n> 例如对：\n>\n> A. 21, 25, 5, 17, 9, 23, 30\tB. 25, 23, 30, 17, 21, 5, 9\n> C.21, 9,17, 30,25, 23,5\t\tD.5,9,17,21,23,25,30\n>\n> 首先根据前两个原则确定 BD 均不快\n>\n> 温习一下快排，手动尝试 AC 分别是\n>\n> 9，17，5，(21)，25，23，30\n>\n> 5，9，17，(21)，25，23，30\n>\n> 这四个序列而言对快排的效率从小到大依次是 D、B、C、A\n\n#### 一些不常用的排序算法\n\n1. 堆排序\n\n排序思想\n\n1. 首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端\n\n2. 将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为 n-1\n\n3. 将剩余的 n-1 个数再构造成大根堆，再将顶端数与 n-1 位置的数交换，如此反复执行，便能得到有序数组\n\n   注意: 升序用大根堆，降序就用小根堆(默认为升序)\n\n4. 希尔排序\n\n{98，36，-9，0，47，23，1，8，10，7}，希尔排序，步长是 4\n\n1. 按照步长分组\n2. 组内简单插入排序\n\n10,7,-9,0,47,23,1,8,98,36\n\n## 二叉判定树\n\n二叉判定树是用于精确判定有限次二分的精确平均比较次数（ASL Average Search Length 平均比较次数）的一种生成式数据结构，对一个 R12 的有序表，有以下二叉判定树\n\n![二叉判定树](https://s2.loli.net/2024/08/01/hEJ9OUcqgIbVimW.png)\n\n## 归并段与最佳归并树与多路平衡归并\n\n**归并段** 顾名思义，其就是一段等待归并的有序字段\n\n最佳归并树的概念依托于最小带权哈夫曼树，最小带权哈夫曼树定义是带权路径和最小的哈夫曼树，哈夫曼树带权路径长度为叶子结点的到根节点的路径长度乘以叶子节点上值得乘积。加权路径长度是归并树的重要属性，其英文全程是 Weighted Path Length WPL。\n\n要理解为何会有最佳归并树的最佳概念，先看一个较简单较劣的算法即多路归并算法。\n\n例如，初始归并段的长度分别为：[9，30，12，18，3，17，2，6，24]，如果使用 3-路归并，则其归并树如下\n\n![3-路归并](https://s2.loli.net/2024/08/02/BjoY4Kksg2HT89n.png)\n\n整个归并需要对外存的读写次数为 484，恰好为 **归并树带权路径长度的四倍**。\n\n而哈夫曼树树就是在多路归并树的基础上采取哈夫曼树的构造方式，与传统的二叉哈夫曼树不同的地方在于，此处的哈夫曼树可以是更高度数的。用标准表述就是 `n路最佳归并树`\n\n**虚段** 的概念源于对 2 度以上哈夫曼树的补充，它将那些度数小于哈夫曼树度的节点补上长度为 0 的段，归一化整体哈夫曼树的结构。\n\n那么到底如何确定添加的虚段的数量呢?\n一般的，假设分段数为 $n$，最佳归并树的路数为 $k$，若 $( m − 1 )\\mod( k − 1 ) = 0$ ，则不用加虚段，否则需要增加 $ k − ( m − 1 )\\mod( k − 1 ) − 1$ 个虚段。(第一次归并为 $( m − 1 )\\mod( k − 1 ) + 1$ 路归并 )。\n\n> 设有 13 个初始归并段，长度分别为 [28,16,37,42,5,9,13,14,20,17,30,12,18]。则 4 路最佳归并树的带权路径长度 WPL 为\n>\n> A 261\n> B 438\n> C 480\n> D 522\n>\n> <details>\n>     【解析】C。\n>      n = 13, k = 4。 (n-1)%(k-1)= 0,\n> 不需加虚段。最佳归并树如图所示。\n> WPL =(5+9+12+13+14+ 16+17+18+20\n> 28+30+37)X2+42 = 480。\n>                               <img src=\"https://s2.loli.net/2024/08/02/o5BS6EJANxeOI9b.png\" alt=\"image-20240802113500129\" />\n>     </details>\n\n\n\n## 外部排序\n\n[数据结构与算法系列——排序(15)_外部排序 - 海米傻傻 - 博客园 (cnblogs.com)](https://www.cnblogs.com/haimishasha/p/10898715.html)\n\n1. 实现外部排序的 **两个过程**：\n   1. 将整个初始文件分为多个初始归并段;\n   2. 将初始归并段进行归并，直至得到一个有序的完整文件；\n\n2. 时间开销构成\n   1. **内部排序** 所需要的时间\n   2. **外存信息读写** 所需要的时间 （关键） \n      - 与归并的趟数有关 \n        - k 要大 —– 传统方法 会引起内部归并时间增大 \n          - 赢者树\n          - 败者树（目的：提高在 k 个归并串中当前值中找到最小值的效率）\n        - m 要小 —– 置换选择排序\n      - Huffman（归并的顺序，对外存的 I/O 次数降到最低）\n   3. **内部归并** 所需要的时间\n3. 为了提高整个外部排序的效率，分别从以上 **两个方面对外部排序** 进行了优化：\n   1. 在实现将初始文件分为 m 个初始归并段时，为了尽量减小 m 的值，**采用置换-选择排序算法(内部使用败者树实现)**，可实现将整个初始文件分为数量较少的长度不等的初始归并段。\n   2. 同时在将初始归并段归并为有序完整文件的过程中，为了尽量减少读写外存的次数，采用 **构建最佳归并树的方式（哈夫曼树实现），对初始归并段进行归并（败者树实现）**，而归并的具体实现方法是采用败者树的方式。\n4. **优化递进顺序：**\n   1. 二路归并【因为硬盘的读写速度比内存要慢的多，按照以上这种方法，每个数据都从硬盘读了三次，写了三次，要花很多时间。考虑 K 路】\n   2. 多路归并【K 不是越大越好，因为 K 越大，在内部排序需要的时间越长，效率低。考虑减少初始顺串的数量 M】\n   3. 置换选择算法【可以用败者树和堆排序实现，得到多个长度不等的初始归并段，如何设置它们的归并顺序，可以使得对外存的访问次数降到最低? 考虑结合哈夫曼树】\n   4. 最佳归并树（置换选择算法+哈夫曼树+多路归并+败者树）\n\n　外部排序算法由两个阶段构成：预处理和合并排序。\n\n1. **预处理产生有序的顺串：** 按照内存大小，将外存上含有 n 个纪录的大文件分成若干长度为 t 的子文件（t 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对子文件的 t 个纪录进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；这样在外存上就得到了 m 个顺串（m = [n/t]）。\n2. **合并序列：** 对得到的顺段进行合并，直至得到整个有序的文件为止。\n\n### k-路平衡归并\n\n![img](https://s2.loli.net/2024/08/02/c8UeXugYZIFbjOl.jpg)\n\n在 2G 内存中排序的时候可以选择合适的 **内部排序**，比如快速排序或归并排序等算法。为了方便，我们把排序好的 2G 有序数据称为有序子串。接着把两个小的有序子串合并成一个大的有序子串。\n\n![img](https://s2.loli.net/2024/08/02/3R8r9YqgAvufFl1.jpg)\n\n假设需要排序的int数有12个，内存一次只能装下3个int数。\n\n![k-路平衡归并1](https://s2.loli.net/2024/08/02/YzvG5B4lec2m9pS.jpg)\n\n 接下来把12个数据分成4份，然后排序成有序子串：\n\n![k-路平衡归并2](https://s2.loli.net/2024/08/02/2alThnoFmOAbvfp.jpg)\n\n 然后把子串进行两两合并：\n\n![k-路平衡归并3](https://s2.loli.net/2024/08/02/tHhCWegpjKd9MJ8.jpg)\n\n  输出哪个元素就在那个元素所在的有序子串再次读入一个元素：\n\n![k-路平衡归并4](https://s2.loli.net/2024/08/02/jwtZ3Emdc7Wilnk.jpg)\n\n![k-路平衡归并5](https://s2.loli.net/2024/08/02/KdEQi3msxPY7cfU.jpg)\n\n重复直到合并成一个包含6个int有序子串，再把两个包含6个int的有序子串合并成一个包含12个int数据的最终有序子串\n\n![k-路平衡归并6](https://s2.loli.net/2024/08/02/tgsRBFyWH7jafVu.jpg)\n\n### 多路归并\n\n**对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多**。8.1 中图中使用的是 2-路平衡归并的方式，举一反三，还可以使用 3-路归并、4-路归并甚至是 10-路归并的方式。\n\n对于 k-路平衡归并中 k 值得选择，**增加 k 可以减少归并的次数**，从而**减少外存读写的次数**，最终达到提高算法效率的目的。除此之外，一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，归并的次数为：**s=⌊logk⁡m ⌋**（其中 s 表示归并次数）。\n\n从公式上可以判断出，想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：\n\n- **增加 k-路平衡归并中的 k 值；[但不能影响内部归并的效率]**\n- **尽量减少初始归并段的数量 m，即增加每个归并段的容量；**\n\n> **其增加 k 值的想法引申出了一种外部排序算法：多路平衡归并算法；增加数量 m 的想法引申出了另一种外部排序算法：置换-选择排序算法。**\n\n### 多路平衡归并排序（胜者树、败者树）\n\n1. 胜者树\n\n   ![胜者二叉树](https://s2.loli.net/2024/08/02/sIUWdA1wTFC3Rmq.png)\n\n   当我们将我们的胜者树的最优值输入到我们的输出缓冲区（**输出缓冲区从内存中额外开辟出来的一段，我们存储当前的归并的结果，缓冲区满写入磁盘**）\n   之后，我们的根节点便出现了空的情况，**我们需要从根节点对应的输入缓冲区中在读入一个数据来充当下一次比较的选手**，然后**从下到上进行维护**，我们的每一次的维护都需要比较兄弟的胜者然后选出新一轮的胜者然后一直优化到我们的根的路径上（从低至上，贯穿整个树)之后我们不断地进行上述的操作，指导我们的所有的输入缓冲区已经为空为止。\n\n**胜者树和败者树的区别就是：胜者树中的非终端结点中存储的是胜利的一方；而败者树中的非终端结点存储的是失败的一方。而在比较过程中，都是拿胜者去比较。**\n\n### 置换选择排序算法\n\n![置换选择排序算法](https://s2.loli.net/2024/08/02/FniZuMpjCGgAySR.png)\n\n![置换选择排序算法2](https://s2.loli.net/2024/08/02/OlN4FT13zHn9yBb.png)\n\n例如已知初始文件中总共有 24 个记录，假设内存工作区最多可容纳 6 个记录，按照之前的选择排序算法最少也只能分为 4 个初始归并段。而如果使用置换—选择排序，可以实现将 24 个记录分为 3 个初始归并段\n\n![置换选择排序算法3](https://s2.loli.net/2024/08/02/zewPVMgiTRXCrEj.png)\n\n　置换—选择排序算法的具体操作过程为：\n\n1. 首先从初始文件中输入 6 个记录到内存工作区中；\n   2. 从内存工作区中选出关键字最小的记录，将其记为 MINIMAX 记录；\n   3. 然后将 MINIMAX 记录输出到归并段文件中；\n   4. 此时内存工作区中还剩余 5 个记录，若初始文件不为空，则从初始文件中输入下一个记录到内存工作区中；\n   5. 从内存工作区中的所有比 MINIMAX 值大的记录中选出值最小的关键字的记录，作为新的 MINIMAX 记录；[使用败者树或者堆排序实现]\n   6. 重复过程 3—5，直至在内存工作区中选不出新的 MINIMAX 记录为止，由此就得到了一个初始归并段；\n   7. 重复 2—6，直至内存工作为空，由此就可以得到全部的初始归并段。\n\n### 胜者树、败者树与堆排序\n\n#### 概念\n\n- **堆**：其实一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后再用孩子节点的最小值和父节点进行比较，所以每调整一层需要比较两次。 \n\n- **胜者树**：这时人们想能否简化比较过程，这时就有了胜者树，这样每次比较只用跟自己的兄弟节点进行比较就好，所以用胜者树可以比堆少一半的比较次数。 而胜者树在节点上升的时候首选需要获得父节点，然后再获得兄弟节点，然后再比较。\n\n- **败者树**：这时人们又想能否再次减少比较次数，于是就有了败者树。在使用败者树的时候，每个新元素上升时，只需要获得父节点并比较即可。 \n\n所以总的来说，减少了访存的时间。 现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了。**在外部排序中通常使用败者树。**\n\n---\n\n胜者树的特点：\n1、胜者树，是一棵完全二叉树\n2、每个叶子节点表示一个选手，记录选手的标号\n3、每个非叶子节点表示一场比赛，记录胜者的标号，而每层也就表示一轮比赛\n\n---\n\n败者树：\n1、败者树，也是一颗完全二叉树\n2、每个叶子节点表示一个选手，记录选手的标号\n3、每个非叶子节点表示一场比赛，记录败者的标号，胜者晋级上一层。并且，因为树根节点记录的是败者的标号，会再新建一个节点记录最终胜者的标号。\n\n---\n\n#### 异同点\n\n三者的相同点在于空间和时间复杂度都是 Ologn)级别的\n\n不同点\n\n- **堆**：所有的节点都是关键字； 每次调整一层需要比较两次（父亲 左孩子| 父亲 右孩子）。 \n- **胜者树**：叶子节点是关键字，非叶子节点保存胜者索引；**每次调整一层需比较 1 次（自己 兄弟），读取两次（父亲| 兄弟）**。\n- **败者树**：叶子节点是关键字，非叶子节点保存败者索引；**每次调整一层需要比较 1 次（自己 父亲），读取一次（父亲），只需要和路径上的节点比较，不需要和兄弟节点比较**，简化了重构的过程。； 新增 B [0] 记录比赛的胜者【在本例子中是 ls [0]】\n\n#### 胜者树败者树重构阐述\n\n1. 胜者树\n\n   ![胜者树结构](https://s2.loli.net/2024/08/02/i4mZ3sOkxlHFBgD.png) 将 b3 替换成 11，胜者树重构示例：\n\n   ![胜者树重构](https://s2.loli.net/2024/08/02/eBYMU2ojSV4fHsQ.png)\n\n   重构过程中，先取到父节点的值，拿到选手对应的标号，然后再根据标号拿到选手的值和新插入选手的值比较，胜者写到父节点。\n\n2. 败者树\n\n   ![败者树结构](https://img2020.cnblogs.com/blog/2499424/202109/2499424-20210918155013278-334692385.png)\n\n   将 b3 替换为 13，败者树重构示例：\n\n   ![败者树重构](https://img2020.cnblogs.com/blog/2499424/202109/2499424-20210918155045828-280607642.png)\n\n   重构上比胜者树有优化，只需要取父节点的值并进行比较\n","slug":"special_subject/NationalPGExamination/ProfessionalCources/DataStructure/补充","published":1,"updated":"2024-08-17T13:20:42.470Z","comments":1,"layout":"post","photos":[],"_id":"clzy68qqx0044m8wv2gymf4tw","content":"<p>注：本文档中知识点为做题时查资料临时补充所得，若在正式知识复习中有所补充则转到目标位置</p>\n<hr>\n<h2 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h2><h3 id=\"线索化\"><a href=\"#线索化\" class=\"headerlink\" title=\"线索化\"></a>线索化</h3><p>线索化是一种在建立二叉树得同时记录下前驱后继得关系，提升寻找前驱后继节点效率的方法。</p>\n<p>现将某结点的空指针域指向该结点的前驱后继，定义规则如下：</p>\n<ul>\n<li>若结点的左子树为空，则该结点的左孩子指针指向其前驱结点</li>\n<li>若结点的右子树为空，则该结点的右孩子指针指向其后继结点</li>\n</ul>\n<p>这种指向前驱和后继的 <strong>指针</strong> 称为 <strong>线索</strong>，将一棵普通的二叉树以某种次序遍历，并添加线索的过程称为线索化。</p>\n<h3 id=\"线索化的问题与解决方式\"><a href=\"#线索化的问题与解决方式\" class=\"headerlink\" title=\"线索化的问题与解决方式\"></a>线索化的问题与解决方式</h3><p>区分左右节点与前驱后继节点</p>\n<p>通过 <strong>ltag, rtag</strong> 区分</p>\n<h2 id=\"二叉树的遍历序\"><a href=\"#二叉树的遍历序\" class=\"headerlink\" title=\"二叉树的遍历序\"></a>二叉树的遍历序</h2><h3 id=\"先序中序与后序遍历的性质\"><a href=\"#先序中序与后序遍历的性质\" class=\"headerlink\" title=\"先序中序与后序遍历的性质\"></a>先序中序与后序遍历的性质</h3><ol>\n<li><p>先序：根，左，右；中序；左，根，右；后序：左、右、根</p>\n</li>\n<li><p>先序与后序是不能确定一个二叉树的</p>\n</li>\n</ol>\n<h2 id=\"树，森林与二叉树的转换\"><a href=\"#树，森林与二叉树的转换\" class=\"headerlink\" title=\"树，森林与二叉树的转换\"></a>树，森林与二叉树的转换</h2><h3 id=\"树转换为二叉树\"><a href=\"#树转换为二叉树\" class=\"headerlink\" title=\"树转换为二叉树\"></a>树转换为二叉树</h3><p>步骤：</p>\n<ol>\n<li>加线：在所有兄弟结点之间加一条线。</li>\n<li>去线：对树中每个结点，<strong>只保留它与第一个孩子结点</strong> 的连线，删除它与其他孩子结点之间的连线。</li>\n<li>层次调整：以树的根结点为轴心，将整棵树顺时针旋转一定的角度，将整棵树一定的角度，使之结构层次分明。注意第一个孩子结点是二叉树结点的左孩子，兄弟转换过来的孩子是结点的孩子。</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/25/sUzCdIjYmAQfGrZ.png\" alt=\"树到二叉树之间的转换\"></p>\n<h3 id=\"森林转化为二叉树\"><a href=\"#森林转化为二叉树\" class=\"headerlink\" title=\"森林转化为二叉树\"></a>森林转化为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一个树都是兄弟，可以按照兄弟的办法来操作。</p>\n<ol>\n<li>把每棵树转换为二叉树。</li>\n<li>第一棵二叉树不动，从第二棵二叉树开始，依次 <strong>把后一颗二叉树的根结点作为前一棵二叉树的根结点的右孩子</strong>，用线连接起来。当所有的二叉树连接起来后，就得到了森林转换来的二叉树</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/25/n1owABbziHOQcUr.png\" alt=\"森林到二叉树\"></p>\n<h3 id=\"二叉树转换为树\"><a href=\"#二叉树转换为树\" class=\"headerlink\" title=\"二叉树转换为树\"></a>二叉树转换为树</h3><p>二叉树转换为树是是转化为二叉树的逆过程，也就是反过来而已。如图所示。步骤如下</p>\n<ol>\n<li>加线：若某结点的左孩子结点存在，则将这个左孩子的右孩子的结点，右孩子的右孩子结点……反正就是左孩子的 n 个右孩子结点都作为此结点的孩子，将结点与这些孩子结点用线连接起来。</li>\n<li>去线：删除原二叉树中所有结点与其右孩子结点的连线。</li>\n<li>层次调整</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/25/lCShs9eEvNcJBpd.png\" alt=\"二叉树到树\"></p>\n<h3 id=\"二叉树到森林\"><a href=\"#二叉树到森林\" class=\"headerlink\" title=\"二叉树到森林\"></a>二叉树到森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简答，那就是只要这课二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。那么如果是转换成森林，步骤如下：</p>\n<ol>\n<li>从根结点开始，若右孩子存在，则 <strong>把右孩子结点的连线删除</strong>，在查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有的右孩子连线都删除为止，得到分离后的二叉树。</li>\n<li>在将每棵分离后的二叉树转换为树即可。</li>\n</ol>\n<h2 id=\"树的表示方法\"><a href=\"#树的表示方法\" class=\"headerlink\" title=\"树的表示方法\"></a>树的表示方法</h2><p>这里补充三种对数的表示方法</p>\n<h3 id=\"双亲表示法\"><a href=\"#双亲表示法\" class=\"headerlink\" title=\"双亲表示法\"></a>双亲表示法</h3><p>我们假设以一段连续空间存储树的结点，同时 <strong>在每个结点中，附设一个指示器指示其双亲结点到链表中的位置</strong>。也就是说，每个结点除了直到自己是谁外，还要直到自己的双亲在哪里。如图：<img src=\"https://s2.loli.net/2024/07/25/DMvbQVnXydagUEk.png\" alt=\"双亲表示法节点图\"></p>\n<p>实际上这种表示方法与一个数组记录每个节点的父节点相同，根节点的父节点为-1</p>\n<h3 id=\"孩子表示法\"><a href=\"#孩子表示法\" class=\"headerlink\" title=\"孩子表示法\"></a>孩子表示法</h3><p>这种表示法类似邻接表，记录每个节点的所有孩子。</p>\n<p>显然，这样的表示方法对数据结构有要求，如何判断每个节点的孩子记录需要多少空间，有三个方法</p>\n<ol>\n<li><p>以树的度作为每个节点的孩子数量</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/vI7Np9Mf2h14YCL.png\" alt=\"孩子表示法 1\"></p>\n</li>\n<li><p>每个结点指针域的个数等于该结点的度，我们专门来取一个位置来存储结点指针域的个数。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/WrMLCNsfjcYSOap.pn\" alt=\"孩子表示法2数据结构\"  /> <img src=\"https://i-blog.csdnimg.cn/blog_migrate/877d911bcbfb63fdd235137138cfa5b8.png\" alt=\"孩子表示法 2\"></p>\n</li>\n<li><p>真正的邻接表</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/2WtkbVTGIAhLXKR.png\" alt=\"孩子表示法第三个方法\"></p>\n</li>\n</ol>\n<h4 id=\"扩展：双亲孩子表示法\"><a href=\"#扩展：双亲孩子表示法\" class=\"headerlink\" title=\"扩展：双亲孩子表示法\"></a>扩展：双亲孩子表示法</h4><p>即对每一个节点加一个双亲域。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/Iyj7s6LWoh451RO.png\" alt=\"双亲孩子表示法\"></p>\n<h3 id=\"孩子兄弟表示法\"><a href=\"#孩子兄弟表示法\" class=\"headerlink\" title=\"孩子兄弟表示法\"></a>孩子兄弟表示法</h3><p><strong>任何一棵树，它的结点的第一个孩子如果是唯一的，它的右兄弟如果存在也是唯一的，因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</strong></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/j7CT9kvuRAXdQhM.png\" alt=\"孩子兄弟表示法节点结构\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/PXI1x6m8DVCcBEg.png\" alt=\"孩子兄弟表示法树形结构\"></p>\n<h2 id=\"实际算法使用与题目当中的区别\"><a href=\"#实际算法使用与题目当中的区别\" class=\"headerlink\" title=\"实际算法使用与题目当中的区别\"></a>实际算法使用与题目当中的区别</h2><h3 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h3><p>直接上例子</p>\n<p>对 A1-A18 找目标元素 A3</p>\n<ol>\n<li>$\\left\\lfloor(1+18)/2\\right\\rfloor = 9$</li>\n<li>$A1\\cdots A8 \\to A4$</li>\n<li>$A1\\cdots A3 \\to A2$</li>\n<li>$A2\\cdots A3 \\to A3$</li>\n</ol>\n<p>因此查找顺序为 9,4,2,3，可以注意到每次排除了二分的 flag，这是与实际不同的。</p>\n<h3 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h3><p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725111145849.png\" alt=\"排序算法\"></p>\n<p>不稳定排序：<strong>快选希堆</strong>（快速排序，选择排序，希尔排序，堆排序）</p>\n<p>快排的时间复杂度是 O(log2n)，归并排序的空间复杂度是 O(n)</p>\n<p>快速排序一般选用左端为 flag，且左右指针一般先动右指针</p>\n<p>快速排序的速度与序列的关系是</p>\n<ol>\n<li><p><strong>越有序的越慢</strong></p>\n</li>\n<li><p>划分越均匀的越快</p>\n</li>\n<li><p>当前两条相同时我们尝试手动快排一次，然后对左右在应用 1，2 原则</p>\n</li>\n</ol>\n<blockquote>\n<p>例如对：</p>\n<p>A. 21, 25, 5, 17, 9, 23, 30    B. 25, 23, 30, 17, 21, 5, 9<br>C.21, 9,17, 30,25, 23,5        D.5,9,17,21,23,25,30</p>\n<p>首先根据前两个原则确定 BD 均不快</p>\n<p>温习一下快排，手动尝试 AC 分别是</p>\n<p>9，17，5，(21)，25，23，30</p>\n<p>5，9，17，(21)，25，23，30</p>\n<p>这四个序列而言对快排的效率从小到大依次是 D、B、C、A</p>\n</blockquote>\n<h4 id=\"一些不常用的排序算法\"><a href=\"#一些不常用的排序算法\" class=\"headerlink\" title=\"一些不常用的排序算法\"></a>一些不常用的排序算法</h4><ol>\n<li>堆排序</li>\n</ol>\n<p>排序思想</p>\n<ol>\n<li><p>首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端</p>\n</li>\n<li><p>将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为 n-1</p>\n</li>\n<li><p>将剩余的 n-1 个数再构造成大根堆，再将顶端数与 n-1 位置的数交换，如此反复执行，便能得到有序数组</p>\n<p>注意: 升序用大根堆，降序就用小根堆(默认为升序)</p>\n</li>\n<li><p>希尔排序</p>\n</li>\n</ol>\n<p>{98，36，-9，0，47，23，1，8，10，7}，希尔排序，步长是 4</p>\n<ol>\n<li>按照步长分组</li>\n<li>组内简单插入排序</li>\n</ol>\n<p>10,7,-9,0,47,23,1,8,98,36</p>\n<h2 id=\"二叉判定树\"><a href=\"#二叉判定树\" class=\"headerlink\" title=\"二叉判定树\"></a>二叉判定树</h2><p>二叉判定树是用于精确判定有限次二分的精确平均比较次数（ASL Average Search Length 平均比较次数）的一种生成式数据结构，对一个 R12 的有序表，有以下二叉判定树</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/hEJ9OUcqgIbVimW.png\" alt=\"二叉判定树\"></p>\n<h2 id=\"归并段与最佳归并树与多路平衡归并\"><a href=\"#归并段与最佳归并树与多路平衡归并\" class=\"headerlink\" title=\"归并段与最佳归并树与多路平衡归并\"></a>归并段与最佳归并树与多路平衡归并</h2><p><strong>归并段</strong> 顾名思义，其就是一段等待归并的有序字段</p>\n<p>最佳归并树的概念依托于最小带权哈夫曼树，最小带权哈夫曼树定义是带权路径和最小的哈夫曼树，哈夫曼树带权路径长度为叶子结点的到根节点的路径长度乘以叶子节点上值得乘积。加权路径长度是归并树的重要属性，其英文全程是 Weighted Path Length WPL。</p>\n<p>要理解为何会有最佳归并树的最佳概念，先看一个较简单较劣的算法即多路归并算法。</p>\n<p>例如，初始归并段的长度分别为：[9，30，12，18，3，17，2，6，24]，如果使用 3-路归并，则其归并树如下</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/BjoY4Kksg2HT89n.png\" alt=\"3-路归并\"></p>\n<p>整个归并需要对外存的读写次数为 484，恰好为 <strong>归并树带权路径长度的四倍</strong>。</p>\n<p>而哈夫曼树树就是在多路归并树的基础上采取哈夫曼树的构造方式，与传统的二叉哈夫曼树不同的地方在于，此处的哈夫曼树可以是更高度数的。用标准表述就是 <code>n路最佳归并树</code></p>\n<p><strong>虚段</strong> 的概念源于对 2 度以上哈夫曼树的补充，它将那些度数小于哈夫曼树度的节点补上长度为 0 的段，归一化整体哈夫曼树的结构。</p>\n<p>那么到底如何确定添加的虚段的数量呢?<br>一般的，假设分段数为 $n$，最佳归并树的路数为 $k$，若 $( m − 1 )\\mod( k − 1 ) = 0$ ，则不用加虚段，否则需要增加 $ k − ( m − 1 )\\mod( k − 1 ) − 1$ 个虚段。(第一次归并为 $( m − 1 )\\mod( k − 1 ) + 1$ 路归并 )。</p>\n<blockquote>\n<p>设有 13 个初始归并段，长度分别为 [28,16,37,42,5,9,13,14,20,17,30,12,18]。则 4 路最佳归并树的带权路径长度 WPL 为</p>\n<p>A 261<br>B 438<br>C 480<br>D 522</p>\n<details>\n    【解析】C。\n     n = 13, k = 4。 (n-1)%(k-1)= 0,\n不需加虚段。最佳归并树如图所示。\nWPL =(5+9+12+13+14+ 16+17+18+20\n28+30+37)X2+42 = 480。\n                              <img src=\"https://s2.loli.net/2024/08/02/o5BS6EJANxeOI9b.png\" alt=\"image-20240802113500129\" />\n    </details>\n\n\n\n</blockquote>\n<h2 id=\"外部排序\"><a href=\"#外部排序\" class=\"headerlink\" title=\"外部排序\"></a>外部排序</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaGFpbWlzaGFzaGEvcC8xMDg5ODcxNS5odG1s\">数据结构与算法系列——排序(15)_外部排序 - 海米傻傻 - 博客园 (cnblogs.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ol>\n<li><p>实现外部排序的 <strong>两个过程</strong>：</p>\n<ol>\n<li>将整个初始文件分为多个初始归并段;</li>\n<li>将初始归并段进行归并，直至得到一个有序的完整文件；</li>\n</ol>\n</li>\n<li><p>时间开销构成</p>\n<ol>\n<li><strong>内部排序</strong> 所需要的时间</li>\n<li><strong>外存信息读写</strong> 所需要的时间 （关键） <ul>\n<li>与归并的趟数有关 <ul>\n<li>k 要大 —– 传统方法 会引起内部归并时间增大 <ul>\n<li>赢者树</li>\n<li>败者树（目的：提高在 k 个归并串中当前值中找到最小值的效率）</li>\n</ul>\n</li>\n<li>m 要小 —– 置换选择排序</li>\n</ul>\n</li>\n<li>Huffman（归并的顺序，对外存的 I/O 次数降到最低）</li>\n</ul>\n</li>\n<li><strong>内部归并</strong> 所需要的时间</li>\n</ol>\n</li>\n<li>为了提高整个外部排序的效率，分别从以上 <strong>两个方面对外部排序</strong> 进行了优化：<ol>\n<li>在实现将初始文件分为 m 个初始归并段时，为了尽量减小 m 的值，<strong>采用置换-选择排序算法(内部使用败者树实现)</strong>，可实现将整个初始文件分为数量较少的长度不等的初始归并段。</li>\n<li>同时在将初始归并段归并为有序完整文件的过程中，为了尽量减少读写外存的次数，采用 <strong>构建最佳归并树的方式（哈夫曼树实现），对初始归并段进行归并（败者树实现）</strong>，而归并的具体实现方法是采用败者树的方式。</li>\n</ol>\n</li>\n<li><strong>优化递进顺序：</strong><ol>\n<li>二路归并【因为硬盘的读写速度比内存要慢的多，按照以上这种方法，每个数据都从硬盘读了三次，写了三次，要花很多时间。考虑 K 路】</li>\n<li>多路归并【K 不是越大越好，因为 K 越大，在内部排序需要的时间越长，效率低。考虑减少初始顺串的数量 M】</li>\n<li>置换选择算法【可以用败者树和堆排序实现，得到多个长度不等的初始归并段，如何设置它们的归并顺序，可以使得对外存的访问次数降到最低? 考虑结合哈夫曼树】</li>\n<li>最佳归并树（置换选择算法+哈夫曼树+多路归并+败者树）</li>\n</ol>\n</li>\n</ol>\n<p>　外部排序算法由两个阶段构成：预处理和合并排序。</p>\n<ol>\n<li><strong>预处理产生有序的顺串：</strong> 按照内存大小，将外存上含有 n 个纪录的大文件分成若干长度为 t 的子文件（t 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对子文件的 t 个纪录进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；这样在外存上就得到了 m 个顺串（m = [n/t]）。</li>\n<li><strong>合并序列：</strong> 对得到的顺段进行合并，直至得到整个有序的文件为止。</li>\n</ol>\n<h3 id=\"k-路平衡归并\"><a href=\"#k-路平衡归并\" class=\"headerlink\" title=\"k-路平衡归并\"></a>k-路平衡归并</h3><p><img src=\"https://s2.loli.net/2024/08/02/c8UeXugYZIFbjOl.jpg\" alt=\"img\"></p>\n<p>在 2G 内存中排序的时候可以选择合适的 <strong>内部排序</strong>，比如快速排序或归并排序等算法。为了方便，我们把排序好的 2G 有序数据称为有序子串。接着把两个小的有序子串合并成一个大的有序子串。</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/3R8r9YqgAvufFl1.jpg\" alt=\"img\"></p>\n<p>假设需要排序的int数有12个，内存一次只能装下3个int数。</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/YzvG5B4lec2m9pS.jpg\" alt=\"k-路平衡归并1\"></p>\n<p> 接下来把12个数据分成4份，然后排序成有序子串：</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/2alThnoFmOAbvfp.jpg\" alt=\"k-路平衡归并2\"></p>\n<p> 然后把子串进行两两合并：</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/tHhCWegpjKd9MJ8.jpg\" alt=\"k-路平衡归并3\"></p>\n<p>  输出哪个元素就在那个元素所在的有序子串再次读入一个元素：</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/jwtZ3Emdc7Wilnk.jpg\" alt=\"k-路平衡归并4\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/02/KdEQi3msxPY7cfU.jpg\" alt=\"k-路平衡归并5\"></p>\n<p>重复直到合并成一个包含6个int有序子串，再把两个包含6个int的有序子串合并成一个包含12个int数据的最终有序子串</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/tgsRBFyWH7jafVu.jpg\" alt=\"k-路平衡归并6\"></p>\n<h3 id=\"多路归并\"><a href=\"#多路归并\" class=\"headerlink\" title=\"多路归并\"></a>多路归并</h3><p><strong>对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多</strong>。8.1 中图中使用的是 2-路平衡归并的方式，举一反三，还可以使用 3-路归并、4-路归并甚至是 10-路归并的方式。</p>\n<p>对于 k-路平衡归并中 k 值得选择，<strong>增加 k 可以减少归并的次数</strong>，从而<strong>减少外存读写的次数</strong>，最终达到提高算法效率的目的。除此之外，一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，归并的次数为：<strong>s=⌊logk⁡m ⌋</strong>（其中 s 表示归并次数）。</p>\n<p>从公式上可以判断出，想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：</p>\n<ul>\n<li><strong>增加 k-路平衡归并中的 k 值；[但不能影响内部归并的效率]</strong></li>\n<li><strong>尽量减少初始归并段的数量 m，即增加每个归并段的容量；</strong></li>\n</ul>\n<blockquote>\n<p><strong>其增加 k 值的想法引申出了一种外部排序算法：多路平衡归并算法；增加数量 m 的想法引申出了另一种外部排序算法：置换-选择排序算法。</strong></p>\n</blockquote>\n<h3 id=\"多路平衡归并排序（胜者树、败者树）\"><a href=\"#多路平衡归并排序（胜者树、败者树）\" class=\"headerlink\" title=\"多路平衡归并排序（胜者树、败者树）\"></a>多路平衡归并排序（胜者树、败者树）</h3><ol>\n<li><p>胜者树</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/sIUWdA1wTFC3Rmq.png\" alt=\"胜者二叉树\"></p>\n<p>当我们将我们的胜者树的最优值输入到我们的输出缓冲区（<strong>输出缓冲区从内存中额外开辟出来的一段，我们存储当前的归并的结果，缓冲区满写入磁盘</strong>）<br>之后，我们的根节点便出现了空的情况，<strong>我们需要从根节点对应的输入缓冲区中在读入一个数据来充当下一次比较的选手</strong>，然后<strong>从下到上进行维护</strong>，我们的每一次的维护都需要比较兄弟的胜者然后选出新一轮的胜者然后一直优化到我们的根的路径上（从低至上，贯穿整个树)之后我们不断地进行上述的操作，指导我们的所有的输入缓冲区已经为空为止。</p>\n</li>\n</ol>\n<p><strong>胜者树和败者树的区别就是：胜者树中的非终端结点中存储的是胜利的一方；而败者树中的非终端结点存储的是失败的一方。而在比较过程中，都是拿胜者去比较。</strong></p>\n<h3 id=\"置换选择排序算法\"><a href=\"#置换选择排序算法\" class=\"headerlink\" title=\"置换选择排序算法\"></a>置换选择排序算法</h3><p><img src=\"https://s2.loli.net/2024/08/02/FniZuMpjCGgAySR.png\" alt=\"置换选择排序算法\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/02/OlN4FT13zHn9yBb.png\" alt=\"置换选择排序算法2\"></p>\n<p>例如已知初始文件中总共有 24 个记录，假设内存工作区最多可容纳 6 个记录，按照之前的选择排序算法最少也只能分为 4 个初始归并段。而如果使用置换—选择排序，可以实现将 24 个记录分为 3 个初始归并段</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/zewPVMgiTRXCrEj.png\" alt=\"置换选择排序算法3\"></p>\n<p>　置换—选择排序算法的具体操作过程为：</p>\n<ol>\n<li>首先从初始文件中输入 6 个记录到内存工作区中；<ol>\n<li>从内存工作区中选出关键字最小的记录，将其记为 MINIMAX 记录；</li>\n<li>然后将 MINIMAX 记录输出到归并段文件中；</li>\n<li>此时内存工作区中还剩余 5 个记录，若初始文件不为空，则从初始文件中输入下一个记录到内存工作区中；</li>\n<li>从内存工作区中的所有比 MINIMAX 值大的记录中选出值最小的关键字的记录，作为新的 MINIMAX 记录；[使用败者树或者堆排序实现]</li>\n<li>重复过程 3—5，直至在内存工作区中选不出新的 MINIMAX 记录为止，由此就得到了一个初始归并段；</li>\n<li>重复 2—6，直至内存工作为空，由此就可以得到全部的初始归并段。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"胜者树、败者树与堆排序\"><a href=\"#胜者树、败者树与堆排序\" class=\"headerlink\" title=\"胜者树、败者树与堆排序\"></a>胜者树、败者树与堆排序</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ul>\n<li><p><strong>堆</strong>：其实一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后再用孩子节点的最小值和父节点进行比较，所以每调整一层需要比较两次。 </p>\n</li>\n<li><p><strong>胜者树</strong>：这时人们想能否简化比较过程，这时就有了胜者树，这样每次比较只用跟自己的兄弟节点进行比较就好，所以用胜者树可以比堆少一半的比较次数。 而胜者树在节点上升的时候首选需要获得父节点，然后再获得兄弟节点，然后再比较。</p>\n</li>\n<li><p><strong>败者树</strong>：这时人们又想能否再次减少比较次数，于是就有了败者树。在使用败者树的时候，每个新元素上升时，只需要获得父节点并比较即可。 </p>\n</li>\n</ul>\n<p>所以总的来说，减少了访存的时间。 现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了。<strong>在外部排序中通常使用败者树。</strong></p>\n<hr>\n<p>胜者树的特点：<br>1、胜者树，是一棵完全二叉树<br>2、每个叶子节点表示一个选手，记录选手的标号<br>3、每个非叶子节点表示一场比赛，记录胜者的标号，而每层也就表示一轮比赛</p>\n<hr>\n<p>败者树：<br>1、败者树，也是一颗完全二叉树<br>2、每个叶子节点表示一个选手，记录选手的标号<br>3、每个非叶子节点表示一场比赛，记录败者的标号，胜者晋级上一层。并且，因为树根节点记录的是败者的标号，会再新建一个节点记录最终胜者的标号。</p>\n<hr>\n<h4 id=\"异同点\"><a href=\"#异同点\" class=\"headerlink\" title=\"异同点\"></a>异同点</h4><p>三者的相同点在于空间和时间复杂度都是 Ologn)级别的</p>\n<p>不同点</p>\n<ul>\n<li><strong>堆</strong>：所有的节点都是关键字； 每次调整一层需要比较两次（父亲 左孩子| 父亲 右孩子）。 </li>\n<li><strong>胜者树</strong>：叶子节点是关键字，非叶子节点保存胜者索引；<strong>每次调整一层需比较 1 次（自己 兄弟），读取两次（父亲| 兄弟）</strong>。</li>\n<li><strong>败者树</strong>：叶子节点是关键字，非叶子节点保存败者索引；<strong>每次调整一层需要比较 1 次（自己 父亲），读取一次（父亲），只需要和路径上的节点比较，不需要和兄弟节点比较</strong>，简化了重构的过程。； 新增 B [0] 记录比赛的胜者【在本例子中是 ls [0]】</li>\n</ul>\n<h4 id=\"胜者树败者树重构阐述\"><a href=\"#胜者树败者树重构阐述\" class=\"headerlink\" title=\"胜者树败者树重构阐述\"></a>胜者树败者树重构阐述</h4><ol>\n<li><p>胜者树</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/i4mZ3sOkxlHFBgD.png\" alt=\"胜者树结构\"> 将 b3 替换成 11，胜者树重构示例：</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/eBYMU2ojSV4fHsQ.png\" alt=\"胜者树重构\"></p>\n<p>重构过程中，先取到父节点的值，拿到选手对应的标号，然后再根据标号拿到选手的值和新插入选手的值比较，胜者写到父节点。</p>\n</li>\n<li><p>败者树</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/2499424/202109/2499424-20210918155013278-334692385.png\" alt=\"败者树结构\"></p>\n<p>将 b3 替换为 13，败者树重构示例：</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/2499424/202109/2499424-20210918155045828-280607642.png\" alt=\"败者树重构\"></p>\n<p>重构上比胜者树有优化，只需要取父节点的值并进行比较</p>\n</li>\n</ol>\n<!-- flag of hidden posts -->","length":5380,"excerpt":"","more":"<p>注：本文档中知识点为做题时查资料临时补充所得，若在正式知识复习中有所补充则转到目标位置</p>\n<hr>\n<h2 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h2><h3 id=\"线索化\"><a href=\"#线索化\" class=\"headerlink\" title=\"线索化\"></a>线索化</h3><p>线索化是一种在建立二叉树得同时记录下前驱后继得关系，提升寻找前驱后继节点效率的方法。</p>\n<p>现将某结点的空指针域指向该结点的前驱后继，定义规则如下：</p>\n<ul>\n<li>若结点的左子树为空，则该结点的左孩子指针指向其前驱结点</li>\n<li>若结点的右子树为空，则该结点的右孩子指针指向其后继结点</li>\n</ul>\n<p>这种指向前驱和后继的 <strong>指针</strong> 称为 <strong>线索</strong>，将一棵普通的二叉树以某种次序遍历，并添加线索的过程称为线索化。</p>\n<h3 id=\"线索化的问题与解决方式\"><a href=\"#线索化的问题与解决方式\" class=\"headerlink\" title=\"线索化的问题与解决方式\"></a>线索化的问题与解决方式</h3><p>区分左右节点与前驱后继节点</p>\n<p>通过 <strong>ltag, rtag</strong> 区分</p>\n<h2 id=\"二叉树的遍历序\"><a href=\"#二叉树的遍历序\" class=\"headerlink\" title=\"二叉树的遍历序\"></a>二叉树的遍历序</h2><h3 id=\"先序中序与后序遍历的性质\"><a href=\"#先序中序与后序遍历的性质\" class=\"headerlink\" title=\"先序中序与后序遍历的性质\"></a>先序中序与后序遍历的性质</h3><ol>\n<li><p>先序：根，左，右；中序；左，根，右；后序：左、右、根</p>\n</li>\n<li><p>先序与后序是不能确定一个二叉树的</p>\n</li>\n</ol>\n<h2 id=\"树，森林与二叉树的转换\"><a href=\"#树，森林与二叉树的转换\" class=\"headerlink\" title=\"树，森林与二叉树的转换\"></a>树，森林与二叉树的转换</h2><h3 id=\"树转换为二叉树\"><a href=\"#树转换为二叉树\" class=\"headerlink\" title=\"树转换为二叉树\"></a>树转换为二叉树</h3><p>步骤：</p>\n<ol>\n<li>加线：在所有兄弟结点之间加一条线。</li>\n<li>去线：对树中每个结点，<strong>只保留它与第一个孩子结点</strong> 的连线，删除它与其他孩子结点之间的连线。</li>\n<li>层次调整：以树的根结点为轴心，将整棵树顺时针旋转一定的角度，将整棵树一定的角度，使之结构层次分明。注意第一个孩子结点是二叉树结点的左孩子，兄弟转换过来的孩子是结点的孩子。</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/25/sUzCdIjYmAQfGrZ.png\" alt=\"树到二叉树之间的转换\"></p>\n<h3 id=\"森林转化为二叉树\"><a href=\"#森林转化为二叉树\" class=\"headerlink\" title=\"森林转化为二叉树\"></a>森林转化为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一个树都是兄弟，可以按照兄弟的办法来操作。</p>\n<ol>\n<li>把每棵树转换为二叉树。</li>\n<li>第一棵二叉树不动，从第二棵二叉树开始，依次 <strong>把后一颗二叉树的根结点作为前一棵二叉树的根结点的右孩子</strong>，用线连接起来。当所有的二叉树连接起来后，就得到了森林转换来的二叉树</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/25/n1owABbziHOQcUr.png\" alt=\"森林到二叉树\"></p>\n<h3 id=\"二叉树转换为树\"><a href=\"#二叉树转换为树\" class=\"headerlink\" title=\"二叉树转换为树\"></a>二叉树转换为树</h3><p>二叉树转换为树是是转化为二叉树的逆过程，也就是反过来而已。如图所示。步骤如下</p>\n<ol>\n<li>加线：若某结点的左孩子结点存在，则将这个左孩子的右孩子的结点，右孩子的右孩子结点……反正就是左孩子的 n 个右孩子结点都作为此结点的孩子，将结点与这些孩子结点用线连接起来。</li>\n<li>去线：删除原二叉树中所有结点与其右孩子结点的连线。</li>\n<li>层次调整</li>\n</ol>\n<p><img src=\"https://s2.loli.net/2024/07/25/lCShs9eEvNcJBpd.png\" alt=\"二叉树到树\"></p>\n<h3 id=\"二叉树到森林\"><a href=\"#二叉树到森林\" class=\"headerlink\" title=\"二叉树到森林\"></a>二叉树到森林</h3><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简答，那就是只要这课二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。那么如果是转换成森林，步骤如下：</p>\n<ol>\n<li>从根结点开始，若右孩子存在，则 <strong>把右孩子结点的连线删除</strong>，在查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有的右孩子连线都删除为止，得到分离后的二叉树。</li>\n<li>在将每棵分离后的二叉树转换为树即可。</li>\n</ol>\n<h2 id=\"树的表示方法\"><a href=\"#树的表示方法\" class=\"headerlink\" title=\"树的表示方法\"></a>树的表示方法</h2><p>这里补充三种对数的表示方法</p>\n<h3 id=\"双亲表示法\"><a href=\"#双亲表示法\" class=\"headerlink\" title=\"双亲表示法\"></a>双亲表示法</h3><p>我们假设以一段连续空间存储树的结点，同时 <strong>在每个结点中，附设一个指示器指示其双亲结点到链表中的位置</strong>。也就是说，每个结点除了直到自己是谁外，还要直到自己的双亲在哪里。如图：<img src=\"https://s2.loli.net/2024/07/25/DMvbQVnXydagUEk.png\" alt=\"双亲表示法节点图\"></p>\n<p>实际上这种表示方法与一个数组记录每个节点的父节点相同，根节点的父节点为-1</p>\n<h3 id=\"孩子表示法\"><a href=\"#孩子表示法\" class=\"headerlink\" title=\"孩子表示法\"></a>孩子表示法</h3><p>这种表示法类似邻接表，记录每个节点的所有孩子。</p>\n<p>显然，这样的表示方法对数据结构有要求，如何判断每个节点的孩子记录需要多少空间，有三个方法</p>\n<ol>\n<li><p>以树的度作为每个节点的孩子数量</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/vI7Np9Mf2h14YCL.png\" alt=\"孩子表示法 1\"></p>\n</li>\n<li><p>每个结点指针域的个数等于该结点的度，我们专门来取一个位置来存储结点指针域的个数。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/WrMLCNsfjcYSOap.pn\" alt=\"孩子表示法2数据结构\"  /> <img src=\"https://i-blog.csdnimg.cn/blog_migrate/877d911bcbfb63fdd235137138cfa5b8.png\" alt=\"孩子表示法 2\"></p>\n</li>\n<li><p>真正的邻接表</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/2WtkbVTGIAhLXKR.png\" alt=\"孩子表示法第三个方法\"></p>\n</li>\n</ol>\n<h4 id=\"扩展：双亲孩子表示法\"><a href=\"#扩展：双亲孩子表示法\" class=\"headerlink\" title=\"扩展：双亲孩子表示法\"></a>扩展：双亲孩子表示法</h4><p>即对每一个节点加一个双亲域。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/Iyj7s6LWoh451RO.png\" alt=\"双亲孩子表示法\"></p>\n<h3 id=\"孩子兄弟表示法\"><a href=\"#孩子兄弟表示法\" class=\"headerlink\" title=\"孩子兄弟表示法\"></a>孩子兄弟表示法</h3><p><strong>任何一棵树，它的结点的第一个孩子如果是唯一的，它的右兄弟如果存在也是唯一的，因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</strong></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/j7CT9kvuRAXdQhM.png\" alt=\"孩子兄弟表示法节点结构\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/PXI1x6m8DVCcBEg.png\" alt=\"孩子兄弟表示法树形结构\"></p>\n<h2 id=\"实际算法使用与题目当中的区别\"><a href=\"#实际算法使用与题目当中的区别\" class=\"headerlink\" title=\"实际算法使用与题目当中的区别\"></a>实际算法使用与题目当中的区别</h2><h3 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h3><p>直接上例子</p>\n<p>对 A1-A18 找目标元素 A3</p>\n<ol>\n<li>$\\left\\lfloor(1+18)/2\\right\\rfloor = 9$</li>\n<li>$A1\\cdots A8 \\to A4$</li>\n<li>$A1\\cdots A3 \\to A2$</li>\n<li>$A2\\cdots A3 \\to A3$</li>\n</ol>\n<p>因此查找顺序为 9,4,2,3，可以注意到每次排除了二分的 flag，这是与实际不同的。</p>\n<h3 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h3><p><img src=\"./../../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725111145849.png\" alt=\"排序算法\"></p>\n<p>不稳定排序：<strong>快选希堆</strong>（快速排序，选择排序，希尔排序，堆排序）</p>\n<p>快排的时间复杂度是 O(log2n)，归并排序的空间复杂度是 O(n)</p>\n<p>快速排序一般选用左端为 flag，且左右指针一般先动右指针</p>\n<p>快速排序的速度与序列的关系是</p>\n<ol>\n<li><p><strong>越有序的越慢</strong></p>\n</li>\n<li><p>划分越均匀的越快</p>\n</li>\n<li><p>当前两条相同时我们尝试手动快排一次，然后对左右在应用 1，2 原则</p>\n</li>\n</ol>\n<blockquote>\n<p>例如对：</p>\n<p>A. 21, 25, 5, 17, 9, 23, 30    B. 25, 23, 30, 17, 21, 5, 9<br>C.21, 9,17, 30,25, 23,5        D.5,9,17,21,23,25,30</p>\n<p>首先根据前两个原则确定 BD 均不快</p>\n<p>温习一下快排，手动尝试 AC 分别是</p>\n<p>9，17，5，(21)，25，23，30</p>\n<p>5，9，17，(21)，25，23，30</p>\n<p>这四个序列而言对快排的效率从小到大依次是 D、B、C、A</p>\n</blockquote>\n<h4 id=\"一些不常用的排序算法\"><a href=\"#一些不常用的排序算法\" class=\"headerlink\" title=\"一些不常用的排序算法\"></a>一些不常用的排序算法</h4><ol>\n<li>堆排序</li>\n</ol>\n<p>排序思想</p>\n<ol>\n<li><p>首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端</p>\n</li>\n<li><p>将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为 n-1</p>\n</li>\n<li><p>将剩余的 n-1 个数再构造成大根堆，再将顶端数与 n-1 位置的数交换，如此反复执行，便能得到有序数组</p>\n<p>注意: 升序用大根堆，降序就用小根堆(默认为升序)</p>\n</li>\n<li><p>希尔排序</p>\n</li>\n</ol>\n<p>{98，36，-9，0，47，23，1，8，10，7}，希尔排序，步长是 4</p>\n<ol>\n<li>按照步长分组</li>\n<li>组内简单插入排序</li>\n</ol>\n<p>10,7,-9,0,47,23,1,8,98,36</p>\n<h2 id=\"二叉判定树\"><a href=\"#二叉判定树\" class=\"headerlink\" title=\"二叉判定树\"></a>二叉判定树</h2><p>二叉判定树是用于精确判定有限次二分的精确平均比较次数（ASL Average Search Length 平均比较次数）的一种生成式数据结构，对一个 R12 的有序表，有以下二叉判定树</p>\n<p><img src=\"https://s2.loli.net/2024/08/01/hEJ9OUcqgIbVimW.png\" alt=\"二叉判定树\"></p>\n<h2 id=\"归并段与最佳归并树与多路平衡归并\"><a href=\"#归并段与最佳归并树与多路平衡归并\" class=\"headerlink\" title=\"归并段与最佳归并树与多路平衡归并\"></a>归并段与最佳归并树与多路平衡归并</h2><p><strong>归并段</strong> 顾名思义，其就是一段等待归并的有序字段</p>\n<p>最佳归并树的概念依托于最小带权哈夫曼树，最小带权哈夫曼树定义是带权路径和最小的哈夫曼树，哈夫曼树带权路径长度为叶子结点的到根节点的路径长度乘以叶子节点上值得乘积。加权路径长度是归并树的重要属性，其英文全程是 Weighted Path Length WPL。</p>\n<p>要理解为何会有最佳归并树的最佳概念，先看一个较简单较劣的算法即多路归并算法。</p>\n<p>例如，初始归并段的长度分别为：[9，30，12，18，3，17，2，6，24]，如果使用 3-路归并，则其归并树如下</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/BjoY4Kksg2HT89n.png\" alt=\"3-路归并\"></p>\n<p>整个归并需要对外存的读写次数为 484，恰好为 <strong>归并树带权路径长度的四倍</strong>。</p>\n<p>而哈夫曼树树就是在多路归并树的基础上采取哈夫曼树的构造方式，与传统的二叉哈夫曼树不同的地方在于，此处的哈夫曼树可以是更高度数的。用标准表述就是 <code>n路最佳归并树</code></p>\n<p><strong>虚段</strong> 的概念源于对 2 度以上哈夫曼树的补充，它将那些度数小于哈夫曼树度的节点补上长度为 0 的段，归一化整体哈夫曼树的结构。</p>\n<p>那么到底如何确定添加的虚段的数量呢?<br>一般的，假设分段数为 $n$，最佳归并树的路数为 $k$，若 $( m − 1 )\\mod( k − 1 ) = 0$ ，则不用加虚段，否则需要增加 $ k − ( m − 1 )\\mod( k − 1 ) − 1$ 个虚段。(第一次归并为 $( m − 1 )\\mod( k − 1 ) + 1$ 路归并 )。</p>\n<blockquote>\n<p>设有 13 个初始归并段，长度分别为 [28,16,37,42,5,9,13,14,20,17,30,12,18]。则 4 路最佳归并树的带权路径长度 WPL 为</p>\n<p>A 261<br>B 438<br>C 480<br>D 522</p>\n<details>\n    【解析】C。\n     n = 13, k = 4。 (n-1)%(k-1)= 0,\n不需加虚段。最佳归并树如图所示。\nWPL =(5+9+12+13+14+ 16+17+18+20\n28+30+37)X2+42 = 480。\n                              <img src=\"https://s2.loli.net/2024/08/02/o5BS6EJANxeOI9b.png\" alt=\"image-20240802113500129\" />\n    </details>\n\n\n\n</blockquote>\n<h2 id=\"外部排序\"><a href=\"#外部排序\" class=\"headerlink\" title=\"外部排序\"></a>外部排序</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaGFpbWlzaGFzaGEvcC8xMDg5ODcxNS5odG1s\">数据结构与算法系列——排序(15)_外部排序 - 海米傻傻 - 博客园 (cnblogs.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ol>\n<li><p>实现外部排序的 <strong>两个过程</strong>：</p>\n<ol>\n<li>将整个初始文件分为多个初始归并段;</li>\n<li>将初始归并段进行归并，直至得到一个有序的完整文件；</li>\n</ol>\n</li>\n<li><p>时间开销构成</p>\n<ol>\n<li><strong>内部排序</strong> 所需要的时间</li>\n<li><strong>外存信息读写</strong> 所需要的时间 （关键） <ul>\n<li>与归并的趟数有关 <ul>\n<li>k 要大 —– 传统方法 会引起内部归并时间增大 <ul>\n<li>赢者树</li>\n<li>败者树（目的：提高在 k 个归并串中当前值中找到最小值的效率）</li>\n</ul>\n</li>\n<li>m 要小 —– 置换选择排序</li>\n</ul>\n</li>\n<li>Huffman（归并的顺序，对外存的 I/O 次数降到最低）</li>\n</ul>\n</li>\n<li><strong>内部归并</strong> 所需要的时间</li>\n</ol>\n</li>\n<li>为了提高整个外部排序的效率，分别从以上 <strong>两个方面对外部排序</strong> 进行了优化：<ol>\n<li>在实现将初始文件分为 m 个初始归并段时，为了尽量减小 m 的值，<strong>采用置换-选择排序算法(内部使用败者树实现)</strong>，可实现将整个初始文件分为数量较少的长度不等的初始归并段。</li>\n<li>同时在将初始归并段归并为有序完整文件的过程中，为了尽量减少读写外存的次数，采用 <strong>构建最佳归并树的方式（哈夫曼树实现），对初始归并段进行归并（败者树实现）</strong>，而归并的具体实现方法是采用败者树的方式。</li>\n</ol>\n</li>\n<li><strong>优化递进顺序：</strong><ol>\n<li>二路归并【因为硬盘的读写速度比内存要慢的多，按照以上这种方法，每个数据都从硬盘读了三次，写了三次，要花很多时间。考虑 K 路】</li>\n<li>多路归并【K 不是越大越好，因为 K 越大，在内部排序需要的时间越长，效率低。考虑减少初始顺串的数量 M】</li>\n<li>置换选择算法【可以用败者树和堆排序实现，得到多个长度不等的初始归并段，如何设置它们的归并顺序，可以使得对外存的访问次数降到最低? 考虑结合哈夫曼树】</li>\n<li>最佳归并树（置换选择算法+哈夫曼树+多路归并+败者树）</li>\n</ol>\n</li>\n</ol>\n<p>　外部排序算法由两个阶段构成：预处理和合并排序。</p>\n<ol>\n<li><strong>预处理产生有序的顺串：</strong> 按照内存大小，将外存上含有 n 个纪录的大文件分成若干长度为 t 的子文件（t 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对子文件的 t 个纪录进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；这样在外存上就得到了 m 个顺串（m = [n/t]）。</li>\n<li><strong>合并序列：</strong> 对得到的顺段进行合并，直至得到整个有序的文件为止。</li>\n</ol>\n<h3 id=\"k-路平衡归并\"><a href=\"#k-路平衡归并\" class=\"headerlink\" title=\"k-路平衡归并\"></a>k-路平衡归并</h3><p><img src=\"https://s2.loli.net/2024/08/02/c8UeXugYZIFbjOl.jpg\" alt=\"img\"></p>\n<p>在 2G 内存中排序的时候可以选择合适的 <strong>内部排序</strong>，比如快速排序或归并排序等算法。为了方便，我们把排序好的 2G 有序数据称为有序子串。接着把两个小的有序子串合并成一个大的有序子串。</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/3R8r9YqgAvufFl1.jpg\" alt=\"img\"></p>\n<p>假设需要排序的int数有12个，内存一次只能装下3个int数。</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/YzvG5B4lec2m9pS.jpg\" alt=\"k-路平衡归并1\"></p>\n<p> 接下来把12个数据分成4份，然后排序成有序子串：</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/2alThnoFmOAbvfp.jpg\" alt=\"k-路平衡归并2\"></p>\n<p> 然后把子串进行两两合并：</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/tHhCWegpjKd9MJ8.jpg\" alt=\"k-路平衡归并3\"></p>\n<p>  输出哪个元素就在那个元素所在的有序子串再次读入一个元素：</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/jwtZ3Emdc7Wilnk.jpg\" alt=\"k-路平衡归并4\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/02/KdEQi3msxPY7cfU.jpg\" alt=\"k-路平衡归并5\"></p>\n<p>重复直到合并成一个包含6个int有序子串，再把两个包含6个int的有序子串合并成一个包含12个int数据的最终有序子串</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/tgsRBFyWH7jafVu.jpg\" alt=\"k-路平衡归并6\"></p>\n<h3 id=\"多路归并\"><a href=\"#多路归并\" class=\"headerlink\" title=\"多路归并\"></a>多路归并</h3><p><strong>对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多</strong>。8.1 中图中使用的是 2-路平衡归并的方式，举一反三，还可以使用 3-路归并、4-路归并甚至是 10-路归并的方式。</p>\n<p>对于 k-路平衡归并中 k 值得选择，<strong>增加 k 可以减少归并的次数</strong>，从而<strong>减少外存读写的次数</strong>，最终达到提高算法效率的目的。除此之外，一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，归并的次数为：<strong>s=⌊logk⁡m ⌋</strong>（其中 s 表示归并次数）。</p>\n<p>从公式上可以判断出，想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：</p>\n<ul>\n<li><strong>增加 k-路平衡归并中的 k 值；[但不能影响内部归并的效率]</strong></li>\n<li><strong>尽量减少初始归并段的数量 m，即增加每个归并段的容量；</strong></li>\n</ul>\n<blockquote>\n<p><strong>其增加 k 值的想法引申出了一种外部排序算法：多路平衡归并算法；增加数量 m 的想法引申出了另一种外部排序算法：置换-选择排序算法。</strong></p>\n</blockquote>\n<h3 id=\"多路平衡归并排序（胜者树、败者树）\"><a href=\"#多路平衡归并排序（胜者树、败者树）\" class=\"headerlink\" title=\"多路平衡归并排序（胜者树、败者树）\"></a>多路平衡归并排序（胜者树、败者树）</h3><ol>\n<li><p>胜者树</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/sIUWdA1wTFC3Rmq.png\" alt=\"胜者二叉树\"></p>\n<p>当我们将我们的胜者树的最优值输入到我们的输出缓冲区（<strong>输出缓冲区从内存中额外开辟出来的一段，我们存储当前的归并的结果，缓冲区满写入磁盘</strong>）<br>之后，我们的根节点便出现了空的情况，<strong>我们需要从根节点对应的输入缓冲区中在读入一个数据来充当下一次比较的选手</strong>，然后<strong>从下到上进行维护</strong>，我们的每一次的维护都需要比较兄弟的胜者然后选出新一轮的胜者然后一直优化到我们的根的路径上（从低至上，贯穿整个树)之后我们不断地进行上述的操作，指导我们的所有的输入缓冲区已经为空为止。</p>\n</li>\n</ol>\n<p><strong>胜者树和败者树的区别就是：胜者树中的非终端结点中存储的是胜利的一方；而败者树中的非终端结点存储的是失败的一方。而在比较过程中，都是拿胜者去比较。</strong></p>\n<h3 id=\"置换选择排序算法\"><a href=\"#置换选择排序算法\" class=\"headerlink\" title=\"置换选择排序算法\"></a>置换选择排序算法</h3><p><img src=\"https://s2.loli.net/2024/08/02/FniZuMpjCGgAySR.png\" alt=\"置换选择排序算法\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/02/OlN4FT13zHn9yBb.png\" alt=\"置换选择排序算法2\"></p>\n<p>例如已知初始文件中总共有 24 个记录，假设内存工作区最多可容纳 6 个记录，按照之前的选择排序算法最少也只能分为 4 个初始归并段。而如果使用置换—选择排序，可以实现将 24 个记录分为 3 个初始归并段</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/zewPVMgiTRXCrEj.png\" alt=\"置换选择排序算法3\"></p>\n<p>　置换—选择排序算法的具体操作过程为：</p>\n<ol>\n<li>首先从初始文件中输入 6 个记录到内存工作区中；<ol>\n<li>从内存工作区中选出关键字最小的记录，将其记为 MINIMAX 记录；</li>\n<li>然后将 MINIMAX 记录输出到归并段文件中；</li>\n<li>此时内存工作区中还剩余 5 个记录，若初始文件不为空，则从初始文件中输入下一个记录到内存工作区中；</li>\n<li>从内存工作区中的所有比 MINIMAX 值大的记录中选出值最小的关键字的记录，作为新的 MINIMAX 记录；[使用败者树或者堆排序实现]</li>\n<li>重复过程 3—5，直至在内存工作区中选不出新的 MINIMAX 记录为止，由此就得到了一个初始归并段；</li>\n<li>重复 2—6，直至内存工作为空，由此就可以得到全部的初始归并段。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"胜者树、败者树与堆排序\"><a href=\"#胜者树、败者树与堆排序\" class=\"headerlink\" title=\"胜者树、败者树与堆排序\"></a>胜者树、败者树与堆排序</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ul>\n<li><p><strong>堆</strong>：其实一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后再用孩子节点的最小值和父节点进行比较，所以每调整一层需要比较两次。 </p>\n</li>\n<li><p><strong>胜者树</strong>：这时人们想能否简化比较过程，这时就有了胜者树，这样每次比较只用跟自己的兄弟节点进行比较就好，所以用胜者树可以比堆少一半的比较次数。 而胜者树在节点上升的时候首选需要获得父节点，然后再获得兄弟节点，然后再比较。</p>\n</li>\n<li><p><strong>败者树</strong>：这时人们又想能否再次减少比较次数，于是就有了败者树。在使用败者树的时候，每个新元素上升时，只需要获得父节点并比较即可。 </p>\n</li>\n</ul>\n<p>所以总的来说，减少了访存的时间。 现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了。<strong>在外部排序中通常使用败者树。</strong></p>\n<hr>\n<p>胜者树的特点：<br>1、胜者树，是一棵完全二叉树<br>2、每个叶子节点表示一个选手，记录选手的标号<br>3、每个非叶子节点表示一场比赛，记录胜者的标号，而每层也就表示一轮比赛</p>\n<hr>\n<p>败者树：<br>1、败者树，也是一颗完全二叉树<br>2、每个叶子节点表示一个选手，记录选手的标号<br>3、每个非叶子节点表示一场比赛，记录败者的标号，胜者晋级上一层。并且，因为树根节点记录的是败者的标号，会再新建一个节点记录最终胜者的标号。</p>\n<hr>\n<h4 id=\"异同点\"><a href=\"#异同点\" class=\"headerlink\" title=\"异同点\"></a>异同点</h4><p>三者的相同点在于空间和时间复杂度都是 Ologn)级别的</p>\n<p>不同点</p>\n<ul>\n<li><strong>堆</strong>：所有的节点都是关键字； 每次调整一层需要比较两次（父亲 左孩子| 父亲 右孩子）。 </li>\n<li><strong>胜者树</strong>：叶子节点是关键字，非叶子节点保存胜者索引；<strong>每次调整一层需比较 1 次（自己 兄弟），读取两次（父亲| 兄弟）</strong>。</li>\n<li><strong>败者树</strong>：叶子节点是关键字，非叶子节点保存败者索引；<strong>每次调整一层需要比较 1 次（自己 父亲），读取一次（父亲），只需要和路径上的节点比较，不需要和兄弟节点比较</strong>，简化了重构的过程。； 新增 B [0] 记录比赛的胜者【在本例子中是 ls [0]】</li>\n</ul>\n<h4 id=\"胜者树败者树重构阐述\"><a href=\"#胜者树败者树重构阐述\" class=\"headerlink\" title=\"胜者树败者树重构阐述\"></a>胜者树败者树重构阐述</h4><ol>\n<li><p>胜者树</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/i4mZ3sOkxlHFBgD.png\" alt=\"胜者树结构\"> 将 b3 替换成 11，胜者树重构示例：</p>\n<p><img src=\"https://s2.loli.net/2024/08/02/eBYMU2ojSV4fHsQ.png\" alt=\"胜者树重构\"></p>\n<p>重构过程中，先取到父节点的值，拿到选手对应的标号，然后再根据标号拿到选手的值和新插入选手的值比较，胜者写到父节点。</p>\n</li>\n<li><p>败者树</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/2499424/202109/2499424-20210918155013278-334692385.png\" alt=\"败者树结构\"></p>\n<p>将 b3 替换为 13，败者树重构示例：</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/2499424/202109/2499424-20210918155045828-280607642.png\" alt=\"败者树重构\"></p>\n<p>重构上比胜者树有优化，只需要取父节点的值并进行比较</p>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clzwonja50009lowvceutdo2r","category_id":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjao002alowv0cepc135"},{"post_id":"clzwonja50009lowvceutdo2r","category_id":"clzwonjab000olowvayn3cxrt","_id":"clzwonjao002clowvhq4w9agd"},{"post_id":"clzwonja50009lowvceutdo2r","category_id":"clzwonjam0020lowv3flmdjix","_id":"clzwonjao002flowvhv9y6x1q"},{"post_id":"clzwonj9z0001lowv8i5jbuer","category_id":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjap002nlowva8lna0cb"},{"post_id":"clzwonj9z0001lowv8i5jbuer","category_id":"clzwonjab000olowvayn3cxrt","_id":"clzwonjap002olowvbhbdejfj"},{"post_id":"clzwonj9z0001lowv8i5jbuer","category_id":"clzwonjao002glowvb92oh9wa","_id":"clzwonjap002rlowvdpzwcg1o"},{"post_id":"clzwonja6000blowvhnjr5ed1","category_id":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjaq002ylowv7n8j47y8"},{"post_id":"clzwonja6000blowvhnjr5ed1","category_id":"clzwonjab000olowvayn3cxrt","_id":"clzwonjaq0030lowv3cvf8kj0"},{"post_id":"clzwonja6000blowvhnjr5ed1","category_id":"clzwonjap002qlowvg0hj2szx","_id":"clzwonjar0033lowvbn8se1lb"},{"post_id":"clzwonjae0014lowvcex2egsd","category_id":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjar0036lowv6fk1gkrh"},{"post_id":"clzwonjae0014lowvcex2egsd","category_id":"clzwonjab000olowvayn3cxrt","_id":"clzwonjar0038lowvcoe12hsm"},{"post_id":"clzwonjae0014lowvcex2egsd","category_id":"clzwonjaq002xlowvc6pu8ggz","_id":"clzwonjar0039lowv016yegw3"},{"post_id":"clzwonja8000glowv9824892s","category_id":"clzwonjae0012lowv7vxfgpd0","_id":"clzwonjas003dlowvdsjdc8ug"},{"post_id":"clzwonja8000glowv9824892s","category_id":"clzwonjar0034lowv7l7b0jif","_id":"clzwonjas003flowv33yjhw1k"},{"post_id":"clzwonjaf0016lowv4o2nachh","category_id":"clzwonjae0012lowv7vxfgpd0","_id":"clzwonjat003jlowvedh43ejc"},{"post_id":"clzwonjaf0016lowv4o2nachh","category_id":"clzwonjar0037lowvd4672z7z","_id":"clzwonjat003klowvagl45vyj"},{"post_id":"clzwonja20003lowv07qw214u","category_id":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjat003plowvhsvw396t"},{"post_id":"clzwonja20003lowv07qw214u","category_id":"clzwonjab000olowvayn3cxrt","_id":"clzwonjat003qlowvavhi0mwy"},{"post_id":"clzwonja20003lowv07qw214u","category_id":"clzwonjam0020lowv3flmdjix","_id":"clzwonjat003tlowvam7i919s"},{"post_id":"clzwonja40007lowv8akhfn6r","category_id":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjaw004hlowv4hls3886"},{"post_id":"clzwonja40007lowv8akhfn6r","category_id":"clzwonjab000olowvayn3cxrt","_id":"clzwonjaw004jlowv869j4l4h"},{"post_id":"clzwonja40007lowv8akhfn6r","category_id":"clzwonjap002qlowvg0hj2szx","_id":"clzwonjaw004nlowv3ih9dsu4"},{"post_id":"clzwonjab000qlowv6v3n1p5b","category_id":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjay0055lowv1ete5qvc"},{"post_id":"clzwonjab000qlowv6v3n1p5b","category_id":"clzwonjal001vlowv0c0g60d8","_id":"clzwonjaz0056lowv35zlhmyy"},{"post_id":"clzwonjab000qlowv6v3n1p5b","category_id":"clzwonjay0050lowvfatk41y7","_id":"clzwonjaz005alowvbk1vfe4q"},{"post_id":"clzwonjac000slowv9vv3epwp","category_id":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjb2005llowv9iebcn9g"},{"post_id":"clzwonjac000slowv9vv3epwp","category_id":"clzwonjal001vlowv0c0g60d8","_id":"clzwonjb3005nlowvfxqs3b17"},{"post_id":"clzwonjac000slowv9vv3epwp","category_id":"clzwonjay0050lowvfatk41y7","_id":"clzwonjb3005plowv41zj7uqr"},{"post_id":"clzwonjad000xlowv4h971bjd","category_id":"clzwonja30004lowv1e3t6mrq","_id":"clzwonjb3005ulowv4cu61df8"},{"post_id":"clzwonjad000xlowv4h971bjd","category_id":"clzwonjal001vlowv0c0g60d8","_id":"clzwonjb4005xlowv0vhf1iwx"},{"post_id":"clzwonjad000xlowv4h971bjd","category_id":"clzwonjb2005mlowvaqz5521c","_id":"clzwonjb4005zlowvgyj4898j"},{"post_id":"clzwonjaf0019lowv3ob64z5c","category_id":"clzwonjae0012lowv7vxfgpd0","_id":"clzwonjb50065lowva72y6hmf"},{"post_id":"clzwonjaf0019lowv3ob64z5c","category_id":"clzwonjas003blowveonufgwf","_id":"clzwonjb60068lowvcxxg0smw"},{"post_id":"clzwonjaf0019lowv3ob64z5c","category_id":"clzwonjb40060lowv51qccr9g","_id":"clzwonjb6006alowv5cjz8ian"},{"post_id":"clzwonjag001dlowvexr7977y","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjb6006flowvewx6e3p6"},{"post_id":"clzwonjag001dlowvexr7977y","category_id":"clzwonjb0005hlowv5dgq56nm","_id":"clzwonjb6006ilowv509e3uz3"},{"post_id":"clzwonja9000ilowv22p652my","category_id":"clzwonjae0012lowv7vxfgpd0","_id":"clzwonjb7006klowv0ps795vm"},{"post_id":"clzwonja9000ilowv22p652my","category_id":"clzwonjat003slowvasqqfkoa","_id":"clzwonjb7006mlowv3vfgd1ky"},{"post_id":"clzwonja9000ilowv22p652my","category_id":"clzwonjb6006blowv4my1d22r","_id":"clzwonjb7006olowv9tek0whl"},{"post_id":"clzwonjah001flowvgzxkezfo","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjb7006slowv1mwoebn2"},{"post_id":"clzwonjah001flowvgzxkezfo","category_id":"clzwonjb0005hlowv5dgq56nm","_id":"clzwonjb7006ulowvain1fbcy"},{"post_id":"clzwonjai001jlowvel3y9co9","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjb80071lowv80al1p5i"},{"post_id":"clzwonjai001jlowvel3y9co9","category_id":"clzwonjb7006vlowvd0aq20fw","_id":"clzwonjb80074lowvbhenej4x"},{"post_id":"clzwonjai001mlowvazzj1jki","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjb80077lowv5hfx6wko"},{"post_id":"clzwonjai001mlowvazzj1jki","category_id":"clzwonjb7006vlowvd0aq20fw","_id":"clzwonjb80079lowv7xc40wxf"},{"post_id":"clzwonjaa000nlowvad5agj9c","category_id":"clzwonjaj001rlowv3qql2zjb","_id":"clzwonjb9007llowvbltk21kj"},{"post_id":"clzwonjaa000nlowvad5agj9c","category_id":"clzwonjax004qlowvb6i375xh","_id":"clzwonjba007plowv85nxfr1i"},{"post_id":"clzwonjaa000nlowvad5agj9c","category_id":"clzwonjb9007flowv00zcatng","_id":"clzwonjba007rlowv3ngkh8qb"},{"post_id":"clzwonjal001wlowvc6cyef0x","category_id":"clzwonjax004ulowvdb310zjs","_id":"clzwonjba007ulowv0zas3n74"},{"post_id":"clzwonjal001wlowvc6cyef0x","category_id":"clzwonjb9007ilowve8127rg3","_id":"clzwonjba007vlowvg0aq1xh4"},{"post_id":"clzwonjad000vlowv4tnqfzyh","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjbc008alowv5jmvfwer"},{"post_id":"clzwonjad000vlowv4tnqfzyh","category_id":"clzwonjb0005hlowv5dgq56nm","_id":"clzwonjbd008dlowvcx7j2o3v"},{"post_id":"clzwonjad000vlowv4tnqfzyh","category_id":"clzwonjbb0083lowvgifs708v","_id":"clzwonjbd008flowvhckwds0v"},{"post_id":"clzwonjae0010lowv13g73imn","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjbd008hlowv6e39734o"},{"post_id":"clzwonjae0010lowv13g73imn","category_id":"clzwonjb3005rlowvdrp02pht","_id":"clzwonjbd008ilowv7izsge4u"},{"post_id":"clzwonjae0010lowv13g73imn","category_id":"clzwonjbc0086lowvg0nl4dxd","_id":"clzwonjbe008llowv94vqfulh"},{"post_id":"clzwonjae0011lowv7rpo9tbw","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjbe008nlowvb7ks5zx0"},{"post_id":"clzwonjae0011lowv7rpo9tbw","category_id":"clzwonjb0005hlowv5dgq56nm","_id":"clzwonjbe008qlowv7tzo209k"},{"post_id":"clzwonjae0011lowv7rpo9tbw","category_id":"clzwonjbc008blowv2p5ify94","_id":"clzwonjbe008rlowve3obdcm1"},{"post_id":"clzwonjag001blowv8l807ti6","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjbe008slowv5eqo0cbf"},{"post_id":"clzwonjag001blowv8l807ti6","category_id":"clzwonjb50063lowvf4kje1uc","_id":"clzwonjbe008ulowvhzotdc6i"},{"post_id":"clzwonjag001blowv8l807ti6","category_id":"clzwonjbd008glowvcvz30pdf","_id":"clzwonjbe008vlowv9pfog19z"},{"post_id":"clzwonjah001hlowvh35o48cx","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjbe008xlowvc9j6ajxj"},{"post_id":"clzwonjah001hlowvh35o48cx","category_id":"clzwonjb6006jlowv9szw0e31","_id":"clzwonjbe008ylowv26w8ccej"},{"post_id":"clzwonjah001hlowvh35o48cx","category_id":"clzwonjbd008klowvgbq279uy","_id":"clzwonjbf0090lowvddind5ly"},{"post_id":"clzwonjaa000llowv8nisgbt6","category_id":"clzwonjae0012lowv7vxfgpd0","_id":"clzwonjbf0091lowvci1a847k"},{"post_id":"clzwonjaa000llowv8nisgbt6","category_id":"clzwonjat003slowvasqqfkoa","_id":"clzwonjbf0093lowv44gj6b9d"},{"post_id":"clzwonjaa000llowv8nisgbt6","category_id":"clzwonjb7006qlowvb9md2fzb","_id":"clzwonjbf0094lowvft6lfw9n"},{"post_id":"clzwonjaa000llowv8nisgbt6","category_id":"clzwonjbe008plowvb9f4e4v2","_id":"clzwonjbf0096lowvestu7fkx"},{"post_id":"clzwonjaj001plowv383h09a0","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjbf0097lowv9zx79qkq"},{"post_id":"clzwonjaj001plowv383h09a0","category_id":"clzwonjb7006vlowvd0aq20fw","_id":"clzwonjbf0099lowv4wqx1c37"},{"post_id":"clzwonjaj001plowv383h09a0","category_id":"clzwonjbe008tlowvcm0lgzcv","_id":"clzwonjbf009alowvhew287pj"},{"post_id":"clzwonjak001slowvfa3hdvg1","category_id":"clzwonjao0029lowv45plfo8p","_id":"clzwonjbf009clowv9fnl0cx0"},{"post_id":"clzwonjak001slowvfa3hdvg1","category_id":"clzwonjb7006vlowvd0aq20fw","_id":"clzwonjbg009dlowv3pn37qq4"},{"post_id":"clzwonjak001slowvfa3hdvg1","category_id":"clzwonjbe008wlowvbqo5hz6e","_id":"clzwonjbg009flowv0uvidta3"},{"post_id":"clzwonjak001tlowv5rq2a4up","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjbg009ilowv8e346buo"},{"post_id":"clzwonjak001tlowv5rq2a4up","category_id":"clzwonjb8007blowva138bibb","_id":"clzwonjbg009jlowvg6mt6rqi"},{"post_id":"clzwonjak001tlowv5rq2a4up","category_id":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbg009llowv8db0aunb"},{"post_id":"clzwonjak001tlowv5rq2a4up","category_id":"clzwonjbg009elowv4fo36rn2","_id":"clzwonjbg009mlowv7knb62jp"},{"post_id":"clzwonjal001xlowv8lrqdg1c","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjbg009olowva51ugnr7"},{"post_id":"clzwonjal001xlowv8lrqdg1c","category_id":"clzwonjb8007blowva138bibb","_id":"clzwonjbh009plowvb73sg5lr"},{"post_id":"clzwonjal001xlowv8lrqdg1c","category_id":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbh009qlowvco0pa3au"},{"post_id":"clzwonjal001xlowv8lrqdg1c","category_id":"clzwonjbg009elowv4fo36rn2","_id":"clzwonjbh009rlowv1b6s4lqi"},{"post_id":"clzwonjam001zlowvdtz1fm6v","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjbh009slowv7uhpfhzh"},{"post_id":"clzwonjam001zlowvdtz1fm6v","category_id":"clzwonjb8007blowva138bibb","_id":"clzwonjbh009tlowvfqix9cr5"},{"post_id":"clzwonjam001zlowvdtz1fm6v","category_id":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbh009ulowvb6860c3z"},{"post_id":"clzwonjam001zlowvdtz1fm6v","category_id":"clzwonjbg009elowv4fo36rn2","_id":"clzwonjbh009vlowv3xvfgwy6"},{"post_id":"clzwonjam0022lowvexcn8zm6","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjbh009wlowv0ic0h2q3"},{"post_id":"clzwonjam0022lowvexcn8zm6","category_id":"clzwonjb8007blowva138bibb","_id":"clzwonjbh009xlowvazcegzjt"},{"post_id":"clzwonjam0022lowvexcn8zm6","category_id":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbh009ylowvhxzo9j2w"},{"post_id":"clzwonjam0022lowvexcn8zm6","category_id":"clzwonjbg009elowv4fo36rn2","_id":"clzwonjbh009zlowv8qqgcr27"},{"post_id":"clzwonjan0025lowv1hth8r6z","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjbh00a0lowv66jigo7t"},{"post_id":"clzwonjan0025lowv1hth8r6z","category_id":"clzwonjb8007blowva138bibb","_id":"clzwonjbh00a1lowvalrs8q4f"},{"post_id":"clzwonjan0025lowv1hth8r6z","category_id":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbh00a2lowv9kpq68ve"},{"post_id":"clzwonjan0025lowv1hth8r6z","category_id":"clzwonjbg009elowv4fo36rn2","_id":"clzwonjbh00a3lowv7cxc2p8u"},{"post_id":"clzwonjbi00a4lowvb2dga8e8","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjbk00aalowv3cy5dru0"},{"post_id":"clzwonjbi00a4lowvb2dga8e8","category_id":"clzwonjb8007blowva138bibb","_id":"clzwonjbl00adlowv5kgw6bmf"},{"post_id":"clzwonjbi00a4lowvb2dga8e8","category_id":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbl00aflowv7tmm4kv2"},{"post_id":"clzwonjbi00a4lowvb2dga8e8","category_id":"clzwonjbg009elowv4fo36rn2","_id":"clzwonjbl00ahlowv214uhasv"},{"post_id":"clzwonjbj00a5lowv3vba0xo5","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjbl00ajlowv15ph5h8n"},{"post_id":"clzwonjbj00a5lowv3vba0xo5","category_id":"clzwonjb8007blowva138bibb","_id":"clzwonjbl00allowv0xz36ym9"},{"post_id":"clzwonjbj00a5lowv3vba0xo5","category_id":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbl00anlowvcu1gf8i1"},{"post_id":"clzwonjbj00a5lowv3vba0xo5","category_id":"clzwonjbg009elowv4fo36rn2","_id":"clzwonjbl00aplowvho2i94qn"},{"post_id":"clzwonjbj00a7lowvf6ws7xca","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjbl00arlowvep2n04bu"},{"post_id":"clzwonjbj00a7lowvf6ws7xca","category_id":"clzwonjb8007blowva138bibb","_id":"clzwonjbl00atlowv12wv6y85"},{"post_id":"clzwonjbj00a7lowvf6ws7xca","category_id":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbl00avlowv1khe160g"},{"post_id":"clzwonjbj00a7lowvf6ws7xca","category_id":"clzwonjbg009elowv4fo36rn2","_id":"clzwonjbl00axlowvfx35agpy"},{"post_id":"clzwonjbk00a9lowvbwh69gbk","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjbl00azlowvdigl5r5y"},{"post_id":"clzwonjbk00a9lowvbwh69gbk","category_id":"clzwonjb8007blowva138bibb","_id":"clzwonjbl00b1lowveb1ralts"},{"post_id":"clzwonjbk00a9lowvbwh69gbk","category_id":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbl00b2lowvf9jd70dc"},{"post_id":"clzwonjbk00a9lowvbwh69gbk","category_id":"clzwonjbg009elowv4fo36rn2","_id":"clzwonjbl00b3lowva673hmed"},{"post_id":"clzwonjbk00aclowvhi9o9o3w","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzwonjbl00b4lowvfqil3kg3"},{"post_id":"clzwonjbk00aclowvhi9o9o3w","category_id":"clzwonjb8007blowva138bibb","_id":"clzwonjbl00b5lowv4ez7e2gc"},{"post_id":"clzwonjbk00aclowvhi9o9o3w","category_id":"clzwonjbe008zlowv54lq6yk3","_id":"clzwonjbl00b6lowv0lmfh4a8"},{"post_id":"clzwonjbk00aclowvhi9o9o3w","category_id":"clzwonjbg009elowv4fo36rn2","_id":"clzwonjbl00b7lowvdrzlfwny"},{"post_id":"clzy68qq10005m8wvd2esgs1r","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqa000jm8wv6btrc8xv"},{"post_id":"clzy68qq10005m8wvd2esgs1r","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqb000nm8wv25zy6r2b"},{"post_id":"clzy68qq10005m8wvd2esgs1r","category_id":"clzy68qq6000bm8wvcrouf33u","_id":"clzy68qqc000pm8wv0l9uchnc"},{"post_id":"clzy68qpo0000m8wv3ui74yiq","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqd000tm8wva9fp56gm"},{"post_id":"clzy68qpo0000m8wv3ui74yiq","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqe000wm8wv07xjerjq"},{"post_id":"clzy68qpo0000m8wv3ui74yiq","category_id":"clzy68qq8000fm8wvgulr6zj1","_id":"clzy68qqf0011m8wvccyn7895"},{"post_id":"clzy68qq20006m8wvhzav778g","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqg0013m8wvhwxm3g93"},{"post_id":"clzy68qq20006m8wvhzav778g","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqg0017m8wv1lo15sqf"},{"post_id":"clzy68qq20006m8wvhzav778g","category_id":"clzy68qq6000bm8wvcrouf33u","_id":"clzy68qqg0019m8wv46ujaqlz"},{"post_id":"clzy68qq50009m8wv0sy5dynu","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqh001dm8wvdzh11nr0"},{"post_id":"clzy68qq50009m8wv0sy5dynu","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqh001fm8wve076er1f"},{"post_id":"clzy68qq50009m8wv0sy5dynu","category_id":"clzy68qq6000bm8wvcrouf33u","_id":"clzy68qqi001jm8wv00z96des"},{"post_id":"clzy68qpz0003m8wv1qcgg0p7","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqi001lm8wverjs72cj"},{"post_id":"clzy68qpz0003m8wv1qcgg0p7","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqj001pm8wvaefkbarq"},{"post_id":"clzy68qpz0003m8wv1qcgg0p7","category_id":"clzy68qq6000bm8wvcrouf33u","_id":"clzy68qqj001rm8wv1x8516g6"},{"post_id":"clzy68qq7000dm8wvcevb1k37","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqk001vm8wv4szc3z49"},{"post_id":"clzy68qq7000dm8wvcevb1k37","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqk001xm8wvek2v2mwy"},{"post_id":"clzy68qq7000dm8wvcevb1k37","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqk0021m8wvdjop0bvh"},{"post_id":"clzy68qq7000em8wvc54rf8yc","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qql0023m8wvhvli86xc"},{"post_id":"clzy68qq7000em8wvc54rf8yc","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qql0027m8wv295jbprh"},{"post_id":"clzy68qq7000em8wvc54rf8yc","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qql0029m8wv35tk7zy2"},{"post_id":"clzy68qq9000hm8wv9a2wg8nj","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqm002dm8wv1je1ckzp"},{"post_id":"clzy68qq9000hm8wv9a2wg8nj","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqm002fm8wv9z7j514z"},{"post_id":"clzy68qq9000hm8wv9a2wg8nj","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqn002jm8wv1ng188aq"},{"post_id":"clzy68qq9000im8wveaip8uma","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqn002lm8wv9dl26yio"},{"post_id":"clzy68qq9000im8wveaip8uma","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqn002om8wvhz2a3ng1"},{"post_id":"clzy68qq9000im8wveaip8uma","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqn002qm8wv9gk0h3uu"},{"post_id":"clzy68qqa000mm8wv33osa11v","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqo002tm8wvee9b8n3i"},{"post_id":"clzy68qqa000mm8wv33osa11v","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqo002vm8wvdwd71mc5"},{"post_id":"clzy68qqa000mm8wv33osa11v","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqo002xm8wvfbyh3r5e"},{"post_id":"clzy68qqb000om8wv8r9q0rg1","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqo002zm8wvgxc71mx2"},{"post_id":"clzy68qqb000om8wv8r9q0rg1","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqo0031m8wv7hp6f1b9"},{"post_id":"clzy68qqb000om8wv8r9q0rg1","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqp0033m8wv7i29ga8w"},{"post_id":"clzy68qqc000rm8wv9528acht","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqp0035m8wv99pkakyg"},{"post_id":"clzy68qqc000rm8wv9528acht","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqp0037m8wvaiiahidq"},{"post_id":"clzy68qqc000rm8wv9528acht","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqp0039m8wvfy02g2wr"},{"post_id":"clzy68qqd000vm8wvcjfccckr","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqp003bm8wvh9648m5m"},{"post_id":"clzy68qqd000vm8wvcjfccckr","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqp003cm8wvcjxl2atr"},{"post_id":"clzy68qqd000vm8wvcjfccckr","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqp003dm8wv85tv8a51"},{"post_id":"clzy68qqe000zm8wv46cb0fgy","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqp003em8wv6b8a7kzu"},{"post_id":"clzy68qqe000zm8wv46cb0fgy","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqp003fm8wvh4xwbu58"},{"post_id":"clzy68qqe000zm8wv46cb0fgy","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqp003gm8wv76zfhsjh"},{"post_id":"clzy68qqr003hm8wv42ub7ko5","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqu003nm8wv7oc8aomx"},{"post_id":"clzy68qqr003hm8wv42ub7ko5","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqu003qm8wvcz0edo3h"},{"post_id":"clzy68qqr003hm8wv42ub7ko5","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqv003tm8wv2xdm9gn3"},{"post_id":"clzy68qqs003im8wv6yqd3bmn","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqw003wm8wv4yh75rd8"},{"post_id":"clzy68qqs003im8wv6yqd3bmn","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqw003zm8wv4sxz8wvw"},{"post_id":"clzy68qqs003im8wv6yqd3bmn","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqx0042m8wv6a1najlo"},{"post_id":"clzy68qqt003km8wvay5ubjyh","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqy0045m8wv6vlwc7lh"},{"post_id":"clzy68qqt003km8wvay5ubjyh","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqy0047m8wv3stk7qyd"},{"post_id":"clzy68qqt003km8wvay5ubjyh","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqy0049m8wv8wwrg3d8"},{"post_id":"clzy68qqt003mm8wv4gascd73","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqy004bm8wv5hm86t1y"},{"post_id":"clzy68qqt003mm8wv4gascd73","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqy004dm8wv7sewerrb"},{"post_id":"clzy68qqt003mm8wv4gascd73","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqy004fm8wvbhzr31g9"},{"post_id":"clzy68qqu003pm8wvd8h27zpm","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqy004hm8wverf9aane"},{"post_id":"clzy68qqu003pm8wvd8h27zpm","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqy004jm8wv20gmh07e"},{"post_id":"clzy68qqu003pm8wvd8h27zpm","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqy004lm8wv48y98zht"},{"post_id":"clzy68qqu003sm8wv4eqg7vi8","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqy004nm8wv5yl2cuqc"},{"post_id":"clzy68qqu003sm8wv4eqg7vi8","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqy004pm8wvhfhsb5dn"},{"post_id":"clzy68qqu003sm8wv4eqg7vi8","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqy004rm8wv5d1y294f"},{"post_id":"clzy68qqv003vm8wv27d11ut9","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqy004tm8wvhzrp54br"},{"post_id":"clzy68qqv003vm8wv27d11ut9","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqz004um8wve01e3738"},{"post_id":"clzy68qqv003vm8wv27d11ut9","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqz004vm8wvhjgb9jgv"},{"post_id":"clzy68qqw003ym8wvhndseyd1","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqz004wm8wv2v4b1tzd"},{"post_id":"clzy68qqw003ym8wvhndseyd1","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqz004xm8wv1c5zdz40"},{"post_id":"clzy68qqw003ym8wvhndseyd1","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqz004ym8wv2lqra07m"},{"post_id":"clzy68qqw0041m8wvc4r37tsc","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqz004zm8wv2dfg4kno"},{"post_id":"clzy68qqw0041m8wvc4r37tsc","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqz0050m8wv2cjw112q"},{"post_id":"clzy68qqw0041m8wvc4r37tsc","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqz0051m8wv5qv92kn0"},{"post_id":"clzy68qqx0044m8wv2gymf4tw","category_id":"clzwonjaw004mlowv3noo7a89","_id":"clzy68qqz0052m8wv57zk8zfy"},{"post_id":"clzy68qqx0044m8wv2gymf4tw","category_id":"clzy68qq00004m8wve1rscwwj","_id":"clzy68qqz0053m8wvgub18077"},{"post_id":"clzy68qqx0044m8wv2gymf4tw","category_id":"clzy68qqg0015m8wvh4rxfhww","_id":"clzy68qqz0054m8wv9pzj4vfc"}],"PostTag":[{"post_id":"clzwonj9z0001lowv8i5jbuer","tag_id":"clzwonja40005lowv22f3hgbe","_id":"clzwonja8000elowv7q4c3usc"},{"post_id":"clzwonja6000blowvhnjr5ed1","tag_id":"clzwonja40005lowv22f3hgbe","_id":"clzwonja9000hlowvdd3ugffs"},{"post_id":"clzwonja20003lowv07qw214u","tag_id":"clzwonja7000dlowvffoddf6v","_id":"clzwonjaa000mlowvahvrfdmw"},{"post_id":"clzwonja40007lowv8akhfn6r","tag_id":"clzwonja40005lowv22f3hgbe","_id":"clzwonjac000rlowvfu7kf084"},{"post_id":"clzwonja50009lowvceutdo2r","tag_id":"clzwonja7000dlowvffoddf6v","_id":"clzwonjad000wlowv3hn85h0w"},{"post_id":"clzwonja8000glowv9824892s","tag_id":"clzwonjac000ulowv2k5440nj","_id":"clzwonjaf0015lowv50ydeb6l"},{"post_id":"clzwonja8000glowv9824892s","tag_id":"clzwonjad000zlowvgeai2c16","_id":"clzwonjaf0018lowvc98qbotq"},{"post_id":"clzwonja9000ilowv22p652my","tag_id":"clzwonjae0013lowv28vvetyl","_id":"clzwonjai001klowv1hur7wtk"},{"post_id":"clzwonja9000ilowv22p652my","tag_id":"clzwonjag001alowvdqlv12qj","_id":"clzwonjaj001nlowv03473ycz"},{"post_id":"clzwonja9000ilowv22p652my","tag_id":"clzwonjah001elowvcxnk5irh","_id":"clzwonjaj001qlowva6829uvz"},{"post_id":"clzwonjaa000llowv8nisgbt6","tag_id":"clzwonjai001ilowv1m9g4eik","_id":"clzwonjam0021lowvfjspbllm"},{"post_id":"clzwonjaa000llowv8nisgbt6","tag_id":"clzwonjaj001olowvgx7ef4wn","_id":"clzwonjan0023lowv5b003bwx"},{"post_id":"clzwonjaa000llowv8nisgbt6","tag_id":"clzwonjak001ulowvdzwuamy6","_id":"clzwonjan0026lowvbqar6lka"},{"post_id":"clzwonjaa000nlowvad5agj9c","tag_id":"clzwonjae0013lowv28vvetyl","_id":"clzwonjao002blowve5to9xkz"},{"post_id":"clzwonjaa000nlowvad5agj9c","tag_id":"clzwonjan0024lowvcodz17kt","_id":"clzwonjao002dlowvhks5af8k"},{"post_id":"clzwonjab000qlowv6v3n1p5b","tag_id":"clzwonjao0028lowv7i25azwa","_id":"clzwonjao002hlowv7bu6dzj7"},{"post_id":"clzwonjac000slowv9vv3epwp","tag_id":"clzwonjao0028lowv7i25azwa","_id":"clzwonjap002jlowv6tlxda3y"},{"post_id":"clzwonjad000vlowv4tnqfzyh","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjaq002ulowv37222nt1"},{"post_id":"clzwonjad000vlowv4tnqfzyh","tag_id":"clzwonjap002llowv7ro96k4z","_id":"clzwonjaq002vlowve1cthznh"},{"post_id":"clzwonjad000vlowv4tnqfzyh","tag_id":"clzwonjap002plowv28mo42np","_id":"clzwonjaq002zlowv6t8xa4ze"},{"post_id":"clzwonjad000xlowv4h971bjd","tag_id":"clzwonjap002slowv7zn7cd0h","_id":"clzwonjaq0031lowvg4rr6njc"},{"post_id":"clzwonjae0010lowv13g73imn","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjas003clowv9v6o482s"},{"post_id":"clzwonjae0010lowv13g73imn","tag_id":"clzwonjaq0032lowv5twv5q6g","_id":"clzwonjas003elowve63ucdiv"},{"post_id":"clzwonjae0010lowv13g73imn","tag_id":"clzwonjar0035lowv1go8d9y1","_id":"clzwonjas003ilowvaw50b3it"},{"post_id":"clzwonjae0011lowv7rpo9tbw","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjau003ulowvbffp1f31"},{"post_id":"clzwonjae0011lowv7rpo9tbw","tag_id":"clzwonjap002llowv7ro96k4z","_id":"clzwonjau003vlowvhhc4boge"},{"post_id":"clzwonjae0011lowv7rpo9tbw","tag_id":"clzwonjat003llowvfbo24iiw","_id":"clzwonjau003ylowv36akh7e8"},{"post_id":"clzwonjae0011lowv7rpo9tbw","tag_id":"clzwonjat003nlowv5pz32qol","_id":"clzwonjau003zlowvei1u5b65"},{"post_id":"clzwonjae0014lowvcex2egsd","tag_id":"clzwonjat003rlowv02rvh97j","_id":"clzwonjau0042lowv30m31rkr"},{"post_id":"clzwonjaf0016lowv4o2nachh","tag_id":"clzwonjau003wlowv2i07d9ga","_id":"clzwonjav0047lowve2nrh2mv"},{"post_id":"clzwonjaf0016lowv4o2nachh","tag_id":"clzwonjau0041lowv4e4s6524","_id":"clzwonjav0049lowvgys5fzoj"},{"post_id":"clzwonjaf0016lowv4o2nachh","tag_id":"clzwonjau0044lowv47ip990k","_id":"clzwonjav004blowv1nxsesx9"},{"post_id":"clzwonjaf0019lowv3ob64z5c","tag_id":"clzwonjav0046lowvazh6alk9","_id":"clzwonjaw004ilowvbx886f9a"},{"post_id":"clzwonjaf0019lowv3ob64z5c","tag_id":"clzwonjav004alowveump1wz5","_id":"clzwonjaw004klowvbqbggu2u"},{"post_id":"clzwonjaf0019lowv3ob64z5c","tag_id":"clzwonjaw004dlowva9r58t10","_id":"clzwonjaw004olowv3njnf0x9"},{"post_id":"clzwonjag001blowv8l807ti6","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjax004rlowvafga805e"},{"post_id":"clzwonjag001blowv8l807ti6","tag_id":"clzwonjaw004llowv4kgj7jbi","_id":"clzwonjax004slowvfn17bh65"},{"post_id":"clzwonjag001dlowvexr7977y","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjax004wlowvbmur5w5w"},{"post_id":"clzwonjag001dlowvexr7977y","tag_id":"clzwonjap002llowv7ro96k4z","_id":"clzwonjay004ylowv7rut301m"},{"post_id":"clzwonjah001flowvgzxkezfo","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjaz0058lowvdabthp1l"},{"post_id":"clzwonjah001flowvgzxkezfo","tag_id":"clzwonjap002llowv7ro96k4z","_id":"clzwonjaz005blowvhqmufm85"},{"post_id":"clzwonjah001flowvgzxkezfo","tag_id":"clzwonjay0051lowvdle68voo","_id":"clzwonjaz005dlowv6wyz7azz"},{"post_id":"clzwonjah001flowvgzxkezfo","tag_id":"clzwonjay0053lowvcrup7xxh","_id":"clzwonjaz005flowv35vza851"},{"post_id":"clzwonjah001hlowvh35o48cx","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjb2005ilowv1b9s5gih"},{"post_id":"clzwonjah001hlowvh35o48cx","tag_id":"clzwonjaz005clowv5qdp6su3","_id":"clzwonjb2005jlowva33n8a9i"},{"post_id":"clzwonjai001jlowvel3y9co9","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjb3005qlowvbqwzdmbv"},{"post_id":"clzwonjai001jlowvel3y9co9","tag_id":"clzwonjat003nlowv5pz32qol","_id":"clzwonjb3005slowvhfixfgii"},{"post_id":"clzwonjai001mlowvazzj1jki","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjb4005ylowv34ic8lpf"},{"post_id":"clzwonjai001mlowvazzj1jki","tag_id":"clzwonjat003nlowv5pz32qol","_id":"clzwonjb40061lowv46ug1mut"},{"post_id":"clzwonjaj001plowv383h09a0","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjb60069lowv9yvrbwj1"},{"post_id":"clzwonjaj001plowv383h09a0","tag_id":"clzwonjat003nlowv5pz32qol","_id":"clzwonjb6006clowv8qkndm38"},{"post_id":"clzwonjaj001plowv383h09a0","tag_id":"clzwonjb50064lowv6ol6d1t7","_id":"clzwonjb6006elowvde1j5lej"},{"post_id":"clzwonjak001slowvfa3hdvg1","tag_id":"clzwonjao002ilowvf9j14iti","_id":"clzwonjb7006nlowv65tjekwc"},{"post_id":"clzwonjak001slowvfa3hdvg1","tag_id":"clzwonjat003nlowv5pz32qol","_id":"clzwonjb7006plowvda9g8fdg"},{"post_id":"clzwonjak001slowvfa3hdvg1","tag_id":"clzwonjb6006hlowv991pbc7n","_id":"clzwonjb7006tlowv4bmj9p6j"},{"post_id":"clzwonjak001tlowv5rq2a4up","tag_id":"clzwonjb7006llowvhywe60hc","_id":"clzwonjb8006zlowv44sg6j0e"},{"post_id":"clzwonjak001tlowv5rq2a4up","tag_id":"clzwonjb7006rlowv5lat4geo","_id":"clzwonjb80072lowvh9mp0bte"},{"post_id":"clzwonjak001tlowv5rq2a4up","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzwonjb80075lowvgzzscsut"},{"post_id":"clzwonjal001wlowvc6cyef0x","tag_id":"clzwonjae0013lowv28vvetyl","_id":"clzwonjb8007alowv8nrffrpw"},{"post_id":"clzwonjal001wlowvc6cyef0x","tag_id":"clzwonjb8006ylowv8pttepa2","_id":"clzwonjb9007clowv9f1ncclq"},{"post_id":"clzwonjal001wlowvc6cyef0x","tag_id":"clzwonjah001elowvcxnk5irh","_id":"clzwonjb9007elowv2xtch0dq"},{"post_id":"clzwonjal001wlowvc6cyef0x","tag_id":"clzwonjb80073lowv6lgcbtzw","_id":"clzwonjb9007glowvbmvdc3cs"},{"post_id":"clzwonjal001xlowv8lrqdg1c","tag_id":"clzwonjb7006llowvhywe60hc","_id":"clzwonjb9007klowv8kwugsvx"},{"post_id":"clzwonjal001xlowv8lrqdg1c","tag_id":"clzwonjb7006rlowv5lat4geo","_id":"clzwonjb9007mlowv0vmh4ohb"},{"post_id":"clzwonjal001xlowv8lrqdg1c","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzwonjba007qlowvh57h0lt6"},{"post_id":"clzwonjam001zlowvdtz1fm6v","tag_id":"clzwonjb7006llowvhywe60hc","_id":"clzwonjba007ylowv2qvnhx13"},{"post_id":"clzwonjam001zlowvdtz1fm6v","tag_id":"clzwonjb7006rlowv5lat4geo","_id":"clzwonjba007zlowvbsylenm4"},{"post_id":"clzwonjam001zlowvdtz1fm6v","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzwonjbb0082lowv1ee93hzv"},{"post_id":"clzwonjam0022lowvexcn8zm6","tag_id":"clzwonjb7006llowvhywe60hc","_id":"clzwonjbc0087lowv9p5efl3a"},{"post_id":"clzwonjam0022lowvexcn8zm6","tag_id":"clzwonjb7006rlowv5lat4geo","_id":"clzwonjbc0088lowv7ffzhpe1"},{"post_id":"clzwonjam0022lowvexcn8zm6","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzwonjbd008clowvaec8cee2"},{"post_id":"clzwonjan0025lowv1hth8r6z","tag_id":"clzwonjb7006llowvhywe60hc","_id":"clzwonjbd008jlowv7cpc3g39"},{"post_id":"clzwonjan0025lowv1hth8r6z","tag_id":"clzwonjb7006rlowv5lat4geo","_id":"clzwonjbe008mlowv1xwjgqrg"},{"post_id":"clzwonjan0025lowv1hth8r6z","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzwonjbe008olowvdjuc4llz"},{"post_id":"clzwonjbi00a4lowvb2dga8e8","tag_id":"clzwonjb7006llowvhywe60hc","_id":"clzwonjbj00a6lowv8jvh0376"},{"post_id":"clzwonjbi00a4lowvb2dga8e8","tag_id":"clzwonjb7006rlowv5lat4geo","_id":"clzwonjbk00a8lowvct3z9opg"},{"post_id":"clzwonjbi00a4lowvb2dga8e8","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzwonjbk00ablowva2hjfdwg"},{"post_id":"clzwonjbj00a5lowv3vba0xo5","tag_id":"clzwonjb7006llowvhywe60hc","_id":"clzwonjbl00aelowv4rejb98v"},{"post_id":"clzwonjbj00a5lowv3vba0xo5","tag_id":"clzwonjb7006rlowv5lat4geo","_id":"clzwonjbl00aglowvc64c0fai"},{"post_id":"clzwonjbj00a5lowv3vba0xo5","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzwonjbl00ailowv8uyk9zgv"},{"post_id":"clzwonjbj00a7lowvf6ws7xca","tag_id":"clzwonjb7006llowvhywe60hc","_id":"clzwonjbl00aklowv7s2077r9"},{"post_id":"clzwonjbj00a7lowvf6ws7xca","tag_id":"clzwonjb7006rlowv5lat4geo","_id":"clzwonjbl00amlowv3zf43du2"},{"post_id":"clzwonjbj00a7lowvf6ws7xca","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzwonjbl00aolowvgton2pb8"},{"post_id":"clzwonjbk00a9lowvbwh69gbk","tag_id":"clzwonjb7006llowvhywe60hc","_id":"clzwonjbl00aqlowv24aday01"},{"post_id":"clzwonjbk00a9lowvbwh69gbk","tag_id":"clzwonjb7006rlowv5lat4geo","_id":"clzwonjbl00aslowv5rli29qa"},{"post_id":"clzwonjbk00a9lowvbwh69gbk","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzwonjbl00aulowv5yac90da"},{"post_id":"clzwonjbk00aclowvhi9o9o3w","tag_id":"clzwonjb7006llowvhywe60hc","_id":"clzwonjbl00awlowv5yvqcifc"},{"post_id":"clzwonjbk00aclowvhi9o9o3w","tag_id":"clzwonjb7006rlowv5lat4geo","_id":"clzwonjbl00aylowv68mh77si"},{"post_id":"clzwonjbk00aclowvhi9o9o3w","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzwonjbl00b0lowv39d1aov8"},{"post_id":"clzy68qqb000om8wv8r9q0rg1","tag_id":"clzy68qq7000cm8wv8lrhbyey","_id":"clzy68qqd000um8wvajqtaam7"},{"post_id":"clzy68qqb000om8wv8r9q0rg1","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqe000xm8wvd8p5he2p"},{"post_id":"clzy68qpo0000m8wv3ui74yiq","tag_id":"clzwonjan0024lowvcodz17kt","_id":"clzy68qqf0012m8wvghe415ng"},{"post_id":"clzy68qpo0000m8wv3ui74yiq","tag_id":"clzy68qpv0002m8wv13zualw2","_id":"clzy68qqg0014m8wvgr9ug7pz"},{"post_id":"clzy68qpo0000m8wv3ui74yiq","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqg0018m8wv7zxt682a"},{"post_id":"clzy68qpo0000m8wv3ui74yiq","tag_id":"clzy68qq7000cm8wv8lrhbyey","_id":"clzy68qqg001am8wvhceu6a27"},{"post_id":"clzy68qpo0000m8wv3ui74yiq","tag_id":"clzy68qq8000gm8wvecwa853s","_id":"clzy68qqh001em8wvg6wy0q97"},{"post_id":"clzy68qpo0000m8wv3ui74yiq","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqh001gm8wvhsul7v2v"},{"post_id":"clzy68qpo0000m8wv3ui74yiq","tag_id":"clzwonjb7006wlowv367n4tfn","_id":"clzy68qqi001km8wv98kgc4wq"},{"post_id":"clzy68qqc000rm8wv9528acht","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqi001mm8wv2s763r7c"},{"post_id":"clzy68qqc000rm8wv9528acht","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqj001qm8wv258sbvr6"},{"post_id":"clzy68qqd000vm8wvcjfccckr","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqj001sm8wvab9ydyqv"},{"post_id":"clzy68qqd000vm8wvcjfccckr","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqk001wm8wvdbdj579v"},{"post_id":"clzy68qqe000zm8wv46cb0fgy","tag_id":"clzy68qq7000cm8wv8lrhbyey","_id":"clzy68qqk001ym8wv4twn22nk"},{"post_id":"clzy68qqe000zm8wv46cb0fgy","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqk0022m8wv0v5273s1"},{"post_id":"clzy68qpz0003m8wv1qcgg0p7","tag_id":"clzy68qqd000sm8wvas0eeuy7","_id":"clzy68qql0024m8wvdlp6f07t"},{"post_id":"clzy68qpz0003m8wv1qcgg0p7","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qql0028m8wv83nv0ly5"},{"post_id":"clzy68qq10005m8wvd2esgs1r","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qql002am8wvgoqv9bxd"},{"post_id":"clzy68qq10005m8wvd2esgs1r","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqm002em8wvb0636thu"},{"post_id":"clzy68qq20006m8wvhzav778g","tag_id":"clzy68qq8000gm8wvecwa853s","_id":"clzy68qqm002gm8wv0gzg0pqo"},{"post_id":"clzy68qq20006m8wvhzav778g","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqn002km8wv4w0v1f6n"},{"post_id":"clzy68qq50009m8wv0sy5dynu","tag_id":"clzy68qq7000cm8wv8lrhbyey","_id":"clzy68qqn002mm8wvhgmiguum"},{"post_id":"clzy68qq50009m8wv0sy5dynu","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqn002pm8wv7uj97ift"},{"post_id":"clzy68qq7000dm8wvcevb1k37","tag_id":"clzy68qq7000cm8wv8lrhbyey","_id":"clzy68qqo002rm8wvfbj12o64"},{"post_id":"clzy68qq7000dm8wvcevb1k37","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqo002um8wv1peaa3l4"},{"post_id":"clzy68qq7000em8wvc54rf8yc","tag_id":"clzy68qq7000cm8wv8lrhbyey","_id":"clzy68qqo002wm8wvb8t9bkj0"},{"post_id":"clzy68qq7000em8wvc54rf8yc","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqo002ym8wv1mr8avcf"},{"post_id":"clzy68qq9000hm8wv9a2wg8nj","tag_id":"clzy68qq7000cm8wv8lrhbyey","_id":"clzy68qqo0030m8wva4bieudd"},{"post_id":"clzy68qq9000hm8wv9a2wg8nj","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqo0032m8wvc3j8fyqd"},{"post_id":"clzy68qq9000im8wveaip8uma","tag_id":"clzy68qq7000cm8wv8lrhbyey","_id":"clzy68qqp0034m8wv0pjl58qm"},{"post_id":"clzy68qq9000im8wveaip8uma","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqp0036m8wv38zs80vh"},{"post_id":"clzy68qqa000mm8wv33osa11v","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqp0038m8wv5tgl5emf"},{"post_id":"clzy68qqa000mm8wv33osa11v","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqp003am8wvc3aseuvw"},{"post_id":"clzy68qqr003hm8wv42ub7ko5","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqt003jm8wvfg9z8w36"},{"post_id":"clzy68qqr003hm8wv42ub7ko5","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqt003lm8wvf8c7c721"},{"post_id":"clzy68qqs003im8wv6yqd3bmn","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqu003om8wv8phsdp9c"},{"post_id":"clzy68qqs003im8wv6yqd3bmn","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqu003rm8wvdwn20dib"},{"post_id":"clzy68qqt003km8wvay5ubjyh","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqv003um8wvdetp1rx5"},{"post_id":"clzy68qqt003km8wvay5ubjyh","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqw003xm8wv5ccxf34i"},{"post_id":"clzy68qqt003mm8wv4gascd73","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqw0040m8wvhxendfkf"},{"post_id":"clzy68qqt003mm8wv4gascd73","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqx0043m8wv1f7f2tpi"},{"post_id":"clzy68qqu003pm8wvd8h27zpm","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqy0046m8wv6y1y7m5r"},{"post_id":"clzy68qqu003pm8wvd8h27zpm","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqy0048m8wvhj6d5lpk"},{"post_id":"clzy68qqu003sm8wv4eqg7vi8","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqy004am8wver369vlh"},{"post_id":"clzy68qqu003sm8wv4eqg7vi8","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqy004cm8wvbfrvdt85"},{"post_id":"clzy68qqv003vm8wv27d11ut9","tag_id":"clzy68qq20007m8wv2hep0d2l","_id":"clzy68qqy004em8wv66ic5x57"},{"post_id":"clzy68qqv003vm8wv27d11ut9","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqy004gm8wvb2blahny"},{"post_id":"clzy68qqw003ym8wvhndseyd1","tag_id":"clzy68qqd000sm8wvas0eeuy7","_id":"clzy68qqy004im8wv67ej5q0b"},{"post_id":"clzy68qqw003ym8wvhndseyd1","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqy004km8wv6xbcgnox"},{"post_id":"clzy68qqw0041m8wvc4r37tsc","tag_id":"clzy68qq8000gm8wvecwa853s","_id":"clzy68qqy004mm8wvcweebunu"},{"post_id":"clzy68qqw0041m8wvc4r37tsc","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqy004om8wvfguf397g"},{"post_id":"clzy68qqx0044m8wv2gymf4tw","tag_id":"clzy68qqd000sm8wvas0eeuy7","_id":"clzy68qqy004qm8wv86r3f39p"},{"post_id":"clzy68qqx0044m8wv2gymf4tw","tag_id":"clzy68qqa000lm8wv9l01bueq","_id":"clzy68qqy004sm8wvdrj6068l"}],"Tag":[{"name":"icpc","_id":"clzwonja40005lowv22f3hgbe"},{"name":"ccpc","_id":"clzwonja7000dlowvffoddf6v"},{"name":"Latex","_id":"clzwonjac000ulowv2k5440nj"},{"name":"图像处理","_id":"clzwonjad000zlowvgeai2c16"},{"name":"信息安全","_id":"clzwonjae0013lowv28vvetyl"},{"name":"软件","_id":"clzwonjag001alowvdqlv12qj"},{"name":"Miracl","_id":"clzwonjah001elowvcxnk5irh"},{"name":"nodejs","_id":"clzwonjai001ilowv1m9g4eik"},{"name":"gcc","_id":"clzwonjaj001olowvgx7ef4wn"},{"name":"linux","_id":"clzwonjak001ulowvdzwuamy6"},{"name":"数学","_id":"clzwonjan0024lowvcodz17kt"},{"name":"newcoder","_id":"clzwonjao0028lowv7i25azwa"},{"name":"算法","_id":"clzwonjao002ilowvf9j14iti"},{"name":"思维题","_id":"clzwonjap002llowv7ro96k4z"},{"name":"模运算","_id":"clzwonjap002plowv28mo42np"},{"name":"atcoder","_id":"clzwonjap002slowv7zn7cd0h"},{"name":"博弈论","_id":"clzwonjaq0032lowv5twv5q6g"},{"name":"不等式","_id":"clzwonjar0035lowv1go8d9y1"},{"name":"贪心","_id":"clzwonjat003llowvfbo24iiw"},{"name":"状态转移","_id":"clzwonjat003nlowv5pz32qol"},{"name":"luogu","_id":"clzwonjat003rlowv02rvh97j"},{"name":"开发","_id":"clzwonjau003wlowv2i07d9ga"},{"name":"文档","_id":"clzwonjau0041lowv4e4s6524"},{"name":"学校","_id":"clzwonjau0044lowv47ip990k"},{"name":"Typora","_id":"clzwonjav0046lowvazh6alk9"},{"name":"Markdown","_id":"clzwonjav004alowveump1wz5"},{"name":"随笔","_id":"clzwonjaw004dlowva9r58t10"},{"name":"子序列自动机","_id":"clzwonjaw004llowv4kgj7jbi"},{"name":"坐标系转换","_id":"clzwonjay0051lowvdle68voo"},{"name":"几何问题","_id":"clzwonjay0053lowvcrup7xxh"},{"name":"树问题，哈希算法","_id":"clzwonjaz005clowv5qdp6su3"},{"name":"异或问题","_id":"clzwonjb50064lowv6ol6d1t7"},{"name":"离散化","_id":"clzwonjb6006hlowv991pbc7n"},{"name":"机器学习","_id":"clzwonjb7006llowvhywe60hc"},{"name":"MindSpore","_id":"clzwonjb7006rlowv5lat4geo"},{"name":"目录","_id":"clzwonjb7006wlowv367n4tfn"},{"name":"加密算法","_id":"clzwonjb8006ylowv8pttepa2"},{"name":"ECC","_id":"clzwonjb80073lowv6lgcbtzw"},{"name":"英语","_id":"clzy68qpv0002m8wv13zualw2"},{"name":"计算机网络","_id":"clzy68qq20007m8wv2hep0d2l"},{"name":"计算机组成原理","_id":"clzy68qq7000cm8wv8lrhbyey"},{"name":"操作系统","_id":"clzy68qq8000gm8wvecwa853s"},{"name":"考研","_id":"clzy68qqa000lm8wv9l01bueq"},{"name":"数据结构","_id":"clzy68qqd000sm8wvas0eeuy7"}]}}