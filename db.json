{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/addtoany.js","path":"js/third-party/addtoany.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/wavedrom.js","path":"js/third-party/tags/wavedrom.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","path":"uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","modified":0,"renderable":0},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","path":"uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","modified":0,"renderable":0}],"Cache":[{"_id":"source/runtime.js","hash":"44cffdad9d8ddd8509a7169356cce35aa141c095","modified":1723798429937},{"_id":"source/about/index.md","hash":"7768e8a05c4eec51618ec4766fe01e964af83c15","modified":1723643469539},{"_id":"source/_posts/2024武汉ICPC邀请赛VP.md","hash":"05d1161108685b793b9afd548040720da5e95a91","modified":1723697478015},{"_id":"source/404/404.md","hash":"8376757f89e049a3a5685b5fa9539c91713ae513","modified":1723613990887},{"_id":"source/_data/languages.yml","hash":"d1e87c531e0901ce393af4e156df5e15ea10cadf","modified":1723799728997},{"_id":"source/_posts/2024江苏CCPC邀请赛-VP.md","hash":"dea64ae3eaa6dc852f2cbe909a8e55f3cb1baf75","modified":1723697474761},{"_id":"source/_posts/2024湖北省赛VP.md","hash":"54eaa6a99357594dc5311f2abde64f2e6fd50562","modified":1723697466767},{"_id":"source/_posts/2024黑龙江省赛-VP.md","hash":"5108e8c0afb53f82c8baef6ea7226f93eba7caee","modified":1723697482977},{"_id":"source/_posts/Latex宏包pgfplots做矩形函数图像.md","hash":"2ae33665d3b6959a0cda695463a815240d90026d","modified":1723642724943},{"_id":"source/_posts/2024河南CCPC邀请赛-VP.md","hash":"f7e8d5123052eb19b2bd67d3abcbc00444d42e76","modified":1723697471832},{"_id":"source/_posts/Miracl的配置ForCentos7.md","hash":"14615d5987afb985413cbf71dc7f01ce28ffe67d","modified":1723642728720},{"_id":"source/_posts/Nodejs安装简要建议.md","hash":"3304dfbc52bba040d869ed0a11166f21479c4b53","modified":1723689685517},{"_id":"source/_posts/RSA涉及算法与数论知识.md","hash":"7dff17cb7672c0377af29bea3d01a1475bc8670c","modified":1723642736431},{"_id":"source/_posts/Xiaobai93D-E.md","hash":"d429c2e43c4142ec1b81e283e442a474d04c79a8","modified":1723697522258},{"_id":"source/_posts/Xiaobai94.md","hash":"e5ee2b33b2eee25b03f2eda5dc7f2f1a938d0ffd","modified":1723697524681},{"_id":"source/_posts/abc353.md","hash":"bc00383714e3875a36ed2158a856571bd78dbc6a","modified":1723697486275},{"_id":"source/_posts/abc354.md","hash":"31b463a84461cd23e507e6d1fe0749709e60b3cf","modified":1723697490384},{"_id":"source/_posts/cf-edu165D.md","hash":"b8e5ae16b118e0c9ec1c17900bbe41f47db311cd","modified":1723642717760},{"_id":"source/_posts/cf-edu165C.md","hash":"227033639ab02e8d6617672a688e199ade9f3579","modified":1723697878784},{"_id":"source/_posts/luogu蓝桥5_19.md","hash":"c5b46458918c26cd8d7bc570fa836ef276d5789f","modified":1723697515211},{"_id":"source/_posts/三种操作系统模拟软件使用手册.md","hash":"55a62f88e91ba3c22a78219edc42b4806c0830cb","modified":1723642739744},{"_id":"source/_posts/为什么我用Typora——Typora与其他markdown的比较.md","hash":"e673ce8b6cec57ed2c9938b87275a33af259b54b","modified":1723642742327},{"_id":"source/_posts/字符串习题1.md","hash":"c2ba5a4d92e4706d8b41cba1256b756709d55735","modified":1723642745118},{"_id":"source/_posts/思维题习题1.md","hash":"59e08f4ab9b2e15029969301e74228501388a190","modified":1723642748223},{"_id":"source/_posts/数学距离问题1.md","hash":"869e8e6da900e6cc0921f94c610c2ba77750ba72","modified":1723642751945},{"_id":"source/_posts/树上回文问题.md","hash":"dfd074c9f52e28e0ffe3b4cc206d952909d0261e","modified":1723642754786},{"_id":"source/_posts/状态转移习题1.md","hash":"0800a8b4b867afc04b64c70d5677977db61504e0","modified":1723642758757},{"_id":"source/_posts/状态转移习题2.md","hash":"a92936db6b29a809a3aaeeec47e92221aa44e70a","modified":1723642761942},{"_id":"source/_posts/状态转移习题3.md","hash":"27d66b4c473e9f7eb306276aa0048289589cb185","modified":1723642765704},{"_id":"source/categories/index.md","hash":"60b226af341348b28c0b119ebdccc5e58c802085","modified":1723618837565},{"_id":"source/_posts/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估.md","hash":"ecd50b1924c7280964f592c34665a4d9c1456d91","modified":1723690718900},{"_id":"source/_posts/状态转移习题4.md","hash":"6fcd363634ac1e626ced2477d2755d4c76eb1a89","modified":1723642769254},{"_id":"source/tags/index.md","hash":"008e0978586bfc95819e8dbb86b9e75efcdf1a3c","modified":1723612488261},{"_id":"source/schedule/index.md","hash":"95b3ff5bf09f7e8fe31b55662d015636f60f8f5a","modified":1723637034657},{"_id":"source/_posts/special_subject/MindSpore/MindSpore学习目录.md","hash":"e245861a43a81ea83668d57efc75fefd82bf0773","modified":1723798713146},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork.md","hash":"f16149f1a6af77aaf854cfa817d571bf869828d1","modified":1723798733357},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Concept.md","hash":"e17c77bd55bd02570409be5b139dc37b16ba27ba","modified":1723798726139},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Fourth_DataSet.md","hash":"da46fa6b331fe09dbc5ecbd8da6d04ccdafe47ec","modified":1723798737218},{"_id":"source/_posts/special_subject/MindSpore/Chapters/First_Install.md","hash":"934e50c6c21ab424c3090d47f4b83f04d94162f2","modified":1723798729871},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Second_TryMindSpore.md","hash":"23362970948bb8816798fabf2b88965bc5d2bab9","modified":1723798740222},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Seven_ModelTrain.md","hash":"dee4ac57539bbf45e4f70077d1770f26b35af562","modified":1723798742737},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc.md","hash":"c03644646d64dafbfe5afc6c9e30cde543b046bc","modified":1723798751713},{"_id":"source/_posts/special_subject/MindSpore/Chapters/TransformerStructure.md","hash":"d4cd9be5e17970f8197bae4114508212e70eaefb","modified":1723798756882},{"_id":"source/_posts/special_subject/MindSpore/img/img_workflow.svg","hash":"72228a0fef6f4bcf1a2b7465c54eb9d981999bc8","modified":1717643990000},{"_id":"source/_posts/special_subject/MindSpore/Chapters/Third_Tensor.md","hash":"517f4fe5ef3325aad46f00dd46b2af87e36de77a","modified":1723798754447},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1723775696146},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"8cfc97916efdc7cb9acfbe3a653e943a97e54de0","modified":1723775696267},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"82dc85404bb716360c136059f8b4ead67f46549c","modified":1723775696267},{"_id":"node_modules/hexo-theme-next/README.md","hash":"20d3aab17b7d9b7ab537800a5ee932af8438664a","modified":1723775696149},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1723775696045},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1723775696266},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1723775696044},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1723775696148},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"7d0f39e8684284a04bb9808521c87fecda8bd131","modified":1723775696269},{"_id":"node_modules/hexo-theme-next/languages/bn.yml","hash":"564bed75da6e05b11dce6164508f97a15e2fb6c2","modified":1723775696269},{"_id":"node_modules/hexo-theme-next/package.json","hash":"655accf88e80dfdd525042da1d65114b47dcb52a","modified":1723775696042},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"ba0fd79a2b1d8db01a034180556061745965ff05","modified":1723775696271},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"dffc63ef42e1266b88e0acf08994fd17a9908d53","modified":1723775696273},{"_id":"node_modules/hexo-theme-next/languages/eo.yml","hash":"e34bb33ae827bf2f0727088599a73bc64bdad1b0","modified":1723775696272},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"8ac44e58f71a38b7697a2f7f98a6971ed818cb5b","modified":1723775696274},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"f3ffc444599f4ac92d62e9ed00a1490ebc277d70","modified":1723775696274},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"d345a303310c8a5f4836c3683f3580f861ebd1b4","modified":1723775696277},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"929df147f4f17d638b07de5fe52ca13e2549ab1c","modified":1723775696275},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"543222bfc516aab6c33e8534f807972ecb8943a9","modified":1723775696276},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"16d716ecfd748def2f6486ef5a82d0ab7ceb4890","modified":1723775696275},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"3cb3687696635ec71b4ca40c5fc43b56acc8843e","modified":1723775696277},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"76b8576ce228d540a16b1f0af5af2cce20923194","modified":1723775696278},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"c6d8de0ff7d8148d09993257cfd3b7aca755696c","modified":1723775696279},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"2d712eedf3f60d04d36c3108cf5a12e2a52e875c","modified":1723775696280},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"79b37df731c29665dee6cd7c90d278e1edfb6e24","modified":1723775696271},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"70de366e10ea584ba039d40d6b35ac97f93454ad","modified":1723775696278},{"_id":"node_modules/hexo-theme-next/languages/th.yml","hash":"6829e998b39f8f143e20b276bb1f62d95a29de58","modified":1723775696280},{"_id":"node_modules/hexo-theme-next/languages/tk.yml","hash":"511726054873f6f8d7ce0d2e803f6731de0ddbe7","modified":1723775696281},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"a57e4ed089b893a95f5e1ecff17ce625165f4d46","modified":1723775696281},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"ff537047b4b4c3ca9a7b64fa7f428a9942751eeb","modified":1723775696282},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"7ebcba5e1128784195e4681dffc9d34c4e873fec","modified":1723775696283},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"4695c87d6b81b3a23d16ad6513d9eaa925f8d8ad","modified":1723775696284},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"741d7efe0262c9cdc2c648014b55599665d90f6b","modified":1723775696283},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"fc0a45112f2dcfc2642404e8934ea32a793c3bd7","modified":1723775696150},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"88ea50eeb9097ab4a87a44981a102d8594feb064","modified":1723775696284},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1723775696153},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1723775696173},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1723775696159},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1723775696192},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1723775696195},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"af6d7570621be760536c216a56d74e40a1cceae2","modified":1723775696183},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"12a6631617695504d5cf2a94b57d87bd331bef6f","modified":1723775696045},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"287f57dbdfd23341800a0ff310f3474272b9dcc8","modified":1723775696147},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1723775696145},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"0be2d7a75ffc3d9a963cf89a13bd1b50579f8304","modified":1723775696147},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"952449064fcb6a5cefc281b585f9149809f857f1","modified":1723775696191},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"547c62ab14d9e05d2d9116db9048a677fbe1fb6d","modified":1723775696193},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"313637fe3569f98fd926e8cd0fcc75d098eb6e6e","modified":1723775696186},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1723775696162},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1723775696175},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"fbf8232cacf0df87e88e74860be66c9f86018302","modified":1723775696165},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"d83fb59f02c5e6630a7770401a05c02f6f07358b","modified":1723775696201},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1723775696183},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"7ed1fa981bf4765af092d7b178acbdeeb95d5b20","modified":1723775696170},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1723775696199},{"_id":"node_modules/hexo-theme-next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1723775696164},{"_id":"node_modules/hexo-theme-next/layout/_third-party/addtoany.njk","hash":"ef64c6bfb8540cd874701236b9be47db2496e98e","modified":1723775696151},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"dfd7cdd6ba89f8c3deabc27726c7a350cadafd11","modified":1723775696171},{"_id":"node_modules/hexo-theme-next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1723775696181},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1723775695997},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1723775696013},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1723775696021},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"2063aaa1db448ebcf7b0fdbbc54d3991a368bbd3","modified":1723775696024},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"049b1a0b66563e39f68710bb576a8c7342ae749c","modified":1723775696000},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1723775696032},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1723775696003},{"_id":"node_modules/hexo-theme-next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1723775696027},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"ce6bd4054653a4066b19869819a17b568eeee915","modified":1723775696028},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1723775696028},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"6281d47c1de98eb38f3aa0f6df29bbb19d412173","modified":1723775696029},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"af3946a595f997eb43d9af87428e4898c9acbc82","modified":1723775696029},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1723775695986},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1723775695987},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1723775695987},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"8d205b7ffdaa9a89bb8f75410507ee1bab230f55","modified":1723775696005},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1723775696192},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1723775696017},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1723775696019},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"1f6aba7820f1fb58b61969485148db21846e1aa9","modified":1723775696014},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1723775696023},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1723775696029},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1723775696031},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1723775696041},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1723775696035},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1723775696204},{"_id":"node_modules/hexo-theme-next/scripts/tags/wavedrom.js","hash":"b44dfeeb58b41945d469141787f3dbce4b117d08","modified":1723775696041},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"bbeae369eaba9a2565fc359a5b79184d21bdd167","modified":1723775696211},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"921a58577f411cf4eb5cfd66db0a241f8f88578c","modified":1723775696239},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1723775696244},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1723775696201},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1723775695980},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1723775696202},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1723775696203},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1723775696265},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1723775696265},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1723775695985},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1723775695993},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1723775695993},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1723775695995},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"8e587c086e3cf8687108fbb3241fe1534c3df463","modified":1723775696025},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"8e2d589585f5270ee90285d3e65b69923c7629d8","modified":1723775696027},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1723775696034},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"adc751f9b63b7a6b4d381506d35a1b3ff4de891f","modified":1723775696032},{"_id":"node_modules/hexo-theme-next/source/js/sidebar.js","hash":"b3289010a0cb52c525b1395db72bd463424f2f48","modified":1723775696035},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"f92420649b150703469bba41cbd5c72768beed88","modified":1723775696037},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1723775696168},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1723775696169},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1723775696159},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1723775696155},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1723775696196},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1723775696182},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1723775696192},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1723775696154},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1723775696179},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1723775696169},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1723775696195},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1723775696179},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1723775696187},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"bfff923526d6800218f08dba6ce0bbf5c17755fd","modified":1723775696187},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1723775696189},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1723775696189},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1723775696190},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-share.njk","hash":"16696990e4ce65fc8db18c4635082a5d5d06ff07","modified":1723775696190},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1723775696152},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1723775696169},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"bc5708e38b6070dff0cab6bf9480971017ce4dda","modified":1723775696194},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1723775696154},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1723775696177},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1723775696161},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1723775696166},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1723775696170},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1723775696179},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1723775696181},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1723775696185},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1723775696167},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/umami.njk","hash":"3343750682fbd8535e50f8129be3003ad26015b4","modified":1723775696198},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1723775696160},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1723775696197},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1723775696160},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1723775696163},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1723775696163},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1723775696165},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1723775696174},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1723775696198},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1723775696172},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1723775696174},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1723775696177},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1723775696152},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1723775696177},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1723775696176},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1723775696156},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1723775696173},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1723775696164},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1723775696175},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/wavedrom.njk","hash":"02202bf563fb5eedde2ccad4d6c5b9109d30a703","modified":1723775696199},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1723775696180},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1723775696184},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"9ec51eb61f7fee612ffc5252f489003a0fa301fc","modified":1723775695995},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"8300553bf2a1c4bfaec76f2da56465016e9d8058","modified":1723775696007},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1723775696025},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1723775696015},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"5942feb3f31ed3480bf50b0f5a4a305b5bdca3d6","modified":1723775696037},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"e2b4a9d6b08155735ec336eedc506763d5671821","modified":1723775696040},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1723775695989},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1723775695994},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1723775695996},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1723775695999},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1723775695997},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1723775696003},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1723775696015},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1723775696020},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1723775696039},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1723775696226},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"2c800eaab6c613e5d091be2111aaa786641aa0c2","modified":1723775696242},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"879b49f693af0c04c285b2dd0c9cccaf77347b7c","modified":1723775696243},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"8b4100f316e9924f2410802615107130588d721e","modified":1723775696218},{"_id":"node_modules/hexo-theme-next/source/js/third-party/addtoany.js","hash":"5276c8f78ee562a8965216dc67d762e59cb4a9f2","modified":1723775695982},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","hash":"819f382c561fe5ec23c67cc5fabd63dd1cc22dc1","modified":1723775696001},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"20d5c6aa136bbb55e03906d98ee90ad3fbaa80a7","modified":1723775696247},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1723775696031},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1723775696033},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"7664491542046df9a3887cf40a06e00c0b4086a9","modified":1723775696216},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1723775696228},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1723775696253},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"1dbf2c339adcd27026c3a2ded32ee91ce08cea26","modified":1723775696243},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1723775696232},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1723775696221},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1723775696217},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1723775696222},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1723775696234},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1723775696244},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1723775696261},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1723775696245},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"37be10c413438060fc76ed31ae74d4300c38c5eb","modified":1723775696263},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"9dfe853c901bdc52fc950bacdf15484dbb9bf140","modified":1723775696236},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"dafc6d23c80d6fe3e55a7711e94210d2479b629a","modified":1723775696205},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1723775696208},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"f23c53e32d140091b819be2603d1afbbb5d66933","modified":1723775696209},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1723775696236},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1723775696212},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"6569a6640f79d247a8235b3914772c0e2f99ead2","modified":1723775696208},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"e31f6adbb22a451f07e4661cff9a2f12e4e99a36","modified":1723775696209},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"3fbfab591f280e2e7f3b0265901c93bc4bd137ed","modified":1723775696206},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"c29a827e82d2820ed8977c92994da73721200fac","modified":1723775696213},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1723775696214},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1723775696237},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"a92c4eb16bdb7806079467eb022ccf193bb0f794","modified":1723775696208},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"dc03835e42d82eaf2633cf3b627990ad3e1f5967","modified":1723775696207},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"d537c748914ad395319f9cfc91cd5ba96db57e8c","modified":1723775696210},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"7ba406f560e3a6646b9254bb670fda696889e1e6","modified":1723775696213},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1723775696215},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1723775696237},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1723775695984},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"def07bcc7c17d8a0caad177fb1dd2f3a5e5b3536","modified":1723775696004},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1723775696005},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1723775696022},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1723775696036},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1723775695992},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1723775695990},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1723775695998},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1723775696004},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1723775696016},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1723775695999},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1723775696020},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1723775696040},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1723775696017},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1723775696022},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1723775695983},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1723775696021},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1723775696002},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/wavedrom.js","hash":"40dcd10df6edf124088c329346e0cc0bdac74ef1","modified":1723775696042},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1723775696017},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1723775696031},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"6bf821310342c5b87a631873e7650a475a0765f1","modified":1723775696024},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1723775696221},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"51a97a33879289904cb523ddc2d88b5b0c60fa72","modified":1723775696222},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1723775696262},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1723775696228},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1723775696254},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1723775696229},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"56d5b7ff73f466c9ae54f7204ae899281295d749","modified":1723775696247},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"809bab3414b1eb1ae44444eb821126868f764414","modified":1723775696249},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"1ecfd64507954810b07a9d21fb5305b5378feda0","modified":1723775696249},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"11497388f124bfbb4001495a67d3629a9f618405","modified":1723775696250},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1723775696250},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"1191f1bfa5c43e54be8e5b3cc0d802984e161747","modified":1723775696251},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1723775696251},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"ebfba158a0a4af3d1dabcacbc58986664de52140","modified":1723775696252},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"04cf4a69537fc14d3b8904f965d283356853847f","modified":1723775696252},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1723775696225},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1723775696226},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1723775696240},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"54d12e2c5d9982f7b9e5b23be5133954a8514e9d","modified":1723775696230},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1723775696255},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1723775696263},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"4e967702cf4c637132346bc74ec8854426f1a68c","modified":1723775696231},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1723775696220},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1723775696227},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1723775696231},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"a3dd3edea9c01b66b28a8367185269b9dcc3bdee","modified":1723775696240},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1723775696260},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1723775696259},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1723775696253},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"0847400d8579b0a2dd1bf662c78954c10adf2680","modified":1723775696255},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"7c203ec68c0f54429caf35803dbac85b18540278","modified":1723775696233},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1723775696256},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"46eece42510c2c89bb9209afb0262ad76a4b0b36","modified":1723775696257},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"c6a27beb3f741211a14576026f3b4cfc44cc6407","modified":1723775696256},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"24752d145c6fb8f5344dca9c7b9640839c02e009","modified":1723775696257},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"c2e354a565c8c1b32bd0ceacc972b17982758b67","modified":1723775696258},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"741566d6ac5f852b5c8dee6a8996b65e48e7c97f","modified":1723775696259},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1723775696260},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f634f94828620e88c3f5a8db56f7944f6ba232b0","modified":1723775696223},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/fold.styl","hash":"42a0b65491ad85438596b3fe0b7f23973e4cef34","modified":1723775696225},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"138f78147bc6bd6005f329ada34dc79b7625542d","modified":1723775696234},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1723775696219},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"22cd37bd5df9972d5074710896aba4424ad5161c","modified":1723775696235},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1723775696227},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1723775696237},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1723775696239},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"98d4c20aff0f0fcfe1824017fb06ab21ef0d218e","modified":1723775696245},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1723775696246},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1723775696241},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"33dd6ad015dde65fd46f34961655442e8e82b52e","modified":1723775696261},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/wavedrom.styl","hash":"af113411ad9cca7674177be36af8dd399680834d","modified":1723775696264},{"_id":"source/_posts/special_subject/MindSpore/img/R.jpg","hash":"14958ff3d91f7e600ce92f23424ebc59c7f7e766","modified":1717740026000},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","hash":"ea8a10b275222aa4fe6004ea90dfb8b7619893ca","modified":1723645068416},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","hash":"85ea4d5ef41451cc6d78520f9b8e9c934f3c45f6","modified":1723644997204},{"_id":"public/runtime.js","hash":"ca5276b144e4a246a8ebd3db6202bce69fe937ad","modified":1723798639119},{"_id":"public/atom.xml","hash":"963b98ff88324a5aace0e665b2f44d26f81b1262","modified":1723798778877},{"_id":"public/en/runtime.js","hash":"ca5276b144e4a246a8ebd3db6202bce69fe937ad","modified":1723798639119},{"_id":"public/ja/runtime.js","hash":"ca5276b144e4a246a8ebd3db6202bce69fe937ad","modified":1723798639119},{"_id":"public/ru/runtime.js","hash":"ca5276b144e4a246a8ebd3db6202bce69fe937ad","modified":1723798639119},{"_id":"public/search.xml","hash":"1cafb59d6d0154494bd22fa3912f14a8883702b0","modified":1723798778877},{"_id":"public/404/404.html","hash":"a6f62243aa71ce4b91571c31458b04ed7bb46b5f","modified":1723799748717},{"_id":"public/about/index.html","hash":"1b998eeed4a3551f3fa80582bd52c0ca7a6bcaf2","modified":1723799748717},{"_id":"public/categories/index.html","hash":"9f70f35b2d12ba0aa2a9ba811efe9e3226ab46bb","modified":1723799748717},{"_id":"public/tags/index.html","hash":"89d2018e14b59738566ac29c7b1fc68cf12ad467","modified":1723799748717},{"_id":"public/schedule/index.html","hash":"1e64353a5be27b3d9808e620a7f8b4898784ace7","modified":1723799748717},{"_id":"public/2024/Nodejs安装简要建议/Nodejs安装简要建议","hash":"00fd1801fa6509a0120907d696f39fd7f160b764","modified":1723799748717},{"_id":"public/2024/Miracl的配置ForCentos7/Miracl的配置ForCentos7","hash":"bdefb080df7b6430734b738b89c402b1b1babcb4","modified":1723799748717},{"_id":"public/2024/RSA涉及算法与数论知识/RSA涉及算法与数论知识","hash":"1bd02434068452872352c2cae213556e06f275bd","modified":1723799748717},{"_id":"public/2024/Latex宏包pgfplots做矩形函数图像/Latex宏包pgfplots做矩形函数图像","hash":"bde2e102e9bcbdd7edfea965aba2e09c7177ba8e","modified":1723799748717},{"_id":"public/2024/special_subject/MindSpore/MindSpore学习目录/special_subject/MindSpore/MindSpore学习目录","hash":"2e9a882d37c1944e77d2d6862e2ea726bee1dcd9","modified":1723799748717},{"_id":"public/2024/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork","hash":"48c0f3cdeec490573ca0b10c341f6170acbc0c9d","modified":1723799748717},{"_id":"public/2024/special_subject/MindSpore/Chapters/Concept/special_subject/MindSpore/Chapters/Concept","hash":"82a5b3331cd7e0c4d87ef16415c9dac711c951f4","modified":1723799748717},{"_id":"public/2024/special_subject/MindSpore/Chapters/First_Install/special_subject/MindSpore/Chapters/First_Install","hash":"76b051dfe8d8847e1c89ee2da19f5d2302bc1e4b","modified":1723799748717},{"_id":"public/2024/special_subject/MindSpore/Chapters/Fourth_DataSet/special_subject/MindSpore/Chapters/Fourth_DataSet","hash":"37497af32a3e72d83ba7e7641637c94e06e69166","modified":1723799748717},{"_id":"public/2024/special_subject/MindSpore/Chapters/Seven_ModelTrain/special_subject/MindSpore/Chapters/Seven_ModelTrain","hash":"4ac8459038267d24000ce2a7a51a61cc97d81412","modified":1723799748717},{"_id":"public/2024/special_subject/MindSpore/Chapters/Second_TryMindSpore/special_subject/MindSpore/Chapters/Second_TryMindSpore","hash":"2f9b1d60ff581e065033e3583aa6f6f2278111e3","modified":1723799748717},{"_id":"public/2024/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc","hash":"f4738e75273556148de30e4341c4c480ac10aac7","modified":1723799748717},{"_id":"public/2024/special_subject/MindSpore/Chapters/TransformerStructure/special_subject/MindSpore/Chapters/TransformerStructure","hash":"230f07a6ae726fc8b7e1ca054dfd1faf61dd0d08","modified":1723799748717},{"_id":"public/2024/special_subject/MindSpore/Chapters/Third_Tensor/special_subject/MindSpore/Chapters/Third_Tensor","hash":"50799b019ba1cdf1dcbc7981034d20038023a44e","modified":1723799748717},{"_id":"public/2024/2024武汉ICPC邀请赛VP/2024武汉ICPC邀请赛VP","hash":"1a8954bac9a807e38e118ab9487fc409e3877f1e","modified":1723799748717},{"_id":"public/2024/2024江苏CCPC邀请赛-VP/2024江苏CCPC邀请赛-VP","hash":"a7988d4645f4039ad649f0f1d4df8ad646e30b48","modified":1723799748717},{"_id":"public/2024/2024湖北省赛VP/2024湖北省赛VP","hash":"aae214479a226033d30fd7cff38541c8ef4ac977","modified":1723799748717},{"_id":"public/2024/2024黑龙江省赛-VP/2024黑龙江省赛-VP","hash":"3a3375542ec7a7e68ade16d1546fc51184dfa260","modified":1723799748717},{"_id":"public/2024/2024河南CCPC邀请赛-VP/2024河南CCPC邀请赛-VP","hash":"860355b982836ca8b19c2434fc06051946a27993","modified":1723799748717},{"_id":"public/2024/Xiaobai93D-E/Xiaobai93D-E","hash":"54d176573d9bccbb2967ecb4b7d263f0ff1a9daf","modified":1723799748717},{"_id":"public/2024/Xiaobai94/Xiaobai94","hash":"4a876504231b392db344caf4f18ee8938b4d865b","modified":1723799748717},{"_id":"public/2024/abc353/abc353","hash":"abe5a31493505b5ab6dd7fa777b9caa13edc8e1d","modified":1723799748717},{"_id":"public/2024/abc354/abc354","hash":"9ea2e45eb55becd90be792317e5a4ce7537fc714","modified":1723799748717},{"_id":"public/2024/cf-edu165C/cf-edu165C","hash":"85004b98394e236f2db081a91e14364331b0e956","modified":1723799748717},{"_id":"public/2024/luogu蓝桥5_19/luogu蓝桥5_19","hash":"24ae6bc0f910335c07dc90f8f5212d98112f5adb","modified":1723799748717},{"_id":"public/2024/cf-edu165D/cf-edu165D","hash":"8808f8c75dadaa1973d27eac01194b7092f78bb4","modified":1723799748717},{"_id":"public/2024/数学距离问题1/数学距离问题1","hash":"4b28d47de7e3b68ef6096b1dd52c061216885812","modified":1723799748717},{"_id":"public/2024/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估","hash":"905e890a98976690761922535446b4aeab2e392a","modified":1723799748717},{"_id":"public/2024/状态转移习题4/状态转移习题4","hash":"97de33c6be968623246524f7899fb83a08755535","modified":1723799748717},{"_id":"public/2024/树上回文问题/树上回文问题","hash":"7a9daa3fe38920f27fce8a38bc8b29e6661b5040","modified":1723799748717},{"_id":"public/2024/状态转移习题3/状态转移习题3","hash":"4841f5ec5595b3106f8345858505b71cc7186533","modified":1723799748717},{"_id":"public/2024/字符串习题1/字符串习题1","hash":"800cbfdbe792b186a2fe60f06ae3050723e0ed9e","modified":1723799748717},{"_id":"public/2024/思维题习题1/思维题习题1","hash":"024b5e29c02a7620c60a0736760c3c5975b3082d","modified":1723799748717},{"_id":"public/2024/状态转移习题2/状态转移习题2","hash":"b3a067918924fae51c65c9b5411eb6df3b342cc5","modified":1723799748717},{"_id":"public/2024/状态转移习题1/状态转移习题1","hash":"7f9dc8579e5c066075dd7e65e6669eb8924648aa","modified":1723799748717},{"_id":"public/2024/三种操作系统模拟软件使用手册/三种操作系统模拟软件使用手册","hash":"1ec33d46585c669dd96de01cdc8716eb36cd19ec","modified":1723799748717},{"_id":"public/2023/为什么我用Typora——Typora与其他markdown的比较/为什么我用Typora——Typora与其他markdown的比较","hash":"1c46c051419be62b73238d2a4b058c352233769b","modified":1723799748717},{"_id":"public/archives/index.html","hash":"6d436534008df5fd05c39e220cc45f81d0c7dd5d","modified":1723799748717},{"_id":"public/archives/page/2/index.html","hash":"066ae9d7744a5559bacb70dfa27e5299ed95d30c","modified":1723799748717},{"_id":"public/archives/page/3/index.html","hash":"18676f363d331cd64561d86fe509a79697f6fbb8","modified":1723799748717},{"_id":"public/archives/page/4/index.html","hash":"6cb45eb349cff6cedea333c346f22d0e12edbaf7","modified":1723799748717},{"_id":"public/archives/2023/index.html","hash":"2b16aeb4b07655c69373f5cab102e54a9fb7be52","modified":1723799748717},{"_id":"public/archives/2023/08/index.html","hash":"014bd2c54ab99602ace81041afbe24b0f0e9ab2c","modified":1723799748717},{"_id":"public/archives/2024/index.html","hash":"29bc690c71c5b9b0197bf784eebd0acab5c636fe","modified":1723799748717},{"_id":"public/archives/2024/page/2/index.html","hash":"742c00d5f61b33243c2911a74d43d97bf3c75355","modified":1723799748717},{"_id":"public/archives/2024/page/3/index.html","hash":"d5136b62ceaa0388e44ec1939feb0f83156a4710","modified":1723799748717},{"_id":"public/archives/2024/page/4/index.html","hash":"12c69f346d23e00df9fa599bfceb2619f0f76f98","modified":1723799748717},{"_id":"public/archives/2024/05/index.html","hash":"ae06744de6febcf2d4d70bdead6761e2f9b27767","modified":1723799748717},{"_id":"public/archives/2024/08/index.html","hash":"cb4cbf860b9e6a8abd36bc3466d7406a4b9d804a","modified":1723799748717},{"_id":"public/archives/2024/08/page/2/index.html","hash":"4bae4bd674c87299a7029e0aa6d4915ea25ee2b8","modified":1723799748717},{"_id":"public/archives/2024/08/page/3/index.html","hash":"93996e86fb538285e4df41328ec51869e1121930","modified":1723799748717},{"_id":"public/archives/2024/08/page/4/index.html","hash":"3bcd288579af29299995727d1444b63e41bd753e","modified":1723799748717},{"_id":"public/categories/比赛/index.html","hash":"9c71ef438678930dfbc2040a4b4181a010d8e1b7","modified":1723799748717},{"_id":"public/categories/比赛/模拟赛/index.html","hash":"ecea6f430799c569c44041be8c47004671ca6895","modified":1723799748717},{"_id":"public/categories/软件/index.html","hash":"6bbf62f3c3e52337e83ac03923989edf36617dcf","modified":1723799748717},{"_id":"public/categories/信息安全/index.html","hash":"62f8d27993311869add84f683883d401dd7f3ee1","modified":1723799748717},{"_id":"public/categories/比赛/日常赛/index.html","hash":"c24a6dd6e733c92beafa2b2db5cdb034ddc24f49","modified":1723799748717},{"_id":"public/categories/比赛/模拟赛/icpc省赛/index.html","hash":"78ed0de7c07307fbb691a1b8774d575032a741f5","modified":1723799748717},{"_id":"public/categories/算法/index.html","hash":"594715f7bdb95248205a9018c6cc2b27ea2f6b58","modified":1723799748717},{"_id":"public/categories/算法/page/2/index.html","hash":"db3b4bdbd532316b8b638561864b27a6cc49e3c5","modified":1723799748717},{"_id":"public/categories/比赛/模拟赛/icpc邀请赛/index.html","hash":"a0c42c27e1627afed3383684973fe6d87513b5cc","modified":1723799748717},{"_id":"public/categories/软件/工具类软件/index.html","hash":"b78258b287019a658168a9859b09ada661180405","modified":1723799748717},{"_id":"public/categories/比赛/模拟赛/蓝桥模拟/index.html","hash":"357ed297d35be819268753c3155d23ac45c25c18","modified":1723799748717},{"_id":"public/categories/软件/经典库/index.html","hash":"0cebf004edd72e8eee03fd59e9389372f49657f1","modified":1723799748717},{"_id":"public/categories/软件/手册/index.html","hash":"148ec3b7e1d633a5eb85632ffd7aaa465b65704c","modified":1723799748717},{"_id":"public/categories/软件/编辑器/index.html","hash":"e3a2b7f2530093bcee595a037de1337cf67aad6f","modified":1723799748717},{"_id":"public/categories/比赛/模拟赛/ccpc邀请赛/index.html","hash":"0b2cea728cbe01109e13cef67dd41b7895fdc49d","modified":1723799748717},{"_id":"public/categories/学术/index.html","hash":"90c15a496c3f9d5309fa9cf00f9e365dd2b39770","modified":1723799748717},{"_id":"public/categories/信息安全/加密算法/index.html","hash":"52adc6135485b63c1c403811818d10da9399811d","modified":1723799748717},{"_id":"public/categories/专题/index.html","hash":"d53c1e1d8708375ff14e8c826b65306bb287533e","modified":1723799748717},{"_id":"public/categories/比赛/日常赛/newcoder/index.html","hash":"e09ec5c3b7cd82003d6ae10a36a366dbacb35558","modified":1723799748717},{"_id":"public/categories/算法/思维题/index.html","hash":"00e7e1705596662eda0a75792978ea8222b1d647","modified":1723799748717},{"_id":"public/categories/比赛/日常赛/atcoder/index.html","hash":"0146e782aa2ed94537326888cb7022e9c7c4380a","modified":1723799748717},{"_id":"public/categories/算法/数学/index.html","hash":"412302602fdfbcb49771c1ec808ba2bc31c9fe05","modified":1723799748717},{"_id":"public/categories/软件/经典库/信息安全/index.html","hash":"09722b75ed90e4a33e4430379e7e96bad8c4b262","modified":1723799748717},{"_id":"public/categories/软件/编辑器/Markdown/index.html","hash":"9f8648d2af7c57c9a0bf05bcee9fa03f00c599ec","modified":1723799748717},{"_id":"public/categories/算法/字符串/index.html","hash":"323ecef4203f68fe9913225ef441c5a23575a2bc","modified":1723799748717},{"_id":"public/categories/算法/图论/index.html","hash":"4450a2bf74ba0c164a8535a31190f09ff2c8d445","modified":1723799748717},{"_id":"public/categories/软件/经典库/前端/index.html","hash":"def585e8a8aee6bd31e5a5f073b236cab7af30f7","modified":1723799748717},{"_id":"public/categories/算法/状态转移/index.html","hash":"ffb4a4b7aee36bca3f2c518b61da3f993fd0fc52","modified":1723799748717},{"_id":"public/categories/学术/综述/index.html","hash":"c0532bcae447203d4a1f587f9038b9e4de8f9d45","modified":1723799748717},{"_id":"public/categories/信息安全/加密算法/数学/index.html","hash":"313644201a9bbae2e4dba96f9e6a6adaec353bda","modified":1723799748717},{"_id":"public/categories/专题/机器学习/index.html","hash":"18f6d0718bf8d7b7ba86a692de8f01cd2aea843d","modified":1723799748717},{"_id":"public/categories/算法/数学/博弈论/index.html","hash":"2af2666c7e3d3fad8c9b710ca4bb4b9a1ec403dc","modified":1723799748717},{"_id":"public/categories/算法/思维题/模运算/index.html","hash":"d05b96c4e3bdd27d4981b7795ce6804036d51895","modified":1723799748717},{"_id":"public/categories/算法/思维题/贪心/index.html","hash":"01fc53542eb5d50a28073d55f3c37dd938c1b659","modified":1723799748717},{"_id":"public/categories/算法/字符串/子序列自动机/index.html","hash":"f1199d74ea72fea8de4fedaad72392401bbf7163","modified":1723799748717},{"_id":"public/categories/算法/图论/图论中的回文问题/index.html","hash":"8935e4245324d7b2a19b7a24c0a19ee0f00caa71","modified":1723799748717},{"_id":"public/categories/软件/经典库/前端/node/index.html","hash":"5e4e8e03e1f628b9d31b96fdaf89d121cc8f9ae3","modified":1723799748717},{"_id":"public/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"9ae042126553e9679488f51fbb0d79da03e9b808","modified":1723799748717},{"_id":"public/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"cd4b4b6882b9bcb5b555f3551cc5d2860314919b","modified":1723799748717},{"_id":"public/categories/专题/机器学习/Mindspore/index.html","hash":"093360728c9174314f672ee540fc4b3703b2b206","modified":1723799748717},{"_id":"public/categories/专题/机器学习/Mindspore/基本概念/index.html","hash":"965cfa62224576c823438c802622e04d876b4152","modified":1723799748717},{"_id":"public/en/404/404.html","hash":"bfe5f0f4b11b0b05561439073b51a09ffd2789ee","modified":1723798639119},{"_id":"public/ja/404/404.html","hash":"b8e356958b2b481762c62649a241147d8ee1356e","modified":1723798639119},{"_id":"public/ru/404/404.html","hash":"6c5e113027ee0c296b3b52b34afbe53b8da3da7a","modified":1723798639119},{"_id":"public/en/about/index.html","hash":"37afd92c5d52c2d566e8408a706f0a1e99c8a6d8","modified":1723798639119},{"_id":"public/ja/about/index.html","hash":"5889ed5dc15bb96fd61234b6f8aef6cf42629ed6","modified":1723798639119},{"_id":"public/ru/about/index.html","hash":"b67077a5a00d0ea8039cd911f16cc61cde5e510e","modified":1723798639119},{"_id":"public/en/schedule/index.html","hash":"e1099f2712f428c5e2c472eaf9de2b7bee49724b","modified":1723799748717},{"_id":"public/ja/schedule/index.html","hash":"07bfff202019efb2bfa51f9fbd39b3336f4551f0","modified":1723799748717},{"_id":"public/ru/schedule/index.html","hash":"4d4945e66fab97e0277de2ca62383b773bf148ae","modified":1723799748717},{"_id":"public/en/categories/index.html","hash":"bfbd01ccc1eab4380121aac9d903d3a8f5ee1bec","modified":1723798639119},{"_id":"public/en/tags/index.html","hash":"e94a8f2c162f8fd439a2640c7d200e31bc4ebeda","modified":1723798639119},{"_id":"public/ru/categories/index.html","hash":"0d501e6430f54281eb380019756a1c1c046aa7f4","modified":1723798639119},{"_id":"public/ja/categories/index.html","hash":"ede82be43246a03ebbbd14a2fce68088afec4eef","modified":1723798639119},{"_id":"public/ru/tags/index.html","hash":"fd9301c9482439d5867ff9459f3d9928294d5a2a","modified":1723798639119},{"_id":"public/ja/tags/index.html","hash":"ad475eec3467a68f9ceaa5c198bf2cd55ff7042f","modified":1723798639119},{"_id":"public/en/2024/2024武汉ICPC邀请赛VP/2024武汉ICPC邀请赛VP","hash":"693c341702396b1cc94caaac3b6696bcd5dd5b59","modified":1723798639119},{"_id":"public/ru/2024/2024武汉ICPC邀请赛VP/2024武汉ICPC邀请赛VP","hash":"d46cb9e8be3b0ce3bf58a80618682f82ce9cf97d","modified":1723798639119},{"_id":"public/en/2024/2024江苏CCPC邀请赛-VP/2024江苏CCPC邀请赛-VP","hash":"3598266e2335add5fc8e46405428aa930d070cab","modified":1723798639119},{"_id":"public/ru/2024/2024江苏CCPC邀请赛-VP/2024江苏CCPC邀请赛-VP","hash":"439c58b4ac1d6378fa2bbc386d15ae808ecab018","modified":1723798639119},{"_id":"public/ja/2024/2024江苏CCPC邀请赛-VP/2024江苏CCPC邀请赛-VP","hash":"ac4136c55d47e50f26db699ae8462ef144758fa0","modified":1723798639119},{"_id":"public/en/2024/2024湖北省赛VP/2024湖北省赛VP","hash":"5a3ac9e8864bd28399f320d7a3d31543ba67c79e","modified":1723798639119},{"_id":"public/ja/2024/2024武汉ICPC邀请赛VP/2024武汉ICPC邀请赛VP","hash":"171ec6ae1ca2199f4b07cc7d09a2f0cf69df25bf","modified":1723798639119},{"_id":"public/ja/2024/2024湖北省赛VP/2024湖北省赛VP","hash":"1242074fcf91160cdf540a68ba5e53d6d7bbb7d3","modified":1723798639119},{"_id":"public/ru/2024/2024湖北省赛VP/2024湖北省赛VP","hash":"2dfaf6b6530366a89992b53dce788cfb781d4fdd","modified":1723798639119},{"_id":"public/en/2024/2024黑龙江省赛-VP/2024黑龙江省赛-VP","hash":"d6a9bee4087340fd574c059e7133f0c510a07cc1","modified":1723798639119},{"_id":"public/ja/2024/2024黑龙江省赛-VP/2024黑龙江省赛-VP","hash":"5c2cd7034b9db4220d81b241624164a20b8cd131","modified":1723798639119},{"_id":"public/ru/2024/2024黑龙江省赛-VP/2024黑龙江省赛-VP","hash":"6c7f868f3bd57eaa8450ae70fef53a0a1cad2f04","modified":1723798639119},{"_id":"public/en/2024/Latex宏包pgfplots做矩形函数图像/Latex宏包pgfplots做矩形函数图像","hash":"ba2348c39303ca834540c014a322844bb282545b","modified":1723798639119},{"_id":"public/ja/2024/Latex宏包pgfplots做矩形函数图像/Latex宏包pgfplots做矩形函数图像","hash":"9773dad0c78e819c4fdbe5d28eaf4b65ff6ff70a","modified":1723798639119},{"_id":"public/ru/2024/Latex宏包pgfplots做矩形函数图像/Latex宏包pgfplots做矩形函数图像","hash":"20b95eeada2e309e9f6056a2cccd958ac1ff6708","modified":1723798639119},{"_id":"public/en/2024/Miracl的配置ForCentos7/Miracl的配置ForCentos7","hash":"74895b9e56f2c75e966a44ecd7ee2608acd53626","modified":1723798639119},{"_id":"public/ja/2024/Miracl的配置ForCentos7/Miracl的配置ForCentos7","hash":"f2e86bd794071157b60909a697f7e6eac71ba09d","modified":1723798639119},{"_id":"public/ru/2024/Miracl的配置ForCentos7/Miracl的配置ForCentos7","hash":"665fefd99fb9e7f3ee854a231542388beedbff89","modified":1723798639119},{"_id":"public/en/2024/2024河南CCPC邀请赛-VP/2024河南CCPC邀请赛-VP","hash":"cd1255f646e4f1b4432b3c0eb1a43ac6e891a4e2","modified":1723798639119},{"_id":"public/ja/2024/2024河南CCPC邀请赛-VP/2024河南CCPC邀请赛-VP","hash":"d6694d91c0a515d7fe48aa61cb870e54a8e17f4f","modified":1723798639119},{"_id":"public/ru/2024/2024河南CCPC邀请赛-VP/2024河南CCPC邀请赛-VP","hash":"82d73f95525223f5650d6c6a94367521dc8e7e3b","modified":1723798639119},{"_id":"public/en/2024/Nodejs安装简要建议/Nodejs安装简要建议","hash":"474a377ec0f35884f1d53423c9cbc189675f6fec","modified":1723798639119},{"_id":"public/ja/2024/Nodejs安装简要建议/Nodejs安装简要建议","hash":"5a1e47d74d05e1ac602c9c9a161b6f849b13ab7c","modified":1723798639119},{"_id":"public/ru/2024/Nodejs安装简要建议/Nodejs安装简要建议","hash":"fb4a3c634db9b8ad9ecf662fd4c611c6e31838e4","modified":1723798639119},{"_id":"public/en/2024/RSA涉及算法与数论知识/RSA涉及算法与数论知识","hash":"12b21b6942d263cd3511c63c449d08e288352013","modified":1723798639119},{"_id":"public/ja/2024/RSA涉及算法与数论知识/RSA涉及算法与数论知识","hash":"c8098d6df19135bdcfa22c4f49baaa440b26681f","modified":1723798639119},{"_id":"public/ru/2024/RSA涉及算法与数论知识/RSA涉及算法与数论知识","hash":"4036dcb1c569c6dc7bad9272f89d5ec99d6f331b","modified":1723798639119},{"_id":"public/en/2024/Xiaobai93D-E/Xiaobai93D-E","hash":"0c672d139d4b7e52080d85781b387d2740a47826","modified":1723798639119},{"_id":"public/ja/2024/Xiaobai93D-E/Xiaobai93D-E","hash":"9503d66944d52b0b43a9dfbf00cc7ec1fbd76b09","modified":1723798639119},{"_id":"public/ru/2024/Xiaobai93D-E/Xiaobai93D-E","hash":"74839b8df55864c425c5e25139cb81628b8daaf5","modified":1723798639119},{"_id":"public/en/2024/Xiaobai94/Xiaobai94","hash":"874266c32e023f10767dd65ae720fb3e8d5c9257","modified":1723798639119},{"_id":"public/ja/2024/Xiaobai94/Xiaobai94","hash":"88ded84d6c2111287e460655f3efba3a58fb6372","modified":1723798639119},{"_id":"public/ru/2024/Xiaobai94/Xiaobai94","hash":"24ad352a204d089890328a8734d74243377ff893","modified":1723798639119},{"_id":"public/en/2024/abc353/abc353","hash":"ebe7aa3c156522363a9189c6cf410589e248fc32","modified":1723798639119},{"_id":"public/ja/2024/abc353/abc353","hash":"2e705922c1d6cdc7ddcf67e02a5e8c9320f91004","modified":1723798639119},{"_id":"public/ru/2024/abc353/abc353","hash":"e00c3124f6014dc455723f90e95cf8b2386f4ef4","modified":1723798639119},{"_id":"public/en/2024/abc354/abc354","hash":"de33e6577535014df2aa9152b97ddc4b2aa55f5b","modified":1723798639119},{"_id":"public/ja/2024/abc354/abc354","hash":"83ed6582b7ecdd9b4c5fe0520ce85fd91c4feda9","modified":1723798639119},{"_id":"public/ru/2024/abc354/abc354","hash":"de7ac71838b7b2c0c6a66749c8f35886f1712e29","modified":1723798639119},{"_id":"public/en/2024/cf-edu165D/cf-edu165D","hash":"9fc02f75b4af62c4bd7fa8506cdc2a49cdf8d183","modified":1723798639119},{"_id":"public/ja/2024/cf-edu165D/cf-edu165D","hash":"3fbbe0eac12ea44b970131cc6c75918cc5b002ba","modified":1723798639119},{"_id":"public/ru/2024/cf-edu165D/cf-edu165D","hash":"b513b2109fa0c8b84eab3bf4c2da7c7e15233e88","modified":1723798639119},{"_id":"public/en/2024/cf-edu165C/cf-edu165C","hash":"384357f85cc6cd971b8b19f10a0c0907bb0c1237","modified":1723798639119},{"_id":"public/ja/2024/cf-edu165C/cf-edu165C","hash":"720441ed0c2feb9bd7ce9b429841f5961d0c8095","modified":1723798639119},{"_id":"public/ru/2024/cf-edu165C/cf-edu165C","hash":"36699e9903e2d8c44d49f2a9a525cee663ae7080","modified":1723798639119},{"_id":"public/en/2024/luogu蓝桥5_19/luogu蓝桥5_19","hash":"13caed8afbec9b199be86180b7470f56810f4ff6","modified":1723798639119},{"_id":"public/ja/2024/luogu蓝桥5_19/luogu蓝桥5_19","hash":"ef7bafad4cefa25e76817777b80b4cc7d8d643d5","modified":1723798639119},{"_id":"public/ru/2024/luogu蓝桥5_19/luogu蓝桥5_19","hash":"e601c64c77197fa40d116d863ae2f07d96148cbf","modified":1723798639119},{"_id":"public/en/2024/三种操作系统模拟软件使用手册/三种操作系统模拟软件使用手册","hash":"732161d8aaf94ec5b772fde30add0253b673a383","modified":1723798639119},{"_id":"public/ja/2024/三种操作系统模拟软件使用手册/三种操作系统模拟软件使用手册","hash":"3a196b8c1a4ebc7f2d8ccdba0257b92ddc7ca935","modified":1723798639119},{"_id":"public/en/2023/为什么我用Typora——Typora与其他markdown的比较/为什么我用Typora——Typora与其他markdown的比较","hash":"2c1da01e24e91d9812eedd9b55d9a45dfa82d829","modified":1723798639119},{"_id":"public/ru/2024/三种操作系统模拟软件使用手册/三种操作系统模拟软件使用手册","hash":"5d34e4918cbae035c2a04b0c12fffde490cb9b5e","modified":1723798639119},{"_id":"public/ja/2023/为什么我用Typora——Typora与其他markdown的比较/为什么我用Typora——Typora与其他markdown的比较","hash":"5e19a52f63ee204915a72dbbfe45bb9ba0aa888b","modified":1723798639119},{"_id":"public/ru/2023/为什么我用Typora——Typora与其他markdown的比较/为什么我用Typora——Typora与其他markdown的比较","hash":"40737742e9485f685ae776e1b49338ffb7a80d2e","modified":1723798639119},{"_id":"public/en/2024/字符串习题1/字符串习题1","hash":"c78f13a6cefee1ebd339638259c9cc9fe43464f1","modified":1723798639119},{"_id":"public/ja/2024/字符串习题1/字符串习题1","hash":"cae7042cb56b44369968e06ac3174422ec1a91cb","modified":1723798639119},{"_id":"public/ru/2024/字符串习题1/字符串习题1","hash":"bb68e2a1c3e0f6fd0f9d4d8cf52d628f2f7d3e26","modified":1723798639119},{"_id":"public/ja/2024/思维题习题1/思维题习题1","hash":"79a0df1bd517389dc696f3cd7778c0259651ab36","modified":1723798639119},{"_id":"public/en/2024/思维题习题1/思维题习题1","hash":"1419caea09da0c6c7b055b073f3d25d709d0c0f7","modified":1723798639119},{"_id":"public/ru/2024/思维题习题1/思维题习题1","hash":"f6a67d528637f038b92396163261ad2a76de8eec","modified":1723798639119},{"_id":"public/en/2024/数学距离问题1/数学距离问题1","hash":"8f554b43e582f1694277e7e7f9210c10b19a3d6b","modified":1723798639119},{"_id":"public/ja/2024/数学距离问题1/数学距离问题1","hash":"045b8df9114bd52fbd979c74afdd53ffaa1d8953","modified":1723798639119},{"_id":"public/ru/2024/数学距离问题1/数学距离问题1","hash":"ab767ca7f1777ad6573f28c2d6fbbb9530368441","modified":1723798639119},{"_id":"public/en/2024/树上回文问题/树上回文问题","hash":"b74b49af2e46f03a402d379db91fbc2d9ccf2e94","modified":1723798639119},{"_id":"public/ja/2024/树上回文问题/树上回文问题","hash":"a15e8ebcc32fcfb2b6c6f0c5f5a39c718a237a05","modified":1723798639119},{"_id":"public/ru/2024/树上回文问题/树上回文问题","hash":"aeebaafbf64b17482e8d3f296377244469347f6d","modified":1723798639119},{"_id":"public/en/2024/状态转移习题1/状态转移习题1","hash":"859471e1c143722b09e95489e4ebd69cf018d07f","modified":1723798639119},{"_id":"public/ja/2024/状态转移习题1/状态转移习题1","hash":"cfea12bde84fa1a25e63cfe6dff2ae54fe673fb5","modified":1723798639119},{"_id":"public/ru/2024/状态转移习题1/状态转移习题1","hash":"6d4ef391f72285d846b3ec2ccf8ac2609a5f27fa","modified":1723798639119},{"_id":"public/en/2024/状态转移习题3/状态转移习题3","hash":"2b03d83721d1edd84307e90d1772e116cf4c3361","modified":1723798639119},{"_id":"public/ja/2024/状态转移习题3/状态转移习题3","hash":"b9a32c9fe27375e7b2b2ff0e9e96c006eaa682ad","modified":1723798639119},{"_id":"public/ru/2024/状态转移习题3/状态转移习题3","hash":"d475bc8c607ec6c5217ad531d29ce6381b33686b","modified":1723798639119},{"_id":"public/en/2024/状态转移习题2/状态转移习题2","hash":"f2e50b2dce2f46ea7e79e0f61d35f0a31337ef76","modified":1723798639119},{"_id":"public/ja/2024/状态转移习题2/状态转移习题2","hash":"b08578e906274aab85860572495eb7f18b12b026","modified":1723798639119},{"_id":"public/ru/2024/状态转移习题2/状态转移习题2","hash":"cda2bf239ed609a60e771a542f12a851e063fa06","modified":1723798639119},{"_id":"public/en/2024/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估","hash":"a83b695554ee10879b62be0bd533398cf04c408b","modified":1723798639119},{"_id":"public/ja/2024/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估","hash":"a990a5a70ee647af4911eba4a1005e65a06e0290","modified":1723798639119},{"_id":"public/ru/2024/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估","hash":"92fef2eaf95c26827d66d57488938763e45dd98f","modified":1723798639119},{"_id":"public/en/2024/状态转移习题4/状态转移习题4","hash":"331b1fdc33a0c05f22e522554c9b703c66db3015","modified":1723798639119},{"_id":"public/ja/2024/状态转移习题4/状态转移习题4","hash":"0016482f19476066fb7b39cc5acd50efeaa8109d","modified":1723798639119},{"_id":"public/ru/2024/状态转移习题4/状态转移习题4","hash":"3b6f408c080486161dfb0d09dfd698a7130dbd3c","modified":1723798639119},{"_id":"public/en/2024/special_subject/MindSpore/MindSpore学习目录/special_subject/MindSpore/MindSpore学习目录","hash":"54e8ed3914ebcbfa49c53aef0fb184f7a5ba083b","modified":1723798778877},{"_id":"public/ja/2024/special_subject/MindSpore/MindSpore学习目录/special_subject/MindSpore/MindSpore学习目录","hash":"b99b2ba2ec4ba04bde64ffd55298b25169f7a146","modified":1723798778877},{"_id":"public/ru/2024/special_subject/MindSpore/MindSpore学习目录/special_subject/MindSpore/MindSpore学习目录","hash":"db1b4eb7f72cddca93bb536d45eba1785bd78d85","modified":1723798778877},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork","hash":"3b8e4e1926c463f85061a433dfb0a32f339a4117","modified":1723798778877},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork","hash":"b96e1c2e4fc40b6f09a5993e8cb294895646ebd4","modified":1723798778877},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork","hash":"2e30c6ba19356cd5e657cb40157a15a75d47c059","modified":1723798778877},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Concept/special_subject/MindSpore/Chapters/Concept","hash":"d01072499ad3a11cea5f9c0c10abe6d727bb1afb","modified":1723798778877},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Concept/special_subject/MindSpore/Chapters/Concept","hash":"71260b4ca94551167ec8a776922db0d46bcf51f0","modified":1723798778877},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Concept/special_subject/MindSpore/Chapters/Concept","hash":"1f5ea9da41d96ddca64364afee604ea653b48097","modified":1723798778877},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/First_Install/special_subject/MindSpore/Chapters/First_Install","hash":"f3acb86ed167c16e66d79fd2bf83da10b18e4b8f","modified":1723798778877},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/First_Install/special_subject/MindSpore/Chapters/First_Install","hash":"ca3abfddd548d73280b375247d8e9af534f4f9f3","modified":1723798778877},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/First_Install/special_subject/MindSpore/Chapters/First_Install","hash":"b51236272fc10b3a9f54be2908aa868da17ffffb","modified":1723798778877},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Fourth_DataSet/special_subject/MindSpore/Chapters/Fourth_DataSet","hash":"8bd8851a2ad03619255dc300688427ddbe6e0c44","modified":1723798778877},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Fourth_DataSet/special_subject/MindSpore/Chapters/Fourth_DataSet","hash":"4b874490eb03e5b0568cf7d546c1dc2963e0a0fa","modified":1723798778877},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Fourth_DataSet/special_subject/MindSpore/Chapters/Fourth_DataSet","hash":"889f1755e9aed2f9f44e95fd725a3ea37cfd8667","modified":1723798778877},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Seven_ModelTrain/special_subject/MindSpore/Chapters/Seven_ModelTrain","hash":"960d899639fbd6280b50c3c534cb3d118d003197","modified":1723798778877},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Seven_ModelTrain/special_subject/MindSpore/Chapters/Seven_ModelTrain","hash":"25d336f1e2197f4acbb0ecb22562f8e2da5369be","modified":1723798778877},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Seven_ModelTrain/special_subject/MindSpore/Chapters/Seven_ModelTrain","hash":"f1ca82b5567843dc4cea58b5283f8ee0fa6a1a60","modified":1723798778877},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Second_TryMindSpore/special_subject/MindSpore/Chapters/Second_TryMindSpore","hash":"88bd766f237c48556c232000588ccaf31f87960b","modified":1723798778877},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Second_TryMindSpore/special_subject/MindSpore/Chapters/Second_TryMindSpore","hash":"d01351a660aeef1fe9d95b33e78f8b96c6db032e","modified":1723798778877},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Second_TryMindSpore/special_subject/MindSpore/Chapters/Second_TryMindSpore","hash":"e978bc242a2c1cff2e682867e5372edea667c4ec","modified":1723798778877},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/TransformerStructure/special_subject/MindSpore/Chapters/TransformerStructure","hash":"edf7314739802fc742c5d9316bc38f6d9008efdd","modified":1723798778877},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/TransformerStructure/special_subject/MindSpore/Chapters/TransformerStructure","hash":"bfa511eb75409ff1b2c344f3d9eb0db63d33fb7a","modified":1723798778877},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/TransformerStructure/special_subject/MindSpore/Chapters/TransformerStructure","hash":"6ada39c24d8de4c485c9913304f9cd3631293a7f","modified":1723798778877},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc","hash":"2ded69d95bb5cc2047ed1d1f85d5608721feeb8b","modified":1723798778877},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc","hash":"b46e24625d6ca64c28b88961d59324866546e958","modified":1723798778877},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc","hash":"7f2ea714fec7ddc08c8b33abe613831b3b3a0445","modified":1723798778877},{"_id":"public/en/2024/special_subject/MindSpore/Chapters/Third_Tensor/special_subject/MindSpore/Chapters/Third_Tensor","hash":"39f55d0e0514845ed5a9b11e63db20c4b4a07a1e","modified":1723798778877},{"_id":"public/ja/2024/special_subject/MindSpore/Chapters/Third_Tensor/special_subject/MindSpore/Chapters/Third_Tensor","hash":"d0c9e282f968ff3aa253513277cc37ca6be38b7e","modified":1723798778877},{"_id":"public/ru/2024/special_subject/MindSpore/Chapters/Third_Tensor/special_subject/MindSpore/Chapters/Third_Tensor","hash":"28acb48ac0ea05bf457322548a0b4ae70dc7f5dc","modified":1723798778877},{"_id":"public/en/index.html","hash":"5a34331dba6d20c12b327020a1880898dd92175d","modified":1723798778877},{"_id":"public/ja/index.html","hash":"f8925963aa93619f72b9d68d3dc169fba5644a32","modified":1723798778877},{"_id":"public/ru/index.html","hash":"7c71400febec8a531c158dc881031b86f18b0da0","modified":1723798778877},{"_id":"public/en/page/2/index.html","hash":"f70ebfae393161a2dcda232aa917d0ebf2a2af9e","modified":1723798778877},{"_id":"public/ja/page/2/index.html","hash":"468f1c582653aaa20cdb766ff49dc7e1ce76fdbc","modified":1723798778877},{"_id":"public/ru/page/2/index.html","hash":"d2ab74f251082238a7a0d2ccc1a45524dbc3ddb3","modified":1723798778877},{"_id":"public/en/page/3/index.html","hash":"0072f0461b8e38e82d66a3af6a0712cb55c4b77f","modified":1723798639119},{"_id":"public/ja/page/3/index.html","hash":"29547153bda756535271a81cc8f16f8ddf086f43","modified":1723798639119},{"_id":"public/ru/page/3/index.html","hash":"263fa0e318edb67b77ad7bee2f2740f82f021a9d","modified":1723798639119},{"_id":"public/en/page/4/index.html","hash":"86fa13eba5e0e230a862e3e4e260a89d20c2b974","modified":1723798639119},{"_id":"public/ja/page/4/index.html","hash":"207212160887f21c55f706b92025976551d6f613","modified":1723798639119},{"_id":"public/ru/page/4/index.html","hash":"0a96f1622f48f1349e5b51ee25e7b4a38c2542cf","modified":1723798639119},{"_id":"public/en/archives/index.html","hash":"3f607abe457812b27b31f1fdcec43a28fdab8b05","modified":1723798639119},{"_id":"public/ja/archives/index.html","hash":"e174c8e8b2657278f6501101e8ec30dabf1c85dc","modified":1723798639119},{"_id":"public/ru/archives/index.html","hash":"66191815f1fd66d99f5d206714f73c3203566503","modified":1723798639119},{"_id":"public/en/archives/page/2/index.html","hash":"50a4cad156898d9ab3dc667dcaf5379f1cac55cc","modified":1723798639119},{"_id":"public/ja/archives/page/2/index.html","hash":"cb9433ce76892166d9568b1f5932a2adccb01930","modified":1723798639119},{"_id":"public/ru/archives/page/2/index.html","hash":"268202c86866ba6ddc5688de6c9dd6176b0e6990","modified":1723798639119},{"_id":"public/en/archives/page/3/index.html","hash":"0be3857df175451c03c9734e00d8d0a5fc17aca9","modified":1723798639119},{"_id":"public/ja/archives/page/3/index.html","hash":"703f7e816034a4d916532b16ba643bd432e1b29c","modified":1723798639119},{"_id":"public/ru/archives/page/3/index.html","hash":"da540d970f07d6c7fcef49a1271cd09a140487c5","modified":1723798639119},{"_id":"public/en/archives/page/4/index.html","hash":"2bc3b9f08e21c5fe711ca682a14ee57849dcd844","modified":1723798639119},{"_id":"public/ja/archives/page/4/index.html","hash":"5edcf591310f9ebe0ca149aa5402b8350c72e4f4","modified":1723798639119},{"_id":"public/ru/archives/page/4/index.html","hash":"9ef16f2079ec5ed550f977ed0c12a853de9c333a","modified":1723798639119},{"_id":"public/en/archives/2023/index.html","hash":"22720db02ca84c0d115eaa3092d74f976093f71b","modified":1723798639119},{"_id":"public/ja/archives/2023/index.html","hash":"a4997a0a4a8d00c02e060e285cddc141f406519e","modified":1723798639119},{"_id":"public/ru/archives/2023/index.html","hash":"fb5a4621e30278b7f0d5f290208a2eb320fb7fb5","modified":1723798639119},{"_id":"public/en/archives/2023/08/index.html","hash":"bf19316eef913e309f0cf347979ee97700d7b656","modified":1723798639119},{"_id":"public/ja/archives/2023/08/index.html","hash":"66733c1f7e59da897b9b826d12b6fb3c1c6fe6db","modified":1723798639119},{"_id":"public/ru/archives/2023/08/index.html","hash":"cccb035add7dac0402ad26c541fb1f7dcc5a84c5","modified":1723798639119},{"_id":"public/en/archives/2024/index.html","hash":"2b8a5364cc01533714ca7e473eda3800f8a0df8b","modified":1723798639119},{"_id":"public/ja/archives/2024/index.html","hash":"d37eb1f71ef5df3463cc7bcc777f67fdb34c2e1f","modified":1723798639119},{"_id":"public/ru/archives/2024/index.html","hash":"bd64539c60cfc565b7bc909dbc57e11db8dfd8ee","modified":1723798639119},{"_id":"public/en/archives/2024/page/2/index.html","hash":"3127f417075b59e8f76639ff6a34259bc9ebbdc4","modified":1723798639119},{"_id":"public/ja/archives/2024/page/2/index.html","hash":"4e0b08673d4e994872541a6fd041b61ca05aea30","modified":1723798639119},{"_id":"public/ru/archives/2024/page/2/index.html","hash":"c1229f0a4357a72a8991858e3eadf94cc8613caf","modified":1723798639119},{"_id":"public/en/archives/2024/page/3/index.html","hash":"31dd8606c0113bddeb30c1b2cd7044177cc35e84","modified":1723798639119},{"_id":"public/ja/archives/2024/page/3/index.html","hash":"15d7ae91635990649d5d1a12cf4352854b51fbb1","modified":1723798639119},{"_id":"public/ru/archives/2024/page/3/index.html","hash":"b77a821abac555a8dcee1f19658df97f69a86ecf","modified":1723798639119},{"_id":"public/en/archives/2024/page/4/index.html","hash":"440bbc68574baac1787e758dc689fed4c62f703f","modified":1723798639119},{"_id":"public/ja/archives/2024/page/4/index.html","hash":"1661ddd120cf74c9bec7903f68123e31ed0a23a7","modified":1723798639119},{"_id":"public/ru/archives/2024/page/4/index.html","hash":"b70c7c805d9d15a66a3634871f8fc1b1391c9c87","modified":1723798639119},{"_id":"public/en/archives/2024/05/index.html","hash":"9d8d20afee13c2004da5c96381ea6b32ce486914","modified":1723798639119},{"_id":"public/ja/archives/2024/05/index.html","hash":"c9f65a19e65eeef43e29858a45e6b62008ec0f34","modified":1723798639119},{"_id":"public/ru/archives/2024/05/index.html","hash":"29e2eacff47534a0bbfc7f1350321b08528e47f5","modified":1723798639119},{"_id":"public/en/archives/2024/08/index.html","hash":"aaf89d0ede18325285300dc9425d13a62886e849","modified":1723798639119},{"_id":"public/ja/archives/2024/08/index.html","hash":"d21d3cb1697a44c2ab5ad0ae191665953af31190","modified":1723798639119},{"_id":"public/ru/archives/2024/08/index.html","hash":"4214e9f3c0ed08e27234369c69c4aaed47e9d197","modified":1723798639119},{"_id":"public/en/archives/2024/08/page/2/index.html","hash":"8d9f540854bf84e0cbb138597614741cc791d042","modified":1723798639119},{"_id":"public/ja/archives/2024/08/page/2/index.html","hash":"92c58ac2dbfa824fb7023d07b61c7b0c3e66970a","modified":1723798639119},{"_id":"public/ru/archives/2024/08/page/2/index.html","hash":"02428d98f07b1d664c3556af18c561f5aac15ffb","modified":1723798639119},{"_id":"public/en/archives/2024/08/page/3/index.html","hash":"8081ef75db1cd4eacc96ef03acfd5376b89e2eb6","modified":1723798639119},{"_id":"public/ja/archives/2024/08/page/3/index.html","hash":"06eb2f9e570ec88c9eb2a6816b555dca27486456","modified":1723798639119},{"_id":"public/ru/archives/2024/08/page/3/index.html","hash":"30c7dd5c3d426d910a8572514b94c9ac7c815003","modified":1723798639119},{"_id":"public/en/archives/2024/08/page/4/index.html","hash":"ae908282a6aaba2d6108d71fb59386fac407352b","modified":1723798639119},{"_id":"public/ja/archives/2024/08/page/4/index.html","hash":"63fa95db7239b576b3ac32e941581275357dab1c","modified":1723798639119},{"_id":"public/ru/archives/2024/08/page/4/index.html","hash":"9ad1b9cd103a44f1b1c089917f6cdb4f38ea65fe","modified":1723798639119},{"_id":"public/en/categories/比赛/index.html","hash":"d010dbb3d43ea21a2c607008637bee941d9bae10","modified":1723798639119},{"_id":"public/ja/categories/比赛/index.html","hash":"96220a9f08d377d61a0d338bd7294ce6510862c2","modified":1723798639119},{"_id":"public/ru/categories/比赛/index.html","hash":"a1dc37d87a338a23f82fe6688d2d3945a6259fb1","modified":1723798639119},{"_id":"public/en/categories/比赛/模拟赛/index.html","hash":"c475614081e4c731616de465934c5102c3750a61","modified":1723798639119},{"_id":"public/ja/categories/比赛/模拟赛/index.html","hash":"bdf47114f0f56d58d39475e9d92a3912a5aca75a","modified":1723798639119},{"_id":"public/ru/categories/比赛/模拟赛/index.html","hash":"65e0a3df08e484aa76a0a547446b8c1c08f48170","modified":1723798639119},{"_id":"public/en/categories/软件/index.html","hash":"e3a064572fcf84029d68e63409070f4c29857540","modified":1723798639119},{"_id":"public/ja/categories/软件/index.html","hash":"f585bb64a07d24b052cccfad0bf5de649ca14af7","modified":1723798639119},{"_id":"public/ru/categories/软件/index.html","hash":"9c7631ae97ce9b8f75d88eb3c99576bf9772c16a","modified":1723798639119},{"_id":"public/ja/categories/信息安全/index.html","hash":"85ec9d8e3dd79095c72d69662e1ee8da9c82ea21","modified":1723798639119},{"_id":"public/en/categories/信息安全/index.html","hash":"1e2426ada98f0902ef322c43658951bcb4ea3a03","modified":1723798639119},{"_id":"public/ru/categories/信息安全/index.html","hash":"3ba37e6cf5f8e3adf447782c00b0483ee82d5955","modified":1723798639119},{"_id":"public/en/categories/比赛/日常赛/index.html","hash":"fbd4b1a0794368462594c18238d0edba61b2f54a","modified":1723798639119},{"_id":"public/ja/categories/比赛/日常赛/index.html","hash":"36cd869b5621b8996e34f51a21d7b597363ac4ea","modified":1723798639119},{"_id":"public/ru/categories/比赛/日常赛/index.html","hash":"41432cb58ebf086431810560690436e3810d526f","modified":1723798639119},{"_id":"public/en/categories/比赛/模拟赛/icpc省赛/index.html","hash":"c97cb60160efd77d2b0fe5589caaaa07446aa68d","modified":1723798639119},{"_id":"public/ja/categories/比赛/模拟赛/icpc省赛/index.html","hash":"1700fad7568bcb40c5eee522684f81c7eb1314a0","modified":1723798639119},{"_id":"public/ru/categories/比赛/模拟赛/icpc省赛/index.html","hash":"1d3003a2b4bdddeebc7778071ba8e1b27837e0b4","modified":1723798639119},{"_id":"public/en/categories/算法/index.html","hash":"f69da56ff98257dac73cebaaa454d530b08b441c","modified":1723798639119},{"_id":"public/ja/categories/算法/index.html","hash":"5844d094b888f6b2f3f4e943cf739592c764304d","modified":1723798639119},{"_id":"public/ru/categories/算法/index.html","hash":"efafd5fa3a5e9a14afa7c046bf6ed975f274cf71","modified":1723798639119},{"_id":"public/en/categories/算法/page/2/index.html","hash":"e73f6dbf896bea9b76fdfdccba20eb50e587628f","modified":1723798639119},{"_id":"public/ja/categories/算法/page/2/index.html","hash":"7ec47d47de7cc73329fd01e08cee235ad71db778","modified":1723798639119},{"_id":"public/ru/categories/算法/page/2/index.html","hash":"14a0f342ed040cc138bf08b58abdd9163777b02c","modified":1723798639119},{"_id":"public/en/categories/比赛/模拟赛/icpc邀请赛/index.html","hash":"ce5e29e5c52a7342de3cac72ddc8b520aa6fe730","modified":1723798639119},{"_id":"public/ja/categories/比赛/模拟赛/icpc邀请赛/index.html","hash":"41b61342b3647caa7f6416ac009afa157639c7df","modified":1723798639119},{"_id":"public/ru/categories/比赛/模拟赛/icpc邀请赛/index.html","hash":"efc58e084125f9ae7337e86a8c4619ada54c345f","modified":1723798639119},{"_id":"public/en/categories/软件/工具类软件/index.html","hash":"0d7b350405b7b1a76d3eace5242ad36f09dfeebe","modified":1723798639119},{"_id":"public/ja/categories/软件/工具类软件/index.html","hash":"6564dc5e82336be0891e9b21ddb3e0e61cb48436","modified":1723798639119},{"_id":"public/ru/categories/软件/工具类软件/index.html","hash":"7ce9c6cd1dc26dc02fd33c2df34b9603593e9283","modified":1723798639119},{"_id":"public/en/categories/比赛/模拟赛/蓝桥模拟/index.html","hash":"2ad1593623bf1aa96595caa14f469df872ba94ae","modified":1723798639119},{"_id":"public/ja/categories/比赛/模拟赛/蓝桥模拟/index.html","hash":"5a9f4ed0dd259a5108c623d4af3929be7999c28b","modified":1723798639119},{"_id":"public/ru/categories/比赛/模拟赛/蓝桥模拟/index.html","hash":"dd686fa7fee50971d46a3b827ea8136396763b96","modified":1723798639119},{"_id":"public/en/categories/软件/经典库/index.html","hash":"ec912ba9bb450ea0b3c5fb14e023ea66b22e05f9","modified":1723798639119},{"_id":"public/ja/categories/软件/经典库/index.html","hash":"77193348b95eef69e997b85fe10990e700845f12","modified":1723798639119},{"_id":"public/ru/categories/软件/经典库/index.html","hash":"e0ae63841f651cd9c02997674c697cdb578f456c","modified":1723798639119},{"_id":"public/en/categories/软件/手册/index.html","hash":"64f48cbdc6d176f198e771475f64ef471ac22080","modified":1723798639119},{"_id":"public/ja/categories/软件/手册/index.html","hash":"13b4251244a289c08beb06d6fb9eba2130aac808","modified":1723798639119},{"_id":"public/ru/categories/软件/手册/index.html","hash":"002d6eb563039793bbe384b2a787248f4f932b72","modified":1723798639119},{"_id":"public/en/categories/软件/编辑器/index.html","hash":"640e5155a88ac270b10b66eb65248a6643ce4ddf","modified":1723798639119},{"_id":"public/ja/categories/软件/编辑器/index.html","hash":"8e9f1d5d3f943b82fe09859a02fe7d74ddacfd58","modified":1723798639119},{"_id":"public/ru/categories/软件/编辑器/index.html","hash":"ae97118a31f250464c458ed903ced91f7b0e4c66","modified":1723798639119},{"_id":"public/en/categories/比赛/模拟赛/ccpc邀请赛/index.html","hash":"723c20fda426273c6cce78fbfe2e6a26c1cc0263","modified":1723798639119},{"_id":"public/ja/categories/比赛/模拟赛/ccpc邀请赛/index.html","hash":"1a2ab32f664131139a2b27687e62b265a122cbcb","modified":1723798639119},{"_id":"public/ru/categories/比赛/模拟赛/ccpc邀请赛/index.html","hash":"dfdd32440d61ad4a8dbe9752e110488c5b2f1a6e","modified":1723798639119},{"_id":"public/en/categories/学术/index.html","hash":"93b99dfc8947ea235d1a1e01474b0323bb41d52c","modified":1723798639119},{"_id":"public/ja/categories/学术/index.html","hash":"582a25f6febf737b7f384444234cfdb5dfce8c15","modified":1723798639119},{"_id":"public/ru/categories/学术/index.html","hash":"eb2a5b97a8cad59f56f707f6f64b4f54799f79ab","modified":1723798639119},{"_id":"public/en/categories/信息安全/加密算法/index.html","hash":"d7fe8de0ccbf5f2fed6c751f1ddaa839c38c64c9","modified":1723798639119},{"_id":"public/ja/categories/信息安全/加密算法/index.html","hash":"c017c7f46f98867995dfa539c52ddaa1bd4c4968","modified":1723798639119},{"_id":"public/ru/categories/信息安全/加密算法/index.html","hash":"e9ad2dafa61c53a92d49e75a0bfa2b18ac048cae","modified":1723798639119},{"_id":"public/en/categories/专题/index.html","hash":"6195006112d422b6671cbdca63df80be7cbf1554","modified":1723798639119},{"_id":"public/ja/categories/专题/index.html","hash":"ce6d8827519b63fc39aff17a6a9a9c58fda26d73","modified":1723798639119},{"_id":"public/ru/categories/专题/index.html","hash":"983637bf62ea343f9b0ec80f330639325a7cb7b8","modified":1723798639119},{"_id":"public/en/categories/比赛/日常赛/newcoder/index.html","hash":"2c02a212f3ffc7c994671f68682f1c0fc63923d4","modified":1723798639119},{"_id":"public/ja/categories/比赛/日常赛/newcoder/index.html","hash":"a4293b0e0fdaacc6f6d5581c0a1d655934d227d3","modified":1723798639119},{"_id":"public/ru/categories/比赛/日常赛/newcoder/index.html","hash":"bfdbddfb2428b6cd36512964a3c46f6e3c4f4bb6","modified":1723798639119},{"_id":"public/en/categories/算法/思维题/index.html","hash":"4bc7aab07696b95de6791bbd728220f120842203","modified":1723798639119},{"_id":"public/ja/categories/算法/思维题/index.html","hash":"3732935099d8f72dbad9e612bb5fc45c8c44f83a","modified":1723798639119},{"_id":"public/ru/categories/算法/思维题/index.html","hash":"5460236668cbe943cef8610674ad62d8a8e5f2eb","modified":1723798639119},{"_id":"public/en/categories/比赛/日常赛/atcoder/index.html","hash":"a33ac47de0d7b387e24c3dfb357126e16650472c","modified":1723798639119},{"_id":"public/ja/categories/比赛/日常赛/atcoder/index.html","hash":"a28df1dea9dc9c47d24cd42f8692674bb203edef","modified":1723798639119},{"_id":"public/ru/categories/比赛/日常赛/atcoder/index.html","hash":"1b015e0e269694b8f383d177a3bec6fa744f09c3","modified":1723798639119},{"_id":"public/en/categories/算法/数学/index.html","hash":"709bd4105c807baa2c0ee569173d326c68abb7f8","modified":1723798639119},{"_id":"public/ja/categories/算法/数学/index.html","hash":"06f367e1482b72cad7d4f60871cf02e4bbde8285","modified":1723798639119},{"_id":"public/ru/categories/算法/数学/index.html","hash":"9e9cba90105ba3c05030f58339be59a9070e974b","modified":1723798639119},{"_id":"public/en/categories/软件/经典库/信息安全/index.html","hash":"d39922f72089dbe9e0b47f8312546cea70844f33","modified":1723798639119},{"_id":"public/ja/categories/软件/经典库/信息安全/index.html","hash":"0ccfc7ba0910d8f43b163c775e54b60f0ee02f2b","modified":1723798639119},{"_id":"public/ru/categories/软件/经典库/信息安全/index.html","hash":"815c00697a9ffcf6ce6b76116a41da64a6f8bf0c","modified":1723798639119},{"_id":"public/en/categories/软件/编辑器/Markdown/index.html","hash":"4fd33c357e7f4f479d85e05872110e4a95bc86b2","modified":1723798639119},{"_id":"public/ja/categories/软件/编辑器/Markdown/index.html","hash":"b3fc9a0c3364de2de1c659209de676ea6b795fe8","modified":1723798639119},{"_id":"public/ru/categories/软件/编辑器/Markdown/index.html","hash":"412719c2016434809664c4d270a8c44e1e8424cb","modified":1723798639119},{"_id":"public/en/categories/算法/字符串/index.html","hash":"dc29b2a8a65bc686e18a085518d3470ff5713205","modified":1723798639119},{"_id":"public/ja/categories/算法/字符串/index.html","hash":"42d60add578b7224b95fbc652310bd01f96d6e47","modified":1723798639119},{"_id":"public/ru/categories/算法/字符串/index.html","hash":"8cee00d0814565e92d92c7a61c72382ef1c7ecb1","modified":1723798639119},{"_id":"public/en/categories/算法/图论/index.html","hash":"74bbfae363b39acce0b1b6396da227bb262dfa7f","modified":1723798639119},{"_id":"public/ja/categories/算法/图论/index.html","hash":"b0cd290069d849dbb5b5c2b943b24f3ca95412b5","modified":1723798639119},{"_id":"public/ru/categories/算法/图论/index.html","hash":"0bedcb471b44337a5e37a5fd709c4597acf741c1","modified":1723798639119},{"_id":"public/en/categories/软件/经典库/前端/index.html","hash":"ae00a8a613b212974fcba5dcc263b76537425ba1","modified":1723798639119},{"_id":"public/ja/categories/软件/经典库/前端/index.html","hash":"9c0a75114e2f4f390aa62fd3fac3b9f7d0faa65c","modified":1723798639119},{"_id":"public/ru/categories/软件/经典库/前端/index.html","hash":"c7d219e281a51735afdae24af2055d7dda2e3da6","modified":1723798639119},{"_id":"public/en/categories/算法/状态转移/index.html","hash":"ae546f90ce69e4e6d10408689b5204999147990d","modified":1723798639119},{"_id":"public/ja/categories/算法/状态转移/index.html","hash":"b2bb9e2dffc19cba1244de7c2af48028b8d950e9","modified":1723798639119},{"_id":"public/ru/categories/算法/状态转移/index.html","hash":"93a47d86c73dc389a75021f7679049686e9ae051","modified":1723798639119},{"_id":"public/en/categories/学术/综述/index.html","hash":"92972163c741e3364e2d1b23c008e0d20f901290","modified":1723798639119},{"_id":"public/ja/categories/学术/综述/index.html","hash":"28d9f232926efadb40da61473c3d421cd49916dc","modified":1723798639119},{"_id":"public/ru/categories/学术/综述/index.html","hash":"33ac8c8fdcf96a17aae6eea4540eb7dcac71b6b7","modified":1723798639119},{"_id":"public/en/categories/信息安全/加密算法/数学/index.html","hash":"2b63d0002d31caaf0238e1c17a204b9775bf3c03","modified":1723798639119},{"_id":"public/ja/categories/信息安全/加密算法/数学/index.html","hash":"991574eec7667b0d29a352b45b3802b12a7310f5","modified":1723798639119},{"_id":"public/ru/categories/信息安全/加密算法/数学/index.html","hash":"50f1bfaf662f198a08612359652d6913c5f59980","modified":1723798639119},{"_id":"public/en/categories/专题/机器学习/index.html","hash":"9631083a80b3c743a8e7c24b4f99242b195e6f5e","modified":1723798639119},{"_id":"public/ja/categories/专题/机器学习/index.html","hash":"13b82f545a332dae6492beced529d698b68725c8","modified":1723798639119},{"_id":"public/ru/categories/专题/机器学习/index.html","hash":"e4aebe75d7e0d3f01dddd4e6f072f72f2b1fa7f4","modified":1723798639119},{"_id":"public/en/categories/算法/思维题/模运算/index.html","hash":"6d8979acf7a02fc6b6449e941b1c5c95ec3db642","modified":1723798639119},{"_id":"public/ja/categories/算法/思维题/模运算/index.html","hash":"4730dd9eeccb4ab7f2744a8e24ae4375623386f7","modified":1723798639119},{"_id":"public/ru/categories/算法/思维题/模运算/index.html","hash":"cb01d081915857ba231efc16193863f7fa834c2c","modified":1723798639119},{"_id":"public/en/categories/算法/数学/博弈论/index.html","hash":"bd002b7116ee8517470a465cd5cd08b46843ac94","modified":1723798639119},{"_id":"public/ja/categories/算法/数学/博弈论/index.html","hash":"5c59c75542bd5c0e90972b68f75ed492ce694444","modified":1723798639119},{"_id":"public/ru/categories/算法/数学/博弈论/index.html","hash":"4a90ccfbdd44a072090189d1dd01f1b77b56ed4d","modified":1723798639119},{"_id":"public/en/categories/算法/思维题/贪心/index.html","hash":"9aab5ad59787d792d95027e5cc2530765c2970c9","modified":1723798639119},{"_id":"public/ja/categories/算法/思维题/贪心/index.html","hash":"449e47d01df2b7d221f703ad876eefc1be870041","modified":1723798639119},{"_id":"public/ru/categories/算法/思维题/贪心/index.html","hash":"d83920f7d7f9bf16945df16da874fdf1eaa6b9ed","modified":1723798639119},{"_id":"public/en/categories/算法/字符串/子序列自动机/index.html","hash":"0425a519a0d15fb84d24850ad611fa0bf49c2a2d","modified":1723798639119},{"_id":"public/ja/categories/算法/字符串/子序列自动机/index.html","hash":"46b3e11c06f88aca437da06e85fa3359a8ebb60c","modified":1723798639119},{"_id":"public/ru/categories/算法/字符串/子序列自动机/index.html","hash":"282f073c12428e44769ddb6ffebd20bbad804c19","modified":1723798639119},{"_id":"public/en/categories/算法/图论/图论中的回文问题/index.html","hash":"a72dee61079280da2b5cb76a0de7cbdcfdeceb2e","modified":1723798639119},{"_id":"public/ja/categories/算法/图论/图论中的回文问题/index.html","hash":"25d7ef804c139d037ce0ede11de62aa20e5975f5","modified":1723798639119},{"_id":"public/ru/categories/算法/图论/图论中的回文问题/index.html","hash":"e4a36b64a53819a3ceee5bd52ffff947fd30353f","modified":1723798639119},{"_id":"public/en/categories/软件/经典库/前端/node/index.html","hash":"d47d829256e2b8258a385033a48eb8fd54a51eb7","modified":1723798639119},{"_id":"public/ja/categories/软件/经典库/前端/node/index.html","hash":"21ee5354ad363bc97cd3f515aa27ed95a6d801d3","modified":1723798639119},{"_id":"public/ru/categories/软件/经典库/前端/node/index.html","hash":"73aa53128150cf4006152ca01ba9f6ef1219bfbf","modified":1723798639119},{"_id":"public/en/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"db07bebbeb0c07bc495a9f7835a8757468499408","modified":1723798639119},{"_id":"public/ja/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"2362a9081431caaacb30b11eccea61d7eb7c5ba0","modified":1723798639119},{"_id":"public/ru/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"d5f136c64d4aeeaec2123d9638dfa8b180709598","modified":1723798639119},{"_id":"public/en/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"638ce53f9ba2eef39ae94aa4a3789b4cd88f8371","modified":1723798639119},{"_id":"public/ja/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"676f2435fe7f86ae116db7f139162bf7f6bf73b3","modified":1723798639119},{"_id":"public/ru/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"c60a7822605067ae1e9d28c0e7077a86b957a762","modified":1723798639119},{"_id":"public/en/categories/专题/机器学习/Mindspore/index.html","hash":"25aeef68c9572171644ac560c72d354786478a3e","modified":1723798639119},{"_id":"public/ja/categories/专题/机器学习/Mindspore/index.html","hash":"fd9876596039c36daeb63b3396bfd81b242d1303","modified":1723798639119},{"_id":"public/ru/categories/专题/机器学习/Mindspore/index.html","hash":"b5c1a63817d546de8e79c32aed6f23f80c2e5a39","modified":1723798639119},{"_id":"public/en/categories/专题/机器学习/Mindspore/基本概念/index.html","hash":"f99e24d895fe02a8dc110b99551fe1804da74e06","modified":1723798639119},{"_id":"public/ja/categories/专题/机器学习/Mindspore/基本概念/index.html","hash":"6dee0d9dc64c3dad299f628388a350a88f9c43b8","modified":1723798639119},{"_id":"public/ru/categories/专题/机器学习/Mindspore/基本概念/index.html","hash":"f7d0b3df4bbd2189cbccc8732a6e0c65a82947d3","modified":1723798639119},{"_id":"public/index.html","hash":"ee41550604239201ad3213d078d99accbcf2bb09","modified":1723799748717},{"_id":"public/page/2/index.html","hash":"5c878064b2971513de9e0ac08b6eda9424c2db75","modified":1723799748717},{"_id":"public/page/3/index.html","hash":"68ad02a7b4ec0bf5bf4867dbd6c312ddf222ffa1","modified":1723799748717},{"_id":"public/page/4/index.html","hash":"f51708fd76ce3e68419f94c4a2431ad9a831e0d6","modified":1723799748717},{"_id":"public/tags/icpc/index.html","hash":"0ad85fc13dc794c20dd0d0b0ccc173bf1a412dac","modified":1723799748717},{"_id":"public/tags/ccpc/index.html","hash":"cb1a0427ab03fd6cf6eccff23fec2ce9b54549f8","modified":1723799748717},{"_id":"public/tags/Latex/index.html","hash":"edfba47e6f0a84ac5d45fdbf8ec9a849d3adc56b","modified":1723799748717},{"_id":"public/tags/图像处理/index.html","hash":"c5fa485051b45a5ae5be8e7d4992493e3024512c","modified":1723799748717},{"_id":"public/tags/信息安全/index.html","hash":"4489cf97947b940c968e499212b69d40d3ed60c8","modified":1723799748717},{"_id":"public/tags/软件/index.html","hash":"24bdb5e78c2c14fb19b85a7d3a58c14b23a378bd","modified":1723799748717},{"_id":"public/tags/Miracl/index.html","hash":"06b2b0c1b4433091be98b258e53a6ddae57f8391","modified":1723799748717},{"_id":"public/tags/nodejs/index.html","hash":"1944c9f6d5a3d91f3600b67bbb5ec25ce1c13a8f","modified":1723799748717},{"_id":"public/tags/gcc/index.html","hash":"f77cb10bab3f5d9ccf5fa2a2674e3268e201c219","modified":1723799748717},{"_id":"public/tags/linux/index.html","hash":"f11e3574123cb15dc3e555499f15714ff55a1e74","modified":1723799748717},{"_id":"public/tags/数学/index.html","hash":"9277ea013749af12eb02ba614957b10adbf38466","modified":1723799748717},{"_id":"public/tags/newcoder/index.html","hash":"de048104e8d02200e5df570347e053c545923099","modified":1723799748717},{"_id":"public/tags/算法/index.html","hash":"fd8560d04746819c8f8cc8a6b9cb3fd86035a53c","modified":1723799748717},{"_id":"public/tags/算法/page/2/index.html","hash":"404da2e3a5f238136a0f8dcb2332d69284d6b0b4","modified":1723799748717},{"_id":"public/tags/思维题/index.html","hash":"1d751b74bf14c7923e98477acdc35e0ac986d2cd","modified":1723799748717},{"_id":"public/tags/模运算/index.html","hash":"4522987af6b62e339e08f13bfb5950e0e349100b","modified":1723799748717},{"_id":"public/tags/atcoder/index.html","hash":"8348dc0c72acefba8693733a1cc1101fd6db6370","modified":1723799748717},{"_id":"public/tags/博弈论/index.html","hash":"ca62550e191af9cbc1afc82fd9f888dc346dd876","modified":1723799748717},{"_id":"public/tags/不等式/index.html","hash":"3a490af5772deb7d3226d39078b7aac7d5c9e2f5","modified":1723799748717},{"_id":"public/tags/贪心/index.html","hash":"28b1084b79073c00b6dcc56ad261297cdd1a8c80","modified":1723799748717},{"_id":"public/tags/状态转移/index.html","hash":"7ba2e8a3a6d314ba742cf911bae7fd69e81d774e","modified":1723799748717},{"_id":"public/tags/luogu/index.html","hash":"8b0ee8254e10b1884a4c4cf712deaf65a5dfabc3","modified":1723799748717},{"_id":"public/tags/开发/index.html","hash":"2a847dd3dc1137402560ae21554b6c30734106ee","modified":1723799748717},{"_id":"public/tags/文档/index.html","hash":"3b4d6c88e7a9589b250114994eace6ac7f2143a4","modified":1723799748717},{"_id":"public/tags/学校/index.html","hash":"68808e6abc03efce144b6abc668dca9958de41e3","modified":1723799748717},{"_id":"public/tags/Typora/index.html","hash":"56e69a472775338d900f5240413190514f487b98","modified":1723799748717},{"_id":"public/tags/Markdown/index.html","hash":"a5d144e8dbf4a1ac4b6d939eb478ce327bef98ec","modified":1723799748717},{"_id":"public/tags/随笔/index.html","hash":"fdadb2377e40a1a9c09cc379f54deab4e5165d4f","modified":1723799748717},{"_id":"public/tags/子序列自动机/index.html","hash":"eebdb02883b71c5349abcfd3bdc049db4e27e674","modified":1723799748717},{"_id":"public/tags/坐标系转换/index.html","hash":"df8d5d38dea2cf6857cfcf03a91dff72d1421b27","modified":1723799748717},{"_id":"public/tags/几何问题/index.html","hash":"7c0d4d1b8be249e43a9757aabaa41f5c142eea43","modified":1723799748717},{"_id":"public/tags/树问题，哈希算法/index.html","hash":"676fc93af3c15395253e40ed164bce054fb511dd","modified":1723799748717},{"_id":"public/tags/异或问题/index.html","hash":"0bd55be51b9d60c6d13eca51c89e3d1b5c596857","modified":1723799748717},{"_id":"public/tags/加密算法/index.html","hash":"46f44cfe4ca1f91e3037df5b4dd9ba21a80825a5","modified":1723799748717},{"_id":"public/tags/ECC/index.html","hash":"f702a47777ca0cf8fc4e783a96cae4c25f42c744","modified":1723799748717},{"_id":"public/tags/离散化/index.html","hash":"7b95344def5e7826230edd91df8ade603066a973","modified":1723799748717},{"_id":"public/tags/机器学习/index.html","hash":"99210fdc2ef5e468b32b62a4f24391a32a9e2fd1","modified":1723799748717},{"_id":"public/tags/MindSpore/index.html","hash":"cb43255ff48a28fe02391173ee8cfe1efac68800","modified":1723799748717},{"_id":"public/tags/目录/index.html","hash":"f44006cdd46605a50831d2455f0180f8a709fff1","modified":1723799748717},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1723798639119},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1723798639119},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1723798639119},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1723798639119},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1723798639119},{"_id":"public/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1723798639119},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1723798639119},{"_id":"public/css/noscript.css","hash":"4cd5301e478e0e0d4b176740ec314087ec5cb707","modified":1723798639119},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1723798639119},{"_id":"public/js/motion.js","hash":"8e587c086e3cf8687108fbb3241fe1534c3df463","modified":1723798639119},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1723798639119},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1723798639119},{"_id":"public/js/next-boot.js","hash":"8e2d589585f5270ee90285d3e65b69923c7629d8","modified":1723798639119},{"_id":"public/js/sidebar.js","hash":"b3289010a0cb52c525b1395db72bd463424f2f48","modified":1723798639119},{"_id":"public/js/pjax.js","hash":"adc751f9b63b7a6b4d381506d35a1b3ff4de891f","modified":1723798639119},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1723798639119},{"_id":"public/js/third-party/addtoany.js","hash":"5276c8f78ee562a8965216dc67d762e59cb4a9f2","modified":1723798639119},{"_id":"public/js/third-party/fancybox.js","hash":"819f382c561fe5ec23c67cc5fabd63dd1cc22dc1","modified":1723798639119},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1723798639119},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1723798639119},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1723798639119},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"def07bcc7c17d8a0caad177fb1dd2f3a5e5b3536","modified":1723798639119},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1723798639119},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1723798639119},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1723798639119},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1723798639119},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1723798639119},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1723798639119},{"_id":"public/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1723798639119},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1723798639119},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1723798639119},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1723798639119},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1723798639119},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1723798639119},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1723798639119},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1723798639119},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1723798639119},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1723798639119},{"_id":"public/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1723798639119},{"_id":"public/js/third-party/tags/mermaid.js","hash":"6bf821310342c5b87a631873e7650a475a0765f1","modified":1723798639119},{"_id":"public/js/third-party/tags/wavedrom.js","hash":"40dcd10df6edf124088c329346e0cc0bdac74ef1","modified":1723798639119},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1723798639119},{"_id":"public/css/main.css","hash":"512856cd79e65aaaee41d155f2585bb214bcc99a","modified":1723798639119},{"_id":"public/js/utils.js","hash":"f92420649b150703469bba41cbd5c72768beed88","modified":1723798639119},{"_id":"public/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","hash":"ea8a10b275222aa4fe6004ea90dfb8b7619893ca","modified":1723798639119},{"_id":"public/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","hash":"85ea4d5ef41451cc6d78520f9b8e9c934f3c45f6","modified":1723798639119}],"Category":[{"name":"比赛","_id":"clzwh7b9n00042wwv1cbu8qor"},{"name":"模拟赛","parent":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7b9v000o2wwv1v1tdkmt"},{"name":"软件","_id":"clzwh7b9x000y2wwv89nw77g9"},{"name":"信息安全","_id":"clzwh7ba4001r2wwv5wmxfk8r"},{"name":"日常赛","parent":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7ba6001v2wwvbf6b7e19"},{"name":"icpc省赛","parent":"clzwh7b9v000o2wwv1v1tdkmt","_id":"clzwh7ba700222wwvhrbe0s2c"},{"name":"算法","_id":"clzwh7ba9002c2wwvfozfgdwq"},{"name":"icpc邀请赛","parent":"clzwh7b9v000o2wwv1v1tdkmt","_id":"clzwh7baa002i2wwv0cnj4h1b"},{"name":"工具类软件","parent":"clzwh7b9x000y2wwv89nw77g9","_id":"clzwh7bab002r2wwv91exfqcs"},{"name":"蓝桥模拟","parent":"clzwh7b9v000o2wwv1v1tdkmt","_id":"clzwh7bab00302wwvgwllalty"},{"name":"经典库","parent":"clzwh7b9x000y2wwv89nw77g9","_id":"clzwh7bac00342wwv3k4leq5u"},{"name":"手册","parent":"clzwh7b9x000y2wwv89nw77g9","_id":"clzwh7bac00372wwvf2jc5an9"},{"name":"编辑器","parent":"clzwh7b9x000y2wwv89nw77g9","_id":"clzwh7bad003d2wwv56ude8yh"},{"name":"ccpc邀请赛","parent":"clzwh7b9v000o2wwv1v1tdkmt","_id":"clzwh7bae003h2wwvb1kpd7ty"},{"name":"学术","_id":"clzwh7bam004j2wwvew929fzz"},{"name":"加密算法","parent":"clzwh7ba4001r2wwv5wmxfk8r","_id":"clzwh7ban004t2wwvaq9set3h"},{"name":"专题","_id":"clzwh7ban004w2wwv3ooa48wo"},{"name":"newcoder","parent":"clzwh7ba6001v2wwvbf6b7e19","_id":"clzwh7bao00512wwv1jg264z5"},{"name":"思维题","parent":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7baq005m2wwv8tcvag3k"},{"name":"atcoder","parent":"clzwh7ba6001v2wwvbf6b7e19","_id":"clzwh7baq005r2wwvh5av6aqr"},{"name":"数学","parent":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bar005v2wwv8xda9wrn"},{"name":"信息安全","parent":"clzwh7bac00342wwv3k4leq5u","_id":"clzwh7bas00652wwvhepe5m96"},{"name":"Markdown","parent":"clzwh7bad003d2wwv56ude8yh","_id":"clzwh7bas00682wwv8tqd6gjl"},{"name":"字符串","parent":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bas006c2wwv7z088sy1"},{"name":"图论","parent":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bau006r2wwv5h648zhk"},{"name":"前端","parent":"clzwh7bac00342wwv3k4leq5u","_id":"clzwh7bau006x2wwvcs3s49ht"},{"name":"状态转移","parent":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bau00722wwv6pxc4xwi"},{"name":"综述","parent":"clzwh7bam004j2wwvew929fzz","_id":"clzwh7bav007d2wwv8ouf3zi8"},{"name":"数学","parent":"clzwh7ban004t2wwvaq9set3h","_id":"clzwh7baw007k2wwv8h7q4gc4"},{"name":"机器学习","parent":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7baw007q2wwvdi9t957d"},{"name":"模运算","parent":"clzwh7baq005m2wwv8tcvag3k","_id":"clzwh7bb0008b2wwvaaer8s27"},{"name":"博弈论","parent":"clzwh7bar005v2wwv8xda9wrn","_id":"clzwh7bb0008e2wwvhwibgxid"},{"name":"贪心","parent":"clzwh7baq005m2wwv8tcvag3k","_id":"clzwh7bb1008j2wwv1jb2avpl"},{"name":"子序列自动机","parent":"clzwh7bas006c2wwv7z088sy1","_id":"clzwh7bb1008o2wwv6w98dh8p"},{"name":"图论中的回文问题","parent":"clzwh7bau006r2wwv5h648zhk","_id":"clzwh7bb1008s2wwvhmx77kv1"},{"name":"node","parent":"clzwh7bau006x2wwvcs3s49ht","_id":"clzwh7bb2008x2wwv5n2k0o6t"},{"name":"状态转移中的异或问题","parent":"clzwh7bau00722wwv6pxc4xwi","_id":"clzwh7bb200912wwv811xep16"},{"name":"复杂状态转移与优化","parent":"clzwh7bau00722wwv6pxc4xwi","_id":"clzwh7bb200942wwvdnog25au"},{"name":"Mindspore","parent":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb200972wwv1gnba94m"},{"name":"基本概念","parent":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb3009o2wwva0s7fotm"}],"Data":[{"_id":"languages","data":{"zh-CN":{"post":{"copyright":{"author":"本文博主"},"comments":{"comments":"评论","write":"编写","preview":"预览"}},"menu":{"monitor":"监控器","categories":"日志"}},"en":{"menu":{"schedule":"Calendar"}}}}],"Page":[{"_content":"!(function() {\n  /** 计时起始时间，自行修改 **/\n  var start = new Date(\"2021/11/17 15:28:57\");\n\n  function update() {\n    var now = new Date();\n    now.setTime(now.getTime()+250);\n    days = (now - start) / 1000 / 60 / 60 / 24;\n    dnum = Math.floor(days);\n    hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n    hnum = Math.floor(hours);\n    if(String(hnum).length === 1 ){\n      hnum = \"0\" + hnum;\n    }\n    minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n    mnum = Math.floor(minutes);\n    if(String(mnum).length === 1 ){\n      mnum = \"0\" + mnum;\n    }\n    seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n    snum = Math.round(seconds);\n    if(String(snum).length === 1 ){\n      snum = \"0\" + snum;\n    }\n    document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行&nbsp\"+dnum+\"&nbsp天\";\n    document.getElementById(\"times\").innerHTML = hnum + \"&nbsp小时&nbsp\" + mnum + \"&nbsp分&nbsp\" + snum + \"&nbsp秒\";\n  }\n\n  update();\n  setInterval(update, 1000);\n})();","source":"runtime.js","raw":"!(function() {\n  /** 计时起始时间，自行修改 **/\n  var start = new Date(\"2021/11/17 15:28:57\");\n\n  function update() {\n    var now = new Date();\n    now.setTime(now.getTime()+250);\n    days = (now - start) / 1000 / 60 / 60 / 24;\n    dnum = Math.floor(days);\n    hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n    hnum = Math.floor(hours);\n    if(String(hnum).length === 1 ){\n      hnum = \"0\" + hnum;\n    }\n    minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n    mnum = Math.floor(minutes);\n    if(String(mnum).length === 1 ){\n      mnum = \"0\" + mnum;\n    }\n    seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n    snum = Math.round(seconds);\n    if(String(snum).length === 1 ){\n      snum = \"0\" + snum;\n    }\n    document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行&nbsp\"+dnum+\"&nbsp天\";\n    document.getElementById(\"times\").innerHTML = hnum + \"&nbsp小时&nbsp\" + mnum + \"&nbsp分&nbsp\" + snum + \"&nbsp秒\";\n  }\n\n  update();\n  setInterval(update, 1000);\n})();","date":"2024-08-16T08:57:05.640Z","updated":"2024-08-16T08:53:49.937Z","path":"runtime.js","layout":"false","title":"","comments":1,"_id":"clzwh7b9g00002wwv6v9l2gp2","content":"!(function() {\n  /** 计时起始时间，自行修改 **/\n  var start = new Date(\"2021/11/17 15:28:57\");\n\n  function update() {\n    var now = new Date();\n    now.setTime(now.getTime()+250);\n    days = (now - start) / 1000 / 60 / 60 / 24;\n    dnum = Math.floor(days);\n    hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n    hnum = Math.floor(hours);\n    if(String(hnum).length === 1 ){\n      hnum = \"0\" + hnum;\n    }\n    minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n    mnum = Math.floor(minutes);\n    if(String(mnum).length === 1 ){\n      mnum = \"0\" + mnum;\n    }\n    seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n    snum = Math.round(seconds);\n    if(String(snum).length === 1 ){\n      snum = \"0\" + snum;\n    }\n    document.getElementById(\"timeDate\").innerHTML = \"本站已安全运行&nbsp\"+dnum+\"&nbsp天\";\n    document.getElementById(\"times\").innerHTML = hnum + \"&nbsp小时&nbsp\" + mnum + \"&nbsp分&nbsp\" + snum + \"&nbsp秒\";\n  }\n\n  update();\n  setInterval(update, 1000);\n})();"},{"title":"404","date":"2014-12-22T04:39:04.000Z","comments":0,"_content":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","source":"404/404.md","raw":"---\ntitle: '404'\ndate: 2014-12-22 12:39:04\ncomments: false\n---\n<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","updated":"2024-08-14T05:39:50.887Z","path":"404/404.html","layout":"page","_id":"clzwh7b9l00022wwvhwew05iz","content":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","length":17,"excerpt":"","more":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>"},{"title":"关于","date":"2024-08-14T07:06:43.000Z","_content":"\n# 注意事项\n***网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主***\nps：我也将尽力保留数据\n\n这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链\n\n## **Little Resume**\n\n博主: Deepcity\n\n职业: 研究生\n\n电子邮箱: f1159472899@163.com\n\n## 友链\n\n{% linkgrid %}\nBraumAce | https://blog.braumace.cn/ByteLighting/ | 一个后端开发者 | https://blog.braumace.cn/ByteLighting/BraumAce.jpg\n{% endlinkgrid %}\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2024-08-14 15:06:43\n---\n\n# 注意事项\n***网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主***\nps：我也将尽力保留数据\n\n这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链\n\n## **Little Resume**\n\n博主: Deepcity\n\n职业: 研究生\n\n电子邮箱: f1159472899@163.com\n\n## 友链\n\n{% linkgrid %}\nBraumAce | https://blog.braumace.cn/ByteLighting/ | 一个后端开发者 | https://blog.braumace.cn/ByteLighting/BraumAce.jpg\n{% endlinkgrid %}\n","updated":"2024-08-14T13:51:09.539Z","path":"about/index.html","comments":1,"layout":"page","_id":"clzwh7b9o00062wwvf84h60pl","content":"<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p><strong><em>网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主</em></strong><br>ps：我也将尽力保留数据</p>\n<p>这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链</p>\n<h2 id=\"Little-Resume\"><a href=\"#Little-Resume\" class=\"headerlink\" title=\"Little Resume\"></a><strong>Little Resume</strong></h2><p>博主: Deepcity</p>\n<p>职业: 研究生</p>\n<p>电子邮箱: f1159472899@163.com</p>\n<h2 id=\"友链\"><a href=\"#友链\" class=\"headerlink\" title=\"友链\"></a>友链</h2><div class=\"link-grid\"><div class=\"link-grid-container\">\n<object class=\"link-grid-image\" data=\"https://blog.braumace.cn/ByteLighting/BraumAce.jpg\"></object>\n<p>BraumAce</p><p>一个后端开发者</p>\n<a href=\"https://blog.braumace.cn/ByteLighting/\"></a>\n</div></div>\n","length":143,"excerpt":"","more":"<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p><strong><em>网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主</em></strong><br>ps：我也将尽力保留数据</p>\n<p>这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链</p>\n<h2 id=\"Little-Resume\"><a href=\"#Little-Resume\" class=\"headerlink\" title=\"Little Resume\"></a><strong>Little Resume</strong></h2><p>博主: Deepcity</p>\n<p>职业: 研究生</p>\n<p>电子邮箱: f1159472899@163.com</p>\n<h2 id=\"友链\"><a href=\"#友链\" class=\"headerlink\" title=\"友链\"></a>友链</h2><div class=\"link-grid\"><div class=\"link-grid-container\">\n<object class=\"link-grid-image\" data=\"https://blog.braumace.cn/ByteLighting/BraumAce.jpg\"></object>\n<p>BraumAce</p><p>一个后端开发者</p>\n<a href=\"https://blog.braumace.cn/ByteLighting/\"></a>\n</div></div>\n"},{"title":"服务器日历","date":"2024-08-14T05:13:45.000Z","type":"schedule","_content":"","source":"schedule/index.md","raw":"---\ntitle: 服务器日历\ndate: 2024-08-14 13:13:45\ntype: schedule\n---\n","updated":"2024-08-14T12:03:54.657Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"clzwh7b9p00082wwv1v6ug91a","content":"","length":0,"excerpt":"","more":""},{"title":"categories","date":"2024-08-14T07:00:25.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2024-08-14 15:00:25\ntype: categories\n---\n","updated":"2024-08-14T07:00:37.565Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clzwh7b9q000a2wwvcv313os4","content":"","length":0,"excerpt":"","more":""},{"title":"标签","date":"2024-08-14T05:02:25.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2024-08-14 13:02:25\ntype: tags\n---","updated":"2024-08-14T05:14:48.261Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clzwh7b9s000f2wwversfe9l5","content":"","length":0,"excerpt":"","more":""}],"Post":[{"title":"2024武汉ICPC邀请赛VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 武汉邀请赛VP\n\n### I.[Cyclic Apple Strings](https://codeforces.com/gym/105143/problem/I)\n\n<!--more-->\n\n计算第一个1后的0的段数\n\n```cpp\nvoid slove() {\n\tstring s;cin>>s;\n\tint f =0,cnt = 0;\n\tfor(int i = 0;i < s.size(); i ++)\n\t{\n\t\tf|=(s[i] == '1');\n\t\tif(s[i]=='0')\n\t\twhile(i+1 < s.size() && s[i+1] == '0')\n\t\t\ti++;\n\t\tif(f && s[i] =='0') cnt++;\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\nK.[Party Games](https://codeforces.com/gym/105143/problem/K)\n\n打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tint r = n % 4;\n\tif(r==0 || r==1) cout<<\"Fluttershy\\n\";\n\telse if(r==2 || r==3) cout<<\"Pinkie Pie\\n\";\n}\n```\n\nF. [Custom-Made Clothes](https://codeforces.com/gym/105143/problem/F)\n\n简单二分或者二分套二分(另一个二分二分第一次的下标)\n\n注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到$$n \\le 1000$$。\n\n考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。\n\n```cpp\nint query(int x,int y,int v){\n\tif(g[x][y]) return g[x][y] <= v;\n\tcout<<\"?\"<<x<<' '<<y<<' '<<v<<endl;\n\tcout.flush();\n\tint res ;cin>>res;\n\treturn res;\n}\n\nint get(int x,int y,int l=1,int r=mx){\n\tif(!g[x][y]) return g[x][y];\n\twhile(l<r){\n\t\tint mid=  l+r>>1;\n\t\tif(query(x,y,mid)) r=mid;\n\t\telse l = mid+1;\n\t}\n\treturn g[x][y] = l;\n}\n\nvoid slove() {\n\tcin>>n>>k;\n\tmx = n * n;\n\tint l=1,r=mx;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\tint now = n;\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\twhile(now && !query(now,i,mid))now--;\n\t\t\tcnt += now;\n\t\t\tif(!now) break;\n\t\t}\n\t\tif(cnt < k) r=mid;\n\t\telse l=mid+1; \n\t}\n\tcout<<r<<endl;\n}\n```\n\n\n\nB. [Countless Me](https://codeforces.com/gym/105143/problem/B)\n\n很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：\n\n取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。\n\n维护sum值，将高位的1拆分给低位。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tint ans =0;\n  for (ll i = 30; i >= 0; i--) {\n      if (((1ll << i) - 1) * n >= sum) continue;\n      ll num = min(n, sum / (1ll << i));\n      if (num == 0) continue;\n      sum -= num * (1ll << i);\n      ans |= 1ll <<  i;\n  }\n\tcout<<ans<<endl;\n}\n```\n\n下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。\n\nhack数据\n\n```txt\n2\n3 0\n-------\n2\n7 3\n```\n\n```cpp\nvoid slove() {\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int sum = 0;\n    for(int i=1;i<=n;i++) sum += a[i];\n\n    int ans =0,cnt = 0;\n    for(int i=31;~i;i--){\n        cnt = (cnt<<1) + (sum >>i &1);\n        if(cnt >= n) ans += (sum >> i &1) <<i;\n    }\n    cout<<ans<<endl;\n}\n```\n\nD.[ICPC](https://codeforces.com/gym/105143/problem/D)\n\nICPC!!!，估计很多人一看到这个名字和答案求法就跑了。\n\n但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。\n\n思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。\n\ndp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++) pre[i] = pre[i-1] + a[i];\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(pre[i] - pre[max(i-j-1,0)]\n\t\t\t\t,pre[min(n,i+j)]- pre[i-1]);\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(f1[i][j],f1[i-1][j-1]);\n\t\t}\n\t}\n\n\tfor(int i=n;i;i--) {\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf2[i][j] = max(f1[i][j],f2[i+1][j-1]);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tll t = 0;\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tt ^= j*max(f1[i][j],f2[i][j]);\n\t\t}\n\t\tans ^= (i+ t);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n","source":"_posts/2024武汉ICPC邀请赛VP.md","raw":"---\ntitle: 2024武汉ICPC邀请赛VP\ndate: 2024-08-14 19:46:31\ntags: [icpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- icpc邀请赛\n---\n\n## 武汉邀请赛VP\n\n### I.[Cyclic Apple Strings](https://codeforces.com/gym/105143/problem/I)\n\n<!--more-->\n\n计算第一个1后的0的段数\n\n```cpp\nvoid slove() {\n\tstring s;cin>>s;\n\tint f =0,cnt = 0;\n\tfor(int i = 0;i < s.size(); i ++)\n\t{\n\t\tf|=(s[i] == '1');\n\t\tif(s[i]=='0')\n\t\twhile(i+1 < s.size() && s[i+1] == '0')\n\t\t\ti++;\n\t\tif(f && s[i] =='0') cnt++;\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\nK.[Party Games](https://codeforces.com/gym/105143/problem/K)\n\n打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tint r = n % 4;\n\tif(r==0 || r==1) cout<<\"Fluttershy\\n\";\n\telse if(r==2 || r==3) cout<<\"Pinkie Pie\\n\";\n}\n```\n\nF. [Custom-Made Clothes](https://codeforces.com/gym/105143/problem/F)\n\n简单二分或者二分套二分(另一个二分二分第一次的下标)\n\n注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到$$n \\le 1000$$。\n\n考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。\n\n```cpp\nint query(int x,int y,int v){\n\tif(g[x][y]) return g[x][y] <= v;\n\tcout<<\"?\"<<x<<' '<<y<<' '<<v<<endl;\n\tcout.flush();\n\tint res ;cin>>res;\n\treturn res;\n}\n\nint get(int x,int y,int l=1,int r=mx){\n\tif(!g[x][y]) return g[x][y];\n\twhile(l<r){\n\t\tint mid=  l+r>>1;\n\t\tif(query(x,y,mid)) r=mid;\n\t\telse l = mid+1;\n\t}\n\treturn g[x][y] = l;\n}\n\nvoid slove() {\n\tcin>>n>>k;\n\tmx = n * n;\n\tint l=1,r=mx;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\tint now = n;\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\twhile(now && !query(now,i,mid))now--;\n\t\t\tcnt += now;\n\t\t\tif(!now) break;\n\t\t}\n\t\tif(cnt < k) r=mid;\n\t\telse l=mid+1; \n\t}\n\tcout<<r<<endl;\n}\n```\n\n\n\nB. [Countless Me](https://codeforces.com/gym/105143/problem/B)\n\n很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：\n\n取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。\n\n维护sum值，将高位的1拆分给低位。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tint ans =0;\n  for (ll i = 30; i >= 0; i--) {\n      if (((1ll << i) - 1) * n >= sum) continue;\n      ll num = min(n, sum / (1ll << i));\n      if (num == 0) continue;\n      sum -= num * (1ll << i);\n      ans |= 1ll <<  i;\n  }\n\tcout<<ans<<endl;\n}\n```\n\n下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。\n\nhack数据\n\n```txt\n2\n3 0\n-------\n2\n7 3\n```\n\n```cpp\nvoid slove() {\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int sum = 0;\n    for(int i=1;i<=n;i++) sum += a[i];\n\n    int ans =0,cnt = 0;\n    for(int i=31;~i;i--){\n        cnt = (cnt<<1) + (sum >>i &1);\n        if(cnt >= n) ans += (sum >> i &1) <<i;\n    }\n    cout<<ans<<endl;\n}\n```\n\nD.[ICPC](https://codeforces.com/gym/105143/problem/D)\n\nICPC!!!，估计很多人一看到这个名字和答案求法就跑了。\n\n但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。\n\n思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。\n\ndp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++) pre[i] = pre[i-1] + a[i];\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(pre[i] - pre[max(i-j-1,0)]\n\t\t\t\t,pre[min(n,i+j)]- pre[i-1]);\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(f1[i][j],f1[i-1][j-1]);\n\t\t}\n\t}\n\n\tfor(int i=n;i;i--) {\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf2[i][j] = max(f1[i][j],f2[i+1][j-1]);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tll t = 0;\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tt ^= j*max(f1[i][j],f2[i][j]);\n\t\t}\n\t\tans ^= (i+ t);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n","slug":"2024武汉ICPC邀请赛VP","published":1,"updated":"2024-08-15T04:51:18.015Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9i00012wwv3676e6cu","content":"<h2 id=\"武汉邀请赛VP\"><a href=\"#武汉邀请赛VP\" class=\"headerlink\" title=\"武汉邀请赛VP\"></a>武汉邀请赛VP</h2><h3 id=\"I-Cyclic-Apple-Strings\"><a href=\"#I-Cyclic-Apple-Strings\" class=\"headerlink\" title=\"I.Cyclic Apple Strings\"></a>I.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSQ==\">Cyclic Apple Strings<i class=\"fa fa-external-link-alt\"></i></span></h3><span id=\"more\"></span>\n<p>计算第一个1后的0的段数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"type\">int</span> f =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i &lt; s.<span class=\"built_in\">size</span>(); i ++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tf|=(s[i] == <span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i<span class=\"number\">+1</span> &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; s[i<span class=\"number\">+1</span>] == <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f &amp;&amp; s[i] ==<span class=\"string\">&#x27;0&#x27;</span>) cnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>K.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSw==\">Party Games<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r = n % <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(r==<span class=\"number\">0</span> || r==<span class=\"number\">1</span>) cout&lt;&lt;<span class=\"string\">&quot;Fluttershy\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(r==<span class=\"number\">2</span> || r==<span class=\"number\">3</span>) cout&lt;&lt;<span class=\"string\">&quot;Pinkie Pie\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>F. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRg==\">Custom-Made Clothes<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>简单二分或者二分套二分(另一个二分二分第一次的下标)</p>\n<p>注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到<script type=\"math/tex\">n \\le 1000</script>。</p>\n<p>考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(g[x][y]) <span class=\"keyword\">return</span> g[x][y] &lt;= v;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;?&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;v&lt;&lt;endl;</span><br><span class=\"line\">\tcout.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> res ;cin&gt;&gt;res;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> l=<span class=\"number\">1</span>,<span class=\"type\">int</span> r=mx)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!g[x][y]) <span class=\"keyword\">return</span> g[x][y];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid=  l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">query</span>(x,y,mid)) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g[x][y] = l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\tmx = n * n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l=<span class=\"number\">1</span>,r=mx;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = n;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(now &amp;&amp; !<span class=\"built_in\">query</span>(now,i,mid))now--;</span><br><span class=\"line\">\t\t\tcnt += now;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!now) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &lt; k) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l=mid<span class=\"number\">+1</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>B. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vQg==\">Countless Me<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：</p>\n<p>取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。</p>\n<p>维护sum值，将高位的1拆分给低位。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans =<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (ll i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((<span class=\"number\">1ll</span> &lt;&lt; i) - <span class=\"number\">1</span>) * n &gt;= sum) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      ll num = <span class=\"built_in\">min</span>(n, sum / (<span class=\"number\">1ll</span> &lt;&lt; i));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      sum -= num * (<span class=\"number\">1ll</span> &lt;&lt; i);</span><br><span class=\"line\">      ans |= <span class=\"number\">1ll</span> &lt;&lt;  i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。</p>\n<p>hack数据</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">3 0</span><br><span class=\"line\">-------</span><br><span class=\"line\">2</span><br><span class=\"line\">7 3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">31</span>;~i;i--)&#123;</span><br><span class=\"line\">        cnt = (cnt&lt;&lt;<span class=\"number\">1</span>) + (sum &gt;&gt;i &amp;<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt;= n) ans += (sum &gt;&gt; i &amp;<span class=\"number\">1</span>) &lt;&lt;i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>D.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRA==\">ICPC<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>ICPC!!!，估计很多人一看到这个名字和答案求法就跑了。</p>\n<p>但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。</p>\n<p>思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。</p>\n<p>dp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(pre[i] - pre[<span class=\"built_in\">max</span>(i-j<span class=\"number\">-1</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">\t\t\t\t,pre[<span class=\"built_in\">min</span>(n,i+j)]- pre[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f1[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf2[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f2[i<span class=\"number\">+1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tll t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tt ^= j*<span class=\"built_in\">max</span>(f1[i][j],f2[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans ^= (i+ t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":1150,"excerpt":"<h2 id=\"武汉邀请赛VP\"><a href=\"#武汉邀请赛VP\" class=\"headerlink\" title=\"武汉邀请赛VP\"></a>武汉邀请赛VP</h2><h3 id=\"I-Cyclic-Apple-Strings\"><a href=\"#I-Cyclic-Apple-Strings\" class=\"headerlink\" title=\"I.Cyclic Apple Strings\"></a>I.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSQ==\">Cyclic Apple Strings<i class=\"fa fa-external-link-alt\"></i></span></h3>","more":"<p>计算第一个1后的0的段数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"type\">int</span> f =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i &lt; s.<span class=\"built_in\">size</span>(); i ++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tf|=(s[i] == <span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i<span class=\"number\">+1</span> &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; s[i<span class=\"number\">+1</span>] == <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f &amp;&amp; s[i] ==<span class=\"string\">&#x27;0&#x27;</span>) cnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>K.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSw==\">Party Games<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r = n % <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(r==<span class=\"number\">0</span> || r==<span class=\"number\">1</span>) cout&lt;&lt;<span class=\"string\">&quot;Fluttershy\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(r==<span class=\"number\">2</span> || r==<span class=\"number\">3</span>) cout&lt;&lt;<span class=\"string\">&quot;Pinkie Pie\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>F. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRg==\">Custom-Made Clothes<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>简单二分或者二分套二分(另一个二分二分第一次的下标)</p>\n<p>注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到<script type=\"math/tex\">n \\le 1000</script>。</p>\n<p>考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(g[x][y]) <span class=\"keyword\">return</span> g[x][y] &lt;= v;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;?&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;v&lt;&lt;endl;</span><br><span class=\"line\">\tcout.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> res ;cin&gt;&gt;res;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> l=<span class=\"number\">1</span>,<span class=\"type\">int</span> r=mx)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!g[x][y]) <span class=\"keyword\">return</span> g[x][y];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid=  l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">query</span>(x,y,mid)) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g[x][y] = l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\tmx = n * n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l=<span class=\"number\">1</span>,r=mx;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = n;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(now &amp;&amp; !<span class=\"built_in\">query</span>(now,i,mid))now--;</span><br><span class=\"line\">\t\t\tcnt += now;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!now) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &lt; k) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l=mid<span class=\"number\">+1</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>B. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vQg==\">Countless Me<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：</p>\n<p>取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。</p>\n<p>维护sum值，将高位的1拆分给低位。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans =<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (ll i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((<span class=\"number\">1ll</span> &lt;&lt; i) - <span class=\"number\">1</span>) * n &gt;= sum) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      ll num = <span class=\"built_in\">min</span>(n, sum / (<span class=\"number\">1ll</span> &lt;&lt; i));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      sum -= num * (<span class=\"number\">1ll</span> &lt;&lt; i);</span><br><span class=\"line\">      ans |= <span class=\"number\">1ll</span> &lt;&lt;  i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。</p>\n<p>hack数据</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">3 0</span><br><span class=\"line\">-------</span><br><span class=\"line\">2</span><br><span class=\"line\">7 3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">31</span>;~i;i--)&#123;</span><br><span class=\"line\">        cnt = (cnt&lt;&lt;<span class=\"number\">1</span>) + (sum &gt;&gt;i &amp;<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt;= n) ans += (sum &gt;&gt; i &amp;<span class=\"number\">1</span>) &lt;&lt;i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>D.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRA==\">ICPC<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>ICPC!!!，估计很多人一看到这个名字和答案求法就跑了。</p>\n<p>但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。</p>\n<p>思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。</p>\n<p>dp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(pre[i] - pre[<span class=\"built_in\">max</span>(i-j<span class=\"number\">-1</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">\t\t\t\t,pre[<span class=\"built_in\">min</span>(n,i+j)]- pre[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f1[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf2[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f2[i<span class=\"number\">+1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tll t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tt ^= j*<span class=\"built_in\">max</span>(f1[i][j],f2[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans ^= (i+ t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"2024江苏CCPC邀请赛-VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 江苏CCPC-VP\n\n## F. Download Speed Monitor\n\n[Problem - F - Codeforces](https://codeforces.com/gym/105161/problem/F)\n\n<!--more-->\n\n### 题意：\n\n您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。\n\n下载速度监视器的工作原理如下：从 $$(k-1)$$$ (秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 $$$k$$ (秒)开始，监视器将显示从 $$(i-k+1)$$$$ (秒)到 $$$$i$$(秒)再到 $$i$$ (秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于 $$1024$$ KiBps 时，下载速度监视器将以 MiBps 为单位显示结果。\n\n您的下载任务将持续 $$n$$ 秒。考虑到平均速度的计算间隔为 $$k$$ ，您想知道从 $k$$$ (秒)到 $$$$n$$ (秒)，监控器上将显示什么。\n\nNote: $$1$$$ MiBps $$$=1024$$$$ KiBps$$​.\n\n### 题解：\n\n签到题，双指针扫一下即可\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tll sum  = 0;\n\tfor(int i=1,j=1;i<=n;i++)\n\t{\n\t\tsum += a[i];\n\t\tif(i - j >= k) sum -= a[j ++];\n\t\tif(i - j + 1 < k) continue;\n\t\t// cout<<i<< ' '<<j<< ' ' <<sum<<endl;\n\t\tdouble spd = double(1.0 * sum / k);\n\t\tstring ad = \"KiBps\";\n\t\tif(spd >= 1024) spd /= 1024, ad = \"MiBps\";\n\t\tprintf(\"%.6lf\", spd);\n\t\tcout<<' '<<ad<<endl;\n\t}\n}\n```\n\n## G. Download Time Monitor\n\n[Problem - G - Codeforces](https://codeforces.com/gym/105161/problem/G)\n\n### 题意：\n\n您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。\n\n您使用的网络带宽为 $$B$$ MiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 $t_1$ 秒，大小为 $$a_1$$ MiB，而第二个文件开始下载的时间为 $$t_2$$ 秒，大小为 $$a_2$$ MiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在 $$B$$ MiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 $$\\frac{B}{2}$$ MiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。\n\n现在，您想知道两个文件完成下载各需要多长时间。\n\n### 题解：\n\n出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）\n\n这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。\n\n注意是下载花费时间而不是总时间\n\n这题浮点运算常数较大，开O2和解同步会比较好\n\n```cpp\n#pragma GCC optimize(2)\n#define FIO std::ios::sync_with_stdio(false);std::cin.tie(0);\n```\n\n```cpp\nvoid slove() {\n\tint B,t1,t2,a1,a2;\n\tcin>>B>>t1>>a1>>t2>>a2;\n\n\tint f = 0;\n\n\tif(t1 > t2){\n\t\tswap(t1,t2);swap(a1,a2);\n\t\tf=1;\n\t}\n\n\tdouble d = t2-t1;\n\tdouble a,b;\n\n\tif(d * B > a1){\n\t\ta = 1.0 *a1 / B;\n\t\tb = 1.0 *a2 / B;\n\t\td=0;\n\t}else {\n\t\ta1 -= d * B;\n\t\tif(a1 > a2) f^= 1,swap(a1,a2);\n\t\t// cout<<a1<< ' '<<a2<<endl;\n\t\ta = 1.0 *a1 / (1.0 *B/2);\n\t\tb = 1.0 *a1 / (1.0 *B/2) + 1.0 *(a2 - a1) /B;\n\t}\n\n\tif(!f) printf(\"%.9lf %.9lf\\n\",a + d, b);\n\telse printf(\"%.9lf %.9lf\\n\",b + d,a);\n}\n```\n\n## K. Number Deletion Game\n\n[Problem - K - Codeforces](https://codeforces.com/gym/105161/problem/K)\n\n### 题意：\n\n爱丽丝和鲍勃正在玩一个数字删除游戏。\n\n一开始，有 $$n$$$ 个整数 $$$a_ 1,a _ 2, \\ldots ,a _n$$ 。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除**大的数字**$$x$$$ ，并选择一个比 $$$x$$**小的非负整数 $$y$$$ ，然后在数字 $$$1,2,\\ldots, y$$$ 中各加一个。特别是可以选择 $$$y=0$$ ，在这种情况下不会添加任何数字。也就是说，删除 $$1$$ 时，不能添加任何数字。删除最后一个数字的人获胜。\n\n双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。\n\n### 题解：\n\n注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。\n\n另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。\n\n​\t那么对于最大值取$$1 \\to k$$成立，试证明对k+1成立，分类讨论\n\n\t1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\n\t1. k+1为偶数个，同理，Bob胜\n\ncoding\n\n```CPP\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tsort(a+1,a+1+n);\n\tint num = -1;\n\tfor(int i=n;i;i--)\n\t\tif(a[i] != a[n]) {\n\t\t\tnum = n-i;\n\t\t\tbreak;\n\t\t}\n\tif(num == -1) num = n;\n\t// cout<<num<<endl;\n\tif(num&1) puts(\"Alice\");\n\telse puts(\"Bob\");\n}\n```\n\n## I. Integer Reaction\n\n[Problem - I - Codeforces](https://codeforces.com/gym/105161/problem/I)\n\n###　题意：\n\n有一个由 $$n$$ 个整数组成的序列，从左到右编号为 $$1$$ 到 $$n$$ 。这些整数有两种颜色，分别是 $$0$$ 和 $$1$$ ，每个整数正好有一种颜色。这些整数按照从 $$1$$到 $$n$$ 的编号顺序进入多集合 $$S_1$$ 。\n\n每当一个新的整数 $$x$$ 进入 $$S_1$$ 时，你必须在 $$S_1$$ 中选择一个颜色与 $$x$$ 不同的整数 $$y$$ 与 $$x$$ 发生反应，使得 $$x$$ 和 $$y$$ 消失，反应产物 $$x+y$$ 插入另一个集合 $$S_2$$ 中。如果不存在这样的 $$y$$ ，则不会发生反应，只有 $$x$$ 会插入 $$S_1$$ 。\n\n给定整数序列和每个整数的颜色，求处理最后一个元素后 $$S_2$$​ 中最小元素的最大可能值。\n\n### 题解\n\n很简单，二分答案贪心维护$$S_1$$即可\n\n```cpp\nint ck(int x){\n\t// cout<<x<<endl;\n\tmultiset<int> ms;\n\tint c = -1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(c==-1){\n\t\t\tms.insert(a[i].x);\n\t\t\tc = a[i].y;\n\t\t}else {\n\t\t\tif(c == a[i].y){\n\t\t\t\tms.insert(a[i].x);\n\t\t\t}else if(ms.size()){\n\t\t\t\t// cout<<x-a[i].y<<endl;\n\t\t\t\tauto it = lower_bound(all(ms), x - a[i].x);\n\t\t\t\tif(it == ms.end()) return 0;\n\t\t\t\t// if(x==7)cout<<*it<<endl;\n\t\t\t\tms.erase(it);\n\t\t\t}else {\n\t\t\t\tms.insert(a[i].x);\n\t\t\t\tc = a[i].y;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n};\n\nvoid slove() {\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].x);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].y);\n\n\tint l = 1,r = INF;\n\twhile(l<r){\n\t\tint mid = l+r+1 >> 1;\n\t\tif(ck(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\n\tprintf(\"%d\\n\",l);\n}\n```\n\n","source":"_posts/2024江苏CCPC邀请赛-VP.md","raw":"---\ntitle: 2024江苏CCPC邀请赛-VP\ndate: 2024-08-14 19:46:31\ntags: [ccpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- ccpc邀请赛\n---\n\n## 江苏CCPC-VP\n\n## F. Download Speed Monitor\n\n[Problem - F - Codeforces](https://codeforces.com/gym/105161/problem/F)\n\n<!--more-->\n\n### 题意：\n\n您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。\n\n下载速度监视器的工作原理如下：从 $$(k-1)$$$ (秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 $$$k$$ (秒)开始，监视器将显示从 $$(i-k+1)$$$$ (秒)到 $$$$i$$(秒)再到 $$i$$ (秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于 $$1024$$ KiBps 时，下载速度监视器将以 MiBps 为单位显示结果。\n\n您的下载任务将持续 $$n$$ 秒。考虑到平均速度的计算间隔为 $$k$$ ，您想知道从 $k$$$ (秒)到 $$$$n$$ (秒)，监控器上将显示什么。\n\nNote: $$1$$$ MiBps $$$=1024$$$$ KiBps$$​.\n\n### 题解：\n\n签到题，双指针扫一下即可\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tll sum  = 0;\n\tfor(int i=1,j=1;i<=n;i++)\n\t{\n\t\tsum += a[i];\n\t\tif(i - j >= k) sum -= a[j ++];\n\t\tif(i - j + 1 < k) continue;\n\t\t// cout<<i<< ' '<<j<< ' ' <<sum<<endl;\n\t\tdouble spd = double(1.0 * sum / k);\n\t\tstring ad = \"KiBps\";\n\t\tif(spd >= 1024) spd /= 1024, ad = \"MiBps\";\n\t\tprintf(\"%.6lf\", spd);\n\t\tcout<<' '<<ad<<endl;\n\t}\n}\n```\n\n## G. Download Time Monitor\n\n[Problem - G - Codeforces](https://codeforces.com/gym/105161/problem/G)\n\n### 题意：\n\n您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。\n\n您使用的网络带宽为 $$B$$ MiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 $t_1$ 秒，大小为 $$a_1$$ MiB，而第二个文件开始下载的时间为 $$t_2$$ 秒，大小为 $$a_2$$ MiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在 $$B$$ MiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 $$\\frac{B}{2}$$ MiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。\n\n现在，您想知道两个文件完成下载各需要多长时间。\n\n### 题解：\n\n出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）\n\n这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。\n\n注意是下载花费时间而不是总时间\n\n这题浮点运算常数较大，开O2和解同步会比较好\n\n```cpp\n#pragma GCC optimize(2)\n#define FIO std::ios::sync_with_stdio(false);std::cin.tie(0);\n```\n\n```cpp\nvoid slove() {\n\tint B,t1,t2,a1,a2;\n\tcin>>B>>t1>>a1>>t2>>a2;\n\n\tint f = 0;\n\n\tif(t1 > t2){\n\t\tswap(t1,t2);swap(a1,a2);\n\t\tf=1;\n\t}\n\n\tdouble d = t2-t1;\n\tdouble a,b;\n\n\tif(d * B > a1){\n\t\ta = 1.0 *a1 / B;\n\t\tb = 1.0 *a2 / B;\n\t\td=0;\n\t}else {\n\t\ta1 -= d * B;\n\t\tif(a1 > a2) f^= 1,swap(a1,a2);\n\t\t// cout<<a1<< ' '<<a2<<endl;\n\t\ta = 1.0 *a1 / (1.0 *B/2);\n\t\tb = 1.0 *a1 / (1.0 *B/2) + 1.0 *(a2 - a1) /B;\n\t}\n\n\tif(!f) printf(\"%.9lf %.9lf\\n\",a + d, b);\n\telse printf(\"%.9lf %.9lf\\n\",b + d,a);\n}\n```\n\n## K. Number Deletion Game\n\n[Problem - K - Codeforces](https://codeforces.com/gym/105161/problem/K)\n\n### 题意：\n\n爱丽丝和鲍勃正在玩一个数字删除游戏。\n\n一开始，有 $$n$$$ 个整数 $$$a_ 1,a _ 2, \\ldots ,a _n$$ 。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除**大的数字**$$x$$$ ，并选择一个比 $$$x$$**小的非负整数 $$y$$$ ，然后在数字 $$$1,2,\\ldots, y$$$ 中各加一个。特别是可以选择 $$$y=0$$ ，在这种情况下不会添加任何数字。也就是说，删除 $$1$$ 时，不能添加任何数字。删除最后一个数字的人获胜。\n\n双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。\n\n### 题解：\n\n注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。\n\n另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。\n\n​\t那么对于最大值取$$1 \\to k$$成立，试证明对k+1成立，分类讨论\n\n\t1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\n\t1. k+1为偶数个，同理，Bob胜\n\ncoding\n\n```CPP\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tsort(a+1,a+1+n);\n\tint num = -1;\n\tfor(int i=n;i;i--)\n\t\tif(a[i] != a[n]) {\n\t\t\tnum = n-i;\n\t\t\tbreak;\n\t\t}\n\tif(num == -1) num = n;\n\t// cout<<num<<endl;\n\tif(num&1) puts(\"Alice\");\n\telse puts(\"Bob\");\n}\n```\n\n## I. Integer Reaction\n\n[Problem - I - Codeforces](https://codeforces.com/gym/105161/problem/I)\n\n###　题意：\n\n有一个由 $$n$$ 个整数组成的序列，从左到右编号为 $$1$$ 到 $$n$$ 。这些整数有两种颜色，分别是 $$0$$ 和 $$1$$ ，每个整数正好有一种颜色。这些整数按照从 $$1$$到 $$n$$ 的编号顺序进入多集合 $$S_1$$ 。\n\n每当一个新的整数 $$x$$ 进入 $$S_1$$ 时，你必须在 $$S_1$$ 中选择一个颜色与 $$x$$ 不同的整数 $$y$$ 与 $$x$$ 发生反应，使得 $$x$$ 和 $$y$$ 消失，反应产物 $$x+y$$ 插入另一个集合 $$S_2$$ 中。如果不存在这样的 $$y$$ ，则不会发生反应，只有 $$x$$ 会插入 $$S_1$$ 。\n\n给定整数序列和每个整数的颜色，求处理最后一个元素后 $$S_2$$​ 中最小元素的最大可能值。\n\n### 题解\n\n很简单，二分答案贪心维护$$S_1$$即可\n\n```cpp\nint ck(int x){\n\t// cout<<x<<endl;\n\tmultiset<int> ms;\n\tint c = -1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(c==-1){\n\t\t\tms.insert(a[i].x);\n\t\t\tc = a[i].y;\n\t\t}else {\n\t\t\tif(c == a[i].y){\n\t\t\t\tms.insert(a[i].x);\n\t\t\t}else if(ms.size()){\n\t\t\t\t// cout<<x-a[i].y<<endl;\n\t\t\t\tauto it = lower_bound(all(ms), x - a[i].x);\n\t\t\t\tif(it == ms.end()) return 0;\n\t\t\t\t// if(x==7)cout<<*it<<endl;\n\t\t\t\tms.erase(it);\n\t\t\t}else {\n\t\t\t\tms.insert(a[i].x);\n\t\t\t\tc = a[i].y;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n};\n\nvoid slove() {\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].x);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].y);\n\n\tint l = 1,r = INF;\n\twhile(l<r){\n\t\tint mid = l+r+1 >> 1;\n\t\tif(ck(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\n\tprintf(\"%d\\n\",l);\n}\n```\n\n","slug":"2024江苏CCPC邀请赛-VP","published":1,"updated":"2024-08-15T04:51:14.761Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9l00032wwv1r3i2qgt","content":"<h2 id=\"江苏CCPC-VP\"><a href=\"#江苏CCPC-VP\" class=\"headerlink\" title=\"江苏CCPC-VP\"></a>江苏CCPC-VP</h2><h2 id=\"F-Download-Speed-Monitor\"><a href=\"#F-Download-Speed-Monitor\" class=\"headerlink\" title=\"F. Download Speed Monitor\"></a>F. Download Speed Monitor</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRg==\">Problem - F - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<span id=\"more\"></span>\n<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。</p>\n<p>下载速度监视器的工作原理如下：从 <script type=\"math/tex\">(k-1)$$$ (秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 $$$k</script> (秒)开始，监视器将显示从 <script type=\"math/tex\">(i-k+1)$$$$ (秒)到 $$$$i</script>(秒)再到 <script type=\"math/tex\">i</script> (秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于 <script type=\"math/tex\">1024</script> KiBps 时，下载速度监视器将以 MiBps 为单位显示结果。</p>\n<p>您的下载任务将持续 <script type=\"math/tex\">n</script> 秒。考虑到平均速度的计算间隔为 <script type=\"math/tex\">k</script> ，您想知道从 $k<script type=\"math/tex\">$ (秒)到 $$$$n</script> (秒)，监控器上将显示什么。</p>\n<p>Note: <script type=\"math/tex\">1$$$ MiBps $$$=1024$$$$ KiBps</script>​.</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>签到题，双指针扫一下即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum  = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum += a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j &gt;= k) sum -= a[j ++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j + <span class=\"number\">1</span> &lt; k) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt; &#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">double</span> spd = <span class=\"built_in\">double</span>(<span class=\"number\">1.0</span> * sum / k);</span><br><span class=\"line\">\t\tstring ad = <span class=\"string\">&quot;KiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(spd &gt;= <span class=\"number\">1024</span>) spd /= <span class=\"number\">1024</span>, ad = <span class=\"string\">&quot;MiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.6lf&quot;</span>, spd);</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ad&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"G-Download-Time-Monitor\"><a href=\"#G-Download-Time-Monitor\" class=\"headerlink\" title=\"G. Download Time Monitor\"></a>G. Download Time Monitor</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRw==\">Problem - G - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意：-1\"><a href=\"#题意：-1\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。</p>\n<p>您使用的网络带宽为 <script type=\"math/tex\">B</script> MiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 $t_1$ 秒，大小为 <script type=\"math/tex\">a_1</script> MiB，而第二个文件开始下载的时间为 <script type=\"math/tex\">t_2</script> 秒，大小为 <script type=\"math/tex\">a_2</script> MiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在 <script type=\"math/tex\">B</script> MiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 <script type=\"math/tex\">\\frac{B}{2}</script> MiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。</p>\n<p>现在，您想知道两个文件完成下载各需要多长时间。</p>\n<h3 id=\"题解：-1\"><a href=\"#题解：-1\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）</p>\n<p>这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。</p>\n<p>注意是下载花费时间而不是总时间</p>\n<p>这题浮点运算常数较大，开O2和解同步会比较好</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> GCC optimize(2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIO std::ios::sync_with_stdio(false);std::cin.tie(0);</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> B,t1,t2,a1,a2;</span><br><span class=\"line\">\tcin&gt;&gt;B&gt;&gt;t1&gt;&gt;a1&gt;&gt;t2&gt;&gt;a2;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t1 &gt; t2)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(t1,t2);<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\tf=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">double</span> d = t2-t1;</span><br><span class=\"line\">\t<span class=\"type\">double</span> a,b;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(d * B &gt; a1)&#123;</span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / B;</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a2 / B;</span><br><span class=\"line\">\t\td=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\ta1 -= d * B;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a1 &gt; a2) f^= <span class=\"number\">1</span>,<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;a1&lt;&lt; &#x27; &#x27;&lt;&lt;a2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>) + <span class=\"number\">1.0</span> *(a2 - a1) /B;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,a + d, b);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,b + d,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"K-Number-Deletion-Game\"><a href=\"#K-Number-Deletion-Game\" class=\"headerlink\" title=\"K. Number Deletion Game\"></a>K. Number Deletion Game</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSw==\">Problem - K - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意：-2\"><a href=\"#题意：-2\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>爱丽丝和鲍勃正在玩一个数字删除游戏。</p>\n<p>一开始，有 <script type=\"math/tex\">n$$$ 个整数 $$$a_ 1,a _ 2, \\ldots ,a _n</script> 。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除<strong>大的数字</strong><script type=\"math/tex\">x$$$ ，并选择一个比 $$$x</script>**小的非负整数 <script type=\"math/tex\">y$$$ ，然后在数字 $$$1,2,\\ldots, y$$$ 中各加一个。特别是可以选择 $$$y=0</script> ，在这种情况下不会添加任何数字。也就是说，删除 <script type=\"math/tex\">1</script> 时，不能添加任何数字。删除最后一个数字的人获胜。</p>\n<p>双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。</p>\n<h3 id=\"题解：-2\"><a href=\"#题解：-2\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。</p>\n<p>另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。</p>\n<p>​    那么对于最大值取<script type=\"math/tex\">1 \\to k</script>成立，试证明对k+1成立，分类讨论</p>\n<pre><code>1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\n1. k+1为偶数个，同理，Bob胜\n</code></pre><p>coding</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> num = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i] != a[n]) &#123;</span><br><span class=\"line\">\t\t\tnum = n-i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num == <span class=\"number\">-1</span>) num = n;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;num&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num&amp;<span class=\"number\">1</span>) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"I-Integer-Reaction\"><a href=\"#I-Integer-Reaction\" class=\"headerlink\" title=\"I. Integer Reaction\"></a>I. Integer Reaction</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSQ==\">Problem - I - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意：-3\"><a href=\"#题意：-3\" class=\"headerlink\" title=\"　题意：\"></a>　题意：</h3><p>有一个由 <script type=\"math/tex\">n</script> 个整数组成的序列，从左到右编号为 <script type=\"math/tex\">1</script> 到 <script type=\"math/tex\">n</script> 。这些整数有两种颜色，分别是 <script type=\"math/tex\">0</script> 和 <script type=\"math/tex\">1</script> ，每个整数正好有一种颜色。这些整数按照从 <script type=\"math/tex\">1</script>到 <script type=\"math/tex\">n</script> 的编号顺序进入多集合 <script type=\"math/tex\">S_1</script> 。</p>\n<p>每当一个新的整数 <script type=\"math/tex\">x</script> 进入 <script type=\"math/tex\">S_1</script> 时，你必须在 <script type=\"math/tex\">S_1</script> 中选择一个颜色与 <script type=\"math/tex\">x</script> 不同的整数 <script type=\"math/tex\">y</script> 与 <script type=\"math/tex\">x</script> 发生反应，使得 <script type=\"math/tex\">x</script> 和 <script type=\"math/tex\">y</script> 消失，反应产物 <script type=\"math/tex\">x+y</script> 插入另一个集合 <script type=\"math/tex\">S_2</script> 中。如果不存在这样的 <script type=\"math/tex\">y</script> ，则不会发生反应，只有 <script type=\"math/tex\">x</script> 会插入 <script type=\"math/tex\">S_1</script> 。</p>\n<p>给定整数序列和每个整数的颜色，求处理最后一个元素后 <script type=\"math/tex\">S_2</script>​ 中最小元素的最大可能值。</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>很简单，二分答案贪心维护<script type=\"math/tex\">S_1</script>即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ck</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class=\"line\">\tmultiset&lt;<span class=\"type\">int</span>&gt; ms;</span><br><span class=\"line\">\t<span class=\"type\">int</span> c = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(c == a[i].y)&#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ms.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// cout&lt;&lt;x-a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">auto</span> it = <span class=\"built_in\">lower_bound</span>(<span class=\"built_in\">all</span>(ms), x - a[i].x);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(it == ms.<span class=\"built_in\">end</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// if(x==7)cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].x);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].y);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">1</span>,r = INF;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r<span class=\"number\">+1</span> &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">ck</span>(mid)) l = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":1556,"excerpt":"<h2 id=\"江苏CCPC-VP\"><a href=\"#江苏CCPC-VP\" class=\"headerlink\" title=\"江苏CCPC-VP\"></a>江苏CCPC-VP</h2><h2 id=\"F-Download-Speed-Monitor\"><a href=\"#F-Download-Speed-Monitor\" class=\"headerlink\" title=\"F. Download Speed Monitor\"></a>F. Download Speed Monitor</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRg==\">Problem - F - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。</p>\n<p>下载速度监视器的工作原理如下：从 <script type=\"math/tex\">(k-1)$$$ (秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 $$$k</script> (秒)开始，监视器将显示从 <script type=\"math/tex\">(i-k+1)$$$$ (秒)到 $$$$i</script>(秒)再到 <script type=\"math/tex\">i</script> (秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于 <script type=\"math/tex\">1024</script> KiBps 时，下载速度监视器将以 MiBps 为单位显示结果。</p>\n<p>您的下载任务将持续 <script type=\"math/tex\">n</script> 秒。考虑到平均速度的计算间隔为 <script type=\"math/tex\">k</script> ，您想知道从 $k<script type=\"math/tex\">$ (秒)到 $$$$n</script> (秒)，监控器上将显示什么。</p>\n<p>Note: <script type=\"math/tex\">1$$$ MiBps $$$=1024$$$$ KiBps</script>​.</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>签到题，双指针扫一下即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum  = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum += a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j &gt;= k) sum -= a[j ++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j + <span class=\"number\">1</span> &lt; k) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt; &#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">double</span> spd = <span class=\"built_in\">double</span>(<span class=\"number\">1.0</span> * sum / k);</span><br><span class=\"line\">\t\tstring ad = <span class=\"string\">&quot;KiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(spd &gt;= <span class=\"number\">1024</span>) spd /= <span class=\"number\">1024</span>, ad = <span class=\"string\">&quot;MiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.6lf&quot;</span>, spd);</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ad&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"G-Download-Time-Monitor\"><a href=\"#G-Download-Time-Monitor\" class=\"headerlink\" title=\"G. Download Time Monitor\"></a>G. Download Time Monitor</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRw==\">Problem - G - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意：-1\"><a href=\"#题意：-1\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。</p>\n<p>您使用的网络带宽为 <script type=\"math/tex\">B</script> MiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 $t_1$ 秒，大小为 <script type=\"math/tex\">a_1</script> MiB，而第二个文件开始下载的时间为 <script type=\"math/tex\">t_2</script> 秒，大小为 <script type=\"math/tex\">a_2</script> MiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在 <script type=\"math/tex\">B</script> MiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 <script type=\"math/tex\">\\frac{B}{2}</script> MiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。</p>\n<p>现在，您想知道两个文件完成下载各需要多长时间。</p>\n<h3 id=\"题解：-1\"><a href=\"#题解：-1\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）</p>\n<p>这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。</p>\n<p>注意是下载花费时间而不是总时间</p>\n<p>这题浮点运算常数较大，开O2和解同步会比较好</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> GCC optimize(2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIO std::ios::sync_with_stdio(false);std::cin.tie(0);</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> B,t1,t2,a1,a2;</span><br><span class=\"line\">\tcin&gt;&gt;B&gt;&gt;t1&gt;&gt;a1&gt;&gt;t2&gt;&gt;a2;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t1 &gt; t2)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(t1,t2);<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\tf=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">double</span> d = t2-t1;</span><br><span class=\"line\">\t<span class=\"type\">double</span> a,b;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(d * B &gt; a1)&#123;</span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / B;</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a2 / B;</span><br><span class=\"line\">\t\td=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\ta1 -= d * B;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a1 &gt; a2) f^= <span class=\"number\">1</span>,<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;a1&lt;&lt; &#x27; &#x27;&lt;&lt;a2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>) + <span class=\"number\">1.0</span> *(a2 - a1) /B;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,a + d, b);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,b + d,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"K-Number-Deletion-Game\"><a href=\"#K-Number-Deletion-Game\" class=\"headerlink\" title=\"K. Number Deletion Game\"></a>K. Number Deletion Game</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSw==\">Problem - K - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意：-2\"><a href=\"#题意：-2\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>爱丽丝和鲍勃正在玩一个数字删除游戏。</p>\n<p>一开始，有 <script type=\"math/tex\">n$$$ 个整数 $$$a_ 1,a _ 2, \\ldots ,a _n</script> 。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除<strong>大的数字</strong><script type=\"math/tex\">x$$$ ，并选择一个比 $$$x</script>**小的非负整数 <script type=\"math/tex\">y$$$ ，然后在数字 $$$1,2,\\ldots, y$$$ 中各加一个。特别是可以选择 $$$y=0</script> ，在这种情况下不会添加任何数字。也就是说，删除 <script type=\"math/tex\">1</script> 时，不能添加任何数字。删除最后一个数字的人获胜。</p>\n<p>双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。</p>\n<h3 id=\"题解：-2\"><a href=\"#题解：-2\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。</p>\n<p>另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。</p>\n<p>​    那么对于最大值取<script type=\"math/tex\">1 \\to k</script>成立，试证明对k+1成立，分类讨论</p>\n<pre><code>1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\n1. k+1为偶数个，同理，Bob胜\n</code></pre><p>coding</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> num = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i] != a[n]) &#123;</span><br><span class=\"line\">\t\t\tnum = n-i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num == <span class=\"number\">-1</span>) num = n;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;num&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num&amp;<span class=\"number\">1</span>) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"I-Integer-Reaction\"><a href=\"#I-Integer-Reaction\" class=\"headerlink\" title=\"I. Integer Reaction\"></a>I. Integer Reaction</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSQ==\">Problem - I - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意：-3\"><a href=\"#题意：-3\" class=\"headerlink\" title=\"　题意：\"></a>　题意：</h3><p>有一个由 <script type=\"math/tex\">n</script> 个整数组成的序列，从左到右编号为 <script type=\"math/tex\">1</script> 到 <script type=\"math/tex\">n</script> 。这些整数有两种颜色，分别是 <script type=\"math/tex\">0</script> 和 <script type=\"math/tex\">1</script> ，每个整数正好有一种颜色。这些整数按照从 <script type=\"math/tex\">1</script>到 <script type=\"math/tex\">n</script> 的编号顺序进入多集合 <script type=\"math/tex\">S_1</script> 。</p>\n<p>每当一个新的整数 <script type=\"math/tex\">x</script> 进入 <script type=\"math/tex\">S_1</script> 时，你必须在 <script type=\"math/tex\">S_1</script> 中选择一个颜色与 <script type=\"math/tex\">x</script> 不同的整数 <script type=\"math/tex\">y</script> 与 <script type=\"math/tex\">x</script> 发生反应，使得 <script type=\"math/tex\">x</script> 和 <script type=\"math/tex\">y</script> 消失，反应产物 <script type=\"math/tex\">x+y</script> 插入另一个集合 <script type=\"math/tex\">S_2</script> 中。如果不存在这样的 <script type=\"math/tex\">y</script> ，则不会发生反应，只有 <script type=\"math/tex\">x</script> 会插入 <script type=\"math/tex\">S_1</script> 。</p>\n<p>给定整数序列和每个整数的颜色，求处理最后一个元素后 <script type=\"math/tex\">S_2</script>​ 中最小元素的最大可能值。</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>很简单，二分答案贪心维护<script type=\"math/tex\">S_1</script>即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ck</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class=\"line\">\tmultiset&lt;<span class=\"type\">int</span>&gt; ms;</span><br><span class=\"line\">\t<span class=\"type\">int</span> c = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(c == a[i].y)&#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ms.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// cout&lt;&lt;x-a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">auto</span> it = <span class=\"built_in\">lower_bound</span>(<span class=\"built_in\">all</span>(ms), x - a[i].x);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(it == ms.<span class=\"built_in\">end</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// if(x==7)cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].x);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].y);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">1</span>,r = INF;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r<span class=\"number\">+1</span> &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">ck</span>(mid)) l = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"2024湖北省赛VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 湖北省赛VP\n\nhttps://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf\n\n## E. Spicy or Grilled?\n\n### 题意\n\n<!--more-->\n\n由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。\n\n![2aceebec00a61b0864fce9d24f11213aab3fc731](https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png)\n\n在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 $n$ 名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是 $a$ 元。但由于有些人像 Walk Alone 一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 $b$ 美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 $x$ 。\n\n但是，\"独行侠 \"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。\n\n### 题解\n\n我觉得麦当劳不素之霸更好吃，谁赞成，谁反对\n\n```cpp\nvoid slove() {\n\tint n,a,b,x;\n\tcin>>n>>x>>a>>b;\n\n\tcout<<1ll * (n-x) * a + x * b<<endl;\n}\n```\n\n## J. Points on the Number Axis A\n\n### 题意\n\n爱丽丝正在数轴上玩单人游戏。\n\n数轴上有 $n$ 个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是 $x_i$ 和 $x_j$，那么操作后将添加 $\\dfrac{x_i+x_j}{2}$ 。\n\n为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。\n\n现在爱丽丝有一个问题：最后一个点的预期位置在哪里？\n\n可以证明答案可以用 $\\dfrac{p}{q}$ 的形式表示，只需输出 $p\\cdot q^{-1} \\bmod 998,244,353$ 的值即可。\n\n### 题意\n\n其实就是所有点的平均值位置\n\n下面是证明：\n\n现在，假设我们有n个点，它们的坐标是$x_1, x_2, …, x_n$，并且我们已经证明了对于任意的$i$和$j$，点 $x_i$和$x_j$的中点的期望坐标是$\\frac{x_i + x_j}{2}$。那么，对于这$n$个点，我们可以计算它们所有可能中点的平均值：\n$$\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n$$\n\n以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的$x_i$它出现在了中点计算公式中出现了$n-1$次，因此后面的二重求和可以变为:\n$$\n \\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i\n$$\n剩下的就很好理解了。\n\n数学推导对这样的“显然解”证明，有着更好的一套方法：\n\n没能够看懂题解上得公式。。。。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tcout<<sum %MOD * qmi(n,MOD-2) % MOD<<endl;\n}\n```\n\n## A. Long Live\n\n### 题意\n\n在《我的世界》中，简单的世界有三个维度，其中一个维度被称为 \"终结\"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。\n\n![](https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png)\n\n现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下\n\n给定两个正整数 $x$ 和 $y$ ，请找出两个整数 $a$ 和 $b$ ，使得\n\n$$\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}\n$$\n\n并使 $a \\cdot b$ 最大。\n\n这里， $\\gcd(a,b)$ 表示 $a,b$ 的最大公约数，而 $\\rm lcm(a,b)$ 表示 $a,b$ 的最小公倍数。\n\n### 题意\n\n如果你的数学功底很好肯定可以极快的打出这一场的签到\n\n简单的数学带入推到公式得到\n\n$$\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}\n$$\n\n```cpp\nvoid slove() {\n\tint x,y;cin>>x>>y;\n\n\tint gc = gcd(x,y);\n\tint lc = lcm(x,y);\n\tcout<<1<<' '<<lc/gc<<endl;\n}\n```","source":"_posts/2024湖北省赛VP.md","raw":"---\ntitle: 2024湖北省赛VP\ndate: 2024-08-14 19:46:31\ntags: [icpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- icpc省赛\n---\n\n## 湖北省赛VP\n\nhttps://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf\n\n## E. Spicy or Grilled?\n\n### 题意\n\n<!--more-->\n\n由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。\n\n![2aceebec00a61b0864fce9d24f11213aab3fc731](https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png)\n\n在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 $n$ 名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是 $a$ 元。但由于有些人像 Walk Alone 一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 $b$ 美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 $x$ 。\n\n但是，\"独行侠 \"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。\n\n### 题解\n\n我觉得麦当劳不素之霸更好吃，谁赞成，谁反对\n\n```cpp\nvoid slove() {\n\tint n,a,b,x;\n\tcin>>n>>x>>a>>b;\n\n\tcout<<1ll * (n-x) * a + x * b<<endl;\n}\n```\n\n## J. Points on the Number Axis A\n\n### 题意\n\n爱丽丝正在数轴上玩单人游戏。\n\n数轴上有 $n$ 个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是 $x_i$ 和 $x_j$，那么操作后将添加 $\\dfrac{x_i+x_j}{2}$ 。\n\n为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。\n\n现在爱丽丝有一个问题：最后一个点的预期位置在哪里？\n\n可以证明答案可以用 $\\dfrac{p}{q}$ 的形式表示，只需输出 $p\\cdot q^{-1} \\bmod 998,244,353$ 的值即可。\n\n### 题意\n\n其实就是所有点的平均值位置\n\n下面是证明：\n\n现在，假设我们有n个点，它们的坐标是$x_1, x_2, …, x_n$，并且我们已经证明了对于任意的$i$和$j$，点 $x_i$和$x_j$的中点的期望坐标是$\\frac{x_i + x_j}{2}$。那么，对于这$n$个点，我们可以计算它们所有可能中点的平均值：\n$$\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n$$\n\n以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的$x_i$它出现在了中点计算公式中出现了$n-1$次，因此后面的二重求和可以变为:\n$$\n \\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i\n$$\n剩下的就很好理解了。\n\n数学推导对这样的“显然解”证明，有着更好的一套方法：\n\n没能够看懂题解上得公式。。。。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tcout<<sum %MOD * qmi(n,MOD-2) % MOD<<endl;\n}\n```\n\n## A. Long Live\n\n### 题意\n\n在《我的世界》中，简单的世界有三个维度，其中一个维度被称为 \"终结\"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。\n\n![](https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png)\n\n现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下\n\n给定两个正整数 $x$ 和 $y$ ，请找出两个整数 $a$ 和 $b$ ，使得\n\n$$\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}\n$$\n\n并使 $a \\cdot b$ 最大。\n\n这里， $\\gcd(a,b)$ 表示 $a,b$ 的最大公约数，而 $\\rm lcm(a,b)$ 表示 $a,b$ 的最小公倍数。\n\n### 题意\n\n如果你的数学功底很好肯定可以极快的打出这一场的签到\n\n简单的数学带入推到公式得到\n\n$$\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}\n$$\n\n```cpp\nvoid slove() {\n\tint x,y;cin>>x>>y;\n\n\tint gc = gcd(x,y);\n\tint lc = lcm(x,y);\n\tcout<<1<<' '<<lc/gc<<endl;\n}\n```","slug":"2024湖北省赛VP","published":1,"updated":"2024-08-15T04:51:06.767Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9o00072wwv2z3sbqf1","content":"<h2 id=\"湖北省赛VP\"><a href=\"#湖北省赛VP\" class=\"headerlink\" title=\"湖北省赛VP\"></a>湖北省赛VP</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTM5L2F0dGFjaG1lbnRzL2Rvd25sb2FkLzI1Mjg3L1NvbF9JQ1BDX2h1YmVpXzI0LnBkZg==\">https://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"E-Spicy-or-Grilled\"><a href=\"#E-Spicy-or-Grilled\" class=\"headerlink\" title=\"E. Spicy or Grilled?\"></a>E. Spicy or Grilled?</h2><h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><span id=\"more\"></span>\n<p>由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。</p>\n<p><img src=\"https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png\" alt=\"2aceebec00a61b0864fce9d24f11213aab3fc731\"></p>\n<p>在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 $n$ 名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是 $a$ 元。但由于有些人像 Walk Alone 一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 $b$ 美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 $x$ 。</p>\n<p>但是，”独行侠 “太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>我觉得麦当劳不素之霸更好吃，谁赞成，谁反对</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n,a,b,x;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1ll</span> * (n-x) * a + x * b&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"J-Points-on-the-Number-Axis-A\"><a href=\"#J-Points-on-the-Number-Axis-A\" class=\"headerlink\" title=\"J. Points on the Number Axis A\"></a>J. Points on the Number Axis A</h2><h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>爱丽丝正在数轴上玩单人游戏。</p>\n<p>数轴上有 $n$ 个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是 $x_i$ 和 $x_j$，那么操作后将添加 $\\dfrac{x_i+x_j}{2}$ 。</p>\n<p>为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。</p>\n<p>现在爱丽丝有一个问题：最后一个点的预期位置在哪里？</p>\n<p>可以证明答案可以用 $\\dfrac{p}{q}$ 的形式表示，只需输出 $p\\cdot q^{-1} \\bmod 998,244,353$ 的值即可。</p>\n<h3 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>其实就是所有点的平均值位置</p>\n<p>下面是证明：</p>\n<p>现在，假设我们有n个点，它们的坐标是$x_1, x_2, …, x_n$，并且我们已经证明了对于任意的$i$和$j$，点 $x_i$和$x_j$的中点的期望坐标是$\\frac{x_i + x_j}{2}$。那么，对于这$n$个点，我们可以计算它们所有可能中点的平均值：</p>\n<script type=\"math/tex; mode=display\">\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}</script><script type=\"math/tex; mode=display\">\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}</script><script type=\"math/tex; mode=display\">\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i</script><p>以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的$x_i$它出现在了中点计算公式中出现了$n-1$次，因此后面的二重求和可以变为:</p>\n<script type=\"math/tex; mode=display\">\n \\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i</script><p>剩下的就很好理解了。</p>\n<p>数学推导对这样的“显然解”证明，有着更好的一套方法：</p>\n<p>没能够看懂题解上得公式。。。。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum %<span class=\"function\">MOD * <span class=\"title\">qmi</span><span class=\"params\">(n,MOD<span class=\"number\">-2</span>)</span> % MOD&lt;&lt;endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"A-Long-Live\"><a href=\"#A-Long-Live\" class=\"headerlink\" title=\"A. Long Live\"></a>A. Long Live</h2><h3 id=\"题意-3\"><a href=\"#题意-3\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>在《我的世界》中，简单的世界有三个维度，其中一个维度被称为 “终结”。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。</p>\n<p><img src=\"https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png\" alt=\"\"></p>\n<p>现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下</p>\n<p>给定两个正整数 $x$ 和 $y$ ，请找出两个整数 $a$ 和 $b$ ，使得</p>\n<script type=\"math/tex; mode=display\">\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}</script><p>并使 $a \\cdot b$ 最大。</p>\n<p>这里， $\\gcd(a,b)$ 表示 $a,b$ 的最大公约数，而 $\\rm lcm(a,b)$ 表示 $a,b$ 的最小公倍数。</p>\n<h3 id=\"题意-4\"><a href=\"#题意-4\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>如果你的数学功底很好肯定可以极快的打出这一场的签到</p>\n<p>简单的数学带入推到公式得到</p>\n<script type=\"math/tex; mode=display\">\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}</script><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> gc = <span class=\"built_in\">gcd</span>(x,y);</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = <span class=\"built_in\">lcm</span>(x,y);</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;lc/gc&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","length":995,"excerpt":"<h2 id=\"湖北省赛VP\"><a href=\"#湖北省赛VP\" class=\"headerlink\" title=\"湖北省赛VP\"></a>湖北省赛VP</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTM5L2F0dGFjaG1lbnRzL2Rvd25sb2FkLzI1Mjg3L1NvbF9JQ1BDX2h1YmVpXzI0LnBkZg==\">https://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"E-Spicy-or-Grilled\"><a href=\"#E-Spicy-or-Grilled\" class=\"headerlink\" title=\"E. Spicy or Grilled?\"></a>E. Spicy or Grilled?</h2><h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3>","more":"<p>由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。</p>\n<p><img src=\"https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png\" alt=\"2aceebec00a61b0864fce9d24f11213aab3fc731\"></p>\n<p>在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 $n$ 名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是 $a$ 元。但由于有些人像 Walk Alone 一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 $b$ 美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 $x$ 。</p>\n<p>但是，”独行侠 “太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>我觉得麦当劳不素之霸更好吃，谁赞成，谁反对</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n,a,b,x;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1ll</span> * (n-x) * a + x * b&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"J-Points-on-the-Number-Axis-A\"><a href=\"#J-Points-on-the-Number-Axis-A\" class=\"headerlink\" title=\"J. Points on the Number Axis A\"></a>J. Points on the Number Axis A</h2><h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>爱丽丝正在数轴上玩单人游戏。</p>\n<p>数轴上有 $n$ 个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是 $x_i$ 和 $x_j$，那么操作后将添加 $\\dfrac{x_i+x_j}{2}$ 。</p>\n<p>为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。</p>\n<p>现在爱丽丝有一个问题：最后一个点的预期位置在哪里？</p>\n<p>可以证明答案可以用 $\\dfrac{p}{q}$ 的形式表示，只需输出 $p\\cdot q^{-1} \\bmod 998,244,353$ 的值即可。</p>\n<h3 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>其实就是所有点的平均值位置</p>\n<p>下面是证明：</p>\n<p>现在，假设我们有n个点，它们的坐标是$x_1, x_2, …, x_n$，并且我们已经证明了对于任意的$i$和$j$，点 $x_i$和$x_j$的中点的期望坐标是$\\frac{x_i + x_j}{2}$。那么，对于这$n$个点，我们可以计算它们所有可能中点的平均值：</p>\n<script type=\"math/tex; mode=display\">\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}</script><script type=\"math/tex; mode=display\">\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}</script><script type=\"math/tex; mode=display\">\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i</script><p>以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的$x_i$它出现在了中点计算公式中出现了$n-1$次，因此后面的二重求和可以变为:</p>\n<script type=\"math/tex; mode=display\">\n \\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i</script><p>剩下的就很好理解了。</p>\n<p>数学推导对这样的“显然解”证明，有着更好的一套方法：</p>\n<p>没能够看懂题解上得公式。。。。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum %<span class=\"function\">MOD * <span class=\"title\">qmi</span><span class=\"params\">(n,MOD<span class=\"number\">-2</span>)</span> % MOD&lt;&lt;endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"A-Long-Live\"><a href=\"#A-Long-Live\" class=\"headerlink\" title=\"A. Long Live\"></a>A. Long Live</h2><h3 id=\"题意-3\"><a href=\"#题意-3\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>在《我的世界》中，简单的世界有三个维度，其中一个维度被称为 “终结”。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。</p>\n<p><img src=\"https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png\" alt=\"\"></p>\n<p>现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下</p>\n<p>给定两个正整数 $x$ 和 $y$ ，请找出两个整数 $a$ 和 $b$ ，使得</p>\n<script type=\"math/tex; mode=display\">\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}</script><p>并使 $a \\cdot b$ 最大。</p>\n<p>这里， $\\gcd(a,b)$ 表示 $a,b$ 的最大公约数，而 $\\rm lcm(a,b)$ 表示 $a,b$ 的最小公倍数。</p>\n<h3 id=\"题意-4\"><a href=\"#题意-4\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>如果你的数学功底很好肯定可以极快的打出这一场的签到</p>\n<p>简单的数学带入推到公式得到</p>\n<script type=\"math/tex; mode=display\">\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}</script><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> gc = <span class=\"built_in\">gcd</span>(x,y);</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = <span class=\"built_in\">lcm</span>(x,y);</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;lc/gc&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"2024黑龙江省赛-VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## I.[This is an easy problem](https://codeforces.com/gym/105163/problem/I)\n\n超级无敌简单的签到\n\n<!--more-->\n\n```cpp\nvoid slove() {\n\tint x;\n\tcin>>x;\n\tint s = 0;\n\twhile(x) x-=x&-x, s++;\n\tcout<<s<<endl;\n}\n```\n\n##B.[String](https://codeforces.com/gym/105163/problem/B)\n\n### 题意\n\n斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。\n\n### 题解\n\n可以注意到一种典型的\n\n```cpp\naabcccbba\n```\n\n这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列\n\n```cpp\nvoid slove() {\n\tstring s;\n\tcin>>s;\n\tn = s.size();\n\tfor(int i=0;i<n;++i){\n\t\tstk[++top] = s[i];\n\n\t\t// for(int i=1;i<=top;i++) cout<<stk[i];\n\t\t// \tcout<<endl;\n\n\t\tint cc = 0;\n\t\tfor(int j = top;j>=top-2&& j > 0; --j){\n\t\t\tcc++;\n\t\t\tif(stk[j-1] != stk[j]) break;\n\t\t}\n\n\t\tif(cc == 3){\n\t\t\ttop-=3;\n\t\t}\n\t}\n\n\tif(!top) cout<<\"NAN\"<<endl;\n\tfor(int i=1;i<=top;i++) cout<<stk[i];\n\treturn;\n}\n```\n\n## J.[Trade](https://codeforces.com/gym/105163/problem/J)\n\n在一个繁荣的国家，金斯诺决定从事贸易。\n\n这个国家由 $$n*m$$ 座城市组成。每个城市由一对整数 $$(x, y)$$ 表示，其中 $$1\\leq x\\leq n$$ 和 $$1\\leq y\\leq m$$ 表示其在网格中的位置。在城市 $$(x,y)$$ 中，物品的价格用 $$a[x][y]$$ 表示，到达该城市的旅行费用用 $b[x][y]$ 表示。\n\n在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：\n\n- 路线的起点必须是位于第一行第一列的城市，即 $$(1, 1)$$ 。\n- 路线的终点必须是位于最后一行（ $$x = n$$ ）或最后一列（ $y = m$ ）的城市。\n- 金斯诺只能从城市 $$(x_i, y_i)$$ 移动到 $$(x_i+1, y_i)$$ 或 $$(x_i, y_i+1)$$ 。因此，对于路线中的每一步 $i$ （路线中的最后一步除外）， $$(x_{i+1}, y_{i+1})$$ 必须选择在 $$(x_i, y_i)$$ 的正下方或正右方。\n\n进入路线后，Kingsnow 将在路线的第一个城市 $$(1, 1)$$ 购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。\n\n也就是说，对于任何给定的路线 $$(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)$$ ，Kingsnow 都会从区间 $$[2, k]$$ 中任意选择一个整数 $t$ 。他在城市 $(x_t, y_t)$ 出售商品的利润计算公式为 $$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。\n\n### 题解\n\n然我们重新看一看这个式子\n\n$$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n我们把它简单变换一下\n$$\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]\n$$\n简单思考一下，我们似乎并不关心$$a[x_t][y_t]$$每一个的值，只关心他是否大于右边这个值\n\n再看一看$$n,m \\le 1000$$这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。\n\n```cpp\nint dfs(int x,int y){\n\tif(x==n && y == m) return 1;\n\tif(x >n || y> m || (!st[x][y])) return 0;\n\tst[x][y] = 0;\n\n\tif(dfs(x+1,y)) return 1;\n\tif(dfs(x,y+1)) return 1;\n\n\treturn 0;\n}\n\nvoid slove() {\n\tmemset(f,0x3f,sizeof f);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>a[i][j];\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>b[i][j];\n\n\tf[1][0] = f[0] [1] = 0; \n\tfor(int i = 1;i<=n;i++) for(int j=1;j<=m;j++){\n\t\tf[i][j] = min(f[i-1][j] + b[i][j], f[i][j-1] + b[i][j]);\n\t}\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<f[i][j]<<'\\t';\n\t// \tcout<<endl;\n\t// }\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;++j){\n\t\tif(f[i][j] + a[1][1] <= a[i][j]){\n\t\t\tst[i][j]  = 1;\n\t\t}\n\t}\n\n\tst[1][1] = st[n][m] = 1;\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<st[i][j];\n\t// \tcout<<endl;\n\t// }\n\n\tif(dfs(1,1)) puts(\"YES\");\n\telse puts(\"NO\");\n}\n```\n\n## K. [Puzzle](https://codeforces.com/gym/105163/problem/K)\n\n### 题意\n\n24 字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为 24。\n\nNerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。\n\nNerifish 有四张扑克牌，每张牌上的数字都是 $$a,b,c,d(1\\leq a,b,c,d\\leq 13)$$ 。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含 4 个整数和 3 个运算符。\n\nNerifish 想知道他能得到多少结果。\n\n### 题解\n\n简单的计算可得$$2^8 = 256$$\n\n暴力！\n\n```cpp\nvoid dfs(int u,stack<int> s,set<int>& S){\n\tif(u==3) {\n\t\tint ans = 0;\n\t\twhile(s.size()) ans += s.top(),s.pop();\n\t\t// cout<<ans<<endl;\n\t\tS.insert(ans);\n\t\treturn ;\n\t}\n\tif(u==0) s.push(a[u]);\n\tfor(int i=0;i<3;++i){\n\t\tif(i==0) {\n\t\t\ts.push(a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse if(i == 1) {\n\t\t\ts.push(-a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse {\n\t\t\tint t = s.top();s.pop();\n\t\t\ts.push(t * a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t}\n\treturn ;\n}\n\nvoid slove() {\n\tfor(int i=0;i<4;i++) cin>>a[i];\n\n\tsort(a,a+4);\n\n\tset<int> S;\n\tdo{\n\t\t// for(int i=0;i<4;++i) cout<<a[i] << ' ';\n\t\t// \tcout<<endl;\n\t\tstack<int> t;\n\t\tdfs(0,t, S);\n\t}while(next_permutation(a,a+4));\n\n\tcout<<S.size();\n\treturn ;\n}\n```\n\n## D.[Card Game](https://codeforces.com/gym/105163/problem/D)\n\n### 题意\n\n甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做 *hpa* 和 *hpb* 。每个玩家开始时都有 *n* 张牌，分别叫做 $$a_1, a_2... a_n $$和 *b*1, $$b_1,b_2...b_n$$ ，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。\n\n回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。\n\n我们称 A 打出的牌序列为 $$p_1, p_2... p_n $$，称 B 打出的牌序列为 $$q_1, q_2... q_n$$ ，它们是从 1 到 *n* 的排列。如果在 *i* - *th* 回合之前游戏还没有结束，那么在 *i* - *th* 回合，甲会下 *a**p**i* ，乙会下 *b**q**i* 。\n\n现在你知道了 A 和 B 的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。\n\n### 题解\n\n","source":"_posts/2024黑龙江省赛-VP.md","raw":"---\ntitle: 2024黑龙江省赛-VP\ndate: 2024-08-14 19:46:31\ntags: [icpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- icpc省赛\n---\n\n## I.[This is an easy problem](https://codeforces.com/gym/105163/problem/I)\n\n超级无敌简单的签到\n\n<!--more-->\n\n```cpp\nvoid slove() {\n\tint x;\n\tcin>>x;\n\tint s = 0;\n\twhile(x) x-=x&-x, s++;\n\tcout<<s<<endl;\n}\n```\n\n##B.[String](https://codeforces.com/gym/105163/problem/B)\n\n### 题意\n\n斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。\n\n### 题解\n\n可以注意到一种典型的\n\n```cpp\naabcccbba\n```\n\n这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列\n\n```cpp\nvoid slove() {\n\tstring s;\n\tcin>>s;\n\tn = s.size();\n\tfor(int i=0;i<n;++i){\n\t\tstk[++top] = s[i];\n\n\t\t// for(int i=1;i<=top;i++) cout<<stk[i];\n\t\t// \tcout<<endl;\n\n\t\tint cc = 0;\n\t\tfor(int j = top;j>=top-2&& j > 0; --j){\n\t\t\tcc++;\n\t\t\tif(stk[j-1] != stk[j]) break;\n\t\t}\n\n\t\tif(cc == 3){\n\t\t\ttop-=3;\n\t\t}\n\t}\n\n\tif(!top) cout<<\"NAN\"<<endl;\n\tfor(int i=1;i<=top;i++) cout<<stk[i];\n\treturn;\n}\n```\n\n## J.[Trade](https://codeforces.com/gym/105163/problem/J)\n\n在一个繁荣的国家，金斯诺决定从事贸易。\n\n这个国家由 $$n*m$$ 座城市组成。每个城市由一对整数 $$(x, y)$$ 表示，其中 $$1\\leq x\\leq n$$ 和 $$1\\leq y\\leq m$$ 表示其在网格中的位置。在城市 $$(x,y)$$ 中，物品的价格用 $$a[x][y]$$ 表示，到达该城市的旅行费用用 $b[x][y]$ 表示。\n\n在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：\n\n- 路线的起点必须是位于第一行第一列的城市，即 $$(1, 1)$$ 。\n- 路线的终点必须是位于最后一行（ $$x = n$$ ）或最后一列（ $y = m$ ）的城市。\n- 金斯诺只能从城市 $$(x_i, y_i)$$ 移动到 $$(x_i+1, y_i)$$ 或 $$(x_i, y_i+1)$$ 。因此，对于路线中的每一步 $i$ （路线中的最后一步除外）， $$(x_{i+1}, y_{i+1})$$ 必须选择在 $$(x_i, y_i)$$ 的正下方或正右方。\n\n进入路线后，Kingsnow 将在路线的第一个城市 $$(1, 1)$$ 购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。\n\n也就是说，对于任何给定的路线 $$(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)$$ ，Kingsnow 都会从区间 $$[2, k]$$ 中任意选择一个整数 $t$ 。他在城市 $(x_t, y_t)$ 出售商品的利润计算公式为 $$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。\n\n### 题解\n\n然我们重新看一看这个式子\n\n$$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n我们把它简单变换一下\n$$\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]\n$$\n简单思考一下，我们似乎并不关心$$a[x_t][y_t]$$每一个的值，只关心他是否大于右边这个值\n\n再看一看$$n,m \\le 1000$$这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。\n\n```cpp\nint dfs(int x,int y){\n\tif(x==n && y == m) return 1;\n\tif(x >n || y> m || (!st[x][y])) return 0;\n\tst[x][y] = 0;\n\n\tif(dfs(x+1,y)) return 1;\n\tif(dfs(x,y+1)) return 1;\n\n\treturn 0;\n}\n\nvoid slove() {\n\tmemset(f,0x3f,sizeof f);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>a[i][j];\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>b[i][j];\n\n\tf[1][0] = f[0] [1] = 0; \n\tfor(int i = 1;i<=n;i++) for(int j=1;j<=m;j++){\n\t\tf[i][j] = min(f[i-1][j] + b[i][j], f[i][j-1] + b[i][j]);\n\t}\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<f[i][j]<<'\\t';\n\t// \tcout<<endl;\n\t// }\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;++j){\n\t\tif(f[i][j] + a[1][1] <= a[i][j]){\n\t\t\tst[i][j]  = 1;\n\t\t}\n\t}\n\n\tst[1][1] = st[n][m] = 1;\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<st[i][j];\n\t// \tcout<<endl;\n\t// }\n\n\tif(dfs(1,1)) puts(\"YES\");\n\telse puts(\"NO\");\n}\n```\n\n## K. [Puzzle](https://codeforces.com/gym/105163/problem/K)\n\n### 题意\n\n24 字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为 24。\n\nNerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。\n\nNerifish 有四张扑克牌，每张牌上的数字都是 $$a,b,c,d(1\\leq a,b,c,d\\leq 13)$$ 。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含 4 个整数和 3 个运算符。\n\nNerifish 想知道他能得到多少结果。\n\n### 题解\n\n简单的计算可得$$2^8 = 256$$\n\n暴力！\n\n```cpp\nvoid dfs(int u,stack<int> s,set<int>& S){\n\tif(u==3) {\n\t\tint ans = 0;\n\t\twhile(s.size()) ans += s.top(),s.pop();\n\t\t// cout<<ans<<endl;\n\t\tS.insert(ans);\n\t\treturn ;\n\t}\n\tif(u==0) s.push(a[u]);\n\tfor(int i=0;i<3;++i){\n\t\tif(i==0) {\n\t\t\ts.push(a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse if(i == 1) {\n\t\t\ts.push(-a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse {\n\t\t\tint t = s.top();s.pop();\n\t\t\ts.push(t * a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t}\n\treturn ;\n}\n\nvoid slove() {\n\tfor(int i=0;i<4;i++) cin>>a[i];\n\n\tsort(a,a+4);\n\n\tset<int> S;\n\tdo{\n\t\t// for(int i=0;i<4;++i) cout<<a[i] << ' ';\n\t\t// \tcout<<endl;\n\t\tstack<int> t;\n\t\tdfs(0,t, S);\n\t}while(next_permutation(a,a+4));\n\n\tcout<<S.size();\n\treturn ;\n}\n```\n\n## D.[Card Game](https://codeforces.com/gym/105163/problem/D)\n\n### 题意\n\n甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做 *hpa* 和 *hpb* 。每个玩家开始时都有 *n* 张牌，分别叫做 $$a_1, a_2... a_n $$和 *b*1, $$b_1,b_2...b_n$$ ，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。\n\n回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。\n\n我们称 A 打出的牌序列为 $$p_1, p_2... p_n $$，称 B 打出的牌序列为 $$q_1, q_2... q_n$$ ，它们是从 1 到 *n* 的排列。如果在 *i* - *th* 回合之前游戏还没有结束，那么在 *i* - *th* 回合，甲会下 *a**p**i* ，乙会下 *b**q**i* 。\n\n现在你知道了 A 和 B 的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。\n\n### 题解\n\n","slug":"2024黑龙江省赛-VP","published":1,"updated":"2024-08-15T04:51:22.977Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9p00092wwv8bw92d9u","content":"<h2 id=\"I-This-is-an-easy-problem\"><a href=\"#I-This-is-an-easy-problem\" class=\"headerlink\" title=\"I.This is an easy problem\"></a>I.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSQ==\">This is an easy problem<i class=\"fa fa-external-link-alt\"></i></span></h2><p>超级无敌简单的签到</p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\tcin&gt;&gt;x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(x) x-=x&amp;-x, s++;</span><br><span class=\"line\">\tcout&lt;&lt;s&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"B-String\"><a href=\"#B-String\" class=\"headerlink\" title=\"B.String\"></a>B.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vQg==\">String<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>可以注意到一种典型的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aabcccbba</span><br></pre></td></tr></table></figure>\n<p>这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;</span><br><span class=\"line\">\tcin&gt;&gt;s;</span><br><span class=\"line\">\tn = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">\t\tstk[++top] = s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=1;i&lt;=top;i++) cout&lt;&lt;stk[i];</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cc = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = top;j&gt;=top<span class=\"number\">-2</span>&amp;&amp; j &gt; <span class=\"number\">0</span>; --j)&#123;</span><br><span class=\"line\">\t\t\tcc++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stk[j<span class=\"number\">-1</span>] != stk[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cc == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\ttop-=<span class=\"number\">3</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!top) cout&lt;&lt;<span class=\"string\">&quot;NAN&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=top;i++) cout&lt;&lt;stk[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"J-Trade\"><a href=\"#J-Trade\" class=\"headerlink\" title=\"J.Trade\"></a>J.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSg==\">Trade<i class=\"fa fa-external-link-alt\"></i></span></h2><p>在一个繁荣的国家，金斯诺决定从事贸易。</p>\n<p>这个国家由 <script type=\"math/tex\">n*m</script> 座城市组成。每个城市由一对整数 <script type=\"math/tex\">(x, y)</script> 表示，其中 <script type=\"math/tex\">1\\leq x\\leq n</script> 和 <script type=\"math/tex\">1\\leq y\\leq m</script> 表示其在网格中的位置。在城市 <script type=\"math/tex\">(x,y)</script> 中，物品的价格用 <script type=\"math/tex\">a[x][y]</script> 表示，到达该城市的旅行费用用 $b[x][y]$ 表示。</p>\n<p>在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：</p>\n<ul>\n<li>路线的起点必须是位于第一行第一列的城市，即 <script type=\"math/tex\">(1, 1)</script> 。</li>\n<li>路线的终点必须是位于最后一行（ <script type=\"math/tex\">x = n</script> ）或最后一列（ $y = m$ ）的城市。</li>\n<li>金斯诺只能从城市 <script type=\"math/tex\">(x_i, y_i)</script> 移动到 <script type=\"math/tex\">(x_i+1, y_i)</script> 或 <script type=\"math/tex\">(x_i, y_i+1)</script> 。因此，对于路线中的每一步 $i$ （路线中的最后一步除外）， <script type=\"math/tex\">(x_{i+1}, y_{i+1})</script> 必须选择在 <script type=\"math/tex\">(x_i, y_i)</script> 的正下方或正右方。</li>\n</ul>\n<p>进入路线后，Kingsnow 将在路线的第一个城市 <script type=\"math/tex\">(1, 1)</script> 购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。</p>\n<p>也就是说，对于任何给定的路线 <script type=\"math/tex\">(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)</script> ，Kingsnow 都会从区间 <script type=\"math/tex\">[2, k]</script> 中任意选择一个整数 $t$ 。他在城市 $(x<em>t, y_t)$ 出售商品的利润计算公式为 $$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum</em>{i=1}^t b[x_i][y_i]$$</p>\n<p>金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>然我们重新看一看这个式子</p>\n<script type=\"math/tex; mode=display\">\\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]</script><p>我们把它简单变换一下</p>\n<script type=\"math/tex; mode=display\">\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]</script><p>简单思考一下，我们似乎并不关心<script type=\"math/tex\">a[x_t][y_t]</script>每一个的值，只关心他是否大于右边这个值</p>\n<p>再看一看<script type=\"math/tex\">n,m \\le 1000</script>这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x==n &amp;&amp; y == m) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt;n || y&gt; m || (!st[x][y])) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tst[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>,y)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x,y<span class=\"number\">+1</span>)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;b[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\tf[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = f[<span class=\"number\">0</span>] [<span class=\"number\">1</span>] = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\tf[i][j] = <span class=\"built_in\">min</span>(f[i<span class=\"number\">-1</span>][j] + b[i][j], f[i][j<span class=\"number\">-1</span>] + b[i][j]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;f[i][j]&lt;&lt;&#x27;\\t&#x27;;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i][j] + a[<span class=\"number\">1</span>][<span class=\"number\">1</span>] &lt;= a[i][j])&#123;</span><br><span class=\"line\">\t\t\tst[i][j]  = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tst[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = st[n][m] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;st[i][j];</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>)) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"K-Puzzle\"><a href=\"#K-Puzzle\" class=\"headerlink\" title=\"K. Puzzle\"></a>K. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSw==\">Puzzle<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>24 字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为 24。</p>\n<p>Nerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。</p>\n<p>Nerifish 有四张扑克牌，每张牌上的数字都是 <script type=\"math/tex\">a,b,c,d(1\\leq a,b,c,d\\leq 13)</script> 。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含 4 个整数和 3 个运算符。</p>\n<p>Nerifish 想知道他能得到多少结果。</p>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>简单的计算可得<script type=\"math/tex\">2^8 = 256</script></p>\n<p>暴力！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,stack&lt;<span class=\"type\">int</span>&gt; s,set&lt;<span class=\"type\">int</span>&gt;&amp; S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(s.<span class=\"built_in\">size</span>()) ans += s.<span class=\"built_in\">top</span>(),s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tS.<span class=\"built_in\">insert</span>(ans);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">0</span>) s.<span class=\"built_in\">push</span>(a[u]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(-a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = s.<span class=\"built_in\">top</span>();s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(t * a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a,a<span class=\"number\">+4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tset&lt;<span class=\"type\">int</span>&gt; S;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=0;i&lt;4;++i) cout&lt;&lt;a[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tstack&lt;<span class=\"type\">int</span>&gt; t;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,t, S);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(a,a<span class=\"number\">+4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;S.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"D-Card-Game\"><a href=\"#D-Card-Game\" class=\"headerlink\" title=\"D.Card Game\"></a>D.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vRA==\">Card Game<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做 <em>hpa</em> 和 <em>hpb</em> 。每个玩家开始时都有 <em>n</em> 张牌，分别叫做 <script type=\"math/tex\">a_1, a_2... a_n</script>和 <em>b</em>1, <script type=\"math/tex\">b_1,b_2...b_n</script> ，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。</p>\n<p>回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。</p>\n<p>我们称 A 打出的牌序列为 <script type=\"math/tex\">p_1, p_2... p_n</script>，称 B 打出的牌序列为 <script type=\"math/tex\">q_1, q_2... q_n</script> ，它们是从 1 到 <em>n</em> 的排列。如果在 <em>i</em> - <em>th</em> 回合之前游戏还没有结束，那么在 <em>i</em> - <em>th</em> 回合，甲会下 <em>a<strong>p</strong>i</em> ，乙会下 <em>b<strong>q</strong>i</em> 。</p>\n<p>现在你知道了 A 和 B 的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。</p>\n<h3 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h3>","length":1796,"excerpt":"<h2 id=\"I-This-is-an-easy-problem\"><a href=\"#I-This-is-an-easy-problem\" class=\"headerlink\" title=\"I.This is an easy problem\"></a>I.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSQ==\">This is an easy problem<i class=\"fa fa-external-link-alt\"></i></span></h2><p>超级无敌简单的签到</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\tcin&gt;&gt;x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(x) x-=x&amp;-x, s++;</span><br><span class=\"line\">\tcout&lt;&lt;s&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"B-String\"><a href=\"#B-String\" class=\"headerlink\" title=\"B.String\"></a>B.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vQg==\">String<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>可以注意到一种典型的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aabcccbba</span><br></pre></td></tr></table></figure>\n<p>这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;</span><br><span class=\"line\">\tcin&gt;&gt;s;</span><br><span class=\"line\">\tn = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">\t\tstk[++top] = s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=1;i&lt;=top;i++) cout&lt;&lt;stk[i];</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cc = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = top;j&gt;=top<span class=\"number\">-2</span>&amp;&amp; j &gt; <span class=\"number\">0</span>; --j)&#123;</span><br><span class=\"line\">\t\t\tcc++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stk[j<span class=\"number\">-1</span>] != stk[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cc == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\ttop-=<span class=\"number\">3</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!top) cout&lt;&lt;<span class=\"string\">&quot;NAN&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=top;i++) cout&lt;&lt;stk[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"J-Trade\"><a href=\"#J-Trade\" class=\"headerlink\" title=\"J.Trade\"></a>J.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSg==\">Trade<i class=\"fa fa-external-link-alt\"></i></span></h2><p>在一个繁荣的国家，金斯诺决定从事贸易。</p>\n<p>这个国家由 <script type=\"math/tex\">n*m</script> 座城市组成。每个城市由一对整数 <script type=\"math/tex\">(x, y)</script> 表示，其中 <script type=\"math/tex\">1\\leq x\\leq n</script> 和 <script type=\"math/tex\">1\\leq y\\leq m</script> 表示其在网格中的位置。在城市 <script type=\"math/tex\">(x,y)</script> 中，物品的价格用 <script type=\"math/tex\">a[x][y]</script> 表示，到达该城市的旅行费用用 $b[x][y]$ 表示。</p>\n<p>在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：</p>\n<ul>\n<li>路线的起点必须是位于第一行第一列的城市，即 <script type=\"math/tex\">(1, 1)</script> 。</li>\n<li>路线的终点必须是位于最后一行（ <script type=\"math/tex\">x = n</script> ）或最后一列（ $y = m$ ）的城市。</li>\n<li>金斯诺只能从城市 <script type=\"math/tex\">(x_i, y_i)</script> 移动到 <script type=\"math/tex\">(x_i+1, y_i)</script> 或 <script type=\"math/tex\">(x_i, y_i+1)</script> 。因此，对于路线中的每一步 $i$ （路线中的最后一步除外）， <script type=\"math/tex\">(x_{i+1}, y_{i+1})</script> 必须选择在 <script type=\"math/tex\">(x_i, y_i)</script> 的正下方或正右方。</li>\n</ul>\n<p>进入路线后，Kingsnow 将在路线的第一个城市 <script type=\"math/tex\">(1, 1)</script> 购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。</p>\n<p>也就是说，对于任何给定的路线 <script type=\"math/tex\">(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)</script> ，Kingsnow 都会从区间 <script type=\"math/tex\">[2, k]</script> 中任意选择一个整数 $t$ 。他在城市 $(x<em>t, y_t)$ 出售商品的利润计算公式为 $$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum</em>{i=1}^t b[x_i][y_i]$$</p>\n<p>金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>然我们重新看一看这个式子</p>\n<script type=\"math/tex; mode=display\">\\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]</script><p>我们把它简单变换一下</p>\n<script type=\"math/tex; mode=display\">\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]</script><p>简单思考一下，我们似乎并不关心<script type=\"math/tex\">a[x_t][y_t]</script>每一个的值，只关心他是否大于右边这个值</p>\n<p>再看一看<script type=\"math/tex\">n,m \\le 1000</script>这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x==n &amp;&amp; y == m) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt;n || y&gt; m || (!st[x][y])) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tst[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>,y)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x,y<span class=\"number\">+1</span>)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;b[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\tf[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = f[<span class=\"number\">0</span>] [<span class=\"number\">1</span>] = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\tf[i][j] = <span class=\"built_in\">min</span>(f[i<span class=\"number\">-1</span>][j] + b[i][j], f[i][j<span class=\"number\">-1</span>] + b[i][j]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;f[i][j]&lt;&lt;&#x27;\\t&#x27;;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i][j] + a[<span class=\"number\">1</span>][<span class=\"number\">1</span>] &lt;= a[i][j])&#123;</span><br><span class=\"line\">\t\t\tst[i][j]  = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tst[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = st[n][m] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;st[i][j];</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>)) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"K-Puzzle\"><a href=\"#K-Puzzle\" class=\"headerlink\" title=\"K. Puzzle\"></a>K. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSw==\">Puzzle<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>24 字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为 24。</p>\n<p>Nerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。</p>\n<p>Nerifish 有四张扑克牌，每张牌上的数字都是 <script type=\"math/tex\">a,b,c,d(1\\leq a,b,c,d\\leq 13)</script> 。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含 4 个整数和 3 个运算符。</p>\n<p>Nerifish 想知道他能得到多少结果。</p>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>简单的计算可得<script type=\"math/tex\">2^8 = 256</script></p>\n<p>暴力！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,stack&lt;<span class=\"type\">int</span>&gt; s,set&lt;<span class=\"type\">int</span>&gt;&amp; S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(s.<span class=\"built_in\">size</span>()) ans += s.<span class=\"built_in\">top</span>(),s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tS.<span class=\"built_in\">insert</span>(ans);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">0</span>) s.<span class=\"built_in\">push</span>(a[u]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(-a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = s.<span class=\"built_in\">top</span>();s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(t * a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a,a<span class=\"number\">+4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tset&lt;<span class=\"type\">int</span>&gt; S;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=0;i&lt;4;++i) cout&lt;&lt;a[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tstack&lt;<span class=\"type\">int</span>&gt; t;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,t, S);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(a,a<span class=\"number\">+4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;S.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"D-Card-Game\"><a href=\"#D-Card-Game\" class=\"headerlink\" title=\"D.Card Game\"></a>D.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vRA==\">Card Game<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做 <em>hpa</em> 和 <em>hpb</em> 。每个玩家开始时都有 <em>n</em> 张牌，分别叫做 <script type=\"math/tex\">a_1, a_2... a_n</script>和 <em>b</em>1, <script type=\"math/tex\">b_1,b_2...b_n</script> ，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。</p>\n<p>回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。</p>\n<p>我们称 A 打出的牌序列为 <script type=\"math/tex\">p_1, p_2... p_n</script>，称 B 打出的牌序列为 <script type=\"math/tex\">q_1, q_2... q_n</script> ，它们是从 1 到 <em>n</em> 的排列。如果在 <em>i</em> - <em>th</em> 回合之前游戏还没有结束，那么在 <em>i</em> - <em>th</em> 回合，甲会下 <em>a<strong>p</strong>i</em> ，乙会下 <em>b<strong>q</strong>i</em> 。</p>\n<p>现在你知道了 A 和 B 的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。</p>\n<h3 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h3>"},{"title":"Latex宏包pgfplots做矩形函数图像","date":"2024-08-14T11:47:58.000Z","_content":"持续更新遇到的问题，完结或不再使用该包将删除这句话\n\n## pgfplots\n\nPgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。\n\n<!--more-->\n\n### 实例一、通过函数方程绘制函数图像\n\n```latex\n%Ex1:f(x)=exp(x)\n\\begin{tikzpicture}\n\\begin{axis}\n\\addplot[color=red]{exp(x)};\n\\end{axis}\n\\end{tikzpicture}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png)\n\n其中绘制图像的语法如下：\n\n```latex\n\\addplot[option] {expression of 2D function};\n```\n\n在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 **;** 结尾。\n\n### 实例二、坐标系的绘制以及3d函数图像\n\n```latex\n\\documentclass{ctexart}\n\\pagestyle{empty}\n\\usepackage{pgfplots}\n\\begin{document}\n%Ex2: put the 2D plot and the 3D plot together\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot[color=red]{exp(x)};\n\t\\end{axis}\n\\end{tikzpicture}\n%Here ends the furst 2D plot\n\n\\hskip 10pt\n\n%Here begins the 3d plot\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot3[\n\t\tsurf,\n\t\t]\n\t\t{exp(-x^2-y^2)*x};\n\t\\end{axis}\n\\end{tikzpicture}\n\\end{document}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png)\n\n```latex\n\\addplot3[\n    surf,\n]\n{exp(-x^2-y^2)*x};\n```\n\n注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。\n\n可以看到对多个图像只需要设定多个tikzpicture作用域即可\n\n#### 坐标系图像中的常用命令、参数与特性\n\n- xlabel、ylabel：设定x,y坐标轴上的标志。\n- 多个addplot可在同一个图中多次作图\n- $$\\tt{domian = a:b}$$设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；\n- $$\\tt{axis\\,\\, lines = left}$$这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；\n- \\addlegendentry{$function（x)$​} 添加函数标签 \n- \\legend 按顺序批量谭家函数标签\n- title在axis中为图像添加标题\n\n### 实例三、数据图\n\n```latex\n%Ex6:plot from data\n\\begin{tikzpicture}\n\t\\begin{axis}[\n\t\ttitle={Temperature dependence of CuSO$_4\\cdot$5H$_2$O solubility},\n\t\txlabel={Temperature [\\textcelsius]},\n\t\tylabel={Solubility [g per 100 g water]},\n\t\txmin=0, xmax=100,\n\t\tymin=0, ymax=120,\n\t\txtick={0,20,40,60,80,100},\n\t\tytick={0,20,40,60,80,100,120},\n\t\tlegend pos=north west,\n\t\tymajorgrids=true,\n\t\tgrid style=dashed,\n\t\t]\n\t\t\n\t\t\\addplot[\n\t\tcolor=blue,\n\t\tmark=square,\n\t\t]\n\t\tcoordinates {\n\t\t\t(0,23.1)\n\t\t\t(10,27.5)\n\t\t\t(20,32)\n\t\t\t(30,37.8)\n\t\t\t(40,44.6)\n\t\t\t(60,61.8)\n\t\t\t(80,83.8)\n\t\t\t(100,114)\n\t\t};\n\t\t\\legend{CuSO$_4\\cdot$5H$_2$O}\n\t\t\n\t\\end{axis}\n\\end{tikzpicture}\n```\n\n\n\n#### 数据图像中的常用命令、参数与特性![test-1-crop-1](https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png)\n\n- mark：设定图像点的形状；如square、triangle、x等\n- $$\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}$$​启用/禁用 𝑦,𝑥 轴上**刻度线位置上**的网格线；\n- $$\\tt{xmin=a, xmax=b, ymin=c, ymax=d}$$​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；\n- $$\\tt{coordinates \\{\\}}$$​设定坐标点画折线图\n- \\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图\n\n### 其他图像\n\npgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。\n\n### 导言区的一些设定\n\n```latex\n\\pgfplotsset{width=10cm}\n```\n\n这里指定了每一张图的宽度为10cm\n\n```tex\n\\usepgfplotslibrary{external}\n\\tikzexternalize \n```\n\n由于$$LATEX$$ 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。","source":"_posts/Latex宏包pgfplots做矩形函数图像.md","raw":"---\ntitle: Latex宏包pgfplots做矩形函数图像\ndate: 2024-08-14 19:47:58\ntags: [Latex, 图像处理]\ncategories: \n\t- 软件\n\t- 工具类软件\n---\n持续更新遇到的问题，完结或不再使用该包将删除这句话\n\n## pgfplots\n\nPgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。\n\n<!--more-->\n\n### 实例一、通过函数方程绘制函数图像\n\n```latex\n%Ex1:f(x)=exp(x)\n\\begin{tikzpicture}\n\\begin{axis}\n\\addplot[color=red]{exp(x)};\n\\end{axis}\n\\end{tikzpicture}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png)\n\n其中绘制图像的语法如下：\n\n```latex\n\\addplot[option] {expression of 2D function};\n```\n\n在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 **;** 结尾。\n\n### 实例二、坐标系的绘制以及3d函数图像\n\n```latex\n\\documentclass{ctexart}\n\\pagestyle{empty}\n\\usepackage{pgfplots}\n\\begin{document}\n%Ex2: put the 2D plot and the 3D plot together\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot[color=red]{exp(x)};\n\t\\end{axis}\n\\end{tikzpicture}\n%Here ends the furst 2D plot\n\n\\hskip 10pt\n\n%Here begins the 3d plot\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot3[\n\t\tsurf,\n\t\t]\n\t\t{exp(-x^2-y^2)*x};\n\t\\end{axis}\n\\end{tikzpicture}\n\\end{document}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png)\n\n```latex\n\\addplot3[\n    surf,\n]\n{exp(-x^2-y^2)*x};\n```\n\n注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。\n\n可以看到对多个图像只需要设定多个tikzpicture作用域即可\n\n#### 坐标系图像中的常用命令、参数与特性\n\n- xlabel、ylabel：设定x,y坐标轴上的标志。\n- 多个addplot可在同一个图中多次作图\n- $$\\tt{domian = a:b}$$设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；\n- $$\\tt{axis\\,\\, lines = left}$$这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；\n- \\addlegendentry{$function（x)$​} 添加函数标签 \n- \\legend 按顺序批量谭家函数标签\n- title在axis中为图像添加标题\n\n### 实例三、数据图\n\n```latex\n%Ex6:plot from data\n\\begin{tikzpicture}\n\t\\begin{axis}[\n\t\ttitle={Temperature dependence of CuSO$_4\\cdot$5H$_2$O solubility},\n\t\txlabel={Temperature [\\textcelsius]},\n\t\tylabel={Solubility [g per 100 g water]},\n\t\txmin=0, xmax=100,\n\t\tymin=0, ymax=120,\n\t\txtick={0,20,40,60,80,100},\n\t\tytick={0,20,40,60,80,100,120},\n\t\tlegend pos=north west,\n\t\tymajorgrids=true,\n\t\tgrid style=dashed,\n\t\t]\n\t\t\n\t\t\\addplot[\n\t\tcolor=blue,\n\t\tmark=square,\n\t\t]\n\t\tcoordinates {\n\t\t\t(0,23.1)\n\t\t\t(10,27.5)\n\t\t\t(20,32)\n\t\t\t(30,37.8)\n\t\t\t(40,44.6)\n\t\t\t(60,61.8)\n\t\t\t(80,83.8)\n\t\t\t(100,114)\n\t\t};\n\t\t\\legend{CuSO$_4\\cdot$5H$_2$O}\n\t\t\n\t\\end{axis}\n\\end{tikzpicture}\n```\n\n\n\n#### 数据图像中的常用命令、参数与特性![test-1-crop-1](https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png)\n\n- mark：设定图像点的形状；如square、triangle、x等\n- $$\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}$$​启用/禁用 𝑦,𝑥 轴上**刻度线位置上**的网格线；\n- $$\\tt{xmin=a, xmax=b, ymin=c, ymax=d}$$​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；\n- $$\\tt{coordinates \\{\\}}$$​设定坐标点画折线图\n- \\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图\n\n### 其他图像\n\npgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。\n\n### 导言区的一些设定\n\n```latex\n\\pgfplotsset{width=10cm}\n```\n\n这里指定了每一张图的宽度为10cm\n\n```tex\n\\usepgfplotslibrary{external}\n\\tikzexternalize \n```\n\n由于$$LATEX$$ 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。","slug":"Latex宏包pgfplots做矩形函数图像","published":1,"updated":"2024-08-14T13:38:44.943Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9q000b2wwv6gficzyi","content":"<p>持续更新遇到的问题，完结或不再使用该包将删除这句话</p>\n<h2 id=\"pgfplots\"><a href=\"#pgfplots\" class=\"headerlink\" title=\"pgfplots\"></a>pgfplots</h2><p>Pgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。</p>\n<span id=\"more\"></span>\n<h3 id=\"实例一、通过函数方程绘制函数图像\"><a href=\"#实例一、通过函数方程绘制函数图像\" class=\"headerlink\" title=\"实例一、通过函数方程绘制函数图像\"></a>实例一、通过函数方程绘制函数图像</h3><figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex1:f(x)=exp(x)</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png\" alt=\"test-1-crop-1\"></p>\n<p>其中绘制图像的语法如下：</p>\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>[option] &#123;expression of 2D function&#125;;</span><br></pre></td></tr></table></figure>\n<p>在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 <strong>;</strong> 结尾。</p>\n<h3 id=\"实例二、坐标系的绘制以及3d函数图像\"><a href=\"#实例二、坐标系的绘制以及3d函数图像\" class=\"headerlink\" title=\"实例二、坐标系的绘制以及3d函数图像\"></a>实例二、坐标系的绘制以及3d函数图像</h3><figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\documentclass</span>&#123;ctexart&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\pagestyle</span>&#123;empty&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\usepackage</span>&#123;pgfplots&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;document&#125;</span><br><span class=\"line\"><span class=\"comment\">%Ex2: put the 2D plot and the 3D plot together</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"comment\">%Here ends the furst 2D plot</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">\\hskip</span> 10pt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%Here begins the 3d plot</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">\t\tsurf,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png\" alt=\"test-1-crop-1\"></p>\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">    surf,</span><br><span class=\"line\">]</span><br><span class=\"line\">&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。</p>\n<p>可以看到对多个图像只需要设定多个tikzpicture作用域即可</p>\n<h4 id=\"坐标系图像中的常用命令、参数与特性\"><a href=\"#坐标系图像中的常用命令、参数与特性\" class=\"headerlink\" title=\"坐标系图像中的常用命令、参数与特性\"></a>坐标系图像中的常用命令、参数与特性</h4><ul>\n<li>xlabel、ylabel：设定x,y坐标轴上的标志。</li>\n<li>多个addplot可在同一个图中多次作图</li>\n<li><script type=\"math/tex\">\\tt{domian = a:b}</script>设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；</li>\n<li><script type=\"math/tex\">\\tt{axis\\,\\, lines = left}</script>这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；</li>\n<li>\\addlegendentry{$function（x)$​} 添加函数标签 </li>\n<li>\\legend 按顺序批量谭家函数标签</li>\n<li>title在axis中为图像添加标题</li>\n</ul>\n<h3 id=\"实例三、数据图\"><a href=\"#实例三、数据图\" class=\"headerlink\" title=\"实例三、数据图\"></a>实例三、数据图</h3><figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex6:plot from data</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;[</span><br><span class=\"line\">\t\ttitle=&#123;Temperature dependence of CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O solubility&#125;,</span><br><span class=\"line\">\t\txlabel=&#123;Temperature [<span class=\"keyword\">\\textcelsius</span>]&#125;,</span><br><span class=\"line\">\t\tylabel=&#123;Solubility [g per 100 g water]&#125;,</span><br><span class=\"line\">\t\txmin=0, xmax=100,</span><br><span class=\"line\">\t\tymin=0, ymax=120,</span><br><span class=\"line\">\t\txtick=&#123;0,20,40,60,80,100&#125;,</span><br><span class=\"line\">\t\tytick=&#123;0,20,40,60,80,100,120&#125;,</span><br><span class=\"line\">\t\tlegend pos=north west,</span><br><span class=\"line\">\t\tymajorgrids=true,</span><br><span class=\"line\">\t\tgrid style=dashed,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[</span><br><span class=\"line\">\t\tcolor=blue,</span><br><span class=\"line\">\t\tmark=square,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\tcoordinates &#123;</span><br><span class=\"line\">\t\t\t(0,23.1)</span><br><span class=\"line\">\t\t\t(10,27.5)</span><br><span class=\"line\">\t\t\t(20,32)</span><br><span class=\"line\">\t\t\t(30,37.8)</span><br><span class=\"line\">\t\t\t(40,44.6)</span><br><span class=\"line\">\t\t\t(60,61.8)</span><br><span class=\"line\">\t\t\t(80,83.8)</span><br><span class=\"line\">\t\t\t(100,114)</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\legend</span>&#123;CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"数据图像中的常用命令、参数与特性\"><a href=\"#数据图像中的常用命令、参数与特性\" class=\"headerlink\" title=\"数据图像中的常用命令、参数与特性\"></a>数据图像中的常用命令、参数与特性<img src=\"https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png\" alt=\"test-1-crop-1\"></h4><ul>\n<li>mark：设定图像点的形状；如square、triangle、x等</li>\n<li><script type=\"math/tex\">\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}</script>​启用/禁用 𝑦,𝑥 轴上<strong>刻度线位置上</strong>的网格线；</li>\n<li><script type=\"math/tex\">\\tt{xmin=a, xmax=b, ymin=c, ymax=d}</script>​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；</li>\n<li><script type=\"math/tex\">\\tt{coordinates \\{\\}}</script>​设定坐标点画折线图</li>\n<li>\\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图</li>\n</ul>\n<h3 id=\"其他图像\"><a href=\"#其他图像\" class=\"headerlink\" title=\"其他图像\"></a>其他图像</h3><p>pgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。</p>\n<h3 id=\"导言区的一些设定\"><a href=\"#导言区的一些设定\" class=\"headerlink\" title=\"导言区的一些设定\"></a>导言区的一些设定</h3><figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\pgfplotsset</span>&#123;width=10cm&#125;</span><br></pre></td></tr></table></figure>\n<p>这里指定了每一张图的宽度为10cm</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\usepgfplotslibrary</span>&#123;external&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\tikzexternalize</span> </span><br></pre></td></tr></table></figure>\n<p>由于<script type=\"math/tex\">LATEX</script> 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。</p>\n","length":929,"excerpt":"<p>持续更新遇到的问题，完结或不再使用该包将删除这句话</p>\n<h2 id=\"pgfplots\"><a href=\"#pgfplots\" class=\"headerlink\" title=\"pgfplots\"></a>pgfplots</h2><p>Pgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。</p>","more":"<h3 id=\"实例一、通过函数方程绘制函数图像\"><a href=\"#实例一、通过函数方程绘制函数图像\" class=\"headerlink\" title=\"实例一、通过函数方程绘制函数图像\"></a>实例一、通过函数方程绘制函数图像</h3><figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex1:f(x)=exp(x)</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png\" alt=\"test-1-crop-1\"></p>\n<p>其中绘制图像的语法如下：</p>\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>[option] &#123;expression of 2D function&#125;;</span><br></pre></td></tr></table></figure>\n<p>在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 <strong>;</strong> 结尾。</p>\n<h3 id=\"实例二、坐标系的绘制以及3d函数图像\"><a href=\"#实例二、坐标系的绘制以及3d函数图像\" class=\"headerlink\" title=\"实例二、坐标系的绘制以及3d函数图像\"></a>实例二、坐标系的绘制以及3d函数图像</h3><figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\documentclass</span>&#123;ctexart&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\pagestyle</span>&#123;empty&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\usepackage</span>&#123;pgfplots&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;document&#125;</span><br><span class=\"line\"><span class=\"comment\">%Ex2: put the 2D plot and the 3D plot together</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"comment\">%Here ends the furst 2D plot</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">\\hskip</span> 10pt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%Here begins the 3d plot</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">\t\tsurf,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png\" alt=\"test-1-crop-1\"></p>\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">    surf,</span><br><span class=\"line\">]</span><br><span class=\"line\">&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。</p>\n<p>可以看到对多个图像只需要设定多个tikzpicture作用域即可</p>\n<h4 id=\"坐标系图像中的常用命令、参数与特性\"><a href=\"#坐标系图像中的常用命令、参数与特性\" class=\"headerlink\" title=\"坐标系图像中的常用命令、参数与特性\"></a>坐标系图像中的常用命令、参数与特性</h4><ul>\n<li>xlabel、ylabel：设定x,y坐标轴上的标志。</li>\n<li>多个addplot可在同一个图中多次作图</li>\n<li><script type=\"math/tex\">\\tt{domian = a:b}</script>设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；</li>\n<li><script type=\"math/tex\">\\tt{axis\\,\\, lines = left}</script>这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；</li>\n<li>\\addlegendentry{$function（x)$​} 添加函数标签 </li>\n<li>\\legend 按顺序批量谭家函数标签</li>\n<li>title在axis中为图像添加标题</li>\n</ul>\n<h3 id=\"实例三、数据图\"><a href=\"#实例三、数据图\" class=\"headerlink\" title=\"实例三、数据图\"></a>实例三、数据图</h3><figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex6:plot from data</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;[</span><br><span class=\"line\">\t\ttitle=&#123;Temperature dependence of CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O solubility&#125;,</span><br><span class=\"line\">\t\txlabel=&#123;Temperature [<span class=\"keyword\">\\textcelsius</span>]&#125;,</span><br><span class=\"line\">\t\tylabel=&#123;Solubility [g per 100 g water]&#125;,</span><br><span class=\"line\">\t\txmin=0, xmax=100,</span><br><span class=\"line\">\t\tymin=0, ymax=120,</span><br><span class=\"line\">\t\txtick=&#123;0,20,40,60,80,100&#125;,</span><br><span class=\"line\">\t\tytick=&#123;0,20,40,60,80,100,120&#125;,</span><br><span class=\"line\">\t\tlegend pos=north west,</span><br><span class=\"line\">\t\tymajorgrids=true,</span><br><span class=\"line\">\t\tgrid style=dashed,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[</span><br><span class=\"line\">\t\tcolor=blue,</span><br><span class=\"line\">\t\tmark=square,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\tcoordinates &#123;</span><br><span class=\"line\">\t\t\t(0,23.1)</span><br><span class=\"line\">\t\t\t(10,27.5)</span><br><span class=\"line\">\t\t\t(20,32)</span><br><span class=\"line\">\t\t\t(30,37.8)</span><br><span class=\"line\">\t\t\t(40,44.6)</span><br><span class=\"line\">\t\t\t(60,61.8)</span><br><span class=\"line\">\t\t\t(80,83.8)</span><br><span class=\"line\">\t\t\t(100,114)</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\legend</span>&#123;CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"数据图像中的常用命令、参数与特性\"><a href=\"#数据图像中的常用命令、参数与特性\" class=\"headerlink\" title=\"数据图像中的常用命令、参数与特性\"></a>数据图像中的常用命令、参数与特性<img src=\"https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png\" alt=\"test-1-crop-1\"></h4><ul>\n<li>mark：设定图像点的形状；如square、triangle、x等</li>\n<li><script type=\"math/tex\">\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}</script>​启用/禁用 𝑦,𝑥 轴上<strong>刻度线位置上</strong>的网格线；</li>\n<li><script type=\"math/tex\">\\tt{xmin=a, xmax=b, ymin=c, ymax=d}</script>​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；</li>\n<li><script type=\"math/tex\">\\tt{coordinates \\{\\}}</script>​设定坐标点画折线图</li>\n<li>\\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图</li>\n</ul>\n<h3 id=\"其他图像\"><a href=\"#其他图像\" class=\"headerlink\" title=\"其他图像\"></a>其他图像</h3><p>pgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。</p>\n<h3 id=\"导言区的一些设定\"><a href=\"#导言区的一些设定\" class=\"headerlink\" title=\"导言区的一些设定\"></a>导言区的一些设定</h3><figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\pgfplotsset</span>&#123;width=10cm&#125;</span><br></pre></td></tr></table></figure>\n<p>这里指定了每一张图的宽度为10cm</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\usepgfplotslibrary</span>&#123;external&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\tikzexternalize</span> </span><br></pre></td></tr></table></figure>\n<p>由于<script type=\"math/tex\">LATEX</script> 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。</p>"},{"title":"Miracl的配置ForCentos7","date":"2024-08-14T11:55:03.000Z","_content":"Miracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).\n\nMiracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的\n\n<!--more-->\n\n```cpp\nextern \"C\"\n{\n     #include \"miracl.h\"\n}\n```\n\n实现兼容。\n\n下面是对miracl在c++环境下部署的简单步骤\n\n第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输\n\n`````shell\nwget https://github.com/miracl/MIRACL/archive/master.zip\n`````\n\n第二步、创建一个文件夹用来存放解压文件\n\n```shell\nmkdir miracl\n```\n\n第三步、复制并解压\n\n```shell\ncp master.zip ./miracl\ncd miracl/\nunzip -j -aa -L master.zip\n```\n\n第四步、验证解压并运行linux64（若32位运行linux）\n\n```shell\nls\nbash linux64\nll | grep miracl.a\n```\n\n第五步、运行官方程序\n\n```shell\n./pk-demo\n```\n\n第六步、一般情况下、复制一下文件到你的源代码目录下\n\n````shell\ncp ../miracl/miracl.a miracl.a\ncp ../miracl/miracl.h miracl.h\ncp ../miracl/mirdef.h mirdef.h\n````\n\n完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：\n\n[静态库文件](https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ)","source":"_posts/Miracl的配置ForCentos7.md","raw":"---\ntitle: Miracl的配置ForCentos7\ndate: 2024-08-14 19:55:03\ntags: [信息安全, 软件, Miracl]\ncategories: \n\t- 软件\n\t- 经典库\n\t- 信息安全\n---\nMiracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).\n\nMiracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的\n\n<!--more-->\n\n```cpp\nextern \"C\"\n{\n     #include \"miracl.h\"\n}\n```\n\n实现兼容。\n\n下面是对miracl在c++环境下部署的简单步骤\n\n第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输\n\n`````shell\nwget https://github.com/miracl/MIRACL/archive/master.zip\n`````\n\n第二步、创建一个文件夹用来存放解压文件\n\n```shell\nmkdir miracl\n```\n\n第三步、复制并解压\n\n```shell\ncp master.zip ./miracl\ncd miracl/\nunzip -j -aa -L master.zip\n```\n\n第四步、验证解压并运行linux64（若32位运行linux）\n\n```shell\nls\nbash linux64\nll | grep miracl.a\n```\n\n第五步、运行官方程序\n\n```shell\n./pk-demo\n```\n\n第六步、一般情况下、复制一下文件到你的源代码目录下\n\n````shell\ncp ../miracl/miracl.a miracl.a\ncp ../miracl/miracl.h miracl.h\ncp ../miracl/mirdef.h mirdef.h\n````\n\n完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：\n\n[静态库文件](https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ)","slug":"Miracl的配置ForCentos7","published":1,"updated":"2024-08-14T13:38:48.720Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9s000g2wwv87817lyn","content":"<p>Miracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).</p>\n<p>Miracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的</p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;miracl.h&quot;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现兼容。</p>\n<p>下面是对miracl在c++环境下部署的简单步骤</p>\n<p>第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/miracl/MIRACL/archive/master.zip</span><br></pre></td></tr></table></figure>\n<p>第二步、创建一个文件夹用来存放解压文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir miracl</span><br></pre></td></tr></table></figure>\n<p>第三步、复制并解压</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp master.zip ./miracl</span><br><span class=\"line\">cd miracl/</span><br><span class=\"line\">unzip -j -aa -L master.zip</span><br></pre></td></tr></table></figure>\n<p>第四步、验证解压并运行linux64（若32位运行linux）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">bash linux64</span><br><span class=\"line\">ll | grep miracl.a</span><br></pre></td></tr></table></figure>\n<p>第五步、运行官方程序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./pk-demo</span><br></pre></td></tr></table></figure>\n<p>第六步、一般情况下、复制一下文件到你的源代码目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ../miracl/miracl.a miracl.a</span><br><span class=\"line\">cp ../miracl/miracl.h miracl.h</span><br><span class=\"line\">cp ../miracl/mirdef.h mirdef.h</span><br></pre></td></tr></table></figure>\n<p>完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly8xZHJ2Lm1zL2YvcyFBcC1lblk3Y2tMQU5nb05NSVF5c1hSVlM4TGRHeVE=\">静态库文件<i class=\"fa fa-external-link-alt\"></i></span></p>\n","length":411,"excerpt":"<p>Miracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).</p>\n<p>Miracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;miracl.h&quot;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现兼容。</p>\n<p>下面是对miracl在c++环境下部署的简单步骤</p>\n<p>第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/miracl/MIRACL/archive/master.zip</span><br></pre></td></tr></table></figure>\n<p>第二步、创建一个文件夹用来存放解压文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir miracl</span><br></pre></td></tr></table></figure>\n<p>第三步、复制并解压</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp master.zip ./miracl</span><br><span class=\"line\">cd miracl/</span><br><span class=\"line\">unzip -j -aa -L master.zip</span><br></pre></td></tr></table></figure>\n<p>第四步、验证解压并运行linux64（若32位运行linux）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">bash linux64</span><br><span class=\"line\">ll | grep miracl.a</span><br></pre></td></tr></table></figure>\n<p>第五步、运行官方程序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./pk-demo</span><br></pre></td></tr></table></figure>\n<p>第六步、一般情况下、复制一下文件到你的源代码目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ../miracl/miracl.a miracl.a</span><br><span class=\"line\">cp ../miracl/miracl.h miracl.h</span><br><span class=\"line\">cp ../miracl/mirdef.h mirdef.h</span><br></pre></td></tr></table></figure>\n<p>完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly8xZHJ2Lm1zL2YvcyFBcC1lblk3Y2tMQU5nb05NSVF5c1hSVlM4TGRHeVE=\">静态库文件<i class=\"fa fa-external-link-alt\"></i></span></p>"},{"title":"2024河南CCPC邀请赛-VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 河南CCPC-VP\n\n[Dashboard - 2024 National Invitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate Programming Contest - Codeforces](https://codeforces.com/gym/105158)\n\n## J. [排列与合数](https://codeforces.com/gym/105158/problem/J)\n\n<!--more-->\n\n### 题意：\n\n​\t小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。 与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关 的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的： 给定一个有且仅有5 位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位， 但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′ 能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345 时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以 重新排列数位得到合数n′=97531=7×13933。 一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。 现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？\n\n### 题解：\n\n​\t签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tstring s;cin>>s;\n\t\tsort(all(s));\n\t\tbool flag= 0;\n\t\tdo{\n\t\t\tint t = 0;\n\t\t\tfor(int i=0;i<5;i++)\n\t\t\t\tt = t * 10 + (s[i] - '0');\n\t\t\tif(t <=10000) continue;\n\t\t\tint f = 1;\n\t\t\tfor(int i=2;i*i<=t;i++)\n\t\t\t\tif(t % i == 0){\n\t\t\t\t\tf=0;break;\n\t\t\t\t}\n\t\t\tif(!f) {cout<<t<<endl;flag =1;break;}\n\t\t}while(next_permutation(all(s)));\n\t\tif(!flag) cout<<-1<<endl;\n\t}\n}\n```\n\n## B.[扫雷 1](https://codeforces.com/gym/105158/problem/B)\n\n### 题意：\n\n​\t T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。 具体来说，T0xel 会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫 雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci 枚扫 雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。 现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？\n\n### 题解\n\n注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tc[i] = a[i].x;\n\t\ta[i].y = i;\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint flag = 0;\n\tint now = 0, ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tnow ++;\n\t\twhile(a[flag].y < i) flag++;\n\t\tif(a[flag].y == i){\n\t\t\tans += now / c[i];\n\t\t\tnow = now % c[i];\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F.[优秀字符串](https://codeforces.com/gym/105158/problem/F)\n\n### 题意：\n\n小A认为，一个字符串S是优秀字符串，当且仅当：\n\n- S 的长度|S|恰好为5\n- S 的第三个字符与第五个字符相同\n- S 的前四个字符互不相同。 \n\n例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query 的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue 的前四个字符中u出现了两次。 现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中 优秀字符串的数量\n\n### 题解\n\n签到，不做阐述\n\n```cpp\nvoid slove() {\n\tcin>>n;int cnt = 0;\n\tfor(int i=1;i<=n;i++){\n\tstring s;cin>>s;\n\t\tif(s.size()!=5){\n\t\t\tcontinue;\n\t\t}else {\n\t\t\tset<char> S;\n\t\t\tfor(int i=0;i<4;i++)S.insert(s[i]);\n\n\t\t\tif(S.size()!=4){\n\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\tif(s[2] != s[4]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tcnt ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\n## M. [有效算法](https://codeforces.com/gym/105158/problem/M)\n\n### 题意：\n\n给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：\n\n- 将ai 变成满足|ai−x|≤k×bi 的任意整数x。 \n\n请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。\n\n### 题解：\n\n分情况讨论绝对值，即可得出以下两个不等式组\n$$\na_i \\le x \\le a_i + k * b_i\\\\\na_i - k * b_i \\le x \\le a_i\n$$\n考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数\n\n考虑暴力一下，枚举的mn到mx为x，发现\n$$\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}\n$$\n但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。\n\n转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。\n\n如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。\n\n我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。\n\n注意可能有极端情况$$a_i$$​均相等\n\n神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。\n\n下面是code\n\n```cpp\nint check(int x){\n\tL.clear(),R.clear(),ves.clear();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tL.push_back(a[i].x - x * a[i].y);\n\t\tR.push_back(a[i].x + x * a[i].y);\n\t}\n\t// cout<<mx<<' '<<mn<<endl;\n\tint l = mn, r = mx;\n\tfor(int i =0; i < n; i++){\n\t\t// cout<< L[i]<<endl;\n\t\tl = max(L[i],l);\n\t\tr = min(r,R[i]);\n\t}\n\t// cout<<x<< ' ' <<l<< ' ' <<r<<endl;\n\tif(l<=r) return 1;\n\telse return 0;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tmx=max(a[i].x,mx);\n\t\tmn=min(a[i].x,mn);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].y;\n\t}\n\n\t// for(int i=1;i<=n;i++) cout<<a[i].x<<'-'<<a[i].y<<endl;\n\n\tll l = 0, r = mx-mn;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\t// cout<<mid<<endl;\n\t\tif(check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tcout<<r<<endl;\n}\n\n```\n\n## H.[随机栈](https://codeforces.com/gym/105158/problem/H)\n\n### 题意：\n\n​\tToxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集 S，从一个非空的随机栈 S 中取出一个 元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会 从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有 2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel 正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插 入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合 非空。Toxel 想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增 的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。 由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。\n\n### 题解：\n\n题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。\n\ncode\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nll inv(ll x){return qmi(x,MOD-2);}\n\nvoid init(){}\n\nvoid slove() {\n\tcin>>n;\n\tvector<int> a,ords;\n\tfor(int i=1;i<=(n<<1);i++){\n\t\tint op;\n\t\tcin>>op;\n\t\tif(~op) a.pb(op);\n\t\tords.pb(op);\n\t}\n\tsort(all(a));\n\n\tint flag= 0;\n\tint ans = 1;\n\tfor(auto op : ords){\n\t\tif(op==-1){\n\t\t\t// cout<<cnt[a[flag]]<< ' '<<sum<<endl;\n\t\t\tans *= cnt[a[flag]] * inv(sum) % MOD;\n\t\t\tans %= MOD;\n\t\t\tcnt[a[flag]]--;\n\t\t\tflag++;\n\t\t\tsum--;\n\t\t}else {\n\t\t\tcnt[op] ++;sum ++;\n\t\t}\n\t}\n\n\tcout<<ans % MOD<<endl;\n}\n```\n\n待续。。。。笔者吃饭去了\n\n## L. [Toxel 与 PCPC II](https://codeforces.com/gym/105158/problem/L)\n\n### 题面：\n\n​\t Toxel 正在参加 PCPC（Pokémon Center Programming Contest）比赛。它写的一段代码中有不少 bug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁 定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。 Toxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1 行开始，顺序运行完 第i行后退出。Toxel 可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i 秒。接下来，Toxel 会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修 复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4 秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC 的赛场争分夺秒。请你帮Toxel 计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？\n\n### 题解：\n\n考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d = j - i，则花费差为\n$$\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\ \n\\Delta = (x+1)^4 - x^4 - i - 1\n$$\n注意到$$i+1$$是常数，但对$$(x+1) ^4- x^4$$ 这个值可能随着我们前面先debug一段而减少。\n\n让我们贪心的考虑，存在前缀，如果我们有$$(x+1)^4 - x^4 \\le i+1$$ ，则我们一定会向后拓展吗？如果不扩展，我们首先损失了$$\\Delta$$，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。\n\n实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展\n\n```cpp\nfor(int i=1;i<=m;i++){\n\t\tint s = 1;\n\t\twhile(i < m && a[i] + 1 >= qmi((s+1),4) - qmi(s,4) ){\n\t\t\ts ++;\n\t\t\ti ++;\n\t\t}\n\n\t\tans += (a[i] + qmi(s,4));\n\t\tcout<<i<<' ' <<ans<<nline;\n\t}\n}\n```\n\n该代码在样例\n\n```cpp\n20 20\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n```\n\n计算答案为\n\n```cpp\n224\n```\n\n但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用$$(x+1)^4 - x^4$$去换$$i+1$$的成本量，相同情况下当然希望后面的扩展越多越好，此时$$i$$更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。\n\n但还是wa， 考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp\n\n根据上面的公式，状态表示为\n$$\nf_i 前i个bug修改所需最小代价\n$$\n状态转移表示为\n$$\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) <= a[i-j] + 1 \\&\\& i-j+1 > 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}\n$$\n暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。\n\ncoding。。。\n\n```cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i =1;i<=m;i++) cin>>a[i];\n\n\tmemset(f,0x3f,sizeof f);\n\tf[0] = 0;\n\n\tint ans = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tf[i] = f[i-1] + a[i] + 1;\n\t\t// cout<<\"#\"<<i<< ' ' <<f[i]<<endl; \n\t\tfor(int j=2;qmi(j,4)- qmi(j-1,4) <= a[i-j+1] + 1 && i-j+1 > 0; j++)\n\t\t{\n\n\t\t\tf[i] = min(f[i-j] + qmi(j,4) + a[i],f[i]);\n\t\t\t// cout<<i<<' '<<j<< ' ' << f[i] <<endl;\n\t\t}\n\t}\n\tcout<<f[m]<<endl;\n}\n```\n\n## K. [树上问题](https://codeforces.com/gym/105158/problem/K)\n\n### 题意:\n\n​\t378QAQ 有一棵由 n 个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ 认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其 点权都.不 .小 .于其父亲节点的点权的 1 2。 请你计算出有多少个节点是美丽节点。\n\n### 题解：\n\n​\t若：\n$$\na >= b/2\n$$\n​\t则：\n$$\n2*a >= b \\rightarrow \\{a/2<=b<=2*a\\}\n$$\n​\t即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。\n\n​\t考虑更换顶点对点关系的影响：\n\n1. 原根节点与新的根节点之间一定是父子关系\n2. 更换根节点仅更改了原根到新根路径上的节点的父子关系。\n\n​\t于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。\n\n​\t显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。\n\n​\t一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。\n\ncoding\n\n```cpp\nint tarjan(int u){\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u, istk[u] = 1;\n    for(int v: e[u]){\n        if(!dfn[v]){\n            tarjan(v);\n            low[u] = min(low[u],low[v]);\n        }else if(istk[v]){\n            low[u] = min(low[u],dfn[v]);\n        }\n    }\n\n    if(low[u] == dfn[u]){\n        int p;\n        scou++;\n        do{\n            p = stk[top--];\n            istk[p] = 0;\n            scnt[scou]++;\n            id[p] = scou;\n        }while(p!=u);\n    }\n}\n\nvoid slove() {\n\tcin>>n;\n\n    scou = top = timestamp = 0;\n    for(int i=1;i<=n;i++) e[i].clear(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = 0;\n\n    for(int i=1;i<=n;i++) cin>>w[i];\n\n    for(int i=1;i<=n-1;i++)\n    {\n        int a,b;cin>>a>>b;\n        // cout<<a<<' '<<b<<endl;\n        if(ceil(1.0*w[a]/2) <= w[b] && w[b] <= (w[a] * 2)){\n            // cout<<a<< ' '<<b<<endl;\n            e[a].pb(b);\n            e[b].pb(a);\n        }else {\n            if(w[a] > w[b]) swap(a,b);\n            e[a].pb(b);\n            // cout<<\"###\"<<a<< ' '<< b<<endl;\n        }\n    }\n    // cout<<nline;\n\n    for(int i=1;i<=n;i++) {\n        if(!dfn[i]){\n            tarjan(i);\n        }\n    }\n\n    for(int i=1;i<=scou;i++) din[i] = 0;\n\n    multiset<ull> rcd;\n    for(int i=1;i<=n;i++) {\n        // cout<<\"---\"<<i<< ' ' <<e[i].size()<<endl;\n        for(auto j: e[i]){\n            int a = id[i], b = id[j];\n            // cout<<i<<' ' << a<<endl;\n            // cout<<j<<' ' << b<<endl;\n            if(a != b && !rcd.count(a * 100000 + b)){\n                rcd.insert(a * 100000+b);\n                din[b] ++;\n            }\n        }\n    }\n\n    // for(int i=1;i<=n;i++){\n    //     cout<<id[i]<<' ';\n    // }\n    // cout<<nline;\n\n    // for(int i=1;i<=scou;i++){\n    //     cout<<scnt[i]<<' '<<din[i]<<endl;\n    // }\n    // cout<<endl;\n\n    int cnt =0,ans=0;\n    for(int i=1;i<=scou;i++){\n        if(!din[i] && !ans) ans = scnt[i];\n        else if(!din[i] && ans){\n            cout<<0<<endl;\n            return ;\n        }\n    }\n    cout<<ans<<endl;\n    return ;\n}\n```\n\n\n\n​\t\n","source":"_posts/2024河南CCPC邀请赛-VP.md","raw":"---\ntitle: 2024河南CCPC邀请赛-VP\ndate: 2024-08-14 19:46:31\ntags: [ccpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- ccpc邀请赛\n---\n\n## 河南CCPC-VP\n\n[Dashboard - 2024 National Invitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate Programming Contest - Codeforces](https://codeforces.com/gym/105158)\n\n## J. [排列与合数](https://codeforces.com/gym/105158/problem/J)\n\n<!--more-->\n\n### 题意：\n\n​\t小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。 与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关 的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的： 给定一个有且仅有5 位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位， 但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′ 能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345 时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以 重新排列数位得到合数n′=97531=7×13933。 一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。 现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？\n\n### 题解：\n\n​\t签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tstring s;cin>>s;\n\t\tsort(all(s));\n\t\tbool flag= 0;\n\t\tdo{\n\t\t\tint t = 0;\n\t\t\tfor(int i=0;i<5;i++)\n\t\t\t\tt = t * 10 + (s[i] - '0');\n\t\t\tif(t <=10000) continue;\n\t\t\tint f = 1;\n\t\t\tfor(int i=2;i*i<=t;i++)\n\t\t\t\tif(t % i == 0){\n\t\t\t\t\tf=0;break;\n\t\t\t\t}\n\t\t\tif(!f) {cout<<t<<endl;flag =1;break;}\n\t\t}while(next_permutation(all(s)));\n\t\tif(!flag) cout<<-1<<endl;\n\t}\n}\n```\n\n## B.[扫雷 1](https://codeforces.com/gym/105158/problem/B)\n\n### 题意：\n\n​\t T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。 具体来说，T0xel 会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫 雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci 枚扫 雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。 现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？\n\n### 题解\n\n注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tc[i] = a[i].x;\n\t\ta[i].y = i;\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint flag = 0;\n\tint now = 0, ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tnow ++;\n\t\twhile(a[flag].y < i) flag++;\n\t\tif(a[flag].y == i){\n\t\t\tans += now / c[i];\n\t\t\tnow = now % c[i];\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F.[优秀字符串](https://codeforces.com/gym/105158/problem/F)\n\n### 题意：\n\n小A认为，一个字符串S是优秀字符串，当且仅当：\n\n- S 的长度|S|恰好为5\n- S 的第三个字符与第五个字符相同\n- S 的前四个字符互不相同。 \n\n例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query 的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue 的前四个字符中u出现了两次。 现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中 优秀字符串的数量\n\n### 题解\n\n签到，不做阐述\n\n```cpp\nvoid slove() {\n\tcin>>n;int cnt = 0;\n\tfor(int i=1;i<=n;i++){\n\tstring s;cin>>s;\n\t\tif(s.size()!=5){\n\t\t\tcontinue;\n\t\t}else {\n\t\t\tset<char> S;\n\t\t\tfor(int i=0;i<4;i++)S.insert(s[i]);\n\n\t\t\tif(S.size()!=4){\n\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\tif(s[2] != s[4]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tcnt ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\n## M. [有效算法](https://codeforces.com/gym/105158/problem/M)\n\n### 题意：\n\n给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：\n\n- 将ai 变成满足|ai−x|≤k×bi 的任意整数x。 \n\n请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。\n\n### 题解：\n\n分情况讨论绝对值，即可得出以下两个不等式组\n$$\na_i \\le x \\le a_i + k * b_i\\\\\na_i - k * b_i \\le x \\le a_i\n$$\n考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数\n\n考虑暴力一下，枚举的mn到mx为x，发现\n$$\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}\n$$\n但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。\n\n转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。\n\n如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。\n\n我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。\n\n注意可能有极端情况$$a_i$$​均相等\n\n神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。\n\n下面是code\n\n```cpp\nint check(int x){\n\tL.clear(),R.clear(),ves.clear();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tL.push_back(a[i].x - x * a[i].y);\n\t\tR.push_back(a[i].x + x * a[i].y);\n\t}\n\t// cout<<mx<<' '<<mn<<endl;\n\tint l = mn, r = mx;\n\tfor(int i =0; i < n; i++){\n\t\t// cout<< L[i]<<endl;\n\t\tl = max(L[i],l);\n\t\tr = min(r,R[i]);\n\t}\n\t// cout<<x<< ' ' <<l<< ' ' <<r<<endl;\n\tif(l<=r) return 1;\n\telse return 0;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tmx=max(a[i].x,mx);\n\t\tmn=min(a[i].x,mn);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].y;\n\t}\n\n\t// for(int i=1;i<=n;i++) cout<<a[i].x<<'-'<<a[i].y<<endl;\n\n\tll l = 0, r = mx-mn;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\t// cout<<mid<<endl;\n\t\tif(check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tcout<<r<<endl;\n}\n\n```\n\n## H.[随机栈](https://codeforces.com/gym/105158/problem/H)\n\n### 题意：\n\n​\tToxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集 S，从一个非空的随机栈 S 中取出一个 元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会 从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有 2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel 正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插 入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合 非空。Toxel 想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增 的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。 由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。\n\n### 题解：\n\n题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。\n\ncode\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nll inv(ll x){return qmi(x,MOD-2);}\n\nvoid init(){}\n\nvoid slove() {\n\tcin>>n;\n\tvector<int> a,ords;\n\tfor(int i=1;i<=(n<<1);i++){\n\t\tint op;\n\t\tcin>>op;\n\t\tif(~op) a.pb(op);\n\t\tords.pb(op);\n\t}\n\tsort(all(a));\n\n\tint flag= 0;\n\tint ans = 1;\n\tfor(auto op : ords){\n\t\tif(op==-1){\n\t\t\t// cout<<cnt[a[flag]]<< ' '<<sum<<endl;\n\t\t\tans *= cnt[a[flag]] * inv(sum) % MOD;\n\t\t\tans %= MOD;\n\t\t\tcnt[a[flag]]--;\n\t\t\tflag++;\n\t\t\tsum--;\n\t\t}else {\n\t\t\tcnt[op] ++;sum ++;\n\t\t}\n\t}\n\n\tcout<<ans % MOD<<endl;\n}\n```\n\n待续。。。。笔者吃饭去了\n\n## L. [Toxel 与 PCPC II](https://codeforces.com/gym/105158/problem/L)\n\n### 题面：\n\n​\t Toxel 正在参加 PCPC（Pokémon Center Programming Contest）比赛。它写的一段代码中有不少 bug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁 定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。 Toxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1 行开始，顺序运行完 第i行后退出。Toxel 可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i 秒。接下来，Toxel 会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修 复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4 秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC 的赛场争分夺秒。请你帮Toxel 计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？\n\n### 题解：\n\n考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d = j - i，则花费差为\n$$\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\ \n\\Delta = (x+1)^4 - x^4 - i - 1\n$$\n注意到$$i+1$$是常数，但对$$(x+1) ^4- x^4$$ 这个值可能随着我们前面先debug一段而减少。\n\n让我们贪心的考虑，存在前缀，如果我们有$$(x+1)^4 - x^4 \\le i+1$$ ，则我们一定会向后拓展吗？如果不扩展，我们首先损失了$$\\Delta$$，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。\n\n实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展\n\n```cpp\nfor(int i=1;i<=m;i++){\n\t\tint s = 1;\n\t\twhile(i < m && a[i] + 1 >= qmi((s+1),4) - qmi(s,4) ){\n\t\t\ts ++;\n\t\t\ti ++;\n\t\t}\n\n\t\tans += (a[i] + qmi(s,4));\n\t\tcout<<i<<' ' <<ans<<nline;\n\t}\n}\n```\n\n该代码在样例\n\n```cpp\n20 20\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n```\n\n计算答案为\n\n```cpp\n224\n```\n\n但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用$$(x+1)^4 - x^4$$去换$$i+1$$的成本量，相同情况下当然希望后面的扩展越多越好，此时$$i$$更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。\n\n但还是wa， 考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp\n\n根据上面的公式，状态表示为\n$$\nf_i 前i个bug修改所需最小代价\n$$\n状态转移表示为\n$$\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) <= a[i-j] + 1 \\&\\& i-j+1 > 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}\n$$\n暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。\n\ncoding。。。\n\n```cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i =1;i<=m;i++) cin>>a[i];\n\n\tmemset(f,0x3f,sizeof f);\n\tf[0] = 0;\n\n\tint ans = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tf[i] = f[i-1] + a[i] + 1;\n\t\t// cout<<\"#\"<<i<< ' ' <<f[i]<<endl; \n\t\tfor(int j=2;qmi(j,4)- qmi(j-1,4) <= a[i-j+1] + 1 && i-j+1 > 0; j++)\n\t\t{\n\n\t\t\tf[i] = min(f[i-j] + qmi(j,4) + a[i],f[i]);\n\t\t\t// cout<<i<<' '<<j<< ' ' << f[i] <<endl;\n\t\t}\n\t}\n\tcout<<f[m]<<endl;\n}\n```\n\n## K. [树上问题](https://codeforces.com/gym/105158/problem/K)\n\n### 题意:\n\n​\t378QAQ 有一棵由 n 个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ 认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其 点权都.不 .小 .于其父亲节点的点权的 1 2。 请你计算出有多少个节点是美丽节点。\n\n### 题解：\n\n​\t若：\n$$\na >= b/2\n$$\n​\t则：\n$$\n2*a >= b \\rightarrow \\{a/2<=b<=2*a\\}\n$$\n​\t即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。\n\n​\t考虑更换顶点对点关系的影响：\n\n1. 原根节点与新的根节点之间一定是父子关系\n2. 更换根节点仅更改了原根到新根路径上的节点的父子关系。\n\n​\t于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。\n\n​\t显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。\n\n​\t一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。\n\ncoding\n\n```cpp\nint tarjan(int u){\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u, istk[u] = 1;\n    for(int v: e[u]){\n        if(!dfn[v]){\n            tarjan(v);\n            low[u] = min(low[u],low[v]);\n        }else if(istk[v]){\n            low[u] = min(low[u],dfn[v]);\n        }\n    }\n\n    if(low[u] == dfn[u]){\n        int p;\n        scou++;\n        do{\n            p = stk[top--];\n            istk[p] = 0;\n            scnt[scou]++;\n            id[p] = scou;\n        }while(p!=u);\n    }\n}\n\nvoid slove() {\n\tcin>>n;\n\n    scou = top = timestamp = 0;\n    for(int i=1;i<=n;i++) e[i].clear(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = 0;\n\n    for(int i=1;i<=n;i++) cin>>w[i];\n\n    for(int i=1;i<=n-1;i++)\n    {\n        int a,b;cin>>a>>b;\n        // cout<<a<<' '<<b<<endl;\n        if(ceil(1.0*w[a]/2) <= w[b] && w[b] <= (w[a] * 2)){\n            // cout<<a<< ' '<<b<<endl;\n            e[a].pb(b);\n            e[b].pb(a);\n        }else {\n            if(w[a] > w[b]) swap(a,b);\n            e[a].pb(b);\n            // cout<<\"###\"<<a<< ' '<< b<<endl;\n        }\n    }\n    // cout<<nline;\n\n    for(int i=1;i<=n;i++) {\n        if(!dfn[i]){\n            tarjan(i);\n        }\n    }\n\n    for(int i=1;i<=scou;i++) din[i] = 0;\n\n    multiset<ull> rcd;\n    for(int i=1;i<=n;i++) {\n        // cout<<\"---\"<<i<< ' ' <<e[i].size()<<endl;\n        for(auto j: e[i]){\n            int a = id[i], b = id[j];\n            // cout<<i<<' ' << a<<endl;\n            // cout<<j<<' ' << b<<endl;\n            if(a != b && !rcd.count(a * 100000 + b)){\n                rcd.insert(a * 100000+b);\n                din[b] ++;\n            }\n        }\n    }\n\n    // for(int i=1;i<=n;i++){\n    //     cout<<id[i]<<' ';\n    // }\n    // cout<<nline;\n\n    // for(int i=1;i<=scou;i++){\n    //     cout<<scnt[i]<<' '<<din[i]<<endl;\n    // }\n    // cout<<endl;\n\n    int cnt =0,ans=0;\n    for(int i=1;i<=scou;i++){\n        if(!din[i] && !ans) ans = scnt[i];\n        else if(!din[i] && ans){\n            cout<<0<<endl;\n            return ;\n        }\n    }\n    cout<<ans<<endl;\n    return ;\n}\n```\n\n\n\n​\t\n","slug":"2024河南CCPC邀请赛-VP","published":1,"updated":"2024-08-15T04:51:11.832Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9t000i2wwv5p632p1t","content":"<h2 id=\"河南CCPC-VP\"><a href=\"#河南CCPC-VP\" class=\"headerlink\" title=\"河南CCPC-VP\"></a>河南CCPC-VP</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4\">Dashboard - 2024 National Invitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate Programming Contest - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"J-排列与合数\"><a href=\"#J-排列与合数\" class=\"headerlink\" title=\"J. 排列与合数\"></a>J. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSg==\">排列与合数<i class=\"fa fa-external-link-alt\"></i></span></h2><span id=\"more\"></span>\n<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>​    小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。 与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关 的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的： 给定一个有且仅有5 位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位， 但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′ 能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345 时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以 重新排列数位得到合数n′=97531=7×13933。 一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。 现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>​    签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(s));</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)</span><br><span class=\"line\">\t\t\t\tt = t * <span class=\"number\">10</span> + (s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &lt;=<span class=\"number\">10000</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i*i&lt;=t;i++)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(t % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf=<span class=\"number\">0</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;t&lt;&lt;endl;flag =<span class=\"number\">1</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(<span class=\"built_in\">all</span>(s)));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!flag) cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"B-扫雷-1\"><a href=\"#B-扫雷-1\" class=\"headerlink\" title=\"B.扫雷 1\"></a>B.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vQg==\">扫雷 1<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意：-1\"><a href=\"#题意：-1\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>​     T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。 具体来说，T0xel 会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫 雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci 枚扫 雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。 现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tc[i] = a[i].x;</span><br><span class=\"line\">\t\ta[i].y = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tnow ++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(a[flag].y &lt; i) flag++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[flag].y == i)&#123;</span><br><span class=\"line\">\t\t\tans += now / c[i];</span><br><span class=\"line\">\t\t\tnow = now % c[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"F-优秀字符串\"><a href=\"#F-优秀字符串\" class=\"headerlink\" title=\"F.优秀字符串\"></a>F.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vRg==\">优秀字符串<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意：-2\"><a href=\"#题意：-2\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>小A认为，一个字符串S是优秀字符串，当且仅当：</p>\n<ul>\n<li>S 的长度|S|恰好为5</li>\n<li>S 的第三个字符与第五个字符相同</li>\n<li>S 的前四个字符互不相同。 </li>\n</ul>\n<p>例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query 的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue 的前四个字符中u出现了两次。 现在，小A有n个仅包含英文字母与数字的字符串S1,S2,…,Sn，请你帮小A求出这些字符串中 优秀字符串的数量</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>签到，不做阐述</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>()!=<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tset&lt;<span class=\"type\">char</span>&gt; S;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)S.<span class=\"built_in\">insert</span>(s[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(S.<span class=\"built_in\">size</span>()!=<span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(s[<span class=\"number\">2</span>] != s[<span class=\"number\">4</span>])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tcnt ++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"M-有效算法\"><a href=\"#M-有效算法\" class=\"headerlink\" title=\"M. 有效算法\"></a>M. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vTQ==\">有效算法<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意：-3\"><a href=\"#题意：-3\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：</p>\n<ul>\n<li>将ai 变成满足|ai−x|≤k×bi 的任意整数x。 </li>\n</ul>\n<p>请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。</p>\n<h3 id=\"题解：-1\"><a href=\"#题解：-1\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>分情况讨论绝对值，即可得出以下两个不等式组</p>\n<script type=\"math/tex; mode=display\">\na_i \\le x \\le a_i + k * b_i\\\\\na_i - k * b_i \\le x \\le a_i</script><p>考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数</p>\n<p>考虑暴力一下，枚举的mn到mx为x，发现</p>\n<script type=\"math/tex; mode=display\">\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}</script><p>但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。</p>\n<p>转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。</p>\n<p>如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。</p>\n<p>我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。</p>\n<p>注意可能有极端情况<script type=\"math/tex\">a_i</script>​均相等</p>\n<p>神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。</p>\n<p>下面是code</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tL.<span class=\"built_in\">clear</span>(),R.<span class=\"built_in\">clear</span>(),ves.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tL.<span class=\"built_in\">push_back</span>(a[i].x - x * a[i].y);</span><br><span class=\"line\">\t\tR.<span class=\"built_in\">push_back</span>(a[i].x + x * a[i].y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;mn&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = mn, r = mx;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt; L[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tl = <span class=\"built_in\">max</span>(L[i],l);</span><br><span class=\"line\">\t\tr = <span class=\"built_in\">min</span>(r,R[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt; &#x27; &#x27; &lt;&lt;l&lt;&lt; &#x27; &#x27; &lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;=r) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tmx=<span class=\"built_in\">max</span>(a[i].x,mx);</span><br><span class=\"line\">\t\tmn=<span class=\"built_in\">min</span>(a[i].x,mn);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].x&lt;&lt;&#x27;-&#x27;&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tll l = <span class=\"number\">0</span>, r = mx-mn;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(mid)) r = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"H-随机栈\"><a href=\"#H-随机栈\" class=\"headerlink\" title=\"H.随机栈\"></a>H.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSA==\">随机栈<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意：-4\"><a href=\"#题意：-4\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>​    Toxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集 S，从一个非空的随机栈 S 中取出一个 元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会 从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有 2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel 正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插 入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合 非空。Toxel 想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增 的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。 由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。</p>\n<h3 id=\"题解：-2\"><a href=\"#题解：-2\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。</p>\n<p>code</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">inv</span><span class=\"params\">(ll x)</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">qmi</span>(x,MOD<span class=\"number\">-2</span>);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; a,ords;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=(n&lt;&lt;<span class=\"number\">1</span>);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op;</span><br><span class=\"line\">\t\tcin&gt;&gt;op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(~op) a.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t\tords.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(a));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> op : ords)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt[a[flag]]&lt;&lt; &#x27; &#x27;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tans *= cnt[a[flag]] * <span class=\"built_in\">inv</span>(sum) % MOD;</span><br><span class=\"line\">\t\t\tans %= MOD;</span><br><span class=\"line\">\t\t\tcnt[a[flag]]--;</span><br><span class=\"line\">\t\t\tflag++;</span><br><span class=\"line\">\t\t\tsum--;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcnt[op] ++;sum ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>待续。。。。笔者吃饭去了</p>\n<h2 id=\"L-Toxel-与-PCPC-II\"><a href=\"#L-Toxel-与-PCPC-II\" class=\"headerlink\" title=\"L. Toxel 与 PCPC II\"></a>L. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vTA==\">Toxel 与 PCPC II<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>​     Toxel 正在参加 PCPC（Pokémon Center Programming Contest）比赛。它写的一段代码中有不少 bug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁 定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。 Toxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1 行开始，顺序运行完 第i行后退出。Toxel 可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i 秒。接下来，Toxel 会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修 复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4 秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC 的赛场争分夺秒。请你帮Toxel 计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？</p>\n<h3 id=\"题解：-3\"><a href=\"#题解：-3\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d = j - i，则花费差为</p>\n<script type=\"math/tex; mode=display\">\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\ \n\\Delta = (x+1)^4 - x^4 - i - 1</script><p>注意到<script type=\"math/tex\">i+1</script>是常数，但对<script type=\"math/tex\">(x+1) ^4- x^4</script> 这个值可能随着我们前面先debug一段而减少。</p>\n<p>让我们贪心的考虑，存在前缀，如果我们有<script type=\"math/tex\">(x+1)^4 - x^4 \\le i+1</script> ，则我们一定会向后拓展吗？如果不扩展，我们首先损失了<script type=\"math/tex\">\\Delta</script>，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。</p>\n<p>实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> s = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; m &amp;&amp; a[i] + <span class=\"number\">1</span> &gt;= <span class=\"built_in\">qmi</span>((s<span class=\"number\">+1</span>),<span class=\"number\">4</span>) - <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>) )&#123;</span><br><span class=\"line\">\t\t\ts ++;</span><br><span class=\"line\">\t\t\ti ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tans += (a[i] + <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>));</span><br><span class=\"line\">\t\tcout&lt;&lt;i&lt;&lt;<span class=\"string\">&#x27; &#x27;</span> &lt;&lt;ans&lt;&lt;nline;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该代码在样例</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span> <span class=\"number\">20</span></span><br><span class=\"line\"> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">10</span> <span class=\"number\">11</span> <span class=\"number\">12</span> <span class=\"number\">13</span> <span class=\"number\">14</span> <span class=\"number\">15</span> <span class=\"number\">16</span> <span class=\"number\">17</span> <span class=\"number\">18</span> <span class=\"number\">19</span> <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<p>计算答案为</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">224</span></span><br></pre></td></tr></table></figure>\n<p>但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用<script type=\"math/tex\">(x+1)^4 - x^4</script>去换<script type=\"math/tex\">i+1</script>的成本量，相同情况下当然希望后面的扩展越多越好，此时<script type=\"math/tex\">i</script>更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。</p>\n<p>但还是wa， 考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp</p>\n<p>根据上面的公式，状态表示为</p>\n<script type=\"math/tex; mode=display\">\nf_i 前i个bug修改所需最小代价</script><p>状态转移表示为</p>\n<script type=\"math/tex; mode=display\">\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) <= a[i-j] + 1 \\&\\& i-j+1 > 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}</script><p>暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。</p>\n<p>coding。。。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tf[i] = f[i<span class=\"number\">-1</span>] + a[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;f[i]&lt;&lt;endl; </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">2</span>;<span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>)- <span class=\"built_in\">qmi</span>(j<span class=\"number\">-1</span>,<span class=\"number\">4</span>) &lt;= a[i-j<span class=\"number\">+1</span>] + <span class=\"number\">1</span> &amp;&amp; i-j<span class=\"number\">+1</span> &gt; <span class=\"number\">0</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tf[i] = <span class=\"built_in\">min</span>(f[i-j] + <span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>) + a[i],f[i]);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt; f[i] &lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"K-树上问题\"><a href=\"#K-树上问题\" class=\"headerlink\" title=\"K. 树上问题\"></a>K. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSw==\">树上问题<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意:\"></a>题意:</h3><p>​    378QAQ 有一棵由 n 个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ 认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其 点权都.不 .小 .于其父亲节点的点权的 1 2。 请你计算出有多少个节点是美丽节点。</p>\n<h3 id=\"题解：-4\"><a href=\"#题解：-4\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>​    若：</p>\n<script type=\"math/tex; mode=display\">\na >= b/2</script><p>​    则：</p>\n<script type=\"math/tex; mode=display\">\n2*a >= b \\rightarrow \\{a/2<=b<=2*a\\}</script><p>​    即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。</p>\n<p>​    考虑更换顶点对点关系的影响：</p>\n<ol>\n<li>原根节点与新的根节点之间一定是父子关系</li>\n<li>更换根节点仅更改了原根到新根路径上的节点的父子关系。</li>\n</ol>\n<p>​    于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。</p>\n<p>​    显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。</p>\n<p>​    一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。</p>\n<p>coding</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    dfn[u] = low[u] = ++timestamp;</span><br><span class=\"line\">    stk[++top] = u, istk[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[v])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(v);</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(istk[v])&#123;</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low[u] == dfn[u])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p;</span><br><span class=\"line\">        scou++;</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            p = stk[top--];</span><br><span class=\"line\">            istk[p] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            scnt[scou]++;</span><br><span class=\"line\">            id[p] = scou;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(p!=u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    scou = top = timestamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) e[i].<span class=\"built_in\">clear</span>(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;a&lt;&lt;&#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">ceil</span>(<span class=\"number\">1.0</span>*w[a]/<span class=\"number\">2</span>) &lt;= w[b] &amp;&amp; w[b] &lt;= (w[a] * <span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w[a] &gt; w[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[i])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++) din[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    multiset&lt;ull&gt; rcd;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;e[i].size()&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j: e[i])&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = id[i], b = id[j];</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27; &lt;&lt; a&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;j&lt;&lt;&#x27; &#x27; &lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a != b &amp;&amp; !rcd.<span class=\"built_in\">count</span>(a * <span class=\"number\">100000</span> + b))&#123;</span><br><span class=\"line\">                rcd.<span class=\"built_in\">insert</span>(a * <span class=\"number\">100000</span>+b);</span><br><span class=\"line\">                din[b] ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;id[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=scou;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;scnt[i]&lt;&lt;&#x27; &#x27;&lt;&lt;din[i]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> cnt =<span class=\"number\">0</span>,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!din[i] &amp;&amp; !ans) ans = scnt[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!din[i] &amp;&amp; ans)&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​    </p>\n","length":3746,"excerpt":"<h2 id=\"河南CCPC-VP\"><a href=\"#河南CCPC-VP\" class=\"headerlink\" title=\"河南CCPC-VP\"></a>河南CCPC-VP</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4\">Dashboard - 2024 National Invitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate Programming Contest - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"J-排列与合数\"><a href=\"#J-排列与合数\" class=\"headerlink\" title=\"J. 排列与合数\"></a>J. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSg==\">排列与合数<i class=\"fa fa-external-link-alt\"></i></span></h2>","more":"<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>​    小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。 与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关 的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的： 给定一个有且仅有5 位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位， 但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′ 能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345 时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以 重新排列数位得到合数n′=97531=7×13933。 一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。 现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>​    签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(s));</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)</span><br><span class=\"line\">\t\t\t\tt = t * <span class=\"number\">10</span> + (s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &lt;=<span class=\"number\">10000</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i*i&lt;=t;i++)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(t % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf=<span class=\"number\">0</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;t&lt;&lt;endl;flag =<span class=\"number\">1</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(<span class=\"built_in\">all</span>(s)));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!flag) cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"B-扫雷-1\"><a href=\"#B-扫雷-1\" class=\"headerlink\" title=\"B.扫雷 1\"></a>B.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vQg==\">扫雷 1<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意：-1\"><a href=\"#题意：-1\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>​     T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。 具体来说，T0xel 会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫 雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci 枚扫 雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。 现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tc[i] = a[i].x;</span><br><span class=\"line\">\t\ta[i].y = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tnow ++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(a[flag].y &lt; i) flag++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[flag].y == i)&#123;</span><br><span class=\"line\">\t\t\tans += now / c[i];</span><br><span class=\"line\">\t\t\tnow = now % c[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"F-优秀字符串\"><a href=\"#F-优秀字符串\" class=\"headerlink\" title=\"F.优秀字符串\"></a>F.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vRg==\">优秀字符串<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意：-2\"><a href=\"#题意：-2\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>小A认为，一个字符串S是优秀字符串，当且仅当：</p>\n<ul>\n<li>S 的长度|S|恰好为5</li>\n<li>S 的第三个字符与第五个字符相同</li>\n<li>S 的前四个字符互不相同。 </li>\n</ul>\n<p>例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query 的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue 的前四个字符中u出现了两次。 现在，小A有n个仅包含英文字母与数字的字符串S1,S2,…,Sn，请你帮小A求出这些字符串中 优秀字符串的数量</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>签到，不做阐述</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>()!=<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tset&lt;<span class=\"type\">char</span>&gt; S;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)S.<span class=\"built_in\">insert</span>(s[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(S.<span class=\"built_in\">size</span>()!=<span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(s[<span class=\"number\">2</span>] != s[<span class=\"number\">4</span>])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tcnt ++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"M-有效算法\"><a href=\"#M-有效算法\" class=\"headerlink\" title=\"M. 有效算法\"></a>M. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vTQ==\">有效算法<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意：-3\"><a href=\"#题意：-3\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：</p>\n<ul>\n<li>将ai 变成满足|ai−x|≤k×bi 的任意整数x。 </li>\n</ul>\n<p>请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。</p>\n<h3 id=\"题解：-1\"><a href=\"#题解：-1\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>分情况讨论绝对值，即可得出以下两个不等式组</p>\n<script type=\"math/tex; mode=display\">\na_i \\le x \\le a_i + k * b_i\\\\\na_i - k * b_i \\le x \\le a_i</script><p>考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数</p>\n<p>考虑暴力一下，枚举的mn到mx为x，发现</p>\n<script type=\"math/tex; mode=display\">\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}</script><p>但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。</p>\n<p>转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。</p>\n<p>如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。</p>\n<p>我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。</p>\n<p>注意可能有极端情况<script type=\"math/tex\">a_i</script>​均相等</p>\n<p>神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。</p>\n<p>下面是code</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tL.<span class=\"built_in\">clear</span>(),R.<span class=\"built_in\">clear</span>(),ves.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tL.<span class=\"built_in\">push_back</span>(a[i].x - x * a[i].y);</span><br><span class=\"line\">\t\tR.<span class=\"built_in\">push_back</span>(a[i].x + x * a[i].y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;mn&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = mn, r = mx;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt; L[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tl = <span class=\"built_in\">max</span>(L[i],l);</span><br><span class=\"line\">\t\tr = <span class=\"built_in\">min</span>(r,R[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt; &#x27; &#x27; &lt;&lt;l&lt;&lt; &#x27; &#x27; &lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;=r) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tmx=<span class=\"built_in\">max</span>(a[i].x,mx);</span><br><span class=\"line\">\t\tmn=<span class=\"built_in\">min</span>(a[i].x,mn);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].x&lt;&lt;&#x27;-&#x27;&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tll l = <span class=\"number\">0</span>, r = mx-mn;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(mid)) r = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"H-随机栈\"><a href=\"#H-随机栈\" class=\"headerlink\" title=\"H.随机栈\"></a>H.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSA==\">随机栈<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意：-4\"><a href=\"#题意：-4\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>​    Toxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集 S，从一个非空的随机栈 S 中取出一个 元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会 从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有 2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel 正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插 入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合 非空。Toxel 想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增 的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。 由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。</p>\n<h3 id=\"题解：-2\"><a href=\"#题解：-2\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。</p>\n<p>code</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">inv</span><span class=\"params\">(ll x)</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">qmi</span>(x,MOD<span class=\"number\">-2</span>);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; a,ords;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=(n&lt;&lt;<span class=\"number\">1</span>);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op;</span><br><span class=\"line\">\t\tcin&gt;&gt;op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(~op) a.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t\tords.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(a));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> op : ords)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt[a[flag]]&lt;&lt; &#x27; &#x27;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tans *= cnt[a[flag]] * <span class=\"built_in\">inv</span>(sum) % MOD;</span><br><span class=\"line\">\t\t\tans %= MOD;</span><br><span class=\"line\">\t\t\tcnt[a[flag]]--;</span><br><span class=\"line\">\t\t\tflag++;</span><br><span class=\"line\">\t\t\tsum--;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcnt[op] ++;sum ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>待续。。。。笔者吃饭去了</p>\n<h2 id=\"L-Toxel-与-PCPC-II\"><a href=\"#L-Toxel-与-PCPC-II\" class=\"headerlink\" title=\"L. Toxel 与 PCPC II\"></a>L. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vTA==\">Toxel 与 PCPC II<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>​     Toxel 正在参加 PCPC（Pokémon Center Programming Contest）比赛。它写的一段代码中有不少 bug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁 定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。 Toxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1 行开始，顺序运行完 第i行后退出。Toxel 可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i 秒。接下来，Toxel 会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修 复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4 秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC 的赛场争分夺秒。请你帮Toxel 计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？</p>\n<h3 id=\"题解：-3\"><a href=\"#题解：-3\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d = j - i，则花费差为</p>\n<script type=\"math/tex; mode=display\">\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\ \n\\Delta = (x+1)^4 - x^4 - i - 1</script><p>注意到<script type=\"math/tex\">i+1</script>是常数，但对<script type=\"math/tex\">(x+1) ^4- x^4</script> 这个值可能随着我们前面先debug一段而减少。</p>\n<p>让我们贪心的考虑，存在前缀，如果我们有<script type=\"math/tex\">(x+1)^4 - x^4 \\le i+1</script> ，则我们一定会向后拓展吗？如果不扩展，我们首先损失了<script type=\"math/tex\">\\Delta</script>，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。</p>\n<p>实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> s = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; m &amp;&amp; a[i] + <span class=\"number\">1</span> &gt;= <span class=\"built_in\">qmi</span>((s<span class=\"number\">+1</span>),<span class=\"number\">4</span>) - <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>) )&#123;</span><br><span class=\"line\">\t\t\ts ++;</span><br><span class=\"line\">\t\t\ti ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tans += (a[i] + <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>));</span><br><span class=\"line\">\t\tcout&lt;&lt;i&lt;&lt;<span class=\"string\">&#x27; &#x27;</span> &lt;&lt;ans&lt;&lt;nline;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该代码在样例</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span> <span class=\"number\">20</span></span><br><span class=\"line\"> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">10</span> <span class=\"number\">11</span> <span class=\"number\">12</span> <span class=\"number\">13</span> <span class=\"number\">14</span> <span class=\"number\">15</span> <span class=\"number\">16</span> <span class=\"number\">17</span> <span class=\"number\">18</span> <span class=\"number\">19</span> <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<p>计算答案为</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">224</span></span><br></pre></td></tr></table></figure>\n<p>但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用<script type=\"math/tex\">(x+1)^4 - x^4</script>去换<script type=\"math/tex\">i+1</script>的成本量，相同情况下当然希望后面的扩展越多越好，此时<script type=\"math/tex\">i</script>更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。</p>\n<p>但还是wa， 考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp</p>\n<p>根据上面的公式，状态表示为</p>\n<script type=\"math/tex; mode=display\">\nf_i 前i个bug修改所需最小代价</script><p>状态转移表示为</p>\n<script type=\"math/tex; mode=display\">\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) <= a[i-j] + 1 \\&\\& i-j+1 > 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}</script><p>暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。</p>\n<p>coding。。。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tf[i] = f[i<span class=\"number\">-1</span>] + a[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;f[i]&lt;&lt;endl; </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">2</span>;<span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>)- <span class=\"built_in\">qmi</span>(j<span class=\"number\">-1</span>,<span class=\"number\">4</span>) &lt;= a[i-j<span class=\"number\">+1</span>] + <span class=\"number\">1</span> &amp;&amp; i-j<span class=\"number\">+1</span> &gt; <span class=\"number\">0</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tf[i] = <span class=\"built_in\">min</span>(f[i-j] + <span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>) + a[i],f[i]);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt; f[i] &lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"K-树上问题\"><a href=\"#K-树上问题\" class=\"headerlink\" title=\"K. 树上问题\"></a>K. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSw==\">树上问题<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意:\"></a>题意:</h3><p>​    378QAQ 有一棵由 n 个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ 认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其 点权都.不 .小 .于其父亲节点的点权的 1 2。 请你计算出有多少个节点是美丽节点。</p>\n<h3 id=\"题解：-4\"><a href=\"#题解：-4\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>​    若：</p>\n<script type=\"math/tex; mode=display\">\na >= b/2</script><p>​    则：</p>\n<script type=\"math/tex; mode=display\">\n2*a >= b \\rightarrow \\{a/2<=b<=2*a\\}</script><p>​    即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。</p>\n<p>​    考虑更换顶点对点关系的影响：</p>\n<ol>\n<li>原根节点与新的根节点之间一定是父子关系</li>\n<li>更换根节点仅更改了原根到新根路径上的节点的父子关系。</li>\n</ol>\n<p>​    于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。</p>\n<p>​    显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。</p>\n<p>​    一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。</p>\n<p>coding</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    dfn[u] = low[u] = ++timestamp;</span><br><span class=\"line\">    stk[++top] = u, istk[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[v])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(v);</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(istk[v])&#123;</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low[u] == dfn[u])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p;</span><br><span class=\"line\">        scou++;</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            p = stk[top--];</span><br><span class=\"line\">            istk[p] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            scnt[scou]++;</span><br><span class=\"line\">            id[p] = scou;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(p!=u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    scou = top = timestamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) e[i].<span class=\"built_in\">clear</span>(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;a&lt;&lt;&#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">ceil</span>(<span class=\"number\">1.0</span>*w[a]/<span class=\"number\">2</span>) &lt;= w[b] &amp;&amp; w[b] &lt;= (w[a] * <span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w[a] &gt; w[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[i])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++) din[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    multiset&lt;ull&gt; rcd;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;e[i].size()&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j: e[i])&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = id[i], b = id[j];</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27; &lt;&lt; a&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;j&lt;&lt;&#x27; &#x27; &lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a != b &amp;&amp; !rcd.<span class=\"built_in\">count</span>(a * <span class=\"number\">100000</span> + b))&#123;</span><br><span class=\"line\">                rcd.<span class=\"built_in\">insert</span>(a * <span class=\"number\">100000</span>+b);</span><br><span class=\"line\">                din[b] ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;id[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=scou;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;scnt[i]&lt;&lt;&#x27; &#x27;&lt;&lt;din[i]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> cnt =<span class=\"number\">0</span>,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!din[i] &amp;&amp; !ans) ans = scnt[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!din[i] &amp;&amp; ans)&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​    </p>"},{"title":"Nodejs安装简要建议","date":"2024-08-15T02:28:48.000Z","_content":"## NodeJS\n\n### 什么是Nodejs\n\n[Node.js — Run JavaScript Everywhere](https://nodejs.org/)这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。\n\n具体的讲，如下。。\n\n>  Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n\n<!--more-->\n\n### 下载时一步步涉及到的包管理\n\nnvm——Node Version Manager\n\nfnm——Fast Node Manager\n\nnvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm 就没这个问题。并且 Windows 上的 [nvm](https://github.com/nvm-sh/nvm) 与 macOS 上的 [nvm](https://github.com/coreybutler/nvm-windows) 实际上并不是同一个，Windows 的只是借了 nvm 的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm 在三大系统上都是同一个，这保证了 API 的一致性。\n\n下面以fnm为例\n\n### fnm 下载\n\n```\ncurl -fsSL https://fnm.vercel.app/install | bash\n```\n\n如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：\n\n[fnm.zip](https://objects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-streamobjects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-stream)\n\n### NodeJS18版本以上的gcc&make版本要求\n\n要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make install即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。\n\n以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog\n\n[OSError: /lib64/libm.so.6: version `GLIBC_2.27' not found (required by xxx.so) ——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n在make过程中通常涉及\n\n```\nld-linux-x86-64.so.2\\libc.so.6\n```\n\n两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n最后记得设置环境变量，切勿随意删除系统gcc文件。\n\n>  许多blog在configure中设置--profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）\n\n安装NodeJS详细步骤建议参考官方：[Node.js — Download Node.js® (nodejs.org)](https://nodejs.org/en/download/package-manager)\n\n注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素\n\n### NodeJS验证\n\n```\nnode -v\nnpm -v\n```\n\n两条指令均正常即说明程序成功安装\n","source":"_posts/Nodejs安装简要建议.md","raw":"---\ntitle: Nodejs安装简要建议\ndate: 2024-08-15 10:28:48\ntags: [nodejs, gcc, linux]\ncategories: \n\t- 软件\n\t- 经典库\n\t- 前端\n\t- node\n---\n## NodeJS\n\n### 什么是Nodejs\n\n[Node.js — Run JavaScript Everywhere](https://nodejs.org/)这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。\n\n具体的讲，如下。。\n\n>  Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n\n<!--more-->\n\n### 下载时一步步涉及到的包管理\n\nnvm——Node Version Manager\n\nfnm——Fast Node Manager\n\nnvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm 就没这个问题。并且 Windows 上的 [nvm](https://github.com/nvm-sh/nvm) 与 macOS 上的 [nvm](https://github.com/coreybutler/nvm-windows) 实际上并不是同一个，Windows 的只是借了 nvm 的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm 在三大系统上都是同一个，这保证了 API 的一致性。\n\n下面以fnm为例\n\n### fnm 下载\n\n```\ncurl -fsSL https://fnm.vercel.app/install | bash\n```\n\n如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：\n\n[fnm.zip](https://objects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-streamobjects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-stream)\n\n### NodeJS18版本以上的gcc&make版本要求\n\n要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make install即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。\n\n以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog\n\n[OSError: /lib64/libm.so.6: version `GLIBC_2.27' not found (required by xxx.so) ——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n在make过程中通常涉及\n\n```\nld-linux-x86-64.so.2\\libc.so.6\n```\n\n两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n最后记得设置环境变量，切勿随意删除系统gcc文件。\n\n>  许多blog在configure中设置--profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）\n\n安装NodeJS详细步骤建议参考官方：[Node.js — Download Node.js® (nodejs.org)](https://nodejs.org/en/download/package-manager)\n\n注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素\n\n### NodeJS验证\n\n```\nnode -v\nnpm -v\n```\n\n两条指令均正常即说明程序成功安装\n","slug":"Nodejs安装简要建议","published":1,"updated":"2024-08-15T02:41:25.517Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9u000l2wwv2t31e5gs","content":"<h2 id=\"NodeJS\"><a href=\"#NodeJS\" class=\"headerlink\" title=\"NodeJS\"></a>NodeJS</h2><h3 id=\"什么是Nodejs\"><a href=\"#什么是Nodejs\" class=\"headerlink\" title=\"什么是Nodejs\"></a>什么是Nodejs</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnLw==\">Node.js — Run JavaScript Everywhere<i class=\"fa fa-external-link-alt\"></i></span>这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。</p>\n<p>具体的讲，如下。。</p>\n<blockquote>\n<p> Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"下载时一步步涉及到的包管理\"><a href=\"#下载时一步步涉及到的包管理\" class=\"headerlink\" title=\"下载时一步步涉及到的包管理\"></a>下载时一步步涉及到的包管理</h3><p>nvm——Node Version Manager</p>\n<p>fnm——Fast Node Manager</p>\n<p>nvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm 就没这个问题。并且 Windows 上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=\">nvm<i class=\"fa fa-external-link-alt\"></i></span> 与 macOS 上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NvcmV5YnV0bGVyL252bS13aW5kb3dz\">nvm<i class=\"fa fa-external-link-alt\"></i></span> 实际上并不是同一个，Windows 的只是借了 nvm 的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm 在三大系统上都是同一个，这保证了 API 的一致性。</p>\n<p>下面以fnm为例</p>\n<h3 id=\"fnm-下载\"><a href=\"#fnm-下载\" class=\"headerlink\" title=\"fnm 下载\"></a>fnm 下载</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://fnm.vercel.app/install | bash</span><br></pre></td></tr></table></figure>\n<p>如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vYmplY3RzLmdpdGh1YnVzZXJjb250ZW50LmNvbS9naXRodWItcHJvZHVjdGlvbi1yZWxlYXNlLWFzc2V0LTJlNjViZS8xNjYwNDU0MjQvNGMwYTllMmEtOWIyMi00ZWJlLWIwMjYtZGU1ZTc4ZGU5MzUxP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9cmVsZWFzZWFzc2V0cHJvZHVjdGlvbiUyRjIwMjQwNTI5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDUyOVQwODMzMjRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1kNWUxMzc2M2I5NzUwNzI3YmQ0NWIwMTRkMTJhYTdlM2E4OTNmZmUyNzU4MTg5NzEwZDhjMTFkODc0ZWI5ZTY2JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD05MTI3MzE2MSZrZXlfaWQ9MCZyZXBvX2lkPTE2NjA0NTQyNCZyZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0IlMjBmaWxlbmFtZSUzRGZubS1saW51eC56aXAmcmVzcG9uc2UtY29udGVudC10eXBlPWFwcGxpY2F0aW9uJTJGb2N0ZXQtc3RyZWFtb2JqZWN0cy5naXRodWJ1c2VyY29udGVudC5jb20vZ2l0aHViLXByb2R1Y3Rpb24tcmVsZWFzZS1hc3NldC0yZTY1YmUvMTY2MDQ1NDI0LzRjMGE5ZTJhLTliMjItNGViZS1iMDI2LWRlNWU3OGRlOTM1MT9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPXJlbGVhc2Vhc3NldHByb2R1Y3Rpb24lMkYyMDI0MDUyOSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA1MjlUMDgzMzI0WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZDVlMTM3NjNiOTc1MDcyN2JkNDViMDE0ZDEyYWE3ZTNhODkzZmZlMjc1ODE4OTcxMGQ4YzExZDg3NGViOWU2NiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9OTEyNzMxNjEma2V5X2lkPTAmcmVwb19pZD0xNjYwNDU0MjQmcmVzcG9uc2UtY29udGVudC1kaXNwb3NpdGlvbj1hdHRhY2htZW50JTNCJTIwZmlsZW5hbWUlM0Rmbm0tbGludXguemlwJnJlc3BvbnNlLWNvbnRlbnQtdHlwZT1hcHBsaWNhdGlvbiUyRm9jdGV0LXN0cmVhbQ==\">fnm.zip<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"NodeJS18版本以上的gcc-amp-make版本要求\"><a href=\"#NodeJS18版本以上的gcc-amp-make版本要求\" class=\"headerlink\" title=\"NodeJS18版本以上的gcc&amp;make版本要求\"></a>NodeJS18版本以上的gcc&amp;make版本要求</h3><p>要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make install即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。</p>\n<p>以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTk3OTE0NTA/c3BtPWEyYzZoLjEyODczNjM5LmFydGljbGUtZGV0YWlsLjcuNzEzNzY1ZmFadXZTd2g=\">OSError: /lib64/libm.so.6: version `GLIBC_2.27’ not found (required by xxx.so) ——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>在make过程中通常涉及</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld-linux-x86-64.so.2\\libc.so.6</span><br></pre></td></tr></table></figure>\n<p>两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTk3OTE0NTA/c3BtPWEyYzZoLjEyODczNjM5LmFydGljbGUtZGV0YWlsLjcuNzEzNzY1ZmFadXZTd2g=\">https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh<i class=\"fa fa-external-link-alt\"></i></span>)</p>\n<p>最后记得设置环境变量，切勿随意删除系统gcc文件。</p>\n<blockquote>\n<p> 许多blog在configure中设置—profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）</p>\n</blockquote>\n<p>安装NodeJS详细步骤建议参考官方：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL3BhY2thZ2UtbWFuYWdlcg==\">Node.js — Download Node.js® (nodejs.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素</p>\n<h3 id=\"NodeJS验证\"><a href=\"#NodeJS验证\" class=\"headerlink\" title=\"NodeJS验证\"></a>NodeJS验证</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n<p>两条指令均正常即说明程序成功安装</p>\n","length":731,"excerpt":"<h2 id=\"NodeJS\"><a href=\"#NodeJS\" class=\"headerlink\" title=\"NodeJS\"></a>NodeJS</h2><h3 id=\"什么是Nodejs\"><a href=\"#什么是Nodejs\" class=\"headerlink\" title=\"什么是Nodejs\"></a>什么是Nodejs</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnLw==\">Node.js — Run JavaScript Everywhere<i class=\"fa fa-external-link-alt\"></i></span>这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。</p>\n<p>具体的讲，如下。。</p>\n<blockquote>\n<p> Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。</p>\n</blockquote>","more":"<h3 id=\"下载时一步步涉及到的包管理\"><a href=\"#下载时一步步涉及到的包管理\" class=\"headerlink\" title=\"下载时一步步涉及到的包管理\"></a>下载时一步步涉及到的包管理</h3><p>nvm——Node Version Manager</p>\n<p>fnm——Fast Node Manager</p>\n<p>nvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm 就没这个问题。并且 Windows 上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=\">nvm<i class=\"fa fa-external-link-alt\"></i></span> 与 macOS 上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NvcmV5YnV0bGVyL252bS13aW5kb3dz\">nvm<i class=\"fa fa-external-link-alt\"></i></span> 实际上并不是同一个，Windows 的只是借了 nvm 的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm 在三大系统上都是同一个，这保证了 API 的一致性。</p>\n<p>下面以fnm为例</p>\n<h3 id=\"fnm-下载\"><a href=\"#fnm-下载\" class=\"headerlink\" title=\"fnm 下载\"></a>fnm 下载</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://fnm.vercel.app/install | bash</span><br></pre></td></tr></table></figure>\n<p>如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vYmplY3RzLmdpdGh1YnVzZXJjb250ZW50LmNvbS9naXRodWItcHJvZHVjdGlvbi1yZWxlYXNlLWFzc2V0LTJlNjViZS8xNjYwNDU0MjQvNGMwYTllMmEtOWIyMi00ZWJlLWIwMjYtZGU1ZTc4ZGU5MzUxP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9cmVsZWFzZWFzc2V0cHJvZHVjdGlvbiUyRjIwMjQwNTI5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDUyOVQwODMzMjRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1kNWUxMzc2M2I5NzUwNzI3YmQ0NWIwMTRkMTJhYTdlM2E4OTNmZmUyNzU4MTg5NzEwZDhjMTFkODc0ZWI5ZTY2JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD05MTI3MzE2MSZrZXlfaWQ9MCZyZXBvX2lkPTE2NjA0NTQyNCZyZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0IlMjBmaWxlbmFtZSUzRGZubS1saW51eC56aXAmcmVzcG9uc2UtY29udGVudC10eXBlPWFwcGxpY2F0aW9uJTJGb2N0ZXQtc3RyZWFtb2JqZWN0cy5naXRodWJ1c2VyY29udGVudC5jb20vZ2l0aHViLXByb2R1Y3Rpb24tcmVsZWFzZS1hc3NldC0yZTY1YmUvMTY2MDQ1NDI0LzRjMGE5ZTJhLTliMjItNGViZS1iMDI2LWRlNWU3OGRlOTM1MT9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPXJlbGVhc2Vhc3NldHByb2R1Y3Rpb24lMkYyMDI0MDUyOSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA1MjlUMDgzMzI0WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZDVlMTM3NjNiOTc1MDcyN2JkNDViMDE0ZDEyYWE3ZTNhODkzZmZlMjc1ODE4OTcxMGQ4YzExZDg3NGViOWU2NiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9OTEyNzMxNjEma2V5X2lkPTAmcmVwb19pZD0xNjYwNDU0MjQmcmVzcG9uc2UtY29udGVudC1kaXNwb3NpdGlvbj1hdHRhY2htZW50JTNCJTIwZmlsZW5hbWUlM0Rmbm0tbGludXguemlwJnJlc3BvbnNlLWNvbnRlbnQtdHlwZT1hcHBsaWNhdGlvbiUyRm9jdGV0LXN0cmVhbQ==\">fnm.zip<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"NodeJS18版本以上的gcc-amp-make版本要求\"><a href=\"#NodeJS18版本以上的gcc-amp-make版本要求\" class=\"headerlink\" title=\"NodeJS18版本以上的gcc&amp;make版本要求\"></a>NodeJS18版本以上的gcc&amp;make版本要求</h3><p>要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make install即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。</p>\n<p>以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTk3OTE0NTA/c3BtPWEyYzZoLjEyODczNjM5LmFydGljbGUtZGV0YWlsLjcuNzEzNzY1ZmFadXZTd2g=\">OSError: /lib64/libm.so.6: version `GLIBC_2.27’ not found (required by xxx.so) ——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>在make过程中通常涉及</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld-linux-x86-64.so.2\\libc.so.6</span><br></pre></td></tr></table></figure>\n<p>两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTk3OTE0NTA/c3BtPWEyYzZoLjEyODczNjM5LmFydGljbGUtZGV0YWlsLjcuNzEzNzY1ZmFadXZTd2g=\">https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh<i class=\"fa fa-external-link-alt\"></i></span>)</p>\n<p>最后记得设置环境变量，切勿随意删除系统gcc文件。</p>\n<blockquote>\n<p> 许多blog在configure中设置—profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）</p>\n</blockquote>\n<p>安装NodeJS详细步骤建议参考官方：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL3BhY2thZ2UtbWFuYWdlcg==\">Node.js — Download Node.js® (nodejs.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素</p>\n<h3 id=\"NodeJS验证\"><a href=\"#NodeJS验证\" class=\"headerlink\" title=\"NodeJS验证\"></a>NodeJS验证</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n<p>两条指令均正常即说明程序成功安装</p>"},{"title":"RSA涉及算法与数论知识","date":"2024-08-14T11:51:58.000Z","_content":"**RSA** (**Rivest–Shamir–Adleman**) is a [public-key cryptosystem](https://en.wikipedia.org/wiki/Public-key_cryptography), one of the oldest widely used for secure data transmission.\n\nRSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。\n\n<!--more-->\n\n## 基础数论知识纲要\n\n传送门：[MH3210 - NTU - Number Theory - Studocu](https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934)\n\n知乎blog：[基础数论学习笔记（1）- Divisibility 整除 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/635332658)\n\n讲义：[NanYang Technological University MH1300ANDMH3210](https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg) \n\n## 概念定义\n\n**费马小定理**：选一个**素数p**，再选一个和p不成倍数关系的整数β，必然满足**β的p次幂**和**β**对p同余。公式如下。\n$$\n\\beta^p \\equiv \\beta (modp)\n$$\n**二次剩余**： 取定 $$𝑎\\perp 𝑝$$, 假若存在着 $x$使得\n$$\nx^2 \\equiv a (modp)\n$$\n\n则称$$a$$是$$modp$$的特殊剩余，否则则是$$modp$$的二次非剩余\n\n**欧拉准则**：元素β是**模奇素数p**的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\n$$\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\n$$\n\n> 欧拉准则证明：\n> 设$$r^2 = \\beta$$则有 $$r^{p-1} \\equiv 1 (modp)$$,利用费马小定理即可得证。\n\n**勒让德符号**：$$(\\frac{a}{p})$$ 若$$a$$ 是$$modp$$的平方剩余 则 $$(\\frac{a}{p}) = 1$$ ，若不是，则$$(\\frac{a}{p})= -1$$ 若$$a$$和$$p$$是整除关系则$$(\\frac{a}{p})=0$$ ,如下列公式\n$$\n(\\frac{a}{p}) = \n\\begin{cases}\n1,\\quad x^2 \\equiv a(modp)\\\\\n0, \\quad a \\equiv 0 (modp) \\\\\n-1, \\quad x^2 \\not\\equiv a(modp)\n\\end{cases}\n\\tag{1}\n$$\nSolovay-Strassen算法：若n是一个素数，那么勒让德符号$$(\\frac{β}{n})\\equiv β^{(n-1)/2}mod n$$。\n\n> Strassen算法证明：根据欧拉准则**β的(n-1)/2次方和1对n不同余**，根据费马小定理，**β的n-1次方**和1对n同余，根据平方差公式，$$β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)$$ 。由于$（β^{(n-1)/2}-1）$ 无法被n整除，所以$$（β^{(n-1)/2}+1）$$ 必然能被n整除，进而得到$$β^{(n-1)/2}\\equiv-1  (mod n)$$。\n\n**该命题的逆命题是不成立的**\n\n**二次互反律**：$$\\mathbb Z_p^\\times\\to\\mathbb Z_2$$​ \n\n**Miller-Rabin算法**：\n\n输入待测试大数$$n$$，对$$n-1$$不断地进行除$$2$$操作，直到得到一个**奇数t**。\n\n于是这可以写成 $$n-1 = 2^s \\cdot t$$ 。显然的，待测试大数$n$肯定是个奇数（废话，是偶数还测个锤子了），那么$$n-1$$肯定是个偶数，故$$s\\not=0$$。\n\n选择**随机种子$$a$$**，$$a＜n$$且与$$n$$互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）\n\n先设$$m=t$$。计算 $$b \\equiv a^t(modn)$$ ：\n\n- 情况①：当 $$m=2^s \\cdot t = n -1$$时，停机，输出“n是一个合数”。\n\n- 情况②：当 $$b \\equiv -1 (modn)$$ 时，停机，换一个随机种子a再次进行测试。\n\n- 情况③：当$$b \\equiv -1(modn)$$不成立时，重新设$b$为$$b²(mod n)$$，$$m$$为$$2m$$​；继续循环，直到得到情况①或情况②为止。\n\n## 计算方法\n\n**快速幂**：通过二进制的快速幂优化\n\n**计算勒让德符号$$(\\frac{\\beta}{n})$$​** ：二次互反\n\n**大整数除法中对小除数的优化**：移位计算小除数的商\n\n**大整数除法中对大除数的优化**：二分查找对每次计算试商的优化","source":"_posts/RSA涉及算法与数论知识.md","raw":"---\ntitle: RSA涉及算法与数论知识\ndate: 2024-08-14 19:51:58\ntags: [信息安全, 数学]\ncategories:\n\t- 信息安全\n\t- 加密算法\n\t- 数学\n---\n**RSA** (**Rivest–Shamir–Adleman**) is a [public-key cryptosystem](https://en.wikipedia.org/wiki/Public-key_cryptography), one of the oldest widely used for secure data transmission.\n\nRSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。\n\n<!--more-->\n\n## 基础数论知识纲要\n\n传送门：[MH3210 - NTU - Number Theory - Studocu](https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934)\n\n知乎blog：[基础数论学习笔记（1）- Divisibility 整除 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/635332658)\n\n讲义：[NanYang Technological University MH1300ANDMH3210](https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg) \n\n## 概念定义\n\n**费马小定理**：选一个**素数p**，再选一个和p不成倍数关系的整数β，必然满足**β的p次幂**和**β**对p同余。公式如下。\n$$\n\\beta^p \\equiv \\beta (modp)\n$$\n**二次剩余**： 取定 $$𝑎\\perp 𝑝$$, 假若存在着 $x$使得\n$$\nx^2 \\equiv a (modp)\n$$\n\n则称$$a$$是$$modp$$的特殊剩余，否则则是$$modp$$的二次非剩余\n\n**欧拉准则**：元素β是**模奇素数p**的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\n$$\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\n$$\n\n> 欧拉准则证明：\n> 设$$r^2 = \\beta$$则有 $$r^{p-1} \\equiv 1 (modp)$$,利用费马小定理即可得证。\n\n**勒让德符号**：$$(\\frac{a}{p})$$ 若$$a$$ 是$$modp$$的平方剩余 则 $$(\\frac{a}{p}) = 1$$ ，若不是，则$$(\\frac{a}{p})= -1$$ 若$$a$$和$$p$$是整除关系则$$(\\frac{a}{p})=0$$ ,如下列公式\n$$\n(\\frac{a}{p}) = \n\\begin{cases}\n1,\\quad x^2 \\equiv a(modp)\\\\\n0, \\quad a \\equiv 0 (modp) \\\\\n-1, \\quad x^2 \\not\\equiv a(modp)\n\\end{cases}\n\\tag{1}\n$$\nSolovay-Strassen算法：若n是一个素数，那么勒让德符号$$(\\frac{β}{n})\\equiv β^{(n-1)/2}mod n$$。\n\n> Strassen算法证明：根据欧拉准则**β的(n-1)/2次方和1对n不同余**，根据费马小定理，**β的n-1次方**和1对n同余，根据平方差公式，$$β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)$$ 。由于$（β^{(n-1)/2}-1）$ 无法被n整除，所以$$（β^{(n-1)/2}+1）$$ 必然能被n整除，进而得到$$β^{(n-1)/2}\\equiv-1  (mod n)$$。\n\n**该命题的逆命题是不成立的**\n\n**二次互反律**：$$\\mathbb Z_p^\\times\\to\\mathbb Z_2$$​ \n\n**Miller-Rabin算法**：\n\n输入待测试大数$$n$$，对$$n-1$$不断地进行除$$2$$操作，直到得到一个**奇数t**。\n\n于是这可以写成 $$n-1 = 2^s \\cdot t$$ 。显然的，待测试大数$n$肯定是个奇数（废话，是偶数还测个锤子了），那么$$n-1$$肯定是个偶数，故$$s\\not=0$$。\n\n选择**随机种子$$a$$**，$$a＜n$$且与$$n$$互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）\n\n先设$$m=t$$。计算 $$b \\equiv a^t(modn)$$ ：\n\n- 情况①：当 $$m=2^s \\cdot t = n -1$$时，停机，输出“n是一个合数”。\n\n- 情况②：当 $$b \\equiv -1 (modn)$$ 时，停机，换一个随机种子a再次进行测试。\n\n- 情况③：当$$b \\equiv -1(modn)$$不成立时，重新设$b$为$$b²(mod n)$$，$$m$$为$$2m$$​；继续循环，直到得到情况①或情况②为止。\n\n## 计算方法\n\n**快速幂**：通过二进制的快速幂优化\n\n**计算勒让德符号$$(\\frac{\\beta}{n})$$​** ：二次互反\n\n**大整数除法中对小除数的优化**：移位计算小除数的商\n\n**大整数除法中对大除数的优化**：二分查找对每次计算试商的优化","slug":"RSA涉及算法与数论知识","published":1,"updated":"2024-08-14T13:38:56.431Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9v000n2wwv2iy4coh0","content":"<p><strong>RSA</strong> (<strong>Rivest–Shamir–Adleman</strong>) is a <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHVibGljLWtleV9jcnlwdG9ncmFwaHk=\">public-key cryptosystem<i class=\"fa fa-external-link-alt\"></i></span>, one of the oldest widely used for secure data transmission.</p>\n<p>RSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。</p>\n<span id=\"more\"></span>\n<h2 id=\"基础数论知识纲要\"><a href=\"#基础数论知识纲要\" class=\"headerlink\" title=\"基础数论知识纲要\"></a>基础数论知识纲要</h2><p>传送门：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3R1ZG9jdS5jb20vc2cvY291cnNlL25hbnlhbmctdGVjaG5vbG9naWNhbC11bml2ZXJzaXR5L251bWJlci10aGVvcnkvMzAzMTkzNA==\">MH3210 - NTU - Number Theory - Studocu<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>知乎blog：<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MzUzMzI2NTg=\">基础数论学习笔记（1）- Divisibility 整除 - 知乎 (zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>讲义：<span class=\"exturl\" data-url=\"aHR0cHM6Ly8xZHJ2Lm1zL2YvcyFBcC1lblk3Y2tMQU5nb05Ib3R6cTNTUlRhZnA0cGc=\">NanYang Technological University MH1300ANDMH3210<i class=\"fa fa-external-link-alt\"></i></span> </p>\n<h2 id=\"概念定义\"><a href=\"#概念定义\" class=\"headerlink\" title=\"概念定义\"></a>概念定义</h2><p><strong>费马小定理</strong>：选一个<strong>素数p</strong>，再选一个和p不成倍数关系的整数β，必然满足<strong>β的p次幂</strong>和<strong>β</strong>对p同余。公式如下。</p>\n<script type=\"math/tex; mode=display\">\n\\beta^p \\equiv \\beta (modp)</script><p><strong>二次剩余</strong>： 取定 <script type=\"math/tex\">𝑎\\perp 𝑝</script>, 假若存在着 $x$使得</p>\n<script type=\"math/tex; mode=display\">\nx^2 \\equiv a (modp)</script><p>则称<script type=\"math/tex\">a</script>是<script type=\"math/tex\">modp</script>的特殊剩余，否则则是<script type=\"math/tex\">modp</script>的二次非剩余</p>\n<p><strong>欧拉准则</strong>：元素β是<strong>模奇素数p</strong>的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式</p>\n<script type=\"math/tex; mode=display\">\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)</script><blockquote>\n<p>欧拉准则证明：<br>设<script type=\"math/tex\">r^2 = \\beta</script>则有 <script type=\"math/tex\">r^{p-1} \\equiv 1 (modp)</script>,利用费马小定理即可得证。</p>\n</blockquote>\n<p><strong>勒让德符号</strong>：<script type=\"math/tex\">(\\frac{a}{p})</script> 若<script type=\"math/tex\">a</script> 是<script type=\"math/tex\">modp</script>的平方剩余 则 <script type=\"math/tex\">(\\frac{a}{p}) = 1</script> ，若不是，则<script type=\"math/tex\">(\\frac{a}{p})= -1</script> 若<script type=\"math/tex\">a</script>和<script type=\"math/tex\">p</script>是整除关系则<script type=\"math/tex\">(\\frac{a}{p})=0</script> ,如下列公式</p>\n<script type=\"math/tex; mode=display\">\n(\\frac{a}{p}) = \n\\begin{cases}\n1,\\quad x^2 \\equiv a(modp)\\\\\n0, \\quad a \\equiv 0 (modp) \\\\\n-1, \\quad x^2 \\not\\equiv a(modp)\n\\end{cases}\n\\tag{1}</script><p>Solovay-Strassen算法：若n是一个素数，那么勒让德符号<script type=\"math/tex\">(\\frac{β}{n})\\equiv β^{(n-1)/2}mod n</script>。</p>\n<blockquote>\n<p>Strassen算法证明：根据欧拉准则<strong>β的(n-1)/2次方和1对n不同余</strong>，根据费马小定理，<strong>β的n-1次方</strong>和1对n同余，根据平方差公式，<script type=\"math/tex\">β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)</script> 。由于$（β^{(n-1)/2}-1）$ 无法被n整除，所以<script type=\"math/tex\">（β^{(n-1)/2}+1）</script> 必然能被n整除，进而得到<script type=\"math/tex\">β^{(n-1)/2}\\equiv-1  (mod n)</script>。</p>\n</blockquote>\n<p><strong>该命题的逆命题是不成立的</strong></p>\n<p><strong>二次互反律</strong>：<script type=\"math/tex\">\\mathbb Z_p^\\times\\to\\mathbb Z_2</script>​ </p>\n<p><strong>Miller-Rabin算法</strong>：</p>\n<p>输入待测试大数<script type=\"math/tex\">n</script>，对<script type=\"math/tex\">n-1</script>不断地进行除<script type=\"math/tex\">2</script>操作，直到得到一个<strong>奇数t</strong>。</p>\n<p>于是这可以写成 <script type=\"math/tex\">n-1 = 2^s \\cdot t</script> 。显然的，待测试大数$n$肯定是个奇数（废话，是偶数还测个锤子了），那么<script type=\"math/tex\">n-1</script>肯定是个偶数，故<script type=\"math/tex\">s\\not=0</script>。</p>\n<p>选择<strong>随机种子<script type=\"math/tex\">a</script></strong>，<script type=\"math/tex\">a＜n</script>且与<script type=\"math/tex\">n</script>互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）</p>\n<p>先设<script type=\"math/tex\">m=t</script>。计算 <script type=\"math/tex\">b \\equiv a^t(modn)</script> ：</p>\n<ul>\n<li><p>情况①：当 <script type=\"math/tex\">m=2^s \\cdot t = n -1</script>时，停机，输出“n是一个合数”。</p>\n</li>\n<li><p>情况②：当 <script type=\"math/tex\">b \\equiv -1 (modn)</script> 时，停机，换一个随机种子a再次进行测试。</p>\n</li>\n<li><p>情况③：当<script type=\"math/tex\">b \\equiv -1(modn)</script>不成立时，重新设$b$为<script type=\"math/tex\">b²(mod n)</script>，<script type=\"math/tex\">m</script>为<script type=\"math/tex\">2m</script>​；继续循环，直到得到情况①或情况②为止。</p>\n</li>\n</ul>\n<h2 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h2><p><strong>快速幂</strong>：通过二进制的快速幂优化</p>\n<p><strong>计算勒让德符号<script type=\"math/tex\">(\\frac{\\beta}{n})</script>​</strong> ：二次互反</p>\n<p><strong>大整数除法中对小除数的优化</strong>：移位计算小除数的商</p>\n<p><strong>大整数除法中对大除数的优化</strong>：二分查找对每次计算试商的优化</p>\n","length":831,"excerpt":"<p><strong>RSA</strong> (<strong>Rivest–Shamir–Adleman</strong>) is a <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHVibGljLWtleV9jcnlwdG9ncmFwaHk=\">public-key cryptosystem<i class=\"fa fa-external-link-alt\"></i></span>, one of the oldest widely used for secure data transmission.</p>\n<p>RSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。</p>","more":"<h2 id=\"基础数论知识纲要\"><a href=\"#基础数论知识纲要\" class=\"headerlink\" title=\"基础数论知识纲要\"></a>基础数论知识纲要</h2><p>传送门：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3R1ZG9jdS5jb20vc2cvY291cnNlL25hbnlhbmctdGVjaG5vbG9naWNhbC11bml2ZXJzaXR5L251bWJlci10aGVvcnkvMzAzMTkzNA==\">MH3210 - NTU - Number Theory - Studocu<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>知乎blog：<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MzUzMzI2NTg=\">基础数论学习笔记（1）- Divisibility 整除 - 知乎 (zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>讲义：<span class=\"exturl\" data-url=\"aHR0cHM6Ly8xZHJ2Lm1zL2YvcyFBcC1lblk3Y2tMQU5nb05Ib3R6cTNTUlRhZnA0cGc=\">NanYang Technological University MH1300ANDMH3210<i class=\"fa fa-external-link-alt\"></i></span> </p>\n<h2 id=\"概念定义\"><a href=\"#概念定义\" class=\"headerlink\" title=\"概念定义\"></a>概念定义</h2><p><strong>费马小定理</strong>：选一个<strong>素数p</strong>，再选一个和p不成倍数关系的整数β，必然满足<strong>β的p次幂</strong>和<strong>β</strong>对p同余。公式如下。</p>\n<script type=\"math/tex; mode=display\">\n\\beta^p \\equiv \\beta (modp)</script><p><strong>二次剩余</strong>： 取定 <script type=\"math/tex\">𝑎\\perp 𝑝</script>, 假若存在着 $x$使得</p>\n<script type=\"math/tex; mode=display\">\nx^2 \\equiv a (modp)</script><p>则称<script type=\"math/tex\">a</script>是<script type=\"math/tex\">modp</script>的特殊剩余，否则则是<script type=\"math/tex\">modp</script>的二次非剩余</p>\n<p><strong>欧拉准则</strong>：元素β是<strong>模奇素数p</strong>的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式</p>\n<script type=\"math/tex; mode=display\">\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)</script><blockquote>\n<p>欧拉准则证明：<br>设<script type=\"math/tex\">r^2 = \\beta</script>则有 <script type=\"math/tex\">r^{p-1} \\equiv 1 (modp)</script>,利用费马小定理即可得证。</p>\n</blockquote>\n<p><strong>勒让德符号</strong>：<script type=\"math/tex\">(\\frac{a}{p})</script> 若<script type=\"math/tex\">a</script> 是<script type=\"math/tex\">modp</script>的平方剩余 则 <script type=\"math/tex\">(\\frac{a}{p}) = 1</script> ，若不是，则<script type=\"math/tex\">(\\frac{a}{p})= -1</script> 若<script type=\"math/tex\">a</script>和<script type=\"math/tex\">p</script>是整除关系则<script type=\"math/tex\">(\\frac{a}{p})=0</script> ,如下列公式</p>\n<script type=\"math/tex; mode=display\">\n(\\frac{a}{p}) = \n\\begin{cases}\n1,\\quad x^2 \\equiv a(modp)\\\\\n0, \\quad a \\equiv 0 (modp) \\\\\n-1, \\quad x^2 \\not\\equiv a(modp)\n\\end{cases}\n\\tag{1}</script><p>Solovay-Strassen算法：若n是一个素数，那么勒让德符号<script type=\"math/tex\">(\\frac{β}{n})\\equiv β^{(n-1)/2}mod n</script>。</p>\n<blockquote>\n<p>Strassen算法证明：根据欧拉准则<strong>β的(n-1)/2次方和1对n不同余</strong>，根据费马小定理，<strong>β的n-1次方</strong>和1对n同余，根据平方差公式，<script type=\"math/tex\">β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)</script> 。由于$（β^{(n-1)/2}-1）$ 无法被n整除，所以<script type=\"math/tex\">（β^{(n-1)/2}+1）</script> 必然能被n整除，进而得到<script type=\"math/tex\">β^{(n-1)/2}\\equiv-1  (mod n)</script>。</p>\n</blockquote>\n<p><strong>该命题的逆命题是不成立的</strong></p>\n<p><strong>二次互反律</strong>：<script type=\"math/tex\">\\mathbb Z_p^\\times\\to\\mathbb Z_2</script>​ </p>\n<p><strong>Miller-Rabin算法</strong>：</p>\n<p>输入待测试大数<script type=\"math/tex\">n</script>，对<script type=\"math/tex\">n-1</script>不断地进行除<script type=\"math/tex\">2</script>操作，直到得到一个<strong>奇数t</strong>。</p>\n<p>于是这可以写成 <script type=\"math/tex\">n-1 = 2^s \\cdot t</script> 。显然的，待测试大数$n$肯定是个奇数（废话，是偶数还测个锤子了），那么<script type=\"math/tex\">n-1</script>肯定是个偶数，故<script type=\"math/tex\">s\\not=0</script>。</p>\n<p>选择<strong>随机种子<script type=\"math/tex\">a</script></strong>，<script type=\"math/tex\">a＜n</script>且与<script type=\"math/tex\">n</script>互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）</p>\n<p>先设<script type=\"math/tex\">m=t</script>。计算 <script type=\"math/tex\">b \\equiv a^t(modn)</script> ：</p>\n<ul>\n<li><p>情况①：当 <script type=\"math/tex\">m=2^s \\cdot t = n -1</script>时，停机，输出“n是一个合数”。</p>\n</li>\n<li><p>情况②：当 <script type=\"math/tex\">b \\equiv -1 (modn)</script> 时，停机，换一个随机种子a再次进行测试。</p>\n</li>\n<li><p>情况③：当<script type=\"math/tex\">b \\equiv -1(modn)</script>不成立时，重新设$b$为<script type=\"math/tex\">b²(mod n)</script>，<script type=\"math/tex\">m</script>为<script type=\"math/tex\">2m</script>​；继续循环，直到得到情况①或情况②为止。</p>\n</li>\n</ul>\n<h2 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h2><p><strong>快速幂</strong>：通过二进制的快速幂优化</p>\n<p><strong>计算勒让德符号<script type=\"math/tex\">(\\frac{\\beta}{n})</script>​</strong> ：二次互反</p>\n<p><strong>大整数除法中对小除数的优化</strong>：移位计算小除数的商</p>\n<p><strong>大整数除法中对大除数的优化</strong>：二分查找对每次计算试商的优化</p>"},{"title":"Xiaobai93D-E","date":"2024-08-14T11:46:31.000Z","_content":"\n## [D-幻兽帕鲁_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/D)\n\n<!--more-->\n\n### 题意\n\n在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。  \n\n你有 $$2^n$$ 只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 $$[0,2^n-1]$$ 工号的顺序排成一队。  \n\n当我们对区间 $$[l,r]$$ 的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 $$[0,r-l]$$ ，记 $$mid = \\lfloor\\frac{l + r}{2}\\rfloor$$，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间 $$[l,mid]$$ 和 $$[mid + 1,r]$$ ，并递归对这两个区间进行上述操作，直到区间长度为 $1$ 。  \n\n现在我们对 $$[0,2^n-1]$$ 的幻兽进行一次操作，然后给你 $m$ 次询问，每次询问 $x$​ 位置的帕鲁工号是多少？\n\n### 题解\n\n简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。\n\n于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1<<(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。\n\n````cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tll x;\n\t\tcin>>x;\n\t\tll ans = 0;\n\t\twhile(x){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(x < (1ll<<(n-i-1))) continue;\n\t\t\t\tx-= (1ll<<(n-i-1));\n\t\t\t\tans += (1ll<<i);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n````\n\n\n\n## [E-奏绝_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/E)\n\n### **题意：**\n\n你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。  \n\n对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为 0。  \n\n区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。  \n\n对于 m 次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对  998244353 取模。\n\n[E-奏绝_牛客小白月赛93（重现赛）](https://ac.nowcoder.com/acm/contest/82821/E)\n\n### **题解**\n\n**不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积**\n\n奏绝，我直接肘击！\n\n题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。\n\n```cpp\nstruct Node\n{\n\tint x, y, id;\n};\n\nbool cmp(const Node& x,const Node& y){\n\tif(x.x/ blk != y.x /blk) return x.x/blk < y.x/blk;\n\telse {\n\t\tif(x.x != y.x) return x.x < y.x;\n\t\telse {\n\t\t\treturn x.y < y.y;\n\t\t}\n\t}\n}\n\nvoid move(int x,int c)\n{\n\tsum1 += (s[x] == '1'? x: 0) * c;\n\tcnt1 += (s[x] == '1') * c;\n\tsum2 += (s[x] == '0'? x: 0) * c;\n\tcnt2 += (s[x] == '0') * c;\n}\n\nvoid updateL(int x,int c){\n\tif(s[x]=='1'){\n\t\tans += (sum2 - x * cnt2) * c% MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x]=='0'){\n\t\tans += (sum1 - x * cnt1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"!\"<<x<<' '<<ans<<endl;\n}\nvoid updateR(int x,int c){\n\tif(s[x] == '0'){\n\t\tans += (x * cnt1 - sum1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x] == '1'){\n\t\tans += (x * cnt2 - sum2) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"#\"<<x<<' '<<ans<<endl;\n}\n```","source":"_posts/Xiaobai93D-E.md","raw":"title: Xiaobai93D-E\ndate: 2024-08-14 19:46:31\ntags: [newcoder]\ncategories: \n\t- 比赛\n\t- 日常赛\n\t- newcoder\n---\n\n## [D-幻兽帕鲁_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/D)\n\n<!--more-->\n\n### 题意\n\n在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。  \n\n你有 $$2^n$$ 只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 $$[0,2^n-1]$$ 工号的顺序排成一队。  \n\n当我们对区间 $$[l,r]$$ 的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 $$[0,r-l]$$ ，记 $$mid = \\lfloor\\frac{l + r}{2}\\rfloor$$，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间 $$[l,mid]$$ 和 $$[mid + 1,r]$$ ，并递归对这两个区间进行上述操作，直到区间长度为 $1$ 。  \n\n现在我们对 $$[0,2^n-1]$$ 的幻兽进行一次操作，然后给你 $m$ 次询问，每次询问 $x$​ 位置的帕鲁工号是多少？\n\n### 题解\n\n简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。\n\n于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1<<(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。\n\n````cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tll x;\n\t\tcin>>x;\n\t\tll ans = 0;\n\t\twhile(x){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(x < (1ll<<(n-i-1))) continue;\n\t\t\t\tx-= (1ll<<(n-i-1));\n\t\t\t\tans += (1ll<<i);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n````\n\n\n\n## [E-奏绝_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/E)\n\n### **题意：**\n\n你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。  \n\n对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为 0。  \n\n区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。  \n\n对于 m 次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对  998244353 取模。\n\n[E-奏绝_牛客小白月赛93（重现赛）](https://ac.nowcoder.com/acm/contest/82821/E)\n\n### **题解**\n\n**不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积**\n\n奏绝，我直接肘击！\n\n题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。\n\n```cpp\nstruct Node\n{\n\tint x, y, id;\n};\n\nbool cmp(const Node& x,const Node& y){\n\tif(x.x/ blk != y.x /blk) return x.x/blk < y.x/blk;\n\telse {\n\t\tif(x.x != y.x) return x.x < y.x;\n\t\telse {\n\t\t\treturn x.y < y.y;\n\t\t}\n\t}\n}\n\nvoid move(int x,int c)\n{\n\tsum1 += (s[x] == '1'? x: 0) * c;\n\tcnt1 += (s[x] == '1') * c;\n\tsum2 += (s[x] == '0'? x: 0) * c;\n\tcnt2 += (s[x] == '0') * c;\n}\n\nvoid updateL(int x,int c){\n\tif(s[x]=='1'){\n\t\tans += (sum2 - x * cnt2) * c% MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x]=='0'){\n\t\tans += (sum1 - x * cnt1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"!\"<<x<<' '<<ans<<endl;\n}\nvoid updateR(int x,int c){\n\tif(s[x] == '0'){\n\t\tans += (x * cnt1 - sum1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x] == '1'){\n\t\tans += (x * cnt2 - sum2) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"#\"<<x<<' '<<ans<<endl;\n}\n```","slug":"Xiaobai93D-E","published":1,"updated":"2024-08-15T04:52:02.258Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9v000r2wwvbjz88z49","content":"<h2 id=\"D-幻兽帕鲁-牛客小白月赛93-nowcoder-com\"><a href=\"#D-幻兽帕鲁-牛客小白月赛93-nowcoder-com\" class=\"headerlink\" title=\"D-幻兽帕鲁_牛客小白月赛93 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI0MDEvRA==\">D-幻兽帕鲁_牛客小白月赛93 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><span id=\"more\"></span>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。  </p>\n<p>你有 <script type=\"math/tex\">2^n</script> 只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 <script type=\"math/tex\">[0,2^n-1]</script> 工号的顺序排成一队。  </p>\n<p>当我们对区间 <script type=\"math/tex\">[l,r]</script> 的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 <script type=\"math/tex\">[0,r-l]</script> ，记 <script type=\"math/tex\">mid = \\lfloor\\frac{l + r}{2}\\rfloor</script>，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间 <script type=\"math/tex\">[l,mid]</script> 和 <script type=\"math/tex\">[mid + 1,r]</script> ，并递归对这两个区间进行上述操作，直到区间长度为 $1$ 。  </p>\n<p>现在我们对 <script type=\"math/tex\">[0,2^n-1]</script> 的幻兽进行一次操作，然后给你 $m$ 次询问，每次询问 $x$​ 位置的帕鲁工号是多少？</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。</p>\n<p>于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1&lt;&lt;(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tll x;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(x)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(x &lt; (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>))) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\tx-= (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t\t\t\tans += (<span class=\"number\">1ll</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"E-奏绝-牛客小白月赛93-nowcoder-com\"><a href=\"#E-奏绝-牛客小白月赛93-nowcoder-com\" class=\"headerlink\" title=\"E-奏绝_牛客小白月赛93 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI0MDEvRQ==\">E-奏绝_牛客小白月赛93 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a><strong>题意：</strong></h3><p>你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。  </p>\n<p>对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为 0。  </p>\n<p>区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。  </p>\n<p>对于 m 次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对  998244353 取模。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI4MjEvRQ==\">E-奏绝_牛客小白月赛93（重现赛）<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a><strong>题解</strong></h3><p><strong>不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积</strong></p>\n<p>奏绝，我直接肘击！</p>\n<p>题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y, id;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> Node&amp; x,<span class=\"type\">const</span> Node&amp; y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x.x/ blk != y.x /blk) <span class=\"keyword\">return</span> x.x/blk &lt; y.x/blk;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x.x != y.x) <span class=\"keyword\">return</span> x.x &lt; y.x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x.y &lt; y.y;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tsum1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>) * c;</span><br><span class=\"line\">\tsum2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>) * c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateL</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum2 - x * cnt2) * c% MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum1 - x * cnt1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;!&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateR</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt1 - sum1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt2 - sum2) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","length":916,"excerpt":"<h2 id=\"D-幻兽帕鲁-牛客小白月赛93-nowcoder-com\"><a href=\"#D-幻兽帕鲁-牛客小白月赛93-nowcoder-com\" class=\"headerlink\" title=\"D-幻兽帕鲁_牛客小白月赛93 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI0MDEvRA==\">D-幻兽帕鲁_牛客小白月赛93 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>","more":"<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。  </p>\n<p>你有 <script type=\"math/tex\">2^n</script> 只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 <script type=\"math/tex\">[0,2^n-1]</script> 工号的顺序排成一队。  </p>\n<p>当我们对区间 <script type=\"math/tex\">[l,r]</script> 的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 <script type=\"math/tex\">[0,r-l]</script> ，记 <script type=\"math/tex\">mid = \\lfloor\\frac{l + r}{2}\\rfloor</script>，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间 <script type=\"math/tex\">[l,mid]</script> 和 <script type=\"math/tex\">[mid + 1,r]</script> ，并递归对这两个区间进行上述操作，直到区间长度为 $1$ 。  </p>\n<p>现在我们对 <script type=\"math/tex\">[0,2^n-1]</script> 的幻兽进行一次操作，然后给你 $m$ 次询问，每次询问 $x$​ 位置的帕鲁工号是多少？</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。</p>\n<p>于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1&lt;&lt;(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tll x;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(x)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(x &lt; (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>))) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\tx-= (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t\t\t\tans += (<span class=\"number\">1ll</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"E-奏绝-牛客小白月赛93-nowcoder-com\"><a href=\"#E-奏绝-牛客小白月赛93-nowcoder-com\" class=\"headerlink\" title=\"E-奏绝_牛客小白月赛93 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI0MDEvRQ==\">E-奏绝_牛客小白月赛93 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a><strong>题意：</strong></h3><p>你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。  </p>\n<p>对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为 0。  </p>\n<p>区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。  </p>\n<p>对于 m 次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对  998244353 取模。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI4MjEvRQ==\">E-奏绝_牛客小白月赛93（重现赛）<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a><strong>题解</strong></h3><p><strong>不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积</strong></p>\n<p>奏绝，我直接肘击！</p>\n<p>题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y, id;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> Node&amp; x,<span class=\"type\">const</span> Node&amp; y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x.x/ blk != y.x /blk) <span class=\"keyword\">return</span> x.x/blk &lt; y.x/blk;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x.x != y.x) <span class=\"keyword\">return</span> x.x &lt; y.x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x.y &lt; y.y;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tsum1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>) * c;</span><br><span class=\"line\">\tsum2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>) * c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateL</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum2 - x * cnt2) * c% MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum1 - x * cnt1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;!&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateR</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt1 - sum1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt2 - sum2) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Xiaobai94","date":"2024-08-14T11:46:31.000Z","_content":"\n## [B-小苯的好数组_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/B)\n\n<!--more-->\n\n### 题意\n\n大白熊给了小苯一个长度为 $n$ 的数组 $a$，这次他希望小苯从数组中选择一个**子序列**（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。  \n\n大白熊定义好数组是：如果一个数组按升序排序后和原来**不完全相同**，则其是一个好数组。例如 $[3,2,2]$ 升序排序后是 $[2, 2, 3]$，和原来不完全相同，因此**是**一个好数组，而 $[1,2,2]$ **不是**一个好数组。\n\n  \n\n小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？\n\n### 题解\n\n误入签到，答案只有0和n两种，很好判断\n\n```cpp\nvoid slove() {\n\tvector<int> ve;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tint x;cin>>x;\n\t\tve.pb(x);\n\t}\n\tint ls = 0,flag = 0;\n\tfor(int v:ve){\n\t\tif(v < ls)flag = 1;\n\t\tls = max(v,ls);\n\t}\n\tif(flag) cout<<n<<endl;\n\telse cout<<0<<endl;\n}\n```\n\n## [C-小苯的数字合并_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/C)\n\n### 题意\n\n大白熊给了小苯一个长度为 $$n$$ 的数组 $$a$$，小苯想要**最大化** $$a$$ 的极差。\n\n具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：  \n\n  \n\n$\\bullet$ 选择一个正整数 $$i \\ (1 \\leq i <n)$$，接着将 $$a_i$$ 与 $$a_{i+1}$$ 合并为一个数字，结果为二者的和。\n\n（即：将 $$a_i$$ 变为 $$a_i + a_{i+1}$$，然后删去 $$a_{i+1}$$，当然操作完后 $a$ 的长度也会减一。）\n\n\n小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。\n\n### 题解\n\n注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++)\n\t\tpre[i] = pre[i-1] + a[i];\n\n\tfor(int i=n;i;i--)\n\t\trep[i] = rep[i+1] + a[i];\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = max(pre[i-1] ,rep[i+1]);\n\t\tans = max(ans,mx - a[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## [D-小苯的排列构造_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/D)\n\n### 题意\n\n格格有一个长度为 $$n$$ 的排列 $$p$$，但她不记得 $$p$$ 具体的样子，她只记得数组 $$a$$。  \n其中：$$a_i = gcd(p_1, p_2,...,p_i)$$，也就是说，$$a_i$$ 表示排列 $$p$$ 中前 $$i$$ 个数字的最大公约数。  \n\n\n现在，她希望小苯将排列 $$p$$ 复原出来，请你帮帮他吧。\n\n（但有可能无解，这意味着格格给出的 $$a$$ 数组可能是不正确的，此时输出 $$-1$$ 即可。）\n\n### 题解\n\n公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。\n\n如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。\n\n如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可\n\n注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\n\tint f = 1;\n\tfor(int i = 1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tif(i > 1 && a[i-1] % a[i] != 0) f = 0;\n\t}\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tint c = 1, s = a[i];\n\t\twhile(i < n && a[i+1] == a[i])i ++,c ++;\n\t\tint t = s;\n\t\twhile(c && t <= n) {\n\t\t\twhile(st[t]) t+=s;\n\t\t\tif(t > n) break;\n\t\t\tves.push_back(t);\n\t\t\tst[t] = 1;\n\t\t\t// cout<<t<<endl;\n\t\t\tt+=s,c--;\n\t\t}\n\t\tif(c) {f = 0;break;}\n\t}\n\n\tif(!f) {cout<<-1<<endl; return ;}\n\n\tfor(int v: ves) cout<<v<<' ';\n\t\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [E-小苯的01背包（easy）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/E)\n\n##[F-小苯的01背包（hard）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/F)\n\n### 题意\n\n**注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。**  \n\n\n小苯有一个容量为 $k$ 的背包，现在有 $n$ 个物品，每个物品有一个体积 $v$ 和价值 $w$，他想知道在体积不超过 $k$ 的前提下，他最多能装价值为多少的物品。\n\n本问题中，物品的总体积定义为所装物品的体积的 $\\&$（按位与），总价值也定义为所装物品的价值的 $\\&$（按位与）。\n\n（如果不选物品，则价值为 0，所占体积也为 0。）\n\n### 题解\n\n按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）\n\n比如对于二进制下物品价值\n\n```\n101101\n110010\n101011\n110110\n```\n\n不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。\n\n构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑$$O(n\\times 4e3)$$即可，注意初始状态为(1<<14)-1，但是这样跑出来是过93%，哪里有问题？\n\n一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。\n\n官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\n\tfor(int i=1;i<=n;i++) cin>>v[i]>>w[i];\n\n\tint ans = 0;\n    for (int i = 0; i <= 2000; i++) {\n        int V = (1 << 20) - 1;\n        for (int j = 1; j <= n; j++) {\n            if ((i & w[j]) == i) {\n                V &= v[j];\n            }\n        }\n        if (V <= k)\n            ans = max(ans, i);\n    }\n    cout<<ans<<endl;\n}\n```\n\n不得不说这个写法更简洁也更正确\n\nhard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。\n\n```cpp\nvoid slove() {\n\tint i, j, k;\n     \n    cin >> n >> k;\n     \n    for (i = 1; i <= n; i++) {\n        cin >> w[i] >> v[i];\n        q[0].push({w[i], v[i]});\n    }\n    int ans = 0;\n    for (i = 30; i >= 0; i--) {\n        int ww = 0x7fffffff;\n        int now = q[0].size();\n        for (j = 0; j < now; j++) {\n            auto x = q[0].front();\n            q[0].pop();\n            if ((x.y >> i) & 1) {\n                q[1].push(x);\n                ww &= x.x;\n            } else {\n                q[0].push(x);\n            }\n        }\n         \n        if (ww <= k) {\n            ans |= (1 << i);\n            while (!q[0].empty()) {\n                q[0].pop();\n            }\n        }\n        while (!q[1].empty()) {\n            q[0].push(q[1].front());\n            q[1].pop();\n        }\n    }\n    cout << ans << endl;\n}\n```\n\n","source":"_posts/Xiaobai94.md","raw":"title: Xiaobai94\ndate: 2024-08-14 19:46:31\ntags: [newcoder]\ncategories: \n\t- 比赛\n\t- 日常赛\n\t- newcoder\n---\n\n## [B-小苯的好数组_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/B)\n\n<!--more-->\n\n### 题意\n\n大白熊给了小苯一个长度为 $n$ 的数组 $a$，这次他希望小苯从数组中选择一个**子序列**（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。  \n\n大白熊定义好数组是：如果一个数组按升序排序后和原来**不完全相同**，则其是一个好数组。例如 $[3,2,2]$ 升序排序后是 $[2, 2, 3]$，和原来不完全相同，因此**是**一个好数组，而 $[1,2,2]$ **不是**一个好数组。\n\n  \n\n小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？\n\n### 题解\n\n误入签到，答案只有0和n两种，很好判断\n\n```cpp\nvoid slove() {\n\tvector<int> ve;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tint x;cin>>x;\n\t\tve.pb(x);\n\t}\n\tint ls = 0,flag = 0;\n\tfor(int v:ve){\n\t\tif(v < ls)flag = 1;\n\t\tls = max(v,ls);\n\t}\n\tif(flag) cout<<n<<endl;\n\telse cout<<0<<endl;\n}\n```\n\n## [C-小苯的数字合并_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/C)\n\n### 题意\n\n大白熊给了小苯一个长度为 $$n$$ 的数组 $$a$$，小苯想要**最大化** $$a$$ 的极差。\n\n具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：  \n\n  \n\n$\\bullet$ 选择一个正整数 $$i \\ (1 \\leq i <n)$$，接着将 $$a_i$$ 与 $$a_{i+1}$$ 合并为一个数字，结果为二者的和。\n\n（即：将 $$a_i$$ 变为 $$a_i + a_{i+1}$$，然后删去 $$a_{i+1}$$，当然操作完后 $a$ 的长度也会减一。）\n\n\n小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。\n\n### 题解\n\n注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++)\n\t\tpre[i] = pre[i-1] + a[i];\n\n\tfor(int i=n;i;i--)\n\t\trep[i] = rep[i+1] + a[i];\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = max(pre[i-1] ,rep[i+1]);\n\t\tans = max(ans,mx - a[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## [D-小苯的排列构造_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/D)\n\n### 题意\n\n格格有一个长度为 $$n$$ 的排列 $$p$$，但她不记得 $$p$$ 具体的样子，她只记得数组 $$a$$。  \n其中：$$a_i = gcd(p_1, p_2,...,p_i)$$，也就是说，$$a_i$$ 表示排列 $$p$$ 中前 $$i$$ 个数字的最大公约数。  \n\n\n现在，她希望小苯将排列 $$p$$ 复原出来，请你帮帮他吧。\n\n（但有可能无解，这意味着格格给出的 $$a$$ 数组可能是不正确的，此时输出 $$-1$$ 即可。）\n\n### 题解\n\n公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。\n\n如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。\n\n如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可\n\n注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\n\tint f = 1;\n\tfor(int i = 1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tif(i > 1 && a[i-1] % a[i] != 0) f = 0;\n\t}\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tint c = 1, s = a[i];\n\t\twhile(i < n && a[i+1] == a[i])i ++,c ++;\n\t\tint t = s;\n\t\twhile(c && t <= n) {\n\t\t\twhile(st[t]) t+=s;\n\t\t\tif(t > n) break;\n\t\t\tves.push_back(t);\n\t\t\tst[t] = 1;\n\t\t\t// cout<<t<<endl;\n\t\t\tt+=s,c--;\n\t\t}\n\t\tif(c) {f = 0;break;}\n\t}\n\n\tif(!f) {cout<<-1<<endl; return ;}\n\n\tfor(int v: ves) cout<<v<<' ';\n\t\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [E-小苯的01背包（easy）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/E)\n\n##[F-小苯的01背包（hard）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/F)\n\n### 题意\n\n**注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。**  \n\n\n小苯有一个容量为 $k$ 的背包，现在有 $n$ 个物品，每个物品有一个体积 $v$ 和价值 $w$，他想知道在体积不超过 $k$ 的前提下，他最多能装价值为多少的物品。\n\n本问题中，物品的总体积定义为所装物品的体积的 $\\&$（按位与），总价值也定义为所装物品的价值的 $\\&$（按位与）。\n\n（如果不选物品，则价值为 0，所占体积也为 0。）\n\n### 题解\n\n按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）\n\n比如对于二进制下物品价值\n\n```\n101101\n110010\n101011\n110110\n```\n\n不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。\n\n构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑$$O(n\\times 4e3)$$即可，注意初始状态为(1<<14)-1，但是这样跑出来是过93%，哪里有问题？\n\n一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。\n\n官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\n\tfor(int i=1;i<=n;i++) cin>>v[i]>>w[i];\n\n\tint ans = 0;\n    for (int i = 0; i <= 2000; i++) {\n        int V = (1 << 20) - 1;\n        for (int j = 1; j <= n; j++) {\n            if ((i & w[j]) == i) {\n                V &= v[j];\n            }\n        }\n        if (V <= k)\n            ans = max(ans, i);\n    }\n    cout<<ans<<endl;\n}\n```\n\n不得不说这个写法更简洁也更正确\n\nhard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。\n\n```cpp\nvoid slove() {\n\tint i, j, k;\n     \n    cin >> n >> k;\n     \n    for (i = 1; i <= n; i++) {\n        cin >> w[i] >> v[i];\n        q[0].push({w[i], v[i]});\n    }\n    int ans = 0;\n    for (i = 30; i >= 0; i--) {\n        int ww = 0x7fffffff;\n        int now = q[0].size();\n        for (j = 0; j < now; j++) {\n            auto x = q[0].front();\n            q[0].pop();\n            if ((x.y >> i) & 1) {\n                q[1].push(x);\n                ww &= x.x;\n            } else {\n                q[0].push(x);\n            }\n        }\n         \n        if (ww <= k) {\n            ans |= (1 << i);\n            while (!q[0].empty()) {\n                q[0].pop();\n            }\n        }\n        while (!q[1].empty()) {\n            q[0].push(q[1].front());\n            q[1].pop();\n        }\n    }\n    cout << ans << endl;\n}\n```\n\n","slug":"Xiaobai94","published":1,"updated":"2024-08-15T04:52:04.681Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9w000t2wwvfscq709t","content":"<h2 id=\"B-小苯的好数组-牛客小白月赛94-nowcoder-com\"><a href=\"#B-小苯的好数组-牛客小白月赛94-nowcoder-com\" class=\"headerlink\" title=\"B-小苯的好数组_牛客小白月赛94 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvQg==\">B-小苯的好数组_牛客小白月赛94 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><span id=\"more\"></span>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>大白熊给了小苯一个长度为 $n$ 的数组 $a$，这次他希望小苯从数组中选择一个<strong>子序列</strong>（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。  </p>\n<p>大白熊定义好数组是：如果一个数组按升序排序后和原来<strong>不完全相同</strong>，则其是一个好数组。例如 $[3,2,2]$ 升序排序后是 $[2, 2, 3]$，和原来不完全相同，因此<strong>是</strong>一个好数组，而 $[1,2,2]$ <strong>不是</strong>一个好数组。</p>\n<p>小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>误入签到，答案只有0和n两种，很好判断</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ve;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x;cin&gt;&gt;x;</span><br><span class=\"line\">\t\tve.<span class=\"built_in\">pb</span>(x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ls = <span class=\"number\">0</span>,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v:ve)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(v &lt; ls)flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tls = <span class=\"built_in\">max</span>(v,ls);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flag) cout&lt;&lt;n&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"C-小苯的数字合并-牛客小白月赛94-nowcoder-com\"><a href=\"#C-小苯的数字合并-牛客小白月赛94-nowcoder-com\" class=\"headerlink\" title=\"C-小苯的数字合并_牛客小白月赛94 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvQw==\">C-小苯的数字合并_牛客小白月赛94 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>大白熊给了小苯一个长度为 <script type=\"math/tex\">n</script> 的数组 <script type=\"math/tex\">a</script>，小苯想要<strong>最大化</strong> <script type=\"math/tex\">a</script> 的极差。</p>\n<p>具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：  </p>\n<p>$\\bullet$ 选择一个正整数 <script type=\"math/tex\">i \\ (1 \\leq i <n)</script>，接着将 <script type=\"math/tex\">a_i</script> 与 <script type=\"math/tex\">a_{i+1}</script> 合并为一个数字，结果为二者的和。</p>\n<p>（即：将 <script type=\"math/tex\">a_i</script> 变为 <script type=\"math/tex\">a_i + a_{i+1}</script>，然后删去 <script type=\"math/tex\">a_{i+1}</script>，当然操作完后 $a$ 的长度也会减一。）</p>\n<p>小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\tpre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\trep[i] = rep[i<span class=\"number\">+1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(pre[i<span class=\"number\">-1</span>] ,rep[i<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\tans = <span class=\"built_in\">max</span>(ans,mx - a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"D-小苯的排列构造-牛客小白月赛94-nowcoder-com\"><a href=\"#D-小苯的排列构造-牛客小白月赛94-nowcoder-com\" class=\"headerlink\" title=\"D-小苯的排列构造_牛客小白月赛94 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRA==\">D-小苯的排列构造_牛客小白月赛94 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>格格有一个长度为 <script type=\"math/tex\">n</script> 的排列 <script type=\"math/tex\">p</script>，但她不记得 <script type=\"math/tex\">p</script> 具体的样子，她只记得数组 <script type=\"math/tex\">a</script>。<br>其中：<script type=\"math/tex\">a_i = gcd(p_1, p_2,...,p_i)</script>，也就是说，<script type=\"math/tex\">a_i</script> 表示排列 <script type=\"math/tex\">p</script> 中前 <script type=\"math/tex\">i</script> 个数字的最大公约数。  </p>\n<p>现在，她希望小苯将排列 <script type=\"math/tex\">p</script> 复原出来，请你帮帮他吧。</p>\n<p>（但有可能无解，这意味着格格给出的 <script type=\"math/tex\">a</script> 数组可能是不正确的，此时输出 <script type=\"math/tex\">-1</script> 即可。）</p>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。</p>\n<p>如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。</p>\n<p>如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可</p>\n<p>注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i &gt; <span class=\"number\">1</span> &amp;&amp; a[i<span class=\"number\">-1</span>] % a[i] != <span class=\"number\">0</span>) f = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = <span class=\"number\">1</span>, s = a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; n &amp;&amp; a[i<span class=\"number\">+1</span>] == a[i])i ++,c ++;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(c &amp;&amp; t &lt;= n) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(st[t]) t+=s;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &gt; n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tves.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">\t\t\tst[t] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;t&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tt+=s,c--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c) &#123;f = <span class=\"number\">0</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ves) cout&lt;&lt;v&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"E-小苯的01背包（easy）-牛客小白月赛94-nowcoder-com\"><a href=\"#E-小苯的01背包（easy）-牛客小白月赛94-nowcoder-com\" class=\"headerlink\" title=\"E-小苯的01背包（easy）_牛客小白月赛94 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRQ==\">E-小苯的01背包（easy）_牛客小白月赛94 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"F-小苯的01背包（hard）-牛客小白月赛94-nowcoder-com\"><a href=\"#F-小苯的01背包（hard）-牛客小白月赛94-nowcoder-com\" class=\"headerlink\" title=\"F-小苯的01背包（hard）_牛客小白月赛94 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRg==\">F-小苯的01背包（hard）_牛客小白月赛94 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意-3\"><a href=\"#题意-3\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p><strong>注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。</strong>  </p>\n<p>小苯有一个容量为 $k$ 的背包，现在有 $n$ 个物品，每个物品有一个体积 $v$ 和价值 $w$，他想知道在体积不超过 $k$ 的前提下，他最多能装价值为多少的物品。</p>\n<p>本问题中，物品的总体积定义为所装物品的体积的 $\\&amp;$（按位与），总价值也定义为所装物品的价值的 $\\&amp;$（按位与）。</p>\n<p>（如果不选物品，则价值为 0，所占体积也为 0。）</p>\n<h3 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）</p>\n<p>比如对于二进制下物品价值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">101101</span><br><span class=\"line\">110010</span><br><span class=\"line\">101011</span><br><span class=\"line\">110110</span><br></pre></td></tr></table></figure>\n<p>不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。</p>\n<p>构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑<script type=\"math/tex\">O(n\\times 4e3)</script>即可，注意初始状态为(1&lt;&lt;14)-1，但是这样跑出来是过93%，哪里有问题？</p>\n<p>一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。</p>\n<p>官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">2000</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> V = (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">20</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((i &amp; w[j]) == i) &#123;</span><br><span class=\"line\">                V &amp;= v[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (V &lt;= k)</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不得不说这个写法更简洁也更正确</p>\n<p>hard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, j, k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class=\"line\">        q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(&#123;w[i], v[i]&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ww = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> now = q[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; now; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> x = q[<span class=\"number\">0</span>].<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((x.y &gt;&gt; i) &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">1</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">                ww &amp;= x.x;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ww &lt;= k) &#123;</span><br><span class=\"line\">            ans |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!q[<span class=\"number\">0</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q[<span class=\"number\">1</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(q[<span class=\"number\">1</span>].<span class=\"built_in\">front</span>());</span><br><span class=\"line\">            q[<span class=\"number\">1</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":1738,"excerpt":"<h2 id=\"B-小苯的好数组-牛客小白月赛94-nowcoder-com\"><a href=\"#B-小苯的好数组-牛客小白月赛94-nowcoder-com\" class=\"headerlink\" title=\"B-小苯的好数组_牛客小白月赛94 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvQg==\">B-小苯的好数组_牛客小白月赛94 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2>","more":"<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>大白熊给了小苯一个长度为 $n$ 的数组 $a$，这次他希望小苯从数组中选择一个<strong>子序列</strong>（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。  </p>\n<p>大白熊定义好数组是：如果一个数组按升序排序后和原来<strong>不完全相同</strong>，则其是一个好数组。例如 $[3,2,2]$ 升序排序后是 $[2, 2, 3]$，和原来不完全相同，因此<strong>是</strong>一个好数组，而 $[1,2,2]$ <strong>不是</strong>一个好数组。</p>\n<p>小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>误入签到，答案只有0和n两种，很好判断</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ve;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x;cin&gt;&gt;x;</span><br><span class=\"line\">\t\tve.<span class=\"built_in\">pb</span>(x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ls = <span class=\"number\">0</span>,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v:ve)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(v &lt; ls)flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tls = <span class=\"built_in\">max</span>(v,ls);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flag) cout&lt;&lt;n&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"C-小苯的数字合并-牛客小白月赛94-nowcoder-com\"><a href=\"#C-小苯的数字合并-牛客小白月赛94-nowcoder-com\" class=\"headerlink\" title=\"C-小苯的数字合并_牛客小白月赛94 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvQw==\">C-小苯的数字合并_牛客小白月赛94 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>大白熊给了小苯一个长度为 <script type=\"math/tex\">n</script> 的数组 <script type=\"math/tex\">a</script>，小苯想要<strong>最大化</strong> <script type=\"math/tex\">a</script> 的极差。</p>\n<p>具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：  </p>\n<p>$\\bullet$ 选择一个正整数 <script type=\"math/tex\">i \\ (1 \\leq i <n)</script>，接着将 <script type=\"math/tex\">a_i</script> 与 <script type=\"math/tex\">a_{i+1}</script> 合并为一个数字，结果为二者的和。</p>\n<p>（即：将 <script type=\"math/tex\">a_i</script> 变为 <script type=\"math/tex\">a_i + a_{i+1}</script>，然后删去 <script type=\"math/tex\">a_{i+1}</script>，当然操作完后 $a$ 的长度也会减一。）</p>\n<p>小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\tpre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\trep[i] = rep[i<span class=\"number\">+1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(pre[i<span class=\"number\">-1</span>] ,rep[i<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\tans = <span class=\"built_in\">max</span>(ans,mx - a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"D-小苯的排列构造-牛客小白月赛94-nowcoder-com\"><a href=\"#D-小苯的排列构造-牛客小白月赛94-nowcoder-com\" class=\"headerlink\" title=\"D-小苯的排列构造_牛客小白月赛94 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRA==\">D-小苯的排列构造_牛客小白月赛94 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>格格有一个长度为 <script type=\"math/tex\">n</script> 的排列 <script type=\"math/tex\">p</script>，但她不记得 <script type=\"math/tex\">p</script> 具体的样子，她只记得数组 <script type=\"math/tex\">a</script>。<br>其中：<script type=\"math/tex\">a_i = gcd(p_1, p_2,...,p_i)</script>，也就是说，<script type=\"math/tex\">a_i</script> 表示排列 <script type=\"math/tex\">p</script> 中前 <script type=\"math/tex\">i</script> 个数字的最大公约数。  </p>\n<p>现在，她希望小苯将排列 <script type=\"math/tex\">p</script> 复原出来，请你帮帮他吧。</p>\n<p>（但有可能无解，这意味着格格给出的 <script type=\"math/tex\">a</script> 数组可能是不正确的，此时输出 <script type=\"math/tex\">-1</script> 即可。）</p>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。</p>\n<p>如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。</p>\n<p>如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可</p>\n<p>注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i &gt; <span class=\"number\">1</span> &amp;&amp; a[i<span class=\"number\">-1</span>] % a[i] != <span class=\"number\">0</span>) f = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = <span class=\"number\">1</span>, s = a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; n &amp;&amp; a[i<span class=\"number\">+1</span>] == a[i])i ++,c ++;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(c &amp;&amp; t &lt;= n) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(st[t]) t+=s;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &gt; n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tves.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">\t\t\tst[t] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;t&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tt+=s,c--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c) &#123;f = <span class=\"number\">0</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ves) cout&lt;&lt;v&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"E-小苯的01背包（easy）-牛客小白月赛94-nowcoder-com\"><a href=\"#E-小苯的01背包（easy）-牛客小白月赛94-nowcoder-com\" class=\"headerlink\" title=\"E-小苯的01背包（easy）_牛客小白月赛94 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRQ==\">E-小苯的01背包（easy）_牛客小白月赛94 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"F-小苯的01背包（hard）-牛客小白月赛94-nowcoder-com\"><a href=\"#F-小苯的01背包（hard）-牛客小白月赛94-nowcoder-com\" class=\"headerlink\" title=\"F-小苯的01背包（hard）_牛客小白月赛94 (nowcoder.com)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRg==\">F-小苯的01背包（hard）_牛客小白月赛94 (nowcoder.com)<i class=\"fa fa-external-link-alt\"></i></span></h2><h3 id=\"题意-3\"><a href=\"#题意-3\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p><strong>注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。</strong>  </p>\n<p>小苯有一个容量为 $k$ 的背包，现在有 $n$ 个物品，每个物品有一个体积 $v$ 和价值 $w$，他想知道在体积不超过 $k$ 的前提下，他最多能装价值为多少的物品。</p>\n<p>本问题中，物品的总体积定义为所装物品的体积的 $\\&amp;$（按位与），总价值也定义为所装物品的价值的 $\\&amp;$（按位与）。</p>\n<p>（如果不选物品，则价值为 0，所占体积也为 0。）</p>\n<h3 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）</p>\n<p>比如对于二进制下物品价值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">101101</span><br><span class=\"line\">110010</span><br><span class=\"line\">101011</span><br><span class=\"line\">110110</span><br></pre></td></tr></table></figure>\n<p>不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。</p>\n<p>构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑<script type=\"math/tex\">O(n\\times 4e3)</script>即可，注意初始状态为(1&lt;&lt;14)-1，但是这样跑出来是过93%，哪里有问题？</p>\n<p>一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。</p>\n<p>官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">2000</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> V = (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">20</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((i &amp; w[j]) == i) &#123;</span><br><span class=\"line\">                V &amp;= v[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (V &lt;= k)</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不得不说这个写法更简洁也更正确</p>\n<p>hard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, j, k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class=\"line\">        q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(&#123;w[i], v[i]&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ww = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> now = q[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; now; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> x = q[<span class=\"number\">0</span>].<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((x.y &gt;&gt; i) &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">1</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">                ww &amp;= x.x;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ww &lt;= k) &#123;</span><br><span class=\"line\">            ans |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!q[<span class=\"number\">0</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q[<span class=\"number\">1</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(q[<span class=\"number\">1</span>].<span class=\"built_in\">front</span>());</span><br><span class=\"line\">            q[<span class=\"number\">1</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"abc353","date":"2024-08-14T11:46:31.000Z","_content":"\n[abc353 (atcoder.jp)](https://atcoder.jp/contests/abc353/tasks)\n\n## **C- Sigma Problem**\n\n<!--more-->\n\n第一个记录的abcC题\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 为 $$(x + y)$ 除以 $$10^8$ 的余数。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n### 题解\n\n注意题目并非是完全模运算，注意到$N\\times N\\times A_i$刚刚好在longlong 边界上。并且$A_i\\times A_i$ 最多减少一次Mod，我们只需要找出mod1e8的次数即可。\n\n刚刚开始我想的是二分，但实际上对于\n\n```text\n1 50000000 5000000 9999999 9999999 999999 999999 999999 \n```\n\n\n\n这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。\n\n我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。\n\ncode\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint cnt = 0;\n\tfor(int i=1,j=n;i<=n;i++)\n\t{\n\t\twhile(i<j && a[i] + a[j] >= MOD) j--;\n\t\tcnt += min(n-i,n-j);\n\t\t// cout<<i<<' '<<j<<endl;\n\t}\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tsum *= (n-1);\n\t// cout<<sum<<endl;\n\n\tcout<<sum - cnt * MOD<<endl;\n}\n```\n\n## **D - Another Sigma Problem**\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 如下：\n\n- 将 $$x$$ 和 $z$ 的十进制表示解释为字符串，并按此顺序连接，得到字符串 $$z$$ 。将 $$f(x, y)$$ 解释为十进制整数时，其值就是 $$z$$ 的值。\n\n例如， $$f(3, 14) = 314$$ 和 $$f(100, 1) = 1001$$ 。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式取模 $998244353$ 的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n\n### 题解\n\n写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。\n\n下面是代码code\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tint t= a[i].x,s=0;\n\t\twhile(t){\n\t\t\ts++;\n\t\t\tt/=10;\n\t\t}\n\t\ta[i].y = s;\n\t}\n\n\tfor(int i=n;i;i--){\n\t\trep[i] = (rep[i+1] + qmi(10,a[i].y)) % MOD;\n\t\t// cout<<rep[i]<<' '; \n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans = (ans + (rep[i+1] + (i-1)) * a[i].x % MOD) % MOD;\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## **E - Yet Another Sigma Problem**\n\n### 题意\n\n对于字符串 $x$ 和 $y$ ，定义 $$f(x, y)$$ 如下：\n\n- $$f(x, y)$$ 是 $$x$$ 和 $$y$$ 的最长公共前缀的长度。\n\n给你一个由小写英文字母组成的 $N$ 字符串 $$(S_1, \\ldots, S_N)$$ 。求以下表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)$$ .\n\n### 题解\n\n还是注意到同样的$O(N^2)$是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。\n\n很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案\n\n```cpp\nint build(string& s){\n\tint p = 0;\n\tint last = -1 ,res = 0;\n\tfor(int i=0;i<s.size();i++){\n\t\tint ip = s[i] - 'a';\n\t\t// cout<<ip<<endl;\n\t\tif(!son[p][ip]) son[p][ip] = ++idx;\n\t\t// cout<<s<< \"====\"<<last<< ' ' << cnt[son[p][ip]]<<nline;\n\t\tif(last == -1) last = cnt[son[p][ip]];\n\t\tif(cnt[son[p][ip]]!= last){\n\t\t\tres += (last - cnt[son[p][ip]]) * i;\n\t\t\tlast = cnt[son[p][ip]];\n\t\t}\n\t\tcnt[son[p][ip]]++;\n\t\tp = son[p][ip];\n\t}\n\tif(cnt[p]!=1){\n\t\tres +=(cnt[p] - 1)*s.size();\n\t}\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>s[i];\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans += build(s[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## **F - Tile Distance**\n\n### 题意\n\n#### 问题陈述\n\n瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 $$1\\times1$$ 的小瓦片和尺寸为 $$K\\times K$$ 的大瓦片，它们按以下规则摆放：\n\n- 对于每一对整数 $(i,j)$ ，正方形 $$\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge j\\leq y\\leq j+1\\rbrace$$ 要么包含在一块小方砖中，要么包含在一块大方砖中。\n    - 如果 $$\\left\\lfloor\\dfrac iK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor$$ 是偶数，则它包含在一个小方格中。\n    - 否则，它被包含在一个大瓦片中。\n\n瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。\n\n例如，当 $K=3$ 时，瓦片的布局如下：\n\n![](https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png)\n\n高桥开始于坐标平面上的点 $$(S_x+0.5,S_y+0.5)$$ 。\n\n他可以重复下面的动作任意多次：\n\n- 选择一个方向（上、下、左或右）和一个正整数 $$n$$ 。向该方向移动 $n$ 个单位。\n\n每次他从一张牌移动到另一张牌时，必须支付 $1$ 的过路费。\n\n求高桥到达点 $$(T_x+0.5,T_y+0.5)$$​ 所需的最小通行费。\n\n### 题解\n\n首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。\n\n然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。\n\n可以发现，不断走最大瓷砖是最优的。                  \n\n![70275E94F5C12B97C927177CEB804E4C](https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg)\n\n即上图所示的路径是最短的。\n\n显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：\n$$\ndistance = \\frac{d_s-d_a}{k} \\times 2 -1\n$$\n其中定义$$d_s$$为走过直线长度，$$d_a$$ 为两端长度，保证$$d_s - d_a \\equiv k$$​\n\n可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即$$\\frac{2}{k}$$，再减去$$1$$\n\n但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。\n\n根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k>=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。\n\n最后的结果形式上是切比雪夫距离\n\n于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小\n\n```cpp\nvoid slove() {\n\tlong k,sx,sy,tx,ty;\n\tcin>>k;\n\tcin>>sx>>sy;\n\tcin>>tx>>ty;\n\tlong ans=LLINF;\n\tint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\tfor(int i=0;i<4;++i)for(int j=0;j<4;++j)\n\t{\n\t\tlong x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=0;\n\t\tif((x+y)%2==0&&(X+Y)%2==0&&x==X&&y==Y)ans=min(ans,abs(sx-tx)+abs(sy-ty));\n\t\tif((x+y)%2==0)\n\t\t{\n\t\t\tif(dx[i]==-1)c+=sx-x*k+1;\n\t\t\tif(dx[i]==1)c+=k*(long)(x+1)-sx;\n\t\t\tif(dy[i]==-1)c+=sy-y*k+1;\n\t\t\tif(dy[i]==1)c+=k*(long)(y+1)-sy;\n\t\t\tif(k!=1)x+=dx[i],y+=dy[i];\n\t\t}\n\t\tif((X+Y)%2==0)\n\t\t{\n\t\t\tif(dx[j]==-1)c+=tx-X*k+1;\n\t\t\tif(dx[j]==1)c+=k*(long)(X+1)-tx;\n\t\t\tif(dy[j]==-1)c+=ty-Y*k+1;\n\t\t\tif(dy[j]==1)c+=k*(long)(Y+1)-ty;\n\t\t\tif(k!=1)X+=dx[j],Y+=dy[j];\n\t\t}\n\t\tif(k==1)c=abs(x-X)+abs(y-Y);\n\t\telse if(k==2)\n\t\t{\n\t\t\tlong d=min(abs(x-X),abs(y-Y));\n\t\t\tc+=d*(long)2;\n\t\t\tc+=(abs(x-X)-d)*(long)3/(long)2;\n\t\t\tc+=(abs(y-Y)-d)*(long)3/(long)2;\n\t\t}\n\t\telse c+=max(abs(x-X),abs(y-Y))*(long)2;\n\t\tans=min(ans,c);\n\t}\n\tcout<<ans;\n}\n```\n\n## **G - Merchant Takahashi**\n\n### 题意\n\nAtCoder 王国有 $N$ 个城镇：城镇 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。从 $i$ 镇到 $j$ 镇，必须支付 $C \\times |i-j|$ 日元的过路费。\n\n商人高桥正在考虑参加 $M$ 个或更多即将到来的市场。\n\n$i$ /-市场 $$(1 \\leq i \\leq M)$$ 由一对整数 $$(T_i, P_i)$$ 描述，其中市场在城镇 $$T_i$$ 举行，如果他参加将赚取 $$P_i$$ 日元。\n\n对于所有 $$1 \\leq i < M$$ ， $$i$$ 次市场在 $$(i+1)$$ 次市场开始之前结束。他移动的时间可以忽略不计。\n\n他从 $$10^{10^{100}}$$ 日元开始，最初在 $$1$$ 镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。\n\n形式上，如果他在 $$M$$ 个市场后获得最大资金额，那么 $$10^{10^{100}} + X$$ 就是他的最终资金额。求 $$X$$ 。\n\n### 题解\n\n显然的dp问题，如果你看不出来这是个dp问题建议你看一看[再看最著名的 NP 问题之 TSP 旅行商问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/659884622)，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。\n\n详细到这一题，很简单的状态表示为\n$$\nf_i:到i城的最大profit\n$$\n状态转移为：\n$$\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}\n$$\n对绝对值正负进行分类\n$$\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}\n$$\n提出取最大中的常数项：\n$$\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C\n$$\n接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。\n\n```cpp\n\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = -LLINF; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = -LLINF,ri = -LLINF;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>c;\n\tcin>>m;\n\tbuild(1,n,1,tr1);\n\tbuild(1,n,1,tr2);\n\n\tmodify(1,c,1,tr1);\n\tmodify(1,-c,1,tr2);\n\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>t[i]>>p[i];\n\t\tint l = query(1,t[i],1,tr1);\n\t\tint r = query(t[i],n,1,tr2);\n\t\t// cout<<l<<' '<<r<<endl;\n\t\tint mx = max(l+p[i]-t[i]*c,r+p[i]+t[i]*c);\n\t\tf[t[i]] = mx;\n\t\t// cout<<t[i]<< ' ' <<f[t[i]]<<nline;\n\t\tmodify(t[i],f[t[i]] + t[i] * c,1,tr1);\n\t\tmodify(t[i],f[t[i]] - t[i] * c,1,tr2);\n\t}\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) ans =max(ans,f[i]);\n\n\tcout<<ans<<endl;\n\treturn ;\n}\n```\n\n","source":"_posts/abc353.md","raw":"---\ntitle: abc353\ndate: 2024-08-14 19:46:31\ntags: [算法, 思维题, 模运算]\ncategories: \n\t- 算法\n\t- 思维题\n\t- 模运算\n---\n\n[abc353 (atcoder.jp)](https://atcoder.jp/contests/abc353/tasks)\n\n## **C- Sigma Problem**\n\n<!--more-->\n\n第一个记录的abcC题\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 为 $$(x + y)$ 除以 $$10^8$ 的余数。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n### 题解\n\n注意题目并非是完全模运算，注意到$N\\times N\\times A_i$刚刚好在longlong 边界上。并且$A_i\\times A_i$ 最多减少一次Mod，我们只需要找出mod1e8的次数即可。\n\n刚刚开始我想的是二分，但实际上对于\n\n```text\n1 50000000 5000000 9999999 9999999 999999 999999 999999 \n```\n\n\n\n这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。\n\n我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。\n\ncode\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint cnt = 0;\n\tfor(int i=1,j=n;i<=n;i++)\n\t{\n\t\twhile(i<j && a[i] + a[j] >= MOD) j--;\n\t\tcnt += min(n-i,n-j);\n\t\t// cout<<i<<' '<<j<<endl;\n\t}\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tsum *= (n-1);\n\t// cout<<sum<<endl;\n\n\tcout<<sum - cnt * MOD<<endl;\n}\n```\n\n## **D - Another Sigma Problem**\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 如下：\n\n- 将 $$x$$ 和 $z$ 的十进制表示解释为字符串，并按此顺序连接，得到字符串 $$z$$ 。将 $$f(x, y)$$ 解释为十进制整数时，其值就是 $$z$$ 的值。\n\n例如， $$f(3, 14) = 314$$ 和 $$f(100, 1) = 1001$$ 。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式取模 $998244353$ 的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n\n### 题解\n\n写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。\n\n下面是代码code\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tint t= a[i].x,s=0;\n\t\twhile(t){\n\t\t\ts++;\n\t\t\tt/=10;\n\t\t}\n\t\ta[i].y = s;\n\t}\n\n\tfor(int i=n;i;i--){\n\t\trep[i] = (rep[i+1] + qmi(10,a[i].y)) % MOD;\n\t\t// cout<<rep[i]<<' '; \n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans = (ans + (rep[i+1] + (i-1)) * a[i].x % MOD) % MOD;\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## **E - Yet Another Sigma Problem**\n\n### 题意\n\n对于字符串 $x$ 和 $y$ ，定义 $$f(x, y)$$ 如下：\n\n- $$f(x, y)$$ 是 $$x$$ 和 $$y$$ 的最长公共前缀的长度。\n\n给你一个由小写英文字母组成的 $N$ 字符串 $$(S_1, \\ldots, S_N)$$ 。求以下表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)$$ .\n\n### 题解\n\n还是注意到同样的$O(N^2)$是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。\n\n很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案\n\n```cpp\nint build(string& s){\n\tint p = 0;\n\tint last = -1 ,res = 0;\n\tfor(int i=0;i<s.size();i++){\n\t\tint ip = s[i] - 'a';\n\t\t// cout<<ip<<endl;\n\t\tif(!son[p][ip]) son[p][ip] = ++idx;\n\t\t// cout<<s<< \"====\"<<last<< ' ' << cnt[son[p][ip]]<<nline;\n\t\tif(last == -1) last = cnt[son[p][ip]];\n\t\tif(cnt[son[p][ip]]!= last){\n\t\t\tres += (last - cnt[son[p][ip]]) * i;\n\t\t\tlast = cnt[son[p][ip]];\n\t\t}\n\t\tcnt[son[p][ip]]++;\n\t\tp = son[p][ip];\n\t}\n\tif(cnt[p]!=1){\n\t\tres +=(cnt[p] - 1)*s.size();\n\t}\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>s[i];\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans += build(s[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## **F - Tile Distance**\n\n### 题意\n\n#### 问题陈述\n\n瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 $$1\\times1$$ 的小瓦片和尺寸为 $$K\\times K$$ 的大瓦片，它们按以下规则摆放：\n\n- 对于每一对整数 $(i,j)$ ，正方形 $$\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge j\\leq y\\leq j+1\\rbrace$$ 要么包含在一块小方砖中，要么包含在一块大方砖中。\n    - 如果 $$\\left\\lfloor\\dfrac iK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor$$ 是偶数，则它包含在一个小方格中。\n    - 否则，它被包含在一个大瓦片中。\n\n瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。\n\n例如，当 $K=3$ 时，瓦片的布局如下：\n\n![](https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png)\n\n高桥开始于坐标平面上的点 $$(S_x+0.5,S_y+0.5)$$ 。\n\n他可以重复下面的动作任意多次：\n\n- 选择一个方向（上、下、左或右）和一个正整数 $$n$$ 。向该方向移动 $n$ 个单位。\n\n每次他从一张牌移动到另一张牌时，必须支付 $1$ 的过路费。\n\n求高桥到达点 $$(T_x+0.5,T_y+0.5)$$​ 所需的最小通行费。\n\n### 题解\n\n首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。\n\n然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。\n\n可以发现，不断走最大瓷砖是最优的。                  \n\n![70275E94F5C12B97C927177CEB804E4C](https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg)\n\n即上图所示的路径是最短的。\n\n显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：\n$$\ndistance = \\frac{d_s-d_a}{k} \\times 2 -1\n$$\n其中定义$$d_s$$为走过直线长度，$$d_a$$ 为两端长度，保证$$d_s - d_a \\equiv k$$​\n\n可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即$$\\frac{2}{k}$$，再减去$$1$$\n\n但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。\n\n根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k>=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。\n\n最后的结果形式上是切比雪夫距离\n\n于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小\n\n```cpp\nvoid slove() {\n\tlong k,sx,sy,tx,ty;\n\tcin>>k;\n\tcin>>sx>>sy;\n\tcin>>tx>>ty;\n\tlong ans=LLINF;\n\tint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\tfor(int i=0;i<4;++i)for(int j=0;j<4;++j)\n\t{\n\t\tlong x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=0;\n\t\tif((x+y)%2==0&&(X+Y)%2==0&&x==X&&y==Y)ans=min(ans,abs(sx-tx)+abs(sy-ty));\n\t\tif((x+y)%2==0)\n\t\t{\n\t\t\tif(dx[i]==-1)c+=sx-x*k+1;\n\t\t\tif(dx[i]==1)c+=k*(long)(x+1)-sx;\n\t\t\tif(dy[i]==-1)c+=sy-y*k+1;\n\t\t\tif(dy[i]==1)c+=k*(long)(y+1)-sy;\n\t\t\tif(k!=1)x+=dx[i],y+=dy[i];\n\t\t}\n\t\tif((X+Y)%2==0)\n\t\t{\n\t\t\tif(dx[j]==-1)c+=tx-X*k+1;\n\t\t\tif(dx[j]==1)c+=k*(long)(X+1)-tx;\n\t\t\tif(dy[j]==-1)c+=ty-Y*k+1;\n\t\t\tif(dy[j]==1)c+=k*(long)(Y+1)-ty;\n\t\t\tif(k!=1)X+=dx[j],Y+=dy[j];\n\t\t}\n\t\tif(k==1)c=abs(x-X)+abs(y-Y);\n\t\telse if(k==2)\n\t\t{\n\t\t\tlong d=min(abs(x-X),abs(y-Y));\n\t\t\tc+=d*(long)2;\n\t\t\tc+=(abs(x-X)-d)*(long)3/(long)2;\n\t\t\tc+=(abs(y-Y)-d)*(long)3/(long)2;\n\t\t}\n\t\telse c+=max(abs(x-X),abs(y-Y))*(long)2;\n\t\tans=min(ans,c);\n\t}\n\tcout<<ans;\n}\n```\n\n## **G - Merchant Takahashi**\n\n### 题意\n\nAtCoder 王国有 $N$ 个城镇：城镇 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。从 $i$ 镇到 $j$ 镇，必须支付 $C \\times |i-j|$ 日元的过路费。\n\n商人高桥正在考虑参加 $M$ 个或更多即将到来的市场。\n\n$i$ /-市场 $$(1 \\leq i \\leq M)$$ 由一对整数 $$(T_i, P_i)$$ 描述，其中市场在城镇 $$T_i$$ 举行，如果他参加将赚取 $$P_i$$ 日元。\n\n对于所有 $$1 \\leq i < M$$ ， $$i$$ 次市场在 $$(i+1)$$ 次市场开始之前结束。他移动的时间可以忽略不计。\n\n他从 $$10^{10^{100}}$$ 日元开始，最初在 $$1$$ 镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。\n\n形式上，如果他在 $$M$$ 个市场后获得最大资金额，那么 $$10^{10^{100}} + X$$ 就是他的最终资金额。求 $$X$$ 。\n\n### 题解\n\n显然的dp问题，如果你看不出来这是个dp问题建议你看一看[再看最著名的 NP 问题之 TSP 旅行商问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/659884622)，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。\n\n详细到这一题，很简单的状态表示为\n$$\nf_i:到i城的最大profit\n$$\n状态转移为：\n$$\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}\n$$\n对绝对值正负进行分类\n$$\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}\n$$\n提出取最大中的常数项：\n$$\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C\n$$\n接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。\n\n```cpp\n\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = -LLINF; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = -LLINF,ri = -LLINF;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>c;\n\tcin>>m;\n\tbuild(1,n,1,tr1);\n\tbuild(1,n,1,tr2);\n\n\tmodify(1,c,1,tr1);\n\tmodify(1,-c,1,tr2);\n\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>t[i]>>p[i];\n\t\tint l = query(1,t[i],1,tr1);\n\t\tint r = query(t[i],n,1,tr2);\n\t\t// cout<<l<<' '<<r<<endl;\n\t\tint mx = max(l+p[i]-t[i]*c,r+p[i]+t[i]*c);\n\t\tf[t[i]] = mx;\n\t\t// cout<<t[i]<< ' ' <<f[t[i]]<<nline;\n\t\tmodify(t[i],f[t[i]] + t[i] * c,1,tr1);\n\t\tmodify(t[i],f[t[i]] - t[i] * c,1,tr2);\n\t}\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) ans =max(ans,f[i]);\n\n\tcout<<ans<<endl;\n\treturn ;\n}\n```\n\n","slug":"abc353","published":1,"updated":"2024-08-15T04:51:26.275Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9x000w2wwvgqa55m28","content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1My90YXNrcw==\">abc353 (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"C-Sigma-Problem\"><a href=\"#C-Sigma-Problem\" class=\"headerlink\" title=\"C- Sigma Problem\"></a><strong>C- Sigma Problem</strong></h2><span id=\"more\"></span>\n<p>第一个记录的abcC题</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>对于正整数 <script type=\"math/tex\">x</script> 和 <script type=\"math/tex\">y</script> ，定义 <script type=\"math/tex\">f(x, y)</script> 为 <script type=\"math/tex\">(x + y)$ 除以</script>10^8$ 的余数。</p>\n<p>给你一个长度为 $N$ 的正整数序列 <script type=\"math/tex\">A = (A_1, \\ldots, A_N)</script> 。求下面表达式的值：</p>\n<script type=\"math/tex; mode=display\">\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n### 题解\n\n注意题目并非是完全模运算，注意到$N\\times N\\times A_i$刚刚好在longlong 边界上。并且$A_i\\times A_i$ 最多减少一次Mod，我们只需要找出mod1e8的次数即可。\n\n刚刚开始我想的是二分，但实际上对于\n\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 50000000 5000000 9999999 9999999 999999 999999 999999 </span><br></pre></td></tr></table></figure>\n\n\n\n这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。\n\n我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。\n\ncode\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=n;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i&lt;j &amp;&amp; a[i] + a[j] &gt;= MOD) j--;</span><br><span class=\"line\">\t\tcnt += <span class=\"built_in\">min</span>(n-i,n-j);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tsum *= (n<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum - cnt * MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n## **D - Another Sigma Problem**\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 如下：\n\n- 将 $$x$$ 和 $z$ 的十进制表示解释为字符串，并按此顺序连接，得到字符串 $$z$$ 。将 $$f(x, y)$$ 解释为十进制整数时，其值就是 $$z$$ 的值。\n\n例如， $$f(3, 14) = 314$$ 和 $$f(100, 1) = 1001$$ 。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式取模 $998244353$ 的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n\n### 题解\n\n写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。\n\n下面是代码code\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t= a[i].x,s=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(t)&#123;</span><br><span class=\"line\">\t\t\ts++;</span><br><span class=\"line\">\t\t\tt/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ta[i].y = s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\trep[i] = (rep[i<span class=\"number\">+1</span>] + <span class=\"built_in\">qmi</span>(<span class=\"number\">10</span>,a[i].y)) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;rep[i]&lt;&lt;&#x27; &#x27;; </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans = (ans + (rep[i<span class=\"number\">+1</span>] + (i<span class=\"number\">-1</span>)) * a[i].x % MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n## **E - Yet Another Sigma Problem**\n\n### 题意\n\n对于字符串 $x$ 和 $y$ ，定义 $$f(x, y)$$ 如下：\n\n- $$f(x, y)$$ 是 $$x$$ 和 $$y$$ 的最长公共前缀的长度。\n\n给你一个由小写英文字母组成的 $N$ 字符串 $$(S_1, \\ldots, S_N)$$ 。求以下表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)$$ .\n\n### 题解\n\n还是注意到同样的$O(N^2)$是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。\n\n很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">build</span><span class=\"params\">(string&amp; s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> last = <span class=\"number\">-1</span> ,res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ip = s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ip&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!son[p][ip]) son[p][ip] = ++idx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;s&lt;&lt; &quot;====&quot;&lt;&lt;last&lt;&lt; &#x27; &#x27; &lt;&lt; cnt[son[p][ip]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(last == <span class=\"number\">-1</span>) last = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt[son[p][ip]]!= last)&#123;</span><br><span class=\"line\">\t\t\tres += (last - cnt[son[p][ip]]) * i;</span><br><span class=\"line\">\t\t\tlast = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt[son[p][ip]]++;</span><br><span class=\"line\">\t\tp = son[p][ip];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(cnt[p]!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tres +=(cnt[p] - <span class=\"number\">1</span>)*s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;s[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans += <span class=\"built_in\">build</span>(s[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n## **F - Tile Distance**\n\n### 题意\n\n#### 问题陈述\n\n瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 $$1\\times1$$ 的小瓦片和尺寸为 $$K\\times K$$ 的大瓦片，它们按以下规则摆放：\n\n- 对于每一对整数 $(i,j)$ ，正方形 $$\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge j\\leq y\\leq j+1\\rbrace$$ 要么包含在一块小方砖中，要么包含在一块大方砖中。\n    - 如果 $$\\left\\lfloor\\dfrac iK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor$$ 是偶数，则它包含在一个小方格中。\n    - 否则，它被包含在一个大瓦片中。\n\n瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。\n\n例如，当 $K=3$ 时，瓦片的布局如下：\n\n![](https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png)\n\n高桥开始于坐标平面上的点 $$(S_x+0.5,S_y+0.5)$$ 。\n\n他可以重复下面的动作任意多次：\n\n- 选择一个方向（上、下、左或右）和一个正整数 $$n$$ 。向该方向移动 $n$ 个单位。\n\n每次他从一张牌移动到另一张牌时，必须支付 $1$ 的过路费。\n\n求高桥到达点 $$(T_x+0.5,T_y+0.5)$$​ 所需的最小通行费。\n\n### 题解\n\n首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。\n\n然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。\n\n可以发现，不断走最大瓷砖是最优的。                  \n\n![70275E94F5C12B97C927177CEB804E4C](https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg)\n\n即上图所示的路径是最短的。\n\n显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：</script><p>distance = \\frac{d_s-d_a}{k} \\times 2 -1</p>\n<script type=\"math/tex; mode=display\">\n其中定义$$d_s$$为走过直线长度，$$d_a$$ 为两端长度，保证$$d_s - d_a \\equiv k$$​\n\n可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即$$\\frac{2}{k}$$，再减去$$1</script><p>但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。</p>\n<p>根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k&gt;=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。</p>\n<p>最后的结果形式上是切比雪夫距离</p>\n<p>于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> k,sx,sy,tx,ty;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\tcin&gt;&gt;sx&gt;&gt;sy;</span><br><span class=\"line\">\tcin&gt;&gt;tx&gt;&gt;ty;</span><br><span class=\"line\">\t<span class=\"type\">long</span> ans=LLINF;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;++i)<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">4</span>;++j)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;(X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;x==X&amp;&amp;y==Y)ans=<span class=\"built_in\">min</span>(ans,<span class=\"built_in\">abs</span>(sx-tx)+<span class=\"built_in\">abs</span>(sy-ty));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">-1</span>)c+=sx-x*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(x<span class=\"number\">+1</span>)-sx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">-1</span>)c+=sy-y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(y<span class=\"number\">+1</span>)-sy;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)x+=dx[i],y+=dy[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">-1</span>)c+=tx-X*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(X<span class=\"number\">+1</span>)-tx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">-1</span>)c+=ty-Y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(Y<span class=\"number\">+1</span>)-ty;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)X+=dx[j],Y+=dy[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(k==<span class=\"number\">1</span>)c=<span class=\"built_in\">abs</span>(x-X)+<span class=\"built_in\">abs</span>(y-Y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k==<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">long</span> d=<span class=\"built_in\">min</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y));</span><br><span class=\"line\">\t\t\tc+=d*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(x-X)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(y-Y)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c+=<span class=\"built_in\">max</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y))*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tans=<span class=\"built_in\">min</span>(ans,c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"G-Merchant-Takahashi\"><a href=\"#G-Merchant-Takahashi\" class=\"headerlink\" title=\"G - Merchant Takahashi\"></a><strong>G - Merchant Takahashi</strong></h2><h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>AtCoder 王国有 $N$ 个城镇：城镇 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。从 $i$ 镇到 $j$ 镇，必须支付 $C \\times |i-j|$ 日元的过路费。</p>\n<p>商人高桥正在考虑参加 $M$ 个或更多即将到来的市场。</p>\n<p>$i$ /-市场 <script type=\"math/tex\">(1 \\leq i \\leq M)</script> 由一对整数 <script type=\"math/tex\">(T_i, P_i)</script> 描述，其中市场在城镇 <script type=\"math/tex\">T_i</script> 举行，如果他参加将赚取 <script type=\"math/tex\">P_i</script> 日元。</p>\n<p>对于所有 <script type=\"math/tex\">1 \\leq i < M</script> ， <script type=\"math/tex\">i</script> 次市场在 <script type=\"math/tex\">(i+1)</script> 次市场开始之前结束。他移动的时间可以忽略不计。</p>\n<p>他从 <script type=\"math/tex\">10^{10^{100}}</script> 日元开始，最初在 <script type=\"math/tex\">1</script> 镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。</p>\n<p>形式上，如果他在 <script type=\"math/tex\">M</script> 个市场后获得最大资金额，那么 <script type=\"math/tex\">10^{10^{100}} + X</script> 就是他的最终资金额。求 <script type=\"math/tex\">X</script> 。</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>显然的dp问题，如果你看不出来这是个dp问题建议你看一看<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NTk4ODQ2MjI=\">再看最著名的 NP 问题之 TSP 旅行商问题 - 知乎 (zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span>，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。</p>\n<p>详细到这一题，很简单的状态表示为</p>\n<script type=\"math/tex; mode=display\">\nf_i:到i城的最大profit</script><p>状态转移为：</p>\n<script type=\"math/tex; mode=display\">\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}</script><p>对绝对值正负进行分类</p>\n<script type=\"math/tex; mode=display\">\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}</script><p>提出取最大中的常数项：</p>\n<script type=\"math/tex; mode=display\">\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C</script><p>接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = -LLINF; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = -LLINF,ri = -LLINF;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;c;</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,-c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t[i]&gt;&gt;p[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,t[i],<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r = <span class=\"built_in\">query</span>(t[i],n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(l+p[i]-t[i]*c,r+p[i]+t[i]*c);</span><br><span class=\"line\">\t\tf[t[i]] = mx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;t[i]&lt;&lt; &#x27; &#x27; &lt;&lt;f[t[i]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] + t[i] * c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] - t[i] * c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans =<span class=\"built_in\">max</span>(ans,f[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":2758,"excerpt":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1My90YXNrcw==\">abc353 (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"C-Sigma-Problem\"><a href=\"#C-Sigma-Problem\" class=\"headerlink\" title=\"C- Sigma Problem\"></a><strong>C- Sigma Problem</strong></h2>","more":"<p>第一个记录的abcC题</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>对于正整数 <script type=\"math/tex\">x</script> 和 <script type=\"math/tex\">y</script> ，定义 <script type=\"math/tex\">f(x, y)</script> 为 <script type=\"math/tex\">(x + y)$ 除以</script>10^8$ 的余数。</p>\n<p>给你一个长度为 $N$ 的正整数序列 <script type=\"math/tex\">A = (A_1, \\ldots, A_N)</script> 。求下面表达式的值：</p>\n<script type=\"math/tex; mode=display\">\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n### 题解\n\n注意题目并非是完全模运算，注意到$N\\times N\\times A_i$刚刚好在longlong 边界上。并且$A_i\\times A_i$ 最多减少一次Mod，我们只需要找出mod1e8的次数即可。\n\n刚刚开始我想的是二分，但实际上对于\n\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 50000000 5000000 9999999 9999999 999999 999999 999999 </span><br></pre></td></tr></table></figure>\n\n\n\n这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。\n\n我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。\n\ncode\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=n;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i&lt;j &amp;&amp; a[i] + a[j] &gt;= MOD) j--;</span><br><span class=\"line\">\t\tcnt += <span class=\"built_in\">min</span>(n-i,n-j);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tsum *= (n<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum - cnt * MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n## **D - Another Sigma Problem**\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 如下：\n\n- 将 $$x$$ 和 $z$ 的十进制表示解释为字符串，并按此顺序连接，得到字符串 $$z$$ 。将 $$f(x, y)$$ 解释为十进制整数时，其值就是 $$z$$ 的值。\n\n例如， $$f(3, 14) = 314$$ 和 $$f(100, 1) = 1001$$ 。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式取模 $998244353$ 的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n\n### 题解\n\n写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。\n\n下面是代码code\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t= a[i].x,s=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(t)&#123;</span><br><span class=\"line\">\t\t\ts++;</span><br><span class=\"line\">\t\t\tt/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ta[i].y = s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\trep[i] = (rep[i<span class=\"number\">+1</span>] + <span class=\"built_in\">qmi</span>(<span class=\"number\">10</span>,a[i].y)) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;rep[i]&lt;&lt;&#x27; &#x27;; </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans = (ans + (rep[i<span class=\"number\">+1</span>] + (i<span class=\"number\">-1</span>)) * a[i].x % MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n## **E - Yet Another Sigma Problem**\n\n### 题意\n\n对于字符串 $x$ 和 $y$ ，定义 $$f(x, y)$$ 如下：\n\n- $$f(x, y)$$ 是 $$x$$ 和 $$y$$ 的最长公共前缀的长度。\n\n给你一个由小写英文字母组成的 $N$ 字符串 $$(S_1, \\ldots, S_N)$$ 。求以下表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)$$ .\n\n### 题解\n\n还是注意到同样的$O(N^2)$是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。\n\n很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">build</span><span class=\"params\">(string&amp; s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> last = <span class=\"number\">-1</span> ,res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ip = s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ip&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!son[p][ip]) son[p][ip] = ++idx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;s&lt;&lt; &quot;====&quot;&lt;&lt;last&lt;&lt; &#x27; &#x27; &lt;&lt; cnt[son[p][ip]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(last == <span class=\"number\">-1</span>) last = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt[son[p][ip]]!= last)&#123;</span><br><span class=\"line\">\t\t\tres += (last - cnt[son[p][ip]]) * i;</span><br><span class=\"line\">\t\t\tlast = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt[son[p][ip]]++;</span><br><span class=\"line\">\t\tp = son[p][ip];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(cnt[p]!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tres +=(cnt[p] - <span class=\"number\">1</span>)*s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;s[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans += <span class=\"built_in\">build</span>(s[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n## **F - Tile Distance**\n\n### 题意\n\n#### 问题陈述\n\n瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 $$1\\times1$$ 的小瓦片和尺寸为 $$K\\times K$$ 的大瓦片，它们按以下规则摆放：\n\n- 对于每一对整数 $(i,j)$ ，正方形 $$\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge j\\leq y\\leq j+1\\rbrace$$ 要么包含在一块小方砖中，要么包含在一块大方砖中。\n    - 如果 $$\\left\\lfloor\\dfrac iK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor$$ 是偶数，则它包含在一个小方格中。\n    - 否则，它被包含在一个大瓦片中。\n\n瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。\n\n例如，当 $K=3$ 时，瓦片的布局如下：\n\n![](https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png)\n\n高桥开始于坐标平面上的点 $$(S_x+0.5,S_y+0.5)$$ 。\n\n他可以重复下面的动作任意多次：\n\n- 选择一个方向（上、下、左或右）和一个正整数 $$n$$ 。向该方向移动 $n$ 个单位。\n\n每次他从一张牌移动到另一张牌时，必须支付 $1$ 的过路费。\n\n求高桥到达点 $$(T_x+0.5,T_y+0.5)$$​ 所需的最小通行费。\n\n### 题解\n\n首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。\n\n然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。\n\n可以发现，不断走最大瓷砖是最优的。                  \n\n![70275E94F5C12B97C927177CEB804E4C](https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg)\n\n即上图所示的路径是最短的。\n\n显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：</script><p>distance = \\frac{d_s-d_a}{k} \\times 2 -1</p>\n<script type=\"math/tex; mode=display\">\n其中定义$$d_s$$为走过直线长度，$$d_a$$ 为两端长度，保证$$d_s - d_a \\equiv k$$​\n\n可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即$$\\frac{2}{k}$$，再减去$$1</script><p>但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。</p>\n<p>根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k&gt;=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。</p>\n<p>最后的结果形式上是切比雪夫距离</p>\n<p>于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> k,sx,sy,tx,ty;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\tcin&gt;&gt;sx&gt;&gt;sy;</span><br><span class=\"line\">\tcin&gt;&gt;tx&gt;&gt;ty;</span><br><span class=\"line\">\t<span class=\"type\">long</span> ans=LLINF;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;++i)<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">4</span>;++j)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;(X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;x==X&amp;&amp;y==Y)ans=<span class=\"built_in\">min</span>(ans,<span class=\"built_in\">abs</span>(sx-tx)+<span class=\"built_in\">abs</span>(sy-ty));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">-1</span>)c+=sx-x*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(x<span class=\"number\">+1</span>)-sx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">-1</span>)c+=sy-y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(y<span class=\"number\">+1</span>)-sy;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)x+=dx[i],y+=dy[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">-1</span>)c+=tx-X*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(X<span class=\"number\">+1</span>)-tx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">-1</span>)c+=ty-Y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(Y<span class=\"number\">+1</span>)-ty;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)X+=dx[j],Y+=dy[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(k==<span class=\"number\">1</span>)c=<span class=\"built_in\">abs</span>(x-X)+<span class=\"built_in\">abs</span>(y-Y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k==<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">long</span> d=<span class=\"built_in\">min</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y));</span><br><span class=\"line\">\t\t\tc+=d*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(x-X)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(y-Y)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c+=<span class=\"built_in\">max</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y))*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tans=<span class=\"built_in\">min</span>(ans,c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"G-Merchant-Takahashi\"><a href=\"#G-Merchant-Takahashi\" class=\"headerlink\" title=\"G - Merchant Takahashi\"></a><strong>G - Merchant Takahashi</strong></h2><h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>AtCoder 王国有 $N$ 个城镇：城镇 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。从 $i$ 镇到 $j$ 镇，必须支付 $C \\times |i-j|$ 日元的过路费。</p>\n<p>商人高桥正在考虑参加 $M$ 个或更多即将到来的市场。</p>\n<p>$i$ /-市场 <script type=\"math/tex\">(1 \\leq i \\leq M)</script> 由一对整数 <script type=\"math/tex\">(T_i, P_i)</script> 描述，其中市场在城镇 <script type=\"math/tex\">T_i</script> 举行，如果他参加将赚取 <script type=\"math/tex\">P_i</script> 日元。</p>\n<p>对于所有 <script type=\"math/tex\">1 \\leq i < M</script> ， <script type=\"math/tex\">i</script> 次市场在 <script type=\"math/tex\">(i+1)</script> 次市场开始之前结束。他移动的时间可以忽略不计。</p>\n<p>他从 <script type=\"math/tex\">10^{10^{100}}</script> 日元开始，最初在 <script type=\"math/tex\">1</script> 镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。</p>\n<p>形式上，如果他在 <script type=\"math/tex\">M</script> 个市场后获得最大资金额，那么 <script type=\"math/tex\">10^{10^{100}} + X</script> 就是他的最终资金额。求 <script type=\"math/tex\">X</script> 。</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>显然的dp问题，如果你看不出来这是个dp问题建议你看一看<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NTk4ODQ2MjI=\">再看最著名的 NP 问题之 TSP 旅行商问题 - 知乎 (zhihu.com)<i class=\"fa fa-external-link-alt\"></i></span>，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。</p>\n<p>详细到这一题，很简单的状态表示为</p>\n<script type=\"math/tex; mode=display\">\nf_i:到i城的最大profit</script><p>状态转移为：</p>\n<script type=\"math/tex; mode=display\">\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}</script><p>对绝对值正负进行分类</p>\n<script type=\"math/tex; mode=display\">\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}</script><p>提出取最大中的常数项：</p>\n<script type=\"math/tex; mode=display\">\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C</script><p>接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = -LLINF; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = -LLINF,ri = -LLINF;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;c;</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,-c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t[i]&gt;&gt;p[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,t[i],<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r = <span class=\"built_in\">query</span>(t[i],n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(l+p[i]-t[i]*c,r+p[i]+t[i]*c);</span><br><span class=\"line\">\t\tf[t[i]] = mx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;t[i]&lt;&lt; &#x27; &#x27; &lt;&lt;f[t[i]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] + t[i] * c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] - t[i] * c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans =<span class=\"built_in\">max</span>(ans,f[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"abc354","date":"2024-08-14T11:46:31.000Z","_content":"\n##  [C - AtCoder Magics](https://atcoder.jp/contests/abc354/tasks/abc354_c)\n\n## 题意\n\n高桥有 $$N$$ 张纸牌，来自纸牌游戏 \"AtCoder Magics\"。其中的 $$i$$ 张卡将被称为 $$i$$ 张卡。每张卡都有两个参数：强度和成本。卡片 $$i$$ 的强度为 $$A_i$$ ，成本为 $$C_i$$ 。\n\n他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：\n\n- 选择两张牌 $$x$$ 和 $$y$$ ，即 $$A_x > A_y$$ 和 $$C_x < C_y$$ 。弃牌 $$y$$ 。\n\n可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。\n\n## 题解\n\n<!--more-->\n\n对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i].x.y>>a[i].x.x,a[i].y = i;\n\n\tsort(a+1,a+1+n);\n\t// for(int i=1;i<=n;i++) cout<<a[i].y<<endl;\n\n\tstd::vector<int> ans;\n\tint mx = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tint j = i;\n\t\tint t = 0;\n\t\tif(a[j].x.y > mx) ans.push_back(a[j].y);\n\t\tt = max(t, a[j].x.y);\n\t\t// while(j<n && a[j+1].x.x == a[j].x.x){\n\t\t// \tif(a[j].x.y > mx) {\n\t\t// \t\t// cout<<a[j].y<<endl;\n\t\t// \t\tans.push_back(a[j].y);\n\t\t// \t}\n\t\t// \tt = max(t, a[j].x.y);\n\t\t// \tj++;\n\t\t// }\n\t\tmx = max(t,mx);\n\t\t// cout<<mx<<endl;\n\t\ti = j;\n\t}\n\tsort(all(ans));\n\n\tcout<<ans.size()<<endl;\n\n\tfor(int idx: ans) cout<<idx<<' ';\n\t\tcout<<endl;\n}\n```\n\n##  [D - AtCoder Wallpaper](https://atcoder.jp/contests/abc354/tasks/abc354_d)\n\n## 题意\n\nAtCoder 的壁纸图案可以在 $xy$ (平面)上表示如下：\n\n- 该平面由以下三种线段划分：\n    - $$x = n$$ (其中 $n$ 为整数)\n    - $$y = n$$ (其中 $n$ 为偶数)\n    - $$x + y = n$$ (其中 $n$ 为偶数)\n- 每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。\n- 包含 $$(0.5, 0.5)$$ 的区域被涂成黑色。\n\n下图显示了图案的一部分。\n\n![](https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png)\n\n给你整数 $$A, B, C, D$$ 。考虑一个边平行于 $$x$$ \\- 和 $$y$$ \\- 轴的矩形，它的左下顶点在 $$(A, B)$$ ，右上顶点在 $(C, D)$ 。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。\n\n可以证明输出值将是一个整数。\n\n## 题解\n\n构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。\n\n对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。\n\n加上偏移量以确保两个数的正负号问题。\n\n```cpp\nvoid slove() {\n\tint a,b,c,d;\n\n    cin>>a>>b>>c>>d;\n\n    ll ans = 0;\n    for(int i = 0; i<2 ; i++){\n        for(int j = 0; j<4; j++){\n            ll x1 = (a - j + 3 + B)/4, x2 = (c - j + 3 + B)/4;\n            int coux = x2 - x1;\n            ll y1 = (b - i + 1 + B)/2, y2 = (d - i + 1 + B)/2;\n            int couy = y2 - y1;\n            ans += coux * couy * p[i][j];\n        }\n    }\n\n    cout<<ans<<endl;\n}\n```\n\n## [E - Remove Pairs (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_e)\n\n## 题意\n\n高桥和青木正在玩一个使用 $$N$$ 张卡片的游戏。 $￥$ 这张牌的正面写着 $$A_i$$ ，背面写着 $$B_i$$ 。最初， $$N$$ 这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：\n\n- 从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。\n\n最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？\n\n## 题解\n\n乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是$$N \\leq 18$$!\n\n于是直接暴力位dp即可\n\n但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i].x>>a[i].y;\n\n\n\tfor(int i=0;i<(1<<n);i++){\n\t\tfor(int x=0;x<n;x++)\n\t\t{\n\t\t\tfor(int y=x+1;y<n;y++){\n\t\t\t\tif((i >> x & 1) && (i >> y & 1) &&\n\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y))){\n\t\t\t\t\tf[i] |= !f[i^(1<<x)^(1<<y)];\n\t\t\t\t\t// cout<<i<<' '<<x<< ' '<<y<<' '\n\t\t\t\t\t// \t<<(i^(1<<x)^(1<<y))<<' '<<f[i^(1<<x)^(1<<y)]<<endl;\n\t\t\t\t\t// cout<<f[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(f[(1<<n)-1]) cout<<\"Takahashi\\n\";\n\telse cout<<\"Aoki\\n\";\n}\n```\n\n## [F - Useless for LIS (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_f)\n\n## 题意\n\n给你一个长度为 $$N$$ 的整数序列 $$A$$ 。\n\n对于每个 $$t = 1, 2, \\dots, N$$ ，判断 $$A_t$$ 是否包含在 $$A$$ 的最长递增子序列中。\n\n这里，当且仅当以下条件成立时， $$A_t$$ 才包含在 $A$ 的最长递增子序列中：\n\n- 设 $$L$$ 是 $$A$$ 的最长递增子序列的长度。存在一个严格递增整数序列 $$i = (i_1, i_2, \\dots, i_L)  (i_1 < i_2 < \\dots < i_ L)$$ ，其中每个元素都介于 $$1$$ 与 $$N$$ 之间，且满足以下所有条件：\n  \n    - $$A_{i_1}<A_{i_2}<\\dots<A _{i _L}$$ .\n    - $$i_k = t$$ 为某个 $$k (1 \\leq k \\leq L)$$ 。\n\n给你 $T$ 个测试用例，请逐个求解。\n\n什么是最长递增子序列？\n\n序列 $A$ 的子序列是指从 $A$ 中提取一些元素而不改变顺序所得到的序列。\n\n序列 $A$ 的最长递增子序列是 $A$ 的子序列，它以最大可能的长度严格递增。\n\n## 题解\n\n求不包含在样最长上升子序列中的数的下标集合\n\n回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值\n\n这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。\n\n可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。\n\n最后，数据范围离散化\n\n```cpp\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = 0; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = 0,ri = 0;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\n\nvoid slove() {\n\tcin>>n;\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tves.push_back(a[i]);\n\t}\n\n\tsort(all(ves));\n\tves.erase(unique(all(ves)),ves.end());\n\n\tfor(int i=0;i<ves.size();i++){\n\t\tmp[ves[i]] = i+1;\n\t}\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = query(1,mp[a[i]]-1,1,tr);\n\t\tf[i] = mx+1;\n\t\tmodify(mp[a[i]],f[i],1,tr);\n\t}\n\n\tint maxx = query(1,n,1,tr);\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=n;i;i--){\n\t\tint mx = query(mp[a[i]]+1,n,1,tr);\n\t\trf[i] = mx+1;\n\t\tmodify(mp[a[i]],rf[i],1,tr);\n\t}\n\n\t// cout<<maxx<<endl;\n\n\t// for(int i=1;i<=n;i++){\n\t// \tcout<<f[i]<< ' ' << rf[i]<<endl;\n\t// }\n\n\tvector<int> ans;\n\tfor(int i=1;i<=n;i++)\n\t\tif(f[i] + rf[i] - 1 == maxx){\n\t\t\tans.push_back(i);\n\t\t}\n\n\tcout<<ans.size()<<endl;\n\tfor(int v: ans) cout<<v<< ' ';\n\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [G - Select Strings (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_g)\n\n## 题意\n\n\n\n## 题解\n\n","source":"_posts/abc354.md","raw":"---\ntitle: abc354\ndate: 2024-08-14 19:46:31\ntags: [atcoder]\ncategories: \n\t- 比赛\n\t- 日常赛\n\t- atcoder\n---\n\n##  [C - AtCoder Magics](https://atcoder.jp/contests/abc354/tasks/abc354_c)\n\n## 题意\n\n高桥有 $$N$$ 张纸牌，来自纸牌游戏 \"AtCoder Magics\"。其中的 $$i$$ 张卡将被称为 $$i$$ 张卡。每张卡都有两个参数：强度和成本。卡片 $$i$$ 的强度为 $$A_i$$ ，成本为 $$C_i$$ 。\n\n他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：\n\n- 选择两张牌 $$x$$ 和 $$y$$ ，即 $$A_x > A_y$$ 和 $$C_x < C_y$$ 。弃牌 $$y$$ 。\n\n可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。\n\n## 题解\n\n<!--more-->\n\n对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i].x.y>>a[i].x.x,a[i].y = i;\n\n\tsort(a+1,a+1+n);\n\t// for(int i=1;i<=n;i++) cout<<a[i].y<<endl;\n\n\tstd::vector<int> ans;\n\tint mx = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tint j = i;\n\t\tint t = 0;\n\t\tif(a[j].x.y > mx) ans.push_back(a[j].y);\n\t\tt = max(t, a[j].x.y);\n\t\t// while(j<n && a[j+1].x.x == a[j].x.x){\n\t\t// \tif(a[j].x.y > mx) {\n\t\t// \t\t// cout<<a[j].y<<endl;\n\t\t// \t\tans.push_back(a[j].y);\n\t\t// \t}\n\t\t// \tt = max(t, a[j].x.y);\n\t\t// \tj++;\n\t\t// }\n\t\tmx = max(t,mx);\n\t\t// cout<<mx<<endl;\n\t\ti = j;\n\t}\n\tsort(all(ans));\n\n\tcout<<ans.size()<<endl;\n\n\tfor(int idx: ans) cout<<idx<<' ';\n\t\tcout<<endl;\n}\n```\n\n##  [D - AtCoder Wallpaper](https://atcoder.jp/contests/abc354/tasks/abc354_d)\n\n## 题意\n\nAtCoder 的壁纸图案可以在 $xy$ (平面)上表示如下：\n\n- 该平面由以下三种线段划分：\n    - $$x = n$$ (其中 $n$ 为整数)\n    - $$y = n$$ (其中 $n$ 为偶数)\n    - $$x + y = n$$ (其中 $n$ 为偶数)\n- 每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。\n- 包含 $$(0.5, 0.5)$$ 的区域被涂成黑色。\n\n下图显示了图案的一部分。\n\n![](https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png)\n\n给你整数 $$A, B, C, D$$ 。考虑一个边平行于 $$x$$ \\- 和 $$y$$ \\- 轴的矩形，它的左下顶点在 $$(A, B)$$ ，右上顶点在 $(C, D)$ 。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。\n\n可以证明输出值将是一个整数。\n\n## 题解\n\n构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。\n\n对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。\n\n加上偏移量以确保两个数的正负号问题。\n\n```cpp\nvoid slove() {\n\tint a,b,c,d;\n\n    cin>>a>>b>>c>>d;\n\n    ll ans = 0;\n    for(int i = 0; i<2 ; i++){\n        for(int j = 0; j<4; j++){\n            ll x1 = (a - j + 3 + B)/4, x2 = (c - j + 3 + B)/4;\n            int coux = x2 - x1;\n            ll y1 = (b - i + 1 + B)/2, y2 = (d - i + 1 + B)/2;\n            int couy = y2 - y1;\n            ans += coux * couy * p[i][j];\n        }\n    }\n\n    cout<<ans<<endl;\n}\n```\n\n## [E - Remove Pairs (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_e)\n\n## 题意\n\n高桥和青木正在玩一个使用 $$N$$ 张卡片的游戏。 $￥$ 这张牌的正面写着 $$A_i$$ ，背面写着 $$B_i$$ 。最初， $$N$$ 这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：\n\n- 从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。\n\n最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？\n\n## 题解\n\n乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是$$N \\leq 18$$!\n\n于是直接暴力位dp即可\n\n但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i].x>>a[i].y;\n\n\n\tfor(int i=0;i<(1<<n);i++){\n\t\tfor(int x=0;x<n;x++)\n\t\t{\n\t\t\tfor(int y=x+1;y<n;y++){\n\t\t\t\tif((i >> x & 1) && (i >> y & 1) &&\n\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y))){\n\t\t\t\t\tf[i] |= !f[i^(1<<x)^(1<<y)];\n\t\t\t\t\t// cout<<i<<' '<<x<< ' '<<y<<' '\n\t\t\t\t\t// \t<<(i^(1<<x)^(1<<y))<<' '<<f[i^(1<<x)^(1<<y)]<<endl;\n\t\t\t\t\t// cout<<f[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(f[(1<<n)-1]) cout<<\"Takahashi\\n\";\n\telse cout<<\"Aoki\\n\";\n}\n```\n\n## [F - Useless for LIS (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_f)\n\n## 题意\n\n给你一个长度为 $$N$$ 的整数序列 $$A$$ 。\n\n对于每个 $$t = 1, 2, \\dots, N$$ ，判断 $$A_t$$ 是否包含在 $$A$$ 的最长递增子序列中。\n\n这里，当且仅当以下条件成立时， $$A_t$$ 才包含在 $A$ 的最长递增子序列中：\n\n- 设 $$L$$ 是 $$A$$ 的最长递增子序列的长度。存在一个严格递增整数序列 $$i = (i_1, i_2, \\dots, i_L)  (i_1 < i_2 < \\dots < i_ L)$$ ，其中每个元素都介于 $$1$$ 与 $$N$$ 之间，且满足以下所有条件：\n  \n    - $$A_{i_1}<A_{i_2}<\\dots<A _{i _L}$$ .\n    - $$i_k = t$$ 为某个 $$k (1 \\leq k \\leq L)$$ 。\n\n给你 $T$ 个测试用例，请逐个求解。\n\n什么是最长递增子序列？\n\n序列 $A$ 的子序列是指从 $A$ 中提取一些元素而不改变顺序所得到的序列。\n\n序列 $A$ 的最长递增子序列是 $A$ 的子序列，它以最大可能的长度严格递增。\n\n## 题解\n\n求不包含在样最长上升子序列中的数的下标集合\n\n回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值\n\n这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。\n\n可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。\n\n最后，数据范围离散化\n\n```cpp\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = 0; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = 0,ri = 0;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\n\nvoid slove() {\n\tcin>>n;\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tves.push_back(a[i]);\n\t}\n\n\tsort(all(ves));\n\tves.erase(unique(all(ves)),ves.end());\n\n\tfor(int i=0;i<ves.size();i++){\n\t\tmp[ves[i]] = i+1;\n\t}\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = query(1,mp[a[i]]-1,1,tr);\n\t\tf[i] = mx+1;\n\t\tmodify(mp[a[i]],f[i],1,tr);\n\t}\n\n\tint maxx = query(1,n,1,tr);\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=n;i;i--){\n\t\tint mx = query(mp[a[i]]+1,n,1,tr);\n\t\trf[i] = mx+1;\n\t\tmodify(mp[a[i]],rf[i],1,tr);\n\t}\n\n\t// cout<<maxx<<endl;\n\n\t// for(int i=1;i<=n;i++){\n\t// \tcout<<f[i]<< ' ' << rf[i]<<endl;\n\t// }\n\n\tvector<int> ans;\n\tfor(int i=1;i<=n;i++)\n\t\tif(f[i] + rf[i] - 1 == maxx){\n\t\t\tans.push_back(i);\n\t\t}\n\n\tcout<<ans.size()<<endl;\n\tfor(int v: ans) cout<<v<< ' ';\n\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [G - Select Strings (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_g)\n\n## 题意\n\n\n\n## 题解\n\n","slug":"abc354","published":1,"updated":"2024-08-15T04:51:30.384Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9x000x2wwv4sww39ge","content":"<h2 id=\"C-AtCoder-Magics\"><a href=\"#C-AtCoder-Magics\" class=\"headerlink\" title=\"C - AtCoder Magics\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfYw==\">C - AtCoder Magics<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>高桥有 <script type=\"math/tex\">N</script> 张纸牌，来自纸牌游戏 “AtCoder Magics”。其中的 <script type=\"math/tex\">i</script> 张卡将被称为 <script type=\"math/tex\">i</script> 张卡。每张卡都有两个参数：强度和成本。卡片 <script type=\"math/tex\">i</script> 的强度为 <script type=\"math/tex\">A_i</script> ，成本为 <script type=\"math/tex\">C_i</script> 。</p>\n<p>他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：</p>\n<ul>\n<li>选择两张牌 <script type=\"math/tex\">x</script> 和 <script type=\"math/tex\">y</script> ，即 <script type=\"math/tex\">A_x > A_y</script> 和 <script type=\"math/tex\">C_x < C_y</script> 。弃牌 <script type=\"math/tex\">y</script> 。</li>\n</ul>\n<p>可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><span id=\"more\"></span>\n<p>对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x.y&gt;&gt;a[i].x.x,a[i].y = i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = i;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[j].x.y &gt; mx) ans.<span class=\"built_in\">push_back</span>(a[j].y);</span><br><span class=\"line\">\t\tt = <span class=\"built_in\">max</span>(t, a[j].x.y);</span><br><span class=\"line\">\t\t<span class=\"comment\">// while(j&lt;n &amp;&amp; a[j+1].x.x == a[j].x.x)&#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tif(a[j].x.y &gt; mx) &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\t// cout&lt;&lt;a[j].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\tans.push_back(a[j].y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tt = max(t, a[j].x.y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tj++;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\">\t\tmx = <span class=\"built_in\">max</span>(t,mx);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ans));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> idx: ans) cout&lt;&lt;idx&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"D-AtCoder-Wallpaper\"><a href=\"#D-AtCoder-Wallpaper\" class=\"headerlink\" title=\"D - AtCoder Wallpaper\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZA==\">D - AtCoder Wallpaper<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>AtCoder 的壁纸图案可以在 $xy$ (平面)上表示如下：</p>\n<ul>\n<li>该平面由以下三种线段划分：<ul>\n<li><script type=\"math/tex\">x = n</script> (其中 $n$ 为整数)</li>\n<li><script type=\"math/tex\">y = n</script> (其中 $n$ 为偶数)</li>\n<li><script type=\"math/tex\">x + y = n</script> (其中 $n$ 为偶数)</li>\n</ul>\n</li>\n<li>每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。</li>\n<li>包含 <script type=\"math/tex\">(0.5, 0.5)</script> 的区域被涂成黑色。</li>\n</ul>\n<p>下图显示了图案的一部分。</p>\n<p><img src=\"https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png\" alt=\"\"></p>\n<p>给你整数 <script type=\"math/tex\">A, B, C, D</script> 。考虑一个边平行于 <script type=\"math/tex\">x</script> - 和 <script type=\"math/tex\">y</script> - 轴的矩形，它的左下顶点在 <script type=\"math/tex\">(A, B)</script> ，右上顶点在 $(C, D)$ 。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。</p>\n<p>可以证明输出值将是一个整数。</p>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。</p>\n<p>对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。</p>\n<p>加上偏移量以确保两个数的正负号问题。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a,b,c,d;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">2</span> ; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j&lt;<span class=\"number\">4</span>; j++)&#123;</span><br><span class=\"line\">            ll x1 = (a - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>, x2 = (c - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> coux = x2 - x1;</span><br><span class=\"line\">            ll y1 = (b - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>, y2 = (d - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> couy = y2 - y1;</span><br><span class=\"line\">            ans += coux * couy * p[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"E-Remove-Pairs-atcoder-jp\"><a href=\"#E-Remove-Pairs-atcoder-jp\" class=\"headerlink\" title=\"E - Remove Pairs (atcoder.jp)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZQ==\">E - Remove Pairs (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>高桥和青木正在玩一个使用 <script type=\"math/tex\">N</script> 张卡片的游戏。 $￥$ 这张牌的正面写着 <script type=\"math/tex\">A_i</script> ，背面写着 <script type=\"math/tex\">B_i</script> 。最初， <script type=\"math/tex\">N</script> 这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：</p>\n<ul>\n<li>从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。</li>\n</ul>\n<p>最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？</p>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是<script type=\"math/tex\">N \\leq 18</script>!</p>\n<p>于是直接暴力位dp即可</p>\n<p>但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>;x&lt;n;x++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> y=x<span class=\"number\">+1</span>;y&lt;n;y++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>((i &gt;&gt; x &amp; <span class=\"number\">1</span>) &amp;&amp; (i &gt;&gt; y &amp; <span class=\"number\">1</span>) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y)))&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i] |= !f[i^(<span class=\"number\">1</span>&lt;&lt;x)^(<span class=\"number\">1</span>&lt;&lt;y)];</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;x&lt;&lt; &#x27; &#x27;&lt;&lt;y&lt;&lt;&#x27; &#x27;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// \t&lt;&lt;(i^(1&lt;&lt;x)^(1&lt;&lt;y))&lt;&lt;&#x27; &#x27;&lt;&lt;f[i^(1&lt;&lt;x)^(1&lt;&lt;y)]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(f[(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]) cout&lt;&lt;<span class=\"string\">&quot;Takahashi\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;Aoki\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"F-Useless-for-LIS-atcoder-jp\"><a href=\"#F-Useless-for-LIS-atcoder-jp\" class=\"headerlink\" title=\"F - Useless for LIS (atcoder.jp)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZg==\">F - Useless for LIS (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"题意-3\"><a href=\"#题意-3\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给你一个长度为 <script type=\"math/tex\">N</script> 的整数序列 <script type=\"math/tex\">A</script> 。</p>\n<p>对于每个 <script type=\"math/tex\">t = 1, 2, \\dots, N</script> ，判断 <script type=\"math/tex\">A_t</script> 是否包含在 <script type=\"math/tex\">A</script> 的最长递增子序列中。</p>\n<p>这里，当且仅当以下条件成立时， <script type=\"math/tex\">A_t</script> 才包含在 $A$ 的最长递增子序列中：</p>\n<ul>\n<li><p>设 <script type=\"math/tex\">L</script> 是 <script type=\"math/tex\">A</script> 的最长递增子序列的长度。存在一个严格递增整数序列 <script type=\"math/tex\">i = (i_1, i_2, \\dots, i_L)  (i_1 < i_2 < \\dots < i_ L)</script> ，其中每个元素都介于 <script type=\"math/tex\">1</script> 与 <script type=\"math/tex\">N</script> 之间，且满足以下所有条件：</p>\n<ul>\n<li><script type=\"math/tex\">A_{i_1}<A_{i_2}<\\dots<A _{i _L}</script> .</li>\n<li><script type=\"math/tex\">i_k = t</script> 为某个 <script type=\"math/tex\">k (1 \\leq k \\leq L)</script> 。</li>\n</ul>\n</li>\n</ul>\n<p>给你 $T$ 个测试用例，请逐个求解。</p>\n<p>什么是最长递增子序列？</p>\n<p>序列 $A$ 的子序列是指从 $A$ 中提取一些元素而不改变顺序所得到的序列。</p>\n<p>序列 $A$ 的最长递增子序列是 $A$ 的子序列，它以最大可能的长度严格递增。</p>\n<h2 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>求不包含在样最长上升子序列中的数的下标集合</p>\n<p>回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值</p>\n<p>这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。</p>\n<p>可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。</p>\n<p>最后，数据范围离散化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = <span class=\"number\">0</span>; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = <span class=\"number\">0</span>,ri = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tves.<span class=\"built_in\">push_back</span>(a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ves));</span><br><span class=\"line\">\tves.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(ves)),ves.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;ves.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\tmp[ves[i]] = i<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,mp[a[i]]<span class=\"number\">-1</span>,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\tf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],f[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> maxx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(mp[a[i]]<span class=\"number\">+1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\trf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],rf[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;maxx&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;f[i]&lt;&lt; &#x27; &#x27; &lt;&lt; rf[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i] + rf[i] - <span class=\"number\">1</span> == maxx)&#123;</span><br><span class=\"line\">\t\t\tans.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ans) cout&lt;&lt;v&lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"G-Select-Strings-atcoder-jp\"><a href=\"#G-Select-Strings-atcoder-jp\" class=\"headerlink\" title=\"G - Select Strings (atcoder.jp)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZw==\">G - Select Strings (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"题意-4\"><a href=\"#题意-4\" class=\"headerlink\" title=\"题意\"></a>题意</h2><h2 id=\"题解-4\"><a href=\"#题解-4\" class=\"headerlink\" title=\"题解\"></a>题解</h2>","length":1930,"excerpt":"<h2 id=\"C-AtCoder-Magics\"><a href=\"#C-AtCoder-Magics\" class=\"headerlink\" title=\"C - AtCoder Magics\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfYw==\">C - AtCoder Magics<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>高桥有 <script type=\"math/tex\">N</script> 张纸牌，来自纸牌游戏 “AtCoder Magics”。其中的 <script type=\"math/tex\">i</script> 张卡将被称为 <script type=\"math/tex\">i</script> 张卡。每张卡都有两个参数：强度和成本。卡片 <script type=\"math/tex\">i</script> 的强度为 <script type=\"math/tex\">A_i</script> ，成本为 <script type=\"math/tex\">C_i</script> 。</p>\n<p>他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：</p>\n<ul>\n<li>选择两张牌 <script type=\"math/tex\">x</script> 和 <script type=\"math/tex\">y</script> ，即 <script type=\"math/tex\">A_x > A_y</script> 和 <script type=\"math/tex\">C_x < C_y</script> 。弃牌 <script type=\"math/tex\">y</script> 。</li>\n</ul>\n<p>可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2>","more":"<p>对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x.y&gt;&gt;a[i].x.x,a[i].y = i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = i;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[j].x.y &gt; mx) ans.<span class=\"built_in\">push_back</span>(a[j].y);</span><br><span class=\"line\">\t\tt = <span class=\"built_in\">max</span>(t, a[j].x.y);</span><br><span class=\"line\">\t\t<span class=\"comment\">// while(j&lt;n &amp;&amp; a[j+1].x.x == a[j].x.x)&#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tif(a[j].x.y &gt; mx) &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\t// cout&lt;&lt;a[j].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\tans.push_back(a[j].y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tt = max(t, a[j].x.y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tj++;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\">\t\tmx = <span class=\"built_in\">max</span>(t,mx);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ans));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> idx: ans) cout&lt;&lt;idx&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"D-AtCoder-Wallpaper\"><a href=\"#D-AtCoder-Wallpaper\" class=\"headerlink\" title=\"D - AtCoder Wallpaper\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZA==\">D - AtCoder Wallpaper<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>AtCoder 的壁纸图案可以在 $xy$ (平面)上表示如下：</p>\n<ul>\n<li>该平面由以下三种线段划分：<ul>\n<li><script type=\"math/tex\">x = n</script> (其中 $n$ 为整数)</li>\n<li><script type=\"math/tex\">y = n</script> (其中 $n$ 为偶数)</li>\n<li><script type=\"math/tex\">x + y = n</script> (其中 $n$ 为偶数)</li>\n</ul>\n</li>\n<li>每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。</li>\n<li>包含 <script type=\"math/tex\">(0.5, 0.5)</script> 的区域被涂成黑色。</li>\n</ul>\n<p>下图显示了图案的一部分。</p>\n<p><img src=\"https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png\" alt=\"\"></p>\n<p>给你整数 <script type=\"math/tex\">A, B, C, D</script> 。考虑一个边平行于 <script type=\"math/tex\">x</script> - 和 <script type=\"math/tex\">y</script> - 轴的矩形，它的左下顶点在 <script type=\"math/tex\">(A, B)</script> ，右上顶点在 $(C, D)$ 。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。</p>\n<p>可以证明输出值将是一个整数。</p>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。</p>\n<p>对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。</p>\n<p>加上偏移量以确保两个数的正负号问题。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a,b,c,d;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">2</span> ; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j&lt;<span class=\"number\">4</span>; j++)&#123;</span><br><span class=\"line\">            ll x1 = (a - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>, x2 = (c - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> coux = x2 - x1;</span><br><span class=\"line\">            ll y1 = (b - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>, y2 = (d - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> couy = y2 - y1;</span><br><span class=\"line\">            ans += coux * couy * p[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"E-Remove-Pairs-atcoder-jp\"><a href=\"#E-Remove-Pairs-atcoder-jp\" class=\"headerlink\" title=\"E - Remove Pairs (atcoder.jp)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZQ==\">E - Remove Pairs (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>高桥和青木正在玩一个使用 <script type=\"math/tex\">N</script> 张卡片的游戏。 $￥$ 这张牌的正面写着 <script type=\"math/tex\">A_i</script> ，背面写着 <script type=\"math/tex\">B_i</script> 。最初， <script type=\"math/tex\">N</script> 这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：</p>\n<ul>\n<li>从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。</li>\n</ul>\n<p>最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？</p>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是<script type=\"math/tex\">N \\leq 18</script>!</p>\n<p>于是直接暴力位dp即可</p>\n<p>但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>;x&lt;n;x++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> y=x<span class=\"number\">+1</span>;y&lt;n;y++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>((i &gt;&gt; x &amp; <span class=\"number\">1</span>) &amp;&amp; (i &gt;&gt; y &amp; <span class=\"number\">1</span>) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y)))&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i] |= !f[i^(<span class=\"number\">1</span>&lt;&lt;x)^(<span class=\"number\">1</span>&lt;&lt;y)];</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;x&lt;&lt; &#x27; &#x27;&lt;&lt;y&lt;&lt;&#x27; &#x27;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// \t&lt;&lt;(i^(1&lt;&lt;x)^(1&lt;&lt;y))&lt;&lt;&#x27; &#x27;&lt;&lt;f[i^(1&lt;&lt;x)^(1&lt;&lt;y)]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(f[(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]) cout&lt;&lt;<span class=\"string\">&quot;Takahashi\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;Aoki\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"F-Useless-for-LIS-atcoder-jp\"><a href=\"#F-Useless-for-LIS-atcoder-jp\" class=\"headerlink\" title=\"F - Useless for LIS (atcoder.jp)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZg==\">F - Useless for LIS (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"题意-3\"><a href=\"#题意-3\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给你一个长度为 <script type=\"math/tex\">N</script> 的整数序列 <script type=\"math/tex\">A</script> 。</p>\n<p>对于每个 <script type=\"math/tex\">t = 1, 2, \\dots, N</script> ，判断 <script type=\"math/tex\">A_t</script> 是否包含在 <script type=\"math/tex\">A</script> 的最长递增子序列中。</p>\n<p>这里，当且仅当以下条件成立时， <script type=\"math/tex\">A_t</script> 才包含在 $A$ 的最长递增子序列中：</p>\n<ul>\n<li><p>设 <script type=\"math/tex\">L</script> 是 <script type=\"math/tex\">A</script> 的最长递增子序列的长度。存在一个严格递增整数序列 <script type=\"math/tex\">i = (i_1, i_2, \\dots, i_L)  (i_1 < i_2 < \\dots < i_ L)</script> ，其中每个元素都介于 <script type=\"math/tex\">1</script> 与 <script type=\"math/tex\">N</script> 之间，且满足以下所有条件：</p>\n<ul>\n<li><script type=\"math/tex\">A_{i_1}<A_{i_2}<\\dots<A _{i _L}</script> .</li>\n<li><script type=\"math/tex\">i_k = t</script> 为某个 <script type=\"math/tex\">k (1 \\leq k \\leq L)</script> 。</li>\n</ul>\n</li>\n</ul>\n<p>给你 $T$ 个测试用例，请逐个求解。</p>\n<p>什么是最长递增子序列？</p>\n<p>序列 $A$ 的子序列是指从 $A$ 中提取一些元素而不改变顺序所得到的序列。</p>\n<p>序列 $A$ 的最长递增子序列是 $A$ 的子序列，它以最大可能的长度严格递增。</p>\n<h2 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>求不包含在样最长上升子序列中的数的下标集合</p>\n<p>回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值</p>\n<p>这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。</p>\n<p>可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。</p>\n<p>最后，数据范围离散化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = <span class=\"number\">0</span>; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = <span class=\"number\">0</span>,ri = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tves.<span class=\"built_in\">push_back</span>(a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ves));</span><br><span class=\"line\">\tves.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(ves)),ves.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;ves.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\tmp[ves[i]] = i<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,mp[a[i]]<span class=\"number\">-1</span>,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\tf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],f[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> maxx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(mp[a[i]]<span class=\"number\">+1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\trf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],rf[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;maxx&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;f[i]&lt;&lt; &#x27; &#x27; &lt;&lt; rf[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i] + rf[i] - <span class=\"number\">1</span> == maxx)&#123;</span><br><span class=\"line\">\t\t\tans.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ans) cout&lt;&lt;v&lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"G-Select-Strings-atcoder-jp\"><a href=\"#G-Select-Strings-atcoder-jp\" class=\"headerlink\" title=\"G - Select Strings (atcoder.jp)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZw==\">G - Select Strings (atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></h2><h2 id=\"题意-4\"><a href=\"#题意-4\" class=\"headerlink\" title=\"题意\"></a>题意</h2><h2 id=\"题解-4\"><a href=\"#题解-4\" class=\"headerlink\" title=\"题解\"></a>题解</h2>"},{"title":"cf-edu165D","date":"2024-08-14T11:45:21.000Z","_content":"## 题意：\n\n爱丽丝和鲍勃正在商店里玩游戏。商店里有 $$n$$ 件商品；每件商品有两个参数： $$a_i$$ （爱丽丝的物品价格）和 $$b_i$$ （鲍勃的物品价格）。\n\n爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：\n\n- 如果爱丽丝购买的物品少于 $$k$$ ，则鲍勃可以免费拿走所有物品；\n- 否则，他会免费拿走爱丽丝购买的$$k$$ 个物品（由鲍勃选择是哪个 $$k$$ 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 $$b_i$$。\n\n爱丽丝的利润等于 $$\\sum\\limits_{i \\in S} b_i - \\sum\\limits_{j \\in T} a_j$$ ，其中$$S$$ 是鲍勃从爱丽丝处购买的物品集， $$T$$ 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。\n\n爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。\n\n[Problem - D - Codeforces](https://codeforces.com/contest/1969/problem/D)\n\n<!--more-->\n\n## 题解：\n\n注意到，Bob在选择免费的时候显然是直接免费最大的$$b_i$$，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的$$b_i - a_i$$尽可能的大。\n\n先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n>count($$a_i<b_i$$)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。\n\n对于一个物品$$i$$，我们可以证明在$$a_i < b_i$$时该物品是必选的吗？如果我们选了这个物品：\n\n1. 并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它\n\n2. 被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。\n\n综上，无法确定在$$a_i < b_i$$时该物品是必选，对这个不等式的反也成立的物品也成立。\n\n注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。\n\n```cpp\nvoid slove() {\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) cin >> b[i];\n    vector<int> id(n);\n    for(int i=0;i<n;i++) id[i] = i;\n    sort(id.begin(), id.end(), [&](int x, int y){\n        if (b[x] != b[y]) return b[x] > b[y];\n        return a[x] < a[y];\n    });\n\n    // for(int i=0;i<n;i++) cout<<a[id[i]]<<' '<<b[id[i]]<<endl;\n    // cout<<nline;\n\n    ll s1 = 0, s2 = 0, ans = 0;\n    set<int> s;\n    for(int i = 0; i < k; i++){\n        s.insert(a[id[i]]);\n        s1 += a[id[i]];\n    }\n    for(int i = k; i < n; i++){\n        if (b[id[i]] > a[id[i]]){\n            s2 += b[id[i]] - a[id[i]];\n        }\n    }\n    for(int i = k; i < n; i++){\n        ans = max(ans, s2 - s1);\n        if (b[id[i]] > a[id[i]]){\n            s2 -= b[id[i]] - a[id[i]];\n        }\n        s.insert({a[id[i]], id[i]});\n        s1 += a[id[i]];\n        s1 -= *(--s.end());\n        s.erase(--s.end());\n    }\n    cout << ans << '\\n';\n}\n```\n","source":"_posts/cf-edu165D.md","raw":"---\ntitle: cf-edu165D\ndate: 2024-08-14 19:45:21\ntags: [算法, 博弈论, 不等式]\ncategories: \n\t- 算法\n\t- 数学\n\t- 博弈论\n---\n## 题意：\n\n爱丽丝和鲍勃正在商店里玩游戏。商店里有 $$n$$ 件商品；每件商品有两个参数： $$a_i$$ （爱丽丝的物品价格）和 $$b_i$$ （鲍勃的物品价格）。\n\n爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：\n\n- 如果爱丽丝购买的物品少于 $$k$$ ，则鲍勃可以免费拿走所有物品；\n- 否则，他会免费拿走爱丽丝购买的$$k$$ 个物品（由鲍勃选择是哪个 $$k$$ 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 $$b_i$$。\n\n爱丽丝的利润等于 $$\\sum\\limits_{i \\in S} b_i - \\sum\\limits_{j \\in T} a_j$$ ，其中$$S$$ 是鲍勃从爱丽丝处购买的物品集， $$T$$ 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。\n\n爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。\n\n[Problem - D - Codeforces](https://codeforces.com/contest/1969/problem/D)\n\n<!--more-->\n\n## 题解：\n\n注意到，Bob在选择免费的时候显然是直接免费最大的$$b_i$$，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的$$b_i - a_i$$尽可能的大。\n\n先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n>count($$a_i<b_i$$)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。\n\n对于一个物品$$i$$，我们可以证明在$$a_i < b_i$$时该物品是必选的吗？如果我们选了这个物品：\n\n1. 并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它\n\n2. 被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。\n\n综上，无法确定在$$a_i < b_i$$时该物品是必选，对这个不等式的反也成立的物品也成立。\n\n注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。\n\n```cpp\nvoid slove() {\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) cin >> b[i];\n    vector<int> id(n);\n    for(int i=0;i<n;i++) id[i] = i;\n    sort(id.begin(), id.end(), [&](int x, int y){\n        if (b[x] != b[y]) return b[x] > b[y];\n        return a[x] < a[y];\n    });\n\n    // for(int i=0;i<n;i++) cout<<a[id[i]]<<' '<<b[id[i]]<<endl;\n    // cout<<nline;\n\n    ll s1 = 0, s2 = 0, ans = 0;\n    set<int> s;\n    for(int i = 0; i < k; i++){\n        s.insert(a[id[i]]);\n        s1 += a[id[i]];\n    }\n    for(int i = k; i < n; i++){\n        if (b[id[i]] > a[id[i]]){\n            s2 += b[id[i]] - a[id[i]];\n        }\n    }\n    for(int i = k; i < n; i++){\n        ans = max(ans, s2 - s1);\n        if (b[id[i]] > a[id[i]]){\n            s2 -= b[id[i]] - a[id[i]];\n        }\n        s.insert({a[id[i]], id[i]});\n        s1 += a[id[i]];\n        s1 -= *(--s.end());\n        s.erase(--s.end());\n    }\n    cout << ans << '\\n';\n}\n```\n","slug":"cf-edu165D","published":1,"updated":"2024-08-14T13:38:37.760Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9y00102wwv9bc31tuf","content":"<h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>爱丽丝和鲍勃正在商店里玩游戏。商店里有 <script type=\"math/tex\">n</script> 件商品；每件商品有两个参数： <script type=\"math/tex\">a_i</script> （爱丽丝的物品价格）和 <script type=\"math/tex\">b_i</script> （鲍勃的物品价格）。</p>\n<p>爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：</p>\n<ul>\n<li>如果爱丽丝购买的物品少于 <script type=\"math/tex\">k</script> ，则鲍勃可以免费拿走所有物品；</li>\n<li>否则，他会免费拿走爱丽丝购买的<script type=\"math/tex\">k</script> 个物品（由鲍勃选择是哪个 <script type=\"math/tex\">k</script> 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 <script type=\"math/tex\">b_i</script>。</li>\n</ul>\n<p>爱丽丝的利润等于 <script type=\"math/tex\">\\sum\\limits_{i \\in S} b_i - \\sum\\limits_{j \\in T} a_j</script> ，其中<script type=\"math/tex\">S</script> 是鲍勃从爱丽丝处购买的物品集， <script type=\"math/tex\">T</script> 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。</p>\n<p>爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9E\">Problem - D - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<span id=\"more\"></span>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>注意到，Bob在选择免费的时候显然是直接免费最大的<script type=\"math/tex\">b_i</script>，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的<script type=\"math/tex\">b_i - a_i</script>尽可能的大。</p>\n<p>先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n&gt;count(<script type=\"math/tex\">a_i<b_i</script>)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。</p>\n<p>对于一个物品<script type=\"math/tex\">i</script>，我们可以证明在<script type=\"math/tex\">a_i < b_i</script>时该物品是必选的吗？如果我们选了这个物品：</p>\n<ol>\n<li><p>并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它</p>\n</li>\n<li><p>被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。</p>\n</li>\n</ol>\n<p>综上，无法确定在<script type=\"math/tex\">a_i < b_i</script>时该物品是必选，对这个不等式的反也成立的物品也成立。</p>\n<p>注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span>, <span class=\"title\">b</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">id</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) id[i] = i;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(id.<span class=\"built_in\">begin</span>(), id.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[x] != b[y]) <span class=\"keyword\">return</span> b[x] &gt; b[y];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[x] &lt; a[y];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=0;i&lt;n;i++) cout&lt;&lt;a[id[i]]&lt;&lt;&#x27; &#x27;&lt;&lt;b[id[i]]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ll s1 = <span class=\"number\">0</span>, s2 = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++)&#123;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(a[id[i]]);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 += b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, s2 - s1);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 -= b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(&#123;a[id[i]], id[i]&#125;);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">        s1 -= *(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        s.<span class=\"built_in\">erase</span>(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":959,"excerpt":"<h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>爱丽丝和鲍勃正在商店里玩游戏。商店里有 <script type=\"math/tex\">n</script> 件商品；每件商品有两个参数： <script type=\"math/tex\">a_i</script> （爱丽丝的物品价格）和 <script type=\"math/tex\">b_i</script> （鲍勃的物品价格）。</p>\n<p>爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：</p>\n<ul>\n<li>如果爱丽丝购买的物品少于 <script type=\"math/tex\">k</script> ，则鲍勃可以免费拿走所有物品；</li>\n<li>否则，他会免费拿走爱丽丝购买的<script type=\"math/tex\">k</script> 个物品（由鲍勃选择是哪个 <script type=\"math/tex\">k</script> 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 <script type=\"math/tex\">b_i</script>。</li>\n</ul>\n<p>爱丽丝的利润等于 <script type=\"math/tex\">\\sum\\limits_{i \\in S} b_i - \\sum\\limits_{j \\in T} a_j</script> ，其中<script type=\"math/tex\">S</script> 是鲍勃从爱丽丝处购买的物品集， <script type=\"math/tex\">T</script> 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。</p>\n<p>爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9E\">Problem - D - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>注意到，Bob在选择免费的时候显然是直接免费最大的<script type=\"math/tex\">b_i</script>，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的<script type=\"math/tex\">b_i - a_i</script>尽可能的大。</p>\n<p>先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n&gt;count(<script type=\"math/tex\">a_i<b_i</script>)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。</p>\n<p>对于一个物品<script type=\"math/tex\">i</script>，我们可以证明在<script type=\"math/tex\">a_i < b_i</script>时该物品是必选的吗？如果我们选了这个物品：</p>\n<ol>\n<li><p>并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它</p>\n</li>\n<li><p>被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。</p>\n</li>\n</ol>\n<p>综上，无法确定在<script type=\"math/tex\">a_i < b_i</script>时该物品是必选，对这个不等式的反也成立的物品也成立。</p>\n<p>注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span>, <span class=\"title\">b</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">id</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) id[i] = i;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(id.<span class=\"built_in\">begin</span>(), id.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[x] != b[y]) <span class=\"keyword\">return</span> b[x] &gt; b[y];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[x] &lt; a[y];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=0;i&lt;n;i++) cout&lt;&lt;a[id[i]]&lt;&lt;&#x27; &#x27;&lt;&lt;b[id[i]]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ll s1 = <span class=\"number\">0</span>, s2 = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++)&#123;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(a[id[i]]);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 += b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, s2 - s1);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 -= b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(&#123;a[id[i]], id[i]&#125;);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">        s1 -= *(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        s.<span class=\"built_in\">erase</span>(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"cf-edu165C","date":"2024-08-14T11:46:31.000Z","_content":"## 题意：\n\n有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。\n\n[Problem - C - Codeforces](https://codeforces.com/contest/1969/problem/C)\n\n<!--more-->\n\n## 题解：\n\n教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。\n\n但为什么不能采用别的解法呢？\n\n考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1\n\n> 2,1,1,2,5\n\n显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。\n\n注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。\n\n于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。\n\n考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。\n\n> [x,a,b,c,y] -> [x,x,x,x,y]->[x,x,y,y,y] 其中含有无意义的两步操作\n\n再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。\n\n下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。\n\n> 对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于$$a_k|k>ii \\&\\& k <= i$$，因此所需操作数为i-ii-1\n\n最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）\n\n```cpp\nvoid slove() {\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=m;j++)f[i][j] = LLINF;\n\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) pre[i] = a[i] + pre[i-1];\n    f[0][0] = 0;\n    for(int i=1;i<=n;i++) {\n        for(int ii=i-1;ii>=0 && i-ii-1 <= m;ii--) {\n            int t = i-ii-1;\n            for(int j=t;j<=m;j++) {\n                for(int k=ii+1;k<=i;k++) {\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    // cout<<i<<' '<<j<<' '<< f[i][j]<<nline;\n                }\n            }\n        }\n    }\n\n    int ans = LLINF;\n    for(int i=0;i<=m;i++) ans = min(ans,f[n][i]);\n    cout<<ans<<endl;\n}\n```\n","source":"_posts/cf-edu165C.md","raw":"---\ntitle: cf-edu165C\ndate: 2024-08-14 19:46:31\ntags: [算法, 思维题, 贪心,状态转移]\ncategories: \n\t- 算法\n\t- 思维题\n\t- 贪心\n---\n## 题意：\n\n有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。\n\n[Problem - C - Codeforces](https://codeforces.com/contest/1969/problem/C)\n\n<!--more-->\n\n## 题解：\n\n教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。\n\n但为什么不能采用别的解法呢？\n\n考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1\n\n> 2,1,1,2,5\n\n显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。\n\n注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。\n\n于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。\n\n考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。\n\n> [x,a,b,c,y] -> [x,x,x,x,y]->[x,x,y,y,y] 其中含有无意义的两步操作\n\n再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。\n\n下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。\n\n> 对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于$$a_k|k>ii \\&\\& k <= i$$，因此所需操作数为i-ii-1\n\n最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）\n\n```cpp\nvoid slove() {\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=m;j++)f[i][j] = LLINF;\n\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) pre[i] = a[i] + pre[i-1];\n    f[0][0] = 0;\n    for(int i=1;i<=n;i++) {\n        for(int ii=i-1;ii>=0 && i-ii-1 <= m;ii--) {\n            int t = i-ii-1;\n            for(int j=t;j<=m;j++) {\n                for(int k=ii+1;k<=i;k++) {\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    // cout<<i<<' '<<j<<' '<< f[i][j]<<nline;\n                }\n            }\n        }\n    }\n\n    int ans = LLINF;\n    for(int i=0;i<=m;i++) ans = min(ans,f[n][i]);\n    cout<<ans<<endl;\n}\n```\n","slug":"cf-edu165C","published":1,"updated":"2024-08-15T04:57:58.784Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9y00122wwvg9fo4zy3","content":"<h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9D\">Problem - C - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\n<span id=\"more\"></span>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。</p>\n<p>但为什么不能采用别的解法呢？</p>\n<p>考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1</p>\n<blockquote>\n<p>2,1,1,2,5</p>\n</blockquote>\n<p>显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。</p>\n<p>注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。</p>\n<p>于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。</p>\n<p>考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。</p>\n<blockquote>\n<p>[x,a,b,c,y] -&gt; [x,x,x,x,y]-&gt;[x,x,y,y,y] 其中含有无意义的两步操作</p>\n</blockquote>\n<p>再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。</p>\n<p>下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。</p>\n<blockquote>\n<p>对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于<script type=\"math/tex\">a_k|k>ii \\&\\& k <= i</script>，因此所需操作数为i-ii-1</p>\n</blockquote>\n<p>最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;j++)f[i][j] = LLINF;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = a[i] + pre[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=i<span class=\"number\">-1</span>;ii&gt;=<span class=\"number\">0</span> &amp;&amp; i-ii<span class=\"number\">-1</span> &lt;= m;ii--) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = i-ii<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=t;j&lt;=m;j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=ii<span class=\"number\">+1</span>;k&lt;=i;k++) &#123;</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt; f[i][j]&lt;&lt;nline;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans = LLINF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++) ans = <span class=\"built_in\">min</span>(ans,f[n][i]);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":875,"excerpt":"<h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9D\">Problem - C - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。</p>\n<p>但为什么不能采用别的解法呢？</p>\n<p>考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1</p>\n<blockquote>\n<p>2,1,1,2,5</p>\n</blockquote>\n<p>显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。</p>\n<p>注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。</p>\n<p>于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。</p>\n<p>考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。</p>\n<blockquote>\n<p>[x,a,b,c,y] -&gt; [x,x,x,x,y]-&gt;[x,x,y,y,y] 其中含有无意义的两步操作</p>\n</blockquote>\n<p>再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。</p>\n<p>下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。</p>\n<blockquote>\n<p>对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于<script type=\"math/tex\">a_k|k>ii \\&\\& k <= i</script>，因此所需操作数为i-ii-1</p>\n</blockquote>\n<p>最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;j++)f[i][j] = LLINF;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = a[i] + pre[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=i<span class=\"number\">-1</span>;ii&gt;=<span class=\"number\">0</span> &amp;&amp; i-ii<span class=\"number\">-1</span> &lt;= m;ii--) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = i-ii<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=t;j&lt;=m;j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=ii<span class=\"number\">+1</span>;k&lt;=i;k++) &#123;</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt; f[i][j]&lt;&lt;nline;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans = LLINF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++) ans = <span class=\"built_in\">min</span>(ans,f[n][i]);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"luogu蓝桥5_19","date":"2024-08-14T11:46:31.000Z","_content":"\n## B. 停车场\n\n[P10509 停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10509?contestId=174155)\n\n<!--more-->\n\n### 题意\n\n你有一片空地。这片空地可以视作一个一个 𝑛×𝑛 的正方形。空地外一圈为墙壁，你无法拆除它们。\n\n现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 1×1的正方形，且正方形的每条边与墙壁平行或者垂直。\n\n每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。\n\n下图为 𝑛=4 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png)\n\n请问 𝑛=2023 下最多能安排多少个停车位？\n\n### 题解\n\n这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸\n\n[云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/17rwjfcz)\n\n洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。\n\n这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png)\n\n直接构造可得\n\n答案为(2022+2021*(674*2-1)+673*2*2+3)\n\n## D. 方差\n\n[P10511 方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10511?contestId=174155)\n\n### 题意\n\n小 S 认为数学很简单，于是小 R 想要考考她。\n\n小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 `l r b`，表示 $a_l,a_{l+1},\\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。\n\n现在，小 R 有 $q$ 个问题。形如 `l r`，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。\n\n由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\\cdot s^2\\bmod 998244353$。可以证明 $(r-l+1)^2\\cdot s^2$ 一定是整数。\n\n作为小 S 的好朋友，你能帮帮她吗？\n\n### 题解\n\n推导一下公式发现结果是\n\n$$(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 - sum^2$$\n\n预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。\n\n但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题\n\n```cpp\nvoid slove() {\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++) {\n\t\tcin>>seg[i].l>>seg[i].r>>seg[i].v;\n\t\tseg[i].l %= MOD;\n\t\tseg[i].r %= MOD;\n\t\tseg[i].v %= MOD;\n\t}\n\n\t// sort(seg+1,seg+1+m);\n\n\tfor(int i=1;i<=m;i++){\n\t\tsegs[i] = segs[i-1] + ((((seg[i].r - seg[i].l  + 1) %MOD + MOD) %MOD) * seg[i].v) % MOD;\n\t\tsegs[i] %= MOD;\n\t\tsegs2[i] = segs2[i-1] + (((((seg[i].r - seg[i].l + 1) %MOD + MOD)%MOD) * seg[i].v %MOD)\n\t\t\t\t* seg[i].v) % MOD;\n\t\tsegs2[i] %= MOD;\n\t}\n\n\t// for(int i=1;i<=m;i++) cout<<segs[i]<<' '<<segs2[i]<<endl;\n\n\twhile(k--){\n\t\tint l,r;cin>>l>>r;\n\t\tint li = upper_bound(seg+1,seg+1+m,(Segment){l,0,0}) - seg - 1;\n\t\tint ri = upper_bound(seg+1,seg+1+m,(Segment){r,0,0}) - seg - 1;\n\t\t// cout<<\"###\"<<li<< ' ' << ri<<endl;\n\n\t\tif(li== ri)\n    \t{\n      \t\tcout<<0<<\"\\n\";\n      \t\tcontinue;\n    \t}\n\n\t\tint msum = ((segs[ri-1] - segs[li])%MOD + MOD) % MOD;\n\t\tmsum %= MOD;\n\t\tint rsum = (((r - seg[ri].l + 1) % MOD + MOD) % MOD * seg[ri].v) % MOD;\n\t\trsum %= MOD;\n\t\tint lsum = ((seg[li].r - l + 1 + MOD) % MOD * seg[li].v) % MOD;\n\t\tlsum %= MOD;\n\t\tint msum2 = ((segs2[ri-1] - segs2[li])%MOD + MOD) %MOD;\n\t\tmsum %=MOD;\n\t\tint rsum2 = ((((r - seg[ri].l + 1)%MOD + MOD) % MOD * seg[ri].v) % MOD\n\t\t\t\t* seg[ri].v) % MOD;\n\t\trsum2%=MOD;\n\t\tint lsum2 = ((((seg[li].r - l + 1) %MOD + MOD) % MOD * seg[li].v) % MOD\n\t\t\t\t*seg[li].v) %MOD;\n\t\tlsum2 %=MOD;\n\t\t// cout<<\"---\"<<lsum << ' '<<msum<< ' '<<rsum<<endl;\n\t\tint sum = lsum + msum % MOD + rsum %MOD;\n\t\tsum %=MOD;\n\t\tint sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;\n\t\tsum2%=MOD;\n\t\t// cout<<\"####\"<<sum<< ' '<< sum2<<endl;\n\t\tcout<<(((((r-l+1) %MOD + MOD) % MOD * sum2) % MOD -\n\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD<<endl;\n\t}\n}\n```\n\n## E. 序列合并\n\nhttps://www.luogu.com.cn/problem/P10512?contestId=174155\n\n## 题意\n\n给定一个长度为 𝑛的非负整数序列 {$$𝑎_𝑛$$}，你可以进行 𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。\n\n形式化地，一次操作中，你选择一个下标 𝑖*i*（1≤𝑖<𝑛1≤*i*<*n*），然后把原序列变成$${a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}$$。\n\n求 𝑘次操作后所有数按位与的最大值。\n\n## 题解\n\n首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大\n\n注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。\n\n要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。\n\n我觉得比取模题简单\n\n```CPP\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint ans = 0;\n\tfor(int i=29;~i;i--){\n\t\tint t = ans | (1<<i);\n\n\t\tint x = 0,cnt = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx |= a[i];\n\t\t\tif((x & t) == t) cnt++,x=0;\n\t\t}\n\t\tif(cnt >= n - k) {\n\t\t\tans = t;\n\t\t\t// cout<<cnt<<endl;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F. 括号\n\nhttps://www.luogu.com.cn/problem/P10513?contestId=174155\n\n### 题意\n\n圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 ```(``` 和 ```)``` 构成。\n\n她会对其做 $m$ 次操作，操作有两种类型：\n\n1. ```1 l r```，她会翻转 $l$ 到 $r$ 的括号，即 ```(``` 变 ```)```，```)``` 变 ```(```。\n1. ```2 l r```，她想知道区间 $\\left[ l,r\\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。\n\n\n圆认为以下的括号序列是合法的：\n\n1. 空序列是一个合法序列。\n\n1. 如果 ```A``` 是一个合法序列，则 ```(A)```  也是一个合法序列。\n\n1. 如果 ```A``` 和 ```B``` 都是合法序列，则 ```AB``` 也是一个合法序列。\n\n圆认为，序列 $a$ 的子序列是满足 $1\\le i_1<i_2<···<i_k \\le n$ 的序列 $[a_{i_1},a_{i_2},...a_{i_k}]$。\n\n由于操作太多了，她算不过来，请你帮帮她吧。\n\n### 题解\n\n洛谷真的要吓死我了，第六题线段树\n\n对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即\n\n$$ans=左边括号序列+右边括号序列+横跨中间的括号序列$$\n\n如何维护交换这一操作呢？\n\n我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。\n\n```cpp\nstruct node {\n\tint l,r,ans;\n\tnode(int x=0,int y=0,int z=0){l=x,r=y,ans=z;}\n};\nstruct tree{int tag;node t1,t2;}t[N<<2];\nchar s[N];\n\nnode merge(node x,node y)\n{\n    int cnt=min(x.l,y.r);\n    return {x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt};\n}\ninline void pushup(int p){t[p].t1=merge(t[ls].t1,t[rs].t1);t[p].t2=merge(t[ls].t2,t[rs].t2);}\ninline void pushson(int p){swap(t[p].t1,t[p].t2);t[p].tag^=1;}\ninline void pushdown(int p){if(!t[p].tag) return;pushson(ls),pushson(rs);t[p].tag=0;}\ninline void build(int p,int l,int r)\n{\n    if(l==r) return t[p].t2.r=t[p].t1.l=(s[l]=='('),t[p].t2.l=t[p].t1.r=(s[l]==')'),void();\n    build(ls,l,mid);build(rs,mid+1,r);pushup(p);\n}\ninline void modify(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return pushson(p);pushdown(p);\n    if(mid>=s) modify(ls,l,mid,s,e);if(mid<e) modify(rs,mid+1,r,s,e);\n    pushup(p);\n}\ninline node query(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return t[p].t1;pushdown(p);\n    if(e<=mid) return query(ls,l,mid,s,e);\n    if(s>mid) return query(rs,mid+1,r,s,e);\n    return merge(query(ls,l,mid,s,e),query(rs,mid+1,r,s,e));\n}\n\nvoid slove() {\n\tcin>>n;\n\tcin>>s+1;\n\tbuild(1,1,n);\n\tcin>>m;\n\twhile(m--){\n\t\tint op,l,r;cin>>op>>l>>r;\n\t\tif(op == 1) {\n\t\t\tmodify(1,1,n,l,r);\n\t\t}else {\n\t\t\tcout<<query(1,1,n,l,r).ans<<endl;\n\t\t}\n\t}\n}\n```\n\n## G.考试\n\nhttps://www.luogu.com.cn/problem/P10514?contestId=174155\n\n### 题意\n\n有 $n$ 名同学去参加考试，考试有 $m$ 道题。\n\n每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。\n\n考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。\n\n### 题解\n\n数学题。。。 懒得打公式了，如下\n\n![image-20240527221944431](https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png)\n\n预处理阶乘，快速幂分母时间复杂度为log(m)+n\n\n处理分子时间复杂度为mlog(n)\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tfac[0] = infac[0] = 1;\n\tfor(int i=1;i<N;i++){\n\t\tfac[i] = fac[i-1] *i % MOD;\n\t\tinfac[i] = infac[i-1] * qmi(i,MOD-2,MOD) % MOD;\n\t\t// cout<<fac[i]<<' ' <<infac[i]<<endl;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>m>>k;\n\n\tint mx = 0;\n\tfor(int i=1;i<=m;i++) cin>>a[i], mx= max(mx,a[i]);\n\n\tif(mx + k > n) {cout<<0<<endl;return ;}\n\n\tint inv = qmi(qmi(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD-2,MOD);\n\n\tint factor = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;\n\t}\n\n\tcout<<factor*inv % MOD<<endl;\n}\n```\n\n## H. 转圈、按钮P4861\n\nhttps://www.luogu.com.cn/problem/P10515?contestId=174155\n\n### 题意\n\n小 $\\delta$ 喜欢转圈圈。\n\n他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \\times m$，他现在站在第一个格子上。\n\n接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。\n\n求最终被小 $\\delta$ 踩到过的格子的数量。由于小 $\\delta$ 有很多圈圈，所以他会问你很多次。\n\n### 题解\n\n这题和P4861撞了，所以我干脆贴这题了\n\n根据欧拉定理$$a^{\\phi(p)}= 1 (modp)$$\n\n因此$$\\phi(p)$$一定是答案的倍数，我们只需要枚举它的因子即可\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\nint gcd(int x,int y){return y? gcd(y,x%y): x;}\n\nvoid init(){}\n\nint get_phi(int x){\n\tint res = x;\n\tif(!(x&1)) res >>= 1;\n\n\tfor(int i=3;i*i<=x; i+= 2){\n\t\tif(x % i == 0){\n\t\t\tres -= res /i;\n\t\t\twhile(x % i == 0) x/=i;\n\t\t}\n\t}\n\tif(x > 1) res -= res / x;\n\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n>>m;\n\tif(gcd(n,m)!=1)puts(\"Let's go Blue Jays!\");//无解\n    else{\n        int p=get_phi(n);//得到phi\n        int mm=p;\n        int tot = 0;\n        for(int i=2;(i*i)<=mm;i++){\n            if(mm%i)continue;\n            pri[++tot]=i;\n            while(mm%i==0){\n                mm/=i;\n                tim[tot]++;\n            }\n        }\n        if(mm!=1){\n            pri[++tot]=mm;\n            tim[tot]=1;\n        }\n\n        int ss=1,qq=p;\n        while(ss<=tot){\n            for(int i=1;i<=tim[ss];i++){\n                if(qmi(m,qq/pri[ss],n)==1)qq/=pri[ss];\n                else break;\n            }\n            ss++;\n        }\n        cout<<qq<<endl;\n    }\n}\n```\n","source":"_posts/luogu蓝桥5_19.md","raw":"---\ntitle: luogu蓝桥5_19\ndate: 2024-08-14 19:46:31\ntags: [luogu]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- 蓝桥模拟\n---\n\n## B. 停车场\n\n[P10509 停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10509?contestId=174155)\n\n<!--more-->\n\n### 题意\n\n你有一片空地。这片空地可以视作一个一个 𝑛×𝑛 的正方形。空地外一圈为墙壁，你无法拆除它们。\n\n现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 1×1的正方形，且正方形的每条边与墙壁平行或者垂直。\n\n每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。\n\n下图为 𝑛=4 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png)\n\n请问 𝑛=2023 下最多能安排多少个停车位？\n\n### 题解\n\n这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸\n\n[云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/17rwjfcz)\n\n洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。\n\n这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png)\n\n直接构造可得\n\n答案为(2022+2021*(674*2-1)+673*2*2+3)\n\n## D. 方差\n\n[P10511 方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10511?contestId=174155)\n\n### 题意\n\n小 S 认为数学很简单，于是小 R 想要考考她。\n\n小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 `l r b`，表示 $a_l,a_{l+1},\\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。\n\n现在，小 R 有 $q$ 个问题。形如 `l r`，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。\n\n由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\\cdot s^2\\bmod 998244353$。可以证明 $(r-l+1)^2\\cdot s^2$ 一定是整数。\n\n作为小 S 的好朋友，你能帮帮她吗？\n\n### 题解\n\n推导一下公式发现结果是\n\n$$(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 - sum^2$$\n\n预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。\n\n但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题\n\n```cpp\nvoid slove() {\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++) {\n\t\tcin>>seg[i].l>>seg[i].r>>seg[i].v;\n\t\tseg[i].l %= MOD;\n\t\tseg[i].r %= MOD;\n\t\tseg[i].v %= MOD;\n\t}\n\n\t// sort(seg+1,seg+1+m);\n\n\tfor(int i=1;i<=m;i++){\n\t\tsegs[i] = segs[i-1] + ((((seg[i].r - seg[i].l  + 1) %MOD + MOD) %MOD) * seg[i].v) % MOD;\n\t\tsegs[i] %= MOD;\n\t\tsegs2[i] = segs2[i-1] + (((((seg[i].r - seg[i].l + 1) %MOD + MOD)%MOD) * seg[i].v %MOD)\n\t\t\t\t* seg[i].v) % MOD;\n\t\tsegs2[i] %= MOD;\n\t}\n\n\t// for(int i=1;i<=m;i++) cout<<segs[i]<<' '<<segs2[i]<<endl;\n\n\twhile(k--){\n\t\tint l,r;cin>>l>>r;\n\t\tint li = upper_bound(seg+1,seg+1+m,(Segment){l,0,0}) - seg - 1;\n\t\tint ri = upper_bound(seg+1,seg+1+m,(Segment){r,0,0}) - seg - 1;\n\t\t// cout<<\"###\"<<li<< ' ' << ri<<endl;\n\n\t\tif(li== ri)\n    \t{\n      \t\tcout<<0<<\"\\n\";\n      \t\tcontinue;\n    \t}\n\n\t\tint msum = ((segs[ri-1] - segs[li])%MOD + MOD) % MOD;\n\t\tmsum %= MOD;\n\t\tint rsum = (((r - seg[ri].l + 1) % MOD + MOD) % MOD * seg[ri].v) % MOD;\n\t\trsum %= MOD;\n\t\tint lsum = ((seg[li].r - l + 1 + MOD) % MOD * seg[li].v) % MOD;\n\t\tlsum %= MOD;\n\t\tint msum2 = ((segs2[ri-1] - segs2[li])%MOD + MOD) %MOD;\n\t\tmsum %=MOD;\n\t\tint rsum2 = ((((r - seg[ri].l + 1)%MOD + MOD) % MOD * seg[ri].v) % MOD\n\t\t\t\t* seg[ri].v) % MOD;\n\t\trsum2%=MOD;\n\t\tint lsum2 = ((((seg[li].r - l + 1) %MOD + MOD) % MOD * seg[li].v) % MOD\n\t\t\t\t*seg[li].v) %MOD;\n\t\tlsum2 %=MOD;\n\t\t// cout<<\"---\"<<lsum << ' '<<msum<< ' '<<rsum<<endl;\n\t\tint sum = lsum + msum % MOD + rsum %MOD;\n\t\tsum %=MOD;\n\t\tint sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;\n\t\tsum2%=MOD;\n\t\t// cout<<\"####\"<<sum<< ' '<< sum2<<endl;\n\t\tcout<<(((((r-l+1) %MOD + MOD) % MOD * sum2) % MOD -\n\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD<<endl;\n\t}\n}\n```\n\n## E. 序列合并\n\nhttps://www.luogu.com.cn/problem/P10512?contestId=174155\n\n## 题意\n\n给定一个长度为 𝑛的非负整数序列 {$$𝑎_𝑛$$}，你可以进行 𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。\n\n形式化地，一次操作中，你选择一个下标 𝑖*i*（1≤𝑖<𝑛1≤*i*<*n*），然后把原序列变成$${a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}$$。\n\n求 𝑘次操作后所有数按位与的最大值。\n\n## 题解\n\n首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大\n\n注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。\n\n要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。\n\n我觉得比取模题简单\n\n```CPP\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint ans = 0;\n\tfor(int i=29;~i;i--){\n\t\tint t = ans | (1<<i);\n\n\t\tint x = 0,cnt = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx |= a[i];\n\t\t\tif((x & t) == t) cnt++,x=0;\n\t\t}\n\t\tif(cnt >= n - k) {\n\t\t\tans = t;\n\t\t\t// cout<<cnt<<endl;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F. 括号\n\nhttps://www.luogu.com.cn/problem/P10513?contestId=174155\n\n### 题意\n\n圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 ```(``` 和 ```)``` 构成。\n\n她会对其做 $m$ 次操作，操作有两种类型：\n\n1. ```1 l r```，她会翻转 $l$ 到 $r$ 的括号，即 ```(``` 变 ```)```，```)``` 变 ```(```。\n1. ```2 l r```，她想知道区间 $\\left[ l,r\\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。\n\n\n圆认为以下的括号序列是合法的：\n\n1. 空序列是一个合法序列。\n\n1. 如果 ```A``` 是一个合法序列，则 ```(A)```  也是一个合法序列。\n\n1. 如果 ```A``` 和 ```B``` 都是合法序列，则 ```AB``` 也是一个合法序列。\n\n圆认为，序列 $a$ 的子序列是满足 $1\\le i_1<i_2<···<i_k \\le n$ 的序列 $[a_{i_1},a_{i_2},...a_{i_k}]$。\n\n由于操作太多了，她算不过来，请你帮帮她吧。\n\n### 题解\n\n洛谷真的要吓死我了，第六题线段树\n\n对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即\n\n$$ans=左边括号序列+右边括号序列+横跨中间的括号序列$$\n\n如何维护交换这一操作呢？\n\n我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。\n\n```cpp\nstruct node {\n\tint l,r,ans;\n\tnode(int x=0,int y=0,int z=0){l=x,r=y,ans=z;}\n};\nstruct tree{int tag;node t1,t2;}t[N<<2];\nchar s[N];\n\nnode merge(node x,node y)\n{\n    int cnt=min(x.l,y.r);\n    return {x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt};\n}\ninline void pushup(int p){t[p].t1=merge(t[ls].t1,t[rs].t1);t[p].t2=merge(t[ls].t2,t[rs].t2);}\ninline void pushson(int p){swap(t[p].t1,t[p].t2);t[p].tag^=1;}\ninline void pushdown(int p){if(!t[p].tag) return;pushson(ls),pushson(rs);t[p].tag=0;}\ninline void build(int p,int l,int r)\n{\n    if(l==r) return t[p].t2.r=t[p].t1.l=(s[l]=='('),t[p].t2.l=t[p].t1.r=(s[l]==')'),void();\n    build(ls,l,mid);build(rs,mid+1,r);pushup(p);\n}\ninline void modify(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return pushson(p);pushdown(p);\n    if(mid>=s) modify(ls,l,mid,s,e);if(mid<e) modify(rs,mid+1,r,s,e);\n    pushup(p);\n}\ninline node query(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return t[p].t1;pushdown(p);\n    if(e<=mid) return query(ls,l,mid,s,e);\n    if(s>mid) return query(rs,mid+1,r,s,e);\n    return merge(query(ls,l,mid,s,e),query(rs,mid+1,r,s,e));\n}\n\nvoid slove() {\n\tcin>>n;\n\tcin>>s+1;\n\tbuild(1,1,n);\n\tcin>>m;\n\twhile(m--){\n\t\tint op,l,r;cin>>op>>l>>r;\n\t\tif(op == 1) {\n\t\t\tmodify(1,1,n,l,r);\n\t\t}else {\n\t\t\tcout<<query(1,1,n,l,r).ans<<endl;\n\t\t}\n\t}\n}\n```\n\n## G.考试\n\nhttps://www.luogu.com.cn/problem/P10514?contestId=174155\n\n### 题意\n\n有 $n$ 名同学去参加考试，考试有 $m$ 道题。\n\n每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。\n\n考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。\n\n### 题解\n\n数学题。。。 懒得打公式了，如下\n\n![image-20240527221944431](https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png)\n\n预处理阶乘，快速幂分母时间复杂度为log(m)+n\n\n处理分子时间复杂度为mlog(n)\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tfac[0] = infac[0] = 1;\n\tfor(int i=1;i<N;i++){\n\t\tfac[i] = fac[i-1] *i % MOD;\n\t\tinfac[i] = infac[i-1] * qmi(i,MOD-2,MOD) % MOD;\n\t\t// cout<<fac[i]<<' ' <<infac[i]<<endl;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>m>>k;\n\n\tint mx = 0;\n\tfor(int i=1;i<=m;i++) cin>>a[i], mx= max(mx,a[i]);\n\n\tif(mx + k > n) {cout<<0<<endl;return ;}\n\n\tint inv = qmi(qmi(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD-2,MOD);\n\n\tint factor = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;\n\t}\n\n\tcout<<factor*inv % MOD<<endl;\n}\n```\n\n## H. 转圈、按钮P4861\n\nhttps://www.luogu.com.cn/problem/P10515?contestId=174155\n\n### 题意\n\n小 $\\delta$ 喜欢转圈圈。\n\n他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \\times m$，他现在站在第一个格子上。\n\n接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。\n\n求最终被小 $\\delta$ 踩到过的格子的数量。由于小 $\\delta$ 有很多圈圈，所以他会问你很多次。\n\n### 题解\n\n这题和P4861撞了，所以我干脆贴这题了\n\n根据欧拉定理$$a^{\\phi(p)}= 1 (modp)$$\n\n因此$$\\phi(p)$$一定是答案的倍数，我们只需要枚举它的因子即可\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\nint gcd(int x,int y){return y? gcd(y,x%y): x;}\n\nvoid init(){}\n\nint get_phi(int x){\n\tint res = x;\n\tif(!(x&1)) res >>= 1;\n\n\tfor(int i=3;i*i<=x; i+= 2){\n\t\tif(x % i == 0){\n\t\t\tres -= res /i;\n\t\t\twhile(x % i == 0) x/=i;\n\t\t}\n\t}\n\tif(x > 1) res -= res / x;\n\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n>>m;\n\tif(gcd(n,m)!=1)puts(\"Let's go Blue Jays!\");//无解\n    else{\n        int p=get_phi(n);//得到phi\n        int mm=p;\n        int tot = 0;\n        for(int i=2;(i*i)<=mm;i++){\n            if(mm%i)continue;\n            pri[++tot]=i;\n            while(mm%i==0){\n                mm/=i;\n                tim[tot]++;\n            }\n        }\n        if(mm!=1){\n            pri[++tot]=mm;\n            tim[tot]=1;\n        }\n\n        int ss=1,qq=p;\n        while(ss<=tot){\n            for(int i=1;i<=tim[ss];i++){\n                if(qmi(m,qq/pri[ss],n)==1)qq/=pri[ss];\n                else break;\n            }\n            ss++;\n        }\n        cout<<qq<<endl;\n    }\n}\n```\n","slug":"luogu蓝桥5_19","published":1,"updated":"2024-08-15T04:51:55.211Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9z00152wwvdnteev4c","content":"<h2 id=\"B-停车场\"><a href=\"#B-停车场\" class=\"headerlink\" title=\"B. 停车场\"></a>B. 停车场</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTA5P2NvbnRlc3RJZD0xNzQxNTU=\">P10509 停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<span id=\"more\"></span>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>你有一片空地。这片空地可以视作一个一个 𝑛×𝑛 的正方形。空地外一圈为墙壁，你无法拆除它们。</p>\n<p>现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 1×1的正方形，且正方形的每条边与墙壁平行或者垂直。</p>\n<p>每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。</p>\n<p>下图为 𝑛=4 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png\" alt=\"img\"></p>\n<p>请问 𝑛=2023 下最多能安排多少个停车位？</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Bhc3RlLzE3cndqZmN6\">云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。</p>\n<p>这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png\" alt=\"img\"></p>\n<p>直接构造可得</p>\n<p>答案为(2022+2021<em>(674</em>2-1)+673<em>2</em>2+3)</p>\n<h2 id=\"D-方差\"><a href=\"#D-方差\" class=\"headerlink\" title=\"D. 方差\"></a>D. 方差</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTExP2NvbnRlc3RJZD0xNzQxNTU=\">P10511 方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>小 S 认为数学很简单，于是小 R 想要考考她。</p>\n<p>小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 <code>l r b</code>，表示 $a<em>l,a</em>{l+1},\\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。</p>\n<p>现在，小 R 有 $q$ 个问题。形如 <code>l r</code>，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。</p>\n<p>由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\\cdot s^2\\bmod 998244353$。可以证明 $(r-l+1)^2\\cdot s^2$ 一定是整数。</p>\n<p>作为小 S 的好朋友，你能帮帮她吗？</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>推导一下公式发现结果是</p>\n<script type=\"math/tex; mode=display\">(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 - sum^2</script><p>预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。</p>\n<p>但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;seg[i].l&gt;&gt;seg[i].r&gt;&gt;seg[i].v;</span><br><span class=\"line\">\t\tseg[i].l %= MOD;</span><br><span class=\"line\">\t\tseg[i].r %= MOD;</span><br><span class=\"line\">\t\tseg[i].v %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sort(seg+1,seg+1+m);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tsegs[i] = segs[i<span class=\"number\">-1</span>] + ((((seg[i].r - seg[i].l  + <span class=\"number\">1</span>) %MOD + MOD) %MOD) * seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs[i] %= MOD;</span><br><span class=\"line\">\t\tsegs2[i] = segs2[i<span class=\"number\">-1</span>] + (((((seg[i].r - seg[i].l + <span class=\"number\">1</span>) %MOD + MOD)%MOD) * seg[i].v %MOD)</span><br><span class=\"line\">\t\t\t\t* seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs2[i] %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=m;i++) cout&lt;&lt;segs[i]&lt;&lt;&#x27; &#x27;&lt;&lt;segs2[i]&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(k--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> li = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;l,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ri = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;r,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;li&lt;&lt; &#x27; &#x27; &lt;&lt; ri&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(li== ri)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">      \t\tcout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum = ((segs[ri<span class=\"number\">-1</span>] - segs[li])%MOD + MOD) % MOD;</span><br><span class=\"line\">\t\tmsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum = (((r - seg[ri].l + <span class=\"number\">1</span>) % MOD + MOD) % MOD * seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum = ((seg[li].r - l + <span class=\"number\">1</span> + MOD) % MOD * seg[li].v) % MOD;</span><br><span class=\"line\">\t\tlsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum2 = ((segs2[ri<span class=\"number\">-1</span>] - segs2[li])%MOD + MOD) %MOD;</span><br><span class=\"line\">\t\tmsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum2 = ((((r - seg[ri].l + <span class=\"number\">1</span>)%MOD + MOD) % MOD * seg[ri].v) % MOD</span><br><span class=\"line\">\t\t\t\t* seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum2 = ((((seg[li].r - l + <span class=\"number\">1</span>) %MOD + MOD) % MOD * seg[li].v) % MOD</span><br><span class=\"line\">\t\t\t\t*seg[li].v) %MOD;</span><br><span class=\"line\">\t\tlsum2 %=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;lsum &lt;&lt; &#x27; &#x27;&lt;&lt;msum&lt;&lt; &#x27; &#x27;&lt;&lt;rsum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum = lsum + msum % MOD + rsum %MOD;</span><br><span class=\"line\">\t\tsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;</span><br><span class=\"line\">\t\tsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;####&quot;&lt;&lt;sum&lt;&lt; &#x27; &#x27;&lt;&lt; sum2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tcout&lt;&lt;(((((r-l<span class=\"number\">+1</span>) %MOD + MOD) % MOD * sum2) % MOD -</span><br><span class=\"line\">\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"E-序列合并\"><a href=\"#E-序列合并\" class=\"headerlink\" title=\"E. 序列合并\"></a>E. 序列合并</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTEyP2NvbnRlc3RJZD0xNzQxNTU=\">https://www.luogu.com.cn/problem/P10512?contestId=174155<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定一个长度为 𝑛的非负整数序列 {<script type=\"math/tex\">𝑎_𝑛</script>}，你可以进行 𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。</p>\n<p>形式化地，一次操作中，你选择一个下标 𝑖<em>i</em>（1≤𝑖&lt;𝑛1≤<em>i</em>&lt;<em>n</em>），然后把原序列变成<script type=\"math/tex\">{a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}</script>。</p>\n<p>求 𝑘次操作后所有数按位与的最大值。</p>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大</p>\n<p>注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。</p>\n<p>要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。</p>\n<p>我觉得比取模题简单</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">29</span>;~i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = ans | (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tx |= a[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((x &amp; t) == t) cnt++,x=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &gt;= n - k) &#123;</span><br><span class=\"line\">\t\t\tans = t;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"F-括号\"><a href=\"#F-括号\" class=\"headerlink\" title=\"F. 括号\"></a>F. 括号</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTEzP2NvbnRlc3RJZD0xNzQxNTU=\">https://www.luogu.com.cn/problem/P10513?contestId=174155<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意-3\"><a href=\"#题意-3\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 <code>(</code> 和 <code>)</code> 构成。</p>\n<p>她会对其做 $m$ 次操作，操作有两种类型：</p>\n<ol>\n<li><code>1 l r</code>，她会翻转 $l$ 到 $r$ 的括号，即 <code>(</code> 变 <code>)</code>，<code>)</code> 变 <code>(</code>。</li>\n<li><code>2 l r</code>，她想知道区间 $\\left[ l,r\\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。</li>\n</ol>\n<p>圆认为以下的括号序列是合法的：</p>\n<ol>\n<li><p>空序列是一个合法序列。</p>\n</li>\n<li><p>如果 <code>A</code> 是一个合法序列，则 <code>(A)</code>  也是一个合法序列。</p>\n</li>\n<li><p>如果 <code>A</code> 和 <code>B</code> 都是合法序列，则 <code>AB</code> 也是一个合法序列。</p>\n</li>\n</ol>\n<p>圆认为，序列 $a$ 的子序列是满足 $1\\le i<em>1&lt;i_2&lt;···&lt;i_k \\le n$ 的序列 $[a</em>{i<em>1},a</em>{i<em>2},…a</em>{i_k}]$。</p>\n<p>由于操作太多了，她算不过来，请你帮帮她吧。</p>\n<h3 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>洛谷真的要吓死我了，第六题线段树</p>\n<p>对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即</p>\n<script type=\"math/tex; mode=display\">ans=左边括号序列+右边括号序列+横跨中间的括号序列</script><p>如何维护交换这一操作呢？</p>\n<p>我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,ans;</span><br><span class=\"line\">\t<span class=\"built_in\">node</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>,<span class=\"type\">int</span> y=<span class=\"number\">0</span>,<span class=\"type\">int</span> z=<span class=\"number\">0</span>)&#123;l=x,r=y,ans=z;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tree</span>&#123;<span class=\"type\">int</span> tag;node t1,t2;&#125;t[N&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">merge</span><span class=\"params\">(node x,node y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt=<span class=\"built_in\">min</span>(x.l,y.r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;t[p].t1=<span class=\"built_in\">merge</span>(t[ls].t1,t[rs].t1);t[p].t2=<span class=\"built_in\">merge</span>(t[ls].t2,t[rs].t2);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushson</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"built_in\">swap</span>(t[p].t1,t[p].t2);t[p].tag^=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"keyword\">if</span>(!t[p].tag) <span class=\"keyword\">return</span>;<span class=\"built_in\">pushson</span>(ls),<span class=\"built_in\">pushson</span>(rs);t[p].tag=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r) <span class=\"keyword\">return</span> t[p].t<span class=\"number\">2.</span>r=t[p].t<span class=\"number\">1.l</span>=(s[l]==<span class=\"string\">&#x27;(&#x27;</span>),t[p].t<span class=\"number\">2.l</span>=t[p].t<span class=\"number\">1.</span>r=(s[l]==<span class=\"string\">&#x27;)&#x27;</span>),<span class=\"built_in\">void</span>();</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(ls,l,mid);<span class=\"built_in\">build</span>(rs,mid<span class=\"number\">+1</span>,r);<span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> <span class=\"built_in\">pushson</span>(p);<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&gt;=s) <span class=\"built_in\">modify</span>(ls,l,mid,s,e);<span class=\"keyword\">if</span>(mid&lt;e) <span class=\"built_in\">modify</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> t[p].t1;<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e&lt;=mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(ls,l,mid,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s&gt;mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">merge</span>(<span class=\"built_in\">query</span>(ls,l,mid,s,e),<span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tcin&gt;&gt;s<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op,l,r;cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r).ans&lt;&lt;endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"G-考试\"><a href=\"#G-考试\" class=\"headerlink\" title=\"G.考试\"></a>G.考试</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTE0P2NvbnRlc3RJZD0xNzQxNTU=\">https://www.luogu.com.cn/problem/P10514?contestId=174155<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意-4\"><a href=\"#题意-4\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>有 $n$ 名同学去参加考试，考试有 $m$ 道题。</p>\n<p>每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。</p>\n<p>考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。</p>\n<h3 id=\"题解-4\"><a href=\"#题解-4\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>数学题。。。 懒得打公式了，如下</p>\n<p><img src=\"https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png\" alt=\"image-20240527221944431\"></p>\n<p>预处理阶乘，快速幂分母时间复杂度为log(m)+n</p>\n<p>处理分子时间复杂度为mlog(n)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tfac[<span class=\"number\">0</span>] = infac[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">\t\tfac[i] = fac[i<span class=\"number\">-1</span>] *i % MOD;</span><br><span class=\"line\">\t\tinfac[i] = infac[i<span class=\"number\">-1</span>] * <span class=\"built_in\">qmi</span>(i,MOD<span class=\"number\">-2</span>,MOD) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;fac[i]&lt;&lt;&#x27; &#x27; &lt;&lt;infac[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i], mx= <span class=\"built_in\">max</span>(mx,a[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(mx + k &gt; n) &#123;cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;<span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> inv = <span class=\"built_in\">qmi</span>(<span class=\"built_in\">qmi</span>(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD<span class=\"number\">-2</span>,MOD);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> factor = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;factor*inv % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"H-转圈、按钮P4861\"><a href=\"#H-转圈、按钮P4861\" class=\"headerlink\" title=\"H. 转圈、按钮P4861\"></a>H. 转圈、按钮P4861</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTE1P2NvbnRlc3RJZD0xNzQxNTU=\">https://www.luogu.com.cn/problem/P10515?contestId=174155<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意-5\"><a href=\"#题意-5\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>小 $\\delta$ 喜欢转圈圈。</p>\n<p>他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \\times m$，他现在站在第一个格子上。</p>\n<p>接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。</p>\n<p>求最终被小 $\\delta$ 踩到过的格子的数量。由于小 $\\delta$ 有很多圈圈，所以他会问你很多次。</p>\n<h3 id=\"题解-5\"><a href=\"#题解-5\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>这题和P4861撞了，所以我干脆贴这题了</p>\n<p>根据欧拉定理<script type=\"math/tex\">a^{\\phi(p)}= 1 (modp)</script></p>\n<p>因此<script type=\"math/tex\">\\phi(p)</script>一定是答案的倍数，我们只需要枚举它的因子即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;<span class=\"keyword\">return</span> y? <span class=\"built_in\">gcd</span>(y,x%y): x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_phi</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> res = x;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(x&amp;<span class=\"number\">1</span>)) res &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">3</span>;i*i&lt;=x; i+= <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tres -= res /i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(x % i == <span class=\"number\">0</span>) x/=i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt; <span class=\"number\">1</span>) res -= res / x;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">gcd</span>(n,m)!=<span class=\"number\">1</span>)<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Let&#x27;s go Blue Jays!&quot;</span>);<span class=\"comment\">//无解</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p=<span class=\"built_in\">get_phi</span>(n);<span class=\"comment\">//得到phi</span></span><br><span class=\"line\">        <span class=\"type\">int</span> mm=p;</span><br><span class=\"line\">        <span class=\"type\">int</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;(i*i)&lt;=mm;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mm%i)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            pri[++tot]=i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(mm%i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                mm/=i;</span><br><span class=\"line\">                tim[tot]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mm!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            pri[++tot]=mm;</span><br><span class=\"line\">            tim[tot]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ss=<span class=\"number\">1</span>,qq=p;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ss&lt;=tot)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tim[ss];i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">qmi</span>(m,qq/pri[ss],n)==<span class=\"number\">1</span>)qq/=pri[ss];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ss++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;qq&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":2696,"excerpt":"<h2 id=\"B-停车场\"><a href=\"#B-停车场\" class=\"headerlink\" title=\"B. 停车场\"></a>B. 停车场</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTA5P2NvbnRlc3RJZD0xNzQxNTU=\">P10509 停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>你有一片空地。这片空地可以视作一个一个 𝑛×𝑛 的正方形。空地外一圈为墙壁，你无法拆除它们。</p>\n<p>现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 1×1的正方形，且正方形的每条边与墙壁平行或者垂直。</p>\n<p>每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。</p>\n<p>下图为 𝑛=4 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png\" alt=\"img\"></p>\n<p>请问 𝑛=2023 下最多能安排多少个停车位？</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Bhc3RlLzE3cndqZmN6\">云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。</p>\n<p>这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png\" alt=\"img\"></p>\n<p>直接构造可得</p>\n<p>答案为(2022+2021<em>(674</em>2-1)+673<em>2</em>2+3)</p>\n<h2 id=\"D-方差\"><a href=\"#D-方差\" class=\"headerlink\" title=\"D. 方差\"></a>D. 方差</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTExP2NvbnRlc3RJZD0xNzQxNTU=\">P10511 方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>小 S 认为数学很简单，于是小 R 想要考考她。</p>\n<p>小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 <code>l r b</code>，表示 $a<em>l,a</em>{l+1},\\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。</p>\n<p>现在，小 R 有 $q$ 个问题。形如 <code>l r</code>，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。</p>\n<p>由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\\cdot s^2\\bmod 998244353$。可以证明 $(r-l+1)^2\\cdot s^2$ 一定是整数。</p>\n<p>作为小 S 的好朋友，你能帮帮她吗？</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>推导一下公式发现结果是</p>\n<script type=\"math/tex; mode=display\">(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 - sum^2</script><p>预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。</p>\n<p>但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;seg[i].l&gt;&gt;seg[i].r&gt;&gt;seg[i].v;</span><br><span class=\"line\">\t\tseg[i].l %= MOD;</span><br><span class=\"line\">\t\tseg[i].r %= MOD;</span><br><span class=\"line\">\t\tseg[i].v %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sort(seg+1,seg+1+m);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tsegs[i] = segs[i<span class=\"number\">-1</span>] + ((((seg[i].r - seg[i].l  + <span class=\"number\">1</span>) %MOD + MOD) %MOD) * seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs[i] %= MOD;</span><br><span class=\"line\">\t\tsegs2[i] = segs2[i<span class=\"number\">-1</span>] + (((((seg[i].r - seg[i].l + <span class=\"number\">1</span>) %MOD + MOD)%MOD) * seg[i].v %MOD)</span><br><span class=\"line\">\t\t\t\t* seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs2[i] %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=m;i++) cout&lt;&lt;segs[i]&lt;&lt;&#x27; &#x27;&lt;&lt;segs2[i]&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(k--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> li = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;l,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ri = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;r,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;li&lt;&lt; &#x27; &#x27; &lt;&lt; ri&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(li== ri)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">      \t\tcout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum = ((segs[ri<span class=\"number\">-1</span>] - segs[li])%MOD + MOD) % MOD;</span><br><span class=\"line\">\t\tmsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum = (((r - seg[ri].l + <span class=\"number\">1</span>) % MOD + MOD) % MOD * seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum = ((seg[li].r - l + <span class=\"number\">1</span> + MOD) % MOD * seg[li].v) % MOD;</span><br><span class=\"line\">\t\tlsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum2 = ((segs2[ri<span class=\"number\">-1</span>] - segs2[li])%MOD + MOD) %MOD;</span><br><span class=\"line\">\t\tmsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum2 = ((((r - seg[ri].l + <span class=\"number\">1</span>)%MOD + MOD) % MOD * seg[ri].v) % MOD</span><br><span class=\"line\">\t\t\t\t* seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum2 = ((((seg[li].r - l + <span class=\"number\">1</span>) %MOD + MOD) % MOD * seg[li].v) % MOD</span><br><span class=\"line\">\t\t\t\t*seg[li].v) %MOD;</span><br><span class=\"line\">\t\tlsum2 %=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;lsum &lt;&lt; &#x27; &#x27;&lt;&lt;msum&lt;&lt; &#x27; &#x27;&lt;&lt;rsum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum = lsum + msum % MOD + rsum %MOD;</span><br><span class=\"line\">\t\tsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;</span><br><span class=\"line\">\t\tsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;####&quot;&lt;&lt;sum&lt;&lt; &#x27; &#x27;&lt;&lt; sum2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tcout&lt;&lt;(((((r-l<span class=\"number\">+1</span>) %MOD + MOD) % MOD * sum2) % MOD -</span><br><span class=\"line\">\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"E-序列合并\"><a href=\"#E-序列合并\" class=\"headerlink\" title=\"E. 序列合并\"></a>E. 序列合并</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTEyP2NvbnRlc3RJZD0xNzQxNTU=\">https://www.luogu.com.cn/problem/P10512?contestId=174155<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定一个长度为 𝑛的非负整数序列 {<script type=\"math/tex\">𝑎_𝑛</script>}，你可以进行 𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。</p>\n<p>形式化地，一次操作中，你选择一个下标 𝑖<em>i</em>（1≤𝑖&lt;𝑛1≤<em>i</em>&lt;<em>n</em>），然后把原序列变成<script type=\"math/tex\">{a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}</script>。</p>\n<p>求 𝑘次操作后所有数按位与的最大值。</p>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大</p>\n<p>注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。</p>\n<p>要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。</p>\n<p>我觉得比取模题简单</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">29</span>;~i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = ans | (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tx |= a[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((x &amp; t) == t) cnt++,x=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &gt;= n - k) &#123;</span><br><span class=\"line\">\t\t\tans = t;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"F-括号\"><a href=\"#F-括号\" class=\"headerlink\" title=\"F. 括号\"></a>F. 括号</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTEzP2NvbnRlc3RJZD0xNzQxNTU=\">https://www.luogu.com.cn/problem/P10513?contestId=174155<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意-3\"><a href=\"#题意-3\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 <code>(</code> 和 <code>)</code> 构成。</p>\n<p>她会对其做 $m$ 次操作，操作有两种类型：</p>\n<ol>\n<li><code>1 l r</code>，她会翻转 $l$ 到 $r$ 的括号，即 <code>(</code> 变 <code>)</code>，<code>)</code> 变 <code>(</code>。</li>\n<li><code>2 l r</code>，她想知道区间 $\\left[ l,r\\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。</li>\n</ol>\n<p>圆认为以下的括号序列是合法的：</p>\n<ol>\n<li><p>空序列是一个合法序列。</p>\n</li>\n<li><p>如果 <code>A</code> 是一个合法序列，则 <code>(A)</code>  也是一个合法序列。</p>\n</li>\n<li><p>如果 <code>A</code> 和 <code>B</code> 都是合法序列，则 <code>AB</code> 也是一个合法序列。</p>\n</li>\n</ol>\n<p>圆认为，序列 $a$ 的子序列是满足 $1\\le i<em>1&lt;i_2&lt;···&lt;i_k \\le n$ 的序列 $[a</em>{i<em>1},a</em>{i<em>2},…a</em>{i_k}]$。</p>\n<p>由于操作太多了，她算不过来，请你帮帮她吧。</p>\n<h3 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>洛谷真的要吓死我了，第六题线段树</p>\n<p>对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即</p>\n<script type=\"math/tex; mode=display\">ans=左边括号序列+右边括号序列+横跨中间的括号序列</script><p>如何维护交换这一操作呢？</p>\n<p>我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,ans;</span><br><span class=\"line\">\t<span class=\"built_in\">node</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>,<span class=\"type\">int</span> y=<span class=\"number\">0</span>,<span class=\"type\">int</span> z=<span class=\"number\">0</span>)&#123;l=x,r=y,ans=z;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tree</span>&#123;<span class=\"type\">int</span> tag;node t1,t2;&#125;t[N&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">merge</span><span class=\"params\">(node x,node y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt=<span class=\"built_in\">min</span>(x.l,y.r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;t[p].t1=<span class=\"built_in\">merge</span>(t[ls].t1,t[rs].t1);t[p].t2=<span class=\"built_in\">merge</span>(t[ls].t2,t[rs].t2);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushson</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"built_in\">swap</span>(t[p].t1,t[p].t2);t[p].tag^=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"keyword\">if</span>(!t[p].tag) <span class=\"keyword\">return</span>;<span class=\"built_in\">pushson</span>(ls),<span class=\"built_in\">pushson</span>(rs);t[p].tag=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r) <span class=\"keyword\">return</span> t[p].t<span class=\"number\">2.</span>r=t[p].t<span class=\"number\">1.l</span>=(s[l]==<span class=\"string\">&#x27;(&#x27;</span>),t[p].t<span class=\"number\">2.l</span>=t[p].t<span class=\"number\">1.</span>r=(s[l]==<span class=\"string\">&#x27;)&#x27;</span>),<span class=\"built_in\">void</span>();</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(ls,l,mid);<span class=\"built_in\">build</span>(rs,mid<span class=\"number\">+1</span>,r);<span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> <span class=\"built_in\">pushson</span>(p);<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&gt;=s) <span class=\"built_in\">modify</span>(ls,l,mid,s,e);<span class=\"keyword\">if</span>(mid&lt;e) <span class=\"built_in\">modify</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> t[p].t1;<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e&lt;=mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(ls,l,mid,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s&gt;mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">merge</span>(<span class=\"built_in\">query</span>(ls,l,mid,s,e),<span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tcin&gt;&gt;s<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op,l,r;cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r).ans&lt;&lt;endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"G-考试\"><a href=\"#G-考试\" class=\"headerlink\" title=\"G.考试\"></a>G.考试</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTE0P2NvbnRlc3RJZD0xNzQxNTU=\">https://www.luogu.com.cn/problem/P10514?contestId=174155<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意-4\"><a href=\"#题意-4\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>有 $n$ 名同学去参加考试，考试有 $m$ 道题。</p>\n<p>每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。</p>\n<p>考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。</p>\n<h3 id=\"题解-4\"><a href=\"#题解-4\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>数学题。。。 懒得打公式了，如下</p>\n<p><img src=\"https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png\" alt=\"image-20240527221944431\"></p>\n<p>预处理阶乘，快速幂分母时间复杂度为log(m)+n</p>\n<p>处理分子时间复杂度为mlog(n)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tfac[<span class=\"number\">0</span>] = infac[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">\t\tfac[i] = fac[i<span class=\"number\">-1</span>] *i % MOD;</span><br><span class=\"line\">\t\tinfac[i] = infac[i<span class=\"number\">-1</span>] * <span class=\"built_in\">qmi</span>(i,MOD<span class=\"number\">-2</span>,MOD) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;fac[i]&lt;&lt;&#x27; &#x27; &lt;&lt;infac[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i], mx= <span class=\"built_in\">max</span>(mx,a[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(mx + k &gt; n) &#123;cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;<span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> inv = <span class=\"built_in\">qmi</span>(<span class=\"built_in\">qmi</span>(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD<span class=\"number\">-2</span>,MOD);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> factor = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;factor*inv % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"H-转圈、按钮P4861\"><a href=\"#H-转圈、按钮P4861\" class=\"headerlink\" title=\"H. 转圈、按钮P4861\"></a>H. 转圈、按钮P4861</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTE1P2NvbnRlc3RJZD0xNzQxNTU=\">https://www.luogu.com.cn/problem/P10515?contestId=174155<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"题意-5\"><a href=\"#题意-5\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>小 $\\delta$ 喜欢转圈圈。</p>\n<p>他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \\times m$，他现在站在第一个格子上。</p>\n<p>接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。</p>\n<p>求最终被小 $\\delta$ 踩到过的格子的数量。由于小 $\\delta$ 有很多圈圈，所以他会问你很多次。</p>\n<h3 id=\"题解-5\"><a href=\"#题解-5\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>这题和P4861撞了，所以我干脆贴这题了</p>\n<p>根据欧拉定理<script type=\"math/tex\">a^{\\phi(p)}= 1 (modp)</script></p>\n<p>因此<script type=\"math/tex\">\\phi(p)</script>一定是答案的倍数，我们只需要枚举它的因子即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;<span class=\"keyword\">return</span> y? <span class=\"built_in\">gcd</span>(y,x%y): x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_phi</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> res = x;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(x&amp;<span class=\"number\">1</span>)) res &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">3</span>;i*i&lt;=x; i+= <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tres -= res /i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(x % i == <span class=\"number\">0</span>) x/=i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt; <span class=\"number\">1</span>) res -= res / x;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">gcd</span>(n,m)!=<span class=\"number\">1</span>)<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Let&#x27;s go Blue Jays!&quot;</span>);<span class=\"comment\">//无解</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p=<span class=\"built_in\">get_phi</span>(n);<span class=\"comment\">//得到phi</span></span><br><span class=\"line\">        <span class=\"type\">int</span> mm=p;</span><br><span class=\"line\">        <span class=\"type\">int</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;(i*i)&lt;=mm;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mm%i)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            pri[++tot]=i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(mm%i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                mm/=i;</span><br><span class=\"line\">                tim[tot]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mm!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            pri[++tot]=mm;</span><br><span class=\"line\">            tim[tot]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ss=<span class=\"number\">1</span>,qq=p;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ss&lt;=tot)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tim[ss];i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">qmi</span>(m,qq/pri[ss],n)==<span class=\"number\">1</span>)qq/=pri[ss];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ss++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;qq&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"三种操作系统模拟软件使用手册","date":"2024-05-13T09:07:09.000Z","_content":"\n# 三种操作系统简单模拟使用手册\n\n## 可运行程序图标\n\nhttps://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw\n\n![image-20240525143542993](https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png)\n\n<!--more-->\n\n## 安装\n\n程序提供了三种安装形式。\n\n### exe模式\n\n第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考[Java官网](https://www.java.com/zh-CN/download/manual.jsp)\n\n### JAR模式\n\n第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用\n\n<!--more-->\n\n### install安装包模式\n\n第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。\n\n## 卸载方式\n\n通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。\n\n## 程序使用指南\n\n### 开源协议窗口\n\n![image-20240525143707804](https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png)\n\n该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。\n\n\n\n### 导航菜单界面\n\n![image-20240525143849896](https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png)\n\n该界面为程序主题界面，可通过界面导航到三个算法界面\n\n### 生产者消费者\n\n![image-20240525144036276](https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png)\n\n该界面可实现生产者消费者业务功能\n\n使用方式为：\n\n1. 按照程序显示按钮进行操作，请勿输入未指定的，空数据。\n\n1.0.1 版本常见问题为：\n\n1. 该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。\n\n### 银行家算法\n\n   ![image-20240525144551258](https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png)\n\n该界面为银行家算法界面，可实现银行家算法的功能与设计\n\n使用方式为：\n\n1. 给定总进程与总资源数\n2. 设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵\n3. 是否继续请求\n\n1.0.1版本可能遇到的问题：\n\n1. 设定过多进程与资源数导致无法输入\n2. ![image-20240525145256829](https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png)\n\n### 调度算法模拟\n\n![image-20240525144538081](https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png)\n\n调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能\n\n![image-20240525144654678](https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png)\n\n六种调度算法全称分别是\n\n1. 先到先执行\n2. 非抢占式短作业优先\n3. 最短剩余时间优先（抢占式最短作业优先）\n4. 非抢占式优先级优先\n5. 抢占式优先级优先\n6. 时间片轮转算法\n\n使用方法为：\n\n1. 输入每个进程的前四列信息\n2. 选择算法\n3. 点击计算\n\n1.0.1版本可能遇到的问题：\n\n1. 请勿设置相同进程号\n2. 请勿设置小数时间片轮转或设置为0\n3. 给定的完成时间，周转时间，等待时间将被忽略","source":"_posts/三种操作系统模拟软件使用手册.md","raw":"---\ntitle: 三种操作系统模拟软件使用手册\ndate: 2024-05-13 17:07:09\ntags: [开发, 文档, 学校]\ncategories: \n   - 软件\n   - 手册\n---\n\n# 三种操作系统简单模拟使用手册\n\n## 可运行程序图标\n\nhttps://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw\n\n![image-20240525143542993](https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png)\n\n<!--more-->\n\n## 安装\n\n程序提供了三种安装形式。\n\n### exe模式\n\n第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考[Java官网](https://www.java.com/zh-CN/download/manual.jsp)\n\n### JAR模式\n\n第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用\n\n<!--more-->\n\n### install安装包模式\n\n第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。\n\n## 卸载方式\n\n通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。\n\n## 程序使用指南\n\n### 开源协议窗口\n\n![image-20240525143707804](https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png)\n\n该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。\n\n\n\n### 导航菜单界面\n\n![image-20240525143849896](https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png)\n\n该界面为程序主题界面，可通过界面导航到三个算法界面\n\n### 生产者消费者\n\n![image-20240525144036276](https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png)\n\n该界面可实现生产者消费者业务功能\n\n使用方式为：\n\n1. 按照程序显示按钮进行操作，请勿输入未指定的，空数据。\n\n1.0.1 版本常见问题为：\n\n1. 该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。\n\n### 银行家算法\n\n   ![image-20240525144551258](https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png)\n\n该界面为银行家算法界面，可实现银行家算法的功能与设计\n\n使用方式为：\n\n1. 给定总进程与总资源数\n2. 设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵\n3. 是否继续请求\n\n1.0.1版本可能遇到的问题：\n\n1. 设定过多进程与资源数导致无法输入\n2. ![image-20240525145256829](https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png)\n\n### 调度算法模拟\n\n![image-20240525144538081](https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png)\n\n调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能\n\n![image-20240525144654678](https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png)\n\n六种调度算法全称分别是\n\n1. 先到先执行\n2. 非抢占式短作业优先\n3. 最短剩余时间优先（抢占式最短作业优先）\n4. 非抢占式优先级优先\n5. 抢占式优先级优先\n6. 时间片轮转算法\n\n使用方法为：\n\n1. 输入每个进程的前四列信息\n2. 选择算法\n3. 点击计算\n\n1.0.1版本可能遇到的问题：\n\n1. 请勿设置相同进程号\n2. 请勿设置小数时间片轮转或设置为0\n3. 给定的完成时间，周转时间，等待时间将被忽略","slug":"三种操作系统模拟软件使用手册","published":1,"updated":"2024-08-14T13:38:59.744Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7b9z00172wwvgavr3uvs","content":"<h1 id=\"三种操作系统简单模拟使用手册\"><a href=\"#三种操作系统简单模拟使用手册\" class=\"headerlink\" title=\"三种操作系统简单模拟使用手册\"></a>三种操作系统简单模拟使用手册</h1><h2 id=\"可运行程序图标\"><a href=\"#可运行程序图标\" class=\"headerlink\" title=\"可运行程序图标\"></a>可运行程序图标</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBcC1lblk3Y2tMQU5ncEJUVnZOSlhHS2ktM3RSWnc=\">https://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><img src=\"https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png\" alt=\"image-20240525143542993\"></p>\n<span id=\"more\"></span>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>程序提供了三种安装形式。</p>\n<h3 id=\"exe模式\"><a href=\"#exe模式\" class=\"headerlink\" title=\"exe模式\"></a>exe模式</h3><p>第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamF2YS5jb20vemgtQ04vZG93bmxvYWQvbWFudWFsLmpzcA==\">Java官网<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"JAR模式\"><a href=\"#JAR模式\" class=\"headerlink\" title=\"JAR模式\"></a>JAR模式</h3><p>第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用</p>\n<!--more-->\n<h3 id=\"install安装包模式\"><a href=\"#install安装包模式\" class=\"headerlink\" title=\"install安装包模式\"></a>install安装包模式</h3><p>第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。</p>\n<h2 id=\"卸载方式\"><a href=\"#卸载方式\" class=\"headerlink\" title=\"卸载方式\"></a>卸载方式</h2><p>通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。</p>\n<h2 id=\"程序使用指南\"><a href=\"#程序使用指南\" class=\"headerlink\" title=\"程序使用指南\"></a>程序使用指南</h2><h3 id=\"开源协议窗口\"><a href=\"#开源协议窗口\" class=\"headerlink\" title=\"开源协议窗口\"></a>开源协议窗口</h3><p><img src=\"https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png\" alt=\"image-20240525143707804\"></p>\n<p>该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。</p>\n<h3 id=\"导航菜单界面\"><a href=\"#导航菜单界面\" class=\"headerlink\" title=\"导航菜单界面\"></a>导航菜单界面</h3><p><img src=\"https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png\" alt=\"image-20240525143849896\"></p>\n<p>该界面为程序主题界面，可通过界面导航到三个算法界面</p>\n<h3 id=\"生产者消费者\"><a href=\"#生产者消费者\" class=\"headerlink\" title=\"生产者消费者\"></a>生产者消费者</h3><p><img src=\"https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png\" alt=\"image-20240525144036276\"></p>\n<p>该界面可实现生产者消费者业务功能</p>\n<p>使用方式为：</p>\n<ol>\n<li>按照程序显示按钮进行操作，请勿输入未指定的，空数据。</li>\n</ol>\n<p>1.0.1 版本常见问题为：</p>\n<ol>\n<li>该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。</li>\n</ol>\n<h3 id=\"银行家算法\"><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h3><p>   <img src=\"https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png\" alt=\"image-20240525144551258\"></p>\n<p>该界面为银行家算法界面，可实现银行家算法的功能与设计</p>\n<p>使用方式为：</p>\n<ol>\n<li>给定总进程与总资源数</li>\n<li>设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵</li>\n<li>是否继续请求</li>\n</ol>\n<p>1.0.1版本可能遇到的问题：</p>\n<ol>\n<li>设定过多进程与资源数导致无法输入</li>\n<li><img src=\"https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png\" alt=\"image-20240525145256829\"></li>\n</ol>\n<h3 id=\"调度算法模拟\"><a href=\"#调度算法模拟\" class=\"headerlink\" title=\"调度算法模拟\"></a>调度算法模拟</h3><p><img src=\"https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png\" alt=\"image-20240525144538081\"></p>\n<p>调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能</p>\n<p><img src=\"https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png\" alt=\"image-20240525144654678\"></p>\n<p>六种调度算法全称分别是</p>\n<ol>\n<li>先到先执行</li>\n<li>非抢占式短作业优先</li>\n<li>最短剩余时间优先（抢占式最短作业优先）</li>\n<li>非抢占式优先级优先</li>\n<li>抢占式优先级优先</li>\n<li>时间片轮转算法</li>\n</ol>\n<p>使用方法为：</p>\n<ol>\n<li>输入每个进程的前四列信息</li>\n<li>选择算法</li>\n<li>点击计算</li>\n</ol>\n<p>1.0.1版本可能遇到的问题：</p>\n<ol>\n<li>请勿设置相同进程号</li>\n<li>请勿设置小数时间片轮转或设置为0</li>\n<li>给定的完成时间，周转时间，等待时间将被忽略</li>\n</ol>\n","length":830,"excerpt":"<h1 id=\"三种操作系统简单模拟使用手册\"><a href=\"#三种操作系统简单模拟使用手册\" class=\"headerlink\" title=\"三种操作系统简单模拟使用手册\"></a>三种操作系统简单模拟使用手册</h1><h2 id=\"可运行程序图标\"><a href=\"#可运行程序图标\" class=\"headerlink\" title=\"可运行程序图标\"></a>可运行程序图标</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBcC1lblk3Y2tMQU5ncEJUVnZOSlhHS2ktM3RSWnc=\">https://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><img src=\"https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png\" alt=\"image-20240525143542993\"></p>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>程序提供了三种安装形式。</p>\n<h3 id=\"exe模式\"><a href=\"#exe模式\" class=\"headerlink\" title=\"exe模式\"></a>exe模式</h3><p>第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamF2YS5jb20vemgtQ04vZG93bmxvYWQvbWFudWFsLmpzcA==\">Java官网<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"JAR模式\"><a href=\"#JAR模式\" class=\"headerlink\" title=\"JAR模式\"></a>JAR模式</h3><p>第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用</p>\n<!--more-->\n<h3 id=\"install安装包模式\"><a href=\"#install安装包模式\" class=\"headerlink\" title=\"install安装包模式\"></a>install安装包模式</h3><p>第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。</p>\n<h2 id=\"卸载方式\"><a href=\"#卸载方式\" class=\"headerlink\" title=\"卸载方式\"></a>卸载方式</h2><p>通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。</p>\n<h2 id=\"程序使用指南\"><a href=\"#程序使用指南\" class=\"headerlink\" title=\"程序使用指南\"></a>程序使用指南</h2><h3 id=\"开源协议窗口\"><a href=\"#开源协议窗口\" class=\"headerlink\" title=\"开源协议窗口\"></a>开源协议窗口</h3><p><img src=\"https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png\" alt=\"image-20240525143707804\"></p>\n<p>该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。</p>\n<h3 id=\"导航菜单界面\"><a href=\"#导航菜单界面\" class=\"headerlink\" title=\"导航菜单界面\"></a>导航菜单界面</h3><p><img src=\"https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png\" alt=\"image-20240525143849896\"></p>\n<p>该界面为程序主题界面，可通过界面导航到三个算法界面</p>\n<h3 id=\"生产者消费者\"><a href=\"#生产者消费者\" class=\"headerlink\" title=\"生产者消费者\"></a>生产者消费者</h3><p><img src=\"https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png\" alt=\"image-20240525144036276\"></p>\n<p>该界面可实现生产者消费者业务功能</p>\n<p>使用方式为：</p>\n<ol>\n<li>按照程序显示按钮进行操作，请勿输入未指定的，空数据。</li>\n</ol>\n<p>1.0.1 版本常见问题为：</p>\n<ol>\n<li>该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。</li>\n</ol>\n<h3 id=\"银行家算法\"><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h3><p>   <img src=\"https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png\" alt=\"image-20240525144551258\"></p>\n<p>该界面为银行家算法界面，可实现银行家算法的功能与设计</p>\n<p>使用方式为：</p>\n<ol>\n<li>给定总进程与总资源数</li>\n<li>设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵</li>\n<li>是否继续请求</li>\n</ol>\n<p>1.0.1版本可能遇到的问题：</p>\n<ol>\n<li>设定过多进程与资源数导致无法输入</li>\n<li><img src=\"https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png\" alt=\"image-20240525145256829\"></li>\n</ol>\n<h3 id=\"调度算法模拟\"><a href=\"#调度算法模拟\" class=\"headerlink\" title=\"调度算法模拟\"></a>调度算法模拟</h3><p><img src=\"https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png\" alt=\"image-20240525144538081\"></p>\n<p>调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能</p>\n<p><img src=\"https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png\" alt=\"image-20240525144654678\"></p>\n<p>六种调度算法全称分别是</p>\n<ol>\n<li>先到先执行</li>\n<li>非抢占式短作业优先</li>\n<li>最短剩余时间优先（抢占式最短作业优先）</li>\n<li>非抢占式优先级优先</li>\n<li>抢占式优先级优先</li>\n<li>时间片轮转算法</li>\n</ol>\n<p>使用方法为：</p>\n<ol>\n<li>输入每个进程的前四列信息</li>\n<li>选择算法</li>\n<li>点击计算</li>\n</ol>\n<p>1.0.1版本可能遇到的问题：</p>\n<ol>\n<li>请勿设置相同进程号</li>\n<li>请勿设置小数时间片轮转或设置为0</li>\n<li>给定的完成时间，周转时间，等待时间将被忽略</li>\n</ol>"},{"title":"为什么我用Typora——Typora与其他markdown的比较","date":"2023-08-13T07:20:34.000Z","_content":"## Typora\n\n​\tTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。\n\n<!--more-->\n\n## Typora的Markdown语法\n\n​\tTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。\n\n​\t但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在**Latex语法格式**。\n\n​\t因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。\n\n> ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化\n\n<!--more-->\n\n### 代码块语法\n\n​\t代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行\n\n### Html、js、css\n\n​\tTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。\n\n​\t通过html也可以实现索引官方的方式是 `[这样]()`\n\n## Typora中的Mermaid，Latex\n\n​\tMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。\n\n​\t但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此**Typora并未bundle Fontawesome**。因此无法使用fa: fa-xxx表示图标。\n\n## Typora中的媒体\n\n​\tTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：\n\n1. 以ssms图床为例[Image Upload - SM.MS - Simple Free Image Hosting](https://sm.ms/)\n2. 到ssms官网注册张航并拿到apikey\n3. 填入picgo插件的配置文件\n4. ![配置图](https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png)\n\n> ```\n> {\n>   \"picBed\": {\n>     \"current\": \"smms\",\n>     \"smms\": {\n>       \"token\": \"xxx\"\n>     }\n>   },\n>   \"picgoPlugins\": {}\n> }\n> ```\n\n5. 测试并运行\n\n## Typora的文档保存机制\n\n​\t当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失\n\n## Typora的个性化主题\n\n​\tTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。\n\n## 总结\n\n​\t对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。\n\n## 一些比较实用的不在Typora文档中的使用技巧\n\n1. 通过html标签扩展typora的显示格式\n\n   如`<details></details>`标签可以显示一个展开栏，做错题本时很好用\n\n2. 一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin\n\n   [obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)](https://github.com/obgnail/typora_plugin)\n\n---\n\n待更新","source":"_posts/为什么我用Typora——Typora与其他markdown的比较.md","raw":"---\ntitle: 为什么我用Typora——Typora与其他markdown的比较\ndate: 2023-08-13 15:20:34\ntags: [Typora, Markdown, 随笔]\ncategories:\n   - 软件\n   - 编辑器\n   - Markdown\n---\n## Typora\n\n​\tTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。\n\n<!--more-->\n\n## Typora的Markdown语法\n\n​\tTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。\n\n​\t但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在**Latex语法格式**。\n\n​\t因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。\n\n> ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化\n\n<!--more-->\n\n### 代码块语法\n\n​\t代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行\n\n### Html、js、css\n\n​\tTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。\n\n​\t通过html也可以实现索引官方的方式是 `[这样]()`\n\n## Typora中的Mermaid，Latex\n\n​\tMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。\n\n​\t但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此**Typora并未bundle Fontawesome**。因此无法使用fa: fa-xxx表示图标。\n\n## Typora中的媒体\n\n​\tTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：\n\n1. 以ssms图床为例[Image Upload - SM.MS - Simple Free Image Hosting](https://sm.ms/)\n2. 到ssms官网注册张航并拿到apikey\n3. 填入picgo插件的配置文件\n4. ![配置图](https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png)\n\n> ```\n> {\n>   \"picBed\": {\n>     \"current\": \"smms\",\n>     \"smms\": {\n>       \"token\": \"xxx\"\n>     }\n>   },\n>   \"picgoPlugins\": {}\n> }\n> ```\n\n5. 测试并运行\n\n## Typora的文档保存机制\n\n​\t当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失\n\n## Typora的个性化主题\n\n​\tTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。\n\n## 总结\n\n​\t对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。\n\n## 一些比较实用的不在Typora文档中的使用技巧\n\n1. 通过html标签扩展typora的显示格式\n\n   如`<details></details>`标签可以显示一个展开栏，做错题本时很好用\n\n2. 一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin\n\n   [obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)](https://github.com/obgnail/typora_plugin)\n\n---\n\n待更新","slug":"为什么我用Typora——Typora与其他markdown的比较","published":1,"updated":"2024-08-14T13:39:02.327Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7ba000192wwv734e6awe","content":"<h2 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h2><p>​    Typora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。</p>\n<span id=\"more\"></span>\n<h2 id=\"Typora的Markdown语法\"><a href=\"#Typora的Markdown语法\" class=\"headerlink\" title=\"Typora的Markdown语法\"></a>Typora的Markdown语法</h2><p>​    Typora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。</p>\n<p>​    但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在<strong>Latex语法格式</strong>。</p>\n<p>​    因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。</p>\n<blockquote>\n<p>ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化</p>\n</blockquote>\n<!--more-->\n<h3 id=\"代码块语法\"><a href=\"#代码块语法\" class=\"headerlink\" title=\"代码块语法\"></a>代码块语法</h3><p>​    代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行</p>\n<h3 id=\"Html、js、css\"><a href=\"#Html、js、css\" class=\"headerlink\" title=\"Html、js、css\"></a>Html、js、css</h3><p>​    Typora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。</p>\n<p>​    通过html也可以实现索引官方的方式是 <code>[这样]()</code></p>\n<h2 id=\"Typora中的Mermaid，Latex\"><a href=\"#Typora中的Mermaid，Latex\" class=\"headerlink\" title=\"Typora中的Mermaid，Latex\"></a>Typora中的Mermaid，Latex</h2><p>​    Markdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。</p>\n<p>​    但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此<strong>Typora并未bundle Fontawesome</strong>。因此无法使用fa: fa-xxx表示图标。</p>\n<h2 id=\"Typora中的媒体\"><a href=\"#Typora中的媒体\" class=\"headerlink\" title=\"Typora中的媒体\"></a>Typora中的媒体</h2><p>​    Typora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：</p>\n<ol>\n<li>以ssms图床为例<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zbS5tcy8=\">Image Upload - SM.MS - Simple Free Image Hosting<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>到ssms官网注册张航并拿到apikey</li>\n<li>填入picgo插件的配置文件</li>\n<li><img src=\"https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png\" alt=\"配置图\"></li>\n</ol>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;picBed&quot;: &#123;</span><br><span class=\"line\">    &quot;current&quot;: &quot;smms&quot;,</span><br><span class=\"line\">    &quot;smms&quot;: &#123;</span><br><span class=\"line\">      &quot;token&quot;: &quot;xxx&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;picgoPlugins&quot;: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ol>\n<li>测试并运行</li>\n</ol>\n<h2 id=\"Typora的文档保存机制\"><a href=\"#Typora的文档保存机制\" class=\"headerlink\" title=\"Typora的文档保存机制\"></a>Typora的文档保存机制</h2><p>​    当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失</p>\n<h2 id=\"Typora的个性化主题\"><a href=\"#Typora的个性化主题\" class=\"headerlink\" title=\"Typora的个性化主题\"></a>Typora的个性化主题</h2><p>​    Typora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​    对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。</p>\n<h2 id=\"一些比较实用的不在Typora文档中的使用技巧\"><a href=\"#一些比较实用的不在Typora文档中的使用技巧\" class=\"headerlink\" title=\"一些比较实用的不在Typora文档中的使用技巧\"></a>一些比较实用的不在Typora文档中的使用技巧</h2><ol>\n<li><p>通过html标签扩展typora的显示格式</p>\n<p>如<code>&lt;details&gt;&lt;/details&gt;</code>标签可以显示一个展开栏，做错题本时很好用</p>\n</li>\n<li><p>一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29iZ25haWwvdHlwb3JhX3BsdWdpbg==\">obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n</ol>\n<hr>\n<p>待更新</p>\n","length":1122,"excerpt":"<h2 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h2><p>​    Typora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。</p>","more":"<h2 id=\"Typora的Markdown语法\"><a href=\"#Typora的Markdown语法\" class=\"headerlink\" title=\"Typora的Markdown语法\"></a>Typora的Markdown语法</h2><p>​    Typora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。</p>\n<p>​    但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在<strong>Latex语法格式</strong>。</p>\n<p>​    因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。</p>\n<blockquote>\n<p>ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化</p>\n</blockquote>\n<!--more-->\n<h3 id=\"代码块语法\"><a href=\"#代码块语法\" class=\"headerlink\" title=\"代码块语法\"></a>代码块语法</h3><p>​    代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行</p>\n<h3 id=\"Html、js、css\"><a href=\"#Html、js、css\" class=\"headerlink\" title=\"Html、js、css\"></a>Html、js、css</h3><p>​    Typora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。</p>\n<p>​    通过html也可以实现索引官方的方式是 <code>[这样]()</code></p>\n<h2 id=\"Typora中的Mermaid，Latex\"><a href=\"#Typora中的Mermaid，Latex\" class=\"headerlink\" title=\"Typora中的Mermaid，Latex\"></a>Typora中的Mermaid，Latex</h2><p>​    Markdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。</p>\n<p>​    但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此<strong>Typora并未bundle Fontawesome</strong>。因此无法使用fa: fa-xxx表示图标。</p>\n<h2 id=\"Typora中的媒体\"><a href=\"#Typora中的媒体\" class=\"headerlink\" title=\"Typora中的媒体\"></a>Typora中的媒体</h2><p>​    Typora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：</p>\n<ol>\n<li>以ssms图床为例<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zbS5tcy8=\">Image Upload - SM.MS - Simple Free Image Hosting<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>到ssms官网注册张航并拿到apikey</li>\n<li>填入picgo插件的配置文件</li>\n<li><img src=\"https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png\" alt=\"配置图\"></li>\n</ol>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;picBed&quot;: &#123;</span><br><span class=\"line\">    &quot;current&quot;: &quot;smms&quot;,</span><br><span class=\"line\">    &quot;smms&quot;: &#123;</span><br><span class=\"line\">      &quot;token&quot;: &quot;xxx&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;picgoPlugins&quot;: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ol>\n<li>测试并运行</li>\n</ol>\n<h2 id=\"Typora的文档保存机制\"><a href=\"#Typora的文档保存机制\" class=\"headerlink\" title=\"Typora的文档保存机制\"></a>Typora的文档保存机制</h2><p>​    当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失</p>\n<h2 id=\"Typora的个性化主题\"><a href=\"#Typora的个性化主题\" class=\"headerlink\" title=\"Typora的个性化主题\"></a>Typora的个性化主题</h2><p>​    Typora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​    对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。</p>\n<h2 id=\"一些比较实用的不在Typora文档中的使用技巧\"><a href=\"#一些比较实用的不在Typora文档中的使用技巧\" class=\"headerlink\" title=\"一些比较实用的不在Typora文档中的使用技巧\"></a>一些比较实用的不在Typora文档中的使用技巧</h2><ol>\n<li><p>通过html标签扩展typora的显示格式</p>\n<p>如<code>&lt;details&gt;&lt;/details&gt;</code>标签可以显示一个展开栏，做错题本时很好用</p>\n</li>\n<li><p>一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29iZ25haWwvdHlwb3JhX3BsdWdpbg==\">obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n</ol>\n<hr>\n<p>待更新</p>"},{"title":"字符串","date":"2024-08-14T11:37:01.000Z","_content":"# 题意：\n\n给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。\n\n# 题解：\n\n子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。\n\n子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt\\[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。\n\n这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。\n\n<!--more-->\n\n```cpp\nvoid get_next(){\n    for(int i=n;i>=0;i--){\n        for(int j=0;j<26;j++){\n            if(i==n) nxt[i][j]=n;\n            else nxt[i][j]=nxt[i+1][j];\n        }\n        if(i!=n) nxt[i][s[i]-'A']=i;\n    }\n}\n\nint get_pos(int st,string s){\n    int first=1;\n    for(auto ch:s){\n        if(first) st=nxt[st][ch-'A'];\n        else st=nxt[st+1][ch-'A'];\n        first=0;\n        if(st==n) return st;\n    }\n    return st;\n}\n\nvoid slove(){\n    cin>>n>>k>>s;\n    get_next();\n    string ac=\"ACCEPT\",wa=\"WA\";\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        int r1=get_pos(i,ac),r2=get_pos(i,wa);\n        r1=max(r1,i+k-1);\n        ans=ans+max(r2-r1,0ll);\n    }\n    cout<<ans<<endl;\n}\n```\n\n","source":"_posts/字符串习题1.md","raw":"---\ntitle: 字符串\ndate: 2024-08-14 19:37:01\ntags: [算法, 子序列自动机]\ncategories: \n\t- 算法\n\t- 字符串\n\t- 子序列自动机\n---\n# 题意：\n\n给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。\n\n# 题解：\n\n子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。\n\n子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt\\[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。\n\n这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。\n\n<!--more-->\n\n```cpp\nvoid get_next(){\n    for(int i=n;i>=0;i--){\n        for(int j=0;j<26;j++){\n            if(i==n) nxt[i][j]=n;\n            else nxt[i][j]=nxt[i+1][j];\n        }\n        if(i!=n) nxt[i][s[i]-'A']=i;\n    }\n}\n\nint get_pos(int st,string s){\n    int first=1;\n    for(auto ch:s){\n        if(first) st=nxt[st][ch-'A'];\n        else st=nxt[st+1][ch-'A'];\n        first=0;\n        if(st==n) return st;\n    }\n    return st;\n}\n\nvoid slove(){\n    cin>>n>>k>>s;\n    get_next();\n    string ac=\"ACCEPT\",wa=\"WA\";\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        int r1=get_pos(i,ac),r2=get_pos(i,wa);\n        r1=max(r1,i+k-1);\n        ans=ans+max(r2-r1,0ll);\n    }\n    cout<<ans<<endl;\n}\n```\n\n","slug":"字符串习题1","published":1,"updated":"2024-08-14T13:39:05.118Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7ba0001b2wwv49oac8vr","content":"<h1 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h1><p>给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。</p>\n<h1 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h1><p>子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。</p>\n<p>子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。</p>\n<p>这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA”，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">26</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==n) nxt[i][j]=n;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nxt[i][j]=nxt[i<span class=\"number\">+1</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=n) nxt[i][s[i]-<span class=\"string\">&#x27;A&#x27;</span>]=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pos</span><span class=\"params\">(<span class=\"type\">int</span> st,string s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> first=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> ch:s)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first) st=nxt[st][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> st=nxt[st<span class=\"number\">+1</span>][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        first=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st==n) <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">get_next</span>();</span><br><span class=\"line\">    string ac=<span class=\"string\">&quot;ACCEPT&quot;</span>,wa=<span class=\"string\">&quot;WA&quot;</span>;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> r1=<span class=\"built_in\">get_pos</span>(i,ac),r2=<span class=\"built_in\">get_pos</span>(i,wa);</span><br><span class=\"line\">        r1=<span class=\"built_in\">max</span>(r1,i+k<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ans=ans+<span class=\"built_in\">max</span>(r2-r1,<span class=\"number\">0ll</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":310,"excerpt":"<h1 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h1><p>给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。</p>\n<h1 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h1><p>子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。</p>\n<p>子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。</p>\n<p>这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA”，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">26</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==n) nxt[i][j]=n;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nxt[i][j]=nxt[i<span class=\"number\">+1</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=n) nxt[i][s[i]-<span class=\"string\">&#x27;A&#x27;</span>]=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pos</span><span class=\"params\">(<span class=\"type\">int</span> st,string s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> first=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> ch:s)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first) st=nxt[st][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> st=nxt[st<span class=\"number\">+1</span>][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        first=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st==n) <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">get_next</span>();</span><br><span class=\"line\">    string ac=<span class=\"string\">&quot;ACCEPT&quot;</span>,wa=<span class=\"string\">&quot;WA&quot;</span>;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> r1=<span class=\"built_in\">get_pos</span>(i,ac),r2=<span class=\"built_in\">get_pos</span>(i,wa);</span><br><span class=\"line\">        r1=<span class=\"built_in\">max</span>(r1,i+k<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ans=ans+<span class=\"built_in\">max</span>(r2-r1,<span class=\"number\">0ll</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"思维题1","date":"2024-08-14T11:35:22.000Z","_content":"# 题意\n题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小\n\n# 题解\n题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt->ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。\n\n<!--more-->\n\n```cpp\nvoid slove(){\n    cin>>n;\n    string s;\n    cin>>s;\n    int cnt = 0,ans = 0;\n\n    for(int i=0;i<n;i++){\n        if(s[i]=='0'){\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2)%MOD;\n        }else if(s[i]&1){\n            cnt=(cnt*2+1)%MOD;\n        }else{\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2+1)%MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。\n\n对于每一个偶数计算它的贡献值为$$2^{i-1}$$，对于每一个0计算它的贡献为$$-2^{n-i}$$，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。","source":"_posts/思维题习题1.md","raw":"---\ntitle: 思维题1\ndate: 2024-08-14 19:35:22\ntags: [算法, 思维题]\ncategories: \n\t- 算法\n\t- 思维题\n---\n# 题意\n题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小\n\n# 题解\n题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt->ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。\n\n<!--more-->\n\n```cpp\nvoid slove(){\n    cin>>n;\n    string s;\n    cin>>s;\n    int cnt = 0,ans = 0;\n\n    for(int i=0;i<n;i++){\n        if(s[i]=='0'){\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2)%MOD;\n        }else if(s[i]&1){\n            cnt=(cnt*2+1)%MOD;\n        }else{\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2+1)%MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。\n\n对于每一个偶数计算它的贡献值为$$2^{i-1}$$，对于每一个0计算它的贡献为$$-2^{n-i}$$，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。","slug":"思维题习题1","published":1,"updated":"2024-08-14T13:39:08.223Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7ba1001d2wwvaxlv0cdm","content":"<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><p>题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]==’0’时，将cnt-1，而ans保持相同计算。cnt-&gt;ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。</p>\n<p>对于每一个偶数计算它的贡献值为<script type=\"math/tex\">2^{i-1}</script>，对于每一个0计算它的贡献为<script type=\"math/tex\">-2^{n-i}</script>，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。</p>\n","length":345,"excerpt":"<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小</p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><p>题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]==’0’时，将cnt-1，而ans保持相同计算。cnt-&gt;ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。</p>\n<p>对于每一个偶数计算它的贡献值为<script type=\"math/tex\">2^{i-1}</script>，对于每一个0计算它的贡献为<script type=\"math/tex\">-2^{n-i}</script>，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。</p>"},{"title":"数学距离问题1","date":"2024-08-14T11:43:20.000Z","_content":"## 题意：\n\n给一个国际象棋中的“象”，但每次只能走一格，给N个点\n\n计算总和 $\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N \\text{dist}(P_i, P_j)$​ 。\n\n<!--more-->\n\n## 题解：\n\n注意到实际上这样的走法将整个棋盘以$$x+y$$的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\n$$\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\n$$\n即两个点之间的切比雪夫距离。\n\n证明如下，对于任意两个$$x+y$$奇偶性相同的顶点而言，设起始点为$$(x,y)$$，目的点为$$(xx,yy)$$设dx<dy即$$dist(p_i,p_j) = |p_i.y-p_j.y|$$。\n\n$$xx=x+dx,yy=y+dy$$，则有$$dx = a-b，a+b=dy$$，根据定义可知$$dy=yy-y$$​。\n\n由以上公式,且x,y的奇偶性相同可知xx为在dx<dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。\n\n详细参考[距离 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/geometry/distance/)\n\n如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）\n\n上图(1,4) -> (1,3)\n\n于是题目变为了求n个点的哈密顿距离之和，很经典的题。\n\n由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。\n\n<img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" />\n\ncoding。。。\n\n```cpp\nvoid slove() {\n    cin>>n;\n\n    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;\n\n    for(int i=1;i<=n;i++) {\n        if((a[i].x+a[i].y) %2==1)\n            bx[1][++cn[1]] = a[i].x + a[i].y,by[1][cn[1]] = a[i].y - a[i].x;\n        else\n            bx[0][++cn[0]] = a[i].x + a[i].y,by[0][cn[0]] = a[i].y - a[i].x;\n    }\n\n    sort(bx[0]+1,bx[0]+1+cn[0]);\n    sort(bx[1]+1,bx[1]+1+cn[1]);\n    sort(by[0]+1,by[0]+1+cn[0]);\n    sort(by[1]+1,by[1]+1+cn[1]);\n    int ans = 0;\n    for(int k =0;k<=1;k++) {\n        int sum1 =0 ,sum2=0;\n        for(int i=1;i<=cn[k];i++) {\n            // cout<<k<<' '<<bx[k][i]<<' '<<by[k][i]<<endl;\n            ans += (i-1) * (bx[k][i]+by[k][i]) - sum1-sum2;\n            sum1 += bx[k][i];\n            sum2 += by[k][i];\n        }\n    }\n    cout<<ans/2<<endl;\n}\n```\n\n","source":"_posts/数学距离问题1.md","raw":"---\ntitle: 数学距离问题1\ndate: 2024-08-14 19:43:20\ntags: [算法, 思维题, 坐标系转换, 几何问题]\ncategories: \n\t- 算法\n\t- 思维题\n---\n## 题意：\n\n给一个国际象棋中的“象”，但每次只能走一格，给N个点\n\n计算总和 $\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N \\text{dist}(P_i, P_j)$​ 。\n\n<!--more-->\n\n## 题解：\n\n注意到实际上这样的走法将整个棋盘以$$x+y$$的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\n$$\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\n$$\n即两个点之间的切比雪夫距离。\n\n证明如下，对于任意两个$$x+y$$奇偶性相同的顶点而言，设起始点为$$(x,y)$$，目的点为$$(xx,yy)$$设dx<dy即$$dist(p_i,p_j) = |p_i.y-p_j.y|$$。\n\n$$xx=x+dx,yy=y+dy$$，则有$$dx = a-b，a+b=dy$$，根据定义可知$$dy=yy-y$$​。\n\n由以上公式,且x,y的奇偶性相同可知xx为在dx<dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。\n\n详细参考[距离 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/geometry/distance/)\n\n如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）\n\n上图(1,4) -> (1,3)\n\n于是题目变为了求n个点的哈密顿距离之和，很经典的题。\n\n由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。\n\n<img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" />\n\ncoding。。。\n\n```cpp\nvoid slove() {\n    cin>>n;\n\n    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;\n\n    for(int i=1;i<=n;i++) {\n        if((a[i].x+a[i].y) %2==1)\n            bx[1][++cn[1]] = a[i].x + a[i].y,by[1][cn[1]] = a[i].y - a[i].x;\n        else\n            bx[0][++cn[0]] = a[i].x + a[i].y,by[0][cn[0]] = a[i].y - a[i].x;\n    }\n\n    sort(bx[0]+1,bx[0]+1+cn[0]);\n    sort(bx[1]+1,bx[1]+1+cn[1]);\n    sort(by[0]+1,by[0]+1+cn[0]);\n    sort(by[1]+1,by[1]+1+cn[1]);\n    int ans = 0;\n    for(int k =0;k<=1;k++) {\n        int sum1 =0 ,sum2=0;\n        for(int i=1;i<=cn[k];i++) {\n            // cout<<k<<' '<<bx[k][i]<<' '<<by[k][i]<<endl;\n            ans += (i-1) * (bx[k][i]+by[k][i]) - sum1-sum2;\n            sum1 += bx[k][i];\n            sum2 += by[k][i];\n        }\n    }\n    cout<<ans/2<<endl;\n}\n```\n\n","slug":"数学距离问题1","published":1,"updated":"2024-08-14T13:39:11.945Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7ba1001f2wwv7fua3fl0","content":"<h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>给一个国际象棋中的“象”，但每次只能走一格，给N个点</p>\n<p>计算总和 $\\displaystyle\\sum<em>{i=1}^{N-1}\\displaystyle\\sum</em>{j=i+1}^N \\text{dist}(P_i, P_j)$​ 。</p>\n<span id=\"more\"></span>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>注意到实际上这样的走法将整个棋盘以<script type=\"math/tex\">x+y</script>的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：</p>\n<script type=\"math/tex; mode=display\">\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)</script><p>即两个点之间的切比雪夫距离。</p>\n<p>证明如下，对于任意两个<script type=\"math/tex\">x+y</script>奇偶性相同的顶点而言，设起始点为<script type=\"math/tex\">(x,y)</script>，目的点为<script type=\"math/tex\">(xx,yy)</script>设dx&lt;dy即<script type=\"math/tex\">dist(p_i,p_j) = |p_i.y-p_j.y|</script>。</p>\n<p><script type=\"math/tex\">xx=x+dx,yy=y+dy</script>，则有<script type=\"math/tex\">dx = a-b，a+b=dy</script>，根据定义可知<script type=\"math/tex\">dy=yy-y</script>​。</p>\n<p>由以上公式,且x,y的奇偶性相同可知xx为在dx&lt;dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。</p>\n<p>详细参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaS13aWtpLm9yZy9nZW9tZXRyeS9kaXN0YW5jZS8=\">距离 - OI Wiki (oi-wiki.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）</p>\n<p>上图(1,4) -&gt; (1,3)</p>\n<p>于是题目变为了求n个点的哈密顿距离之和，很经典的题。</p>\n<p>由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。</p>\n<p><img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" /></p>\n<p>coding。。。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((a[i].x+a[i].y) %<span class=\"number\">2</span>==<span class=\"number\">1</span>)</span><br><span class=\"line\">            bx[<span class=\"number\">1</span>][++cn[<span class=\"number\">1</span>]] = a[i].x + a[i].y,by[<span class=\"number\">1</span>][cn[<span class=\"number\">1</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            bx[<span class=\"number\">0</span>][++cn[<span class=\"number\">0</span>]] = a[i].x + a[i].y,by[<span class=\"number\">0</span>][cn[<span class=\"number\">0</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k =<span class=\"number\">0</span>;k&lt;=<span class=\"number\">1</span>;k++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum1 =<span class=\"number\">0</span> ,sum2=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cn[k];i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;bx[k][i]&lt;&lt;&#x27; &#x27;&lt;&lt;by[k][i]&lt;&lt;endl;</span></span><br><span class=\"line\">            ans += (i<span class=\"number\">-1</span>) * (bx[k][i]+by[k][i]) - sum1-sum2;</span><br><span class=\"line\">            sum1 += bx[k][i];</span><br><span class=\"line\">            sum2 += by[k][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":638,"excerpt":"<h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>给一个国际象棋中的“象”，但每次只能走一格，给N个点</p>\n<p>计算总和 $\\displaystyle\\sum<em>{i=1}^{N-1}\\displaystyle\\sum</em>{j=i+1}^N \\text{dist}(P_i, P_j)$​ 。</p>","more":"<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>注意到实际上这样的走法将整个棋盘以<script type=\"math/tex\">x+y</script>的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：</p>\n<script type=\"math/tex; mode=display\">\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)</script><p>即两个点之间的切比雪夫距离。</p>\n<p>证明如下，对于任意两个<script type=\"math/tex\">x+y</script>奇偶性相同的顶点而言，设起始点为<script type=\"math/tex\">(x,y)</script>，目的点为<script type=\"math/tex\">(xx,yy)</script>设dx&lt;dy即<script type=\"math/tex\">dist(p_i,p_j) = |p_i.y-p_j.y|</script>。</p>\n<p><script type=\"math/tex\">xx=x+dx,yy=y+dy</script>，则有<script type=\"math/tex\">dx = a-b，a+b=dy</script>，根据定义可知<script type=\"math/tex\">dy=yy-y</script>​。</p>\n<p>由以上公式,且x,y的奇偶性相同可知xx为在dx&lt;dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。</p>\n<p>详细参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaS13aWtpLm9yZy9nZW9tZXRyeS9kaXN0YW5jZS8=\">距离 - OI Wiki (oi-wiki.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）</p>\n<p>上图(1,4) -&gt; (1,3)</p>\n<p>于是题目变为了求n个点的哈密顿距离之和，很经典的题。</p>\n<p>由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。</p>\n<p><img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" /></p>\n<p>coding。。。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((a[i].x+a[i].y) %<span class=\"number\">2</span>==<span class=\"number\">1</span>)</span><br><span class=\"line\">            bx[<span class=\"number\">1</span>][++cn[<span class=\"number\">1</span>]] = a[i].x + a[i].y,by[<span class=\"number\">1</span>][cn[<span class=\"number\">1</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            bx[<span class=\"number\">0</span>][++cn[<span class=\"number\">0</span>]] = a[i].x + a[i].y,by[<span class=\"number\">0</span>][cn[<span class=\"number\">0</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k =<span class=\"number\">0</span>;k&lt;=<span class=\"number\">1</span>;k++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum1 =<span class=\"number\">0</span> ,sum2=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cn[k];i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;bx[k][i]&lt;&lt;&#x27; &#x27;&lt;&lt;by[k][i]&lt;&lt;endl;</span></span><br><span class=\"line\">            ans += (i<span class=\"number\">-1</span>) * (bx[k][i]+by[k][i]) - sum1-sum2;</span><br><span class=\"line\">            sum1 += bx[k][i];</span><br><span class=\"line\">            sum2 += by[k][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"树上最短回文问题","date":"2024-08-14T11:39:46.000Z","_content":"## 题意\n\n给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？\n\n<!--more-->\n\n## 题解\n\n不想看回文的读者请跳转到“真的题解”\n\n看到回文，回顾回文！下面以数组为例子，求最长回文字符串。\n\n回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度\n\n回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。\n\n回文哈希二分：对于i，从前从后hax，二分回文长度。\n\n二分如下：\n\n```cpp\null get(ull h[], ull l, ull r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = p[i-1] * P;\n    int t =0;\n    while(cin>>s,s!=\"END\") {\n        n = s.size();\n\n        n *= 2;\n        s.resize(n);\n        for (int i = n; i; i -= 2)\n        {\n            s[i] = s[i / 2];\n            s[i - 1] = '#';\n        }\n        s = '#' + s;\n        n++;\n        // cout<<n<<endl;\n        // cout<<s<<nline;\n\n        for(int i=0;i<n;i++)if(!i) ph[i] = s[i];else ph[i] = ph[i-1] * P + s[i];\n        for(int i=n-1;~i;i--)if(i==n-1) rh[i] = s[i];else rh[i] = rh[i+1] * P + s[i];\n\n        int ans = 1;\n        for (int i = 1; i <= n; i ++ )\n        {\n            ull r = min(i - 1, n - i);\n            if (ans >= r || get(ph, i - ans, i - 1) != get(rh, n - (i + ans) + 1, n - i)) continue;\n            while (ans <= r && get(ph, i - ans, i - 1) == get(rh, n - (i + ans) + 1, n - i)) ans ++ ;\n            ans -- ;\n        }\n        cout<<\"Case \" << ++t<<\": \"<<ans<<endl;\n    }\n}\n```\n\n题解要开始加速了！\n\n首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化$$log_2n$$的解法！\n\n注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！\n\n```cpp\null ans = 1;\nfor (int i = 1; i <= n; i ++ )\n{\n  ull r = min(i - 1, n - i);\n  if (ans >= r || get(h1, i - ans, i - 1) != get(h2, n - (i + ans) + 1, n - i)) continue;\n  while (ans <= r && get(h1, i - ans, i - 1) == get(h2, n - (i + ans) + 1, n - i)) ans ++ ;\n  ans -- ;\n}\n```\n\n最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。\n\n简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R 回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）\n\n整个该算法的重点在于：“回文对称”！\n\n![img](https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg)\n\n即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。\n\n若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。\n\n若i-w[i_mirror]>=0即i_mirror的回文子串碰到了边界，则中心扩展i\n\n```cpp\n// 马拉车算法\npublic String longestPalindrome2(String s) {\n    String T = preProcess(s);\n    int n = T.length();\n    int[] P = new int[n];\n    int C = 0, R = 0;\n    for (int i = 1; i < n - 1; i++) {\n        int i_mirror = 2 * C - i;\n        if (R > i) {\n            P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R\n        } else {\n            P[i] = 0;// 等于 R 的情况\n        }\n\n        // 碰到之前讲的三种情况时候，需要利用中心扩展法\n        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\n            P[i]++;\n        }\n\n        // 判断是否需要更新 R\n        if (i + P[i] > R) {\n            C = i;\n            R = i + P[i];\n        }\n\n    }\n   \\\\代码source :https://zhuanlan.zhihu.com/p/70532099\n```\n\n## 真的题解\n\n上面讲了一串，最后还得是哈！希！，字符串，哈！希！\n\n最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。\n\n注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大$$n^2$$）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！\n\n但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。\n\n但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。\n\n```cpp\nvoid add(int a,int b) {\n    e[a].pb(b);\n    e[b].pb(a);\n}\n\nint qmi(int a,int b,int mod){\n    int res=1%mod;\n    while(b){\n        if(b&1) res=res*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return res;\n}\n\nvoid dfs1(int u = 1) {\n    siz[u] = 1;\n    int mx = 0;\n    for(int& v: e[u]) {\n        if(v==fa[u])continue;\n\n        depth[v] = depth[u] + 1;\n        ph[v]=(ph[u]*P%MOD+(s[v]-'a'+1))%MOD;\n        rh[v]=(rh[u]+p[depth[v]-1]*(s[v]-'a'+1)% MOD)%MOD;\n\n        f[v][0] = u;\n        for(int i=1;i<=20;i++)\n            f[v][i] = f[f[v][i-1]][i-1];\n        dfs1(v);\n        siz[u] += siz[v];\n        if(siz[v] > mx) {\n            mx = siz[v];hs[u] = v;\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int t = 1) {\n    len[t] ++;\n    top[u] = t;\n    if(siz[u] == 1) return ;\n    dfs2(hs[u],t);\n\n    for(int v: e[u]) {\n        if(v!=hs[u]&&v!=fa[u]) {\n            dfs2(v,v);\n        }\n    }\n}\n\nint lca(int a,int b) {\n    while(top[a] != top[b]) {\n        if(depth[top[a]] < depth[top[b]])swap(a,b);\n        a = fa[top[a]];\n    }\n    if(depth[a] < depth[b]) swap(a,b);\n    return b;\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = (p[i-1] * P) % MOD;\n    cin>>n;\n    cin>>s;\n    s = ' ' + s;\n    depth[1] = 1;\n    for(int i=1;i<=n;i++) {\n        cin>>fa[i];\n        if(fa[i]) add(i,fa[i]);\n        else fa[i] = -1;\n    }\n\n\n    ph[1]=s[1]-'a'+1,rh[1]=s[1]-'a'+1;\n    dfs1();dfs2();\n\n    cin>>m;\n    while(m--) {\n        int a,b;cin>>a>>b;\n        if(depth[a] < depth[b]) swap(a,b);\n        lc = lca(a,b);\n\n        int f=lca(a,b);\n        int p1=((rh[a]-rh[fa[f]]*qmi(p[depth[f]-1],MOD-2,MOD)%MOD)+MOD) %MOD;\n        int p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;\n        int ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;\n        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*qmi(p[depth[f]-1],MOD-2,MOD)%MOD;\n        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;\n        int ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;\n        cout<<(ans1==ans2?\"YES\\n\":\"NO\\n\");\n        cout<<f<<endl;\n        cout<<ans1<<' '<<ans2<<nline;\n    }\n}\n```\n\n","source":"_posts/树上回文问题.md","raw":"---\ntitle: 树上最短回文问题\ndate: 2024-08-14 19:39:46\ntags: [算法, 树问题，哈希算法]\ncategories: \n\t- 算法\n\t- 图论\n\t- 图论中的回文问题\n---\n## 题意\n\n给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？\n\n<!--more-->\n\n## 题解\n\n不想看回文的读者请跳转到“真的题解”\n\n看到回文，回顾回文！下面以数组为例子，求最长回文字符串。\n\n回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度\n\n回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。\n\n回文哈希二分：对于i，从前从后hax，二分回文长度。\n\n二分如下：\n\n```cpp\null get(ull h[], ull l, ull r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = p[i-1] * P;\n    int t =0;\n    while(cin>>s,s!=\"END\") {\n        n = s.size();\n\n        n *= 2;\n        s.resize(n);\n        for (int i = n; i; i -= 2)\n        {\n            s[i] = s[i / 2];\n            s[i - 1] = '#';\n        }\n        s = '#' + s;\n        n++;\n        // cout<<n<<endl;\n        // cout<<s<<nline;\n\n        for(int i=0;i<n;i++)if(!i) ph[i] = s[i];else ph[i] = ph[i-1] * P + s[i];\n        for(int i=n-1;~i;i--)if(i==n-1) rh[i] = s[i];else rh[i] = rh[i+1] * P + s[i];\n\n        int ans = 1;\n        for (int i = 1; i <= n; i ++ )\n        {\n            ull r = min(i - 1, n - i);\n            if (ans >= r || get(ph, i - ans, i - 1) != get(rh, n - (i + ans) + 1, n - i)) continue;\n            while (ans <= r && get(ph, i - ans, i - 1) == get(rh, n - (i + ans) + 1, n - i)) ans ++ ;\n            ans -- ;\n        }\n        cout<<\"Case \" << ++t<<\": \"<<ans<<endl;\n    }\n}\n```\n\n题解要开始加速了！\n\n首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化$$log_2n$$的解法！\n\n注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！\n\n```cpp\null ans = 1;\nfor (int i = 1; i <= n; i ++ )\n{\n  ull r = min(i - 1, n - i);\n  if (ans >= r || get(h1, i - ans, i - 1) != get(h2, n - (i + ans) + 1, n - i)) continue;\n  while (ans <= r && get(h1, i - ans, i - 1) == get(h2, n - (i + ans) + 1, n - i)) ans ++ ;\n  ans -- ;\n}\n```\n\n最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。\n\n简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R 回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）\n\n整个该算法的重点在于：“回文对称”！\n\n![img](https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg)\n\n即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。\n\n若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。\n\n若i-w[i_mirror]>=0即i_mirror的回文子串碰到了边界，则中心扩展i\n\n```cpp\n// 马拉车算法\npublic String longestPalindrome2(String s) {\n    String T = preProcess(s);\n    int n = T.length();\n    int[] P = new int[n];\n    int C = 0, R = 0;\n    for (int i = 1; i < n - 1; i++) {\n        int i_mirror = 2 * C - i;\n        if (R > i) {\n            P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R\n        } else {\n            P[i] = 0;// 等于 R 的情况\n        }\n\n        // 碰到之前讲的三种情况时候，需要利用中心扩展法\n        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\n            P[i]++;\n        }\n\n        // 判断是否需要更新 R\n        if (i + P[i] > R) {\n            C = i;\n            R = i + P[i];\n        }\n\n    }\n   \\\\代码source :https://zhuanlan.zhihu.com/p/70532099\n```\n\n## 真的题解\n\n上面讲了一串，最后还得是哈！希！，字符串，哈！希！\n\n最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。\n\n注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大$$n^2$$）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！\n\n但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。\n\n但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。\n\n```cpp\nvoid add(int a,int b) {\n    e[a].pb(b);\n    e[b].pb(a);\n}\n\nint qmi(int a,int b,int mod){\n    int res=1%mod;\n    while(b){\n        if(b&1) res=res*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return res;\n}\n\nvoid dfs1(int u = 1) {\n    siz[u] = 1;\n    int mx = 0;\n    for(int& v: e[u]) {\n        if(v==fa[u])continue;\n\n        depth[v] = depth[u] + 1;\n        ph[v]=(ph[u]*P%MOD+(s[v]-'a'+1))%MOD;\n        rh[v]=(rh[u]+p[depth[v]-1]*(s[v]-'a'+1)% MOD)%MOD;\n\n        f[v][0] = u;\n        for(int i=1;i<=20;i++)\n            f[v][i] = f[f[v][i-1]][i-1];\n        dfs1(v);\n        siz[u] += siz[v];\n        if(siz[v] > mx) {\n            mx = siz[v];hs[u] = v;\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int t = 1) {\n    len[t] ++;\n    top[u] = t;\n    if(siz[u] == 1) return ;\n    dfs2(hs[u],t);\n\n    for(int v: e[u]) {\n        if(v!=hs[u]&&v!=fa[u]) {\n            dfs2(v,v);\n        }\n    }\n}\n\nint lca(int a,int b) {\n    while(top[a] != top[b]) {\n        if(depth[top[a]] < depth[top[b]])swap(a,b);\n        a = fa[top[a]];\n    }\n    if(depth[a] < depth[b]) swap(a,b);\n    return b;\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = (p[i-1] * P) % MOD;\n    cin>>n;\n    cin>>s;\n    s = ' ' + s;\n    depth[1] = 1;\n    for(int i=1;i<=n;i++) {\n        cin>>fa[i];\n        if(fa[i]) add(i,fa[i]);\n        else fa[i] = -1;\n    }\n\n\n    ph[1]=s[1]-'a'+1,rh[1]=s[1]-'a'+1;\n    dfs1();dfs2();\n\n    cin>>m;\n    while(m--) {\n        int a,b;cin>>a>>b;\n        if(depth[a] < depth[b]) swap(a,b);\n        lc = lca(a,b);\n\n        int f=lca(a,b);\n        int p1=((rh[a]-rh[fa[f]]*qmi(p[depth[f]-1],MOD-2,MOD)%MOD)+MOD) %MOD;\n        int p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;\n        int ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;\n        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*qmi(p[depth[f]-1],MOD-2,MOD)%MOD;\n        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;\n        int ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;\n        cout<<(ans1==ans2?\"YES\\n\":\"NO\\n\");\n        cout<<f<<endl;\n        cout<<ans1<<' '<<ans2<<nline;\n    }\n}\n```\n\n","slug":"树上回文问题","published":1,"updated":"2024-08-14T13:39:14.786Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7ba2001i2wwv5lsx0zpp","content":"<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？</p>\n<span id=\"more\"></span>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>不想看回文的读者请跳转到“真的题解”</p>\n<p>看到回文，回顾回文！下面以数组为例子，求最长回文字符串。</p>\n<p>回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度</p>\n<p>回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。</p>\n<p>回文哈希二分：对于i，从前从后hax，二分回文长度。</p>\n<p>二分如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ull <span class=\"title\">get</span><span class=\"params\">(ull h[], ull l, ull r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h[r] - h[l - <span class=\"number\">1</span>] * p[r - l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = p[i<span class=\"number\">-1</span>] * P;</span><br><span class=\"line\">    <span class=\"type\">int</span> t =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;s,s!=<span class=\"string\">&quot;END&quot;</span>) &#123;</span><br><span class=\"line\">        n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i; i -= <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s[i] = s[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">            s[i - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s = <span class=\"string\">&#x27;#&#x27;</span> + s;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;s&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"keyword\">if</span>(!i) ph[i] = s[i];<span class=\"keyword\">else</span> ph[i] = ph[i<span class=\"number\">-1</span>] * P + s[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n<span class=\"number\">-1</span>;~i;i--)<span class=\"keyword\">if</span>(i==n<span class=\"number\">-1</span>) rh[i] = s[i];<span class=\"keyword\">else</span> rh[i] = rh[i<span class=\"number\">+1</span>] * P + s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">            ans -- ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case &quot;</span> &lt;&lt; ++t&lt;&lt;<span class=\"string\">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>题解要开始加速了！</p>\n<p>首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化<script type=\"math/tex\">log_2n</script>的解法！</p>\n<p>注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ull ans = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">  ans -- ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。</p>\n<p>简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R 回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）</p>\n<p>整个该算法的重点在于：“回文对称”！</p>\n<p><img src=\"https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg\" alt=\"img\"></p>\n<p>即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。</p>\n<p>若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。</p>\n<p>若i-w[i_mirror]&gt;=0即i_mirror的回文子串碰到了边界，则中心扩展i</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 马拉车算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome2</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    String T = <span class=\"built_in\">preProcess</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = T.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] P = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n];</span><br><span class=\"line\">    <span class=\"type\">int</span> C = <span class=\"number\">0</span>, R = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i_mirror = <span class=\"number\">2</span> * C - i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (R &gt; i) &#123;</span><br><span class=\"line\">            P[i] = Math.<span class=\"built_in\">min</span>(R - i, P[i_mirror]);<span class=\"comment\">// 防止超出 R</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            P[i] = <span class=\"number\">0</span>;<span class=\"comment\">// 等于 R 的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T.<span class=\"built_in\">charAt</span>(i + <span class=\"number\">1</span> + P[i]) == T.<span class=\"built_in\">charAt</span>(i - <span class=\"number\">1</span> - P[i])) &#123;</span><br><span class=\"line\">            P[i]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否需要更新 R</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + P[i] &gt; R) &#123;</span><br><span class=\"line\">            C = i;</span><br><span class=\"line\">            R = i + P[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \\\\代码source :https:<span class=\"comment\">//zhuanlan.zhihu.com/p/70532099</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"真的题解\"><a href=\"#真的题解\" class=\"headerlink\" title=\"真的题解\"></a>真的题解</h2><p>上面讲了一串，最后还得是哈！希！，字符串，哈！希！</p>\n<p>最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。</p>\n<p>注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大<script type=\"math/tex\">n^2</script>）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！</p>\n<p>但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。</p>\n<p>但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">    e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">qmi</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> mod)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">1</span>%mod;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res=res*a%mod;</span><br><span class=\"line\">        a=a*a%mod;</span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    siz[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span>&amp; v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==fa[u])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        depth[v] = depth[u] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        ph[v]=(ph[u]*P%MOD+(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>))%MOD;</span><br><span class=\"line\">        rh[v]=(rh[u]+p[depth[v]<span class=\"number\">-1</span>]*(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>)% MOD)%MOD;</span><br><span class=\"line\"></span><br><span class=\"line\">        f[v][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">20</span>;i++)</span><br><span class=\"line\">            f[v][i] = f[f[v][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">dfs1</span>(v);</span><br><span class=\"line\">        siz[u] += siz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[v] &gt; mx) &#123;</span><br><span class=\"line\">            mx = siz[v];hs[u] = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>, <span class=\"type\">int</span> t = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    len[t] ++;</span><br><span class=\"line\">    top[u] = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(siz[u] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(hs[u],t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v!=hs[u]&amp;&amp;v!=fa[u]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs2</span>(v,v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[a] != top[b]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[top[a]] &lt; depth[top[b]])<span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        a = fa[top[a]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = (p[i<span class=\"number\">-1</span>] * P) % MOD;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    s = <span class=\"string\">&#x27; &#x27;</span> + s;</span><br><span class=\"line\">    depth[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;fa[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fa[i]) <span class=\"built_in\">add</span>(i,fa[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> fa[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    ph[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>,rh[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dfs1</span>();<span class=\"built_in\">dfs2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        lc = <span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> f=<span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\">        <span class=\"type\">int</span> p1=((rh[a]-rh[fa[f]]*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD)+MOD) %MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD;</span><br><span class=\"line\">        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        cout&lt;&lt;(ans1==ans2?<span class=\"string\">&quot;YES\\n&quot;</span>:<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        cout&lt;&lt;f&lt;&lt;endl;</span><br><span class=\"line\">        cout&lt;&lt;ans1&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;nline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":1668,"excerpt":"<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？</p>","more":"<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>不想看回文的读者请跳转到“真的题解”</p>\n<p>看到回文，回顾回文！下面以数组为例子，求最长回文字符串。</p>\n<p>回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度</p>\n<p>回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。</p>\n<p>回文哈希二分：对于i，从前从后hax，二分回文长度。</p>\n<p>二分如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ull <span class=\"title\">get</span><span class=\"params\">(ull h[], ull l, ull r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h[r] - h[l - <span class=\"number\">1</span>] * p[r - l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = p[i<span class=\"number\">-1</span>] * P;</span><br><span class=\"line\">    <span class=\"type\">int</span> t =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;s,s!=<span class=\"string\">&quot;END&quot;</span>) &#123;</span><br><span class=\"line\">        n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i; i -= <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s[i] = s[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">            s[i - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s = <span class=\"string\">&#x27;#&#x27;</span> + s;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;s&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"keyword\">if</span>(!i) ph[i] = s[i];<span class=\"keyword\">else</span> ph[i] = ph[i<span class=\"number\">-1</span>] * P + s[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n<span class=\"number\">-1</span>;~i;i--)<span class=\"keyword\">if</span>(i==n<span class=\"number\">-1</span>) rh[i] = s[i];<span class=\"keyword\">else</span> rh[i] = rh[i<span class=\"number\">+1</span>] * P + s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">            ans -- ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case &quot;</span> &lt;&lt; ++t&lt;&lt;<span class=\"string\">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>题解要开始加速了！</p>\n<p>首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化<script type=\"math/tex\">log_2n</script>的解法！</p>\n<p>注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ull ans = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">  ans -- ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。</p>\n<p>简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R 回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）</p>\n<p>整个该算法的重点在于：“回文对称”！</p>\n<p><img src=\"https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg\" alt=\"img\"></p>\n<p>即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。</p>\n<p>若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。</p>\n<p>若i-w[i_mirror]&gt;=0即i_mirror的回文子串碰到了边界，则中心扩展i</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 马拉车算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome2</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    String T = <span class=\"built_in\">preProcess</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = T.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] P = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n];</span><br><span class=\"line\">    <span class=\"type\">int</span> C = <span class=\"number\">0</span>, R = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i_mirror = <span class=\"number\">2</span> * C - i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (R &gt; i) &#123;</span><br><span class=\"line\">            P[i] = Math.<span class=\"built_in\">min</span>(R - i, P[i_mirror]);<span class=\"comment\">// 防止超出 R</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            P[i] = <span class=\"number\">0</span>;<span class=\"comment\">// 等于 R 的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T.<span class=\"built_in\">charAt</span>(i + <span class=\"number\">1</span> + P[i]) == T.<span class=\"built_in\">charAt</span>(i - <span class=\"number\">1</span> - P[i])) &#123;</span><br><span class=\"line\">            P[i]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否需要更新 R</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + P[i] &gt; R) &#123;</span><br><span class=\"line\">            C = i;</span><br><span class=\"line\">            R = i + P[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \\\\代码source :https:<span class=\"comment\">//zhuanlan.zhihu.com/p/70532099</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"真的题解\"><a href=\"#真的题解\" class=\"headerlink\" title=\"真的题解\"></a>真的题解</h2><p>上面讲了一串，最后还得是哈！希！，字符串，哈！希！</p>\n<p>最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。</p>\n<p>注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大<script type=\"math/tex\">n^2</script>）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！</p>\n<p>但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。</p>\n<p>但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">    e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">qmi</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> mod)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">1</span>%mod;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res=res*a%mod;</span><br><span class=\"line\">        a=a*a%mod;</span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    siz[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span>&amp; v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==fa[u])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        depth[v] = depth[u] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        ph[v]=(ph[u]*P%MOD+(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>))%MOD;</span><br><span class=\"line\">        rh[v]=(rh[u]+p[depth[v]<span class=\"number\">-1</span>]*(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>)% MOD)%MOD;</span><br><span class=\"line\"></span><br><span class=\"line\">        f[v][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">20</span>;i++)</span><br><span class=\"line\">            f[v][i] = f[f[v][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">dfs1</span>(v);</span><br><span class=\"line\">        siz[u] += siz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[v] &gt; mx) &#123;</span><br><span class=\"line\">            mx = siz[v];hs[u] = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>, <span class=\"type\">int</span> t = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    len[t] ++;</span><br><span class=\"line\">    top[u] = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(siz[u] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(hs[u],t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v!=hs[u]&amp;&amp;v!=fa[u]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs2</span>(v,v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[a] != top[b]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[top[a]] &lt; depth[top[b]])<span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        a = fa[top[a]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = (p[i<span class=\"number\">-1</span>] * P) % MOD;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    s = <span class=\"string\">&#x27; &#x27;</span> + s;</span><br><span class=\"line\">    depth[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;fa[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fa[i]) <span class=\"built_in\">add</span>(i,fa[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> fa[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    ph[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>,rh[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dfs1</span>();<span class=\"built_in\">dfs2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        lc = <span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> f=<span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\">        <span class=\"type\">int</span> p1=((rh[a]-rh[fa[f]]*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD)+MOD) %MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD;</span><br><span class=\"line\">        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        cout&lt;&lt;(ans1==ans2?<span class=\"string\">&quot;YES\\n&quot;</span>:<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        cout&lt;&lt;f&lt;&lt;endl;</span><br><span class=\"line\">        cout&lt;&lt;ans1&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;nline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题","date":"2024-08-14T11:30:37.000Z","_content":"# 题意：\n\n给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。\n\n你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个**连续的子段**，然后从该子段中删除**所有**元素，**除**该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。\n\n如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。\n\n<!--more-->\n\n# 题解：\n\n根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。\n\n考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]<a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l_{a_i}$下标为j，则小于j且大于$l_{a_j}$的下标k的下标idx均无法转移至i，显然$l_{a_i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l_{a_x}$则无法转移到i。\n\n总结状态转移为$f_i = \\sum_{k={l_{a_i}+1}}^{i-1} f_k + \\sum_{k=l^x(l_{a_i})}^{k>0}f_{k}$\n\n前缀和处理即可。\n\n```cpp\n\tvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n\n    s[top] = {-1,-1};\n    for(int i = 1;i <= n;i++) {\n        while(top && s[top].x > a[i]) top--;\n        l[i] = s[top].y;\n        s[++top] = {a[i],i};\n    }\n\n    // for(int i=1;i<=n;i++) cout<<l[i]<<' ';\n    // cout<<endl;\n\n    for(int i=0;i<=n;i++) pre1[i] = pre2[i] = 0;\n\n    f[0] = 1;\n    pre1[0] = 1;\n    for(int i=1;i<=n;i++) {\n        if(l[i]!=-1) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;\n        int t = l[i] == -1 ? 0: pre1[l[i]];\n        f[i] = (pre1[i-1] - t) % MOD ;\n        // cout<<(pre1[i-1] - t)<<' ';\n        f[i] += pre2[i];\n\n        pre1[i] = pre1[i-1] + f[i] % MOD;\n        // cout<<i<<' '<<pre1[i]<<' '<<pre2[i]<<' '<<f[i]<<nline;\n    }\n\n    int mi = 1e18,ans = 0;\n    for(int i=n; i>=1; i--) {\n        mi = min(mi,a[i]);\n        if(mi==a[i]) {\n            ans = (ans + f[i]) % MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n","source":"_posts/状态转移习题1.md","raw":"---\ntitle: 状态转移习题\ndate: 2024-08-14 19:30:37\ntags: [算法, 状态转移]\ncategories: \n\t- 算法\n\t- 状态转移\n---\n# 题意：\n\n给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。\n\n你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个**连续的子段**，然后从该子段中删除**所有**元素，**除**该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。\n\n如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。\n\n<!--more-->\n\n# 题解：\n\n根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。\n\n考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]<a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l_{a_i}$下标为j，则小于j且大于$l_{a_j}$的下标k的下标idx均无法转移至i，显然$l_{a_i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l_{a_x}$则无法转移到i。\n\n总结状态转移为$f_i = \\sum_{k={l_{a_i}+1}}^{i-1} f_k + \\sum_{k=l^x(l_{a_i})}^{k>0}f_{k}$\n\n前缀和处理即可。\n\n```cpp\n\tvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n\n    s[top] = {-1,-1};\n    for(int i = 1;i <= n;i++) {\n        while(top && s[top].x > a[i]) top--;\n        l[i] = s[top].y;\n        s[++top] = {a[i],i};\n    }\n\n    // for(int i=1;i<=n;i++) cout<<l[i]<<' ';\n    // cout<<endl;\n\n    for(int i=0;i<=n;i++) pre1[i] = pre2[i] = 0;\n\n    f[0] = 1;\n    pre1[0] = 1;\n    for(int i=1;i<=n;i++) {\n        if(l[i]!=-1) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;\n        int t = l[i] == -1 ? 0: pre1[l[i]];\n        f[i] = (pre1[i-1] - t) % MOD ;\n        // cout<<(pre1[i-1] - t)<<' ';\n        f[i] += pre2[i];\n\n        pre1[i] = pre1[i-1] + f[i] % MOD;\n        // cout<<i<<' '<<pre1[i]<<' '<<pre2[i]<<' '<<f[i]<<nline;\n    }\n\n    int mi = 1e18,ans = 0;\n    for(int i=n; i>=1; i--) {\n        mi = min(mi,a[i]);\n        if(mi==a[i]) {\n            ans = (ans + f[i]) % MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n","slug":"状态转移习题1","published":1,"updated":"2024-08-14T13:39:18.757Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7ba2001l2wwv4o5ibxv1","content":"<h1 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h1><p>给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。</p>\n<p>你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个<strong>连续的子段</strong>，然后从该子段中删除<strong>所有</strong>元素，<strong>除</strong>该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。</p>\n<p>如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。</p>\n<span id=\"more\"></span>\n<h1 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h1><p>根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。</p>\n<p>考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]&lt;a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l<em>{a_i}$下标为j，则小于j且大于$l</em>{a<em>j}$的下标k的下标idx均无法转移至i，显然$l</em>{a<em>i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l</em>{a_x}$则无法转移到i。</p>\n<p>总结状态转移为$f<em>i = \\sum</em>{k={l<em>{a_i}+1}}^{i-1} f_k + \\sum</em>{k=l^x(l<em>{a_i})}^{k&gt;0}f</em>{k}$</p>\n<p>前缀和处理即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    s[top] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(top &amp;&amp; s[top].x &gt; a[i]) top--;</span><br><span class=\"line\">        l[i] = s[top].y;</span><br><span class=\"line\">        s[++top] = &#123;a[i],i&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;l[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++) pre1[i] = pre2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    pre1[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l[i]!=<span class=\"number\">-1</span>) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = l[i] == <span class=\"number\">-1</span> ? <span class=\"number\">0</span>: pre1[l[i]];</span><br><span class=\"line\">        f[i] = (pre1[i<span class=\"number\">-1</span>] - t) % MOD ;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;(pre1[i-1] - t)&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">        f[i] += pre2[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        pre1[i] = pre1[i<span class=\"number\">-1</span>] + f[i] % MOD;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;pre1[i]&lt;&lt;&#x27; &#x27;&lt;&lt;pre2[i]&lt;&lt;&#x27; &#x27;&lt;&lt;f[i]&lt;&lt;nline;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mi = <span class=\"number\">1e18</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n; i&gt;=<span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        mi = <span class=\"built_in\">min</span>(mi,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mi==a[i]) &#123;</span><br><span class=\"line\">            ans = (ans + f[i]) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":708,"excerpt":"<h1 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h1><p>给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。</p>\n<p>你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个<strong>连续的子段</strong>，然后从该子段中删除<strong>所有</strong>元素，<strong>除</strong>该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。</p>\n<p>如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。</p>","more":"<h1 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h1><p>根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。</p>\n<p>考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]&lt;a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l<em>{a_i}$下标为j，则小于j且大于$l</em>{a<em>j}$的下标k的下标idx均无法转移至i，显然$l</em>{a<em>i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l</em>{a_x}$则无法转移到i。</p>\n<p>总结状态转移为$f<em>i = \\sum</em>{k={l<em>{a_i}+1}}^{i-1} f_k + \\sum</em>{k=l^x(l<em>{a_i})}^{k&gt;0}f</em>{k}$</p>\n<p>前缀和处理即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    s[top] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(top &amp;&amp; s[top].x &gt; a[i]) top--;</span><br><span class=\"line\">        l[i] = s[top].y;</span><br><span class=\"line\">        s[++top] = &#123;a[i],i&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;l[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++) pre1[i] = pre2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    pre1[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l[i]!=<span class=\"number\">-1</span>) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = l[i] == <span class=\"number\">-1</span> ? <span class=\"number\">0</span>: pre1[l[i]];</span><br><span class=\"line\">        f[i] = (pre1[i<span class=\"number\">-1</span>] - t) % MOD ;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;(pre1[i-1] - t)&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">        f[i] += pre2[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        pre1[i] = pre1[i<span class=\"number\">-1</span>] + f[i] % MOD;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;pre1[i]&lt;&lt;&#x27; &#x27;&lt;&lt;pre2[i]&lt;&lt;&#x27; &#x27;&lt;&lt;f[i]&lt;&lt;nline;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mi = <span class=\"number\">1e18</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n; i&gt;=<span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        mi = <span class=\"built_in\">min</span>(mi,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mi==a[i]) &#123;</span><br><span class=\"line\">            ans = (ans + f[i]) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题3","date":"2024-08-14T11:38:14.000Z","_content":"## 题意：\n\n对一个数组的所有非空子区间，计算这个公式$$w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus a_j $$的和。\n\n<!--more-->\n\n## 题解：\n\n非常经典的题目，看见了就再巩固一下。\n\n1. 拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\\lceil log_2mx\\rceil$个数组。计算每一位的贡献。\n\n当拆位后原式子会变为这样的\n$$\nallW = \\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil log_2mx\\rceil}cnt(a_{i-x} != a_{x})\n$$\n这个复杂度仍然是爆炸的，因此需要继续优化\n\n很容易想到的一个优化就是，对于$$a_i \\oplus a_j$$他是满足交换律的，即$$a_i \\oplus a_j = a_j \\oplus a_i$$因此我们仅需要计算单边值即可（然后乘2。\n\n因此将原有的式子改写$$w =2 \\times (\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) $$虽然对于$$a_i$$本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。\n\n再转头考虑所有子区间的问题，一个数组的所有子区间显然是$$n^2$$级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为$$i\\times (n-j+1)$$（下标从1开始），则对任意i,j，其贡献值为以下公式\n$$\nw(bt,{i,j}) = (i\\times (n-j+1) * (1<<bt) * (bit(x,a_i)\\not=bit(x,a_j))\n$$\n施展数学的神奇魔法！\n\n提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算$$a_j$$ 与$$a_i|i<j$$的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。\n\n最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。\n\n```cpp\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n\n    ll ans = 0;\n    for(int bt = 0;bt <=29;bt++) {\n        ll s1=0,s2 =0;\n        for(int i=1;i<=n;i++) {\n            if(a[i] >>bt&1) {\n                ans = (ans + s2 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s1 += i;\n                s1 %= MOD;\n            }\n            else {\n                ans = (ans + s1 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s2 += i;\n                s2 %= MOD;\n            }\n        }\n    }\n    cout<<(2ll * ans)%MOD<<endl;\n}\n```\n\n不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。","source":"_posts/状态转移习题3.md","raw":"---\ntitle: 状态转移习题3\ndate: 2024-08-14 19:38:14\ntags: [算法, 状态转移, 异或问题]\ncategories: \n\t- 算法\n\t- 状态转移\n\t- 状态转移中的异或问题\n---\n## 题意：\n\n对一个数组的所有非空子区间，计算这个公式$$w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus a_j $$的和。\n\n<!--more-->\n\n## 题解：\n\n非常经典的题目，看见了就再巩固一下。\n\n1. 拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\\lceil log_2mx\\rceil$个数组。计算每一位的贡献。\n\n当拆位后原式子会变为这样的\n$$\nallW = \\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil log_2mx\\rceil}cnt(a_{i-x} != a_{x})\n$$\n这个复杂度仍然是爆炸的，因此需要继续优化\n\n很容易想到的一个优化就是，对于$$a_i \\oplus a_j$$他是满足交换律的，即$$a_i \\oplus a_j = a_j \\oplus a_i$$因此我们仅需要计算单边值即可（然后乘2。\n\n因此将原有的式子改写$$w =2 \\times (\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) $$虽然对于$$a_i$$本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。\n\n再转头考虑所有子区间的问题，一个数组的所有子区间显然是$$n^2$$级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为$$i\\times (n-j+1)$$（下标从1开始），则对任意i,j，其贡献值为以下公式\n$$\nw(bt,{i,j}) = (i\\times (n-j+1) * (1<<bt) * (bit(x,a_i)\\not=bit(x,a_j))\n$$\n施展数学的神奇魔法！\n\n提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算$$a_j$$ 与$$a_i|i<j$$的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。\n\n最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。\n\n```cpp\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n\n    ll ans = 0;\n    for(int bt = 0;bt <=29;bt++) {\n        ll s1=0,s2 =0;\n        for(int i=1;i<=n;i++) {\n            if(a[i] >>bt&1) {\n                ans = (ans + s2 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s1 += i;\n                s1 %= MOD;\n            }\n            else {\n                ans = (ans + s1 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s2 += i;\n                s2 %= MOD;\n            }\n        }\n    }\n    cout<<(2ll * ans)%MOD<<endl;\n}\n```\n\n不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。","slug":"状态转移习题3","published":1,"updated":"2024-08-14T13:39:25.704Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7ba3001o2wwvd6bjc7ze","content":"<h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>对一个数组的所有非空子区间，计算这个公式<script type=\"math/tex\">w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus a_j</script>的和。</p>\n<span id=\"more\"></span>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>非常经典的题目，看见了就再巩固一下。</p>\n<ol>\n<li>拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\\lceil log_2mx\\rceil$个数组。计算每一位的贡献。</li>\n</ol>\n<p>当拆位后原式子会变为这样的</p>\n<script type=\"math/tex; mode=display\">\nallW = \\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil log_2mx\\rceil}cnt(a_{i-x} != a_{x})</script><p>这个复杂度仍然是爆炸的，因此需要继续优化</p>\n<p>很容易想到的一个优化就是，对于<script type=\"math/tex\">a_i \\oplus a_j</script>他是满足交换律的，即<script type=\"math/tex\">a_i \\oplus a_j = a_j \\oplus a_i</script>因此我们仅需要计算单边值即可（然后乘2。</p>\n<p>因此将原有的式子改写<script type=\"math/tex\">w =2 \\times (\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j)</script>虽然对于<script type=\"math/tex\">a_i</script>本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。</p>\n<p>再转头考虑所有子区间的问题，一个数组的所有子区间显然是<script type=\"math/tex\">n^2</script>级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为<script type=\"math/tex\">i\\times (n-j+1)</script>（下标从1开始），则对任意i,j，其贡献值为以下公式</p>\n<script type=\"math/tex; mode=display\">\nw(bt,{i,j}) = (i\\times (n-j+1) * (1<<bt) * (bit(x,a_i)\\not=bit(x,a_j))</script><p>施展数学的神奇魔法！</p>\n<p>提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算<script type=\"math/tex\">a_j</script> 与<script type=\"math/tex\">a_i|i<j</script>的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。</p>\n<p>最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> bt = <span class=\"number\">0</span>;bt &lt;=<span class=\"number\">29</span>;bt++) &#123;</span><br><span class=\"line\">        ll s1=<span class=\"number\">0</span>,s2 =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt;&gt;bt&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = (ans + s2 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s1 += i;</span><br><span class=\"line\">                s1 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = (ans + s1 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s2 += i;</span><br><span class=\"line\">                s2 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"number\">2ll</span> * ans)%MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。</p>\n","length":705,"excerpt":"<h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>对一个数组的所有非空子区间，计算这个公式<script type=\"math/tex\">w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus a_j</script>的和。</p>","more":"<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>非常经典的题目，看见了就再巩固一下。</p>\n<ol>\n<li>拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\\lceil log_2mx\\rceil$个数组。计算每一位的贡献。</li>\n</ol>\n<p>当拆位后原式子会变为这样的</p>\n<script type=\"math/tex; mode=display\">\nallW = \\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil log_2mx\\rceil}cnt(a_{i-x} != a_{x})</script><p>这个复杂度仍然是爆炸的，因此需要继续优化</p>\n<p>很容易想到的一个优化就是，对于<script type=\"math/tex\">a_i \\oplus a_j</script>他是满足交换律的，即<script type=\"math/tex\">a_i \\oplus a_j = a_j \\oplus a_i</script>因此我们仅需要计算单边值即可（然后乘2。</p>\n<p>因此将原有的式子改写<script type=\"math/tex\">w =2 \\times (\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j)</script>虽然对于<script type=\"math/tex\">a_i</script>本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。</p>\n<p>再转头考虑所有子区间的问题，一个数组的所有子区间显然是<script type=\"math/tex\">n^2</script>级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为<script type=\"math/tex\">i\\times (n-j+1)</script>（下标从1开始），则对任意i,j，其贡献值为以下公式</p>\n<script type=\"math/tex; mode=display\">\nw(bt,{i,j}) = (i\\times (n-j+1) * (1<<bt) * (bit(x,a_i)\\not=bit(x,a_j))</script><p>施展数学的神奇魔法！</p>\n<p>提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算<script type=\"math/tex\">a_j</script> 与<script type=\"math/tex\">a_i|i<j</script>的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。</p>\n<p>最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> bt = <span class=\"number\">0</span>;bt &lt;=<span class=\"number\">29</span>;bt++) &#123;</span><br><span class=\"line\">        ll s1=<span class=\"number\">0</span>,s2 =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt;&gt;bt&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = (ans + s2 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s1 += i;</span><br><span class=\"line\">                s1 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = (ans + s1 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s2 += i;</span><br><span class=\"line\">                s2 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"number\">2ll</span> * ans)%MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。</p>"},{"title":"状态转移习题2","date":"2024-08-14T11:32:13.000Z","_content":"# 题意：\n\n给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。\n\n首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。\n\n然后，你必须使数组中的所有元素相等。一开始，你选择一个**正**整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。**注意， x 在所有操作中都是一样的**。\n\n选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？\n\n<!--more-->\n\n# 题解：\n\n容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。\n\n可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。\n\n```\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int mx = -INF;\n    for(int i=1;i<=n;i++) {\n        mx = max(mx,a[i]);\n    }\n\n    for(int i=1;i<=n;i++) d[i] = mx - a[i];\n\n    int gd = 0;\n    for(int i=1;i<=n;i++) gd = __gcd(d[i],gd);\n\n    if(!gd) {cout<<1<<endl;return ;}\n\n    ll sum = 0;\n    set<int> S;\n    for(int i=1;i<=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);\n    int t = 1;\n    while(1) if(S.count(t)) t++;else break;\n    cout<<sum + t<<endl;\n}\n```","source":"_posts/状态转移习题2.md","raw":"---\ntitle: 状态转移习题2\ndate: 2024-08-14 19:32:13\ntags: [算法, 状态转移]\ncategories: \n\t- 算法\n\t- 状态转移\n---\n# 题意：\n\n给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。\n\n首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。\n\n然后，你必须使数组中的所有元素相等。一开始，你选择一个**正**整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。**注意， x 在所有操作中都是一样的**。\n\n选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？\n\n<!--more-->\n\n# 题解：\n\n容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。\n\n可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。\n\n```\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int mx = -INF;\n    for(int i=1;i<=n;i++) {\n        mx = max(mx,a[i]);\n    }\n\n    for(int i=1;i<=n;i++) d[i] = mx - a[i];\n\n    int gd = 0;\n    for(int i=1;i<=n;i++) gd = __gcd(d[i],gd);\n\n    if(!gd) {cout<<1<<endl;return ;}\n\n    ll sum = 0;\n    set<int> S;\n    for(int i=1;i<=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);\n    int t = 1;\n    while(1) if(S.count(t)) t++;else break;\n    cout<<sum + t<<endl;\n}\n```","slug":"状态转移习题2","published":1,"updated":"2024-08-14T13:39:21.942Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7ba3001p2wwvgt63dcu9","content":"<h1 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h1><p>给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。</p>\n<p>首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。</p>\n<p>然后，你必须使数组中的所有元素相等。一开始，你选择一个<strong>正</strong>整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。<strong>注意， x 在所有操作中都是一样的</strong>。</p>\n<p>选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？</p>\n<span id=\"more\"></span>\n<h1 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h1><p>容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。</p>\n<p>可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void slove()&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int mx = -INF;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        mx = max(mx,a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) d[i] = mx - a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int gd = 0;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) gd = __gcd(d[i],gd);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!gd) &#123;cout&lt;&lt;1&lt;&lt;endl;return ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll sum = 0;</span><br><span class=\"line\">    set&lt;int&gt; S;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);</span><br><span class=\"line\">    int t = 1;</span><br><span class=\"line\">    while(1) if(S.count(t)) t++;else break;</span><br><span class=\"line\">    cout&lt;&lt;sum + t&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","length":355,"excerpt":"<h1 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h1><p>给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。</p>\n<p>首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。</p>\n<p>然后，你必须使数组中的所有元素相等。一开始，你选择一个<strong>正</strong>整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。<strong>注意， x 在所有操作中都是一样的</strong>。</p>\n<p>选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？</p>","more":"<h1 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h1><p>容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。</p>\n<p>可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void slove()&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int mx = -INF;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        mx = max(mx,a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) d[i] = mx - a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int gd = 0;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) gd = __gcd(d[i],gd);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!gd) &#123;cout&lt;&lt;1&lt;&lt;endl;return ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll sum = 0;</span><br><span class=\"line\">    set&lt;int&gt; S;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);</span><br><span class=\"line\">    int t = 1;</span><br><span class=\"line\">    while(1) if(S.count(t)) t++;else break;</span><br><span class=\"line\">    cout&lt;&lt;sum + t&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估","date":"2024-08-14T11:41:55.000Z","_content":"\n于江西理工大学信息安全课程的论文综述\n\n学术，未发表，Miarcl\n下载连接：http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\n\n感谢母校对我的指导\n\n{% pdf http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf 3000px}","source":"_posts/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估.md","raw":"---\ntitle: 由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估\ndate: 2024-08-14 19:41:55\ntags: [信息安全, 加密算法, Miracl, ECC]\ncategories: \n\t- 学术\n\t- 综述\n---\n\n于江西理工大学信息安全课程的论文综述\n\n学术，未发表，Miarcl\n下载连接：http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\n\n感谢母校对我的指导\n\n{% pdf http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf 3000px}","slug":"由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估","published":1,"updated":"2024-08-15T02:58:38.900Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7ba4001s2wwv4a5d6879","content":"<p>于江西理工大学信息安全课程的论文综述</p>\n<p>学术，未发表，Miarcl<br>下载连接：<span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cua2Vib2UuY24vdXBsb2Fkcy/nlLFSU0HliLBFQ0PmtYXosIjpnZ7lr7nnp7DlhazpkqUt56eB6ZKl5a+G56CB57O757uf4oCU4oCU5bi46KeB5Yeg56eN5L+h5oGv5Yqg5a+G566X5rOV5a6e546w5q+U6L6D5ZKM6K+E5LywLnBkZg==\">http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>感谢母校对我的指导</p>\n<p><div class=\"pdf-container\" data-target=\"<a\" data-height=\"href=http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf>http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf</a>\"></div>","length":115,"excerpt":"","more":"<p>于江西理工大学信息安全课程的论文综述</p>\n<p>学术，未发表，Miarcl<br>下载连接：<span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cua2Vib2UuY24vdXBsb2Fkcy/nlLFSU0HliLBFQ0PmtYXosIjpnZ7lr7nnp7DlhazpkqUt56eB6ZKl5a+G56CB57O757uf4oCU4oCU5bi46KeB5Yeg56eN5L+h5oGv5Yqg5a+G566X5rOV5a6e546w5q+U6L6D5ZKM6K+E5LywLnBkZg==\">http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>感谢母校对我的指导</p>\n<p><div class=\"pdf-container\" data-target=\"<a\" data-height=\"href=http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf>http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf</a>\"></div>"},{"title":"状态转移习题4","date":"2024-08-14T11:41:55.000Z","_content":"## 题意：\n\n给定m条线段，求将1-n覆盖两次的所有方案数\n\n<!--more-->\n\n## 题解：\n\n离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。\n\n个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。\n\n状态表示这样设计：$$dpi,j,k$$表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。\n\n之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    dp[0][0][0] = 1;\n    for(int i=1;i<=m;i++) {\n        for(int ii=0;ii<i;ii++) {\n            for(int j=200;j;j--) {\n                for(int k = 200;k;k--)\n                    dp[i][j][k] = dp[ii][j][k];\n            }\n            for(int j=200;~j;j--) {\n                for(int k = 200;~k;k--) {\n                    if(mp[segs[i].x] <= j+1) {\n                        if(mp[segs[i].x] > k+1) {\n                            dp[i][max(mp[segs[i].y], j)][k] =\n                                (dp[i][max(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][k]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"!\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<k<<' '<<dp[i][max(mp[segs[i].y], j)][k]<<nline;\n                            // }\n                        }\n                        else {\n                            dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] =\n                                (dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"?\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<max(k,min(j,mp[segs[i].y]))<<' '<<\n                            //         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]<<nline;\n                            // }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<dp[m][mp[n]][mp[n]]<<endl;\n}\n```\n\n这段代码中显然有一个很严重的问题：时间复杂度为$$1.6e^{9}$$略微有点超出复杂度\n\n其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。\n\n时间如何优化？\n\n首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f\\[i]\\[j][k] += f\\[i - 1]\\[j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        segs[i].x--;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    for(int i=1;i<=m;i++) {\n        segs[i].x = mp[segs[i].x];\n        segs[i].y = mp[segs[i].y];\n    }\n\n    f[0][0][0] = 1;\n    for (int k = 1; k <= m; k++) {\n        for (int i = 0; i <= mp[n]; i++) {\n            for (int j = i; j <= mp[n]; j++) {\n                if (f[k - 1][i][j] == 0) {\n                    continue;\n                }\n                f[k][i][j] += f[k - 1][i][j];\n                f[k][i][j] %=MOD;\n                if (segs[k].x <= i) {\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]+=f[k - 1][i][j];\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]%=MOD;\n                }\n            }\n        }\n    }\n\n    cout<<f[m][mp[n]][mp[n]]% MOD<<endl;\n}\n```\n","source":"_posts/状态转移习题4.md","raw":"---\ntitle: 状态转移习题4\ndate: 2024-08-14 19:41:55\ntags: [算法, 状态转移, 离散化]\ncategories: \n\t- 算法\n\t- 状态转移\n\t- 复杂状态转移与优化\n---\n## 题意：\n\n给定m条线段，求将1-n覆盖两次的所有方案数\n\n<!--more-->\n\n## 题解：\n\n离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。\n\n个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。\n\n状态表示这样设计：$$dpi,j,k$$表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。\n\n之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    dp[0][0][0] = 1;\n    for(int i=1;i<=m;i++) {\n        for(int ii=0;ii<i;ii++) {\n            for(int j=200;j;j--) {\n                for(int k = 200;k;k--)\n                    dp[i][j][k] = dp[ii][j][k];\n            }\n            for(int j=200;~j;j--) {\n                for(int k = 200;~k;k--) {\n                    if(mp[segs[i].x] <= j+1) {\n                        if(mp[segs[i].x] > k+1) {\n                            dp[i][max(mp[segs[i].y], j)][k] =\n                                (dp[i][max(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][k]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"!\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<k<<' '<<dp[i][max(mp[segs[i].y], j)][k]<<nline;\n                            // }\n                        }\n                        else {\n                            dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] =\n                                (dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"?\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<max(k,min(j,mp[segs[i].y]))<<' '<<\n                            //         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]<<nline;\n                            // }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<dp[m][mp[n]][mp[n]]<<endl;\n}\n```\n\n这段代码中显然有一个很严重的问题：时间复杂度为$$1.6e^{9}$$略微有点超出复杂度\n\n其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。\n\n时间如何优化？\n\n首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f\\[i]\\[j][k] += f\\[i - 1]\\[j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        segs[i].x--;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    for(int i=1;i<=m;i++) {\n        segs[i].x = mp[segs[i].x];\n        segs[i].y = mp[segs[i].y];\n    }\n\n    f[0][0][0] = 1;\n    for (int k = 1; k <= m; k++) {\n        for (int i = 0; i <= mp[n]; i++) {\n            for (int j = i; j <= mp[n]; j++) {\n                if (f[k - 1][i][j] == 0) {\n                    continue;\n                }\n                f[k][i][j] += f[k - 1][i][j];\n                f[k][i][j] %=MOD;\n                if (segs[k].x <= i) {\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]+=f[k - 1][i][j];\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]%=MOD;\n                }\n            }\n        }\n    }\n\n    cout<<f[m][mp[n]][mp[n]]% MOD<<endl;\n}\n```\n","slug":"状态转移习题4","published":1,"updated":"2024-08-14T13:39:29.254Z","comments":1,"layout":"post","photos":[],"_id":"clzwh7ba5001t2wwv7hip63a6","content":"<h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>给定m条线段，求将1-n覆盖两次的所有方案数</p>\n<span id=\"more\"></span>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。</p>\n<p>个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。</p>\n<p>状态表示这样设计：<script type=\"math/tex\">dpi,j,k</script>表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。</p>\n<p>之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=<span class=\"number\">0</span>;ii&lt;i;ii++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;k;k--)</span><br><span class=\"line\">                    dp[i][j][k] = dp[ii][j][k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;~j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;~k;k--) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(mp[segs[i].x] &lt;= j<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(mp[segs[i].x] &gt; k<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][k] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][k]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;!&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][max(mp[segs[i].y], j)][k]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;?&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;max(k,min(j,mp[segs[i].y]))&lt;&lt;&#x27; &#x27;&lt;&lt;</span></span><br><span class=\"line\">                            <span class=\"comment\">//         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;dp[m][mp[n]][mp[n]]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码中显然有一个很严重的问题：时间复杂度为<script type=\"math/tex\">1.6e^{9}</script>略微有点超出复杂度</p>\n<p>其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。</p>\n<p>时间如何优化？</p>\n<p>首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f[i][j][k] += f[i - 1][j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        segs[i].x--;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        segs[i].x = mp[segs[i].x];</span><br><span class=\"line\">        segs[i].y = mp[segs[i].y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= m; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= mp[n]; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= mp[n]; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f[k - <span class=\"number\">1</span>][i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                f[k][i][j] += f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                f[k][i][j] %=MOD;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (segs[k].x &lt;= i) &#123;</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]+=f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]%=MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;f[m][mp[n]][mp[n]]% MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","length":1004,"excerpt":"<h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>给定m条线段，求将1-n覆盖两次的所有方案数</p>","more":"<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。</p>\n<p>个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。</p>\n<p>状态表示这样设计：<script type=\"math/tex\">dpi,j,k</script>表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。</p>\n<p>之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=<span class=\"number\">0</span>;ii&lt;i;ii++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;k;k--)</span><br><span class=\"line\">                    dp[i][j][k] = dp[ii][j][k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;~j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;~k;k--) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(mp[segs[i].x] &lt;= j<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(mp[segs[i].x] &gt; k<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][k] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][k]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;!&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][max(mp[segs[i].y], j)][k]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;?&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;max(k,min(j,mp[segs[i].y]))&lt;&lt;&#x27; &#x27;&lt;&lt;</span></span><br><span class=\"line\">                            <span class=\"comment\">//         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;dp[m][mp[n]][mp[n]]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码中显然有一个很严重的问题：时间复杂度为<script type=\"math/tex\">1.6e^{9}</script>略微有点超出复杂度</p>\n<p>其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。</p>\n<p>时间如何优化？</p>\n<p>首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f[i][j][k] += f[i - 1][j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        segs[i].x--;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        segs[i].x = mp[segs[i].x];</span><br><span class=\"line\">        segs[i].y = mp[segs[i].y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= m; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= mp[n]; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= mp[n]; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f[k - <span class=\"number\">1</span>][i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                f[k][i][j] += f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                f[k][i][j] %=MOD;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (segs[k].x &lt;= i) &#123;</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]+=f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]%=MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;f[m][mp[n]][mp[n]]% MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"MindSpore专题","date":"2024-08-14T11:47:58.000Z","_content":"\n# MindSpore Studying By Windows And Ubuntu\n\n文档编写采用Typora，须获得更好观看体验请自行clone本仓库\n\n## 初级教程\n\n[前置数学](../Chapters/Concept/index.html)\n\n<!--more-->\n\n[第一章 Ubuntu以及Windows安装MindSpore](../Chapters/First_Install/index.html)\n\n[第二章 尝试使用MindSpore](../Chapters/Second_TryMindSpore/index.html)\n\n[第三章 张量](../Chapters/Third_Tensor/index.html)\n\n[第四章 数据集](../Chapters/Fourth_DataSet/index.html)\n\n[第五章 网格构建](../Chapters/Fivth_ConstructNetwork/index.html)\n\n[第六章 函数式自动微分](../Chapters/Sixth_FunctionAutoDifferentalCalc/index.html)\n\n[第七章 模型训练](../Chapters/Seven_ModelTrain/index.html)","source":"_posts/special_subject/MindSpore/MindSpore学习目录.md","raw":"---\ntitle: MindSpore专题\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n\n# MindSpore Studying By Windows And Ubuntu\n\n文档编写采用Typora，须获得更好观看体验请自行clone本仓库\n\n## 初级教程\n\n[前置数学](../Chapters/Concept/index.html)\n\n<!--more-->\n\n[第一章 Ubuntu以及Windows安装MindSpore](../Chapters/First_Install/index.html)\n\n[第二章 尝试使用MindSpore](../Chapters/Second_TryMindSpore/index.html)\n\n[第三章 张量](../Chapters/Third_Tensor/index.html)\n\n[第四章 数据集](../Chapters/Fourth_DataSet/index.html)\n\n[第五章 网格构建](../Chapters/Fivth_ConstructNetwork/index.html)\n\n[第六章 函数式自动微分](../Chapters/Sixth_FunctionAutoDifferentalCalc/index.html)\n\n[第七章 模型训练](../Chapters/Seven_ModelTrain/index.html)","slug":"special_subject/MindSpore/MindSpore学习目录","published":1,"updated":"2024-08-16T08:58:33.146Z","_id":"clzwh7ba6001w2wwv8cah6cid","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"mindspore-studying-by-windows-and-ubuntu\">MindSpore Studying By\r\nWindows And Ubuntu</h1>\r\n<p>文档编写采用Typora，须获得更好观看体验请自行clone本仓库</p>\r\n<h2 id=\"初级教程\">初级教程</h2>\r\n<p><a href=\"../Chapters/Concept/index.html\">前置数学</a></p>\r\n<span id=\"more\"></span>\r\n<p><a href=\"../Chapters/First_Install/index.html\">第一章\r\nUbuntu以及Windows安装MindSpore</a></p>\r\n<p><a href=\"../Chapters/Second_TryMindSpore/index.html\">第二章\r\n尝试使用MindSpore</a></p>\r\n<p><a href=\"../Chapters/Third_Tensor/index.html\">第三章 张量</a></p>\r\n<p><a href=\"../Chapters/Fourth_DataSet/index.html\">第四章 数据集</a></p>\r\n<p><a href=\"../Chapters/Fivth_ConstructNetwork/index.html\">第五章\r\n网格构建</a></p>\r\n<p><a\r\nhref=\"../Chapters/Sixth_FunctionAutoDifferentalCalc/index.html\">第六章\r\n函数式自动微分</a></p>\r\n<p><a href=\"../Chapters/Seven_ModelTrain/index.html\">第七章\r\n模型训练</a></p>\r\n","length":91,"excerpt":"<h1 id=\"mindspore-studying-by-windows-and-ubuntu\">MindSpore Studying By\r\nWindows And Ubuntu</h1>\r\n<p>文档编写采用Typora，须获得更好观看体验请自行clone本仓库</p>\r\n<h2 id=\"初级教程\">初级教程</h2>\r\n<p><a href=\"../Chapters/Concept/index.html\">前置数学</a></p>","more":"<p><a href=\"../Chapters/First_Install/index.html\">第一章\r\nUbuntu以及Windows安装MindSpore</a></p>\r\n<p><a href=\"../Chapters/Second_TryMindSpore/index.html\">第二章\r\n尝试使用MindSpore</a></p>\r\n<p><a href=\"../Chapters/Third_Tensor/index.html\">第三章 张量</a></p>\r\n<p><a href=\"../Chapters/Fourth_DataSet/index.html\">第四章 数据集</a></p>\r\n<p><a href=\"../Chapters/Fivth_ConstructNetwork/index.html\">第五章\r\n网格构建</a></p>\r\n<p><a\r\nhref=\"../Chapters/Sixth_FunctionAutoDifferentalCalc/index.html\">第六章\r\n函数式自动微分</a></p>\r\n<p><a href=\"../Chapters/Seven_ModelTrain/index.html\">第七章\r\n模型训练</a></p>"},{"title":"MindSpore专题——第五章、网络构建","date":"2024-08-14T11:47:58.000Z","_content":"## 网格构建\n\n神经网络模型是由神经网络层和Tensor操作构成的，[mindspore.nn](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.nn.html)提供了常见神经网络层的实现，在MindSpore中，[Cell](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Cell.html)类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个`Cell`，它由不同的子`Cell`构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。\n\n下面我们将构建一个用于Mnist数据集分类的神经网络模型。\n\n<!--more-->\n\n### 定义模型类\n\n当我们定义神经网络时，可以继承`nn.Cell`类，在`__init__`方法中进行子Cell的实例化和状态管理，在`construct`方法中实现Tensor操作。\n\n```python\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512, weight_init=\"normal\", bias_init=\"zeros\"),\n            nn.ReLU(),\n            nn.Dense(512, 512, weight_init=\"normal\", bias_init=\"zeros\"),\n            nn.ReLU(),\n            nn.Dense(512, 10, weight_init=\"normal\", bias_init=\"zeros\")\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\n\nmodel = Network()\nprint(model)\n\n```\n\n> ```\n> Network<\n>   (flatten): Flatten<>\n>   (dense_relu_sequential): SequentialCell<\n>     (0): Dense<input_channels=784, output_channels=512, has_bias=True>\n>     (1): ReLU<>\n>     (2): Dense<input_channels=512, output_channels=512, has_bias=True>\n>     (3): ReLU<>\n>     (4): Dense<input_channels=512, output_channels=10, has_bias=True>\n>     >\n>   >\n> ```\n\n我们构造一个输入数据，直接调用模型，可以获得一个十维的Tensor输出，其包含每个类别的原始预测值。\n\n**`model.construct()`方法不可直接调用。**\n\n这里出现了很多很抽象的概念好像一下子让机器学习变成了一个黑盒子，实际上，我们观察上面的代码，很容易可以从中看出一些结构来，下面记录一下我这个初学者的理解。\n\n首先搬出一幅经典的图像\n\n![神经网络入门 - 阮一峰的网络日志](https://s2.loli.net/2024/06/07/n358NwDPeSg1LsZ.jpg)\n\n这幅图形象的描述了上面的过程。其中\n\n![image-20240607140358272](https://s2.loli.net/2024/06/07/KgVFjZ6LTY54r1s.png)\n\n这里开始的inputLayer就是我们的输入数据，中间连的密密麻麻的线就是上面结构输出中的Dense，可以观察到我们分别有$$784\\rightarrow 512\\rightarrow512\\rightarrow10$$​四层这样的全连接。最初的784也和28*28对应了起来。即我们每一个像素点都是一个参数，为最初输入的一个点，最后输出的则是代表数字概率的10个参数，最终我们会选择一个最接近的参数。这里的变量名用logits（不确定是否标准，但这里是这么用的）\n\n下面是一些展示调用的代码\n\n```python\nX = ops.ones((1, 28, 28), mindspore.float32)\nlogits = model(X)\n# print logits\n\nprint(Tensor(logits))\npred_probab = nn.Softmax(axis=1)(logits)\ny_pred = pred_probab.argmax(1)\nprint(f\"Predicted class: {y_pred}\")\n```\n\n读者可以试着运行几次，由于给出数据全是1，代表全黑或全白。因此输出是杂乱的。但可以观察到，我们最终的预测值为最大的值的标签。\n\n下面官网上给出了一些模型层次的解释，来看看。\n\n### 模型层\n\n>  本节中我们分解上节构造的神经网络模型中的每一层。首先我们构造一个shape为(3, 28, 28)的随机数据（3个28x28的图像），依次通过每一个神经网络层来观察其效果。\n\n```\ninput_image = ops.ones((3, 28, 28), mindspore.float32)\nprint(input_image.shape)\n```\n\n> (3, 28, 28)\n\n### nn.Flatten\n\n>  实例化[nn.Flatten](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Flatten.html)层，将28x28的2D张量转换为784大小的连续数组。\n\n```python\nflatten = nn.Flatten()\nflat_image = flatten(input_image)\nprint(flat_image.shape)\n```\n\n> ```\n> (3, 784)\n> ```\n\n这里可见flatten打平只是打平第一维以外即输入数据样例外的维度，如果说初始数据是一个结构体数组，那Flatten的作用就是将其变为一个一维数组的数组。\n\n### nn.Dense\n\n> [nn.Dense](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Dense.html)为全连接层，其使用权重和偏差对输入进行线性变换。\n\n```\nlayer1 = nn.Dense(in_channels=28*28, out_channels=20)\nhidden1 = layer1(flat_image)\nprint(hidden1.shape)\n```\n\n> ```\n> (3, 20)\n> ```\n\n这里注意到有两个额外的参数即权重和偏差。也就是说下面每一层的节点就是上一层节点的带权和加上一个常数。\n\n### nn.ReLU\n\n>  [nn.ReLU](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.ReLU.html)层给网络中加入非线性的激活函数，帮助神经网络学习各种复杂的特征。\n\n```python\nprint(f\"Before ReLU: {hidden1}\\n\\n\")\nhidden1 = nn.ReLU()(hidden1)\nprint(f\"After ReLU: {hidden1}\")\n```\n\n> ```\n> Before ReLU: [[-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]\n>  [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]\n>  [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]]\n> \n> \n> After ReLU: [[0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]\n>  [0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]\n>  [0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]]\n> ```\n\n注意到，这里首次提出非线性运算的概念，也就是说，在这之前，运算都是线性的，这一步显然比较复杂，也不谈论。\n\n### nn.SequentialCell\n\n> [nn.SequentialCell](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.SequentialCell.html)是一个有序的Cell容器。输入Tensor将按照定义的顺序通过所有Cell。我们可以使用`SequentialCell`来快速组合构造一个神经网络模型。\n\n```python\nseq_modules = nn.SequentialCell(\n    flatten,\n    layer1,\n    nn.ReLU(),\n    nn.Dense(20, 10)\n)\n\nlogits = seq_modules(input_image)\nprint(logits.shape)\n```\n\n> ```\n> (3, 10)\n> ```\n\n注意看代码，对于这里的代码最好都不要跳过，也不要深究实现原理（新手），可见这里依次调用了上面的所有步骤，是对这一流程的封装。\n\n### nn.Softmax\n\n>  最后使用[nn.Softmax](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Softmax.html)将神经网络最后一个全连接层返回的logits的值缩放为[0, 1]，表示每个类别的预测概率。`axis`指定的维度数值和为1。\n\n```\nsoftmax = nn.Softmax(axis=1)\npred_probab = softmax(logits)\n```\n\n官网文档已经非常清楚了。还有不懂可以跑跑代码\n\n## 模型参数\n\n> 网络内部神经网络层具有权重参数和偏置参数（如`nn.Dense`），这些参数会在训练过程中不断进行优化，可通过 `model.parameters_and_names()` 来获取参数名及对应的参数详情。\n\n```python\nprint(f\"Model structure: {model}\\n\\n\")\n\nfor name, param in model.parameters_and_names():\n    print(f\"Layer: {name}\\nSize: {param.shape}\\nValues : {param[:2]} \\n\")\n```\n\n通过这一代码可以查看权重参数和偏置参数，这一代码应该是十分常见并且常用的。","source":"_posts/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork.md","raw":"---\ntitle: MindSpore专题——第五章、网络构建\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## 网格构建\n\n神经网络模型是由神经网络层和Tensor操作构成的，[mindspore.nn](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.nn.html)提供了常见神经网络层的实现，在MindSpore中，[Cell](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Cell.html)类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个`Cell`，它由不同的子`Cell`构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。\n\n下面我们将构建一个用于Mnist数据集分类的神经网络模型。\n\n<!--more-->\n\n### 定义模型类\n\n当我们定义神经网络时，可以继承`nn.Cell`类，在`__init__`方法中进行子Cell的实例化和状态管理，在`construct`方法中实现Tensor操作。\n\n```python\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512, weight_init=\"normal\", bias_init=\"zeros\"),\n            nn.ReLU(),\n            nn.Dense(512, 512, weight_init=\"normal\", bias_init=\"zeros\"),\n            nn.ReLU(),\n            nn.Dense(512, 10, weight_init=\"normal\", bias_init=\"zeros\")\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\n\nmodel = Network()\nprint(model)\n\n```\n\n> ```\n> Network<\n>   (flatten): Flatten<>\n>   (dense_relu_sequential): SequentialCell<\n>     (0): Dense<input_channels=784, output_channels=512, has_bias=True>\n>     (1): ReLU<>\n>     (2): Dense<input_channels=512, output_channels=512, has_bias=True>\n>     (3): ReLU<>\n>     (4): Dense<input_channels=512, output_channels=10, has_bias=True>\n>     >\n>   >\n> ```\n\n我们构造一个输入数据，直接调用模型，可以获得一个十维的Tensor输出，其包含每个类别的原始预测值。\n\n**`model.construct()`方法不可直接调用。**\n\n这里出现了很多很抽象的概念好像一下子让机器学习变成了一个黑盒子，实际上，我们观察上面的代码，很容易可以从中看出一些结构来，下面记录一下我这个初学者的理解。\n\n首先搬出一幅经典的图像\n\n![神经网络入门 - 阮一峰的网络日志](https://s2.loli.net/2024/06/07/n358NwDPeSg1LsZ.jpg)\n\n这幅图形象的描述了上面的过程。其中\n\n![image-20240607140358272](https://s2.loli.net/2024/06/07/KgVFjZ6LTY54r1s.png)\n\n这里开始的inputLayer就是我们的输入数据，中间连的密密麻麻的线就是上面结构输出中的Dense，可以观察到我们分别有$$784\\rightarrow 512\\rightarrow512\\rightarrow10$$​四层这样的全连接。最初的784也和28*28对应了起来。即我们每一个像素点都是一个参数，为最初输入的一个点，最后输出的则是代表数字概率的10个参数，最终我们会选择一个最接近的参数。这里的变量名用logits（不确定是否标准，但这里是这么用的）\n\n下面是一些展示调用的代码\n\n```python\nX = ops.ones((1, 28, 28), mindspore.float32)\nlogits = model(X)\n# print logits\n\nprint(Tensor(logits))\npred_probab = nn.Softmax(axis=1)(logits)\ny_pred = pred_probab.argmax(1)\nprint(f\"Predicted class: {y_pred}\")\n```\n\n读者可以试着运行几次，由于给出数据全是1，代表全黑或全白。因此输出是杂乱的。但可以观察到，我们最终的预测值为最大的值的标签。\n\n下面官网上给出了一些模型层次的解释，来看看。\n\n### 模型层\n\n>  本节中我们分解上节构造的神经网络模型中的每一层。首先我们构造一个shape为(3, 28, 28)的随机数据（3个28x28的图像），依次通过每一个神经网络层来观察其效果。\n\n```\ninput_image = ops.ones((3, 28, 28), mindspore.float32)\nprint(input_image.shape)\n```\n\n> (3, 28, 28)\n\n### nn.Flatten\n\n>  实例化[nn.Flatten](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Flatten.html)层，将28x28的2D张量转换为784大小的连续数组。\n\n```python\nflatten = nn.Flatten()\nflat_image = flatten(input_image)\nprint(flat_image.shape)\n```\n\n> ```\n> (3, 784)\n> ```\n\n这里可见flatten打平只是打平第一维以外即输入数据样例外的维度，如果说初始数据是一个结构体数组，那Flatten的作用就是将其变为一个一维数组的数组。\n\n### nn.Dense\n\n> [nn.Dense](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Dense.html)为全连接层，其使用权重和偏差对输入进行线性变换。\n\n```\nlayer1 = nn.Dense(in_channels=28*28, out_channels=20)\nhidden1 = layer1(flat_image)\nprint(hidden1.shape)\n```\n\n> ```\n> (3, 20)\n> ```\n\n这里注意到有两个额外的参数即权重和偏差。也就是说下面每一层的节点就是上一层节点的带权和加上一个常数。\n\n### nn.ReLU\n\n>  [nn.ReLU](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.ReLU.html)层给网络中加入非线性的激活函数，帮助神经网络学习各种复杂的特征。\n\n```python\nprint(f\"Before ReLU: {hidden1}\\n\\n\")\nhidden1 = nn.ReLU()(hidden1)\nprint(f\"After ReLU: {hidden1}\")\n```\n\n> ```\n> Before ReLU: [[-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]\n>  [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]\n>  [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264\n>    0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792\n>    0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425\n>   -0.10083733  0.05171938]]\n> \n> \n> After ReLU: [[0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]\n>  [0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]\n>  [0.         0.2939465  0.         0.         0.         0.\n>   0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792\n>   0.01825903 0.01287796 0.17238477 0.         0.         0.\n>   0.         0.05171938]]\n> ```\n\n注意到，这里首次提出非线性运算的概念，也就是说，在这之前，运算都是线性的，这一步显然比较复杂，也不谈论。\n\n### nn.SequentialCell\n\n> [nn.SequentialCell](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.SequentialCell.html)是一个有序的Cell容器。输入Tensor将按照定义的顺序通过所有Cell。我们可以使用`SequentialCell`来快速组合构造一个神经网络模型。\n\n```python\nseq_modules = nn.SequentialCell(\n    flatten,\n    layer1,\n    nn.ReLU(),\n    nn.Dense(20, 10)\n)\n\nlogits = seq_modules(input_image)\nprint(logits.shape)\n```\n\n> ```\n> (3, 10)\n> ```\n\n注意看代码，对于这里的代码最好都不要跳过，也不要深究实现原理（新手），可见这里依次调用了上面的所有步骤，是对这一流程的封装。\n\n### nn.Softmax\n\n>  最后使用[nn.Softmax](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Softmax.html)将神经网络最后一个全连接层返回的logits的值缩放为[0, 1]，表示每个类别的预测概率。`axis`指定的维度数值和为1。\n\n```\nsoftmax = nn.Softmax(axis=1)\npred_probab = softmax(logits)\n```\n\n官网文档已经非常清楚了。还有不懂可以跑跑代码\n\n## 模型参数\n\n> 网络内部神经网络层具有权重参数和偏置参数（如`nn.Dense`），这些参数会在训练过程中不断进行优化，可通过 `model.parameters_and_names()` 来获取参数名及对应的参数详情。\n\n```python\nprint(f\"Model structure: {model}\\n\\n\")\n\nfor name, param in model.parameters_and_names():\n    print(f\"Layer: {name}\\nSize: {param.shape}\\nValues : {param[:2]} \\n\")\n```\n\n通过这一代码可以查看权重参数和偏置参数，这一代码应该是十分常见并且常用的。","slug":"special_subject/MindSpore/Chapters/Fivth_ConstructNetwork","published":1,"updated":"2024-08-16T08:58:53.357Z","_id":"clzwh7ba6001y2wwv11b87osw","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"网格构建\">网格构建</h2>\r\n<p>神经网络模型是由神经网络层和Tensor操作构成的，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5ubi5odG1s\">mindspore.nn<i class=\"fa fa-external-link-alt\"></i></span>提供了常见神经网络层的实现，在MindSpore中，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5DZWxsLmh0bWw=\">Cell<i class=\"fa fa-external-link-alt\"></i></span>类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个<code>Cell</code>，它由不同的子<code>Cell</code>构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。</p>\r\n<p>下面我们将构建一个用于Mnist数据集分类的神经网络模型。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"定义模型类\">定义模型类</h3>\r\n<p>当我们定义神经网络时，可以继承<code>nn.Cell</code>类，在<code>__init__</code>方法中进行子Cell的实例化和状态管理，在<code>construct</code>方法中实现Tensor操作。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Network&lt;</span><br><span class=\"line\">  (flatten): Flatten&lt;&gt;</span><br><span class=\"line\">  (dense_relu_sequential): SequentialCell&lt;</span><br><span class=\"line\">    (0): Dense&lt;input_channels=784, output_channels=512, has_bias=True&gt;</span><br><span class=\"line\">    (1): ReLU&lt;&gt;</span><br><span class=\"line\">    (2): Dense&lt;input_channels=512, output_channels=512, has_bias=True&gt;</span><br><span class=\"line\">    (3): ReLU&lt;&gt;</span><br><span class=\"line\">    (4): Dense&lt;input_channels=512, output_channels=10, has_bias=True&gt;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">  &gt;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>我们构造一个输入数据，直接调用模型，可以获得一个十维的Tensor输出，其包含每个类别的原始预测值。</p>\r\n<p><strong><code>model.construct()</code>方法不可直接调用。</strong></p>\r\n<p>这里出现了很多很抽象的概念好像一下子让机器学习变成了一个黑盒子，实际上，我们观察上面的代码，很容易可以从中看出一些结构来，下面记录一下我这个初学者的理解。</p>\r\n<p>首先搬出一幅经典的图像</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/n358NwDPeSg1LsZ.jpg\"\r\nalt=\"神经网络入门 - 阮一峰的网络日志\" />\r\n<figcaption aria-hidden=\"true\">神经网络入门 -\r\n阮一峰的网络日志</figcaption>\r\n</figure>\r\n<p>这幅图形象的描述了上面的过程。其中</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/KgVFjZ6LTY54r1s.png\"\r\nalt=\"image-20240607140358272\" />\r\n<figcaption aria-hidden=\"true\">image-20240607140358272</figcaption>\r\n</figure>\r\n<p>这里开始的inputLayer就是我们的输入数据，中间连的密密麻麻的线就是上面结构输出中的Dense，可以观察到我们分别有<span\r\nclass=\"math display\">\\[784\\rightarrow\r\n512\\rightarrow512\\rightarrow10\\]</span>​四层这样的全连接。最初的784也和28*28对应了起来。即我们每一个像素点都是一个参数，为最初输入的一个点，最后输出的则是代表数字概率的10个参数，最终我们会选择一个最接近的参数。这里的变量名用logits（不确定是否标准，但这里是这么用的）</p>\r\n<p>下面是一些展示调用的代码</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X = ops.ones((<span class=\"number\">1</span>, <span class=\"number\">28</span>, <span class=\"number\">28</span>), mindspore.float32)</span><br><span class=\"line\">logits = model(X)</span><br><span class=\"line\"><span class=\"comment\"># print logits</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(Tensor(logits))</span><br><span class=\"line\">pred_probab = nn.Softmax(axis=<span class=\"number\">1</span>)(logits)</span><br><span class=\"line\">y_pred = pred_probab.argmax(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Predicted class: <span class=\"subst\">&#123;y_pred&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>读者可以试着运行几次，由于给出数据全是1，代表全黑或全白。因此输出是杂乱的。但可以观察到，我们最终的预测值为最大的值的标签。</p>\r\n<p>下面官网上给出了一些模型层次的解释，来看看。</p>\r\n<h3 id=\"模型层\">模型层</h3>\r\n<blockquote>\r\n<p>本节中我们分解上节构造的神经网络模型中的每一层。首先我们构造一个shape为(3,\r\n28,\r\n28)的随机数据（3个28x28的图像），依次通过每一个神经网络层来观察其效果。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_image = ops.ones((3, 28, 28), mindspore.float32)</span><br><span class=\"line\">print(input_image.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>(3, 28, 28)</p>\r\n</blockquote>\r\n<h3 id=\"nn.flatten\">nn.Flatten</h3>\r\n<blockquote>\r\n<p>实例化<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5GbGF0dGVuLmh0bWw=\">nn.Flatten<i class=\"fa fa-external-link-alt\"></i></span>层，将28x28的2D张量转换为784大小的连续数组。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flatten = nn.Flatten()</span><br><span class=\"line\">flat_image = flatten(input_image)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(flat_image.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 784)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>这里可见flatten打平只是打平第一维以外即输入数据样例外的维度，如果说初始数据是一个结构体数组，那Flatten的作用就是将其变为一个一维数组的数组。</p>\r\n<h3 id=\"nn.dense\">nn.Dense</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5EZW5zZS5odG1s\">nn.Dense<i class=\"fa fa-external-link-alt\"></i></span>为全连接层，其使用权重和偏差对输入进行线性变换。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layer1 = nn.Dense(in_channels=28*28, out_channels=20)</span><br><span class=\"line\">hidden1 = layer1(flat_image)</span><br><span class=\"line\">print(hidden1.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 20)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>这里注意到有两个额外的参数即权重和偏差。也就是说下面每一层的节点就是上一层节点的带权和加上一个常数。</p>\r\n<h3 id=\"nn.relu\">nn.ReLU</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5SZUxVLmh0bWw=\">nn.ReLU<i class=\"fa fa-external-link-alt\"></i></span>层给网络中加入非线性的激活函数，帮助神经网络学习各种复杂的特征。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Before ReLU: <span class=\"subst\">&#123;hidden1&#125;</span>\\n\\n&quot;</span>)</span><br><span class=\"line\">hidden1 = nn.ReLU()(hidden1)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;After ReLU: <span class=\"subst\">&#123;hidden1&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before ReLU: [[-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]</span><br><span class=\"line\"> [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]</span><br><span class=\"line\"> [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">After ReLU: [[0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]</span><br><span class=\"line\"> [0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]</span><br><span class=\"line\"> [0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]]</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>注意到，这里首次提出非线性运算的概念，也就是说，在这之前，运算都是线性的，这一步显然比较复杂，也不谈论。</p>\r\n<h3 id=\"nn.sequentialcell\">nn.SequentialCell</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5TZXF1ZW50aWFsQ2VsbC5odG1s\">nn.SequentialCell<i class=\"fa fa-external-link-alt\"></i></span>是一个有序的Cell容器。输入Tensor将按照定义的顺序通过所有Cell。我们可以使用<code>SequentialCell</code>来快速组合构造一个神经网络模型。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seq_modules = nn.SequentialCell(</span><br><span class=\"line\">    flatten,</span><br><span class=\"line\">    layer1,</span><br><span class=\"line\">    nn.ReLU(),</span><br><span class=\"line\">    nn.Dense(<span class=\"number\">20</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">logits = seq_modules(input_image)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logits.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 10)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>注意看代码，对于这里的代码最好都不要跳过，也不要深究实现原理（新手），可见这里依次调用了上面的所有步骤，是对这一流程的封装。</p>\r\n<h3 id=\"nn.softmax\">nn.Softmax</h3>\r\n<blockquote>\r\n<p>最后使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5Tb2Z0bWF4Lmh0bWw=\">nn.Softmax<i class=\"fa fa-external-link-alt\"></i></span>将神经网络最后一个全连接层返回的logits的值缩放为[0,\r\n1]，表示每个类别的预测概率。<code>axis</code>指定的维度数值和为1。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">softmax = nn.Softmax(axis=1)</span><br><span class=\"line\">pred_probab = softmax(logits)</span><br></pre></td></tr></table></figure>\r\n<p>官网文档已经非常清楚了。还有不懂可以跑跑代码</p>\r\n<h2 id=\"模型参数\">模型参数</h2>\r\n<blockquote>\r\n<p>网络内部神经网络层具有权重参数和偏置参数（如<code>nn.Dense</code>），这些参数会在训练过程中不断进行优化，可通过\r\n<code>model.parameters_and_names()</code>\r\n来获取参数名及对应的参数详情。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Model structure: <span class=\"subst\">&#123;model&#125;</span>\\n\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> name, param <span class=\"keyword\">in</span> model.parameters_and_names():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Layer: <span class=\"subst\">&#123;name&#125;</span>\\nSize: <span class=\"subst\">&#123;param.shape&#125;</span>\\nValues : <span class=\"subst\">&#123;param[:<span class=\"number\">2</span>]&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>通过这一代码可以查看权重参数和偏置参数，这一代码应该是十分常见并且常用的。</p>\r\n","length":1514,"excerpt":"<h2 id=\"网格构建\">网格构建</h2>\r\n<p>神经网络模型是由神经网络层和Tensor操作构成的，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5ubi5odG1s\">mindspore.nn<i class=\"fa fa-external-link-alt\"></i></span>提供了常见神经网络层的实现，在MindSpore中，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5DZWxsLmh0bWw=\">Cell<i class=\"fa fa-external-link-alt\"></i></span>类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个<code>Cell</code>，它由不同的子<code>Cell</code>构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。</p>\r\n<p>下面我们将构建一个用于Mnist数据集分类的神经网络模型。</p>","more":"<h3 id=\"定义模型类\">定义模型类</h3>\r\n<p>当我们定义神经网络时，可以继承<code>nn.Cell</code>类，在<code>__init__</code>方法中进行子Cell的实例化和状态管理，在<code>construct</code>方法中实现Tensor操作。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>, weight_init=<span class=\"string\">&quot;normal&quot;</span>, bias_init=<span class=\"string\">&quot;zeros&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Network&lt;</span><br><span class=\"line\">  (flatten): Flatten&lt;&gt;</span><br><span class=\"line\">  (dense_relu_sequential): SequentialCell&lt;</span><br><span class=\"line\">    (0): Dense&lt;input_channels=784, output_channels=512, has_bias=True&gt;</span><br><span class=\"line\">    (1): ReLU&lt;&gt;</span><br><span class=\"line\">    (2): Dense&lt;input_channels=512, output_channels=512, has_bias=True&gt;</span><br><span class=\"line\">    (3): ReLU&lt;&gt;</span><br><span class=\"line\">    (4): Dense&lt;input_channels=512, output_channels=10, has_bias=True&gt;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">  &gt;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>我们构造一个输入数据，直接调用模型，可以获得一个十维的Tensor输出，其包含每个类别的原始预测值。</p>\r\n<p><strong><code>model.construct()</code>方法不可直接调用。</strong></p>\r\n<p>这里出现了很多很抽象的概念好像一下子让机器学习变成了一个黑盒子，实际上，我们观察上面的代码，很容易可以从中看出一些结构来，下面记录一下我这个初学者的理解。</p>\r\n<p>首先搬出一幅经典的图像</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/n358NwDPeSg1LsZ.jpg\"\r\nalt=\"神经网络入门 - 阮一峰的网络日志\" />\r\n<figcaption aria-hidden=\"true\">神经网络入门 -\r\n阮一峰的网络日志</figcaption>\r\n</figure>\r\n<p>这幅图形象的描述了上面的过程。其中</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/KgVFjZ6LTY54r1s.png\"\r\nalt=\"image-20240607140358272\" />\r\n<figcaption aria-hidden=\"true\">image-20240607140358272</figcaption>\r\n</figure>\r\n<p>这里开始的inputLayer就是我们的输入数据，中间连的密密麻麻的线就是上面结构输出中的Dense，可以观察到我们分别有<span\r\nclass=\"math display\">\\[784\\rightarrow\r\n512\\rightarrow512\\rightarrow10\\]</span>​四层这样的全连接。最初的784也和28*28对应了起来。即我们每一个像素点都是一个参数，为最初输入的一个点，最后输出的则是代表数字概率的10个参数，最终我们会选择一个最接近的参数。这里的变量名用logits（不确定是否标准，但这里是这么用的）</p>\r\n<p>下面是一些展示调用的代码</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X = ops.ones((<span class=\"number\">1</span>, <span class=\"number\">28</span>, <span class=\"number\">28</span>), mindspore.float32)</span><br><span class=\"line\">logits = model(X)</span><br><span class=\"line\"><span class=\"comment\"># print logits</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(Tensor(logits))</span><br><span class=\"line\">pred_probab = nn.Softmax(axis=<span class=\"number\">1</span>)(logits)</span><br><span class=\"line\">y_pred = pred_probab.argmax(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Predicted class: <span class=\"subst\">&#123;y_pred&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>读者可以试着运行几次，由于给出数据全是1，代表全黑或全白。因此输出是杂乱的。但可以观察到，我们最终的预测值为最大的值的标签。</p>\r\n<p>下面官网上给出了一些模型层次的解释，来看看。</p>\r\n<h3 id=\"模型层\">模型层</h3>\r\n<blockquote>\r\n<p>本节中我们分解上节构造的神经网络模型中的每一层。首先我们构造一个shape为(3,\r\n28,\r\n28)的随机数据（3个28x28的图像），依次通过每一个神经网络层来观察其效果。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_image = ops.ones((3, 28, 28), mindspore.float32)</span><br><span class=\"line\">print(input_image.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>(3, 28, 28)</p>\r\n</blockquote>\r\n<h3 id=\"nn.flatten\">nn.Flatten</h3>\r\n<blockquote>\r\n<p>实例化<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5GbGF0dGVuLmh0bWw=\">nn.Flatten<i class=\"fa fa-external-link-alt\"></i></span>层，将28x28的2D张量转换为784大小的连续数组。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flatten = nn.Flatten()</span><br><span class=\"line\">flat_image = flatten(input_image)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(flat_image.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 784)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>这里可见flatten打平只是打平第一维以外即输入数据样例外的维度，如果说初始数据是一个结构体数组，那Flatten的作用就是将其变为一个一维数组的数组。</p>\r\n<h3 id=\"nn.dense\">nn.Dense</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5EZW5zZS5odG1s\">nn.Dense<i class=\"fa fa-external-link-alt\"></i></span>为全连接层，其使用权重和偏差对输入进行线性变换。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layer1 = nn.Dense(in_channels=28*28, out_channels=20)</span><br><span class=\"line\">hidden1 = layer1(flat_image)</span><br><span class=\"line\">print(hidden1.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 20)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>这里注意到有两个额外的参数即权重和偏差。也就是说下面每一层的节点就是上一层节点的带权和加上一个常数。</p>\r\n<h3 id=\"nn.relu\">nn.ReLU</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5SZUxVLmh0bWw=\">nn.ReLU<i class=\"fa fa-external-link-alt\"></i></span>层给网络中加入非线性的激活函数，帮助神经网络学习各种复杂的特征。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Before ReLU: <span class=\"subst\">&#123;hidden1&#125;</span>\\n\\n&quot;</span>)</span><br><span class=\"line\">hidden1 = nn.ReLU()(hidden1)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;After ReLU: <span class=\"subst\">&#123;hidden1&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before ReLU: [[-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]</span><br><span class=\"line\"> [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]</span><br><span class=\"line\"> [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class=\"line\">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class=\"line\">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class=\"line\">  -0.10083733  0.05171938]]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">After ReLU: [[0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]</span><br><span class=\"line\"> [0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]</span><br><span class=\"line\"> [0.         0.2939465  0.         0.         0.         0.</span><br><span class=\"line\">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class=\"line\">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class=\"line\">  0.         0.05171938]]</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>注意到，这里首次提出非线性运算的概念，也就是说，在这之前，运算都是线性的，这一步显然比较复杂，也不谈论。</p>\r\n<h3 id=\"nn.sequentialcell\">nn.SequentialCell</h3>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5TZXF1ZW50aWFsQ2VsbC5odG1s\">nn.SequentialCell<i class=\"fa fa-external-link-alt\"></i></span>是一个有序的Cell容器。输入Tensor将按照定义的顺序通过所有Cell。我们可以使用<code>SequentialCell</code>来快速组合构造一个神经网络模型。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seq_modules = nn.SequentialCell(</span><br><span class=\"line\">    flatten,</span><br><span class=\"line\">    layer1,</span><br><span class=\"line\">    nn.ReLU(),</span><br><span class=\"line\">    nn.Dense(<span class=\"number\">20</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">logits = seq_modules(input_image)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logits.shape)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3, 10)</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>注意看代码，对于这里的代码最好都不要跳过，也不要深究实现原理（新手），可见这里依次调用了上面的所有步骤，是对这一流程的封装。</p>\r\n<h3 id=\"nn.softmax\">nn.Softmax</h3>\r\n<blockquote>\r\n<p>最后使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5Tb2Z0bWF4Lmh0bWw=\">nn.Softmax<i class=\"fa fa-external-link-alt\"></i></span>将神经网络最后一个全连接层返回的logits的值缩放为[0,\r\n1]，表示每个类别的预测概率。<code>axis</code>指定的维度数值和为1。</p>\r\n</blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">softmax = nn.Softmax(axis=1)</span><br><span class=\"line\">pred_probab = softmax(logits)</span><br></pre></td></tr></table></figure>\r\n<p>官网文档已经非常清楚了。还有不懂可以跑跑代码</p>\r\n<h2 id=\"模型参数\">模型参数</h2>\r\n<blockquote>\r\n<p>网络内部神经网络层具有权重参数和偏置参数（如<code>nn.Dense</code>），这些参数会在训练过程中不断进行优化，可通过\r\n<code>model.parameters_and_names()</code>\r\n来获取参数名及对应的参数详情。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Model structure: <span class=\"subst\">&#123;model&#125;</span>\\n\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> name, param <span class=\"keyword\">in</span> model.parameters_and_names():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Layer: <span class=\"subst\">&#123;name&#125;</span>\\nSize: <span class=\"subst\">&#123;param.shape&#125;</span>\\nValues : <span class=\"subst\">&#123;param[:<span class=\"number\">2</span>]&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>通过这一代码可以查看权重参数和偏置参数，这一代码应该是十分常见并且常用的。</p>"},{"title":"MindSpore专题——第〇章、概念","date":"2024-08-14T11:47:58.000Z","_content":"# 初等概念名词解释\n\n在接近学完初级的机器学习后，我意识到单纯的看MindSpore文档以及看Youtube视频是远远不够的，我必须系统的学习一些概念知识以避免在后面的学习中云里雾里，故就有了这一章，在这一章中几乎全是对概念的解释，他们的来源广泛，传送门我都会贴在此处，供查阅：\n\n> [神经网络入门 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2017/07/neural-network.html)\n>\n> https://github.com/exacity/deeplearningbook-chinese\n\n<!--more-->\n\n##  感知机（Perceptron）\n\n![img](https://s2.loli.net/2024/06/10/bkVr3Lymea1OAnw.png)\n\n​\t上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3...），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。\n\n​\t感知机是输出传入参数的一个函数变换，大多数情况下他是(最初涉及)\n$$\noutput = \\sigma(w_1*a_1 +\\cdots +w_n*a_n + b)\n$$\n其中$$\\sigma $$​函数表达式如下\n$$\nσ(z) = 1 / (1 + e^{-z})\n$$\n\n## 表示学习（Representation Learning）\n\n使用机器学习来发掘表示本身，而不仅仅把表示映射到输出,学习到的表示往往比手动设计的表示表现得更好。并且不需要人工干预就能迅速适应新的任务。\n\n## 变差因素\n\n在此背景下，‘‘因素’’这个词仅指代影响的不同来源；因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反，它们可能是现实世界中观察不到的物体或者不可观测的力，但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因，它们还可能以概念的形式存在于人类的思维中。\n\n它们可以被看作数据的概念或者抽象，帮助我们了解这些数据的丰富多样性。\n\n## 可见层\n\n也就是神经网路的输入层，这样命名的原因是因为它包含我们能观察到的变量。\n\n## 隐藏层\n\n也就是神经网路的中间层。因为它们的值不在数据中给出，所以将这些层称为‘‘隐藏”;模型必须确定哪些概念有利于解释观察数据中的关系。这里的图像是每个隐藏单元表示的特征的可视化。这里也是分形的思想运用的层次。\n\n## 输出层\n\n输出神经网路的判断也称Object Identify\n\n## 前馈深度网络\n\n### 多层感知机（Multilayer Perceptron）\n\n多层感知机仅仅是一个将一组输入值映射到输出值的数学函数。该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。\n\n## 为什么需要使用非线性函数\n\n这是由于线性模型的局限性，一个很经典的例子是，线性模型是无法学习异或函数的。\n\n## 分布式表示\n\n其思想是：系统的每一个输入都应该由多个特征表示，并且每一个特征都应该参与到多个可能输入的表示。这显然也与神经网络每一层layer与layer之间的dense有关联\n\n## 激活函数\n\n## 损失函数\n\n## 梯度下降\n\n## 正则化\n\n## 过拟合\n\n## 线性代数\n\n### 主对角线\n\n即满足$$a = \\{a_{i,j}|i=j\\}$$的元素构成的线，特殊的$$n\\not =m$$\n\n![image-20240609143044969](https://s2.loli.net/2024/06/10/7WA9zDuB2UYrlKF.png)\n\n### 转置\n\n即矩阵对主对角线的镜像，特俗的有$$n\\not = m$$\n\n![image-20240609143213322](https://s2.loli.net/2024/06/10/vtux96qNrkAH8jZ.png)\n\n### 元素对应乘积（Hadamard 乘积）\n\n记为$$A\\odot B$$\n\n### 点积\n\n两个相同维数的向量x和y的点积（dot product）可看作是矩阵乘积$$A^\\top B$$​。我们可以把矩阵乘积C=AB中计算Cij的步骤看作是A的第i行和B的第j列之间的点积。\n\n矩阵的乘法是不满足交换律的，但是矩阵的点积是满足的。\n$$\nx^\\top y = y^\\top x\n$$\n\n\n矩阵乘积转置的简单形式\n$$\n(AB)^\\top = B^\\top A^\\top\n$$\n注意顺序是不能更改的因为矩阵乘法不满足交换律\n\n### 单位矩阵\n\n单位矩阵指主对角线上的值都为1，其他地方都为零的矩阵。\n\n我们将保持n维向量不变的单位矩阵记作$$I_n$$。\n\n### 逆矩阵\n\n很朴素的定义，需要注意的是由于矩阵乘法不满足交换律，因此我们再说一个矩阵的逆的时候通常是说矩阵的左逆。\n\n对于方阵而言，它的左逆和右逆是相等的\n\n### 线性相关与生成子空间\n\n如果逆矩阵$$A^{-1}$$​存在。那么式(2.11)肯定对于每一个向量b恰好存在一个解。但是，对于方程组而言，对于向量b的某些值，有可能不存在解，或者存在无限多个解。存在多于一个解但是少于无限多个解的情况是不可能发生的；因为如果x和y都是某方程组的解，则x,y则构成了一个张成空间。\n\n为了分析方程有多少个解，我们可以将A的列向量看作从原点（origin）（元素都是零的向量）出发的不同方向，确定有多少种方法可以到达向量b。在这个观点下，向量x中的每个元素表示我们应该沿着这些方向走多远，即xi表示我们需要沿着第i个向量的方向走多远：\n$$\nAx = \\sum _i x_i A_{:,i}\n$$\n这样的操作我们称为线性组合。形式上，一组向量的线性组合是指每个向量乘以对应标量系数之后的和，即：\n$$\n\\sum _i c_i v^{(i)}\n$$\n一组向量的生成子空间（span）是原始向量线性组合后所能抵达的点的集合。\n\n确定Ax=b是否有解相当于确定向量b是否在A列向量的生成子空间中。这个特殊的生成子空间被称为A的列空间（column space）或者A的值域（range）。\n\n为了使方程Ax=b对于任意向量$$b\\in \\mathbb{R}^m$$都存在解，我们要求A的列空间构成整个$$\\mathbb{R}^m$$。如果$$\\mathbb{R}^m$$中的某个点不在A的列空间中，那么该点对应的b会使得该方程没有解。矩阵A的列空间是整个$$\\mathbb{R}^m$$的要求，意味着A至少有m列，即n>=m。否则，A列空间的维数会小于m。例如，假设A是一个$$3\\times 2$$的矩阵。目标b是3维的，但是x只有2维。所以无论如何修改x的值，也只能描绘出$$\\mathbb{R}^3$$空间中的二维平面。当且仅当向量b在该二维平面中时，该方程有解。\n\n不等式n>=m仅是方程对每一点都有解的必要条件。这不是一个充分条件，因为有些列向量可能是冗余的。假设有一个$$\\mathbb{R}^{2\\times2}$$中的矩阵，它的两个列向量是相同的。那么它的列空间和它的一个列向量作为矩阵的列空间是一样的。换言之，虽然该矩阵有2列，但是它的列空间仍然只是一条线，不能涵盖整个$$\\mathbb{R}^2$$空间。\n\n正式地说，这种冗余被称为线性相关（linear dependence）。如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为线性无关（linearly independent）。如果某个向量是一组向量中某些向量的线性组合，那么我们将这个向量加入这组向量后不会增加这组向量的生成子空间。这意味着，如果一个矩阵的列空间涵盖整个$$\\mathbb{R}^m$$，那么该矩阵必须包含至少一组m个线性无关的向量。这是对于每一个向量b的取值都有解的充分必要条件。值得注意的是，这个条件是说该向量集恰好有m个线性无关的列向量，而不是至少m个。不存在一个m维向量的集合具有多于m个彼此线性不相关的列向量，但是一个有多于m个列向量的矩阵有可能拥有不止一个大小为m的线性无关向量集。\n\n要想使矩阵可逆，我们还需要保证对于每一个b值至多有一个解。为此，我们需要确保该矩阵至多有m个列向量。否则，该方程会有不止一个解。\n\n### 奇异矩阵（singular square）\n\n该矩阵必须是一个方阵（square），即m=n，并且所有列向量都是线性无关的。一个列向量线性相关的方阵被称为奇异的（singular）。\n\n### 矩阵右乘\n\n$$\nAA^{-1}=I\n$$\n\n### 范数（norm）\n\n用来衡量一个向量的大小。机器学习中常用范数衡量向量大小。形式上$$L^p$$定义如下\n$$\n||x||_p = \\left( \\sum _i |x_i|^p \\right) ^{\\frac{1}{p}}\n$$\n范数（包括Lp范数）是将向量映射到非负值的函数\n\n严格的讲，范数是满足以下性质的函数\n\n- f(x) = 0 => x=0\n- f(x+y) <=f(x) + f(y) （三角不等式）\n- 对$$\\forall \\alpha \\in \\mathbb{R},f(\\alpha x) = |\\alpha|f(x)$$\n\n当p= 2时，$$L^2$$范数被称为欧几里得范数（Euclidean norm）。它表示从原点出发到向量x确定的点的欧几里得距离。$$L^2$$范数在机器学习中出现地十分频繁，经常简化表示为∥x∥，略去了下标2。平方$$L^2$$范数也经常用来衡量向量的大小，可以简单地通过点积$$x ^\\top x$$计算。\n\n但是在很多情况下，平方$$L^2$$范数也可能不受欢迎，因为它在原点附近增长得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数：$$L^1$$范数。$$L^1$$范数可以简化如下：\n$$\n||x||_1 = \\sum _i |x_i|\n$$\n有时候我们会统计向量中非零元素的个数来衡量向量的大小。有些作者将这种函数称为“$$L^0$$范数’’，但是这个术语在数学意义上是不对的\n\n另外一个经常在机器学习中出现的范数是$$L^\\inf$$范数，也被称为最大范数（maxnorm）。这个范数表示向量中具有最大幅值的元素的绝对值：\n$$\n||x||_1 = \\max _i |x_i|\n$$\n有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用Frobenius范数（Frobenius norm），\n$$\n||A||_F = \\sqrt{\\sum _{i,j} A^2_{i,j}}\n$$\n两个向量的点集可以用范数来表示，具体的\n$$\nx^\\top y = ||x||_2 ||y||_2 cos\\theta\n$$\n$$\\theta$$表示x,y之间的夹角\n\n### 对角矩阵\n\n只在主对角线上含有非零元素，，其他位置都是零。用diag($$v$$)表示一个对角矩阵。\n\n计算乘法diag(v)x，我们只需要将x中的每个元素xi放大vi倍。换言之，diag(v)x=v⊙x\n\n对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，在这种情况下，diag(v)1=diag([1/v1;.... ;1/vn]⊤)。\n\n非方阵的对角矩阵没有逆矩阵\n\n### 对称矩阵\n\n对称矩阵是矩阵的转置和自己相等的矩阵\n$$\nA = A ^\\top\n$$\n\n### 单位矩阵\n\n具有单位范数的矩阵\n\n如果$$x^\\top y=0$$，那么向量x和向量y互相正交（orthogonal）。如果两个向量都有非零范数，那么这两个向量之间的夹角是90度。在Rn中，至多有n个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为1，那么我们称它们是标准正交（orthonormal）。\n\n正交矩阵（orthogonal matrix）是指行向量和列向量是分别标准正交的方阵，更具体的，他们是满足以下条件的矩阵\n$$\nA^\\top A = A ^\\top A = I.\n$$\n这样意味着\n$$\nA^{-1} = A^\\top\n$$\n\n### 特征分解\n\n特征分解（eigendecomposition）是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值。\n\n方阵A的特征向量（eigenvector）是指与A相乘后相当于对该向量进行缩放的非零向量v：\n$$\nA v = \\lambda v\n$$\n标量$\\lambda$被称为这个特征向量对应的特征值（eigenvalue）。\n\n（类似地，我们也可以定义左特征向量（left eigenvector）$$v^⊤A=\\lambda v^⊤$$，但是通常我们更关注右特征向量（right eigenvector））。\n\n所有特征值都是正数的矩阵被称为正定（positive definite）；所有特征值都是非负数的矩阵被称为半正定（positive semidefinite）。同样地，所有特征值都是负数的矩阵被称为负定（negative definite）；所有特征值都是非正数的矩阵被称为半负定（negative semidefinite）。\n\n然而，我们也常常希望将矩阵分解（decompose）成特征值和特征向量。这样可以帮助我们分析矩阵的特定性质，就像质因数分解有助于我们理解整数。\n\n矩阵A的特征分解可以记作\n$$\nA = V diag(\\lambda) V^{-1}\n$$\n不是每一个矩阵都可以分解成特征值和特征向量。在某些情况下，特征分解存在，但是会涉及复数而非实数。\n\n其中Q是A的特征向量组成的正交矩阵，是对角矩阵。特征值$$\\lambda_{i;i}$$对应的特征向量是矩阵Q的第i列，记作Q:;i。因为Q是正交矩阵，我们可以将A看作沿方向v(i)延展i倍的空间","source":"_posts/special_subject/MindSpore/Chapters/Concept.md","raw":"---\ntitle: MindSpore专题——第〇章、概念\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n# 初等概念名词解释\n\n在接近学完初级的机器学习后，我意识到单纯的看MindSpore文档以及看Youtube视频是远远不够的，我必须系统的学习一些概念知识以避免在后面的学习中云里雾里，故就有了这一章，在这一章中几乎全是对概念的解释，他们的来源广泛，传送门我都会贴在此处，供查阅：\n\n> [神经网络入门 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2017/07/neural-network.html)\n>\n> https://github.com/exacity/deeplearningbook-chinese\n\n<!--more-->\n\n##  感知机（Perceptron）\n\n![img](https://s2.loli.net/2024/06/10/bkVr3Lymea1OAnw.png)\n\n​\t上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3...），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。\n\n​\t感知机是输出传入参数的一个函数变换，大多数情况下他是(最初涉及)\n$$\noutput = \\sigma(w_1*a_1 +\\cdots +w_n*a_n + b)\n$$\n其中$$\\sigma $$​函数表达式如下\n$$\nσ(z) = 1 / (1 + e^{-z})\n$$\n\n## 表示学习（Representation Learning）\n\n使用机器学习来发掘表示本身，而不仅仅把表示映射到输出,学习到的表示往往比手动设计的表示表现得更好。并且不需要人工干预就能迅速适应新的任务。\n\n## 变差因素\n\n在此背景下，‘‘因素’’这个词仅指代影响的不同来源；因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反，它们可能是现实世界中观察不到的物体或者不可观测的力，但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因，它们还可能以概念的形式存在于人类的思维中。\n\n它们可以被看作数据的概念或者抽象，帮助我们了解这些数据的丰富多样性。\n\n## 可见层\n\n也就是神经网路的输入层，这样命名的原因是因为它包含我们能观察到的变量。\n\n## 隐藏层\n\n也就是神经网路的中间层。因为它们的值不在数据中给出，所以将这些层称为‘‘隐藏”;模型必须确定哪些概念有利于解释观察数据中的关系。这里的图像是每个隐藏单元表示的特征的可视化。这里也是分形的思想运用的层次。\n\n## 输出层\n\n输出神经网路的判断也称Object Identify\n\n## 前馈深度网络\n\n### 多层感知机（Multilayer Perceptron）\n\n多层感知机仅仅是一个将一组输入值映射到输出值的数学函数。该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。\n\n## 为什么需要使用非线性函数\n\n这是由于线性模型的局限性，一个很经典的例子是，线性模型是无法学习异或函数的。\n\n## 分布式表示\n\n其思想是：系统的每一个输入都应该由多个特征表示，并且每一个特征都应该参与到多个可能输入的表示。这显然也与神经网络每一层layer与layer之间的dense有关联\n\n## 激活函数\n\n## 损失函数\n\n## 梯度下降\n\n## 正则化\n\n## 过拟合\n\n## 线性代数\n\n### 主对角线\n\n即满足$$a = \\{a_{i,j}|i=j\\}$$的元素构成的线，特殊的$$n\\not =m$$\n\n![image-20240609143044969](https://s2.loli.net/2024/06/10/7WA9zDuB2UYrlKF.png)\n\n### 转置\n\n即矩阵对主对角线的镜像，特俗的有$$n\\not = m$$\n\n![image-20240609143213322](https://s2.loli.net/2024/06/10/vtux96qNrkAH8jZ.png)\n\n### 元素对应乘积（Hadamard 乘积）\n\n记为$$A\\odot B$$\n\n### 点积\n\n两个相同维数的向量x和y的点积（dot product）可看作是矩阵乘积$$A^\\top B$$​。我们可以把矩阵乘积C=AB中计算Cij的步骤看作是A的第i行和B的第j列之间的点积。\n\n矩阵的乘法是不满足交换律的，但是矩阵的点积是满足的。\n$$\nx^\\top y = y^\\top x\n$$\n\n\n矩阵乘积转置的简单形式\n$$\n(AB)^\\top = B^\\top A^\\top\n$$\n注意顺序是不能更改的因为矩阵乘法不满足交换律\n\n### 单位矩阵\n\n单位矩阵指主对角线上的值都为1，其他地方都为零的矩阵。\n\n我们将保持n维向量不变的单位矩阵记作$$I_n$$。\n\n### 逆矩阵\n\n很朴素的定义，需要注意的是由于矩阵乘法不满足交换律，因此我们再说一个矩阵的逆的时候通常是说矩阵的左逆。\n\n对于方阵而言，它的左逆和右逆是相等的\n\n### 线性相关与生成子空间\n\n如果逆矩阵$$A^{-1}$$​存在。那么式(2.11)肯定对于每一个向量b恰好存在一个解。但是，对于方程组而言，对于向量b的某些值，有可能不存在解，或者存在无限多个解。存在多于一个解但是少于无限多个解的情况是不可能发生的；因为如果x和y都是某方程组的解，则x,y则构成了一个张成空间。\n\n为了分析方程有多少个解，我们可以将A的列向量看作从原点（origin）（元素都是零的向量）出发的不同方向，确定有多少种方法可以到达向量b。在这个观点下，向量x中的每个元素表示我们应该沿着这些方向走多远，即xi表示我们需要沿着第i个向量的方向走多远：\n$$\nAx = \\sum _i x_i A_{:,i}\n$$\n这样的操作我们称为线性组合。形式上，一组向量的线性组合是指每个向量乘以对应标量系数之后的和，即：\n$$\n\\sum _i c_i v^{(i)}\n$$\n一组向量的生成子空间（span）是原始向量线性组合后所能抵达的点的集合。\n\n确定Ax=b是否有解相当于确定向量b是否在A列向量的生成子空间中。这个特殊的生成子空间被称为A的列空间（column space）或者A的值域（range）。\n\n为了使方程Ax=b对于任意向量$$b\\in \\mathbb{R}^m$$都存在解，我们要求A的列空间构成整个$$\\mathbb{R}^m$$。如果$$\\mathbb{R}^m$$中的某个点不在A的列空间中，那么该点对应的b会使得该方程没有解。矩阵A的列空间是整个$$\\mathbb{R}^m$$的要求，意味着A至少有m列，即n>=m。否则，A列空间的维数会小于m。例如，假设A是一个$$3\\times 2$$的矩阵。目标b是3维的，但是x只有2维。所以无论如何修改x的值，也只能描绘出$$\\mathbb{R}^3$$空间中的二维平面。当且仅当向量b在该二维平面中时，该方程有解。\n\n不等式n>=m仅是方程对每一点都有解的必要条件。这不是一个充分条件，因为有些列向量可能是冗余的。假设有一个$$\\mathbb{R}^{2\\times2}$$中的矩阵，它的两个列向量是相同的。那么它的列空间和它的一个列向量作为矩阵的列空间是一样的。换言之，虽然该矩阵有2列，但是它的列空间仍然只是一条线，不能涵盖整个$$\\mathbb{R}^2$$空间。\n\n正式地说，这种冗余被称为线性相关（linear dependence）。如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为线性无关（linearly independent）。如果某个向量是一组向量中某些向量的线性组合，那么我们将这个向量加入这组向量后不会增加这组向量的生成子空间。这意味着，如果一个矩阵的列空间涵盖整个$$\\mathbb{R}^m$$，那么该矩阵必须包含至少一组m个线性无关的向量。这是对于每一个向量b的取值都有解的充分必要条件。值得注意的是，这个条件是说该向量集恰好有m个线性无关的列向量，而不是至少m个。不存在一个m维向量的集合具有多于m个彼此线性不相关的列向量，但是一个有多于m个列向量的矩阵有可能拥有不止一个大小为m的线性无关向量集。\n\n要想使矩阵可逆，我们还需要保证对于每一个b值至多有一个解。为此，我们需要确保该矩阵至多有m个列向量。否则，该方程会有不止一个解。\n\n### 奇异矩阵（singular square）\n\n该矩阵必须是一个方阵（square），即m=n，并且所有列向量都是线性无关的。一个列向量线性相关的方阵被称为奇异的（singular）。\n\n### 矩阵右乘\n\n$$\nAA^{-1}=I\n$$\n\n### 范数（norm）\n\n用来衡量一个向量的大小。机器学习中常用范数衡量向量大小。形式上$$L^p$$定义如下\n$$\n||x||_p = \\left( \\sum _i |x_i|^p \\right) ^{\\frac{1}{p}}\n$$\n范数（包括Lp范数）是将向量映射到非负值的函数\n\n严格的讲，范数是满足以下性质的函数\n\n- f(x) = 0 => x=0\n- f(x+y) <=f(x) + f(y) （三角不等式）\n- 对$$\\forall \\alpha \\in \\mathbb{R},f(\\alpha x) = |\\alpha|f(x)$$\n\n当p= 2时，$$L^2$$范数被称为欧几里得范数（Euclidean norm）。它表示从原点出发到向量x确定的点的欧几里得距离。$$L^2$$范数在机器学习中出现地十分频繁，经常简化表示为∥x∥，略去了下标2。平方$$L^2$$范数也经常用来衡量向量的大小，可以简单地通过点积$$x ^\\top x$$计算。\n\n但是在很多情况下，平方$$L^2$$范数也可能不受欢迎，因为它在原点附近增长得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数：$$L^1$$范数。$$L^1$$范数可以简化如下：\n$$\n||x||_1 = \\sum _i |x_i|\n$$\n有时候我们会统计向量中非零元素的个数来衡量向量的大小。有些作者将这种函数称为“$$L^0$$范数’’，但是这个术语在数学意义上是不对的\n\n另外一个经常在机器学习中出现的范数是$$L^\\inf$$范数，也被称为最大范数（maxnorm）。这个范数表示向量中具有最大幅值的元素的绝对值：\n$$\n||x||_1 = \\max _i |x_i|\n$$\n有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用Frobenius范数（Frobenius norm），\n$$\n||A||_F = \\sqrt{\\sum _{i,j} A^2_{i,j}}\n$$\n两个向量的点集可以用范数来表示，具体的\n$$\nx^\\top y = ||x||_2 ||y||_2 cos\\theta\n$$\n$$\\theta$$表示x,y之间的夹角\n\n### 对角矩阵\n\n只在主对角线上含有非零元素，，其他位置都是零。用diag($$v$$)表示一个对角矩阵。\n\n计算乘法diag(v)x，我们只需要将x中的每个元素xi放大vi倍。换言之，diag(v)x=v⊙x\n\n对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，在这种情况下，diag(v)1=diag([1/v1;.... ;1/vn]⊤)。\n\n非方阵的对角矩阵没有逆矩阵\n\n### 对称矩阵\n\n对称矩阵是矩阵的转置和自己相等的矩阵\n$$\nA = A ^\\top\n$$\n\n### 单位矩阵\n\n具有单位范数的矩阵\n\n如果$$x^\\top y=0$$，那么向量x和向量y互相正交（orthogonal）。如果两个向量都有非零范数，那么这两个向量之间的夹角是90度。在Rn中，至多有n个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为1，那么我们称它们是标准正交（orthonormal）。\n\n正交矩阵（orthogonal matrix）是指行向量和列向量是分别标准正交的方阵，更具体的，他们是满足以下条件的矩阵\n$$\nA^\\top A = A ^\\top A = I.\n$$\n这样意味着\n$$\nA^{-1} = A^\\top\n$$\n\n### 特征分解\n\n特征分解（eigendecomposition）是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值。\n\n方阵A的特征向量（eigenvector）是指与A相乘后相当于对该向量进行缩放的非零向量v：\n$$\nA v = \\lambda v\n$$\n标量$\\lambda$被称为这个特征向量对应的特征值（eigenvalue）。\n\n（类似地，我们也可以定义左特征向量（left eigenvector）$$v^⊤A=\\lambda v^⊤$$，但是通常我们更关注右特征向量（right eigenvector））。\n\n所有特征值都是正数的矩阵被称为正定（positive definite）；所有特征值都是非负数的矩阵被称为半正定（positive semidefinite）。同样地，所有特征值都是负数的矩阵被称为负定（negative definite）；所有特征值都是非正数的矩阵被称为半负定（negative semidefinite）。\n\n然而，我们也常常希望将矩阵分解（decompose）成特征值和特征向量。这样可以帮助我们分析矩阵的特定性质，就像质因数分解有助于我们理解整数。\n\n矩阵A的特征分解可以记作\n$$\nA = V diag(\\lambda) V^{-1}\n$$\n不是每一个矩阵都可以分解成特征值和特征向量。在某些情况下，特征分解存在，但是会涉及复数而非实数。\n\n其中Q是A的特征向量组成的正交矩阵，是对角矩阵。特征值$$\\lambda_{i;i}$$对应的特征向量是矩阵Q的第i列，记作Q:;i。因为Q是正交矩阵，我们可以将A看作沿方向v(i)延展i倍的空间","slug":"special_subject/MindSpore/Chapters/Concept","published":1,"updated":"2024-08-16T08:58:46.139Z","_id":"clzwh7ba700212wwvgo593hks","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"初等概念名词解释\">初等概念名词解释</h1>\r\n<p>在接近学完初级的机器学习后，我意识到单纯的看MindSpore文档以及看Youtube视频是远远不够的，我必须系统的学习一些概念知识以避免在后面的学习中云里雾里，故就有了这一章，在这一章中几乎全是对概念的解释，他们的来源广泛，传送门我都会贴在此处，供查阅：</p>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE3LzA3L25ldXJhbC1uZXR3b3JrLmh0bWw=\">神经网络入门\r\n- 阮一峰的网络日志 (ruanyifeng.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>https://github.com/exacity/deeplearningbook-chinese</p>\r\n</blockquote>\r\n<span id=\"more\"></span>\r\n<h2 id=\"感知机perceptron\">感知机（Perceptron）</h2>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/bkVr3Lymea1OAnw.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>​\r\n上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3...），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。</p>\r\n<p>​ 感知机是输出传入参数的一个函数变换，大多数情况下他是(最初涉及) <span\r\nclass=\"math display\">\\[\r\noutput = \\sigma(w_1*a_1 +\\cdots +w_n*a_n + b)\r\n\\]</span> 其中<span class=\"math display\">\\[\\sigma\r\n\\]</span>​函数表达式如下 <span class=\"math display\">\\[\r\nσ(z) = 1 / (1 + e^{-z})\r\n\\]</span></p>\r\n<h2 id=\"表示学习representation-learning\">表示学习（Representation\r\nLearning）</h2>\r\n<p>使用机器学习来发掘表示本身，而不仅仅把表示映射到输出,学习到的表示往往比手动设计的表示表现得更好。并且不需要人工干预就能迅速适应新的任务。</p>\r\n<h2 id=\"变差因素\">变差因素</h2>\r\n<p>在此背景下，‘‘因素’’这个词仅指代影响的不同来源；因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反，它们可能是现实世界中观察不到的物体或者不可观测的力，但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因，它们还可能以概念的形式存在于人类的思维中。</p>\r\n<p>它们可以被看作数据的概念或者抽象，帮助我们了解这些数据的丰富多样性。</p>\r\n<h2 id=\"可见层\">可见层</h2>\r\n<p>也就是神经网路的输入层，这样命名的原因是因为它包含我们能观察到的变量。</p>\r\n<h2 id=\"隐藏层\">隐藏层</h2>\r\n<p>也就是神经网路的中间层。因为它们的值不在数据中给出，所以将这些层称为‘‘隐藏”;模型必须确定哪些概念有利于解释观察数据中的关系。这里的图像是每个隐藏单元表示的特征的可视化。这里也是分形的思想运用的层次。</p>\r\n<h2 id=\"输出层\">输出层</h2>\r\n<p>输出神经网路的判断也称Object Identify</p>\r\n<h2 id=\"前馈深度网络\">前馈深度网络</h2>\r\n<h3 id=\"多层感知机multilayer-perceptron\">多层感知机（Multilayer\r\nPerceptron）</h3>\r\n<p>多层感知机仅仅是一个将一组输入值映射到输出值的数学函数。该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。</p>\r\n<h2 id=\"为什么需要使用非线性函数\">为什么需要使用非线性函数</h2>\r\n<p>这是由于线性模型的局限性，一个很经典的例子是，线性模型是无法学习异或函数的。</p>\r\n<h2 id=\"分布式表示\">分布式表示</h2>\r\n<p>其思想是：系统的每一个输入都应该由多个特征表示，并且每一个特征都应该参与到多个可能输入的表示。这显然也与神经网络每一层layer与layer之间的dense有关联</p>\r\n<h2 id=\"激活函数\">激活函数</h2>\r\n<h2 id=\"损失函数\">损失函数</h2>\r\n<h2 id=\"梯度下降\">梯度下降</h2>\r\n<h2 id=\"正则化\">正则化</h2>\r\n<h2 id=\"过拟合\">过拟合</h2>\r\n<h2 id=\"线性代数\">线性代数</h2>\r\n<h3 id=\"主对角线\">主对角线</h3>\r\n<p>即满足<span class=\"math display\">\\[a =\r\n\\{a_{i,j}|i=j\\}\\]</span>的元素构成的线，特殊的<span\r\nclass=\"math display\">\\[n\\not =m\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/7WA9zDuB2UYrlKF.png\"\r\nalt=\"image-20240609143044969\" />\r\n<figcaption aria-hidden=\"true\">image-20240609143044969</figcaption>\r\n</figure>\r\n<h3 id=\"转置\">转置</h3>\r\n<p>即矩阵对主对角线的镜像，特俗的有<span class=\"math display\">\\[n\\not =\r\nm\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/vtux96qNrkAH8jZ.png\"\r\nalt=\"image-20240609143213322\" />\r\n<figcaption aria-hidden=\"true\">image-20240609143213322</figcaption>\r\n</figure>\r\n<h3 id=\"元素对应乘积hadamard-乘积\">元素对应乘积（Hadamard 乘积）</h3>\r\n<p>记为<span class=\"math display\">\\[A\\odot B\\]</span></p>\r\n<h3 id=\"点积\">点积</h3>\r\n<p>两个相同维数的向量x和y的点积（dot product）可看作是矩阵乘积<span\r\nclass=\"math display\">\\[A^\\top\r\nB\\]</span>​。我们可以把矩阵乘积C=AB中计算Cij的步骤看作是A的第i行和B的第j列之间的点积。</p>\r\n<p>矩阵的乘法是不满足交换律的，但是矩阵的点积是满足的。 <span\r\nclass=\"math display\">\\[\r\nx^\\top y = y^\\top x\r\n\\]</span></p>\r\n<p>矩阵乘积转置的简单形式 <span class=\"math display\">\\[\r\n(AB)^\\top = B^\\top A^\\top\r\n\\]</span> 注意顺序是不能更改的因为矩阵乘法不满足交换律</p>\r\n<h3 id=\"单位矩阵\">单位矩阵</h3>\r\n<p>单位矩阵指主对角线上的值都为1，其他地方都为零的矩阵。</p>\r\n<p>我们将保持n维向量不变的单位矩阵记作<span\r\nclass=\"math display\">\\[I_n\\]</span>。</p>\r\n<h3 id=\"逆矩阵\">逆矩阵</h3>\r\n<p>很朴素的定义，需要注意的是由于矩阵乘法不满足交换律，因此我们再说一个矩阵的逆的时候通常是说矩阵的左逆。</p>\r\n<p>对于方阵而言，它的左逆和右逆是相等的</p>\r\n<h3 id=\"线性相关与生成子空间\">线性相关与生成子空间</h3>\r\n<p>如果逆矩阵<span\r\nclass=\"math display\">\\[A^{-1}\\]</span>​存在。那么式(2.11)肯定对于每一个向量b恰好存在一个解。但是，对于方程组而言，对于向量b的某些值，有可能不存在解，或者存在无限多个解。存在多于一个解但是少于无限多个解的情况是不可能发生的；因为如果x和y都是某方程组的解，则x,y则构成了一个张成空间。</p>\r\n<p>为了分析方程有多少个解，我们可以将A的列向量看作从原点（origin）（元素都是零的向量）出发的不同方向，确定有多少种方法可以到达向量b。在这个观点下，向量x中的每个元素表示我们应该沿着这些方向走多远，即xi表示我们需要沿着第i个向量的方向走多远：\r\n<span class=\"math display\">\\[\r\nAx = \\sum _i x_i A_{:,i}\r\n\\]</span>\r\n这样的操作我们称为线性组合。形式上，一组向量的线性组合是指每个向量乘以对应标量系数之后的和，即：\r\n<span class=\"math display\">\\[\r\n\\sum _i c_i v^{(i)}\r\n\\]</span>\r\n一组向量的生成子空间（span）是原始向量线性组合后所能抵达的点的集合。</p>\r\n<p>确定Ax=b是否有解相当于确定向量b是否在A列向量的生成子空间中。这个特殊的生成子空间被称为A的列空间（column\r\nspace）或者A的值域（range）。</p>\r\n<p>为了使方程Ax=b对于任意向量<span class=\"math display\">\\[b\\in\r\n\\mathbb{R}^m\\]</span>都存在解，我们要求A的列空间构成整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>。如果<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>中的某个点不在A的列空间中，那么该点对应的b会使得该方程没有解。矩阵A的列空间是整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>的要求，意味着A至少有m列，即n&gt;=m。否则，A列空间的维数会小于m。例如，假设A是一个<span\r\nclass=\"math display\">\\[3\\times\r\n2\\]</span>的矩阵。目标b是3维的，但是x只有2维。所以无论如何修改x的值，也只能描绘出<span\r\nclass=\"math display\">\\[\\mathbb{R}^3\\]</span>空间中的二维平面。当且仅当向量b在该二维平面中时，该方程有解。</p>\r\n<p>不等式n&gt;=m仅是方程对每一点都有解的必要条件。这不是一个充分条件，因为有些列向量可能是冗余的。假设有一个<span\r\nclass=\"math display\">\\[\\mathbb{R}^{2\\times2}\\]</span>中的矩阵，它的两个列向量是相同的。那么它的列空间和它的一个列向量作为矩阵的列空间是一样的。换言之，虽然该矩阵有2列，但是它的列空间仍然只是一条线，不能涵盖整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^2\\]</span>空间。</p>\r\n<p>正式地说，这种冗余被称为线性相关（linear\r\ndependence）。如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为线性无关（linearly\r\nindependent）。如果某个向量是一组向量中某些向量的线性组合，那么我们将这个向量加入这组向量后不会增加这组向量的生成子空间。这意味着，如果一个矩阵的列空间涵盖整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>，那么该矩阵必须包含至少一组m个线性无关的向量。这是对于每一个向量b的取值都有解的充分必要条件。值得注意的是，这个条件是说该向量集恰好有m个线性无关的列向量，而不是至少m个。不存在一个m维向量的集合具有多于m个彼此线性不相关的列向量，但是一个有多于m个列向量的矩阵有可能拥有不止一个大小为m的线性无关向量集。</p>\r\n<p>要想使矩阵可逆，我们还需要保证对于每一个b值至多有一个解。为此，我们需要确保该矩阵至多有m个列向量。否则，该方程会有不止一个解。</p>\r\n<h3 id=\"奇异矩阵singular-square\">奇异矩阵（singular square）</h3>\r\n<p>该矩阵必须是一个方阵（square），即m=n，并且所有列向量都是线性无关的。一个列向量线性相关的方阵被称为奇异的（singular）。</p>\r\n<h3 id=\"矩阵右乘\">矩阵右乘</h3>\r\n<p><span class=\"math display\">\\[\r\nAA^{-1}=I\r\n\\]</span></p>\r\n<h3 id=\"范数norm\">范数（norm）</h3>\r\n<p>用来衡量一个向量的大小。机器学习中常用范数衡量向量大小。形式上<span\r\nclass=\"math display\">\\[L^p\\]</span>定义如下 <span\r\nclass=\"math display\">\\[\r\n||x||_p = \\left( \\sum _i |x_i|^p \\right) ^{\\frac{1}{p}}\r\n\\]</span> 范数（包括Lp范数）是将向量映射到非负值的函数</p>\r\n<p>严格的讲，范数是满足以下性质的函数</p>\r\n<ul>\r\n<li>f(x) = 0 =&gt; x=0</li>\r\n<li>f(x+y) &lt;=f(x) + f(y) （三角不等式）</li>\r\n<li>对<span class=\"math display\">\\[\\forall \\alpha \\in\r\n\\mathbb{R},f(\\alpha x) = |\\alpha|f(x)\\]</span></li>\r\n</ul>\r\n<p>当p= 2时，<span\r\nclass=\"math display\">\\[L^2\\]</span>范数被称为欧几里得范数（Euclidean\r\nnorm）。它表示从原点出发到向量x确定的点的欧几里得距离。<span\r\nclass=\"math display\">\\[L^2\\]</span>范数在机器学习中出现地十分频繁，经常简化表示为∥x∥，略去了下标2。平方<span\r\nclass=\"math display\">\\[L^2\\]</span>范数也经常用来衡量向量的大小，可以简单地通过点积<span\r\nclass=\"math display\">\\[x ^\\top x\\]</span>计算。</p>\r\n<p>但是在很多情况下，平方<span\r\nclass=\"math display\">\\[L^2\\]</span>范数也可能不受欢迎，因为它在原点附近增长得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数：<span\r\nclass=\"math display\">\\[L^1\\]</span>范数。<span\r\nclass=\"math display\">\\[L^1\\]</span>范数可以简化如下： <span\r\nclass=\"math display\">\\[\r\n||x||_1 = \\sum _i |x_i|\r\n\\]</span>\r\n有时候我们会统计向量中非零元素的个数来衡量向量的大小。有些作者将这种函数称为“<span\r\nclass=\"math display\">\\[L^0\\]</span>范数’’，但是这个术语在数学意义上是不对的</p>\r\n<p>另外一个经常在机器学习中出现的范数是<span\r\nclass=\"math display\">\\[L^\\inf\\]</span>范数，也被称为最大范数（maxnorm）。这个范数表示向量中具有最大幅值的元素的绝对值：\r\n<span class=\"math display\">\\[\r\n||x||_1 = \\max _i |x_i|\r\n\\]</span>\r\n有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用Frobenius范数（Frobenius\r\nnorm）， <span class=\"math display\">\\[\r\n||A||_F = \\sqrt{\\sum _{i,j} A^2_{i,j}}\r\n\\]</span> 两个向量的点集可以用范数来表示，具体的 <span\r\nclass=\"math display\">\\[\r\nx^\\top y = ||x||_2 ||y||_2 cos\\theta\r\n\\]</span> <span\r\nclass=\"math display\">\\[\\theta\\]</span>表示x,y之间的夹角</p>\r\n<h3 id=\"对角矩阵\">对角矩阵</h3>\r\n<p>只在主对角线上含有非零元素，，其他位置都是零。用diag(<span\r\nclass=\"math display\">\\[v\\]</span>)表示一个对角矩阵。</p>\r\n<p>计算乘法diag(v)x，我们只需要将x中的每个元素xi放大vi倍。换言之，diag(v)x=v⊙x</p>\r\n<p>对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，在这种情况下，diag(v)1=diag([1/v1;....\r\n;1/vn]⊤)。</p>\r\n<p>非方阵的对角矩阵没有逆矩阵</p>\r\n<h3 id=\"对称矩阵\">对称矩阵</h3>\r\n<p>对称矩阵是矩阵的转置和自己相等的矩阵 <span class=\"math display\">\\[\r\nA = A ^\\top\r\n\\]</span></p>\r\n<h3 id=\"单位矩阵-1\">单位矩阵</h3>\r\n<p>具有单位范数的矩阵</p>\r\n<p>如果<span class=\"math display\">\\[x^\\top\r\ny=0\\]</span>，那么向量x和向量y互相正交（orthogonal）。如果两个向量都有非零范数，那么这两个向量之间的夹角是90度。在Rn中，至多有n个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为1，那么我们称它们是标准正交（orthonormal）。</p>\r\n<p>正交矩阵（orthogonal\r\nmatrix）是指行向量和列向量是分别标准正交的方阵，更具体的，他们是满足以下条件的矩阵\r\n<span class=\"math display\">\\[\r\nA^\\top A = A ^\\top A = I.\r\n\\]</span> 这样意味着 <span class=\"math display\">\\[\r\nA^{-1} = A^\\top\r\n\\]</span></p>\r\n<h3 id=\"特征分解\">特征分解</h3>\r\n<p>特征分解（eigendecomposition）是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值。</p>\r\n<p>方阵A的特征向量（eigenvector）是指与A相乘后相当于对该向量进行缩放的非零向量v：\r\n<span class=\"math display\">\\[\r\nA v = \\lambda v\r\n\\]</span> 标量<span\r\nclass=\"math inline\">\\(\\lambda\\)</span>被称为这个特征向量对应的特征值（eigenvalue）。</p>\r\n<p>（类似地，我们也可以定义左特征向量（left eigenvector）<span\r\nclass=\"math display\">\\[v^⊤A=\\lambda\r\nv^⊤\\]</span>，但是通常我们更关注右特征向量（right eigenvector））。</p>\r\n<p>所有特征值都是正数的矩阵被称为正定（positive\r\ndefinite）；所有特征值都是非负数的矩阵被称为半正定（positive\r\nsemidefinite）。同样地，所有特征值都是负数的矩阵被称为负定（negative\r\ndefinite）；所有特征值都是非正数的矩阵被称为半负定（negative\r\nsemidefinite）。</p>\r\n<p>然而，我们也常常希望将矩阵分解（decompose）成特征值和特征向量。这样可以帮助我们分析矩阵的特定性质，就像质因数分解有助于我们理解整数。</p>\r\n<p>矩阵A的特征分解可以记作 <span class=\"math display\">\\[\r\nA = V diag(\\lambda) V^{-1}\r\n\\]</span>\r\n不是每一个矩阵都可以分解成特征值和特征向量。在某些情况下，特征分解存在，但是会涉及复数而非实数。</p>\r\n<p>其中Q是A的特征向量组成的正交矩阵，是对角矩阵。特征值<span\r\nclass=\"math display\">\\[\\lambda_{i;i}\\]</span>对应的特征向量是矩阵Q的第i列，记作Q:;i。因为Q是正交矩阵，我们可以将A看作沿方向v(i)延展i倍的空间</p>\r\n","length":3525,"excerpt":"<h1 id=\"初等概念名词解释\">初等概念名词解释</h1>\r\n<p>在接近学完初级的机器学习后，我意识到单纯的看MindSpore文档以及看Youtube视频是远远不够的，我必须系统的学习一些概念知识以避免在后面的学习中云里雾里，故就有了这一章，在这一章中几乎全是对概念的解释，他们的来源广泛，传送门我都会贴在此处，供查阅：</p>\r\n<blockquote>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE3LzA3L25ldXJhbC1uZXR3b3JrLmh0bWw=\">神经网络入门\r\n- 阮一峰的网络日志 (ruanyifeng.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>https://github.com/exacity/deeplearningbook-chinese</p>\r\n</blockquote>","more":"<h2 id=\"感知机perceptron\">感知机（Perceptron）</h2>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/bkVr3Lymea1OAnw.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>​\r\n上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3...），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。</p>\r\n<p>​ 感知机是输出传入参数的一个函数变换，大多数情况下他是(最初涉及) <span\r\nclass=\"math display\">\\[\r\noutput = \\sigma(w_1*a_1 +\\cdots +w_n*a_n + b)\r\n\\]</span> 其中<span class=\"math display\">\\[\\sigma\r\n\\]</span>​函数表达式如下 <span class=\"math display\">\\[\r\nσ(z) = 1 / (1 + e^{-z})\r\n\\]</span></p>\r\n<h2 id=\"表示学习representation-learning\">表示学习（Representation\r\nLearning）</h2>\r\n<p>使用机器学习来发掘表示本身，而不仅仅把表示映射到输出,学习到的表示往往比手动设计的表示表现得更好。并且不需要人工干预就能迅速适应新的任务。</p>\r\n<h2 id=\"变差因素\">变差因素</h2>\r\n<p>在此背景下，‘‘因素’’这个词仅指代影响的不同来源；因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反，它们可能是现实世界中观察不到的物体或者不可观测的力，但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因，它们还可能以概念的形式存在于人类的思维中。</p>\r\n<p>它们可以被看作数据的概念或者抽象，帮助我们了解这些数据的丰富多样性。</p>\r\n<h2 id=\"可见层\">可见层</h2>\r\n<p>也就是神经网路的输入层，这样命名的原因是因为它包含我们能观察到的变量。</p>\r\n<h2 id=\"隐藏层\">隐藏层</h2>\r\n<p>也就是神经网路的中间层。因为它们的值不在数据中给出，所以将这些层称为‘‘隐藏”;模型必须确定哪些概念有利于解释观察数据中的关系。这里的图像是每个隐藏单元表示的特征的可视化。这里也是分形的思想运用的层次。</p>\r\n<h2 id=\"输出层\">输出层</h2>\r\n<p>输出神经网路的判断也称Object Identify</p>\r\n<h2 id=\"前馈深度网络\">前馈深度网络</h2>\r\n<h3 id=\"多层感知机multilayer-perceptron\">多层感知机（Multilayer\r\nPerceptron）</h3>\r\n<p>多层感知机仅仅是一个将一组输入值映射到输出值的数学函数。该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。</p>\r\n<h2 id=\"为什么需要使用非线性函数\">为什么需要使用非线性函数</h2>\r\n<p>这是由于线性模型的局限性，一个很经典的例子是，线性模型是无法学习异或函数的。</p>\r\n<h2 id=\"分布式表示\">分布式表示</h2>\r\n<p>其思想是：系统的每一个输入都应该由多个特征表示，并且每一个特征都应该参与到多个可能输入的表示。这显然也与神经网络每一层layer与layer之间的dense有关联</p>\r\n<h2 id=\"激活函数\">激活函数</h2>\r\n<h2 id=\"损失函数\">损失函数</h2>\r\n<h2 id=\"梯度下降\">梯度下降</h2>\r\n<h2 id=\"正则化\">正则化</h2>\r\n<h2 id=\"过拟合\">过拟合</h2>\r\n<h2 id=\"线性代数\">线性代数</h2>\r\n<h3 id=\"主对角线\">主对角线</h3>\r\n<p>即满足<span class=\"math display\">\\[a =\r\n\\{a_{i,j}|i=j\\}\\]</span>的元素构成的线，特殊的<span\r\nclass=\"math display\">\\[n\\not =m\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/7WA9zDuB2UYrlKF.png\"\r\nalt=\"image-20240609143044969\" />\r\n<figcaption aria-hidden=\"true\">image-20240609143044969</figcaption>\r\n</figure>\r\n<h3 id=\"转置\">转置</h3>\r\n<p>即矩阵对主对角线的镜像，特俗的有<span class=\"math display\">\\[n\\not =\r\nm\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/10/vtux96qNrkAH8jZ.png\"\r\nalt=\"image-20240609143213322\" />\r\n<figcaption aria-hidden=\"true\">image-20240609143213322</figcaption>\r\n</figure>\r\n<h3 id=\"元素对应乘积hadamard-乘积\">元素对应乘积（Hadamard 乘积）</h3>\r\n<p>记为<span class=\"math display\">\\[A\\odot B\\]</span></p>\r\n<h3 id=\"点积\">点积</h3>\r\n<p>两个相同维数的向量x和y的点积（dot product）可看作是矩阵乘积<span\r\nclass=\"math display\">\\[A^\\top\r\nB\\]</span>​。我们可以把矩阵乘积C=AB中计算Cij的步骤看作是A的第i行和B的第j列之间的点积。</p>\r\n<p>矩阵的乘法是不满足交换律的，但是矩阵的点积是满足的。 <span\r\nclass=\"math display\">\\[\r\nx^\\top y = y^\\top x\r\n\\]</span></p>\r\n<p>矩阵乘积转置的简单形式 <span class=\"math display\">\\[\r\n(AB)^\\top = B^\\top A^\\top\r\n\\]</span> 注意顺序是不能更改的因为矩阵乘法不满足交换律</p>\r\n<h3 id=\"单位矩阵\">单位矩阵</h3>\r\n<p>单位矩阵指主对角线上的值都为1，其他地方都为零的矩阵。</p>\r\n<p>我们将保持n维向量不变的单位矩阵记作<span\r\nclass=\"math display\">\\[I_n\\]</span>。</p>\r\n<h3 id=\"逆矩阵\">逆矩阵</h3>\r\n<p>很朴素的定义，需要注意的是由于矩阵乘法不满足交换律，因此我们再说一个矩阵的逆的时候通常是说矩阵的左逆。</p>\r\n<p>对于方阵而言，它的左逆和右逆是相等的</p>\r\n<h3 id=\"线性相关与生成子空间\">线性相关与生成子空间</h3>\r\n<p>如果逆矩阵<span\r\nclass=\"math display\">\\[A^{-1}\\]</span>​存在。那么式(2.11)肯定对于每一个向量b恰好存在一个解。但是，对于方程组而言，对于向量b的某些值，有可能不存在解，或者存在无限多个解。存在多于一个解但是少于无限多个解的情况是不可能发生的；因为如果x和y都是某方程组的解，则x,y则构成了一个张成空间。</p>\r\n<p>为了分析方程有多少个解，我们可以将A的列向量看作从原点（origin）（元素都是零的向量）出发的不同方向，确定有多少种方法可以到达向量b。在这个观点下，向量x中的每个元素表示我们应该沿着这些方向走多远，即xi表示我们需要沿着第i个向量的方向走多远：\r\n<span class=\"math display\">\\[\r\nAx = \\sum _i x_i A_{:,i}\r\n\\]</span>\r\n这样的操作我们称为线性组合。形式上，一组向量的线性组合是指每个向量乘以对应标量系数之后的和，即：\r\n<span class=\"math display\">\\[\r\n\\sum _i c_i v^{(i)}\r\n\\]</span>\r\n一组向量的生成子空间（span）是原始向量线性组合后所能抵达的点的集合。</p>\r\n<p>确定Ax=b是否有解相当于确定向量b是否在A列向量的生成子空间中。这个特殊的生成子空间被称为A的列空间（column\r\nspace）或者A的值域（range）。</p>\r\n<p>为了使方程Ax=b对于任意向量<span class=\"math display\">\\[b\\in\r\n\\mathbb{R}^m\\]</span>都存在解，我们要求A的列空间构成整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>。如果<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>中的某个点不在A的列空间中，那么该点对应的b会使得该方程没有解。矩阵A的列空间是整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>的要求，意味着A至少有m列，即n&gt;=m。否则，A列空间的维数会小于m。例如，假设A是一个<span\r\nclass=\"math display\">\\[3\\times\r\n2\\]</span>的矩阵。目标b是3维的，但是x只有2维。所以无论如何修改x的值，也只能描绘出<span\r\nclass=\"math display\">\\[\\mathbb{R}^3\\]</span>空间中的二维平面。当且仅当向量b在该二维平面中时，该方程有解。</p>\r\n<p>不等式n&gt;=m仅是方程对每一点都有解的必要条件。这不是一个充分条件，因为有些列向量可能是冗余的。假设有一个<span\r\nclass=\"math display\">\\[\\mathbb{R}^{2\\times2}\\]</span>中的矩阵，它的两个列向量是相同的。那么它的列空间和它的一个列向量作为矩阵的列空间是一样的。换言之，虽然该矩阵有2列，但是它的列空间仍然只是一条线，不能涵盖整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^2\\]</span>空间。</p>\r\n<p>正式地说，这种冗余被称为线性相关（linear\r\ndependence）。如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为线性无关（linearly\r\nindependent）。如果某个向量是一组向量中某些向量的线性组合，那么我们将这个向量加入这组向量后不会增加这组向量的生成子空间。这意味着，如果一个矩阵的列空间涵盖整个<span\r\nclass=\"math display\">\\[\\mathbb{R}^m\\]</span>，那么该矩阵必须包含至少一组m个线性无关的向量。这是对于每一个向量b的取值都有解的充分必要条件。值得注意的是，这个条件是说该向量集恰好有m个线性无关的列向量，而不是至少m个。不存在一个m维向量的集合具有多于m个彼此线性不相关的列向量，但是一个有多于m个列向量的矩阵有可能拥有不止一个大小为m的线性无关向量集。</p>\r\n<p>要想使矩阵可逆，我们还需要保证对于每一个b值至多有一个解。为此，我们需要确保该矩阵至多有m个列向量。否则，该方程会有不止一个解。</p>\r\n<h3 id=\"奇异矩阵singular-square\">奇异矩阵（singular square）</h3>\r\n<p>该矩阵必须是一个方阵（square），即m=n，并且所有列向量都是线性无关的。一个列向量线性相关的方阵被称为奇异的（singular）。</p>\r\n<h3 id=\"矩阵右乘\">矩阵右乘</h3>\r\n<p><span class=\"math display\">\\[\r\nAA^{-1}=I\r\n\\]</span></p>\r\n<h3 id=\"范数norm\">范数（norm）</h3>\r\n<p>用来衡量一个向量的大小。机器学习中常用范数衡量向量大小。形式上<span\r\nclass=\"math display\">\\[L^p\\]</span>定义如下 <span\r\nclass=\"math display\">\\[\r\n||x||_p = \\left( \\sum _i |x_i|^p \\right) ^{\\frac{1}{p}}\r\n\\]</span> 范数（包括Lp范数）是将向量映射到非负值的函数</p>\r\n<p>严格的讲，范数是满足以下性质的函数</p>\r\n<ul>\r\n<li>f(x) = 0 =&gt; x=0</li>\r\n<li>f(x+y) &lt;=f(x) + f(y) （三角不等式）</li>\r\n<li>对<span class=\"math display\">\\[\\forall \\alpha \\in\r\n\\mathbb{R},f(\\alpha x) = |\\alpha|f(x)\\]</span></li>\r\n</ul>\r\n<p>当p= 2时，<span\r\nclass=\"math display\">\\[L^2\\]</span>范数被称为欧几里得范数（Euclidean\r\nnorm）。它表示从原点出发到向量x确定的点的欧几里得距离。<span\r\nclass=\"math display\">\\[L^2\\]</span>范数在机器学习中出现地十分频繁，经常简化表示为∥x∥，略去了下标2。平方<span\r\nclass=\"math display\">\\[L^2\\]</span>范数也经常用来衡量向量的大小，可以简单地通过点积<span\r\nclass=\"math display\">\\[x ^\\top x\\]</span>计算。</p>\r\n<p>但是在很多情况下，平方<span\r\nclass=\"math display\">\\[L^2\\]</span>范数也可能不受欢迎，因为它在原点附近增长得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数：<span\r\nclass=\"math display\">\\[L^1\\]</span>范数。<span\r\nclass=\"math display\">\\[L^1\\]</span>范数可以简化如下： <span\r\nclass=\"math display\">\\[\r\n||x||_1 = \\sum _i |x_i|\r\n\\]</span>\r\n有时候我们会统计向量中非零元素的个数来衡量向量的大小。有些作者将这种函数称为“<span\r\nclass=\"math display\">\\[L^0\\]</span>范数’’，但是这个术语在数学意义上是不对的</p>\r\n<p>另外一个经常在机器学习中出现的范数是<span\r\nclass=\"math display\">\\[L^\\inf\\]</span>范数，也被称为最大范数（maxnorm）。这个范数表示向量中具有最大幅值的元素的绝对值：\r\n<span class=\"math display\">\\[\r\n||x||_1 = \\max _i |x_i|\r\n\\]</span>\r\n有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用Frobenius范数（Frobenius\r\nnorm）， <span class=\"math display\">\\[\r\n||A||_F = \\sqrt{\\sum _{i,j} A^2_{i,j}}\r\n\\]</span> 两个向量的点集可以用范数来表示，具体的 <span\r\nclass=\"math display\">\\[\r\nx^\\top y = ||x||_2 ||y||_2 cos\\theta\r\n\\]</span> <span\r\nclass=\"math display\">\\[\\theta\\]</span>表示x,y之间的夹角</p>\r\n<h3 id=\"对角矩阵\">对角矩阵</h3>\r\n<p>只在主对角线上含有非零元素，，其他位置都是零。用diag(<span\r\nclass=\"math display\">\\[v\\]</span>)表示一个对角矩阵。</p>\r\n<p>计算乘法diag(v)x，我们只需要将x中的每个元素xi放大vi倍。换言之，diag(v)x=v⊙x</p>\r\n<p>对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，在这种情况下，diag(v)1=diag([1/v1;....\r\n;1/vn]⊤)。</p>\r\n<p>非方阵的对角矩阵没有逆矩阵</p>\r\n<h3 id=\"对称矩阵\">对称矩阵</h3>\r\n<p>对称矩阵是矩阵的转置和自己相等的矩阵 <span class=\"math display\">\\[\r\nA = A ^\\top\r\n\\]</span></p>\r\n<h3 id=\"单位矩阵-1\">单位矩阵</h3>\r\n<p>具有单位范数的矩阵</p>\r\n<p>如果<span class=\"math display\">\\[x^\\top\r\ny=0\\]</span>，那么向量x和向量y互相正交（orthogonal）。如果两个向量都有非零范数，那么这两个向量之间的夹角是90度。在Rn中，至多有n个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为1，那么我们称它们是标准正交（orthonormal）。</p>\r\n<p>正交矩阵（orthogonal\r\nmatrix）是指行向量和列向量是分别标准正交的方阵，更具体的，他们是满足以下条件的矩阵\r\n<span class=\"math display\">\\[\r\nA^\\top A = A ^\\top A = I.\r\n\\]</span> 这样意味着 <span class=\"math display\">\\[\r\nA^{-1} = A^\\top\r\n\\]</span></p>\r\n<h3 id=\"特征分解\">特征分解</h3>\r\n<p>特征分解（eigendecomposition）是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值。</p>\r\n<p>方阵A的特征向量（eigenvector）是指与A相乘后相当于对该向量进行缩放的非零向量v：\r\n<span class=\"math display\">\\[\r\nA v = \\lambda v\r\n\\]</span> 标量<span\r\nclass=\"math inline\">\\(\\lambda\\)</span>被称为这个特征向量对应的特征值（eigenvalue）。</p>\r\n<p>（类似地，我们也可以定义左特征向量（left eigenvector）<span\r\nclass=\"math display\">\\[v^⊤A=\\lambda\r\nv^⊤\\]</span>，但是通常我们更关注右特征向量（right eigenvector））。</p>\r\n<p>所有特征值都是正数的矩阵被称为正定（positive\r\ndefinite）；所有特征值都是非负数的矩阵被称为半正定（positive\r\nsemidefinite）。同样地，所有特征值都是负数的矩阵被称为负定（negative\r\ndefinite）；所有特征值都是非正数的矩阵被称为半负定（negative\r\nsemidefinite）。</p>\r\n<p>然而，我们也常常希望将矩阵分解（decompose）成特征值和特征向量。这样可以帮助我们分析矩阵的特定性质，就像质因数分解有助于我们理解整数。</p>\r\n<p>矩阵A的特征分解可以记作 <span class=\"math display\">\\[\r\nA = V diag(\\lambda) V^{-1}\r\n\\]</span>\r\n不是每一个矩阵都可以分解成特征值和特征向量。在某些情况下，特征分解存在，但是会涉及复数而非实数。</p>\r\n<p>其中Q是A的特征向量组成的正交矩阵，是对角矩阵。特征值<span\r\nclass=\"math display\">\\[\\lambda_{i;i}\\]</span>对应的特征向量是矩阵Q的第i列，记作Q:;i。因为Q是正交矩阵，我们可以将A看作沿方向v(i)延展i倍的空间</p>"},{"title":"MindSpore专题——第一章、安装","date":"2024-08-14T11:47:58.000Z","_content":"## Ubuntu系统安装\n\n### 环境\n\n VMware Workstation 17Pro\n\n1. 原有的系统为Ubuntu22.04因此下载Ubuntu18.04 镜像光盘文件\n   -  通过cat /proc/version文件查看当前的系统版本\n\n<!--more-->\n\n![image-20240604174857507](https://s2.loli.net/2024/06/04/9tNsqxUkrJFHQOc.png)\n\n2. 下载Ubuntu18.04系统光盘https://releases.ubuntu.com/18.04/ubuntu-18.04.6-desktop-amd64.iso\n\n3. VMware简易安装后对18旧版本遇到的问题的解决方案\n   1. 旧版本屏幕无法适应屏幕，想到vmwaretools的问题，检查该部分发现并未自动安装\n\n通过重新启动挂载\\VMware\\VMware Workstation目录下linux.iso文件出现\n\n![image-20240604182654391](https://s2.loli.net/2024/06/06/IWioHYeLj9JgMtb.png)\n\n安装该软件\n\n![image-20240604182901358](https://s2.loli.net/2024/06/04/vIXUHlWVx2sb1co.png)\n\n```shell\nsudo perl vmware-install.pl\n```\n\n通过在解压的目录下运行该脚本文件安装vmware-tools\n\n![image-20240604183315457](https://s2.loli.net/2024/06/04/pJI4WAgKdYmvPES.png)\n\n在经过一系列configure后安装完成\n\n由此问题解决\n\n \t2. update apt-get\n\n```shell\nsudo update apt-get\n```\n\n\n\n![image-20240604184437693](https://s2.loli.net/2024/06/04/9cXhEq3V2DMiWNx.png)\n\n3. 修复vmware剪贴板不共享的问题\n\n```shell\nsudo apt-get install open-vm-tools-desktop\n```\n\n​\t安装该软件一路回车即可\n\n## 尝试自动脚本安装\n\n由于vmware对nvdia的支持补全，此处采用版本如下\n\n![image-20240604183528425](https://s2.loli.net/2024/06/04/5e3IG9tuAPdfjKr.png)\n\n进入默认源码目录进行操作\n\n![image-20240604183616489](https://s2.loli.net/2024/06/04/K8tqnFmeQuOMiZc.png)\n\n![image-20240604185144770](https://s2.loli.net/2024/06/04/d1YgnqUjbWJfXLH.png)\n\n由于系统全新，设定一下系统密码并切换到root用户\n\n![image-20240604185341858](https://s2.loli.net/2024/06/04/KQiWzJtOUsS2mnT.png)\n\n根据官网下载\n\n![image-20240604185417980](https://s2.loli.net/2024/06/04/g3BCMVGQHDzjAUL.png)\n\n根据官网命令执行脚本\n\n![MindSpore安装成功](https://s2.loli.net/2024/06/05/xBlJgjPwU3krsqa.png)\n\n可见安装成功\n\n## Windows中安装MindSpore以及杂项\n\n1. 相似的安装程序，记得更改选定的官方安装脚本\n2. Windows一般位于C:\\Users\\%USERNAME%\\pip 目录下存在配置文件，可通过更改该配置文件修改镜像，在使用镜像中启用代理可能会导致满屏的飘红报错\n3. 对于MindSpore的前置软件安装而言，最重要易错的为Python的版本，建议多通过\n\n```shell\npython --version\n```\n4. 查看当前版本，及时正确配置环境变量","source":"_posts/special_subject/MindSpore/Chapters/First_Install.md","raw":"---\ntitle: MindSpore专题——第一章、安装\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## Ubuntu系统安装\n\n### 环境\n\n VMware Workstation 17Pro\n\n1. 原有的系统为Ubuntu22.04因此下载Ubuntu18.04 镜像光盘文件\n   -  通过cat /proc/version文件查看当前的系统版本\n\n<!--more-->\n\n![image-20240604174857507](https://s2.loli.net/2024/06/04/9tNsqxUkrJFHQOc.png)\n\n2. 下载Ubuntu18.04系统光盘https://releases.ubuntu.com/18.04/ubuntu-18.04.6-desktop-amd64.iso\n\n3. VMware简易安装后对18旧版本遇到的问题的解决方案\n   1. 旧版本屏幕无法适应屏幕，想到vmwaretools的问题，检查该部分发现并未自动安装\n\n通过重新启动挂载\\VMware\\VMware Workstation目录下linux.iso文件出现\n\n![image-20240604182654391](https://s2.loli.net/2024/06/06/IWioHYeLj9JgMtb.png)\n\n安装该软件\n\n![image-20240604182901358](https://s2.loli.net/2024/06/04/vIXUHlWVx2sb1co.png)\n\n```shell\nsudo perl vmware-install.pl\n```\n\n通过在解压的目录下运行该脚本文件安装vmware-tools\n\n![image-20240604183315457](https://s2.loli.net/2024/06/04/pJI4WAgKdYmvPES.png)\n\n在经过一系列configure后安装完成\n\n由此问题解决\n\n \t2. update apt-get\n\n```shell\nsudo update apt-get\n```\n\n\n\n![image-20240604184437693](https://s2.loli.net/2024/06/04/9cXhEq3V2DMiWNx.png)\n\n3. 修复vmware剪贴板不共享的问题\n\n```shell\nsudo apt-get install open-vm-tools-desktop\n```\n\n​\t安装该软件一路回车即可\n\n## 尝试自动脚本安装\n\n由于vmware对nvdia的支持补全，此处采用版本如下\n\n![image-20240604183528425](https://s2.loli.net/2024/06/04/5e3IG9tuAPdfjKr.png)\n\n进入默认源码目录进行操作\n\n![image-20240604183616489](https://s2.loli.net/2024/06/04/K8tqnFmeQuOMiZc.png)\n\n![image-20240604185144770](https://s2.loli.net/2024/06/04/d1YgnqUjbWJfXLH.png)\n\n由于系统全新，设定一下系统密码并切换到root用户\n\n![image-20240604185341858](https://s2.loli.net/2024/06/04/KQiWzJtOUsS2mnT.png)\n\n根据官网下载\n\n![image-20240604185417980](https://s2.loli.net/2024/06/04/g3BCMVGQHDzjAUL.png)\n\n根据官网命令执行脚本\n\n![MindSpore安装成功](https://s2.loli.net/2024/06/05/xBlJgjPwU3krsqa.png)\n\n可见安装成功\n\n## Windows中安装MindSpore以及杂项\n\n1. 相似的安装程序，记得更改选定的官方安装脚本\n2. Windows一般位于C:\\Users\\%USERNAME%\\pip 目录下存在配置文件，可通过更改该配置文件修改镜像，在使用镜像中启用代理可能会导致满屏的飘红报错\n3. 对于MindSpore的前置软件安装而言，最重要易错的为Python的版本，建议多通过\n\n```shell\npython --version\n```\n4. 查看当前版本，及时正确配置环境变量","slug":"special_subject/MindSpore/Chapters/First_Install","published":1,"updated":"2024-08-16T08:58:49.871Z","_id":"clzwh7ba700242wwvaaf2bver","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"ubuntu系统安装\">Ubuntu系统安装</h2>\r\n<h3 id=\"环境\">环境</h3>\r\n<p>VMware Workstation 17Pro</p>\r\n<ol type=\"1\">\r\n<li>原有的系统为Ubuntu22.04因此下载Ubuntu18.04 镜像光盘文件\r\n<ul>\r\n<li>通过cat /proc/version文件查看当前的系统版本</li>\r\n</ul></li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/9tNsqxUkrJFHQOc.png\"\r\nalt=\"image-20240604174857507\" />\r\n<figcaption aria-hidden=\"true\">image-20240604174857507</figcaption>\r\n</figure>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>下载Ubuntu18.04系统光盘https://releases.ubuntu.com/18.04/ubuntu-18.04.6-desktop-amd64.iso</p></li>\r\n<li><p>VMware简易安装后对18旧版本遇到的问题的解决方案</p>\r\n<ol type=\"1\">\r\n<li>旧版本屏幕无法适应屏幕，想到vmwaretools的问题，检查该部分发现并未自动安装</li>\r\n</ol></li>\r\n</ol>\r\n<p>通过重新启动挂载Workstation目录下linux.iso文件出现</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/IWioHYeLj9JgMtb.png\"\r\nalt=\"image-20240604182654391\" />\r\n<figcaption aria-hidden=\"true\">image-20240604182654391</figcaption>\r\n</figure>\r\n<p>安装该软件</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/vIXUHlWVx2sb1co.png\"\r\nalt=\"image-20240604182901358\" />\r\n<figcaption aria-hidden=\"true\">image-20240604182901358</figcaption>\r\n</figure>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo perl vmware-install.pl</span><br></pre></td></tr></table></figure>\r\n<p>通过在解压的目录下运行该脚本文件安装vmware-tools</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/pJI4WAgKdYmvPES.png\"\r\nalt=\"image-20240604183315457\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183315457</figcaption>\r\n</figure>\r\n<p>在经过一系列configure后安装完成</p>\r\n<p>由此问题解决</p>\r\n<pre><code>2. update apt-get</code></pre>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo update apt-get</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/9cXhEq3V2DMiWNx.png\"\r\nalt=\"image-20240604184437693\" />\r\n<figcaption aria-hidden=\"true\">image-20240604184437693</figcaption>\r\n</figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li>修复vmware剪贴板不共享的问题</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>\r\n<p>​ 安装该软件一路回车即可</p>\r\n<h2 id=\"尝试自动脚本安装\">尝试自动脚本安装</h2>\r\n<p>由于vmware对nvdia的支持补全，此处采用版本如下</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/5e3IG9tuAPdfjKr.png\"\r\nalt=\"image-20240604183528425\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183528425</figcaption>\r\n</figure>\r\n<p>进入默认源码目录进行操作</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/K8tqnFmeQuOMiZc.png\"\r\nalt=\"image-20240604183616489\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183616489</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/d1YgnqUjbWJfXLH.png\"\r\nalt=\"image-20240604185144770\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185144770</figcaption>\r\n</figure>\r\n<p>由于系统全新，设定一下系统密码并切换到root用户</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/KQiWzJtOUsS2mnT.png\"\r\nalt=\"image-20240604185341858\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185341858</figcaption>\r\n</figure>\r\n<p>根据官网下载</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/g3BCMVGQHDzjAUL.png\"\r\nalt=\"image-20240604185417980\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185417980</figcaption>\r\n</figure>\r\n<p>根据官网命令执行脚本</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/xBlJgjPwU3krsqa.png\"\r\nalt=\"MindSpore安装成功\" />\r\n<figcaption aria-hidden=\"true\">MindSpore安装成功</figcaption>\r\n</figure>\r\n<p>可见安装成功</p>\r\n<h2\r\nid=\"windows中安装mindspore以及杂项\">Windows中安装MindSpore以及杂项</h2>\r\n<ol type=\"1\">\r\n<li>相似的安装程序，记得更改选定的官方安装脚本</li>\r\n<li>Windows一般位于C:%USERNAME%目录下存在配置文件，可通过更改该配置文件修改镜像，在使用镜像中启用代理可能会导致满屏的飘红报错</li>\r\n<li>对于MindSpore的前置软件安装而言，最重要易错的为Python的版本，建议多通过</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python --version</span><br></pre></td></tr></table></figure>\r\n<ol start=\"4\" type=\"1\">\r\n<li>查看当前版本，及时正确配置环境变量</li>\r\n</ol>\r\n","length":464,"excerpt":"<h2 id=\"ubuntu系统安装\">Ubuntu系统安装</h2>\r\n<h3 id=\"环境\">环境</h3>\r\n<p>VMware Workstation 17Pro</p>\r\n<ol type=\"1\">\r\n<li>原有的系统为Ubuntu22.04因此下载Ubuntu18.04 镜像光盘文件\r\n<ul>\r\n<li>通过cat /proc/version文件查看当前的系统版本</li>\r\n</ul></li>\r\n</ol>","more":"<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/9tNsqxUkrJFHQOc.png\"\r\nalt=\"image-20240604174857507\" />\r\n<figcaption aria-hidden=\"true\">image-20240604174857507</figcaption>\r\n</figure>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>下载Ubuntu18.04系统光盘https://releases.ubuntu.com/18.04/ubuntu-18.04.6-desktop-amd64.iso</p></li>\r\n<li><p>VMware简易安装后对18旧版本遇到的问题的解决方案</p>\r\n<ol type=\"1\">\r\n<li>旧版本屏幕无法适应屏幕，想到vmwaretools的问题，检查该部分发现并未自动安装</li>\r\n</ol></li>\r\n</ol>\r\n<p>通过重新启动挂载Workstation目录下linux.iso文件出现</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/IWioHYeLj9JgMtb.png\"\r\nalt=\"image-20240604182654391\" />\r\n<figcaption aria-hidden=\"true\">image-20240604182654391</figcaption>\r\n</figure>\r\n<p>安装该软件</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/vIXUHlWVx2sb1co.png\"\r\nalt=\"image-20240604182901358\" />\r\n<figcaption aria-hidden=\"true\">image-20240604182901358</figcaption>\r\n</figure>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo perl vmware-install.pl</span><br></pre></td></tr></table></figure>\r\n<p>通过在解压的目录下运行该脚本文件安装vmware-tools</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/pJI4WAgKdYmvPES.png\"\r\nalt=\"image-20240604183315457\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183315457</figcaption>\r\n</figure>\r\n<p>在经过一系列configure后安装完成</p>\r\n<p>由此问题解决</p>\r\n<pre><code>2. update apt-get</code></pre>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo update apt-get</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/9cXhEq3V2DMiWNx.png\"\r\nalt=\"image-20240604184437693\" />\r\n<figcaption aria-hidden=\"true\">image-20240604184437693</figcaption>\r\n</figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li>修复vmware剪贴板不共享的问题</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>\r\n<p>​ 安装该软件一路回车即可</p>\r\n<h2 id=\"尝试自动脚本安装\">尝试自动脚本安装</h2>\r\n<p>由于vmware对nvdia的支持补全，此处采用版本如下</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/5e3IG9tuAPdfjKr.png\"\r\nalt=\"image-20240604183528425\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183528425</figcaption>\r\n</figure>\r\n<p>进入默认源码目录进行操作</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/K8tqnFmeQuOMiZc.png\"\r\nalt=\"image-20240604183616489\" />\r\n<figcaption aria-hidden=\"true\">image-20240604183616489</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/d1YgnqUjbWJfXLH.png\"\r\nalt=\"image-20240604185144770\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185144770</figcaption>\r\n</figure>\r\n<p>由于系统全新，设定一下系统密码并切换到root用户</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/KQiWzJtOUsS2mnT.png\"\r\nalt=\"image-20240604185341858\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185341858</figcaption>\r\n</figure>\r\n<p>根据官网下载</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/04/g3BCMVGQHDzjAUL.png\"\r\nalt=\"image-20240604185417980\" />\r\n<figcaption aria-hidden=\"true\">image-20240604185417980</figcaption>\r\n</figure>\r\n<p>根据官网命令执行脚本</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/xBlJgjPwU3krsqa.png\"\r\nalt=\"MindSpore安装成功\" />\r\n<figcaption aria-hidden=\"true\">MindSpore安装成功</figcaption>\r\n</figure>\r\n<p>可见安装成功</p>\r\n<h2\r\nid=\"windows中安装mindspore以及杂项\">Windows中安装MindSpore以及杂项</h2>\r\n<ol type=\"1\">\r\n<li>相似的安装程序，记得更改选定的官方安装脚本</li>\r\n<li>Windows一般位于C:%USERNAME%目录下存在配置文件，可通过更改该配置文件修改镜像，在使用镜像中启用代理可能会导致满屏的飘红报错</li>\r\n<li>对于MindSpore的前置软件安装而言，最重要易错的为Python的版本，建议多通过</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python --version</span><br></pre></td></tr></table></figure>\r\n<ol start=\"4\" type=\"1\">\r\n<li>查看当前版本，及时正确配置环境变量</li>\r\n</ol>"},{"title":"MindSpore专题——第四章、数据集","date":"2024-08-14T11:47:58.000Z","_content":"## 数据集\n\n继续[第二章](./Second_TryMindSpore.md)中的Mnist数据库为例，介绍使用mindspore.dataset进行加载的方法。\n\n详情请见MNIST数据官方网站：[MNIST handwritten digit database, Yann LeCun, Corinna Cortes and Chris Burges](http://yann.lecun.com/exdb/mnist/)\n\n<!--more-->\n\n下面是简略介绍\n\n|   数据集   |      MNIST中的文件名       |                          下载地址                           |  文件大小   |\n| :--------: | :------------------------: | :---------------------------------------------------------: | :---------: |\n| 训练集图像 | train-images-idx3-ubyte.gz | http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz | 9912422字节 |\n| 训练集标签 | train-labels-idx1-ubyte.gz | http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz |  28881字节  |\n| 测试集图像 | t10k-images-idx3-ubyte.gz  | http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz  | 1648877字节 |\n| 测试集标签 | t10k-labels-idx1-ubyte.gz  | http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz  |  4542字节   |\n\n\n\n### 数据库加载\n\n*请注意：mindspore.dataset的接口仅支持解压后的数据文件*\n\n```python\ntrain_dataset = MnistDataset(\"MNIST_Data/train\", shuffle=False)\nprint(type(train_dataset))\n```\n\n> <class 'mindspore.dataset.engine.datasets_vision.MnistDataset'>\n\n### 数据库迭代\n\n数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。我们可以用[create_tuple_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_tuple_iterator.html)或[create_dict_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_dict_iterator.html)接口创建数据迭代器，迭代访问数据。访问的数据类型默认为`Tensor`；若设置`output_numpy=True`，访问的数据类型为`Numpy`。\n\n下面定义一个可视化函数，迭代9张图片进行展示。\n\n```python\ndef visualize(dataset):\n    figure = plt.figure(figsize=(4, 4))\n    cols, rows = 3, 3\n\n    plt.subplots_adjust(wspace=0.5, hspace=0.5)\n\n    for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):\n        figure.add_subplot(rows, cols, idx + 1)\n        plt.title(int(label))\n        plt.axis(\"off\")\n        plt.imshow(image.asnumpy().squeeze(), cmap=\"gray\")\n        if idx == cols * rows - 1:\n            break\n    plt.show()\n```\n\n在`for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):`此处的循环中枚举了训练集的前9个图像`enumerate()`函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\n\n在循环体中使用了plt类画图。\n\n![image-20240606173353887](https://s2.loli.net/2024/06/06/36CU8spH9eSEkxl.png)\n\n### 数据集常用操作\n\nPipeline的设计理念使得数据集的常用操作采用`dataset = dataset.operation()`的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。\n\n下面分别介绍几种常见的数据集操作。\n\n### shuffle\n\n数据集随机`shuffle`可以消除数据排列造成的分布不均问题\n\n![op-shuffle](https://s2.loli.net/2024/06/06/M54ICySt9dzenva.png)\n\n`mindspore.dataset`提供的数据集在加载时可配置`shuffle=True`，或使用如下操作\n\n```python\ntrain_dataset = train_dataset.shuffle(buffer_size=64)\nvisualize(train_dataset)\n```\n\n![image-20240606173414784](https://s2.loli.net/2024/06/06/yB76TmklvtYXIgE.png)\n\n### map\n\n`map`操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。\n\n```python\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(\"map前：\")\nprint(image.shape, image.dtype)\ntrain_dataset = train_dataset.map(vision.Rescale(1.0 / 255.0, 0), input_columns='image')\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(\"map后：\")\nprint(image.shape, image.dtype)\n```\n\n> ```\n> map前：\n> (28, 28, 1) UInt8\n> map后：\n> (28, 28, 1) Float32\n> ```\n\n### batch\n\n将数据集打包为固定大小的`batch`是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。分块思想\n\n一般我们会设置一个固定的batch size，将连续的数据分为若干批（batch）。\n\n```python\n# 一般设定固定batchSize\ntrain_dataset = train_dataset.batch(batch_size=32)\n# batch后的数据增加一维，大小为batch_size\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(image.shape, image.dtype)\n```\n\n> (32, 28, 28, 1) Float32\n\n### 自定义数据集\n\n`mindspore.dataset`模块提供了一些常用的公开数据集和标准格式数据集的加载API。\n\n对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过`GeneratorDataset`接口实现自定义方式的数据集加载。\n\n`GeneratorDataset`支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。\n\n#### 可随机访问数据集\n\n可随机访问数据集是实现了`__getitem__`和`__len__`方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。\n\n1. 实现了` __init__`，`__getitem__ ` 和`__len__`\n2. 当使用`dataset[idx]`访问这样的数据集时，可以读取dataset内容中第idx个样本或标签\n\n```python\n# Random-accessible object as input source\nclass RandomAccessDataset:\n    def __init__(self):\n        self._data = np.ones((5, 2))\n        self._label = np.zeros((5, 1))\n\n    def __getitem__(self, index):\n        return self._data[index], self._label[index]\n\n    def __len__(self):\n        return len(self._data)\n\n\nloader = RandomAccessDataset()\ndataset = GeneratorDataset(source=loader, column_names=[\"data\", \"label\"])\n\nfor data in dataset:\n    print(data)\n    \nloader = [np.array(0), np.array(1), np.array(2)]\ndataset = GeneratorDataset(source=loader, column_names=[\"data\"])\n\nfor data in dataset:\n    print(data)\n\n```\n\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n\n创建的过程非常简单，通过numpy的数据结构为底层，实现三个方法就好了，更简单的直接使用list，tuple也是可行的。\n\n#### 可迭代数据集\n\n可迭代的数据集是实现了`__iter__`和`__next__`方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。\n\n例如，当使用`iter(dataset)`的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。\n\n下面构造一个简单迭代器，并将其加载至`GeneratorDataset`。\n\n```python\n# Iterator as input source\nclass IterableDataset():\n    def __init__(self, start, end):\n        '''init the class object to hold the data'''\n        self.start = start\n        self.end = end\n\n    def __next__(self):\n        '''iter one data and return'''\n        return next(self.data)\n\n    def __iter__(self):\n        '''reset the iter'''\n        self.data = iter(range(self.start, self.end))\n        return self\n\n\nloader = IterableDataset(1, 5)\ndataset = GeneratorDataset(source=loader, column_names=[\"data\"])\n\nfor d in dataset:\n    print(d)\n\n```\n\n> [Tensor(shape=[], dtype=Int32, value= 1)]\n> [Tensor(shape=[], dtype=Int32, value= 2)]\n> [Tensor(shape=[], dtype=Int32, value= 3)]\n> [Tensor(shape=[], dtype=Int32, value= 4)]\n\n同样的，实现方法即可\n\n#### 生成器\n\n生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型`generator`返回数据，直至生成器抛出`StopIteration`异常。\n\n下面构造一个生成器，并将其加载至`GeneratorDataset`。\n\n```python\n# Generator\ndef my_generator(start, end):\n    for i in range(start, end):\n        yield i\n\n\n# since a generator instance can be only iterated once, we need to wrap it by lambda to generate multiple instances\ndataset = GeneratorDataset(source=lambda: my_generator(3, 6), column_names=[\"data\"])\n\nfor d in dataset:\n    print(d)\n```\n\n>[Tensor(shape=[], dtype=Int32, value= 3)]\n>[Tensor(shape=[], dtype=Int32, value= 4)]\n>[Tensor(shape=[], dtype=Int32, value= 5)]\n\n这个更绝，仅用一个函数即可生成。（此处匿不匿名无关紧要）\n\n## 常见问题\n\n1. 找不到模块 matplotlib\n\n```shell\npip install matplotlib\n```\n\n","source":"_posts/special_subject/MindSpore/Chapters/Fourth_DataSet.md","raw":"---\ntitle: MindSpore专题——第四章、数据集\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## 数据集\n\n继续[第二章](./Second_TryMindSpore.md)中的Mnist数据库为例，介绍使用mindspore.dataset进行加载的方法。\n\n详情请见MNIST数据官方网站：[MNIST handwritten digit database, Yann LeCun, Corinna Cortes and Chris Burges](http://yann.lecun.com/exdb/mnist/)\n\n<!--more-->\n\n下面是简略介绍\n\n|   数据集   |      MNIST中的文件名       |                          下载地址                           |  文件大小   |\n| :--------: | :------------------------: | :---------------------------------------------------------: | :---------: |\n| 训练集图像 | train-images-idx3-ubyte.gz | http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz | 9912422字节 |\n| 训练集标签 | train-labels-idx1-ubyte.gz | http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz |  28881字节  |\n| 测试集图像 | t10k-images-idx3-ubyte.gz  | http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz  | 1648877字节 |\n| 测试集标签 | t10k-labels-idx1-ubyte.gz  | http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz  |  4542字节   |\n\n\n\n### 数据库加载\n\n*请注意：mindspore.dataset的接口仅支持解压后的数据文件*\n\n```python\ntrain_dataset = MnistDataset(\"MNIST_Data/train\", shuffle=False)\nprint(type(train_dataset))\n```\n\n> <class 'mindspore.dataset.engine.datasets_vision.MnistDataset'>\n\n### 数据库迭代\n\n数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。我们可以用[create_tuple_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_tuple_iterator.html)或[create_dict_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_dict_iterator.html)接口创建数据迭代器，迭代访问数据。访问的数据类型默认为`Tensor`；若设置`output_numpy=True`，访问的数据类型为`Numpy`。\n\n下面定义一个可视化函数，迭代9张图片进行展示。\n\n```python\ndef visualize(dataset):\n    figure = plt.figure(figsize=(4, 4))\n    cols, rows = 3, 3\n\n    plt.subplots_adjust(wspace=0.5, hspace=0.5)\n\n    for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):\n        figure.add_subplot(rows, cols, idx + 1)\n        plt.title(int(label))\n        plt.axis(\"off\")\n        plt.imshow(image.asnumpy().squeeze(), cmap=\"gray\")\n        if idx == cols * rows - 1:\n            break\n    plt.show()\n```\n\n在`for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):`此处的循环中枚举了训练集的前9个图像`enumerate()`函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\n\n在循环体中使用了plt类画图。\n\n![image-20240606173353887](https://s2.loli.net/2024/06/06/36CU8spH9eSEkxl.png)\n\n### 数据集常用操作\n\nPipeline的设计理念使得数据集的常用操作采用`dataset = dataset.operation()`的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。\n\n下面分别介绍几种常见的数据集操作。\n\n### shuffle\n\n数据集随机`shuffle`可以消除数据排列造成的分布不均问题\n\n![op-shuffle](https://s2.loli.net/2024/06/06/M54ICySt9dzenva.png)\n\n`mindspore.dataset`提供的数据集在加载时可配置`shuffle=True`，或使用如下操作\n\n```python\ntrain_dataset = train_dataset.shuffle(buffer_size=64)\nvisualize(train_dataset)\n```\n\n![image-20240606173414784](https://s2.loli.net/2024/06/06/yB76TmklvtYXIgE.png)\n\n### map\n\n`map`操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。\n\n```python\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(\"map前：\")\nprint(image.shape, image.dtype)\ntrain_dataset = train_dataset.map(vision.Rescale(1.0 / 255.0, 0), input_columns='image')\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(\"map后：\")\nprint(image.shape, image.dtype)\n```\n\n> ```\n> map前：\n> (28, 28, 1) UInt8\n> map后：\n> (28, 28, 1) Float32\n> ```\n\n### batch\n\n将数据集打包为固定大小的`batch`是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。分块思想\n\n一般我们会设置一个固定的batch size，将连续的数据分为若干批（batch）。\n\n```python\n# 一般设定固定batchSize\ntrain_dataset = train_dataset.batch(batch_size=32)\n# batch后的数据增加一维，大小为batch_size\nimage, label = next(train_dataset.create_tuple_iterator())\nprint(image.shape, image.dtype)\n```\n\n> (32, 28, 28, 1) Float32\n\n### 自定义数据集\n\n`mindspore.dataset`模块提供了一些常用的公开数据集和标准格式数据集的加载API。\n\n对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过`GeneratorDataset`接口实现自定义方式的数据集加载。\n\n`GeneratorDataset`支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。\n\n#### 可随机访问数据集\n\n可随机访问数据集是实现了`__getitem__`和`__len__`方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。\n\n1. 实现了` __init__`，`__getitem__ ` 和`__len__`\n2. 当使用`dataset[idx]`访问这样的数据集时，可以读取dataset内容中第idx个样本或标签\n\n```python\n# Random-accessible object as input source\nclass RandomAccessDataset:\n    def __init__(self):\n        self._data = np.ones((5, 2))\n        self._label = np.zeros((5, 1))\n\n    def __getitem__(self, index):\n        return self._data[index], self._label[index]\n\n    def __len__(self):\n        return len(self._data)\n\n\nloader = RandomAccessDataset()\ndataset = GeneratorDataset(source=loader, column_names=[\"data\", \"label\"])\n\nfor data in dataset:\n    print(data)\n    \nloader = [np.array(0), np.array(1), np.array(2)]\ndataset = GeneratorDataset(source=loader, column_names=[\"data\"])\n\nfor data in dataset:\n    print(data)\n\n```\n\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n> [Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]\n\n创建的过程非常简单，通过numpy的数据结构为底层，实现三个方法就好了，更简单的直接使用list，tuple也是可行的。\n\n#### 可迭代数据集\n\n可迭代的数据集是实现了`__iter__`和`__next__`方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。\n\n例如，当使用`iter(dataset)`的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。\n\n下面构造一个简单迭代器，并将其加载至`GeneratorDataset`。\n\n```python\n# Iterator as input source\nclass IterableDataset():\n    def __init__(self, start, end):\n        '''init the class object to hold the data'''\n        self.start = start\n        self.end = end\n\n    def __next__(self):\n        '''iter one data and return'''\n        return next(self.data)\n\n    def __iter__(self):\n        '''reset the iter'''\n        self.data = iter(range(self.start, self.end))\n        return self\n\n\nloader = IterableDataset(1, 5)\ndataset = GeneratorDataset(source=loader, column_names=[\"data\"])\n\nfor d in dataset:\n    print(d)\n\n```\n\n> [Tensor(shape=[], dtype=Int32, value= 1)]\n> [Tensor(shape=[], dtype=Int32, value= 2)]\n> [Tensor(shape=[], dtype=Int32, value= 3)]\n> [Tensor(shape=[], dtype=Int32, value= 4)]\n\n同样的，实现方法即可\n\n#### 生成器\n\n生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型`generator`返回数据，直至生成器抛出`StopIteration`异常。\n\n下面构造一个生成器，并将其加载至`GeneratorDataset`。\n\n```python\n# Generator\ndef my_generator(start, end):\n    for i in range(start, end):\n        yield i\n\n\n# since a generator instance can be only iterated once, we need to wrap it by lambda to generate multiple instances\ndataset = GeneratorDataset(source=lambda: my_generator(3, 6), column_names=[\"data\"])\n\nfor d in dataset:\n    print(d)\n```\n\n>[Tensor(shape=[], dtype=Int32, value= 3)]\n>[Tensor(shape=[], dtype=Int32, value= 4)]\n>[Tensor(shape=[], dtype=Int32, value= 5)]\n\n这个更绝，仅用一个函数即可生成。（此处匿不匿名无关紧要）\n\n## 常见问题\n\n1. 找不到模块 matplotlib\n\n```shell\npip install matplotlib\n```\n\n","slug":"special_subject/MindSpore/Chapters/Fourth_DataSet","published":1,"updated":"2024-08-16T08:58:57.218Z","_id":"clzwh7ba800262wwv54oofvcu","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"数据集\">数据集</h2>\r\n<p>继续<a\r\nhref=\"./Second_TryMindSpore.md\">第二章</a>中的Mnist数据库为例，介绍使用mindspore.dataset进行加载的方法。</p>\r\n<p>详情请见MNIST数据官方网站：<span class=\"exturl\" data-url=\"aHR0cDovL3lhbm4ubGVjdW4uY29tL2V4ZGIvbW5pc3Qv\">MNIST handwritten digit\r\ndatabase, Yann LeCun, Corinna Cortes and Chris Burges<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<p>下面是简略介绍</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 9%\" />\r\n<col style=\"width: 24%\" />\r\n<col style=\"width: 55%\" />\r\n<col style=\"width: 10%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">数据集</th>\r\n<th style=\"text-align: center;\">MNIST中的文件名</th>\r\n<th style=\"text-align: center;\">下载地址</th>\r\n<th style=\"text-align: center;\">文件大小</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">训练集图像</td>\r\n<td style=\"text-align: center;\">train-images-idx3-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz</td>\r\n<td style=\"text-align: center;\">9912422字节</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">训练集标签</td>\r\n<td style=\"text-align: center;\">train-labels-idx1-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz</td>\r\n<td style=\"text-align: center;\">28881字节</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">测试集图像</td>\r\n<td style=\"text-align: center;\">t10k-images-idx3-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz</td>\r\n<td style=\"text-align: center;\">1648877字节</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">测试集标签</td>\r\n<td style=\"text-align: center;\">t10k-labels-idx1-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz</td>\r\n<td style=\"text-align: center;\">4542字节</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"数据库加载\">数据库加载</h3>\r\n<p><em>请注意：mindspore.dataset的接口仅支持解压后的数据文件</em></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">train_dataset = MnistDataset(<span class=\"string\">&quot;MNIST_Data/train&quot;</span>, shuffle=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(train_dataset))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>&lt;class\r\n'mindspore.dataset.engine.datasets_vision.MnistDataset'&gt;</p>\r\n</blockquote>\r\n<h3 id=\"数据库迭代\">数据库迭代</h3>\r\n<p>数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。我们可以用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfdHVwbGVfaXRlcmF0b3IuaHRtbA==\">create_tuple_iterator<i class=\"fa fa-external-link-alt\"></i></span>或<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfZGljdF9pdGVyYXRvci5odG1s\">create_dict_iterator<i class=\"fa fa-external-link-alt\"></i></span>接口创建数据迭代器，迭代访问数据。访问的数据类型默认为<code>Tensor</code>；若设置<code>output_numpy=True</code>，访问的数据类型为<code>Numpy</code>。</p>\r\n<p>下面定义一个可视化函数，迭代9张图片进行展示。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">visualize</span>(<span class=\"params\">dataset</span>):</span><br><span class=\"line\">    figure = plt.figure(figsize=(<span class=\"number\">4</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\">    cols, rows = <span class=\"number\">3</span>, <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    plt.subplots_adjust(wspace=<span class=\"number\">0.5</span>, hspace=<span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx, (image, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        figure.add_subplot(rows, cols, idx + <span class=\"number\">1</span>)</span><br><span class=\"line\">        plt.title(<span class=\"built_in\">int</span>(label))</span><br><span class=\"line\">        plt.axis(<span class=\"string\">&quot;off&quot;</span>)</span><br><span class=\"line\">        plt.imshow(image.asnumpy().squeeze(), cmap=<span class=\"string\">&quot;gray&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> idx == cols * rows - <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    plt.show()</span><br></pre></td></tr></table></figure>\r\n<p>在<code>for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):</code>此处的循环中枚举了训练集的前9个图像<code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在\r\nfor 循环当中。</p>\r\n<p>在循环体中使用了plt类画图。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/36CU8spH9eSEkxl.png\"\r\nalt=\"image-20240606173353887\" />\r\n<figcaption aria-hidden=\"true\">image-20240606173353887</figcaption>\r\n</figure>\r\n<h3 id=\"数据集常用操作\">数据集常用操作</h3>\r\n<p>Pipeline的设计理念使得数据集的常用操作采用<code>dataset = dataset.operation()</code>的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。</p>\r\n<p>下面分别介绍几种常见的数据集操作。</p>\r\n<h3 id=\"shuffle\">shuffle</h3>\r\n<p>数据集随机<code>shuffle</code>可以消除数据排列造成的分布不均问题</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/M54ICySt9dzenva.png\"\r\nalt=\"op-shuffle\" />\r\n<figcaption aria-hidden=\"true\">op-shuffle</figcaption>\r\n</figure>\r\n<p><code>mindspore.dataset</code>提供的数据集在加载时可配置<code>shuffle=True</code>，或使用如下操作</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">train_dataset = train_dataset.shuffle(buffer_size=<span class=\"number\">64</span>)</span><br><span class=\"line\">visualize(train_dataset)</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/yB76TmklvtYXIgE.png\"\r\nalt=\"image-20240606173414784\" />\r\n<figcaption aria-hidden=\"true\">image-20240606173414784</figcaption>\r\n</figure>\r\n<h3 id=\"map\">map</h3>\r\n<p><code>map</code>操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;map前：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br><span class=\"line\">train_dataset = train_dataset.<span class=\"built_in\">map</span>(vision.Rescale(<span class=\"number\">1.0</span> / <span class=\"number\">255.0</span>, <span class=\"number\">0</span>), input_columns=<span class=\"string\">&#x27;image&#x27;</span>)</span><br><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;map后：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map前：</span><br><span class=\"line\">(28, 28, 1) UInt8</span><br><span class=\"line\">map后：</span><br><span class=\"line\">(28, 28, 1) Float32</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<h3 id=\"batch\">batch</h3>\r\n<p>将数据集打包为固定大小的<code>batch</code>是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。分块思想</p>\r\n<p>一般我们会设置一个固定的batch\r\nsize，将连续的数据分为若干批（batch）。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一般设定固定batchSize</span></span><br><span class=\"line\">train_dataset = train_dataset.batch(batch_size=<span class=\"number\">32</span>)</span><br><span class=\"line\"><span class=\"comment\"># batch后的数据增加一维，大小为batch_size</span></span><br><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>(32, 28, 28, 1) Float32</p>\r\n</blockquote>\r\n<h3 id=\"自定义数据集\">自定义数据集</h3>\r\n<p><code>mindspore.dataset</code>模块提供了一些常用的公开数据集和标准格式数据集的加载API。</p>\r\n<p>对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过<code>GeneratorDataset</code>接口实现自定义方式的数据集加载。</p>\r\n<p><code>GeneratorDataset</code>支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。</p>\r\n<h4 id=\"可随机访问数据集\">可随机访问数据集</h4>\r\n<p>可随机访问数据集是实现了<code>__getitem__</code>和<code>__len__</code>方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。</p>\r\n<ol type=\"1\">\r\n<li>实现了<code>__init__</code>，<code>__getitem__</code>\r\n和<code>__len__</code></li>\r\n<li>当使用<code>dataset[idx]</code>访问这样的数据集时，可以读取dataset内容中第idx个样本或标签</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Random-accessible object as input source</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RandomAccessDataset</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>._data = np.ones((<span class=\"number\">5</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>._label = np.zeros((<span class=\"number\">5</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__getitem__</span>(<span class=\"params\">self, index</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>._data[index], <span class=\"variable language_\">self</span>._label[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__len__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(<span class=\"variable language_\">self</span>._data)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">loader = RandomAccessDataset()</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>, <span class=\"string\">&quot;label&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data)</span><br><span class=\"line\">    </span><br><span class=\"line\">loader = [np.array(<span class=\"number\">0</span>), np.array(<span class=\"number\">1</span>), np.array(<span class=\"number\">2</span>)]</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,\r\n1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [\r\n0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])]</p>\r\n</blockquote>\r\n<p>创建的过程非常简单，通过numpy的数据结构为底层，实现三个方法就好了，更简单的直接使用list，tuple也是可行的。</p>\r\n<h4 id=\"可迭代数据集\">可迭代数据集</h4>\r\n<p>可迭代的数据集是实现了<code>__iter__</code>和<code>__next__</code>方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。</p>\r\n<p>例如，当使用<code>iter(dataset)</code>的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。</p>\r\n<p>下面构造一个简单迭代器，并将其加载至<code>GeneratorDataset</code>。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Iterator as input source</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IterableDataset</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, start, end</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;init the class object to hold the data&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.start = start</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.end = end</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;iter one data and return&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(<span class=\"variable language_\">self</span>.data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;reset the iter&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.data = <span class=\"built_in\">iter</span>(<span class=\"built_in\">range</span>(<span class=\"variable language_\">self</span>.start, <span class=\"variable language_\">self</span>.end))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">loader = IterableDataset(<span class=\"number\">1</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(d)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[], dtype=Int32, value= 1)] [Tensor(shape=[],\r\ndtype=Int32, value= 2)] [Tensor(shape=[], dtype=Int32, value= 3)]\r\n[Tensor(shape=[], dtype=Int32, value= 4)]</p>\r\n</blockquote>\r\n<p>同样的，实现方法即可</p>\r\n<h4 id=\"生成器\">生成器</h4>\r\n<p>生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型<code>generator</code>返回数据，直至生成器抛出<code>StopIteration</code>异常。</p>\r\n<p>下面构造一个生成器，并将其加载至<code>GeneratorDataset</code>。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Generator</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_generator</span>(<span class=\"params\">start, end</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(start, end):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># since a generator instance can be only iterated once, we need to wrap it by lambda to generate multiple instances</span></span><br><span class=\"line\">dataset = GeneratorDataset(source=<span class=\"keyword\">lambda</span>: my_generator(<span class=\"number\">3</span>, <span class=\"number\">6</span>), column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(d)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[], dtype=Int32, value= 3)] [Tensor(shape=[],\r\ndtype=Int32, value= 4)] [Tensor(shape=[], dtype=Int32, value= 5)]</p>\r\n</blockquote>\r\n<p>这个更绝，仅用一个函数即可生成。（此处匿不匿名无关紧要）</p>\r\n<h2 id=\"常见问题\">常见问题</h2>\r\n<ol type=\"1\">\r\n<li>找不到模块 matplotlib</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install matplotlib</span><br></pre></td></tr></table></figure>\r\n","length":1651,"excerpt":"<h2 id=\"数据集\">数据集</h2>\r\n<p>继续<a\r\nhref=\"./Second_TryMindSpore.md\">第二章</a>中的Mnist数据库为例，介绍使用mindspore.dataset进行加载的方法。</p>\r\n<p>详情请见MNIST数据官方网站：<span class=\"exturl\" data-url=\"aHR0cDovL3lhbm4ubGVjdW4uY29tL2V4ZGIvbW5pc3Qv\">MNIST handwritten digit\r\ndatabase, Yann LeCun, Corinna Cortes and Chris Burges<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<p>下面是简略介绍</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 9%\" />\r\n<col style=\"width: 24%\" />\r\n<col style=\"width: 55%\" />\r\n<col style=\"width: 10%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">数据集</th>\r\n<th style=\"text-align: center;\">MNIST中的文件名</th>\r\n<th style=\"text-align: center;\">下载地址</th>\r\n<th style=\"text-align: center;\">文件大小</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">训练集图像</td>\r\n<td style=\"text-align: center;\">train-images-idx3-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz</td>\r\n<td style=\"text-align: center;\">9912422字节</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">训练集标签</td>\r\n<td style=\"text-align: center;\">train-labels-idx1-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz</td>\r\n<td style=\"text-align: center;\">28881字节</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">测试集图像</td>\r\n<td style=\"text-align: center;\">t10k-images-idx3-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz</td>\r\n<td style=\"text-align: center;\">1648877字节</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">测试集标签</td>\r\n<td style=\"text-align: center;\">t10k-labels-idx1-ubyte.gz</td>\r\n<td\r\nstyle=\"text-align: center;\">http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz</td>\r\n<td style=\"text-align: center;\">4542字节</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"数据库加载\">数据库加载</h3>\r\n<p><em>请注意：mindspore.dataset的接口仅支持解压后的数据文件</em></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">train_dataset = MnistDataset(<span class=\"string\">&quot;MNIST_Data/train&quot;</span>, shuffle=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(train_dataset))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>&lt;class\r\n'mindspore.dataset.engine.datasets_vision.MnistDataset'&gt;</p>\r\n</blockquote>\r\n<h3 id=\"数据库迭代\">数据库迭代</h3>\r\n<p>数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。我们可以用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfdHVwbGVfaXRlcmF0b3IuaHRtbA==\">create_tuple_iterator<i class=\"fa fa-external-link-alt\"></i></span>或<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfZGljdF9pdGVyYXRvci5odG1s\">create_dict_iterator<i class=\"fa fa-external-link-alt\"></i></span>接口创建数据迭代器，迭代访问数据。访问的数据类型默认为<code>Tensor</code>；若设置<code>output_numpy=True</code>，访问的数据类型为<code>Numpy</code>。</p>\r\n<p>下面定义一个可视化函数，迭代9张图片进行展示。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">visualize</span>(<span class=\"params\">dataset</span>):</span><br><span class=\"line\">    figure = plt.figure(figsize=(<span class=\"number\">4</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\">    cols, rows = <span class=\"number\">3</span>, <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    plt.subplots_adjust(wspace=<span class=\"number\">0.5</span>, hspace=<span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx, (image, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        figure.add_subplot(rows, cols, idx + <span class=\"number\">1</span>)</span><br><span class=\"line\">        plt.title(<span class=\"built_in\">int</span>(label))</span><br><span class=\"line\">        plt.axis(<span class=\"string\">&quot;off&quot;</span>)</span><br><span class=\"line\">        plt.imshow(image.asnumpy().squeeze(), cmap=<span class=\"string\">&quot;gray&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> idx == cols * rows - <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    plt.show()</span><br></pre></td></tr></table></figure>\r\n<p>在<code>for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):</code>此处的循环中枚举了训练集的前9个图像<code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在\r\nfor 循环当中。</p>\r\n<p>在循环体中使用了plt类画图。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/36CU8spH9eSEkxl.png\"\r\nalt=\"image-20240606173353887\" />\r\n<figcaption aria-hidden=\"true\">image-20240606173353887</figcaption>\r\n</figure>\r\n<h3 id=\"数据集常用操作\">数据集常用操作</h3>\r\n<p>Pipeline的设计理念使得数据集的常用操作采用<code>dataset = dataset.operation()</code>的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。</p>\r\n<p>下面分别介绍几种常见的数据集操作。</p>\r\n<h3 id=\"shuffle\">shuffle</h3>\r\n<p>数据集随机<code>shuffle</code>可以消除数据排列造成的分布不均问题</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/M54ICySt9dzenva.png\"\r\nalt=\"op-shuffle\" />\r\n<figcaption aria-hidden=\"true\">op-shuffle</figcaption>\r\n</figure>\r\n<p><code>mindspore.dataset</code>提供的数据集在加载时可配置<code>shuffle=True</code>，或使用如下操作</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">train_dataset = train_dataset.shuffle(buffer_size=<span class=\"number\">64</span>)</span><br><span class=\"line\">visualize(train_dataset)</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/06/yB76TmklvtYXIgE.png\"\r\nalt=\"image-20240606173414784\" />\r\n<figcaption aria-hidden=\"true\">image-20240606173414784</figcaption>\r\n</figure>\r\n<h3 id=\"map\">map</h3>\r\n<p><code>map</code>操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;map前：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br><span class=\"line\">train_dataset = train_dataset.<span class=\"built_in\">map</span>(vision.Rescale(<span class=\"number\">1.0</span> / <span class=\"number\">255.0</span>, <span class=\"number\">0</span>), input_columns=<span class=\"string\">&#x27;image&#x27;</span>)</span><br><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;map后：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map前：</span><br><span class=\"line\">(28, 28, 1) UInt8</span><br><span class=\"line\">map后：</span><br><span class=\"line\">(28, 28, 1) Float32</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<h3 id=\"batch\">batch</h3>\r\n<p>将数据集打包为固定大小的<code>batch</code>是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。分块思想</p>\r\n<p>一般我们会设置一个固定的batch\r\nsize，将连续的数据分为若干批（batch）。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一般设定固定batchSize</span></span><br><span class=\"line\">train_dataset = train_dataset.batch(batch_size=<span class=\"number\">32</span>)</span><br><span class=\"line\"><span class=\"comment\"># batch后的数据增加一维，大小为batch_size</span></span><br><span class=\"line\">image, label = <span class=\"built_in\">next</span>(train_dataset.create_tuple_iterator())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(image.shape, image.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>(32, 28, 28, 1) Float32</p>\r\n</blockquote>\r\n<h3 id=\"自定义数据集\">自定义数据集</h3>\r\n<p><code>mindspore.dataset</code>模块提供了一些常用的公开数据集和标准格式数据集的加载API。</p>\r\n<p>对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过<code>GeneratorDataset</code>接口实现自定义方式的数据集加载。</p>\r\n<p><code>GeneratorDataset</code>支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。</p>\r\n<h4 id=\"可随机访问数据集\">可随机访问数据集</h4>\r\n<p>可随机访问数据集是实现了<code>__getitem__</code>和<code>__len__</code>方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。</p>\r\n<ol type=\"1\">\r\n<li>实现了<code>__init__</code>，<code>__getitem__</code>\r\n和<code>__len__</code></li>\r\n<li>当使用<code>dataset[idx]</code>访问这样的数据集时，可以读取dataset内容中第idx个样本或标签</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Random-accessible object as input source</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RandomAccessDataset</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>._data = np.ones((<span class=\"number\">5</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>._label = np.zeros((<span class=\"number\">5</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__getitem__</span>(<span class=\"params\">self, index</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>._data[index], <span class=\"variable language_\">self</span>._label[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__len__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(<span class=\"variable language_\">self</span>._data)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">loader = RandomAccessDataset()</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>, <span class=\"string\">&quot;label&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data)</span><br><span class=\"line\">    </span><br><span class=\"line\">loader = [np.array(<span class=\"number\">0</span>), np.array(<span class=\"number\">1</span>), np.array(<span class=\"number\">2</span>)]</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,\r\n1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [\r\n0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])] [Tensor(shape=[2], dtype=Float64, value= [\r\n1.00000000e+00, 1.00000000e+00]), Tensor(shape=[1], dtype=Float64,\r\nvalue= [ 0.00000000e+00])]</p>\r\n</blockquote>\r\n<p>创建的过程非常简单，通过numpy的数据结构为底层，实现三个方法就好了，更简单的直接使用list，tuple也是可行的。</p>\r\n<h4 id=\"可迭代数据集\">可迭代数据集</h4>\r\n<p>可迭代的数据集是实现了<code>__iter__</code>和<code>__next__</code>方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。</p>\r\n<p>例如，当使用<code>iter(dataset)</code>的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。</p>\r\n<p>下面构造一个简单迭代器，并将其加载至<code>GeneratorDataset</code>。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Iterator as input source</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IterableDataset</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, start, end</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;init the class object to hold the data&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.start = start</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.end = end</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;iter one data and return&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(<span class=\"variable language_\">self</span>.data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;reset the iter&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.data = <span class=\"built_in\">iter</span>(<span class=\"built_in\">range</span>(<span class=\"variable language_\">self</span>.start, <span class=\"variable language_\">self</span>.end))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">loader = IterableDataset(<span class=\"number\">1</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">dataset = GeneratorDataset(source=loader, column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(d)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[], dtype=Int32, value= 1)] [Tensor(shape=[],\r\ndtype=Int32, value= 2)] [Tensor(shape=[], dtype=Int32, value= 3)]\r\n[Tensor(shape=[], dtype=Int32, value= 4)]</p>\r\n</blockquote>\r\n<p>同样的，实现方法即可</p>\r\n<h4 id=\"生成器\">生成器</h4>\r\n<p>生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型<code>generator</code>返回数据，直至生成器抛出<code>StopIteration</code>异常。</p>\r\n<p>下面构造一个生成器，并将其加载至<code>GeneratorDataset</code>。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Generator</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_generator</span>(<span class=\"params\">start, end</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(start, end):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># since a generator instance can be only iterated once, we need to wrap it by lambda to generate multiple instances</span></span><br><span class=\"line\">dataset = GeneratorDataset(source=<span class=\"keyword\">lambda</span>: my_generator(<span class=\"number\">3</span>, <span class=\"number\">6</span>), column_names=[<span class=\"string\">&quot;data&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> dataset:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(d)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[Tensor(shape=[], dtype=Int32, value= 3)] [Tensor(shape=[],\r\ndtype=Int32, value= 4)] [Tensor(shape=[], dtype=Int32, value= 5)]</p>\r\n</blockquote>\r\n<p>这个更绝，仅用一个函数即可生成。（此处匿不匿名无关紧要）</p>\r\n<h2 id=\"常见问题\">常见问题</h2>\r\n<ol type=\"1\">\r\n<li>找不到模块 matplotlib</li>\r\n</ol>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install matplotlib</span><br></pre></td></tr></table></figure>"},{"title":"MindSpore专题——第七章、模型训练","date":"2024-08-14T11:47:58.000Z","_content":"## 模型训练\n\n本片涉及大量之前提到概念的定义以及大量引用MindSpore官方文档。原文传送门：\n\n[MindSpore](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/train.html)\n\n<!--more-->\n\n### 四个步骤\n\n1. 构建数据集。\n2. 定义神经网络模型。\n3. 定义超参、损失函数及优化器。\n4. 输入数据集进行训练与评估。\n\n现在我们有了数据集和模型后，可以进行模型的训练与评估。\n\n### 构建数据集\n\n从dataset加载代码，构建数据集\n\n```\ndef datapipe(path, batch_size):\n    image_transforms = [\n        vision.Rescale(1.0 / 255.0, 0),\n        vision.Normalize(mean=(0.1307,), std=(0.3081,)),\n        vision.HWC2CHW()\n    ]\n    label_transform = transforms.TypeCast(mindspore.int32)\n\n    dataset = MnistDataset(path)\n    dataset = dataset.map(image_transforms, 'image')\n    dataset = dataset.map(label_transform, 'label')\n    dataset = dataset.batch(batch_size)\n    return dataset\n\ntrain_dataset = datapipe('MNIST_Data/train', batch_size=64)\ntest_dataset = datapipe('MNIST_Data/test', batch_size=64)\n```\n\n*class*mindspore.dataset.vision.HWC2CHW\n\n将输入图像的shape从 <H, W, C> 转换为 <C, H, W>。 如果输入图像的shape为 <H, W> ，图像将保持不变。\n\n异常处理\n\n- **RuntimeError** - 如果输入图像的shape不是 <H, W> 或 <H, W, C>。\n\n*class*mindspore.nn.**ReLU**\n\n逐元素求 max(0,𝑥) 。\n\n- **x** (Tensor) - 用于计算**ReLU**的任意维度的Tensor。数据类型为 [number](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.dtype.html#mindspore.dtype)。\n\n### 定义神经网络模型\n\n>  从[网络构建](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/model.html)中加载代码，构建一个神经网络模型。\n\n```python\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512),\n            nn.ReLU(),\n            nn.Dense(512, 512),\n            nn.ReLU(),\n            nn.Dense(512, 10)\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\nmodel = Network()\nprint(model)\n```\n\n### 定义超参、损失函数和优化器\n\n#### 超参\n\n超参（Hyperparameters）是可以调整的参数，可以控制模型训练优化的过程，不同的超参数值可能会影响模型训练和收敛速度。目前深度学习模型多采用批量随机梯度下降算法进行优化，随机梯度下降算法的原理如下：\n$$\nw_{t+1}=w_{t}-\\eta \\frac{1}{n} \\sum_{x \\in \\mathcal{B}} \\nabla l\\left(x, w_{t}\\right)\n$$\n公式中，𝑛是批量大小（batch size），𝜂是学习率（learning rate）。另外，𝑤𝑡为训练轮次𝑡中的权重参数，∇𝑙为损失函数的导数。除了梯度本身，这两个因子直接决定了模型的权重更新，从优化本身来看，它们是影响模型性能收敛最重要的参数。一般会定义以下超参用于训练：\n\n- **训练轮次（epoch）**：训练时遍历数据集的次数。\n- **批次大小（batch size）**：数据集进行分批读取训练，设定每个批次数据的大小。batch size过小，花费时间多，同时梯度震荡严重，不利于收敛；batch size过大，不同batch的梯度方向没有任何变化，容易陷入局部极小值，因此需要选择合适的batch size，可以有效提高模型精度、全局收敛。\n- **学习率（learning rate）**：如果学习率偏小，会导致收敛的速度变慢，如果学习率偏大，则可能会导致训练不收敛等不可预测的结果。梯度下降法被广泛应用在最小化模型误差的参数优化算法上。梯度下降法通过多次迭代，并在每一步中最小化损失函数来预估模型的参数。学习率就是在迭代过程中，会控制模型的学习进度。\n\n```python\nepochs = 3\nbatch_size = 64\nlearning_rate = 1e-2\n```\n\n#### 损失函数\n\n损失函数（loss function）用于评估模型的预测值（logits）和目标值（targets）之间的误差。训练模型时，随机初始化的神经网络模型开始时会预测出错误的结果。损失函数会评估预测结果与目标值的相异程度，模型训练的目标即为降低损失函数求得的误差。\n\n常见的损失函数包括用于回归任务的`nn.MSELoss`（均方误差）和用于分类的`nn.NLLLoss`（负对数似然）等。 `nn.CrossEntropyLoss` 结合了`nn.LogSoftmax`和`nn.NLLLoss`，可以对logits 进行归一化并计算预测误差。\n\n```python\nloss_fn = nn.CrossEntropyLoss()\n```\n\n#### 优化器\n\n模型优化（Optimization）是在每个训练步骤中调整模型参数以减少模型误差的过程。MindSpore提供多种优化算法的实现，称之为优化器（Optimizer）。优化器内部定义了模型的参数优化过程（即梯度如何更新至模型参数），所有优化逻辑都封装在优化器对象中。在这里，我们使用SGD（Stochastic Gradient Descent）优化器。\n\n我们通过`model.trainable_params()`方法获得模型的可训练参数，并传入学习率超参来初始化优化器。\n\n```python\noptimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)\n```\n\n*class*mindspore.experimental.optim.**SGD**(*params*, *lr*, *momentum=0*, *dampening=0*, *weight_decay=0*, *nesterov=False*, ***, *maximize=False*)\n\n随机梯度下降算法。\n$$\nv_{t+1} = u \\ast v_{t} + gradient \\ast (1-dampening)\n$$\n如果nesterov为True：\n$$\np_{t+1} = p_{t} - lr \\ast (gradient + u \\ast v_{t+1})\n$$\n如果nesterov为False：\n$$\np_{t+1} = p_{t} - lr \\ast v_{t+1}\n$$\n需要注意的是，对于训练的第一步 𝑣𝑡+1=𝑔𝑟𝑎𝑑𝑖𝑒𝑛𝑡。其中，p、v和u分别表示 parameters、accum 和 momentum。\n\n#### 训练与评估\n\n设置了超参、损失函数和优化器后，我们就可以循环输入数据来训练模型。一次数据集的完整迭代循环称为一轮（epoch）。每轮执行训练时包括两个步骤：\n\n1. 训练：迭代训练数据集，并尝试收敛到最佳参数。\n2. 验证/测试：迭代测试数据集，以检查模型性能是否提升。\n\n接下来我们定义用于训练的`train_loop`函数和用于测试的`test_loop`函数。\n\n使用函数式自动微分，需先定义正向函数`forward_fn`，使用[value_and_grad](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.value_and_grad.html)获得微分函数`grad_fn`。然后，我们将微分函数和优化器的执行封装为`train_step`函数，接下来循环迭代数据集进行训练即可。\n\n```python\n# Define forward function\ndef forward_fn(data, label):\n    logits = model(data)\n    loss = loss_fn(logits, label)\n    return loss, logits\n\n# Get gradient function\ngrad_fn = mindspore.value_and_grad(forward_fn, None, optimizer.parameters, has_aux=True)\n\n# Define function of one-step training\ndef train_step(data, label):\n    (loss, _), grads = grad_fn(data, label)\n    optimizer(grads)\n    return loss\n\ndef train_loop(model, dataset):\n    size = dataset.get_dataset_size()\n    model.set_train()\n    for batch, (data, label) in enumerate(dataset.create_tuple_iterator()):\n        loss = train_step(data, label)\n\n        if batch % 100 == 0:\n            loss, current = loss.asnumpy(), batch\n            print(f\"loss: {loss:>7f}  [{current:>3d}/{size:>3d}]\")\n```\n\n`test_loop`函数同样需循环遍历数据集，调用模型计算loss和Accuray并返回最终结果。\n\n```python\ndef test_loop(model, dataset, loss_fn):\n    num_batches = dataset.get_dataset_size()\n    model.set_train(False)\n    total, test_loss, correct = 0, 0, 0\n    for data, label in dataset.create_tuple_iterator():\n        pred = model(data)\n        total += len(data)\n        test_loss += loss_fn(pred, label).asnumpy()\n        correct += (pred.argmax(1) == label).asnumpy().sum()\n    test_loss /= num_batches\n    correct /= total\n    print(f\"Test: \\n Accuracy: {(100*correct):>0.1f}%, Avg loss: {test_loss:>8f} \\n\")\n```\n\n我们将实例化的损失函数和优化器传入`train_loop`和`test_loop`中。训练3轮并输出loss和Accuracy，查看性能变化。\n\n```python\nloss_fn = nn.CrossEntropyLoss()\noptimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)\n\nfor t in range(epochs):\n    print(f\"Epoch {t+1}\\n-------------------------------\")\n    train_loop(model, train_dataset)\n    test_loop(model, test_dataset, loss_fn)\nprint(\"Done!\")\n```\n\n> ```\n> Epoch 1\n> -------------------------------\n> loss: 2.302806  [  0/938]\n> loss: 2.285086  [100/938]\n> loss: 2.264712  [200/938]\n> loss: 2.174010  [300/938]\n> loss: 1.931853  [400/938]\n> loss: 1.340721  [500/938]\n> loss: 0.953515  [600/938]\n> loss: 0.756860  [700/938]\n> loss: 0.756263  [800/938]\n> loss: 0.463846  [900/938]\n> Test:\n>  Accuracy: 84.7%, Avg loss: 0.527155\n> \n> Epoch 2\n> -------------------------------\n> loss: 0.479126  [  0/938]\n> loss: 0.437443  [100/938]\n> loss: 0.685504  [200/938]\n> loss: 0.395121  [300/938]\n> loss: 0.550566  [400/938]\n> loss: 0.459457  [500/938]\n> loss: 0.293049  [600/938]\n> loss: 0.422102  [700/938]\n> loss: 0.333153  [800/938]\n> loss: 0.412182  [900/938]\n> Test:\n>  Accuracy: 90.5%, Avg loss: 0.335083\n> \n> Epoch 3\n> -------------------------------\n> loss: 0.207366  [  0/938]\n> loss: 0.343559  [100/938]\n> loss: 0.391145  [200/938]\n> loss: 0.317566  [300/938]\n> loss: 0.200746  [400/938]\n> loss: 0.445798  [500/938]\n> loss: 0.603720  [600/938]\n> loss: 0.170811  [700/938]\n> loss: 0.411954  [800/938]\n> loss: 0.315902  [900/938]\n> Test:\n>  Accuracy: 91.9%, Avg loss: 0.279034\n> \n> Done!\n> ```\n\n读者可以修改参数多跑几边，观察数据的变化，不懂随机梯度下降算法或不懂正向反向传播、学习率乃至超参的概念可以回顾之前文章中提到的视频并重复观看之前的文章，这几个概念应该比较好理解。","source":"_posts/special_subject/MindSpore/Chapters/Seven_ModelTrain.md","raw":"---\ntitle: MindSpore专题——第七章、模型训练\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## 模型训练\n\n本片涉及大量之前提到概念的定义以及大量引用MindSpore官方文档。原文传送门：\n\n[MindSpore](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/train.html)\n\n<!--more-->\n\n### 四个步骤\n\n1. 构建数据集。\n2. 定义神经网络模型。\n3. 定义超参、损失函数及优化器。\n4. 输入数据集进行训练与评估。\n\n现在我们有了数据集和模型后，可以进行模型的训练与评估。\n\n### 构建数据集\n\n从dataset加载代码，构建数据集\n\n```\ndef datapipe(path, batch_size):\n    image_transforms = [\n        vision.Rescale(1.0 / 255.0, 0),\n        vision.Normalize(mean=(0.1307,), std=(0.3081,)),\n        vision.HWC2CHW()\n    ]\n    label_transform = transforms.TypeCast(mindspore.int32)\n\n    dataset = MnistDataset(path)\n    dataset = dataset.map(image_transforms, 'image')\n    dataset = dataset.map(label_transform, 'label')\n    dataset = dataset.batch(batch_size)\n    return dataset\n\ntrain_dataset = datapipe('MNIST_Data/train', batch_size=64)\ntest_dataset = datapipe('MNIST_Data/test', batch_size=64)\n```\n\n*class*mindspore.dataset.vision.HWC2CHW\n\n将输入图像的shape从 <H, W, C> 转换为 <C, H, W>。 如果输入图像的shape为 <H, W> ，图像将保持不变。\n\n异常处理\n\n- **RuntimeError** - 如果输入图像的shape不是 <H, W> 或 <H, W, C>。\n\n*class*mindspore.nn.**ReLU**\n\n逐元素求 max(0,𝑥) 。\n\n- **x** (Tensor) - 用于计算**ReLU**的任意维度的Tensor。数据类型为 [number](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.dtype.html#mindspore.dtype)。\n\n### 定义神经网络模型\n\n>  从[网络构建](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/model.html)中加载代码，构建一个神经网络模型。\n\n```python\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512),\n            nn.ReLU(),\n            nn.Dense(512, 512),\n            nn.ReLU(),\n            nn.Dense(512, 10)\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\nmodel = Network()\nprint(model)\n```\n\n### 定义超参、损失函数和优化器\n\n#### 超参\n\n超参（Hyperparameters）是可以调整的参数，可以控制模型训练优化的过程，不同的超参数值可能会影响模型训练和收敛速度。目前深度学习模型多采用批量随机梯度下降算法进行优化，随机梯度下降算法的原理如下：\n$$\nw_{t+1}=w_{t}-\\eta \\frac{1}{n} \\sum_{x \\in \\mathcal{B}} \\nabla l\\left(x, w_{t}\\right)\n$$\n公式中，𝑛是批量大小（batch size），𝜂是学习率（learning rate）。另外，𝑤𝑡为训练轮次𝑡中的权重参数，∇𝑙为损失函数的导数。除了梯度本身，这两个因子直接决定了模型的权重更新，从优化本身来看，它们是影响模型性能收敛最重要的参数。一般会定义以下超参用于训练：\n\n- **训练轮次（epoch）**：训练时遍历数据集的次数。\n- **批次大小（batch size）**：数据集进行分批读取训练，设定每个批次数据的大小。batch size过小，花费时间多，同时梯度震荡严重，不利于收敛；batch size过大，不同batch的梯度方向没有任何变化，容易陷入局部极小值，因此需要选择合适的batch size，可以有效提高模型精度、全局收敛。\n- **学习率（learning rate）**：如果学习率偏小，会导致收敛的速度变慢，如果学习率偏大，则可能会导致训练不收敛等不可预测的结果。梯度下降法被广泛应用在最小化模型误差的参数优化算法上。梯度下降法通过多次迭代，并在每一步中最小化损失函数来预估模型的参数。学习率就是在迭代过程中，会控制模型的学习进度。\n\n```python\nepochs = 3\nbatch_size = 64\nlearning_rate = 1e-2\n```\n\n#### 损失函数\n\n损失函数（loss function）用于评估模型的预测值（logits）和目标值（targets）之间的误差。训练模型时，随机初始化的神经网络模型开始时会预测出错误的结果。损失函数会评估预测结果与目标值的相异程度，模型训练的目标即为降低损失函数求得的误差。\n\n常见的损失函数包括用于回归任务的`nn.MSELoss`（均方误差）和用于分类的`nn.NLLLoss`（负对数似然）等。 `nn.CrossEntropyLoss` 结合了`nn.LogSoftmax`和`nn.NLLLoss`，可以对logits 进行归一化并计算预测误差。\n\n```python\nloss_fn = nn.CrossEntropyLoss()\n```\n\n#### 优化器\n\n模型优化（Optimization）是在每个训练步骤中调整模型参数以减少模型误差的过程。MindSpore提供多种优化算法的实现，称之为优化器（Optimizer）。优化器内部定义了模型的参数优化过程（即梯度如何更新至模型参数），所有优化逻辑都封装在优化器对象中。在这里，我们使用SGD（Stochastic Gradient Descent）优化器。\n\n我们通过`model.trainable_params()`方法获得模型的可训练参数，并传入学习率超参来初始化优化器。\n\n```python\noptimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)\n```\n\n*class*mindspore.experimental.optim.**SGD**(*params*, *lr*, *momentum=0*, *dampening=0*, *weight_decay=0*, *nesterov=False*, ***, *maximize=False*)\n\n随机梯度下降算法。\n$$\nv_{t+1} = u \\ast v_{t} + gradient \\ast (1-dampening)\n$$\n如果nesterov为True：\n$$\np_{t+1} = p_{t} - lr \\ast (gradient + u \\ast v_{t+1})\n$$\n如果nesterov为False：\n$$\np_{t+1} = p_{t} - lr \\ast v_{t+1}\n$$\n需要注意的是，对于训练的第一步 𝑣𝑡+1=𝑔𝑟𝑎𝑑𝑖𝑒𝑛𝑡。其中，p、v和u分别表示 parameters、accum 和 momentum。\n\n#### 训练与评估\n\n设置了超参、损失函数和优化器后，我们就可以循环输入数据来训练模型。一次数据集的完整迭代循环称为一轮（epoch）。每轮执行训练时包括两个步骤：\n\n1. 训练：迭代训练数据集，并尝试收敛到最佳参数。\n2. 验证/测试：迭代测试数据集，以检查模型性能是否提升。\n\n接下来我们定义用于训练的`train_loop`函数和用于测试的`test_loop`函数。\n\n使用函数式自动微分，需先定义正向函数`forward_fn`，使用[value_and_grad](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.value_and_grad.html)获得微分函数`grad_fn`。然后，我们将微分函数和优化器的执行封装为`train_step`函数，接下来循环迭代数据集进行训练即可。\n\n```python\n# Define forward function\ndef forward_fn(data, label):\n    logits = model(data)\n    loss = loss_fn(logits, label)\n    return loss, logits\n\n# Get gradient function\ngrad_fn = mindspore.value_and_grad(forward_fn, None, optimizer.parameters, has_aux=True)\n\n# Define function of one-step training\ndef train_step(data, label):\n    (loss, _), grads = grad_fn(data, label)\n    optimizer(grads)\n    return loss\n\ndef train_loop(model, dataset):\n    size = dataset.get_dataset_size()\n    model.set_train()\n    for batch, (data, label) in enumerate(dataset.create_tuple_iterator()):\n        loss = train_step(data, label)\n\n        if batch % 100 == 0:\n            loss, current = loss.asnumpy(), batch\n            print(f\"loss: {loss:>7f}  [{current:>3d}/{size:>3d}]\")\n```\n\n`test_loop`函数同样需循环遍历数据集，调用模型计算loss和Accuray并返回最终结果。\n\n```python\ndef test_loop(model, dataset, loss_fn):\n    num_batches = dataset.get_dataset_size()\n    model.set_train(False)\n    total, test_loss, correct = 0, 0, 0\n    for data, label in dataset.create_tuple_iterator():\n        pred = model(data)\n        total += len(data)\n        test_loss += loss_fn(pred, label).asnumpy()\n        correct += (pred.argmax(1) == label).asnumpy().sum()\n    test_loss /= num_batches\n    correct /= total\n    print(f\"Test: \\n Accuracy: {(100*correct):>0.1f}%, Avg loss: {test_loss:>8f} \\n\")\n```\n\n我们将实例化的损失函数和优化器传入`train_loop`和`test_loop`中。训练3轮并输出loss和Accuracy，查看性能变化。\n\n```python\nloss_fn = nn.CrossEntropyLoss()\noptimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)\n\nfor t in range(epochs):\n    print(f\"Epoch {t+1}\\n-------------------------------\")\n    train_loop(model, train_dataset)\n    test_loop(model, test_dataset, loss_fn)\nprint(\"Done!\")\n```\n\n> ```\n> Epoch 1\n> -------------------------------\n> loss: 2.302806  [  0/938]\n> loss: 2.285086  [100/938]\n> loss: 2.264712  [200/938]\n> loss: 2.174010  [300/938]\n> loss: 1.931853  [400/938]\n> loss: 1.340721  [500/938]\n> loss: 0.953515  [600/938]\n> loss: 0.756860  [700/938]\n> loss: 0.756263  [800/938]\n> loss: 0.463846  [900/938]\n> Test:\n>  Accuracy: 84.7%, Avg loss: 0.527155\n> \n> Epoch 2\n> -------------------------------\n> loss: 0.479126  [  0/938]\n> loss: 0.437443  [100/938]\n> loss: 0.685504  [200/938]\n> loss: 0.395121  [300/938]\n> loss: 0.550566  [400/938]\n> loss: 0.459457  [500/938]\n> loss: 0.293049  [600/938]\n> loss: 0.422102  [700/938]\n> loss: 0.333153  [800/938]\n> loss: 0.412182  [900/938]\n> Test:\n>  Accuracy: 90.5%, Avg loss: 0.335083\n> \n> Epoch 3\n> -------------------------------\n> loss: 0.207366  [  0/938]\n> loss: 0.343559  [100/938]\n> loss: 0.391145  [200/938]\n> loss: 0.317566  [300/938]\n> loss: 0.200746  [400/938]\n> loss: 0.445798  [500/938]\n> loss: 0.603720  [600/938]\n> loss: 0.170811  [700/938]\n> loss: 0.411954  [800/938]\n> loss: 0.315902  [900/938]\n> Test:\n>  Accuracy: 91.9%, Avg loss: 0.279034\n> \n> Done!\n> ```\n\n读者可以修改参数多跑几边，观察数据的变化，不懂随机梯度下降算法或不懂正向反向传播、学习率乃至超参的概念可以回顾之前文章中提到的视频并重复观看之前的文章，这几个概念应该比较好理解。","slug":"special_subject/MindSpore/Chapters/Seven_ModelTrain","published":1,"updated":"2024-08-16T08:59:02.737Z","_id":"clzwh7ba800292wwv2i6icy12","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"模型训练\">模型训练</h2>\r\n<p>本片涉及大量之前提到概念的定义以及大量引用MindSpore官方文档。原文传送门：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RyYWluLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"四个步骤\">四个步骤</h3>\r\n<ol type=\"1\">\r\n<li>构建数据集。</li>\r\n<li>定义神经网络模型。</li>\r\n<li>定义超参、损失函数及优化器。</li>\r\n<li>输入数据集进行训练与评估。</li>\r\n</ol>\r\n<p>现在我们有了数据集和模型后，可以进行模型的训练与评估。</p>\r\n<h3 id=\"构建数据集\">构建数据集</h3>\r\n<p>从dataset加载代码，构建数据集</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def datapipe(path, batch_size):</span><br><span class=\"line\">    image_transforms = [</span><br><span class=\"line\">        vision.Rescale(1.0 / 255.0, 0),</span><br><span class=\"line\">        vision.Normalize(mean=(0.1307,), std=(0.3081,)),</span><br><span class=\"line\">        vision.HWC2CHW()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    label_transform = transforms.TypeCast(mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\">    dataset = MnistDataset(path)</span><br><span class=\"line\">    dataset = dataset.map(image_transforms, &#x27;image&#x27;)</span><br><span class=\"line\">    dataset = dataset.map(label_transform, &#x27;label&#x27;)</span><br><span class=\"line\">    dataset = dataset.batch(batch_size)</span><br><span class=\"line\">    return dataset</span><br><span class=\"line\"></span><br><span class=\"line\">train_dataset = datapipe(&#x27;MNIST_Data/train&#x27;, batch_size=64)</span><br><span class=\"line\">test_dataset = datapipe(&#x27;MNIST_Data/test&#x27;, batch_size=64)</span><br></pre></td></tr></table></figure>\r\n<p><em>class</em>mindspore.dataset.vision.HWC2CHW</p>\r\n<p>将输入图像的shape从 &lt;H, W, C&gt; 转换为 &lt;C, H, W&gt;。\r\n如果输入图像的shape为 &lt;H, W&gt; ，图像将保持不变。</p>\r\n<p>异常处理</p>\r\n<ul>\r\n<li><strong>RuntimeError</strong> - 如果输入图像的shape不是 &lt;H, W&gt;\r\n或 &lt;H, W, C&gt;。</li>\r\n</ul>\r\n<p><em>class</em>mindspore.nn.<strong>ReLU</strong></p>\r\n<p>逐元素求 max(0,𝑥) 。</p>\r\n<ul>\r\n<li><strong>x</strong> (Tensor) -\r\n用于计算<strong>ReLU</strong>的任意维度的Tensor。数据类型为 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZHR5cGUuaHRtbCNtaW5kc3BvcmUuZHR5cGU=\">number<i class=\"fa fa-external-link-alt\"></i></span>。</li>\r\n</ul>\r\n<h3 id=\"定义神经网络模型\">定义神经网络模型</h3>\r\n<blockquote>\r\n<p>从<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL21vZGVsLmh0bWw=\">网络构建<i class=\"fa fa-external-link-alt\"></i></span>中加载代码，构建一个神经网络模型。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"定义超参损失函数和优化器\">定义超参、损失函数和优化器</h3>\r\n<h4 id=\"超参\">超参</h4>\r\n<p>超参（Hyperparameters）是可以调整的参数，可以控制模型训练优化的过程，不同的超参数值可能会影响模型训练和收敛速度。目前深度学习模型多采用批量随机梯度下降算法进行优化，随机梯度下降算法的原理如下：\r\n<span class=\"math display\">\\[\r\nw_{t+1}=w_{t}-\\eta \\frac{1}{n} \\sum_{x \\in \\mathcal{B}} \\nabla l\\left(x,\r\nw_{t}\\right)\r\n\\]</span> 公式中，𝑛是批量大小（batch size），𝜂是学习率（learning\r\nrate）。另外，𝑤𝑡为训练轮次𝑡中的权重参数，∇𝑙为损失函数的导数。除了梯度本身，这两个因子直接决定了模型的权重更新，从优化本身来看，它们是影响模型性能收敛最重要的参数。一般会定义以下超参用于训练：</p>\r\n<ul>\r\n<li><strong>训练轮次（epoch）</strong>：训练时遍历数据集的次数。</li>\r\n<li><strong>批次大小（batch\r\nsize）</strong>：数据集进行分批读取训练，设定每个批次数据的大小。batch\r\nsize过小，花费时间多，同时梯度震荡严重，不利于收敛；batch\r\nsize过大，不同batch的梯度方向没有任何变化，容易陷入局部极小值，因此需要选择合适的batch\r\nsize，可以有效提高模型精度、全局收敛。</li>\r\n<li><strong>学习率（learning\r\nrate）</strong>：如果学习率偏小，会导致收敛的速度变慢，如果学习率偏大，则可能会导致训练不收敛等不可预测的结果。梯度下降法被广泛应用在最小化模型误差的参数优化算法上。梯度下降法通过多次迭代，并在每一步中最小化损失函数来预估模型的参数。学习率就是在迭代过程中，会控制模型的学习进度。</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">epochs = <span class=\"number\">3</span></span><br><span class=\"line\">batch_size = <span class=\"number\">64</span></span><br><span class=\"line\">learning_rate = <span class=\"number\">1e-2</span></span><br></pre></td></tr></table></figure>\r\n<h4 id=\"损失函数\">损失函数</h4>\r\n<p>损失函数（loss\r\nfunction）用于评估模型的预测值（logits）和目标值（targets）之间的误差。训练模型时，随机初始化的神经网络模型开始时会预测出错误的结果。损失函数会评估预测结果与目标值的相异程度，模型训练的目标即为降低损失函数求得的误差。</p>\r\n<p>常见的损失函数包括用于回归任务的<code>nn.MSELoss</code>（均方误差）和用于分类的<code>nn.NLLLoss</code>（负对数似然）等。\r\n<code>nn.CrossEntropyLoss</code>\r\n结合了<code>nn.LogSoftmax</code>和<code>nn.NLLLoss</code>，可以对logits\r\n进行归一化并计算预测误差。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"优化器\">优化器</h4>\r\n<p>模型优化（Optimization）是在每个训练步骤中调整模型参数以减少模型误差的过程。MindSpore提供多种优化算法的实现，称之为优化器（Optimizer）。优化器内部定义了模型的参数优化过程（即梯度如何更新至模型参数），所有优化逻辑都封装在优化器对象中。在这里，我们使用SGD（Stochastic\r\nGradient Descent）优化器。</p>\r\n<p>我们通过<code>model.trainable_params()</code>方法获得模型的可训练参数，并传入学习率超参来初始化优化器。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)</span><br></pre></td></tr></table></figure>\r\n<p><em>class</em>mindspore.experimental.optim.<strong>SGD</strong>(<em>params</em>,\r\n<em>lr</em>, <em>momentum=0</em>, <em>dampening=0</em>,\r\n<em>weight_decay=0</em>, <em>nesterov=False</em>, **<em>,\r\n</em>maximize=False*)</p>\r\n<p>随机梯度下降算法。 <span class=\"math display\">\\[\r\nv_{t+1} = u \\ast v_{t} + gradient \\ast (1-dampening)\r\n\\]</span> 如果nesterov为True： <span class=\"math display\">\\[\r\np_{t+1} = p_{t} - lr \\ast (gradient + u \\ast v_{t+1})\r\n\\]</span> 如果nesterov为False： <span class=\"math display\">\\[\r\np_{t+1} = p_{t} - lr \\ast v_{t+1}\r\n\\]</span> 需要注意的是，对于训练的第一步\r\n𝑣𝑡+1=𝑔𝑟𝑎𝑑𝑖𝑒𝑛𝑡。其中，p、v和u分别表示 parameters、accum 和 momentum。</p>\r\n<h4 id=\"训练与评估\">训练与评估</h4>\r\n<p>设置了超参、损失函数和优化器后，我们就可以循环输入数据来训练模型。一次数据集的完整迭代循环称为一轮（epoch）。每轮执行训练时包括两个步骤：</p>\r\n<ol type=\"1\">\r\n<li>训练：迭代训练数据集，并尝试收敛到最佳参数。</li>\r\n<li>验证/测试：迭代测试数据集，以检查模型性能是否提升。</li>\r\n</ol>\r\n<p>接下来我们定义用于训练的<code>train_loop</code>函数和用于测试的<code>test_loop</code>函数。</p>\r\n<p>使用函数式自动微分，需先定义正向函数<code>forward_fn</code>，使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUudmFsdWVfYW5kX2dyYWQuaHRtbA==\">value_and_grad<i class=\"fa fa-external-link-alt\"></i></span>获得微分函数<code>grad_fn</code>。然后，我们将微分函数和优化器的执行封装为<code>train_step</code>函数，接下来循环迭代数据集进行训练即可。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    logits = model(data)</span><br><span class=\"line\">    loss = loss_fn(logits, label)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, logits</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get gradient function</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, optimizer.parameters, has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Define function of one-step training</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_step</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    (loss, _), grads = grad_fn(data, label)</span><br><span class=\"line\">    optimizer(grads)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_loop</span>(<span class=\"params\">model, dataset</span>):</span><br><span class=\"line\">    size = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> batch, (data, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        loss = train_step(data, label)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> batch % <span class=\"number\">100</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            loss, current = loss.asnumpy(), batch</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;loss: <span class=\"subst\">&#123;loss:&gt;7f&#125;</span>  [<span class=\"subst\">&#123;current:&gt;3d&#125;</span>/<span class=\"subst\">&#123;size:&gt;3d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p><code>test_loop</code>函数同样需循环遍历数据集，调用模型计算loss和Accuray并返回最终结果。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_loop</span>(<span class=\"params\">model, dataset, loss_fn</span>):</span><br><span class=\"line\">    num_batches = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\">    total, test_loss, correct = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> dataset.create_tuple_iterator():</span><br><span class=\"line\">        pred = model(data)</span><br><span class=\"line\">        total += <span class=\"built_in\">len</span>(data)</span><br><span class=\"line\">        test_loss += loss_fn(pred, label).asnumpy()</span><br><span class=\"line\">        correct += (pred.argmax(<span class=\"number\">1</span>) == label).asnumpy().<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">    test_loss /= num_batches</span><br><span class=\"line\">    correct /= total</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Test: \\n Accuracy: <span class=\"subst\">&#123;(<span class=\"number\">100</span>*correct):&gt;<span class=\"number\">0.1</span>f&#125;</span>%, Avg loss: <span class=\"subst\">&#123;test_loss:&gt;8f&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>我们将实例化的损失函数和优化器传入<code>train_loop</code>和<code>test_loop</code>中。训练3轮并输出loss和Accuracy，查看性能变化。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(epochs):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Epoch <span class=\"subst\">&#123;t+<span class=\"number\">1</span>&#125;</span>\\n-------------------------------&quot;</span>)</span><br><span class=\"line\">    train_loop(model, train_dataset)</span><br><span class=\"line\">    test_loop(model, test_dataset, loss_fn)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Epoch 1</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 2.302806  [  0/938]</span><br><span class=\"line\">loss: 2.285086  [100/938]</span><br><span class=\"line\">loss: 2.264712  [200/938]</span><br><span class=\"line\">loss: 2.174010  [300/938]</span><br><span class=\"line\">loss: 1.931853  [400/938]</span><br><span class=\"line\">loss: 1.340721  [500/938]</span><br><span class=\"line\">loss: 0.953515  [600/938]</span><br><span class=\"line\">loss: 0.756860  [700/938]</span><br><span class=\"line\">loss: 0.756263  [800/938]</span><br><span class=\"line\">loss: 0.463846  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 84.7%, Avg loss: 0.527155</span><br><span class=\"line\"></span><br><span class=\"line\">Epoch 2</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 0.479126  [  0/938]</span><br><span class=\"line\">loss: 0.437443  [100/938]</span><br><span class=\"line\">loss: 0.685504  [200/938]</span><br><span class=\"line\">loss: 0.395121  [300/938]</span><br><span class=\"line\">loss: 0.550566  [400/938]</span><br><span class=\"line\">loss: 0.459457  [500/938]</span><br><span class=\"line\">loss: 0.293049  [600/938]</span><br><span class=\"line\">loss: 0.422102  [700/938]</span><br><span class=\"line\">loss: 0.333153  [800/938]</span><br><span class=\"line\">loss: 0.412182  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 90.5%, Avg loss: 0.335083</span><br><span class=\"line\"></span><br><span class=\"line\">Epoch 3</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 0.207366  [  0/938]</span><br><span class=\"line\">loss: 0.343559  [100/938]</span><br><span class=\"line\">loss: 0.391145  [200/938]</span><br><span class=\"line\">loss: 0.317566  [300/938]</span><br><span class=\"line\">loss: 0.200746  [400/938]</span><br><span class=\"line\">loss: 0.445798  [500/938]</span><br><span class=\"line\">loss: 0.603720  [600/938]</span><br><span class=\"line\">loss: 0.170811  [700/938]</span><br><span class=\"line\">loss: 0.411954  [800/938]</span><br><span class=\"line\">loss: 0.315902  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 91.9%, Avg loss: 0.279034</span><br><span class=\"line\"></span><br><span class=\"line\">Done!</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>读者可以修改参数多跑几边，观察数据的变化，不懂随机梯度下降算法或不懂正向反向传播、学习率乃至超参的概念可以回顾之前文章中提到的视频并重复观看之前的文章，这几个概念应该比较好理解。</p>\r\n","length":1864,"excerpt":"<h2 id=\"模型训练\">模型训练</h2>\r\n<p>本片涉及大量之前提到概念的定义以及大量引用MindSpore官方文档。原文传送门：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RyYWluLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h3 id=\"四个步骤\">四个步骤</h3>\r\n<ol type=\"1\">\r\n<li>构建数据集。</li>\r\n<li>定义神经网络模型。</li>\r\n<li>定义超参、损失函数及优化器。</li>\r\n<li>输入数据集进行训练与评估。</li>\r\n</ol>\r\n<p>现在我们有了数据集和模型后，可以进行模型的训练与评估。</p>\r\n<h3 id=\"构建数据集\">构建数据集</h3>\r\n<p>从dataset加载代码，构建数据集</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def datapipe(path, batch_size):</span><br><span class=\"line\">    image_transforms = [</span><br><span class=\"line\">        vision.Rescale(1.0 / 255.0, 0),</span><br><span class=\"line\">        vision.Normalize(mean=(0.1307,), std=(0.3081,)),</span><br><span class=\"line\">        vision.HWC2CHW()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    label_transform = transforms.TypeCast(mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\">    dataset = MnistDataset(path)</span><br><span class=\"line\">    dataset = dataset.map(image_transforms, &#x27;image&#x27;)</span><br><span class=\"line\">    dataset = dataset.map(label_transform, &#x27;label&#x27;)</span><br><span class=\"line\">    dataset = dataset.batch(batch_size)</span><br><span class=\"line\">    return dataset</span><br><span class=\"line\"></span><br><span class=\"line\">train_dataset = datapipe(&#x27;MNIST_Data/train&#x27;, batch_size=64)</span><br><span class=\"line\">test_dataset = datapipe(&#x27;MNIST_Data/test&#x27;, batch_size=64)</span><br></pre></td></tr></table></figure>\r\n<p><em>class</em>mindspore.dataset.vision.HWC2CHW</p>\r\n<p>将输入图像的shape从 &lt;H, W, C&gt; 转换为 &lt;C, H, W&gt;。\r\n如果输入图像的shape为 &lt;H, W&gt; ，图像将保持不变。</p>\r\n<p>异常处理</p>\r\n<ul>\r\n<li><strong>RuntimeError</strong> - 如果输入图像的shape不是 &lt;H, W&gt;\r\n或 &lt;H, W, C&gt;。</li>\r\n</ul>\r\n<p><em>class</em>mindspore.nn.<strong>ReLU</strong></p>\r\n<p>逐元素求 max(0,𝑥) 。</p>\r\n<ul>\r\n<li><strong>x</strong> (Tensor) -\r\n用于计算<strong>ReLU</strong>的任意维度的Tensor。数据类型为 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZHR5cGUuaHRtbCNtaW5kc3BvcmUuZHR5cGU=\">number<i class=\"fa fa-external-link-alt\"></i></span>。</li>\r\n</ul>\r\n<h3 id=\"定义神经网络模型\">定义神经网络模型</h3>\r\n<blockquote>\r\n<p>从<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL21vZGVsLmh0bWw=\">网络构建<i class=\"fa fa-external-link-alt\"></i></span>中加载代码，构建一个神经网络模型。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"定义超参损失函数和优化器\">定义超参、损失函数和优化器</h3>\r\n<h4 id=\"超参\">超参</h4>\r\n<p>超参（Hyperparameters）是可以调整的参数，可以控制模型训练优化的过程，不同的超参数值可能会影响模型训练和收敛速度。目前深度学习模型多采用批量随机梯度下降算法进行优化，随机梯度下降算法的原理如下：\r\n<span class=\"math display\">\\[\r\nw_{t+1}=w_{t}-\\eta \\frac{1}{n} \\sum_{x \\in \\mathcal{B}} \\nabla l\\left(x,\r\nw_{t}\\right)\r\n\\]</span> 公式中，𝑛是批量大小（batch size），𝜂是学习率（learning\r\nrate）。另外，𝑤𝑡为训练轮次𝑡中的权重参数，∇𝑙为损失函数的导数。除了梯度本身，这两个因子直接决定了模型的权重更新，从优化本身来看，它们是影响模型性能收敛最重要的参数。一般会定义以下超参用于训练：</p>\r\n<ul>\r\n<li><strong>训练轮次（epoch）</strong>：训练时遍历数据集的次数。</li>\r\n<li><strong>批次大小（batch\r\nsize）</strong>：数据集进行分批读取训练，设定每个批次数据的大小。batch\r\nsize过小，花费时间多，同时梯度震荡严重，不利于收敛；batch\r\nsize过大，不同batch的梯度方向没有任何变化，容易陷入局部极小值，因此需要选择合适的batch\r\nsize，可以有效提高模型精度、全局收敛。</li>\r\n<li><strong>学习率（learning\r\nrate）</strong>：如果学习率偏小，会导致收敛的速度变慢，如果学习率偏大，则可能会导致训练不收敛等不可预测的结果。梯度下降法被广泛应用在最小化模型误差的参数优化算法上。梯度下降法通过多次迭代，并在每一步中最小化损失函数来预估模型的参数。学习率就是在迭代过程中，会控制模型的学习进度。</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">epochs = <span class=\"number\">3</span></span><br><span class=\"line\">batch_size = <span class=\"number\">64</span></span><br><span class=\"line\">learning_rate = <span class=\"number\">1e-2</span></span><br></pre></td></tr></table></figure>\r\n<h4 id=\"损失函数\">损失函数</h4>\r\n<p>损失函数（loss\r\nfunction）用于评估模型的预测值（logits）和目标值（targets）之间的误差。训练模型时，随机初始化的神经网络模型开始时会预测出错误的结果。损失函数会评估预测结果与目标值的相异程度，模型训练的目标即为降低损失函数求得的误差。</p>\r\n<p>常见的损失函数包括用于回归任务的<code>nn.MSELoss</code>（均方误差）和用于分类的<code>nn.NLLLoss</code>（负对数似然）等。\r\n<code>nn.CrossEntropyLoss</code>\r\n结合了<code>nn.LogSoftmax</code>和<code>nn.NLLLoss</code>，可以对logits\r\n进行归一化并计算预测误差。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"优化器\">优化器</h4>\r\n<p>模型优化（Optimization）是在每个训练步骤中调整模型参数以减少模型误差的过程。MindSpore提供多种优化算法的实现，称之为优化器（Optimizer）。优化器内部定义了模型的参数优化过程（即梯度如何更新至模型参数），所有优化逻辑都封装在优化器对象中。在这里，我们使用SGD（Stochastic\r\nGradient Descent）优化器。</p>\r\n<p>我们通过<code>model.trainable_params()</code>方法获得模型的可训练参数，并传入学习率超参来初始化优化器。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)</span><br></pre></td></tr></table></figure>\r\n<p><em>class</em>mindspore.experimental.optim.<strong>SGD</strong>(<em>params</em>,\r\n<em>lr</em>, <em>momentum=0</em>, <em>dampening=0</em>,\r\n<em>weight_decay=0</em>, <em>nesterov=False</em>, **<em>,\r\n</em>maximize=False*)</p>\r\n<p>随机梯度下降算法。 <span class=\"math display\">\\[\r\nv_{t+1} = u \\ast v_{t} + gradient \\ast (1-dampening)\r\n\\]</span> 如果nesterov为True： <span class=\"math display\">\\[\r\np_{t+1} = p_{t} - lr \\ast (gradient + u \\ast v_{t+1})\r\n\\]</span> 如果nesterov为False： <span class=\"math display\">\\[\r\np_{t+1} = p_{t} - lr \\ast v_{t+1}\r\n\\]</span> 需要注意的是，对于训练的第一步\r\n𝑣𝑡+1=𝑔𝑟𝑎𝑑𝑖𝑒𝑛𝑡。其中，p、v和u分别表示 parameters、accum 和 momentum。</p>\r\n<h4 id=\"训练与评估\">训练与评估</h4>\r\n<p>设置了超参、损失函数和优化器后，我们就可以循环输入数据来训练模型。一次数据集的完整迭代循环称为一轮（epoch）。每轮执行训练时包括两个步骤：</p>\r\n<ol type=\"1\">\r\n<li>训练：迭代训练数据集，并尝试收敛到最佳参数。</li>\r\n<li>验证/测试：迭代测试数据集，以检查模型性能是否提升。</li>\r\n</ol>\r\n<p>接下来我们定义用于训练的<code>train_loop</code>函数和用于测试的<code>test_loop</code>函数。</p>\r\n<p>使用函数式自动微分，需先定义正向函数<code>forward_fn</code>，使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUudmFsdWVfYW5kX2dyYWQuaHRtbA==\">value_and_grad<i class=\"fa fa-external-link-alt\"></i></span>获得微分函数<code>grad_fn</code>。然后，我们将微分函数和优化器的执行封装为<code>train_step</code>函数，接下来循环迭代数据集进行训练即可。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    logits = model(data)</span><br><span class=\"line\">    loss = loss_fn(logits, label)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, logits</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get gradient function</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, optimizer.parameters, has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Define function of one-step training</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_step</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    (loss, _), grads = grad_fn(data, label)</span><br><span class=\"line\">    optimizer(grads)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_loop</span>(<span class=\"params\">model, dataset</span>):</span><br><span class=\"line\">    size = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> batch, (data, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        loss = train_step(data, label)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> batch % <span class=\"number\">100</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            loss, current = loss.asnumpy(), batch</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;loss: <span class=\"subst\">&#123;loss:&gt;7f&#125;</span>  [<span class=\"subst\">&#123;current:&gt;3d&#125;</span>/<span class=\"subst\">&#123;size:&gt;3d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p><code>test_loop</code>函数同样需循环遍历数据集，调用模型计算loss和Accuray并返回最终结果。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_loop</span>(<span class=\"params\">model, dataset, loss_fn</span>):</span><br><span class=\"line\">    num_batches = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\">    total, test_loss, correct = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> dataset.create_tuple_iterator():</span><br><span class=\"line\">        pred = model(data)</span><br><span class=\"line\">        total += <span class=\"built_in\">len</span>(data)</span><br><span class=\"line\">        test_loss += loss_fn(pred, label).asnumpy()</span><br><span class=\"line\">        correct += (pred.argmax(<span class=\"number\">1</span>) == label).asnumpy().<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">    test_loss /= num_batches</span><br><span class=\"line\">    correct /= total</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Test: \\n Accuracy: <span class=\"subst\">&#123;(<span class=\"number\">100</span>*correct):&gt;<span class=\"number\">0.1</span>f&#125;</span>%, Avg loss: <span class=\"subst\">&#123;test_loss:&gt;8f&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>我们将实例化的损失函数和优化器传入<code>train_loop</code>和<code>test_loop</code>中。训练3轮并输出loss和Accuracy，查看性能变化。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(epochs):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Epoch <span class=\"subst\">&#123;t+<span class=\"number\">1</span>&#125;</span>\\n-------------------------------&quot;</span>)</span><br><span class=\"line\">    train_loop(model, train_dataset)</span><br><span class=\"line\">    test_loop(model, test_dataset, loss_fn)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Epoch 1</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 2.302806  [  0/938]</span><br><span class=\"line\">loss: 2.285086  [100/938]</span><br><span class=\"line\">loss: 2.264712  [200/938]</span><br><span class=\"line\">loss: 2.174010  [300/938]</span><br><span class=\"line\">loss: 1.931853  [400/938]</span><br><span class=\"line\">loss: 1.340721  [500/938]</span><br><span class=\"line\">loss: 0.953515  [600/938]</span><br><span class=\"line\">loss: 0.756860  [700/938]</span><br><span class=\"line\">loss: 0.756263  [800/938]</span><br><span class=\"line\">loss: 0.463846  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 84.7%, Avg loss: 0.527155</span><br><span class=\"line\"></span><br><span class=\"line\">Epoch 2</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 0.479126  [  0/938]</span><br><span class=\"line\">loss: 0.437443  [100/938]</span><br><span class=\"line\">loss: 0.685504  [200/938]</span><br><span class=\"line\">loss: 0.395121  [300/938]</span><br><span class=\"line\">loss: 0.550566  [400/938]</span><br><span class=\"line\">loss: 0.459457  [500/938]</span><br><span class=\"line\">loss: 0.293049  [600/938]</span><br><span class=\"line\">loss: 0.422102  [700/938]</span><br><span class=\"line\">loss: 0.333153  [800/938]</span><br><span class=\"line\">loss: 0.412182  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 90.5%, Avg loss: 0.335083</span><br><span class=\"line\"></span><br><span class=\"line\">Epoch 3</span><br><span class=\"line\">-------------------------------</span><br><span class=\"line\">loss: 0.207366  [  0/938]</span><br><span class=\"line\">loss: 0.343559  [100/938]</span><br><span class=\"line\">loss: 0.391145  [200/938]</span><br><span class=\"line\">loss: 0.317566  [300/938]</span><br><span class=\"line\">loss: 0.200746  [400/938]</span><br><span class=\"line\">loss: 0.445798  [500/938]</span><br><span class=\"line\">loss: 0.603720  [600/938]</span><br><span class=\"line\">loss: 0.170811  [700/938]</span><br><span class=\"line\">loss: 0.411954  [800/938]</span><br><span class=\"line\">loss: 0.315902  [900/938]</span><br><span class=\"line\">Test:</span><br><span class=\"line\"> Accuracy: 91.9%, Avg loss: 0.279034</span><br><span class=\"line\"></span><br><span class=\"line\">Done!</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>读者可以修改参数多跑几边，观察数据的变化，不懂随机梯度下降算法或不懂正向反向传播、学习率乃至超参的概念可以回顾之前文章中提到的视频并重复观看之前的文章，这几个概念应该比较好理解。</p>"},{"title":"MindSpore专题","date":"2024-08-14T11:47:58.000Z","_content":"[MindSpore](https://www.mindspore.cn/tutorials/zh-CN/r2.3.0rc2/beginner/quick_start.html)\n\n<!--more-->\n\n## MindSpore 数据处理\n\n### download\n\n```shell\npip install download\n```\n\n下载download python模块\n\n### 引包并下载所需数据集\n\n```python\nimport mindspore\nfrom mindspore import nn\nfrom mindspore.dataset import vision, transforms\nfrom mindspore.dataset import MnistDataset\n```\n\n```python\n# Download data from open datasets\nfrom download import download\n\nurl = \"https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/\" \\\n      \"notebook/datasets/MNIST_Data.zip\"\npath = download(url, \"./\", kind=\"zip\", replace=True)\n```\n\n![image-20240605204942126](https://s2.loli.net/2024/06/05/EuK87I6YUjdAs2v.png)\n\n下载下来MNIST_Data数据，根据官网这是一份Mnist数据集，结构如下\n\n```\nMNIST_Data\n└── train\n    ├── train-images-idx3-ubyte (60000个训练图片)\n    ├── train-labels-idx1-ubyte (60000个训练标签)\n└── test\n    ├── t10k-images-idx3-ubyte (10000个测试图片)\n    ├── t10k-labels-idx1-ubyte (10000个测试标签)\n```\n\n### MindSpore数据处理\n\n```python\nprint(train_dataset.get_col_names())\n```\n\n打印数据集中所包含的数据列名\n\n> MindSpore的dataset使用数据处理流水线（Data Processing Pipeline），需指定map、batch、shuffle等操作。这里我们使用map对图像数据及标签进行变换处理，将输入的图像缩放为1/255，根据均值0.1307和标准差值0.3081进行归一化处理，然后将处理好的数据集打包为大小为64的batch。\n\n上面是官网对以下代码的处理。\n\n其中出现了一个新名词——[归一化处理](#归一化处理)，这里使用的是Z-score normalization。\n\n```python\ndef datapipe(dataset, batch_size):\n    image_transforms = [\n        vision.Rescale(1.0 / 255.0, 0),\n        vision.Normalize(mean=(0.1307,), std=(0.3081,)),\n        vision.HWC2CHW()\n    ]\n    label_transform = transforms.TypeCast(mindspore.int32)\n\n    dataset = dataset.map(image_transforms, 'image')\n    dataset = dataset.map(label_transform, 'label')\n    dataset = dataset.batch(batch_size)\n    return dataset\n\n\n# Map vision transforms and batch dataset\ntrain_dataset = datapipe(train_dataset, 64)\ntest_dataset = datapipe(test_dataset, 64)\n```\n\n---\n\n可使用[create_tuple_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_tuple_iterator.html) 或[create_dict_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_dict_iterator.html)对数据集进行迭代访问，查看数据和标签的shape和datatype。\n\n```python\nfor image, label in test_dataset.create_tuple_iterator():\n    print(f\"Shape of image [N, C, H, W]: {image.shape} {image.dtype}\")\n    print(f\"Shape of label: {label.shape} {label.dtype}\")\n    break\n```\n\n>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32\n>Shape of label: (64,) Int32\n\n```python\nfor data in test_dataset.create_dict_iterator():\n    print(f\"Shape of image [N, C, H, W]: {data['image'].shape} {data['image'].dtype}\")\n    print(f\"Shape of label: {data['label'].shape} {data['label'].dtype}\")\n    break\n```\n\n> Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32\n> Shape of label: (64,) Int32\n\n更多细节详见[数据集 Dataset](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/dataset.html)与[数据变换 Transforms](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/transforms.html)。\n\n### 网络构建\n\n```python\n# Define model\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512),\n            nn.ReLU(),\n            nn.Dense(512, 512),\n            nn.ReLU(),\n            nn.Dense(512, 10)\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\nmodel = Network()\nprint(model)\n```\n\n> Network<\n>   (flatten): Flatten<>\n>   (dense_relu_sequential): SequentialCell<\n>     (0): Dense<input_channels=784, output_channels=512, has_bias=True>\n>     (1): ReLU<>\n>     (2): Dense<input_channels=512, output_channels=512, has_bias=True>\n>     (3): ReLU<>\n>     (4): Dense<input_channels=512, output_channels=10, has_bias=True>\n>     >\n\n以上为网格的构建以及其输出，有以下几点需要注意\n\n1. 上面重命名过MindSpore中的nn类是构建所有网格的基类，也是网格的基本单元\n2. 当需要自定义网络时可以重写``nn.Cell`类重写`__init__`方法和`construct`方法\n3. `__init__`包含所有网络层的定义`construct`中包含数据（[Tensor](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/tensor.html)）的变换过程\n\n> `mindspore.nn`类是构建所有网络的基类，也是网络的基本单元。当用户需要自定义网络时，可以继承`nn.Cell`类，并重写`__init__`方法和`construct`方法。`__init__`包含所有网络层的定义，`construct`中包含数据（[Tensor](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/tensor.html)）的变换过程。\n\n### 模型训练\n\n个人菜狗形象的想，实际上这里的网格神经网络对图像的识别类似一种带指向的可变哈希函数（只不过这个函数的实现比较复杂和通用）。他是从大量信息到小量准确抽象的描述过程。下面是[3.2. 机器学习工作流 — 机器学习系统：设计和实现 1.0.0 documentation (openmlsys.github.io)](https://openmlsys.github.io/chapter_programming_interface/ml_workflow.html)手册上的机器学习流程图，这里以求形象的理解\n\n![img_workflow](./../img/img_workflow.svg)\n\n> 在模型训练中，一个完整的训练过程（step）需要实现以下三步：\n>\n> 1. **正向计算**：模型预测结果（logits），并与正确标签（label）求预测损失（loss）。\n> 2. **反向传播**：利用自动微分机制，自动求模型参数（parameters）对于loss的梯度（gradients）。\n> 3. **参数优化**：将梯度更新到参数上。\n\n> MindSpore使用函数式自动微分机制，因此针对上述步骤需要实现：\n>\n> 1. 定义正向计算函数。\n> 2. 使用[value_and_grad](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.value_and_grad.html)通过函数变换获得梯度计算函数。\n> 3. 定义训练函数，使用[set_train](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Cell.html#mindspore.nn.Cell.set_train)设置为训练模式，执行正向计算、反向传播和参数优化。\n\n```python\n# Instantiate loss function and optimizer\nloss_fn = nn.CrossEntropyLoss()\noptimizer = nn.SGD(model.trainable_params(), 1e-2)\n\n# 1. Define forward function\ndef forward_fn(data, label):\n    logits = model(data)\n    loss = loss_fn(logits, label)\n    return loss, logits\n\n# 2. Get gradient function\ngrad_fn = mindspore.value_and_grad(forward_fn, None, optimizer.parameters, has_aux=True)\n\n# 3. Define function of one-step training\ndef train_step(data, label):\n    (loss, _), grads = grad_fn(data, label)\n    optimizer(grads)\n    return loss\n\ndef train(model, dataset):\n    size = dataset.get_dataset_size()\n    model.set_train()\n    for batch, (data, label) in enumerate(dataset.create_tuple_iterator()):\n        loss = train_step(data, label)\n\n        if batch % 100 == 0:\n            loss, current = loss.asnumpy(), batch\n            print(f\"loss: {loss:>7f}  [{current:>3d}/{size:>3d}]\")\n```\n\n> 除训练外，我们定义测试函数，用来评估模型的性能。\n\n```python\ndef test(model, dataset, loss_fn):\n    num_batches = dataset.get_dataset_size()\n    model.set_train(False)\n    total, test_loss, correct = 0, 0, 0\n    for data, label in dataset.create_tuple_iterator():\n        pred = model(data)\n        total += len(data)\n        test_loss += loss_fn(pred, label).asnumpy()\n        correct += (pred.argmax(1) == label).asnumpy().sum()\n    test_loss /= num_batches\n    correct /= total\n    print(f\"Test: \\n Accuracy: {(100*correct):>0.1f}%, Avg loss: {test_loss:>8f} \\n\")\n```\n\n> 训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。\n\n```python\nepochs = 3\nfor t in range(epochs):\n    print(f\"Epoch {t+1}\\n-------------------------------\")\n    train(model, train_dataset)\n    test(model, test_dataset, loss_fn)\nprint(\"Done!\")\n```\n\n>```\n>Epoch 1\n>-------------------------------\n>loss: 2.302088  [  0/938]\n>loss: 2.290692  [100/938]\n>loss: 2.266338  [200/938]\n>loss: 2.205240  [300/938]\n>loss: 1.907198  [400/938]\n>loss: 1.455603  [500/938]\n>loss: 0.861103  [600/938]\n>loss: 0.767219  [700/938]\n>loss: 0.422253  [800/938]\n>loss: 0.513922  [900/938]\n>Test:\n> Accuracy: 83.8%, Avg loss: 0.529534\n>\n>Epoch 2\n>-------------------------------\n>loss: 0.580867  [  0/938]\n>loss: 0.479347  [100/938]\n>loss: 0.677991  [200/938]\n>loss: 0.550141  [300/938]\n>loss: 0.226565  [400/938]\n>loss: 0.314738  [500/938]\n>loss: 0.298739  [600/938]\n>loss: 0.459540  [700/938]\n>loss: 0.332978  [800/938]\n>loss: 0.406709  [900/938]\n>Test:\n> Accuracy: 90.2%, Avg loss: 0.334828\n>\n>Epoch 3\n>-------------------------------\n>loss: 0.461890  [  0/938]\n>loss: 0.242303  [100/938]\n>loss: 0.281414  [200/938]\n>loss: 0.207835  [300/938]\n>loss: 0.206000  [400/938]\n>loss: 0.409646  [500/938]\n>loss: 0.193608  [600/938]\n>loss: 0.217575  [700/938]\n>loss: 0.212817  [800/938]\n>loss: 0.202862  [900/938]\n>Test:\n> Accuracy: 91.9%, Avg loss: 0.280962\n>\n>Done!\n>```\n\n> 训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。\n\n### 保存模型\n\n模型训练完成后，需要将其参数进行保存。\n\n```python\n# Save checkpoint\nmindspore.save_checkpoint(model, \"model.ckpt\")\nprint(\"Saved Model to model.ckpt\")\n```\n\n> Saved Model to model.ckpt\n\n### 加载模型\n\n> 加载保存的权重分为两步：\n>\n> 1. 重新实例化模型对象，构造模型。\n> 2. 加载模型参数，并将其加载至模型上。\n\n```python\n# Instantiate a random initialized model\nmodel = Network()\n# Load checkpoint and load parameter to model\nparam_dict = mindspore.load_checkpoint(\"model.ckpt\")\nparam_not_load, _ = mindspore.load_param_into_net(model, param_dict)\nprint(param_not_load)\n```\n\n> `param_not_load未被加载的参数列表，为空时代表所有参数均加载成功。`\n\n> 加载后的模型可以直接用于预测推理。\n\n```python\nmodel.set_train(False)\nfor data, label in test_dataset:\n    pred = model(data)\n    predicted = pred.argmax(1)\n    print(f'Predicted: \"{predicted[:10]}\", Actual: \"{label[:10]}\"')\n    break\n```\n\n以上就是一个简单的图像识别机械学习\n\n**注意在加载模型的过程中必须定义模型构建与datapipe**\n\n## 归一化处理\n\n> 一些传送门：\n> [归一化基础知识点 — PaddleEdu documentation (paddlepedia.readthedocs.io)](https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/normalization/basic_normalization.html)\n>\n> [Numpy数组归一化|极客教程 (geek-docs.com)](https://geek-docs.com/numpy/numpy-ask-answer/normalize-numpy-array_z1.html)\n\n归一化是一种数据处理方式，能将数据经过处理后限制在某个固定范围内。\n\n### 归一化处理的两种形式\n\n归一化存在两种形式\n\n1. 将数处理为 [0, 1] 之间的小数，其目的是为了在随后的数据处理过程中更便捷，其他情况下，也可将数据处理到 [-1, 1] 之间，或其他的固定范围内。\n\n> 例如，在图像处理中，就会将图像从 [0, 255] 归一化到 [0, 1]之间，这样既不会改变图像本身的信息储存，又可加速后续的网络处理。\n\n2. 通过归一化将有[量纲表达式](#有/无量纲表达式)变成[无量纲表达式](#有/无量纲表达式)。\n\n### 为什么要进行归一化\n\n1. 解决数据间的可比性问题\n2. 数据归一化后，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。[为什么能提高收敛速度](为什么归一化能提高求解最优解的速度).\n\n### 归一化类型\n\n1. Min-max normalization (Rescaling) 范围为[0,1]:\n\n$$\nx^{'} = \\frac{x - min(x)}{max(x) - min(x)}\n$$\n\n2. Mean normalization范围为[-1,1]：\n\n$$\nx^{'} = \\frac{x - mean(x)}{max(x) - min(x)}\n$$\n\n> mean(x)：x数据的平均值\n\n​\tMin-max归一化和mean归一化适合在最大最小值明确不变的情况下使用，比如图像处理时，灰度值限定在 [0, 255] 的范围内，就可以用min-max归一化将其处理到[0, 1]之间。在最大最小值不明确时，每当有新数据加入，都可能会改变最大或最小值，导致归一化结果不稳定，后续使用效果也不稳定。同时，数据需要相对稳定，如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。如果对处理后的数据范围有严格要求，也应使用min-max归一化或mean归一化。\n\n3. Z-score normalization (Standardization)范围为实数集：\n\n$$\nx^{'} = \\frac{x - \\mu}{\\sigma}\n$$\n\n> 𝜇、𝜎 分别为样本数据的均值和标准差。\n\n​\tZ-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。标准化会改变数据的状态分布，但不会改变分布的种类。特别地，神经网络中经常会使用到z-score归一化，针对这一点，我们将在后续的文章中进行详细的介绍。\n\n4. 对数归一化：\n\n$$\nx^{'} = \\frac{\\lg x}{\\lg max(x)}\n$$\n\n5. 反正切函数归一化：\n\n$$\nx^{'} = \\arctan(x) * \\frac{2}{\\pi}\n$$\n\n6. 小数定标标准化（Demical Point Normalization）:\n\n$$\nx^{'} = \\frac{x}{10^j}\n$$\n\n​\t非线性归一化通常被用在数据分化程度较大的场景，有时需要通过一些数学函数对原始值进行映射，如对数、反正切等。\n\n### 归一化和标准化的联系与区别\n\n谈到归一化和标准化可能会存在一些概念的混淆，我们都知道归一化是指normalization，标准化是指standardization，但根据wiki上对feature scaling方法的定义，standardization其实就是z-score normalization，也就是说标准化其实是归一化的一种，而一般情况下，我们会把z-score归一化称为标准化，把min-max归一化简称为归一化。在下文中，我们也是用标准化指代z-score归一化，并使用归一化指代min-max归一化。\n\n其实，归一化和标准化在本质上都是一种线性变换。在[归一化类型](#归一化类型)中，我们提到了归一化和标准化的公式，对于归一化的公式，在数据给定的情况下，可以令𝑎=𝑚𝑎𝑥(𝑥)−𝑚𝑖𝑛(𝑥)、𝑏=𝑚𝑖𝑛(𝑥)，则归一化的公式可变形为：\n$$\nx^{'} = \\frac{x - b}{a} = \\frac{x}{a} - \\frac{b}{a} = \\frac{x}{a} - c\n$$\n标准化的公式与变形后的归一化类似，其中的$\\mu $和$\\sigma$在数据给定的情况下，可以看作常数。因此，标准化的变形与归一化的类似，都可看作对𝑥按比例𝑎进行缩放，再进行𝑐个单位的平移。由此可见，归一化和标准化的本质都是一种线性变换，他们都不会因为对数据的处理而改变数据的原始数值排序。\n\n那么归一化和标准化又有什么区别呢？\n\n1. 归一化不会改变数据的状态分布，但标准化会改变数据的状态分布；\n2. 归一化会将数据限定在一个具体的范围内，如 [0, 1]，但标准化不会，标准化只会将数据处理为均值为0，标准差为1。\n\n### 为什么归一化能提高求解最优解的速度\n\n$$\n\\begin{split}\n\\begin{align}\ny &= \\theta_1x_1 + \\theta_2x_2 \\\\\nJ &= (\\theta_{1}x_{1} + \\theta_{2}x_{2} - y_{label})^2\n\\end{align}\n\\end{split}\n$$\n\n假设自变量只有房子到地铁站的距离$$𝑥_1$$和房子内房间的个数$$𝑥_2$$，因变量为房价，预测公式和损失函数分别为：\n\n$$\nJ = (1000\\theta_{1}+3\\theta_{2} - y_{label})^2\n$$\n\n![normalization](https://s2.loli.net/2024/06/05/QAonmGKX4FqxUMt.png)\n\n<div align=\"center\">图1: 损失函数的等高线，图1（左）为未归一化时，图1（右）为归一化</div>\n\n​\t在图1中，左图的红色椭圆代表归一化前的损失函数等高线，蓝色线段代表梯度的更新，箭头的方向代表梯度更新的方向。寻求最优解的过程就是梯度更新的过程，其更新方向与登高线垂直。由于𝑥1 和 𝑥2 的量级相差过大，损失函数的等高线呈现为一个瘦窄的椭圆。因此如图1（左）所示，瘦窄的椭圆形会使得梯度下降过程呈之字形呈现，导致梯度下降速度缓慢。\n\n​\t当数据经过归一化后，$x_{1}^{'} = \\frac{1000-0}{5000-0}=0.2$，$x_{2}^{'} = \\frac{3-0}{10-0}=0.3$，那么损失函数的公式可以写为：\n$$\nJ(x) = (0.2\\theta_{1} + 0.3\\theta_{2} - y_{label})^2\n$$\n​\t我们可以看到，经过归一化后的数据属于同一量级，损失函数的等高线呈现为一个矮胖的椭圆形（如图1（右）所示），求解最优解过程变得更加迅速且平缓，因此可以在通过梯度下降进行求解时获得更快的收敛。\n\n## 有/无量纲表达式\n\n我们假定数据都是一个个变量（不过提前收集好了）量纲指有些未知数他们是变量存在的一种或几种依赖关系，该变量的值由这些依赖关系的未知数（量纲）决定。\n\n>  就像一些函数的y值，理想状态下的房价，他们由x，面积/位置决定。\n\n显然位置差几百米，面积差几百平方米对变量影响差距极大，这种情况下我们称对这些依赖关系式是有量纲的。他们对变量影响的系数存在数量级的不同。\n\n## 常见问题\n\n1. vscode 出现python解释器的选择错误，这在windows经常有非常多版本的相同软件上经常出现，选定安装MindSpore库的python版本\n\n![image-20240605210110827](https://s2.loli.net/2024/06/05/QSIFMsjBCUAo34y.png)\n\n​\t点击此处python版本即可\n\n2. 注意python的多数语法检查集成已分离为插件，一些在2023.10发布，发布后一些网络上的blog修改linting的将禁用，详情请看[迁移到 Python 工具扩展 ·microsoft/vscode-python 维基 (github.com)](https://github.com/microsoft/vscode-python/wiki/Migration-to-Python-Tools-Extensions)\n\n3. 解决一些格式上的报错也可以不理会，但根据PEP 8 python规范，一行不能超过80个字符，同时换行需要缩进,如果看不管可以在扩展语法检查中增加args\n\n```\n--max-line-length=120\n```\n\n","source":"_posts/special_subject/MindSpore/Chapters/Second_TryMindSpore.md","raw":"---\ntitle: MindSpore专题\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n[MindSpore](https://www.mindspore.cn/tutorials/zh-CN/r2.3.0rc2/beginner/quick_start.html)\n\n<!--more-->\n\n## MindSpore 数据处理\n\n### download\n\n```shell\npip install download\n```\n\n下载download python模块\n\n### 引包并下载所需数据集\n\n```python\nimport mindspore\nfrom mindspore import nn\nfrom mindspore.dataset import vision, transforms\nfrom mindspore.dataset import MnistDataset\n```\n\n```python\n# Download data from open datasets\nfrom download import download\n\nurl = \"https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/\" \\\n      \"notebook/datasets/MNIST_Data.zip\"\npath = download(url, \"./\", kind=\"zip\", replace=True)\n```\n\n![image-20240605204942126](https://s2.loli.net/2024/06/05/EuK87I6YUjdAs2v.png)\n\n下载下来MNIST_Data数据，根据官网这是一份Mnist数据集，结构如下\n\n```\nMNIST_Data\n└── train\n    ├── train-images-idx3-ubyte (60000个训练图片)\n    ├── train-labels-idx1-ubyte (60000个训练标签)\n└── test\n    ├── t10k-images-idx3-ubyte (10000个测试图片)\n    ├── t10k-labels-idx1-ubyte (10000个测试标签)\n```\n\n### MindSpore数据处理\n\n```python\nprint(train_dataset.get_col_names())\n```\n\n打印数据集中所包含的数据列名\n\n> MindSpore的dataset使用数据处理流水线（Data Processing Pipeline），需指定map、batch、shuffle等操作。这里我们使用map对图像数据及标签进行变换处理，将输入的图像缩放为1/255，根据均值0.1307和标准差值0.3081进行归一化处理，然后将处理好的数据集打包为大小为64的batch。\n\n上面是官网对以下代码的处理。\n\n其中出现了一个新名词——[归一化处理](#归一化处理)，这里使用的是Z-score normalization。\n\n```python\ndef datapipe(dataset, batch_size):\n    image_transforms = [\n        vision.Rescale(1.0 / 255.0, 0),\n        vision.Normalize(mean=(0.1307,), std=(0.3081,)),\n        vision.HWC2CHW()\n    ]\n    label_transform = transforms.TypeCast(mindspore.int32)\n\n    dataset = dataset.map(image_transforms, 'image')\n    dataset = dataset.map(label_transform, 'label')\n    dataset = dataset.batch(batch_size)\n    return dataset\n\n\n# Map vision transforms and batch dataset\ntrain_dataset = datapipe(train_dataset, 64)\ntest_dataset = datapipe(test_dataset, 64)\n```\n\n---\n\n可使用[create_tuple_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_tuple_iterator.html) 或[create_dict_iterator](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/dataset/dataset_method/iterator/mindspore.dataset.Dataset.create_dict_iterator.html)对数据集进行迭代访问，查看数据和标签的shape和datatype。\n\n```python\nfor image, label in test_dataset.create_tuple_iterator():\n    print(f\"Shape of image [N, C, H, W]: {image.shape} {image.dtype}\")\n    print(f\"Shape of label: {label.shape} {label.dtype}\")\n    break\n```\n\n>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32\n>Shape of label: (64,) Int32\n\n```python\nfor data in test_dataset.create_dict_iterator():\n    print(f\"Shape of image [N, C, H, W]: {data['image'].shape} {data['image'].dtype}\")\n    print(f\"Shape of label: {data['label'].shape} {data['label'].dtype}\")\n    break\n```\n\n> Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32\n> Shape of label: (64,) Int32\n\n更多细节详见[数据集 Dataset](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/dataset.html)与[数据变换 Transforms](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/transforms.html)。\n\n### 网络构建\n\n```python\n# Define model\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.flatten = nn.Flatten()\n        self.dense_relu_sequential = nn.SequentialCell(\n            nn.Dense(28*28, 512),\n            nn.ReLU(),\n            nn.Dense(512, 512),\n            nn.ReLU(),\n            nn.Dense(512, 10)\n        )\n\n    def construct(self, x):\n        x = self.flatten(x)\n        logits = self.dense_relu_sequential(x)\n        return logits\n\nmodel = Network()\nprint(model)\n```\n\n> Network<\n>   (flatten): Flatten<>\n>   (dense_relu_sequential): SequentialCell<\n>     (0): Dense<input_channels=784, output_channels=512, has_bias=True>\n>     (1): ReLU<>\n>     (2): Dense<input_channels=512, output_channels=512, has_bias=True>\n>     (3): ReLU<>\n>     (4): Dense<input_channels=512, output_channels=10, has_bias=True>\n>     >\n\n以上为网格的构建以及其输出，有以下几点需要注意\n\n1. 上面重命名过MindSpore中的nn类是构建所有网格的基类，也是网格的基本单元\n2. 当需要自定义网络时可以重写``nn.Cell`类重写`__init__`方法和`construct`方法\n3. `__init__`包含所有网络层的定义`construct`中包含数据（[Tensor](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/tensor.html)）的变换过程\n\n> `mindspore.nn`类是构建所有网络的基类，也是网络的基本单元。当用户需要自定义网络时，可以继承`nn.Cell`类，并重写`__init__`方法和`construct`方法。`__init__`包含所有网络层的定义，`construct`中包含数据（[Tensor](https://www.mindspore.cn/tutorials/zh-CN/r2.2/beginner/tensor.html)）的变换过程。\n\n### 模型训练\n\n个人菜狗形象的想，实际上这里的网格神经网络对图像的识别类似一种带指向的可变哈希函数（只不过这个函数的实现比较复杂和通用）。他是从大量信息到小量准确抽象的描述过程。下面是[3.2. 机器学习工作流 — 机器学习系统：设计和实现 1.0.0 documentation (openmlsys.github.io)](https://openmlsys.github.io/chapter_programming_interface/ml_workflow.html)手册上的机器学习流程图，这里以求形象的理解\n\n![img_workflow](./../img/img_workflow.svg)\n\n> 在模型训练中，一个完整的训练过程（step）需要实现以下三步：\n>\n> 1. **正向计算**：模型预测结果（logits），并与正确标签（label）求预测损失（loss）。\n> 2. **反向传播**：利用自动微分机制，自动求模型参数（parameters）对于loss的梯度（gradients）。\n> 3. **参数优化**：将梯度更新到参数上。\n\n> MindSpore使用函数式自动微分机制，因此针对上述步骤需要实现：\n>\n> 1. 定义正向计算函数。\n> 2. 使用[value_and_grad](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.value_and_grad.html)通过函数变换获得梯度计算函数。\n> 3. 定义训练函数，使用[set_train](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/nn/mindspore.nn.Cell.html#mindspore.nn.Cell.set_train)设置为训练模式，执行正向计算、反向传播和参数优化。\n\n```python\n# Instantiate loss function and optimizer\nloss_fn = nn.CrossEntropyLoss()\noptimizer = nn.SGD(model.trainable_params(), 1e-2)\n\n# 1. Define forward function\ndef forward_fn(data, label):\n    logits = model(data)\n    loss = loss_fn(logits, label)\n    return loss, logits\n\n# 2. Get gradient function\ngrad_fn = mindspore.value_and_grad(forward_fn, None, optimizer.parameters, has_aux=True)\n\n# 3. Define function of one-step training\ndef train_step(data, label):\n    (loss, _), grads = grad_fn(data, label)\n    optimizer(grads)\n    return loss\n\ndef train(model, dataset):\n    size = dataset.get_dataset_size()\n    model.set_train()\n    for batch, (data, label) in enumerate(dataset.create_tuple_iterator()):\n        loss = train_step(data, label)\n\n        if batch % 100 == 0:\n            loss, current = loss.asnumpy(), batch\n            print(f\"loss: {loss:>7f}  [{current:>3d}/{size:>3d}]\")\n```\n\n> 除训练外，我们定义测试函数，用来评估模型的性能。\n\n```python\ndef test(model, dataset, loss_fn):\n    num_batches = dataset.get_dataset_size()\n    model.set_train(False)\n    total, test_loss, correct = 0, 0, 0\n    for data, label in dataset.create_tuple_iterator():\n        pred = model(data)\n        total += len(data)\n        test_loss += loss_fn(pred, label).asnumpy()\n        correct += (pred.argmax(1) == label).asnumpy().sum()\n    test_loss /= num_batches\n    correct /= total\n    print(f\"Test: \\n Accuracy: {(100*correct):>0.1f}%, Avg loss: {test_loss:>8f} \\n\")\n```\n\n> 训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。\n\n```python\nepochs = 3\nfor t in range(epochs):\n    print(f\"Epoch {t+1}\\n-------------------------------\")\n    train(model, train_dataset)\n    test(model, test_dataset, loss_fn)\nprint(\"Done!\")\n```\n\n>```\n>Epoch 1\n>-------------------------------\n>loss: 2.302088  [  0/938]\n>loss: 2.290692  [100/938]\n>loss: 2.266338  [200/938]\n>loss: 2.205240  [300/938]\n>loss: 1.907198  [400/938]\n>loss: 1.455603  [500/938]\n>loss: 0.861103  [600/938]\n>loss: 0.767219  [700/938]\n>loss: 0.422253  [800/938]\n>loss: 0.513922  [900/938]\n>Test:\n> Accuracy: 83.8%, Avg loss: 0.529534\n>\n>Epoch 2\n>-------------------------------\n>loss: 0.580867  [  0/938]\n>loss: 0.479347  [100/938]\n>loss: 0.677991  [200/938]\n>loss: 0.550141  [300/938]\n>loss: 0.226565  [400/938]\n>loss: 0.314738  [500/938]\n>loss: 0.298739  [600/938]\n>loss: 0.459540  [700/938]\n>loss: 0.332978  [800/938]\n>loss: 0.406709  [900/938]\n>Test:\n> Accuracy: 90.2%, Avg loss: 0.334828\n>\n>Epoch 3\n>-------------------------------\n>loss: 0.461890  [  0/938]\n>loss: 0.242303  [100/938]\n>loss: 0.281414  [200/938]\n>loss: 0.207835  [300/938]\n>loss: 0.206000  [400/938]\n>loss: 0.409646  [500/938]\n>loss: 0.193608  [600/938]\n>loss: 0.217575  [700/938]\n>loss: 0.212817  [800/938]\n>loss: 0.202862  [900/938]\n>Test:\n> Accuracy: 91.9%, Avg loss: 0.280962\n>\n>Done!\n>```\n\n> 训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。\n\n### 保存模型\n\n模型训练完成后，需要将其参数进行保存。\n\n```python\n# Save checkpoint\nmindspore.save_checkpoint(model, \"model.ckpt\")\nprint(\"Saved Model to model.ckpt\")\n```\n\n> Saved Model to model.ckpt\n\n### 加载模型\n\n> 加载保存的权重分为两步：\n>\n> 1. 重新实例化模型对象，构造模型。\n> 2. 加载模型参数，并将其加载至模型上。\n\n```python\n# Instantiate a random initialized model\nmodel = Network()\n# Load checkpoint and load parameter to model\nparam_dict = mindspore.load_checkpoint(\"model.ckpt\")\nparam_not_load, _ = mindspore.load_param_into_net(model, param_dict)\nprint(param_not_load)\n```\n\n> `param_not_load未被加载的参数列表，为空时代表所有参数均加载成功。`\n\n> 加载后的模型可以直接用于预测推理。\n\n```python\nmodel.set_train(False)\nfor data, label in test_dataset:\n    pred = model(data)\n    predicted = pred.argmax(1)\n    print(f'Predicted: \"{predicted[:10]}\", Actual: \"{label[:10]}\"')\n    break\n```\n\n以上就是一个简单的图像识别机械学习\n\n**注意在加载模型的过程中必须定义模型构建与datapipe**\n\n## 归一化处理\n\n> 一些传送门：\n> [归一化基础知识点 — PaddleEdu documentation (paddlepedia.readthedocs.io)](https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/normalization/basic_normalization.html)\n>\n> [Numpy数组归一化|极客教程 (geek-docs.com)](https://geek-docs.com/numpy/numpy-ask-answer/normalize-numpy-array_z1.html)\n\n归一化是一种数据处理方式，能将数据经过处理后限制在某个固定范围内。\n\n### 归一化处理的两种形式\n\n归一化存在两种形式\n\n1. 将数处理为 [0, 1] 之间的小数，其目的是为了在随后的数据处理过程中更便捷，其他情况下，也可将数据处理到 [-1, 1] 之间，或其他的固定范围内。\n\n> 例如，在图像处理中，就会将图像从 [0, 255] 归一化到 [0, 1]之间，这样既不会改变图像本身的信息储存，又可加速后续的网络处理。\n\n2. 通过归一化将有[量纲表达式](#有/无量纲表达式)变成[无量纲表达式](#有/无量纲表达式)。\n\n### 为什么要进行归一化\n\n1. 解决数据间的可比性问题\n2. 数据归一化后，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。[为什么能提高收敛速度](为什么归一化能提高求解最优解的速度).\n\n### 归一化类型\n\n1. Min-max normalization (Rescaling) 范围为[0,1]:\n\n$$\nx^{'} = \\frac{x - min(x)}{max(x) - min(x)}\n$$\n\n2. Mean normalization范围为[-1,1]：\n\n$$\nx^{'} = \\frac{x - mean(x)}{max(x) - min(x)}\n$$\n\n> mean(x)：x数据的平均值\n\n​\tMin-max归一化和mean归一化适合在最大最小值明确不变的情况下使用，比如图像处理时，灰度值限定在 [0, 255] 的范围内，就可以用min-max归一化将其处理到[0, 1]之间。在最大最小值不明确时，每当有新数据加入，都可能会改变最大或最小值，导致归一化结果不稳定，后续使用效果也不稳定。同时，数据需要相对稳定，如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。如果对处理后的数据范围有严格要求，也应使用min-max归一化或mean归一化。\n\n3. Z-score normalization (Standardization)范围为实数集：\n\n$$\nx^{'} = \\frac{x - \\mu}{\\sigma}\n$$\n\n> 𝜇、𝜎 分别为样本数据的均值和标准差。\n\n​\tZ-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。标准化会改变数据的状态分布，但不会改变分布的种类。特别地，神经网络中经常会使用到z-score归一化，针对这一点，我们将在后续的文章中进行详细的介绍。\n\n4. 对数归一化：\n\n$$\nx^{'} = \\frac{\\lg x}{\\lg max(x)}\n$$\n\n5. 反正切函数归一化：\n\n$$\nx^{'} = \\arctan(x) * \\frac{2}{\\pi}\n$$\n\n6. 小数定标标准化（Demical Point Normalization）:\n\n$$\nx^{'} = \\frac{x}{10^j}\n$$\n\n​\t非线性归一化通常被用在数据分化程度较大的场景，有时需要通过一些数学函数对原始值进行映射，如对数、反正切等。\n\n### 归一化和标准化的联系与区别\n\n谈到归一化和标准化可能会存在一些概念的混淆，我们都知道归一化是指normalization，标准化是指standardization，但根据wiki上对feature scaling方法的定义，standardization其实就是z-score normalization，也就是说标准化其实是归一化的一种，而一般情况下，我们会把z-score归一化称为标准化，把min-max归一化简称为归一化。在下文中，我们也是用标准化指代z-score归一化，并使用归一化指代min-max归一化。\n\n其实，归一化和标准化在本质上都是一种线性变换。在[归一化类型](#归一化类型)中，我们提到了归一化和标准化的公式，对于归一化的公式，在数据给定的情况下，可以令𝑎=𝑚𝑎𝑥(𝑥)−𝑚𝑖𝑛(𝑥)、𝑏=𝑚𝑖𝑛(𝑥)，则归一化的公式可变形为：\n$$\nx^{'} = \\frac{x - b}{a} = \\frac{x}{a} - \\frac{b}{a} = \\frac{x}{a} - c\n$$\n标准化的公式与变形后的归一化类似，其中的$\\mu $和$\\sigma$在数据给定的情况下，可以看作常数。因此，标准化的变形与归一化的类似，都可看作对𝑥按比例𝑎进行缩放，再进行𝑐个单位的平移。由此可见，归一化和标准化的本质都是一种线性变换，他们都不会因为对数据的处理而改变数据的原始数值排序。\n\n那么归一化和标准化又有什么区别呢？\n\n1. 归一化不会改变数据的状态分布，但标准化会改变数据的状态分布；\n2. 归一化会将数据限定在一个具体的范围内，如 [0, 1]，但标准化不会，标准化只会将数据处理为均值为0，标准差为1。\n\n### 为什么归一化能提高求解最优解的速度\n\n$$\n\\begin{split}\n\\begin{align}\ny &= \\theta_1x_1 + \\theta_2x_2 \\\\\nJ &= (\\theta_{1}x_{1} + \\theta_{2}x_{2} - y_{label})^2\n\\end{align}\n\\end{split}\n$$\n\n假设自变量只有房子到地铁站的距离$$𝑥_1$$和房子内房间的个数$$𝑥_2$$，因变量为房价，预测公式和损失函数分别为：\n\n$$\nJ = (1000\\theta_{1}+3\\theta_{2} - y_{label})^2\n$$\n\n![normalization](https://s2.loli.net/2024/06/05/QAonmGKX4FqxUMt.png)\n\n<div align=\"center\">图1: 损失函数的等高线，图1（左）为未归一化时，图1（右）为归一化</div>\n\n​\t在图1中，左图的红色椭圆代表归一化前的损失函数等高线，蓝色线段代表梯度的更新，箭头的方向代表梯度更新的方向。寻求最优解的过程就是梯度更新的过程，其更新方向与登高线垂直。由于𝑥1 和 𝑥2 的量级相差过大，损失函数的等高线呈现为一个瘦窄的椭圆。因此如图1（左）所示，瘦窄的椭圆形会使得梯度下降过程呈之字形呈现，导致梯度下降速度缓慢。\n\n​\t当数据经过归一化后，$x_{1}^{'} = \\frac{1000-0}{5000-0}=0.2$，$x_{2}^{'} = \\frac{3-0}{10-0}=0.3$，那么损失函数的公式可以写为：\n$$\nJ(x) = (0.2\\theta_{1} + 0.3\\theta_{2} - y_{label})^2\n$$\n​\t我们可以看到，经过归一化后的数据属于同一量级，损失函数的等高线呈现为一个矮胖的椭圆形（如图1（右）所示），求解最优解过程变得更加迅速且平缓，因此可以在通过梯度下降进行求解时获得更快的收敛。\n\n## 有/无量纲表达式\n\n我们假定数据都是一个个变量（不过提前收集好了）量纲指有些未知数他们是变量存在的一种或几种依赖关系，该变量的值由这些依赖关系的未知数（量纲）决定。\n\n>  就像一些函数的y值，理想状态下的房价，他们由x，面积/位置决定。\n\n显然位置差几百米，面积差几百平方米对变量影响差距极大，这种情况下我们称对这些依赖关系式是有量纲的。他们对变量影响的系数存在数量级的不同。\n\n## 常见问题\n\n1. vscode 出现python解释器的选择错误，这在windows经常有非常多版本的相同软件上经常出现，选定安装MindSpore库的python版本\n\n![image-20240605210110827](https://s2.loli.net/2024/06/05/QSIFMsjBCUAo34y.png)\n\n​\t点击此处python版本即可\n\n2. 注意python的多数语法检查集成已分离为插件，一些在2023.10发布，发布后一些网络上的blog修改linting的将禁用，详情请看[迁移到 Python 工具扩展 ·microsoft/vscode-python 维基 (github.com)](https://github.com/microsoft/vscode-python/wiki/Migration-to-Python-Tools-Extensions)\n\n3. 解决一些格式上的报错也可以不理会，但根据PEP 8 python规范，一行不能超过80个字符，同时换行需要缩进,如果看不管可以在扩展语法检查中增加args\n\n```\n--max-line-length=120\n```\n\n","slug":"special_subject/MindSpore/Chapters/Second_TryMindSpore","published":1,"updated":"2024-08-16T08:59:00.222Z","_id":"clzwh7bb700ai2wwv9irs5ump","comments":1,"layout":"post","photos":[],"content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4zLjByYzIvYmVnaW5uZXIvcXVpY2tfc3RhcnQuaHRtbA==\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"mindspore-数据处理\">MindSpore 数据处理</h2>\r\n<h3 id=\"download\">download</h3>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install download</span><br></pre></td></tr></table></figure>\r\n<p>下载download python模块</p>\r\n<h3 id=\"引包并下载所需数据集\">引包并下载所需数据集</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> mindspore</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore <span class=\"keyword\">import</span> nn</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore.dataset <span class=\"keyword\">import</span> vision, transforms</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore.dataset <span class=\"keyword\">import</span> MnistDataset</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Download data from open datasets</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> download <span class=\"keyword\">import</span> download</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">&quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&quot;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&quot;notebook/datasets/MNIST_Data.zip&quot;</span></span><br><span class=\"line\">path = download(url, <span class=\"string\">&quot;./&quot;</span>, kind=<span class=\"string\">&quot;zip&quot;</span>, replace=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/EuK87I6YUjdAs2v.png\"\r\nalt=\"image-20240605204942126\" />\r\n<figcaption aria-hidden=\"true\">image-20240605204942126</figcaption>\r\n</figure>\r\n<p>下载下来MNIST_Data数据，根据官网这是一份Mnist数据集，结构如下</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MNIST_Data</span><br><span class=\"line\">└── train</span><br><span class=\"line\">    ├── train-images-idx3-ubyte (60000个训练图片)</span><br><span class=\"line\">    ├── train-labels-idx1-ubyte (60000个训练标签)</span><br><span class=\"line\">└── test</span><br><span class=\"line\">    ├── t10k-images-idx3-ubyte (10000个测试图片)</span><br><span class=\"line\">    ├── t10k-labels-idx1-ubyte (10000个测试标签)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"mindspore数据处理\">MindSpore数据处理</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(train_dataset.get_col_names())</span><br></pre></td></tr></table></figure>\r\n<p>打印数据集中所包含的数据列名</p>\r\n<blockquote>\r\n<p>MindSpore的dataset使用数据处理流水线（Data Processing\r\nPipeline），需指定map、batch、shuffle等操作。这里我们使用map对图像数据及标签进行变换处理，将输入的图像缩放为1/255，根据均值0.1307和标准差值0.3081进行归一化处理，然后将处理好的数据集打包为大小为64的batch。</p>\r\n</blockquote>\r\n<p>上面是官网对以下代码的处理。</p>\r\n<p>其中出现了一个新名词——<a\r\nhref=\"#归一化处理\">归一化处理</a>，这里使用的是Z-score\r\nnormalization。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">datapipe</span>(<span class=\"params\">dataset, batch_size</span>):</span><br><span class=\"line\">    image_transforms = [</span><br><span class=\"line\">        vision.Rescale(<span class=\"number\">1.0</span> / <span class=\"number\">255.0</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">        vision.Normalize(mean=(<span class=\"number\">0.1307</span>,), std=(<span class=\"number\">0.3081</span>,)),</span><br><span class=\"line\">        vision.HWC2CHW()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    label_transform = transforms.TypeCast(mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\">    dataset = dataset.<span class=\"built_in\">map</span>(image_transforms, <span class=\"string\">&#x27;image&#x27;</span>)</span><br><span class=\"line\">    dataset = dataset.<span class=\"built_in\">map</span>(label_transform, <span class=\"string\">&#x27;label&#x27;</span>)</span><br><span class=\"line\">    dataset = dataset.batch(batch_size)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataset</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Map vision transforms and batch dataset</span></span><br><span class=\"line\">train_dataset = datapipe(train_dataset, <span class=\"number\">64</span>)</span><br><span class=\"line\">test_dataset = datapipe(test_dataset, <span class=\"number\">64</span>)</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<p>可使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfdHVwbGVfaXRlcmF0b3IuaHRtbA==\">create_tuple_iterator<i class=\"fa fa-external-link-alt\"></i></span>\r\n或<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfZGljdF9pdGVyYXRvci5odG1s\">create_dict_iterator<i class=\"fa fa-external-link-alt\"></i></span>对数据集进行迭代访问，查看数据和标签的shape和datatype。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> image, label <span class=\"keyword\">in</span> test_dataset.create_tuple_iterator():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of image [N, C, H, W]: <span class=\"subst\">&#123;image.shape&#125;</span> <span class=\"subst\">&#123;image.dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of label: <span class=\"subst\">&#123;label.shape&#125;</span> <span class=\"subst\">&#123;label.dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32 Shape of label:\r\n(64,) Int32</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> test_dataset.create_dict_iterator():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of image [N, C, H, W]: <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;image&#x27;</span>].shape&#125;</span> <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;image&#x27;</span>].dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of label: <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;label&#x27;</span>].shape&#125;</span> <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;label&#x27;</span>].dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32 Shape of label:\r\n(64,) Int32</p>\r\n</blockquote>\r\n<p>更多细节详见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL2RhdGFzZXQuaHRtbA==\">数据集\r\nDataset<i class=\"fa fa-external-link-alt\"></i></span>与<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RyYW5zZm9ybXMuaHRtbA==\">数据变换\r\nTransforms<i class=\"fa fa-external-link-alt\"></i></span>。</p>\r\n<h3 id=\"网络构建\">网络构建</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define model</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Network&lt; (flatten): Flatten&lt;&gt; (dense_relu_sequential):\r\nSequentialCell&lt; (0): Dense&lt;input_channels=784,\r\noutput_channels=512, has_bias=True&gt; (1): ReLU&lt;&gt; (2):\r\nDense&lt;input_channels=512, output_channels=512, has_bias=True&gt; (3):\r\nReLU&lt;&gt; (4): Dense&lt;input_channels=512, output_channels=10,\r\nhas_bias=True&gt; &gt;</p>\r\n</blockquote>\r\n<p>以上为网格的构建以及其输出，有以下几点需要注意</p>\r\n<ol type=\"1\">\r\n<li>上面重命名过MindSpore中的nn类是构建所有网格的基类，也是网格的基本单元</li>\r\n<li>当需要自定义网络时可以重写`<code>nn.Cell</code>类重写<code>__init__</code>方法和<code>construct</code>方法</li>\r\n<li><code>__init__</code>包含所有网络层的定义<code>construct</code>中包含数据（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RlbnNvci5odG1s\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）的变换过程</li>\r\n</ol>\r\n<blockquote>\r\n<p><code>mindspore.nn</code>类是构建所有网络的基类，也是网络的基本单元。当用户需要自定义网络时，可以继承<code>nn.Cell</code>类，并重写<code>__init__</code>方法和<code>construct</code>方法。<code>__init__</code>包含所有网络层的定义，<code>construct</code>中包含数据（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RlbnNvci5odG1s\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）的变换过程。</p>\r\n</blockquote>\r\n<h3 id=\"模型训练\">模型训练</h3>\r\n<p>个人菜狗形象的想，实际上这里的网格神经网络对图像的识别类似一种带指向的可变哈希函数（只不过这个函数的实现比较复杂和通用）。他是从大量信息到小量准确抽象的描述过程。下面是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVubWxzeXMuZ2l0aHViLmlvL2NoYXB0ZXJfcHJvZ3JhbW1pbmdfaW50ZXJmYWNlL21sX3dvcmtmbG93Lmh0bWw=\">3.2.\r\n机器学习工作流 — 机器学习系统：设计和实现 1.0.0 documentation\r\n(openmlsys.github.io)<i class=\"fa fa-external-link-alt\"></i></span>手册上的机器学习流程图，这里以求形象的理解</p>\r\n<figure>\r\n<img src=\"./../img/img_workflow.svg\" alt=\"img_workflow\" />\r\n<figcaption aria-hidden=\"true\">img_workflow</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>在模型训练中，一个完整的训练过程（step）需要实现以下三步：</p>\r\n<ol type=\"1\">\r\n<li><strong>正向计算</strong>：模型预测结果（logits），并与正确标签（label）求预测损失（loss）。</li>\r\n<li><strong>反向传播</strong>：利用自动微分机制，自动求模型参数（parameters）对于loss的梯度（gradients）。</li>\r\n<li><strong>参数优化</strong>：将梯度更新到参数上。</li>\r\n</ol>\r\n</blockquote>\r\n<blockquote>\r\n<p>MindSpore使用函数式自动微分机制，因此针对上述步骤需要实现：</p>\r\n<ol type=\"1\">\r\n<li>定义正向计算函数。</li>\r\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUudmFsdWVfYW5kX2dyYWQuaHRtbA==\">value_and_grad<i class=\"fa fa-external-link-alt\"></i></span>通过函数变换获得梯度计算函数。</li>\r\n<li>定义训练函数，使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5DZWxsLmh0bWwjbWluZHNwb3JlLm5uLkNlbGwuc2V0X3RyYWlu\">set_train<i class=\"fa fa-external-link-alt\"></i></span>设置为训练模式，执行正向计算、反向传播和参数优化。</li>\r\n</ol>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Instantiate loss function and optimizer</span></span><br><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), <span class=\"number\">1e-2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    logits = model(data)</span><br><span class=\"line\">    loss = loss_fn(logits, label)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, logits</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. Get gradient function</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, optimizer.parameters, has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. Define function of one-step training</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_step</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    (loss, _), grads = grad_fn(data, label)</span><br><span class=\"line\">    optimizer(grads)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train</span>(<span class=\"params\">model, dataset</span>):</span><br><span class=\"line\">    size = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> batch, (data, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        loss = train_step(data, label)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> batch % <span class=\"number\">100</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            loss, current = loss.asnumpy(), batch</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;loss: <span class=\"subst\">&#123;loss:&gt;7f&#125;</span>  [<span class=\"subst\">&#123;current:&gt;3d&#125;</span>/<span class=\"subst\">&#123;size:&gt;3d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>除训练外，我们定义测试函数，用来评估模型的性能。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">model, dataset, loss_fn</span>):</span><br><span class=\"line\">    num_batches = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\">    total, test_loss, correct = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> dataset.create_tuple_iterator():</span><br><span class=\"line\">        pred = model(data)</span><br><span class=\"line\">        total += <span class=\"built_in\">len</span>(data)</span><br><span class=\"line\">        test_loss += loss_fn(pred, label).asnumpy()</span><br><span class=\"line\">        correct += (pred.argmax(<span class=\"number\">1</span>) == label).asnumpy().<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">    test_loss /= num_batches</span><br><span class=\"line\">    correct /= total</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Test: \\n Accuracy: <span class=\"subst\">&#123;(<span class=\"number\">100</span>*correct):&gt;<span class=\"number\">0.1</span>f&#125;</span>%, Avg loss: <span class=\"subst\">&#123;test_loss:&gt;8f&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">epochs = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(epochs):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Epoch <span class=\"subst\">&#123;t+<span class=\"number\">1</span>&#125;</span>\\n-------------------------------&quot;</span>)</span><br><span class=\"line\">    train(model, train_dataset)</span><br><span class=\"line\">    test(model, test_dataset, loss_fn)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;Epoch 1</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 2.302088  [  0/938]</span><br><span class=\"line\">&gt;loss: 2.290692  [100/938]</span><br><span class=\"line\">&gt;loss: 2.266338  [200/938]</span><br><span class=\"line\">&gt;loss: 2.205240  [300/938]</span><br><span class=\"line\">&gt;loss: 1.907198  [400/938]</span><br><span class=\"line\">&gt;loss: 1.455603  [500/938]</span><br><span class=\"line\">&gt;loss: 0.861103  [600/938]</span><br><span class=\"line\">&gt;loss: 0.767219  [700/938]</span><br><span class=\"line\">&gt;loss: 0.422253  [800/938]</span><br><span class=\"line\">&gt;loss: 0.513922  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 83.8%, Avg loss: 0.529534</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Epoch 2</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 0.580867  [  0/938]</span><br><span class=\"line\">&gt;loss: 0.479347  [100/938]</span><br><span class=\"line\">&gt;loss: 0.677991  [200/938]</span><br><span class=\"line\">&gt;loss: 0.550141  [300/938]</span><br><span class=\"line\">&gt;loss: 0.226565  [400/938]</span><br><span class=\"line\">&gt;loss: 0.314738  [500/938]</span><br><span class=\"line\">&gt;loss: 0.298739  [600/938]</span><br><span class=\"line\">&gt;loss: 0.459540  [700/938]</span><br><span class=\"line\">&gt;loss: 0.332978  [800/938]</span><br><span class=\"line\">&gt;loss: 0.406709  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 90.2%, Avg loss: 0.334828</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Epoch 3</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 0.461890  [  0/938]</span><br><span class=\"line\">&gt;loss: 0.242303  [100/938]</span><br><span class=\"line\">&gt;loss: 0.281414  [200/938]</span><br><span class=\"line\">&gt;loss: 0.207835  [300/938]</span><br><span class=\"line\">&gt;loss: 0.206000  [400/938]</span><br><span class=\"line\">&gt;loss: 0.409646  [500/938]</span><br><span class=\"line\">&gt;loss: 0.193608  [600/938]</span><br><span class=\"line\">&gt;loss: 0.217575  [700/938]</span><br><span class=\"line\">&gt;loss: 0.212817  [800/938]</span><br><span class=\"line\">&gt;loss: 0.202862  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 91.9%, Avg loss: 0.280962</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Done!</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<blockquote>\r\n<p>训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。</p>\r\n</blockquote>\r\n<h3 id=\"保存模型\">保存模型</h3>\r\n<p>模型训练完成后，需要将其参数进行保存。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Save checkpoint</span></span><br><span class=\"line\">mindspore.save_checkpoint(model, <span class=\"string\">&quot;model.ckpt&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Saved Model to model.ckpt&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Saved Model to model.ckpt</p>\r\n</blockquote>\r\n<h3 id=\"加载模型\">加载模型</h3>\r\n<blockquote>\r\n<p>加载保存的权重分为两步：</p>\r\n<ol type=\"1\">\r\n<li>重新实例化模型对象，构造模型。</li>\r\n<li>加载模型参数，并将其加载至模型上。</li>\r\n</ol>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Instantiate a random initialized model</span></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"comment\"># Load checkpoint and load parameter to model</span></span><br><span class=\"line\">param_dict = mindspore.load_checkpoint(<span class=\"string\">&quot;model.ckpt&quot;</span>)</span><br><span class=\"line\">param_not_load, _ = mindspore.load_param_into_net(model, param_dict)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(param_not_load)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p><code>param_not_load未被加载的参数列表，为空时代表所有参数均加载成功。</code></p>\r\n</blockquote>\r\n<blockquote>\r\n<p>加载后的模型可以直接用于预测推理。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> test_dataset:</span><br><span class=\"line\">    pred = model(data)</span><br><span class=\"line\">    predicted = pred.argmax(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Predicted: &quot;<span class=\"subst\">&#123;predicted[:<span class=\"number\">10</span>]&#125;</span>&quot;, Actual: &quot;<span class=\"subst\">&#123;label[:<span class=\"number\">10</span>]&#125;</span>&quot;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<p>以上就是一个简单的图像识别机械学习</p>\r\n<p><strong>注意在加载模型的过程中必须定义模型构建与datapipe</strong></p>\r\n<h2 id=\"归一化处理\">归一化处理</h2>\r\n<blockquote>\r\n<p>一些传送门： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWRkbGVwZWRpYS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvdHV0b3JpYWxzL2RlZXBfbGVhcm5pbmcvbm9ybWFsaXphdGlvbi9iYXNpY19ub3JtYWxpemF0aW9uLmh0bWw=\">归一化基础知识点\r\n— PaddleEdu documentation (paddlepedia.readthedocs.io)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9nZWVrLWRvY3MuY29tL251bXB5L251bXB5LWFzay1hbnN3ZXIvbm9ybWFsaXplLW51bXB5LWFycmF5X3oxLmh0bWw=\">Numpy数组归一化|极客教程\r\n(geek-docs.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n</blockquote>\r\n<p>归一化是一种数据处理方式，能将数据经过处理后限制在某个固定范围内。</p>\r\n<h3 id=\"归一化处理的两种形式\">归一化处理的两种形式</h3>\r\n<p>归一化存在两种形式</p>\r\n<ol type=\"1\">\r\n<li>将数处理为 [0, 1]\r\n之间的小数，其目的是为了在随后的数据处理过程中更便捷，其他情况下，也可将数据处理到\r\n[-1, 1] 之间，或其他的固定范围内。</li>\r\n</ol>\r\n<blockquote>\r\n<p>例如，在图像处理中，就会将图像从 [0, 255] 归一化到 [0,\r\n1]之间，这样既不会改变图像本身的信息储存，又可加速后续的网络处理。</p>\r\n</blockquote>\r\n<ol start=\"2\" type=\"1\">\r\n<li>通过归一化将有<a href=\"#有/无量纲表达式\">量纲表达式</a>变成<a\r\nhref=\"#有/无量纲表达式\">无量纲表达式</a>。</li>\r\n</ol>\r\n<h3 id=\"为什么要进行归一化\">为什么要进行归一化</h3>\r\n<ol type=\"1\">\r\n<li>解决数据间的可比性问题</li>\r\n<li>数据归一化后，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。<a\r\nhref=\"为什么归一化能提高求解最优解的速度\">为什么能提高收敛速度</a>.</li>\r\n</ol>\r\n<h3 id=\"归一化类型\">归一化类型</h3>\r\n<ol type=\"1\">\r\n<li>Min-max normalization (Rescaling) 范围为[0,1]:</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - min(x)}{max(x) - min(x)}\r\n\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Mean normalization范围为[-1,1]：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - mean(x)}{max(x) - min(x)}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>mean(x)：x数据的平均值</p>\r\n</blockquote>\r\n<p>​\r\nMin-max归一化和mean归一化适合在最大最小值明确不变的情况下使用，比如图像处理时，灰度值限定在\r\n[0, 255] 的范围内，就可以用min-max归一化将其处理到[0,\r\n1]之间。在最大最小值不明确时，每当有新数据加入，都可能会改变最大或最小值，导致归一化结果不稳定，后续使用效果也不稳定。同时，数据需要相对稳定，如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。如果对处理后的数据范围有严格要求，也应使用min-max归一化或mean归一化。</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Z-score normalization (Standardization)范围为实数集：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - \\mu}{\\sigma}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>𝜇、𝜎 分别为样本数据的均值和标准差。</p>\r\n</blockquote>\r\n<p>​\r\nZ-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。标准化会改变数据的状态分布，但不会改变分布的种类。特别地，神经网络中经常会使用到z-score归一化，针对这一点，我们将在后续的文章中进行详细的介绍。</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>对数归一化：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{\\lg x}{\\lg max(x)}\r\n\\]</span></p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>反正切函数归一化：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\arctan(x) * \\frac{2}{\\pi}\r\n\\]</span></p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>小数定标标准化（Demical Point Normalization）:</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x}{10^j}\r\n\\]</span></p>\r\n<p>​\r\n非线性归一化通常被用在数据分化程度较大的场景，有时需要通过一些数学函数对原始值进行映射，如对数、反正切等。</p>\r\n<h3 id=\"归一化和标准化的联系与区别\">归一化和标准化的联系与区别</h3>\r\n<p>谈到归一化和标准化可能会存在一些概念的混淆，我们都知道归一化是指normalization，标准化是指standardization，但根据wiki上对feature\r\nscaling方法的定义，standardization其实就是z-score\r\nnormalization，也就是说标准化其实是归一化的一种，而一般情况下，我们会把z-score归一化称为标准化，把min-max归一化简称为归一化。在下文中，我们也是用标准化指代z-score归一化，并使用归一化指代min-max归一化。</p>\r\n<p>其实，归一化和标准化在本质上都是一种线性变换。在<a\r\nhref=\"#归一化类型\">归一化类型</a>中，我们提到了归一化和标准化的公式，对于归一化的公式，在数据给定的情况下，可以令𝑎=𝑚𝑎𝑥(𝑥)−𝑚𝑖𝑛(𝑥)、𝑏=𝑚𝑖𝑛(𝑥)，则归一化的公式可变形为：\r\n<span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - b}{a} = \\frac{x}{a} - \\frac{b}{a} = \\frac{x}{a} -\r\nc\r\n\\]</span> 标准化的公式与变形后的归一化类似，其中的$<span\r\nclass=\"math inline\">\\(和\\)</span>$在数据给定的情况下，可以看作常数。因此，标准化的变形与归一化的类似，都可看作对𝑥按比例𝑎进行缩放，再进行𝑐个单位的平移。由此可见，归一化和标准化的本质都是一种线性变换，他们都不会因为对数据的处理而改变数据的原始数值排序。</p>\r\n<p>那么归一化和标准化又有什么区别呢？</p>\r\n<ol type=\"1\">\r\n<li>归一化不会改变数据的状态分布，但标准化会改变数据的状态分布；</li>\r\n<li>归一化会将数据限定在一个具体的范围内，如 [0,\r\n1]，但标准化不会，标准化只会将数据处理为均值为0，标准差为1。</li>\r\n</ol>\r\n<h3\r\nid=\"为什么归一化能提高求解最优解的速度\">为什么归一化能提高求解最优解的速度</h3>\r\n<p><span class=\"math display\">\\[\r\n\\begin{split}\r\n\\begin{align}\r\ny &amp;= \\theta_1x_1 + \\theta_2x_2 \\\\\r\nJ &amp;= (\\theta_{1}x_{1} + \\theta_{2}x_{2} - y_{label})^2\r\n\\end{align}\r\n\\end{split}\r\n\\]</span></p>\r\n<p>假设自变量只有房子到地铁站的距离<span\r\nclass=\"math display\">\\[𝑥_1\\]</span>和房子内房间的个数<span\r\nclass=\"math display\">\\[𝑥_2\\]</span>，因变量为房价，预测公式和损失函数分别为：</p>\r\n<p><span class=\"math display\">\\[\r\nJ = (1000\\theta_{1}+3\\theta_{2} - y_{label})^2\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/QAonmGKX4FqxUMt.png\"\r\nalt=\"normalization\" />\r\n<figcaption aria-hidden=\"true\">normalization</figcaption>\r\n</figure>\r\n<div data-align=\"center\">\r\n图1: 损失函数的等高线，图1（左）为未归一化时，图1（右）为归一化\r\n</div>\r\n<p>​\r\n在图1中，左图的红色椭圆代表归一化前的损失函数等高线，蓝色线段代表梯度的更新，箭头的方向代表梯度更新的方向。寻求最优解的过程就是梯度更新的过程，其更新方向与登高线垂直。由于𝑥1\r\n和 𝑥2\r\n的量级相差过大，损失函数的等高线呈现为一个瘦窄的椭圆。因此如图1（左）所示，瘦窄的椭圆形会使得梯度下降过程呈之字形呈现，导致梯度下降速度缓慢。</p>\r\n<p>​ 当数据经过归一化后，<span class=\"math inline\">\\(x_{1}^{&#39;} =\r\n\\frac{1000-0}{5000-0}=0.2\\)</span>，<span\r\nclass=\"math inline\">\\(x_{2}^{&#39;} =\r\n\\frac{3-0}{10-0}=0.3\\)</span>，那么损失函数的公式可以写为： <span\r\nclass=\"math display\">\\[\r\nJ(x) = (0.2\\theta_{1} + 0.3\\theta_{2} - y_{label})^2\r\n\\]</span> ​\r\n我们可以看到，经过归一化后的数据属于同一量级，损失函数的等高线呈现为一个矮胖的椭圆形（如图1（右）所示），求解最优解过程变得更加迅速且平缓，因此可以在通过梯度下降进行求解时获得更快的收敛。</p>\r\n<h2 id=\"有无量纲表达式\">有/无量纲表达式</h2>\r\n<p>我们假定数据都是一个个变量（不过提前收集好了）量纲指有些未知数他们是变量存在的一种或几种依赖关系，该变量的值由这些依赖关系的未知数（量纲）决定。</p>\r\n<blockquote>\r\n<p>就像一些函数的y值，理想状态下的房价，他们由x，面积/位置决定。</p>\r\n</blockquote>\r\n<p>显然位置差几百米，面积差几百平方米对变量影响差距极大，这种情况下我们称对这些依赖关系式是有量纲的。他们对变量影响的系数存在数量级的不同。</p>\r\n<h2 id=\"常见问题\">常见问题</h2>\r\n<ol type=\"1\">\r\n<li>vscode\r\n出现python解释器的选择错误，这在windows经常有非常多版本的相同软件上经常出现，选定安装MindSpore库的python版本</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/QSIFMsjBCUAo34y.png\"\r\nalt=\"image-20240605210110827\" />\r\n<figcaption aria-hidden=\"true\">image-20240605210110827</figcaption>\r\n</figure>\r\n<p>​ 点击此处python版本即可</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>注意python的多数语法检查集成已分离为插件，一些在2023.10发布，发布后一些网络上的blog修改linting的将禁用，详情请看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUtcHl0aG9uL3dpa2kvTWlncmF0aW9uLXRvLVB5dGhvbi1Ub29scy1FeHRlbnNpb25z\">迁移到\r\nPython 工具扩展 ·microsoft/vscode-python 维基 (github.com)<i class=\"fa fa-external-link-alt\"></i></span></p></li>\r\n<li><p>解决一些格式上的报错也可以不理会，但根据PEP 8\r\npython规范，一行不能超过80个字符，同时换行需要缩进,如果看不管可以在扩展语法检查中增加args</p></li>\r\n</ol>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--max-line-length=120</span><br></pre></td></tr></table></figure>\r\n","length":3710,"excerpt":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4zLjByYzIvYmVnaW5uZXIvcXVpY2tfc3RhcnQuaHRtbA==\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h2 id=\"mindspore-数据处理\">MindSpore 数据处理</h2>\r\n<h3 id=\"download\">download</h3>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install download</span><br></pre></td></tr></table></figure>\r\n<p>下载download python模块</p>\r\n<h3 id=\"引包并下载所需数据集\">引包并下载所需数据集</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> mindspore</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore <span class=\"keyword\">import</span> nn</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore.dataset <span class=\"keyword\">import</span> vision, transforms</span><br><span class=\"line\"><span class=\"keyword\">from</span> mindspore.dataset <span class=\"keyword\">import</span> MnistDataset</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Download data from open datasets</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> download <span class=\"keyword\">import</span> download</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">&quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&quot;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&quot;notebook/datasets/MNIST_Data.zip&quot;</span></span><br><span class=\"line\">path = download(url, <span class=\"string\">&quot;./&quot;</span>, kind=<span class=\"string\">&quot;zip&quot;</span>, replace=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/EuK87I6YUjdAs2v.png\"\r\nalt=\"image-20240605204942126\" />\r\n<figcaption aria-hidden=\"true\">image-20240605204942126</figcaption>\r\n</figure>\r\n<p>下载下来MNIST_Data数据，根据官网这是一份Mnist数据集，结构如下</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MNIST_Data</span><br><span class=\"line\">└── train</span><br><span class=\"line\">    ├── train-images-idx3-ubyte (60000个训练图片)</span><br><span class=\"line\">    ├── train-labels-idx1-ubyte (60000个训练标签)</span><br><span class=\"line\">└── test</span><br><span class=\"line\">    ├── t10k-images-idx3-ubyte (10000个测试图片)</span><br><span class=\"line\">    ├── t10k-labels-idx1-ubyte (10000个测试标签)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"mindspore数据处理\">MindSpore数据处理</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(train_dataset.get_col_names())</span><br></pre></td></tr></table></figure>\r\n<p>打印数据集中所包含的数据列名</p>\r\n<blockquote>\r\n<p>MindSpore的dataset使用数据处理流水线（Data Processing\r\nPipeline），需指定map、batch、shuffle等操作。这里我们使用map对图像数据及标签进行变换处理，将输入的图像缩放为1/255，根据均值0.1307和标准差值0.3081进行归一化处理，然后将处理好的数据集打包为大小为64的batch。</p>\r\n</blockquote>\r\n<p>上面是官网对以下代码的处理。</p>\r\n<p>其中出现了一个新名词——<a\r\nhref=\"#归一化处理\">归一化处理</a>，这里使用的是Z-score\r\nnormalization。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">datapipe</span>(<span class=\"params\">dataset, batch_size</span>):</span><br><span class=\"line\">    image_transforms = [</span><br><span class=\"line\">        vision.Rescale(<span class=\"number\">1.0</span> / <span class=\"number\">255.0</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">        vision.Normalize(mean=(<span class=\"number\">0.1307</span>,), std=(<span class=\"number\">0.3081</span>,)),</span><br><span class=\"line\">        vision.HWC2CHW()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    label_transform = transforms.TypeCast(mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\">    dataset = dataset.<span class=\"built_in\">map</span>(image_transforms, <span class=\"string\">&#x27;image&#x27;</span>)</span><br><span class=\"line\">    dataset = dataset.<span class=\"built_in\">map</span>(label_transform, <span class=\"string\">&#x27;label&#x27;</span>)</span><br><span class=\"line\">    dataset = dataset.batch(batch_size)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataset</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Map vision transforms and batch dataset</span></span><br><span class=\"line\">train_dataset = datapipe(train_dataset, <span class=\"number\">64</span>)</span><br><span class=\"line\">test_dataset = datapipe(test_dataset, <span class=\"number\">64</span>)</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<p>可使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfdHVwbGVfaXRlcmF0b3IuaHRtbA==\">create_tuple_iterator<i class=\"fa fa-external-link-alt\"></i></span>\r\n或<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfZGljdF9pdGVyYXRvci5odG1s\">create_dict_iterator<i class=\"fa fa-external-link-alt\"></i></span>对数据集进行迭代访问，查看数据和标签的shape和datatype。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> image, label <span class=\"keyword\">in</span> test_dataset.create_tuple_iterator():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of image [N, C, H, W]: <span class=\"subst\">&#123;image.shape&#125;</span> <span class=\"subst\">&#123;image.dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of label: <span class=\"subst\">&#123;label.shape&#125;</span> <span class=\"subst\">&#123;label.dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32 Shape of label:\r\n(64,) Int32</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> test_dataset.create_dict_iterator():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of image [N, C, H, W]: <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;image&#x27;</span>].shape&#125;</span> <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;image&#x27;</span>].dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Shape of label: <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;label&#x27;</span>].shape&#125;</span> <span class=\"subst\">&#123;data[<span class=\"string\">&#x27;label&#x27;</span>].dtype&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32 Shape of label:\r\n(64,) Int32</p>\r\n</blockquote>\r\n<p>更多细节详见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL2RhdGFzZXQuaHRtbA==\">数据集\r\nDataset<i class=\"fa fa-external-link-alt\"></i></span>与<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RyYW5zZm9ybXMuaHRtbA==\">数据变换\r\nTransforms<i class=\"fa fa-external-link-alt\"></i></span>。</p>\r\n<h3 id=\"网络构建\">网络构建</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Define model</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.flatten = nn.Flatten()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">28</span>*<span class=\"number\">28</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">512</span>),</span><br><span class=\"line\">            nn.ReLU(),</span><br><span class=\"line\">            nn.Dense(<span class=\"number\">512</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        x = <span class=\"variable language_\">self</span>.flatten(x)</span><br><span class=\"line\">        logits = <span class=\"variable language_\">self</span>.dense_relu_sequential(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> logits</span><br><span class=\"line\"></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Network&lt; (flatten): Flatten&lt;&gt; (dense_relu_sequential):\r\nSequentialCell&lt; (0): Dense&lt;input_channels=784,\r\noutput_channels=512, has_bias=True&gt; (1): ReLU&lt;&gt; (2):\r\nDense&lt;input_channels=512, output_channels=512, has_bias=True&gt; (3):\r\nReLU&lt;&gt; (4): Dense&lt;input_channels=512, output_channels=10,\r\nhas_bias=True&gt; &gt;</p>\r\n</blockquote>\r\n<p>以上为网格的构建以及其输出，有以下几点需要注意</p>\r\n<ol type=\"1\">\r\n<li>上面重命名过MindSpore中的nn类是构建所有网格的基类，也是网格的基本单元</li>\r\n<li>当需要自定义网络时可以重写`<code>nn.Cell</code>类重写<code>__init__</code>方法和<code>construct</code>方法</li>\r\n<li><code>__init__</code>包含所有网络层的定义<code>construct</code>中包含数据（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RlbnNvci5odG1s\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）的变换过程</li>\r\n</ol>\r\n<blockquote>\r\n<p><code>mindspore.nn</code>类是构建所有网络的基类，也是网络的基本单元。当用户需要自定义网络时，可以继承<code>nn.Cell</code>类，并重写<code>__init__</code>方法和<code>construct</code>方法。<code>__init__</code>包含所有网络层的定义，<code>construct</code>中包含数据（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RlbnNvci5odG1s\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）的变换过程。</p>\r\n</blockquote>\r\n<h3 id=\"模型训练\">模型训练</h3>\r\n<p>个人菜狗形象的想，实际上这里的网格神经网络对图像的识别类似一种带指向的可变哈希函数（只不过这个函数的实现比较复杂和通用）。他是从大量信息到小量准确抽象的描述过程。下面是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVubWxzeXMuZ2l0aHViLmlvL2NoYXB0ZXJfcHJvZ3JhbW1pbmdfaW50ZXJmYWNlL21sX3dvcmtmbG93Lmh0bWw=\">3.2.\r\n机器学习工作流 — 机器学习系统：设计和实现 1.0.0 documentation\r\n(openmlsys.github.io)<i class=\"fa fa-external-link-alt\"></i></span>手册上的机器学习流程图，这里以求形象的理解</p>\r\n<figure>\r\n<img src=\"./../img/img_workflow.svg\" alt=\"img_workflow\" />\r\n<figcaption aria-hidden=\"true\">img_workflow</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>在模型训练中，一个完整的训练过程（step）需要实现以下三步：</p>\r\n<ol type=\"1\">\r\n<li><strong>正向计算</strong>：模型预测结果（logits），并与正确标签（label）求预测损失（loss）。</li>\r\n<li><strong>反向传播</strong>：利用自动微分机制，自动求模型参数（parameters）对于loss的梯度（gradients）。</li>\r\n<li><strong>参数优化</strong>：将梯度更新到参数上。</li>\r\n</ol>\r\n</blockquote>\r\n<blockquote>\r\n<p>MindSpore使用函数式自动微分机制，因此针对上述步骤需要实现：</p>\r\n<ol type=\"1\">\r\n<li>定义正向计算函数。</li>\r\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUudmFsdWVfYW5kX2dyYWQuaHRtbA==\">value_and_grad<i class=\"fa fa-external-link-alt\"></i></span>通过函数变换获得梯度计算函数。</li>\r\n<li>定义训练函数，使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5DZWxsLmh0bWwjbWluZHNwb3JlLm5uLkNlbGwuc2V0X3RyYWlu\">set_train<i class=\"fa fa-external-link-alt\"></i></span>设置为训练模式，执行正向计算、反向传播和参数优化。</li>\r\n</ol>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Instantiate loss function and optimizer</span></span><br><span class=\"line\">loss_fn = nn.CrossEntropyLoss()</span><br><span class=\"line\">optimizer = nn.SGD(model.trainable_params(), <span class=\"number\">1e-2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    logits = model(data)</span><br><span class=\"line\">    loss = loss_fn(logits, label)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, logits</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. Get gradient function</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, optimizer.parameters, has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. Define function of one-step training</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train_step</span>(<span class=\"params\">data, label</span>):</span><br><span class=\"line\">    (loss, _), grads = grad_fn(data, label)</span><br><span class=\"line\">    optimizer(grads)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train</span>(<span class=\"params\">model, dataset</span>):</span><br><span class=\"line\">    size = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> batch, (data, label) <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class=\"line\">        loss = train_step(data, label)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> batch % <span class=\"number\">100</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            loss, current = loss.asnumpy(), batch</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;loss: <span class=\"subst\">&#123;loss:&gt;7f&#125;</span>  [<span class=\"subst\">&#123;current:&gt;3d&#125;</span>/<span class=\"subst\">&#123;size:&gt;3d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>除训练外，我们定义测试函数，用来评估模型的性能。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">model, dataset, loss_fn</span>):</span><br><span class=\"line\">    num_batches = dataset.get_dataset_size()</span><br><span class=\"line\">    model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\">    total, test_loss, correct = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> dataset.create_tuple_iterator():</span><br><span class=\"line\">        pred = model(data)</span><br><span class=\"line\">        total += <span class=\"built_in\">len</span>(data)</span><br><span class=\"line\">        test_loss += loss_fn(pred, label).asnumpy()</span><br><span class=\"line\">        correct += (pred.argmax(<span class=\"number\">1</span>) == label).asnumpy().<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">    test_loss /= num_batches</span><br><span class=\"line\">    correct /= total</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Test: \\n Accuracy: <span class=\"subst\">&#123;(<span class=\"number\">100</span>*correct):&gt;<span class=\"number\">0.1</span>f&#125;</span>%, Avg loss: <span class=\"subst\">&#123;test_loss:&gt;8f&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">epochs = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(epochs):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Epoch <span class=\"subst\">&#123;t+<span class=\"number\">1</span>&#125;</span>\\n-------------------------------&quot;</span>)</span><br><span class=\"line\">    train(model, train_dataset)</span><br><span class=\"line\">    test(model, test_dataset, loss_fn)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;Epoch 1</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 2.302088  [  0/938]</span><br><span class=\"line\">&gt;loss: 2.290692  [100/938]</span><br><span class=\"line\">&gt;loss: 2.266338  [200/938]</span><br><span class=\"line\">&gt;loss: 2.205240  [300/938]</span><br><span class=\"line\">&gt;loss: 1.907198  [400/938]</span><br><span class=\"line\">&gt;loss: 1.455603  [500/938]</span><br><span class=\"line\">&gt;loss: 0.861103  [600/938]</span><br><span class=\"line\">&gt;loss: 0.767219  [700/938]</span><br><span class=\"line\">&gt;loss: 0.422253  [800/938]</span><br><span class=\"line\">&gt;loss: 0.513922  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 83.8%, Avg loss: 0.529534</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Epoch 2</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 0.580867  [  0/938]</span><br><span class=\"line\">&gt;loss: 0.479347  [100/938]</span><br><span class=\"line\">&gt;loss: 0.677991  [200/938]</span><br><span class=\"line\">&gt;loss: 0.550141  [300/938]</span><br><span class=\"line\">&gt;loss: 0.226565  [400/938]</span><br><span class=\"line\">&gt;loss: 0.314738  [500/938]</span><br><span class=\"line\">&gt;loss: 0.298739  [600/938]</span><br><span class=\"line\">&gt;loss: 0.459540  [700/938]</span><br><span class=\"line\">&gt;loss: 0.332978  [800/938]</span><br><span class=\"line\">&gt;loss: 0.406709  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 90.2%, Avg loss: 0.334828</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Epoch 3</span><br><span class=\"line\">&gt;-------------------------------</span><br><span class=\"line\">&gt;loss: 0.461890  [  0/938]</span><br><span class=\"line\">&gt;loss: 0.242303  [100/938]</span><br><span class=\"line\">&gt;loss: 0.281414  [200/938]</span><br><span class=\"line\">&gt;loss: 0.207835  [300/938]</span><br><span class=\"line\">&gt;loss: 0.206000  [400/938]</span><br><span class=\"line\">&gt;loss: 0.409646  [500/938]</span><br><span class=\"line\">&gt;loss: 0.193608  [600/938]</span><br><span class=\"line\">&gt;loss: 0.217575  [700/938]</span><br><span class=\"line\">&gt;loss: 0.212817  [800/938]</span><br><span class=\"line\">&gt;loss: 0.202862  [900/938]</span><br><span class=\"line\">&gt;Test:</span><br><span class=\"line\">Accuracy: 91.9%, Avg loss: 0.280962</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Done!</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<blockquote>\r\n<p>训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。</p>\r\n</blockquote>\r\n<h3 id=\"保存模型\">保存模型</h3>\r\n<p>模型训练完成后，需要将其参数进行保存。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Save checkpoint</span></span><br><span class=\"line\">mindspore.save_checkpoint(model, <span class=\"string\">&quot;model.ckpt&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Saved Model to model.ckpt&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Saved Model to model.ckpt</p>\r\n</blockquote>\r\n<h3 id=\"加载模型\">加载模型</h3>\r\n<blockquote>\r\n<p>加载保存的权重分为两步：</p>\r\n<ol type=\"1\">\r\n<li>重新实例化模型对象，构造模型。</li>\r\n<li>加载模型参数，并将其加载至模型上。</li>\r\n</ol>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Instantiate a random initialized model</span></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"comment\"># Load checkpoint and load parameter to model</span></span><br><span class=\"line\">param_dict = mindspore.load_checkpoint(<span class=\"string\">&quot;model.ckpt&quot;</span>)</span><br><span class=\"line\">param_not_load, _ = mindspore.load_param_into_net(model, param_dict)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(param_not_load)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p><code>param_not_load未被加载的参数列表，为空时代表所有参数均加载成功。</code></p>\r\n</blockquote>\r\n<blockquote>\r\n<p>加载后的模型可以直接用于预测推理。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model.set_train(<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> data, label <span class=\"keyword\">in</span> test_dataset:</span><br><span class=\"line\">    pred = model(data)</span><br><span class=\"line\">    predicted = pred.argmax(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Predicted: &quot;<span class=\"subst\">&#123;predicted[:<span class=\"number\">10</span>]&#125;</span>&quot;, Actual: &quot;<span class=\"subst\">&#123;label[:<span class=\"number\">10</span>]&#125;</span>&quot;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<p>以上就是一个简单的图像识别机械学习</p>\r\n<p><strong>注意在加载模型的过程中必须定义模型构建与datapipe</strong></p>\r\n<h2 id=\"归一化处理\">归一化处理</h2>\r\n<blockquote>\r\n<p>一些传送门： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWRkbGVwZWRpYS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvdHV0b3JpYWxzL2RlZXBfbGVhcm5pbmcvbm9ybWFsaXphdGlvbi9iYXNpY19ub3JtYWxpemF0aW9uLmh0bWw=\">归一化基础知识点\r\n— PaddleEdu documentation (paddlepedia.readthedocs.io)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9nZWVrLWRvY3MuY29tL251bXB5L251bXB5LWFzay1hbnN3ZXIvbm9ybWFsaXplLW51bXB5LWFycmF5X3oxLmh0bWw=\">Numpy数组归一化|极客教程\r\n(geek-docs.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n</blockquote>\r\n<p>归一化是一种数据处理方式，能将数据经过处理后限制在某个固定范围内。</p>\r\n<h3 id=\"归一化处理的两种形式\">归一化处理的两种形式</h3>\r\n<p>归一化存在两种形式</p>\r\n<ol type=\"1\">\r\n<li>将数处理为 [0, 1]\r\n之间的小数，其目的是为了在随后的数据处理过程中更便捷，其他情况下，也可将数据处理到\r\n[-1, 1] 之间，或其他的固定范围内。</li>\r\n</ol>\r\n<blockquote>\r\n<p>例如，在图像处理中，就会将图像从 [0, 255] 归一化到 [0,\r\n1]之间，这样既不会改变图像本身的信息储存，又可加速后续的网络处理。</p>\r\n</blockquote>\r\n<ol start=\"2\" type=\"1\">\r\n<li>通过归一化将有<a href=\"#有/无量纲表达式\">量纲表达式</a>变成<a\r\nhref=\"#有/无量纲表达式\">无量纲表达式</a>。</li>\r\n</ol>\r\n<h3 id=\"为什么要进行归一化\">为什么要进行归一化</h3>\r\n<ol type=\"1\">\r\n<li>解决数据间的可比性问题</li>\r\n<li>数据归一化后，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。<a\r\nhref=\"为什么归一化能提高求解最优解的速度\">为什么能提高收敛速度</a>.</li>\r\n</ol>\r\n<h3 id=\"归一化类型\">归一化类型</h3>\r\n<ol type=\"1\">\r\n<li>Min-max normalization (Rescaling) 范围为[0,1]:</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - min(x)}{max(x) - min(x)}\r\n\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Mean normalization范围为[-1,1]：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - mean(x)}{max(x) - min(x)}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>mean(x)：x数据的平均值</p>\r\n</blockquote>\r\n<p>​\r\nMin-max归一化和mean归一化适合在最大最小值明确不变的情况下使用，比如图像处理时，灰度值限定在\r\n[0, 255] 的范围内，就可以用min-max归一化将其处理到[0,\r\n1]之间。在最大最小值不明确时，每当有新数据加入，都可能会改变最大或最小值，导致归一化结果不稳定，后续使用效果也不稳定。同时，数据需要相对稳定，如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。如果对处理后的数据范围有严格要求，也应使用min-max归一化或mean归一化。</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Z-score normalization (Standardization)范围为实数集：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - \\mu}{\\sigma}\r\n\\]</span></p>\r\n<blockquote>\r\n<p>𝜇、𝜎 分别为样本数据的均值和标准差。</p>\r\n</blockquote>\r\n<p>​\r\nZ-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。标准化会改变数据的状态分布，但不会改变分布的种类。特别地，神经网络中经常会使用到z-score归一化，针对这一点，我们将在后续的文章中进行详细的介绍。</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>对数归一化：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{\\lg x}{\\lg max(x)}\r\n\\]</span></p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>反正切函数归一化：</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\arctan(x) * \\frac{2}{\\pi}\r\n\\]</span></p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>小数定标标准化（Demical Point Normalization）:</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x}{10^j}\r\n\\]</span></p>\r\n<p>​\r\n非线性归一化通常被用在数据分化程度较大的场景，有时需要通过一些数学函数对原始值进行映射，如对数、反正切等。</p>\r\n<h3 id=\"归一化和标准化的联系与区别\">归一化和标准化的联系与区别</h3>\r\n<p>谈到归一化和标准化可能会存在一些概念的混淆，我们都知道归一化是指normalization，标准化是指standardization，但根据wiki上对feature\r\nscaling方法的定义，standardization其实就是z-score\r\nnormalization，也就是说标准化其实是归一化的一种，而一般情况下，我们会把z-score归一化称为标准化，把min-max归一化简称为归一化。在下文中，我们也是用标准化指代z-score归一化，并使用归一化指代min-max归一化。</p>\r\n<p>其实，归一化和标准化在本质上都是一种线性变换。在<a\r\nhref=\"#归一化类型\">归一化类型</a>中，我们提到了归一化和标准化的公式，对于归一化的公式，在数据给定的情况下，可以令𝑎=𝑚𝑎𝑥(𝑥)−𝑚𝑖𝑛(𝑥)、𝑏=𝑚𝑖𝑛(𝑥)，则归一化的公式可变形为：\r\n<span class=\"math display\">\\[\r\nx^{&#39;} = \\frac{x - b}{a} = \\frac{x}{a} - \\frac{b}{a} = \\frac{x}{a} -\r\nc\r\n\\]</span> 标准化的公式与变形后的归一化类似，其中的$<span\r\nclass=\"math inline\">\\(和\\)</span>$在数据给定的情况下，可以看作常数。因此，标准化的变形与归一化的类似，都可看作对𝑥按比例𝑎进行缩放，再进行𝑐个单位的平移。由此可见，归一化和标准化的本质都是一种线性变换，他们都不会因为对数据的处理而改变数据的原始数值排序。</p>\r\n<p>那么归一化和标准化又有什么区别呢？</p>\r\n<ol type=\"1\">\r\n<li>归一化不会改变数据的状态分布，但标准化会改变数据的状态分布；</li>\r\n<li>归一化会将数据限定在一个具体的范围内，如 [0,\r\n1]，但标准化不会，标准化只会将数据处理为均值为0，标准差为1。</li>\r\n</ol>\r\n<h3\r\nid=\"为什么归一化能提高求解最优解的速度\">为什么归一化能提高求解最优解的速度</h3>\r\n<p><span class=\"math display\">\\[\r\n\\begin{split}\r\n\\begin{align}\r\ny &amp;= \\theta_1x_1 + \\theta_2x_2 \\\\\r\nJ &amp;= (\\theta_{1}x_{1} + \\theta_{2}x_{2} - y_{label})^2\r\n\\end{align}\r\n\\end{split}\r\n\\]</span></p>\r\n<p>假设自变量只有房子到地铁站的距离<span\r\nclass=\"math display\">\\[𝑥_1\\]</span>和房子内房间的个数<span\r\nclass=\"math display\">\\[𝑥_2\\]</span>，因变量为房价，预测公式和损失函数分别为：</p>\r\n<p><span class=\"math display\">\\[\r\nJ = (1000\\theta_{1}+3\\theta_{2} - y_{label})^2\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/QAonmGKX4FqxUMt.png\"\r\nalt=\"normalization\" />\r\n<figcaption aria-hidden=\"true\">normalization</figcaption>\r\n</figure>\r\n<div data-align=\"center\">\r\n图1: 损失函数的等高线，图1（左）为未归一化时，图1（右）为归一化\r\n</div>\r\n<p>​\r\n在图1中，左图的红色椭圆代表归一化前的损失函数等高线，蓝色线段代表梯度的更新，箭头的方向代表梯度更新的方向。寻求最优解的过程就是梯度更新的过程，其更新方向与登高线垂直。由于𝑥1\r\n和 𝑥2\r\n的量级相差过大，损失函数的等高线呈现为一个瘦窄的椭圆。因此如图1（左）所示，瘦窄的椭圆形会使得梯度下降过程呈之字形呈现，导致梯度下降速度缓慢。</p>\r\n<p>​ 当数据经过归一化后，<span class=\"math inline\">\\(x_{1}^{&#39;} =\r\n\\frac{1000-0}{5000-0}=0.2\\)</span>，<span\r\nclass=\"math inline\">\\(x_{2}^{&#39;} =\r\n\\frac{3-0}{10-0}=0.3\\)</span>，那么损失函数的公式可以写为： <span\r\nclass=\"math display\">\\[\r\nJ(x) = (0.2\\theta_{1} + 0.3\\theta_{2} - y_{label})^2\r\n\\]</span> ​\r\n我们可以看到，经过归一化后的数据属于同一量级，损失函数的等高线呈现为一个矮胖的椭圆形（如图1（右）所示），求解最优解过程变得更加迅速且平缓，因此可以在通过梯度下降进行求解时获得更快的收敛。</p>\r\n<h2 id=\"有无量纲表达式\">有/无量纲表达式</h2>\r\n<p>我们假定数据都是一个个变量（不过提前收集好了）量纲指有些未知数他们是变量存在的一种或几种依赖关系，该变量的值由这些依赖关系的未知数（量纲）决定。</p>\r\n<blockquote>\r\n<p>就像一些函数的y值，理想状态下的房价，他们由x，面积/位置决定。</p>\r\n</blockquote>\r\n<p>显然位置差几百米，面积差几百平方米对变量影响差距极大，这种情况下我们称对这些依赖关系式是有量纲的。他们对变量影响的系数存在数量级的不同。</p>\r\n<h2 id=\"常见问题\">常见问题</h2>\r\n<ol type=\"1\">\r\n<li>vscode\r\n出现python解释器的选择错误，这在windows经常有非常多版本的相同软件上经常出现，选定安装MindSpore库的python版本</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/05/QSIFMsjBCUAo34y.png\"\r\nalt=\"image-20240605210110827\" />\r\n<figcaption aria-hidden=\"true\">image-20240605210110827</figcaption>\r\n</figure>\r\n<p>​ 点击此处python版本即可</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>注意python的多数语法检查集成已分离为插件，一些在2023.10发布，发布后一些网络上的blog修改linting的将禁用，详情请看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUtcHl0aG9uL3dpa2kvTWlncmF0aW9uLXRvLVB5dGhvbi1Ub29scy1FeHRlbnNpb25z\">迁移到\r\nPython 工具扩展 ·microsoft/vscode-python 维基 (github.com)<i class=\"fa fa-external-link-alt\"></i></span></p></li>\r\n<li><p>解决一些格式上的报错也可以不理会，但根据PEP 8\r\npython规范，一行不能超过80个字符，同时换行需要缩进,如果看不管可以在扩展语法检查中增加args</p></li>\r\n</ol>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--max-line-length=120</span><br></pre></td></tr></table></figure>"},{"title":"MindSpore专题——番外、Trans Fore模型","date":"2024-08-14T11:47:58.000Z","_content":"# Transformer\n\nTransformer是一种神经网络结构，有Vaswani等人在2017年的论文“Attention Is All You Need”中提出，用于处理机器翻译、语言建模和文本生成登自然语言处理任务。\n\n<!--more-->\n\nTransformer与传统NLP特征提取类模型的区别主要在以下两点。\n\n- Transformer是一个纯基于注意力机制的结构，并将自**注意力机制**和**多头注意力机制**的概念运用到模型中；\n- 由于缺少RNN模型的时序性，Transformer引入了位置编码，在数据上而非模型中添加位置信息；\n\n以上的处理带来了几个优点\n\n- 更容易并行化，训练更加高效；\n- 在处理长序列的任务中表现优秀，可以快速捕捉长距离中的关联信息；\n\n## 注意力机制\n\n注意力机制是判断词在句子中的重要性，通过**注意力分数**来表达某个词在句子中的重要性\n\n### 注意力分数的计算\n\n#### query、key、value\n\n- query:任务内容_目标序列_\n- key:索引/标签（帮助定位到答案）_原序列_\n- value:答案\n\n![image-20240629145758835](https://s2.loli.net/2024/06/29/ESPv4kLWxinFZqy.png)\n\n#### 常用的计算注意力分数的方法\n\nadditive attention可加性注意力计算方法\n\nscaled dot-product attention缩放的“点-积”注意力\n\n","source":"_posts/special_subject/MindSpore/Chapters/TransformerStructure.md","raw":"---\ntitle: MindSpore专题——番外、Trans Fore模型\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n# Transformer\n\nTransformer是一种神经网络结构，有Vaswani等人在2017年的论文“Attention Is All You Need”中提出，用于处理机器翻译、语言建模和文本生成登自然语言处理任务。\n\n<!--more-->\n\nTransformer与传统NLP特征提取类模型的区别主要在以下两点。\n\n- Transformer是一个纯基于注意力机制的结构，并将自**注意力机制**和**多头注意力机制**的概念运用到模型中；\n- 由于缺少RNN模型的时序性，Transformer引入了位置编码，在数据上而非模型中添加位置信息；\n\n以上的处理带来了几个优点\n\n- 更容易并行化，训练更加高效；\n- 在处理长序列的任务中表现优秀，可以快速捕捉长距离中的关联信息；\n\n## 注意力机制\n\n注意力机制是判断词在句子中的重要性，通过**注意力分数**来表达某个词在句子中的重要性\n\n### 注意力分数的计算\n\n#### query、key、value\n\n- query:任务内容_目标序列_\n- key:索引/标签（帮助定位到答案）_原序列_\n- value:答案\n\n![image-20240629145758835](https://s2.loli.net/2024/06/29/ESPv4kLWxinFZqy.png)\n\n#### 常用的计算注意力分数的方法\n\nadditive attention可加性注意力计算方法\n\nscaled dot-product attention缩放的“点-积”注意力\n\n","slug":"special_subject/MindSpore/Chapters/TransformerStructure","published":1,"updated":"2024-08-16T08:59:16.882Z","_id":"clzwh7bb700aj2wwv7g6a9t4v","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"transformer\">Transformer</h1>\r\n<p>Transformer是一种神经网络结构，有Vaswani等人在2017年的论文“Attention\r\nIs All You\r\nNeed”中提出，用于处理机器翻译、语言建模和文本生成登自然语言处理任务。</p>\r\n<span id=\"more\"></span>\r\n<p>Transformer与传统NLP特征提取类模型的区别主要在以下两点。</p>\r\n<ul>\r\n<li>Transformer是一个纯基于注意力机制的结构，并将自<strong>注意力机制</strong>和<strong>多头注意力机制</strong>的概念运用到模型中；</li>\r\n<li>由于缺少RNN模型的时序性，Transformer引入了位置编码，在数据上而非模型中添加位置信息；</li>\r\n</ul>\r\n<p>以上的处理带来了几个优点</p>\r\n<ul>\r\n<li>更容易并行化，训练更加高效；</li>\r\n<li>在处理长序列的任务中表现优秀，可以快速捕捉长距离中的关联信息；</li>\r\n</ul>\r\n<h2 id=\"注意力机制\">注意力机制</h2>\r\n<p>注意力机制是判断词在句子中的重要性，通过<strong>注意力分数</strong>来表达某个词在句子中的重要性</p>\r\n<h3 id=\"注意力分数的计算\">注意力分数的计算</h3>\r\n<h4 id=\"querykeyvalue\">query、key、value</h4>\r\n<ul>\r\n<li>query:任务内容_目标序列_</li>\r\n<li>key:索引/标签（帮助定位到答案）<em>原序列</em></li>\r\n<li>value:答案</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/29/ESPv4kLWxinFZqy.png\"\r\nalt=\"image-20240629145758835\" />\r\n<figcaption aria-hidden=\"true\">image-20240629145758835</figcaption>\r\n</figure>\r\n<h4 id=\"常用的计算注意力分数的方法\">常用的计算注意力分数的方法</h4>\r\n<p>additive attention可加性注意力计算方法</p>\r\n<p>scaled dot-product attention缩放的“点-积”注意力</p>\r\n","length":325,"excerpt":"<h1 id=\"transformer\">Transformer</h1>\r\n<p>Transformer是一种神经网络结构，有Vaswani等人在2017年的论文“Attention\r\nIs All You\r\nNeed”中提出，用于处理机器翻译、语言建模和文本生成登自然语言处理任务。</p>","more":"<p>Transformer与传统NLP特征提取类模型的区别主要在以下两点。</p>\r\n<ul>\r\n<li>Transformer是一个纯基于注意力机制的结构，并将自<strong>注意力机制</strong>和<strong>多头注意力机制</strong>的概念运用到模型中；</li>\r\n<li>由于缺少RNN模型的时序性，Transformer引入了位置编码，在数据上而非模型中添加位置信息；</li>\r\n</ul>\r\n<p>以上的处理带来了几个优点</p>\r\n<ul>\r\n<li>更容易并行化，训练更加高效；</li>\r\n<li>在处理长序列的任务中表现优秀，可以快速捕捉长距离中的关联信息；</li>\r\n</ul>\r\n<h2 id=\"注意力机制\">注意力机制</h2>\r\n<p>注意力机制是判断词在句子中的重要性，通过<strong>注意力分数</strong>来表达某个词在句子中的重要性</p>\r\n<h3 id=\"注意力分数的计算\">注意力分数的计算</h3>\r\n<h4 id=\"querykeyvalue\">query、key、value</h4>\r\n<ul>\r\n<li>query:任务内容_目标序列_</li>\r\n<li>key:索引/标签（帮助定位到答案）<em>原序列</em></li>\r\n<li>value:答案</li>\r\n</ul>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/29/ESPv4kLWxinFZqy.png\"\r\nalt=\"image-20240629145758835\" />\r\n<figcaption aria-hidden=\"true\">image-20240629145758835</figcaption>\r\n</figure>\r\n<h4 id=\"常用的计算注意力分数的方法\">常用的计算注意力分数的方法</h4>\r\n<p>additive attention可加性注意力计算方法</p>\r\n<p>scaled dot-product attention缩放的“点-积”注意力</p>"},{"title":"MindSpore专题——第六章——函数式微分","date":"2024-08-14T11:47:58.000Z","_content":"## 函数式自动微分\n\n> 神经网络的训练主要使用反向传播算法，模型预测值（logits）与正确标签（label）送入损失函数（loss function）获得loss，然后进行反向传播计算，求得梯度（gradients），最终更新至模型参数（parameters）。自动微分能够计算可导函数在某点处的导数值，是反向传播算法的一般化。自动微分主要解决的问题是将一个复杂的数学运算分解为一系列简单的基本运算，该功能对用户屏蔽了大量的求导细节和过程，大大降低了框架的使用门槛。\n\n<!--more-->\n\n> MindSpore使用函数式自动微分的设计理念，提供更接近于数学语义的自动微分接口`grad`和`value_and_grad`。下面我们使用一个简单的单层线性变换模型进行介绍。\n\n这里总算是提到了反向传播，最近我看到了一系列视频有关Machine Learning，传送门如下：\n\n[🔴 World of Warships / USS Des Moines cut (youtube.com)](https://www.youtube.com/watch?v=Ilg3gGewQ5U)\n\n如果你试图看下去的话，可能会发现，事情好像突然变难了，似乎一群从未见过的知识组合在了一起，神经网络就像一个黑箱连着另一个黑箱，而你根本不知道如何优化它，使得黑箱在给定的输入下输出正确答案\n\n## 神经网络到底代表了什么\n\n首先让我们定义什么是神经：他是一个携带一个浮点数的结构，然后让我们看向神经网络\n\n![R](https://s2.loli.net/2024/06/07/MLN1Ap2wslU4SQB.jpg)\n\n对于每一个点，我们从最后看起，显然，他们代表0-9，更准确的说，他们代表0-9的图像。为什么这样的网络是生效的呢？\n\n***因为分形思想***，我们将一段连续的图像区分为一段一段，比如9是⚪在上而线条在下。4由多端线段1组成。而⚪和线条又可以继续再分，我们可以将神经网络中的每一个节点代表的数据想象成这种规律图案的集合。他们之间的传递就是图案在网络中不断组合。这也是为什么在网络中使用全连接的原因，因为每一个图案都能与其他任何图案组合。最终我们使图案变成了不断分形像素的组合。\n\n但如何做到这一点呢？ 考虑我们前面提到的参数，权值。\n\n![image-20240607181215798](./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240607181215798.png)\n\n这张图相信有很多人见过类似的图，实际上权值代表的就是神经网络之间的连线，假设我们让正权值在下表中为绿负权值在下表中为红，我们将这样描述一条“线段”：一段由红色包围的长条状绿色区域这样我们就能得出，如果这段线条是成立得话，比如确实原图这里存在一条线段，我们得到的这个神经节点上得值就会很接近1，否则就会很接近零。这就是权值得意义。但同时，我们会注意到神经得值是许多这样计算的累和，因此我们需要一个bias，偏差值将其计算到到0-1。\n\n注意这里得权值和偏差值均是变量，是训练出来的。并且注意，我们并不知道机器是如何分形得，这取决于学习数据和使用的算法，以上只为举例理解。\n\n如果将最初得神经网络拿去使用，你只会得到一大堆垃圾数据。我们都知道神经网络存在“进化”过程，但他是如何知道自己错得有多离谱的呢？\n\n## Cost Function（Maybe also loss function?）\n\n初略的定义是他是输出的张量与正确的张量的差值平方和，比如，机器输出了一个全是0.5的10个数的张量，而正确答案是其中之一，那么\n$$\n\\text{Cost} = (1-0.5) + 0.5*9\n$$\n显然这个数字更接近0，说明结果更加准确\n\n考虑如何让模型表现得更好，显然是需要找到一组参数，使得每次输出的cost值最小。我们可以考虑这样一种方式，以参数作为输入，cost的值作为输出，而训练数据则是参数。\n\n### 梯度下降 (Gradient Descent)\n\n似乎难以理解，假设我们只有一个参数cost=f(c)，c是唯一的参数。于是变为了函数的最值问题，只需要求导数然后慢慢移动我们的初始点。很显然，一个函数在常数域上可能存在多个极大值而只有一个最大值。当我们从一个点出发寻找最大值时，很有可能（概率学上讲应该是绝对）我们只会找到一个极大值。即在神经网络中，我们不能保证我们的参数是最优的，只能保证我们的参数是局部最优的（这取决于我们的起始点）。\n\n变到多维，我们意识到，一个数的导数是否只有正或负两种信息有效（代表是应该增加这个数还是减少这个数）。假定两个变量在一个点上的导数其中一个是另一个的三倍，这至少说明在该点的邻域内，这一变量应该减少的更多是正确的。（可能有一些函数存在极端的尖点导致错误，但这在神经网络中是低概率的，掌控好更改数据的大小即可）。\n\n一个简单的例子是，维护好一个$$\\nabla C$$矩阵，一阶导数对应的值高则其增加，反之则减少。\n\n## 反向传播\n\n从特殊到一般，我们先观察这样一个样例\n\n![image-20240607205110764](https://s2.loli.net/2024/06/07/SJ5Rf7m6cXFs8yN.png)\n\n显然我们需要增加2，并且如果给我们要做的事情做出一个排序，增加2显然排在减少8之前。\n\n因此，让我们继续看增加2所涉及的值\n\n1. 更改偏差值\n2. 更改权值（根据节点值）\n3. 更改上一层节点的值（根据权值）\n\n我们对权值和边权同时改变，并统计下一层节点需要的变化对上一层的节点影响的累和\n\n通过多组数据得出权值的总共改变值改变值。这就是随机梯度下降（Stochastic gradient descent）\n\n下面简单讲一讲其他的名词解释\n\n## Mini-batches\n\n和他的名字一样，这个技术就是将训练数据分为几组以提高收敛参数的效率\n\n## Backpropagation\n\n反向传播是一种梯度下降法的应用，通过链式法则计算损失函数相对于每个权重的梯度，然后利用这些梯度来更新权重。\n\n## 函数与计算图\n\n![compute-graph](https://s2.loli.net/2024/06/07/iqHnjI12DSKR6P7.png)\n\n> 计算图是用图论语言表示数学函数的一种方式，也是深度学习框架表达神经网络模型的统一方法。我们将根据下面的计算图构造计算函数和神经网络。\n\n> 在这个模型中，𝑥为输入，𝑦为正确值，𝑤和𝑏是我们需要优化的参数。\n\n1. 𝑥为输入\n2. 𝑦为正确值\n3. 𝑤和𝑏是我们需要优化的参数\n\n即对应了原始数据，输出结果，权重和偏差\n\n```python\nx = ops.ones(5, mindspore.float32)  # input tensor\ny = ops.zeros(3, mindspore.float32)  # expected output\nw = Parameter(Tensor(np.random.randn(5, 3), mindspore.float32), name='w') # weight\nb = Parameter(Tensor(np.random.randn(3,), mindspore.float32), name='b') # bias\n```\n\n> 我们根据计算图描述的计算过程，构造计算函数。 其中，[binary_cross_entropy_with_logits](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.binary_cross_entropy_with_logits.html) 是一个损失函数，计算预测值和目标值之间的二值交叉熵损失。\n\n解释一下Parameter(): **Parameter** 是 Tensor 的子类，当它们被绑定为Cell的属性时，会自动添加到其参数列表中，并且可以通过Cell的某些方法获取，例如 cell.get_**parameter**s() 。\n\n```python\ndef function(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss\n\nloss = function(x, y, w, b)\nprint(loss)\n```\n\n这里有复杂概念[*二值交叉熵损失*](#二值交叉熵损失)，如果你不想深究只需要这是一个对参数的函数，当这个函数值最低时，整体参数就是一个准确率较高的局部最优解即可。\n\n## 微分函数与梯度计算\n\n>  为了优化模型参数，需要求参数对loss的导数：$$\\frac{𝜕loss}{𝜕𝑤}$$和$$\\frac{𝜕loss}{𝜕𝑏}$$，此时我们调用`mindspore.grad`函数，来获得`function`的微分函数。\n\n> 这里使用了`grad`函数的两个入参，分别为：\n>\n> - `fn`：待求导的函数。\n> - `grad_position`：指定求导输入位置的索引。\n\n> 由于我们对$$𝑤$$和$$𝑏$$​求导，因此配置其在`function`入参对应的位置`(2, 3)`。\n\n> *使用`grad`获得微分函数是一种函数变换，即输入为函数，输出也为函数。*\n\n```python\ngrad_fn = mindspore.grad(function, (2, 3))\n\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n```\n\n> ```\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]]), Tensor(shape=[3], dtype=Float32, value= [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]))\n> ```\n\n执行微分函数，即可获得$$𝑤$$、$$𝑏$$​对应的梯度。可以注意到w,b的梯度与最初始的梯度是一致的。\n\n### Stop Gradient\n\n> 通常情况下，求导时会求loss对参数的导数，因此函数的输出只有loss一项。**当我们希望函数输出多项时，微分函数会求所有输出项对参数的导数**。此时如果想实现对某个输出项的梯度截断，或消除某个Tensor对梯度的影响，需要用到Stop Gradient操作。\n\n> 这里我们将`function`改为同时输出loss和z的`function_with_logits`，获得微分函数并执行。\n\n```python\ndef function_with_logits(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss, z\n\ngrad_fn = mindspore.grad(function_with_logits, (2, 3))\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n```\n\n```python\ndef function_stop_gradient(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss, ops.stop_gradient(z)\n\ngrad_fn = mindspore.grad(function_stop_gradient, (2, 3))\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n\n```\n\n`ops.stop_gradient(z)`:重点在该函数，表示屏蔽了z对梯度的影响，即仍只求参数对loss的导数。\n\n这里解释一下一些api的含义\n\n```python\nmindspore.grad(fn, grad_position=0, weights=None, has_aux=False, return_ids=False)\n```\n\n- [MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.grad.html?highlight=grad#mindspore.grad)\n\n```\nmindspore.numpy.matmul(x1, x2, dtype=None)\n```\n\n- [MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/numpy/mindspore.numpy.matmul.html?highlight=matmul#mindspore.numpy.matmul)\n\n### Auxiliary data\n\nAuxiliary data意为辅助数据，是函数除第一个输出项外的其他输出。通常我们会将函数的loss设置为函数的第一个输出，其他的输出即为辅助数据。\n\n`grad`和`value_and_grad`提供`has_aux`参数，当其设置为`True`时，可以自动实现前文手动添加`stop_gradient`的功能，满足返回辅助数据的同时不影响梯度计算的效果。\n\n下面仍使用`function_with_logits`，配置`has_aux=True`，并执行。\n\n```python\ngrad_fn = mindspore.grad(function_with_logits, (2, 3), has_aux=True)\ngrads, (z,) = grad_fn(x, y, w, b)\nprint(grads, z)\n```\n\n### 神经网络梯度计算\n\n>  前述章节主要根据计算图对应的函数介绍了MindSpore的函数式自动微分，但我们的神经网络构造是继承自面向对象编程范式的`nn.Cell`。接下来我们通过`Cell`构造同样的神经网络，利用函数式自动微分来实现反向传播。\n\n> 首先我们继承`nn.Cell`构造单层线性变换神经网络。这里我们直接使用前文的𝑤、𝑏作为模型参数，使用`mindspore.Parameter`进行包装后，作为内部属性，并在`construct`内实现相同的Tensor操作。\n\n这里出现了反向传播方法,并且是包装好的,建议读者仔细看一下代码并尝试自己运行一下。\n\n```python\n# 定义神经网络模型\n# Define model\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.w = w\n        self.b = b\n\n    def construct(self, x):\n        z = ops.matmul(x, self.w) + self.b\n        return z\n\n\n# Instantiate model\nmodel = Network()\n# Instantiate loss function\nloss_fn = nn.BCEWithLogitsLoss()\n\n\n# Define forward function\ndef forward_fn(x, y):\n    z = model(x)\n    loss = loss_fn(z, y)\n    return loss\n\n\n# 注入损失函数\ngrad_fn = mindspore.value_and_grad(forward_fn, None, weights=model.trainable_params())\nloss, grads = grad_fn(x, y)\nprint(grads)\n```\n\n### 总结输出（单次）\n\n> ```\n> 0.92031693\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> 计算多个参数的导数\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]]), Tensor(shape=[3], dtype=Float32, value= [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]))\n> 消除部分张量对梯度的影响\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> Auxiliary data 辅助数据测试\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01])) [ 0.8580145   0.62723386 -0.44728255]      \n> 开始实测网络模型的反向传播\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> ```\n\n可见，除了在计算z的导数对梯度的影响情况下，均保持了相同的输出，并且可以观察到w,b的权值\n\n## 二值交叉熵损失\n\n***以下的对数均为自然对数***\n\nBinary cross entropy 二元[交叉熵](https://zh.wikipedia.org/wiki/交叉熵)是二分类问题中常用的一个Loss损失函数，在常见的机器学习模块中都有实现。就二元交叉熵这个损失函数的原理，简单地进行解释。下面是二元交叉熵损失函数的公式\n$$\nL=-\\frac1N \\sum_{i=1}^{N}[y_ilog(p_i)+(1-y_i)log(1-p_i)]\n$$\n先不尝试理解他，先看看他是如何运作的\n\n![img](https://s2.loli.net/2024/06/07/MAOZxqKodRSW6uy.jpg)\n$$\nL=\\frac13[(1*log0.8+(1-1)*log(1-0.8))+(0*log0.2+(1-0)*log(1-0.2))+(0*log0.4+(1-0)*log(1-0.4))]=0.319 \\\\\n$$\n对于以上的案例计算损失函数，结果是0.31903\n\n### 从熵来看交叉熵损失\n\n#### 信息量\n\n信息量来衡量一个事件的不确定性，一个事件发生的概率越大，不确定性越小，则其携带的信息量就越小。\n\n设$$X$$是一个离散型随机变量，其取值为集合$$X = {x_0,x_1,\\dots,x_n}$$，则其概率分布函数为$$p(x) = Pr(X = x),x \\in X$$，则定义事件$$X=x_0$$的信息量为：\n$$\nI(x_0) = -\\log(p(x_0))\n$$\n当$$p(x_0) = 1$$时，其携带的信息量为0。\n\n#### 熵\n\n熵用来衡量一个系统的混乱程度，代表系统中信息量的总和；熵值越大，表明这个系统的不确定性就越大。具体而数学的讲，熵就是一个系统中所有信息量的期望。\n\n信息量是衡量某个事件的不确定性，而熵是衡量一个系统（所有事件）的不确定性。\n\n熵的计算公式\n$$\nH(x) = -\\sum_{i=1}^np(x_i)\\log(p(x_i))\n$$\n比较特殊的有二项分布熵\n$$\n\\begin{eqnarray}\nH(X)&=&-\\sum_{i=1}^n p(x_i)log(p(x_i))\\\\\n&=&-p(x)log(p(x))-(1-p(x))log(1-p(x))\n\\end{eqnarray}\n$$\n*熵也有其他类型的计算公式，这里是信息学上的定义*\n\n其中$$p(x)$$为这件事发生的概率，$$-log(p(x_i))$$是事件$$x_i$$所携带的信息量。\n\n可以看出，熵是信息量的期望值，是一个随机变量（一个系统，事件所有可能性）不确定性的度量。熵值越大，随机变量的取值就越难确定，系统也就越不稳定；熵值越小，随机变量的取值也就越容易确定，系统越稳定。\n\n#### 相对熵 （Relative entropy）/  KL散度\n\nwiki对相对熵的定义如下：`In the context of machine learning, DKL(P‖Q) is often called the information gain achieved if P is used instead of Q.`\n\n即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。\n\n在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。\n\n总结：相对熵也称为KL散度(Kullback-Leibler divergence)，表示同一个随机变量的两个不同分布间的距离。\n\n设 $$p(x),𝑞(𝑥)$$分别是 离散随机变量$$X$$的两个概率分布，则$$p$$对$$q$$的相对熵是：\n$$\nD_{KL}(p \\parallel q) = \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\n$$\n相对熵具有以下性质：\n\n- 如果p(x)和q(x)的分布相同，则其相对熵等于0\n- $$D_{KL}(p∥q)≠D_{KL}(q∥p)𝐷_{𝐾𝐿}(𝑝∥𝑞)≠𝐷_{𝐾𝐿}(𝑞∥𝑝)$$，也就是相对熵不具有对称性。\n- $$D_{KL}(p∥q)≥0$$\n\n总的来说，相对熵是用来衡量同一个随机变量的两个不同分布之间的距离。**在实际应用中，假如p(x)是目标真实的分布，而q(x)是预测得来的分布，为了让这两个分布尽可能的相同的，就需要最小化KL散度。**\n\n#### 交叉熵 Cross Entropy\n\n设$$p(x),q(x)$$分别是 离散随机变量$$X$$的两个概率分布，其中$$p(x)$$是目标分布，$$p$$和$$q$$的交叉熵可以看做是，使用分布$$q(x)$$表示目标分布$$p(x)$$的困难程度\n$$\nH(p,q) = \\sum_ip(x_i)log\\frac{1}{\\log q(x_i)} = -\\sum_ip(x_i)\\log q(x_i)\n$$\n将熵、相对熵以及交叉熵的公式放到一起，\n$$\n\\begin{align}\nH(p) &= -\\sum_{i}p(x_i) \\log p(x_i) \\\\\nD_{KL}(p \\parallel q) &= \\sum_{i}p(x_i)\\log \\frac{p(x_i)}{q(x_i)} = \\sum_i (p(x_i)\\log p(x_i) - p(x_i) \\log q(x_i)) \\\\\nH(p,q) &=  -\\sum_ip(x_i)\\log q(x_i)\n\\end{align}\n$$\n通过上面三个公式就可以得到\n$$\nD_{KL}(p,q) = H(p,q)- H(p)\n$$\n其中，前一项$$H(p,q)$$就是$$p,q$$的交叉熵。在机器学习中，目标的分布$$p(x)$$通常是训练数据的分布是固定，即是$$H(p)$$是一个常量。这样两个分布的交叉熵$$H(p,q)$$也就等价于最小化这两个分布的相对熵$$D_{KL}(p \\parallel q)$$\n\n设$$p(x)$$是目标分布（训练数据的分布），我们的目标的就让训练得到的分布$$q(x)$$尽可能的接近$$p(x)$$，这时候就可以最小化$$D_{KL}(p∥q)$$，等价于最小化交叉熵$$H(p,q)$$​。\n\n### 为什么要用交叉熵做loss函数\n\n在线性回归问题中，常常使用MSE（Mean Squared Error）作为loss函数，比如：\n$$\nloss = \\frac{1}{2m}\\sum_{i=1}^m(y_i-\\hat{y_i})^2\n$$\n这里的m表示m个样本的，loss为m个样本的loss均值。\nMSE在[线性回归问题](# 回归问题)中比较好用，那么在逻辑分类问题中还是如此么？\n\n### 交叉熵在单分类问题中的使用\n\n这里的单类别是指，每一张图像样本只能有一个类别，比如只能是狗或只能是猫。\n交叉熵在单分类问题上基本是标配的方法\n$$\nloss=-\\sum_{i=1}^{n}y_ilog(\\hat{y_i})\n$$\n上式为一张样本的loss计算方法。n代表着n种类别。\n举例说明,比如有如下样本\n\n对应的标签和预测值\n\n| *     | 猫   | 青蛙 | 老鼠 |\n| ----- | ---- | ---- | ---- |\n| Label | 0    | 1    | 0    |\n| Pred  | 0.3  | 0.6  | 0.1  |\n\n\n$$\n\\begin{eqnarray}\nloss&=&-(0\\times log(0.3)+1\\times log(0.6)+0\\times log(0.1)\\\\\n&=&-log(0.6)\n\\end{eqnarray}\n$$\n对应的一个batch的loss就是\n$$\nloss=-\\frac{1}{m}\\sum_{j=1}^m\\sum_{i=1}^{n}y_{ji}log(\\hat{y_{ji}})\n$$\nm为当前batch的样本数\n\n### 交叉熵在多分类问题中的使用\n\n这里的多类别是指，每一张图像样本可以有多个类别，比如同时包含一只猫和一只狗\n和单分类问题的标签不同，多分类的标签是n-hot。\n比如下面这张样本图，即有青蛙，又有老鼠，所以是一个多分类问题\n\n栗子\n\n| *     | 猫   | 青蛙 | 老鼠 |\n| ----- | ---- | ---- | ---- |\n| Label | 0    | 1    | 1    |\n| Pred  | 0.1  | 0.7  | 0.8  |\n\n值得注意的是，这里的Pred不再是通过softmax计算的了，这里采用的是sigmoid。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。换句话说，就是每一个Label都是独立分布的，相互之间没有影响。所以交叉熵在这里是单独对每一个节点进行计算，每一个节点只有两种可能值，所以是一个二项分布。前面说过对于二项分布这种特殊的分布，熵的计算可以进行简化。\n\n同样的，交叉熵的计算也可以简化，即\n$$\nloss =-ylog(\\hat{y})-(1-y)log(1-\\hat{y})\n$$\n注意，上式只是针对一个节点的计算公式。这一点一定要和单分类loss区分开来。\n例子中可以计算为：\n$$\n\\begin{eqnarray}\nloss_猫 &=&-0\\times log(0.1)-(1-0)log(1-0.1)=-log(0.9)\\\\\nloss_蛙 &=&-1\\times log(0.7)-(1-1)log(1-0.7)=-log(0.7)\\\\\nloss_鼠 &=&-1\\times log(0.8)-(1-1)log(1-0.8)=-log(0.8)\n\\end{eqnarray}\n$$\n单张样本的loss即为\n每一个batch的loss就是：\n$$\nloss =\\sum_{j=1}^{m}\\sum_{i=1}^{n}-y_{ji}log(\\hat{y_{ji}})-(1-y_{ji})log(1-\\hat{y_{ji}})\n$$\n式中m为当前batch中的样本量，n为类别数。\n\n### 从[最大似然](# 最大似然估计)看交叉熵\n\n设有一组训练样本$X= \\{x_1,x_2,\\cdots,x_m\\}$ ,该样本的分布为$p(x)$ 。假设使用$\\theta$ 参数化模型得到$q(x;\\theta)$ ，现用这个模型来估计$X$ 的概率分布，得到似然函数\n$$\nL(\\theta) = q(X; \\theta) = \\prod_i^mq(x_i;\\theta)\n$$\n最大似然估计就是求得$\\theta$ 使得$L(\\theta)$ 的值最大，也就是\n$$\n\\theta_{ML} = arg \\max_{\\theta} \\prod_i^mq(x_i;\\theta)\n$$\n对上式的两边同时取$\\log$ ，等价优化$\\log$ 的最大似然估计即`log-likelyhood` ，最大对数似然估计\n$$\n\\theta_{ML} = arg \\max_\\theta \\sum_i^m \\log q(x_i;\\theta)\n$$\n对上式的右边进行缩放并不会改变$arg \\max$ 的解，上式的右边除以样本的个数$m$\n$$\n\\theta_{ML} = arg \\max_\\theta \\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\n$$\n\n#### 和相对熵等价\n\n上式的最大化$\\theta_{ML}$ 是和没有训练样本没有关联的，就需要某种变换使其可以用训练的样本分布来表示，因为训练样本的分布可以看作是已知的，也是对最大化似然的一个约束条件。\n\n注意上式的\n$$\n\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\n$$\n相当于**求随机变量$X$ 的函数$\\log (X;\\theta)$ 的均值** ，根据大数定理，**随着样本容量的增加，样本的算术平均值将趋近于随机变量的期望。** 也就是说\n$$\n\\frac{1}{m}\\sum_i^m \\log q(x_i;\\theta) \\rightarrow E_{x\\sim P}(\\log q(x;\\theta))\n$$\n其中$E_{X\\sim P}$ 表示符合样本分布$P$ 的期望，这样就将最大似然估计使用真实样本的期望来表示\n$$\n\\begin{aligned} \\theta_{ML} &= arg \\max_{\\theta} E_{x\\sim P}({\\log q(x;\\theta)}) \\\\ &= arg \\min_{\\theta} E_{x \\sim P}(- \\log q(x;\\theta)) \\end{aligned}\n$$\n对右边取负号，将最大化变成最小化运算。\n\n> 上述的推导过程，可以参考 《Deep Learning》 的第五章。 但是，在书中变为期望的只有一句话，将式子的右边除以样本数量$m$ 进行缩放，从而可以将其变为$E_{x \\sim p}\\log q(x;\\theta)$，没有细节过程，也可能是作者默认上面的变换对读者是一直。 确实是理解不了，查了很多文章，都是对这个变换的细节含糊其辞。一个周，对这个点一直耿耿于怀，就看了些关于概率论的科普书籍，其中共有介绍大数定理的：**当样本容量趋于无穷时，样本的均值趋于其期望**。\n>\n> 针对上面公式，除以$m$后，$\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)$ ，确实是关于随机变量函数$\\log q(x)$ 的算术平均值，而$x$ 是训练样本其分布是已知的$p(x)$ ，这样就得到了$E_{x \\sim p}(\\log q(x))$ 。\n\n$$\n\\begin{aligned} D_{KL}(p \\parallel q) &= \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\\\\ &= E_{x\\sim p}(\\log \\frac{p(x)}{q(x)}) \\\\ &= E_{x \\sim p}(\\log p(x) - \\log q(x)) \\\\ &= E_{x \\sim p}(\\log p(x)) - E_{x \\sim p} (\\log q(x)) \\end{aligned}\n$$\n\n由于$E_{x \\sim p} (\\log p(x))$ 是训练样本的期望，是个固定的常数，在求最小值时可以忽略，所以最小化$D_{KL}(p \\parallel q)$ 就变成了最小化$-E_{x\\sim p}(\\log q(x))$ ，这和最大似然估计是等价的。\n\n#### 和交叉熵等价\n\n最大似然估计、相对熵、交叉熵的公式如下\n$$\n\\begin{aligned}\\theta_{ML} &= -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log q(x) \\\\H(p,q) &= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log q(x)\\end{aligned}\\begin{aligned}\\theta_{ML} &= arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log q(x) \\\\H(p,q) &= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log q(x)\\end{aligned}\n$$\n从上面可以看出，最小化交叉熵，也就是最小化$D_{KL}$ ，从而预测的分布$q(x)$ 和训练样本的真实分布$p(x)$ 最接近。而最小化$D_{KL}$ 和最大似然估计是等价的。\n\n### 多分类交叉熵\n\n多分类任务中输出的是目标属于**每个类别的概率，所有类别概率的和为1，其中概率最大的类别就是目标所属的分类。** 而`softmax` 函数能将一个向量的每个分量映射到$[0,1]$ 区间，并且对整个向量的输出做了归一化，保证所有分量输出的和为1，正好满足多分类任务的输出要求。所以，在多分类中，在最后就需要将提取的到特征经过`softmax`函数的，输出为每个类别的概率，然后再使用**交叉熵** 作为损失函数。\n\n`softmax`函数定义如下：\n$$\nS_i = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\n$$\n其中，输入的向量为$z_i(i = 1,2,\\dots,n)$ 。\n\n更直观的参见下图\n\n![img](https://s2.loli.net/2024/06/07/XvLsuFKjBe39AaD.png)\n\n通过前面的特征提取到的特征向量为$(z_1,z_2,\\dots,z_k)$ ，将向量输入到`softmax`函数中，即可得到目标属于每个类别的概率，概率最大的就是预测得到的目标的类别。\n\n#### Cross Entropy Loss\n\n使用`softmax`函数可以将特征向量映射为所属类别的概率，可以看作是预测类别的概率分布$q(c_i)$ ，有\n$$\nq(c_i) = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\n$$\n其中$c_i$ 为某个类别。\n\n设训练数据中类别的概率分布为$p(c_i)$ ，那么目标分布$p(c_i)$ 和预测分布$q(c_i)$的交叉熵为\n\n$$H(p,q) =-\\sum_ip(c_i)\\log q(c_i) $$\n\n每个训练样本所属的类别是已知的，并且每个样本只会属于一个类别（概率为1），属于其他类别概率为0。具体的，可以假设有个三分类任务，三个类分别是：猫，猪，狗。现有一个训练样本类别为猫，则有：\n\n$$\\begin{align} p(cat) & = 1 \\\\ p(pig) &= 0 \\\\ p(dog) & = 0 \\end{align} $$\n\n通过预测得到的三个类别的概率分别为：$q(cat) = 0.6,q(pig) = 0.2,q(dog) = 0.2$ ，计算$p$ 和$q$ 的交叉熵为：\n$$\n\\begin{aligned} H(p,q) &= -(p(cat) \\log q(cat) + p(pig) + \\log q(pig) + \\log q(dog)) \\\\ &= - (1 \\cdot \\log 0.6 + 0 \\cdot \\log 0.2 +0 \\cdot \\log 0.2) \\\\ &= - \\log 0.6 \\\\ &= - \\log q(cat) \\end{aligned}\n$$\n利用这种特性，可以将样本的类别进行重新编码，就可以简化交叉熵的计算，这种编码方式就是**one-hot** 编码。以上面例子为例，\n$$\n\\begin{aligned} \\text{cat} &= (1 0 0) \\\\ \\text{pig} &= (010) \\\\ \\text{dog} &= (001) \\end{aligned}\n$$\n\n\n通过这种编码方式，在计算交叉熵时，只需要计算和训练样本对应类别预测概率的值，其他的项都是$0 \\cdot \\log q(c_i) = 0$ 。\n\n具体的，交叉熵计算公式变成如下：\n$$\n(p,q) = - \\log q(c_i)\n$$\n其中$c_i$ 为训练样本对应的类别，上式也被称为**负对数似然（negative log-likelihood,nll）**。\n\n#### PyTorch中的Cross Entropy\n\nPyTorch中实现交叉熵损失的有三个函数`torch.nn.CrossEntropyLoss`，`torch.nn.LogSoftmax`以及`torch.nn.NLLLoss`。\n\n- `torch.nn.functional.log_softmax` 比较简单，输入为$n$维向量，指定要计算的维度`dim`，输出为$log(Softmax(x))$。其计算公式如下：\n\n$$\n\\text{LogSoftmax}(x_i) = \\log (\\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)})\n$$\n\n没有额外的处理，就是对输入的$n$维向量的每个元素进行上述运算。\n\n- `torch.nn.functional.nll_loss` 负对数似然损失（Negative Log Likelihood Loss)，用于多分类，其输入的通常是`torch.nn.functional.log_softmax`的输出值。其函数如下\n\n```python\ntorch.nn.functional.nll_loss(input, target, weight=None, size_average=None, ignore_index=-100, reduce=None, reduction='mean')\n```\n\n`input` 也就是`log_softmax`的输出值，各个类别的对数概率。`target` 目标正确类别,`weight` 针对类别不平衡问题，可以为类别设置不同的权值；`ignore_index` 要忽略的类别，不参与loss的计算；比较重要的是`reduction` 的值，有三个取值：`none` 不做处理，输出的结果为向量；`mean` 将`none`结果求均值后输出；`sum` 将`none` 结果求和后输出。\n\n- `torch.nn.CrossEntropyLoss`就是上面两个函数的组合`nll_loss(log_softmax(input))`。\n\n### 二分类交叉熵\n\n多分类中使用`softmax`函数将最后的输出映射为每个类别的概率，而在二分类中则通常使用`sigmoid` 将输出映射为正样本的概率。这是因为二分类中，只有两个类别：{正样本，负样本}，只需要求得正样本的概率$q$,则$1-q$ 就是负样本的概率。这也是多分类和二分类不同的地方。\n\n$\\text{sigmoid}$ 函数的表达式如下：\n$$\n\\sigma(z) = \\frac{1}{1 + e^{-z}}\n$$\nsigmoid的输入为$z$ ，其输出为$(0,1)$ ，可以表示分类为正样本的概率。\n\n二分类的交叉熵可以看作是交叉熵损失的一个特列，交叉熵为\n$$\n\\text{$Cross\\_Entorpy$}(p,q) = -\\sum_i^m p(x_i) \\log q(x_i)\n$$\n这里只有两个类别$x \\in {x_1,x_2}$ ，则有\n$$\n\\begin{aligned}\\text{$Cross\\_Entorpy$}(p,q) &= -(p(x_1) \\log q(x_1) + p(x_2) \\log q(x_2)) \\end{aligned} \n$$\n\n\n因为只有两个选择，则有$p(x_1) + p(x_2) = 1,q(x_1) + q(x_2) = 1$ 。设，训练样本中$x_1$的概率为$p$，则$x_2$为$1-p$; 预测的$x_1$的概率为$q$，则$x_2$的预测概率为$1 - q$ 。则上式可改写为\n$$\n\\text{$Cross\\_Entropy$}(p,q) = -(p \\log q + (1-p) \\log (1-q))\n$$\n也就是二分类交叉熵的损失函数。\n\n### 总结\n\n相对熵可以用来度量两个分布相似性，假设分布$p$是训练样本的分布，$q$是预测得到的分布。分类训练的过程实际上就是最小化$D_{KL}(p \\parallel q)$，由于由于交叉熵\n$$\nH(p,q)= D_{KL}(p \\parallel q) + H(p)\n$$\n其中,$H(p)$是训练样本的熵，是一个已知的常量，这样最小化相对熵就等价于最小化交叉熵。\n\n从最大似然估计转化为最小化负对数似然\n$$\n\\theta_{ML} = -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta)\n$$\n也等价于最小化相对熵。\n\n## 回归问题\n\n回归：人们在测量事物的时候因为客观条件所限，求得的都是测量值，而不是事物真实的值，为了能够得到真实值，无限次的进行测量，最后通过这些测量数据计算**回归到真实值**，这就是回归的由来。\n\n回归分析的主要算法包括：\n\n1. 线性回归(Linear Regression)\n2. 逻辑回归（Logistic regressions）\n3. 多项式回归(Polynomial Regression)\n4. 逐步回归(Step Regression)\n5. 岭回归(Ridge Regression)\n6. 套索回归(Lasso Regression)\n7. 弹性网回归(ElasticNet)\n\n## 最大似然估计\n\nwiki定义：`在统计学中，最大似然估计（英语：maximum likelihood estimation，简作MLE），也称极大似然估计，是用来估计一个概率模型的参数的一种方法。`\n\n### 原理\n\n给定一个概率分布𝐷，已知其[概率密度函数](https://zh.wikipedia.org/wiki/概率密度函数)（连续分布）或[概率质量函数](https://zh.wikipedia.org/wiki/概率质量函数)（离散分布）为𝑓𝐷，以及一个分布参数𝜃，我们可以从这个分布中抽出一个具有𝑛个值的采样𝑋1,𝑋2,…,𝑋𝑛，利用𝑓𝐷计算出其[似然函数](https://zh.wikipedia.org/wiki/似然函数)：\n\n![{\\displaystyle {\\mbox{L}}(\\theta \\mid x_{1},\\dots ,x_{n})=f_{\\theta }(x_{1},\\dots ,x_{n}).}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a9702eeec5a8eb416883af66665ac11bd8151f0f)\n\n若𝐷是离散分布，𝑓𝜃即是在参数为𝜃时观测到这一采样的概率；若其是连续分布，𝑓𝜃则为𝑋1,𝑋2,…,𝑋𝑛联合分布的概率密度函数在观测值处的取值。一旦我们获得𝑋1,𝑋2,…,𝑋𝑛，我们就能求得一个关于𝜃的估计。最大似然估计会寻找关于𝜃的最可能的值（即，在所有可能的𝜃取值中，寻找一个值使这个采样的“可能性”最大化）。从数学上来说，我们可以在𝜃的所有可能取值中寻找一个值使得似然[函数](https://zh.wikipedia.org/wiki/函数)取到最大值。这个使可能性最大的$$\\hat 𝜃$$值即称为𝜃的**最大似然估计**。由定义，最大似然估计是样本的函数。\n\n[最大似然估计 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/最大似然估计)","source":"_posts/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc.md","raw":"---\ntitle: MindSpore专题——第六章——函数式微分\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## 函数式自动微分\n\n> 神经网络的训练主要使用反向传播算法，模型预测值（logits）与正确标签（label）送入损失函数（loss function）获得loss，然后进行反向传播计算，求得梯度（gradients），最终更新至模型参数（parameters）。自动微分能够计算可导函数在某点处的导数值，是反向传播算法的一般化。自动微分主要解决的问题是将一个复杂的数学运算分解为一系列简单的基本运算，该功能对用户屏蔽了大量的求导细节和过程，大大降低了框架的使用门槛。\n\n<!--more-->\n\n> MindSpore使用函数式自动微分的设计理念，提供更接近于数学语义的自动微分接口`grad`和`value_and_grad`。下面我们使用一个简单的单层线性变换模型进行介绍。\n\n这里总算是提到了反向传播，最近我看到了一系列视频有关Machine Learning，传送门如下：\n\n[🔴 World of Warships / USS Des Moines cut (youtube.com)](https://www.youtube.com/watch?v=Ilg3gGewQ5U)\n\n如果你试图看下去的话，可能会发现，事情好像突然变难了，似乎一群从未见过的知识组合在了一起，神经网络就像一个黑箱连着另一个黑箱，而你根本不知道如何优化它，使得黑箱在给定的输入下输出正确答案\n\n## 神经网络到底代表了什么\n\n首先让我们定义什么是神经：他是一个携带一个浮点数的结构，然后让我们看向神经网络\n\n![R](https://s2.loli.net/2024/06/07/MLN1Ap2wslU4SQB.jpg)\n\n对于每一个点，我们从最后看起，显然，他们代表0-9，更准确的说，他们代表0-9的图像。为什么这样的网络是生效的呢？\n\n***因为分形思想***，我们将一段连续的图像区分为一段一段，比如9是⚪在上而线条在下。4由多端线段1组成。而⚪和线条又可以继续再分，我们可以将神经网络中的每一个节点代表的数据想象成这种规律图案的集合。他们之间的传递就是图案在网络中不断组合。这也是为什么在网络中使用全连接的原因，因为每一个图案都能与其他任何图案组合。最终我们使图案变成了不断分形像素的组合。\n\n但如何做到这一点呢？ 考虑我们前面提到的参数，权值。\n\n![image-20240607181215798](./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240607181215798.png)\n\n这张图相信有很多人见过类似的图，实际上权值代表的就是神经网络之间的连线，假设我们让正权值在下表中为绿负权值在下表中为红，我们将这样描述一条“线段”：一段由红色包围的长条状绿色区域这样我们就能得出，如果这段线条是成立得话，比如确实原图这里存在一条线段，我们得到的这个神经节点上得值就会很接近1，否则就会很接近零。这就是权值得意义。但同时，我们会注意到神经得值是许多这样计算的累和，因此我们需要一个bias，偏差值将其计算到到0-1。\n\n注意这里得权值和偏差值均是变量，是训练出来的。并且注意，我们并不知道机器是如何分形得，这取决于学习数据和使用的算法，以上只为举例理解。\n\n如果将最初得神经网络拿去使用，你只会得到一大堆垃圾数据。我们都知道神经网络存在“进化”过程，但他是如何知道自己错得有多离谱的呢？\n\n## Cost Function（Maybe also loss function?）\n\n初略的定义是他是输出的张量与正确的张量的差值平方和，比如，机器输出了一个全是0.5的10个数的张量，而正确答案是其中之一，那么\n$$\n\\text{Cost} = (1-0.5) + 0.5*9\n$$\n显然这个数字更接近0，说明结果更加准确\n\n考虑如何让模型表现得更好，显然是需要找到一组参数，使得每次输出的cost值最小。我们可以考虑这样一种方式，以参数作为输入，cost的值作为输出，而训练数据则是参数。\n\n### 梯度下降 (Gradient Descent)\n\n似乎难以理解，假设我们只有一个参数cost=f(c)，c是唯一的参数。于是变为了函数的最值问题，只需要求导数然后慢慢移动我们的初始点。很显然，一个函数在常数域上可能存在多个极大值而只有一个最大值。当我们从一个点出发寻找最大值时，很有可能（概率学上讲应该是绝对）我们只会找到一个极大值。即在神经网络中，我们不能保证我们的参数是最优的，只能保证我们的参数是局部最优的（这取决于我们的起始点）。\n\n变到多维，我们意识到，一个数的导数是否只有正或负两种信息有效（代表是应该增加这个数还是减少这个数）。假定两个变量在一个点上的导数其中一个是另一个的三倍，这至少说明在该点的邻域内，这一变量应该减少的更多是正确的。（可能有一些函数存在极端的尖点导致错误，但这在神经网络中是低概率的，掌控好更改数据的大小即可）。\n\n一个简单的例子是，维护好一个$$\\nabla C$$矩阵，一阶导数对应的值高则其增加，反之则减少。\n\n## 反向传播\n\n从特殊到一般，我们先观察这样一个样例\n\n![image-20240607205110764](https://s2.loli.net/2024/06/07/SJ5Rf7m6cXFs8yN.png)\n\n显然我们需要增加2，并且如果给我们要做的事情做出一个排序，增加2显然排在减少8之前。\n\n因此，让我们继续看增加2所涉及的值\n\n1. 更改偏差值\n2. 更改权值（根据节点值）\n3. 更改上一层节点的值（根据权值）\n\n我们对权值和边权同时改变，并统计下一层节点需要的变化对上一层的节点影响的累和\n\n通过多组数据得出权值的总共改变值改变值。这就是随机梯度下降（Stochastic gradient descent）\n\n下面简单讲一讲其他的名词解释\n\n## Mini-batches\n\n和他的名字一样，这个技术就是将训练数据分为几组以提高收敛参数的效率\n\n## Backpropagation\n\n反向传播是一种梯度下降法的应用，通过链式法则计算损失函数相对于每个权重的梯度，然后利用这些梯度来更新权重。\n\n## 函数与计算图\n\n![compute-graph](https://s2.loli.net/2024/06/07/iqHnjI12DSKR6P7.png)\n\n> 计算图是用图论语言表示数学函数的一种方式，也是深度学习框架表达神经网络模型的统一方法。我们将根据下面的计算图构造计算函数和神经网络。\n\n> 在这个模型中，𝑥为输入，𝑦为正确值，𝑤和𝑏是我们需要优化的参数。\n\n1. 𝑥为输入\n2. 𝑦为正确值\n3. 𝑤和𝑏是我们需要优化的参数\n\n即对应了原始数据，输出结果，权重和偏差\n\n```python\nx = ops.ones(5, mindspore.float32)  # input tensor\ny = ops.zeros(3, mindspore.float32)  # expected output\nw = Parameter(Tensor(np.random.randn(5, 3), mindspore.float32), name='w') # weight\nb = Parameter(Tensor(np.random.randn(3,), mindspore.float32), name='b') # bias\n```\n\n> 我们根据计算图描述的计算过程，构造计算函数。 其中，[binary_cross_entropy_with_logits](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.binary_cross_entropy_with_logits.html) 是一个损失函数，计算预测值和目标值之间的二值交叉熵损失。\n\n解释一下Parameter(): **Parameter** 是 Tensor 的子类，当它们被绑定为Cell的属性时，会自动添加到其参数列表中，并且可以通过Cell的某些方法获取，例如 cell.get_**parameter**s() 。\n\n```python\ndef function(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss\n\nloss = function(x, y, w, b)\nprint(loss)\n```\n\n这里有复杂概念[*二值交叉熵损失*](#二值交叉熵损失)，如果你不想深究只需要这是一个对参数的函数，当这个函数值最低时，整体参数就是一个准确率较高的局部最优解即可。\n\n## 微分函数与梯度计算\n\n>  为了优化模型参数，需要求参数对loss的导数：$$\\frac{𝜕loss}{𝜕𝑤}$$和$$\\frac{𝜕loss}{𝜕𝑏}$$，此时我们调用`mindspore.grad`函数，来获得`function`的微分函数。\n\n> 这里使用了`grad`函数的两个入参，分别为：\n>\n> - `fn`：待求导的函数。\n> - `grad_position`：指定求导输入位置的索引。\n\n> 由于我们对$$𝑤$$和$$𝑏$$​求导，因此配置其在`function`入参对应的位置`(2, 3)`。\n\n> *使用`grad`获得微分函数是一种函数变换，即输入为函数，输出也为函数。*\n\n```python\ngrad_fn = mindspore.grad(function, (2, 3))\n\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n```\n\n> ```\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],\n>  [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]]), Tensor(shape=[3], dtype=Float32, value= [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]))\n> ```\n\n执行微分函数，即可获得$$𝑤$$、$$𝑏$$​对应的梯度。可以注意到w,b的梯度与最初始的梯度是一致的。\n\n### Stop Gradient\n\n> 通常情况下，求导时会求loss对参数的导数，因此函数的输出只有loss一项。**当我们希望函数输出多项时，微分函数会求所有输出项对参数的导数**。此时如果想实现对某个输出项的梯度截断，或消除某个Tensor对梯度的影响，需要用到Stop Gradient操作。\n\n> 这里我们将`function`改为同时输出loss和z的`function_with_logits`，获得微分函数并执行。\n\n```python\ndef function_with_logits(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss, z\n\ngrad_fn = mindspore.grad(function_with_logits, (2, 3))\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n```\n\n```python\ndef function_stop_gradient(x, y, w, b):\n    z = ops.matmul(x, w) + b\n    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))\n    return loss, ops.stop_gradient(z)\n\ngrad_fn = mindspore.grad(function_stop_gradient, (2, 3))\ngrads = grad_fn(x, y, w, b)\nprint(grads)\n\n```\n\n`ops.stop_gradient(z)`:重点在该函数，表示屏蔽了z对梯度的影响，即仍只求参数对loss的导数。\n\n这里解释一下一些api的含义\n\n```python\nmindspore.grad(fn, grad_position=0, weights=None, has_aux=False, return_ids=False)\n```\n\n- [MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.grad.html?highlight=grad#mindspore.grad)\n\n```\nmindspore.numpy.matmul(x1, x2, dtype=None)\n```\n\n- [MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/numpy/mindspore.numpy.matmul.html?highlight=matmul#mindspore.numpy.matmul)\n\n### Auxiliary data\n\nAuxiliary data意为辅助数据，是函数除第一个输出项外的其他输出。通常我们会将函数的loss设置为函数的第一个输出，其他的输出即为辅助数据。\n\n`grad`和`value_and_grad`提供`has_aux`参数，当其设置为`True`时，可以自动实现前文手动添加`stop_gradient`的功能，满足返回辅助数据的同时不影响梯度计算的效果。\n\n下面仍使用`function_with_logits`，配置`has_aux=True`，并执行。\n\n```python\ngrad_fn = mindspore.grad(function_with_logits, (2, 3), has_aux=True)\ngrads, (z,) = grad_fn(x, y, w, b)\nprint(grads, z)\n```\n\n### 神经网络梯度计算\n\n>  前述章节主要根据计算图对应的函数介绍了MindSpore的函数式自动微分，但我们的神经网络构造是继承自面向对象编程范式的`nn.Cell`。接下来我们通过`Cell`构造同样的神经网络，利用函数式自动微分来实现反向传播。\n\n> 首先我们继承`nn.Cell`构造单层线性变换神经网络。这里我们直接使用前文的𝑤、𝑏作为模型参数，使用`mindspore.Parameter`进行包装后，作为内部属性，并在`construct`内实现相同的Tensor操作。\n\n这里出现了反向传播方法,并且是包装好的,建议读者仔细看一下代码并尝试自己运行一下。\n\n```python\n# 定义神经网络模型\n# Define model\nclass Network(nn.Cell):\n    def __init__(self):\n        super().__init__()\n        self.w = w\n        self.b = b\n\n    def construct(self, x):\n        z = ops.matmul(x, self.w) + self.b\n        return z\n\n\n# Instantiate model\nmodel = Network()\n# Instantiate loss function\nloss_fn = nn.BCEWithLogitsLoss()\n\n\n# Define forward function\ndef forward_fn(x, y):\n    z = model(x)\n    loss = loss_fn(z, y)\n    return loss\n\n\n# 注入损失函数\ngrad_fn = mindspore.value_and_grad(forward_fn, None, weights=model.trainable_params())\nloss, grads = grad_fn(x, y)\nprint(grads)\n```\n\n### 总结输出（单次）\n\n> ```\n> 0.92031693\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> 计算多个参数的导数\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],\n>  [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]]), Tensor(shape=[3], dtype=Float32, value= [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]))\n> 消除部分张量对梯度的影响\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> Auxiliary data 辅助数据测试\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01])) [ 0.8580145   0.62723386 -0.44728255]      \n> 开始实测网络模型的反向传播\n> (Tensor(shape=[5, 3], dtype=Float32, value=\n> [[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],\n>  [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))\n> ```\n\n可见，除了在计算z的导数对梯度的影响情况下，均保持了相同的输出，并且可以观察到w,b的权值\n\n## 二值交叉熵损失\n\n***以下的对数均为自然对数***\n\nBinary cross entropy 二元[交叉熵](https://zh.wikipedia.org/wiki/交叉熵)是二分类问题中常用的一个Loss损失函数，在常见的机器学习模块中都有实现。就二元交叉熵这个损失函数的原理，简单地进行解释。下面是二元交叉熵损失函数的公式\n$$\nL=-\\frac1N \\sum_{i=1}^{N}[y_ilog(p_i)+(1-y_i)log(1-p_i)]\n$$\n先不尝试理解他，先看看他是如何运作的\n\n![img](https://s2.loli.net/2024/06/07/MAOZxqKodRSW6uy.jpg)\n$$\nL=\\frac13[(1*log0.8+(1-1)*log(1-0.8))+(0*log0.2+(1-0)*log(1-0.2))+(0*log0.4+(1-0)*log(1-0.4))]=0.319 \\\\\n$$\n对于以上的案例计算损失函数，结果是0.31903\n\n### 从熵来看交叉熵损失\n\n#### 信息量\n\n信息量来衡量一个事件的不确定性，一个事件发生的概率越大，不确定性越小，则其携带的信息量就越小。\n\n设$$X$$是一个离散型随机变量，其取值为集合$$X = {x_0,x_1,\\dots,x_n}$$，则其概率分布函数为$$p(x) = Pr(X = x),x \\in X$$，则定义事件$$X=x_0$$的信息量为：\n$$\nI(x_0) = -\\log(p(x_0))\n$$\n当$$p(x_0) = 1$$时，其携带的信息量为0。\n\n#### 熵\n\n熵用来衡量一个系统的混乱程度，代表系统中信息量的总和；熵值越大，表明这个系统的不确定性就越大。具体而数学的讲，熵就是一个系统中所有信息量的期望。\n\n信息量是衡量某个事件的不确定性，而熵是衡量一个系统（所有事件）的不确定性。\n\n熵的计算公式\n$$\nH(x) = -\\sum_{i=1}^np(x_i)\\log(p(x_i))\n$$\n比较特殊的有二项分布熵\n$$\n\\begin{eqnarray}\nH(X)&=&-\\sum_{i=1}^n p(x_i)log(p(x_i))\\\\\n&=&-p(x)log(p(x))-(1-p(x))log(1-p(x))\n\\end{eqnarray}\n$$\n*熵也有其他类型的计算公式，这里是信息学上的定义*\n\n其中$$p(x)$$为这件事发生的概率，$$-log(p(x_i))$$是事件$$x_i$$所携带的信息量。\n\n可以看出，熵是信息量的期望值，是一个随机变量（一个系统，事件所有可能性）不确定性的度量。熵值越大，随机变量的取值就越难确定，系统也就越不稳定；熵值越小，随机变量的取值也就越容易确定，系统越稳定。\n\n#### 相对熵 （Relative entropy）/  KL散度\n\nwiki对相对熵的定义如下：`In the context of machine learning, DKL(P‖Q) is often called the information gain achieved if P is used instead of Q.`\n\n即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。\n\n在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。\n\n总结：相对熵也称为KL散度(Kullback-Leibler divergence)，表示同一个随机变量的两个不同分布间的距离。\n\n设 $$p(x),𝑞(𝑥)$$分别是 离散随机变量$$X$$的两个概率分布，则$$p$$对$$q$$的相对熵是：\n$$\nD_{KL}(p \\parallel q) = \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\n$$\n相对熵具有以下性质：\n\n- 如果p(x)和q(x)的分布相同，则其相对熵等于0\n- $$D_{KL}(p∥q)≠D_{KL}(q∥p)𝐷_{𝐾𝐿}(𝑝∥𝑞)≠𝐷_{𝐾𝐿}(𝑞∥𝑝)$$，也就是相对熵不具有对称性。\n- $$D_{KL}(p∥q)≥0$$\n\n总的来说，相对熵是用来衡量同一个随机变量的两个不同分布之间的距离。**在实际应用中，假如p(x)是目标真实的分布，而q(x)是预测得来的分布，为了让这两个分布尽可能的相同的，就需要最小化KL散度。**\n\n#### 交叉熵 Cross Entropy\n\n设$$p(x),q(x)$$分别是 离散随机变量$$X$$的两个概率分布，其中$$p(x)$$是目标分布，$$p$$和$$q$$的交叉熵可以看做是，使用分布$$q(x)$$表示目标分布$$p(x)$$的困难程度\n$$\nH(p,q) = \\sum_ip(x_i)log\\frac{1}{\\log q(x_i)} = -\\sum_ip(x_i)\\log q(x_i)\n$$\n将熵、相对熵以及交叉熵的公式放到一起，\n$$\n\\begin{align}\nH(p) &= -\\sum_{i}p(x_i) \\log p(x_i) \\\\\nD_{KL}(p \\parallel q) &= \\sum_{i}p(x_i)\\log \\frac{p(x_i)}{q(x_i)} = \\sum_i (p(x_i)\\log p(x_i) - p(x_i) \\log q(x_i)) \\\\\nH(p,q) &=  -\\sum_ip(x_i)\\log q(x_i)\n\\end{align}\n$$\n通过上面三个公式就可以得到\n$$\nD_{KL}(p,q) = H(p,q)- H(p)\n$$\n其中，前一项$$H(p,q)$$就是$$p,q$$的交叉熵。在机器学习中，目标的分布$$p(x)$$通常是训练数据的分布是固定，即是$$H(p)$$是一个常量。这样两个分布的交叉熵$$H(p,q)$$也就等价于最小化这两个分布的相对熵$$D_{KL}(p \\parallel q)$$\n\n设$$p(x)$$是目标分布（训练数据的分布），我们的目标的就让训练得到的分布$$q(x)$$尽可能的接近$$p(x)$$，这时候就可以最小化$$D_{KL}(p∥q)$$，等价于最小化交叉熵$$H(p,q)$$​。\n\n### 为什么要用交叉熵做loss函数\n\n在线性回归问题中，常常使用MSE（Mean Squared Error）作为loss函数，比如：\n$$\nloss = \\frac{1}{2m}\\sum_{i=1}^m(y_i-\\hat{y_i})^2\n$$\n这里的m表示m个样本的，loss为m个样本的loss均值。\nMSE在[线性回归问题](# 回归问题)中比较好用，那么在逻辑分类问题中还是如此么？\n\n### 交叉熵在单分类问题中的使用\n\n这里的单类别是指，每一张图像样本只能有一个类别，比如只能是狗或只能是猫。\n交叉熵在单分类问题上基本是标配的方法\n$$\nloss=-\\sum_{i=1}^{n}y_ilog(\\hat{y_i})\n$$\n上式为一张样本的loss计算方法。n代表着n种类别。\n举例说明,比如有如下样本\n\n对应的标签和预测值\n\n| *     | 猫   | 青蛙 | 老鼠 |\n| ----- | ---- | ---- | ---- |\n| Label | 0    | 1    | 0    |\n| Pred  | 0.3  | 0.6  | 0.1  |\n\n\n$$\n\\begin{eqnarray}\nloss&=&-(0\\times log(0.3)+1\\times log(0.6)+0\\times log(0.1)\\\\\n&=&-log(0.6)\n\\end{eqnarray}\n$$\n对应的一个batch的loss就是\n$$\nloss=-\\frac{1}{m}\\sum_{j=1}^m\\sum_{i=1}^{n}y_{ji}log(\\hat{y_{ji}})\n$$\nm为当前batch的样本数\n\n### 交叉熵在多分类问题中的使用\n\n这里的多类别是指，每一张图像样本可以有多个类别，比如同时包含一只猫和一只狗\n和单分类问题的标签不同，多分类的标签是n-hot。\n比如下面这张样本图，即有青蛙，又有老鼠，所以是一个多分类问题\n\n栗子\n\n| *     | 猫   | 青蛙 | 老鼠 |\n| ----- | ---- | ---- | ---- |\n| Label | 0    | 1    | 1    |\n| Pred  | 0.1  | 0.7  | 0.8  |\n\n值得注意的是，这里的Pred不再是通过softmax计算的了，这里采用的是sigmoid。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。换句话说，就是每一个Label都是独立分布的，相互之间没有影响。所以交叉熵在这里是单独对每一个节点进行计算，每一个节点只有两种可能值，所以是一个二项分布。前面说过对于二项分布这种特殊的分布，熵的计算可以进行简化。\n\n同样的，交叉熵的计算也可以简化，即\n$$\nloss =-ylog(\\hat{y})-(1-y)log(1-\\hat{y})\n$$\n注意，上式只是针对一个节点的计算公式。这一点一定要和单分类loss区分开来。\n例子中可以计算为：\n$$\n\\begin{eqnarray}\nloss_猫 &=&-0\\times log(0.1)-(1-0)log(1-0.1)=-log(0.9)\\\\\nloss_蛙 &=&-1\\times log(0.7)-(1-1)log(1-0.7)=-log(0.7)\\\\\nloss_鼠 &=&-1\\times log(0.8)-(1-1)log(1-0.8)=-log(0.8)\n\\end{eqnarray}\n$$\n单张样本的loss即为\n每一个batch的loss就是：\n$$\nloss =\\sum_{j=1}^{m}\\sum_{i=1}^{n}-y_{ji}log(\\hat{y_{ji}})-(1-y_{ji})log(1-\\hat{y_{ji}})\n$$\n式中m为当前batch中的样本量，n为类别数。\n\n### 从[最大似然](# 最大似然估计)看交叉熵\n\n设有一组训练样本$X= \\{x_1,x_2,\\cdots,x_m\\}$ ,该样本的分布为$p(x)$ 。假设使用$\\theta$ 参数化模型得到$q(x;\\theta)$ ，现用这个模型来估计$X$ 的概率分布，得到似然函数\n$$\nL(\\theta) = q(X; \\theta) = \\prod_i^mq(x_i;\\theta)\n$$\n最大似然估计就是求得$\\theta$ 使得$L(\\theta)$ 的值最大，也就是\n$$\n\\theta_{ML} = arg \\max_{\\theta} \\prod_i^mq(x_i;\\theta)\n$$\n对上式的两边同时取$\\log$ ，等价优化$\\log$ 的最大似然估计即`log-likelyhood` ，最大对数似然估计\n$$\n\\theta_{ML} = arg \\max_\\theta \\sum_i^m \\log q(x_i;\\theta)\n$$\n对上式的右边进行缩放并不会改变$arg \\max$ 的解，上式的右边除以样本的个数$m$\n$$\n\\theta_{ML} = arg \\max_\\theta \\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\n$$\n\n#### 和相对熵等价\n\n上式的最大化$\\theta_{ML}$ 是和没有训练样本没有关联的，就需要某种变换使其可以用训练的样本分布来表示，因为训练样本的分布可以看作是已知的，也是对最大化似然的一个约束条件。\n\n注意上式的\n$$\n\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\n$$\n相当于**求随机变量$X$ 的函数$\\log (X;\\theta)$ 的均值** ，根据大数定理，**随着样本容量的增加，样本的算术平均值将趋近于随机变量的期望。** 也就是说\n$$\n\\frac{1}{m}\\sum_i^m \\log q(x_i;\\theta) \\rightarrow E_{x\\sim P}(\\log q(x;\\theta))\n$$\n其中$E_{X\\sim P}$ 表示符合样本分布$P$ 的期望，这样就将最大似然估计使用真实样本的期望来表示\n$$\n\\begin{aligned} \\theta_{ML} &= arg \\max_{\\theta} E_{x\\sim P}({\\log q(x;\\theta)}) \\\\ &= arg \\min_{\\theta} E_{x \\sim P}(- \\log q(x;\\theta)) \\end{aligned}\n$$\n对右边取负号，将最大化变成最小化运算。\n\n> 上述的推导过程，可以参考 《Deep Learning》 的第五章。 但是，在书中变为期望的只有一句话，将式子的右边除以样本数量$m$ 进行缩放，从而可以将其变为$E_{x \\sim p}\\log q(x;\\theta)$，没有细节过程，也可能是作者默认上面的变换对读者是一直。 确实是理解不了，查了很多文章，都是对这个变换的细节含糊其辞。一个周，对这个点一直耿耿于怀，就看了些关于概率论的科普书籍，其中共有介绍大数定理的：**当样本容量趋于无穷时，样本的均值趋于其期望**。\n>\n> 针对上面公式，除以$m$后，$\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)$ ，确实是关于随机变量函数$\\log q(x)$ 的算术平均值，而$x$ 是训练样本其分布是已知的$p(x)$ ，这样就得到了$E_{x \\sim p}(\\log q(x))$ 。\n\n$$\n\\begin{aligned} D_{KL}(p \\parallel q) &= \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\\\\ &= E_{x\\sim p}(\\log \\frac{p(x)}{q(x)}) \\\\ &= E_{x \\sim p}(\\log p(x) - \\log q(x)) \\\\ &= E_{x \\sim p}(\\log p(x)) - E_{x \\sim p} (\\log q(x)) \\end{aligned}\n$$\n\n由于$E_{x \\sim p} (\\log p(x))$ 是训练样本的期望，是个固定的常数，在求最小值时可以忽略，所以最小化$D_{KL}(p \\parallel q)$ 就变成了最小化$-E_{x\\sim p}(\\log q(x))$ ，这和最大似然估计是等价的。\n\n#### 和交叉熵等价\n\n最大似然估计、相对熵、交叉熵的公式如下\n$$\n\\begin{aligned}\\theta_{ML} &= -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log q(x) \\\\H(p,q) &= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log q(x)\\end{aligned}\\begin{aligned}\\theta_{ML} &= arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log q(x) \\\\H(p,q) &= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log q(x)\\end{aligned}\n$$\n从上面可以看出，最小化交叉熵，也就是最小化$D_{KL}$ ，从而预测的分布$q(x)$ 和训练样本的真实分布$p(x)$ 最接近。而最小化$D_{KL}$ 和最大似然估计是等价的。\n\n### 多分类交叉熵\n\n多分类任务中输出的是目标属于**每个类别的概率，所有类别概率的和为1，其中概率最大的类别就是目标所属的分类。** 而`softmax` 函数能将一个向量的每个分量映射到$[0,1]$ 区间，并且对整个向量的输出做了归一化，保证所有分量输出的和为1，正好满足多分类任务的输出要求。所以，在多分类中，在最后就需要将提取的到特征经过`softmax`函数的，输出为每个类别的概率，然后再使用**交叉熵** 作为损失函数。\n\n`softmax`函数定义如下：\n$$\nS_i = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\n$$\n其中，输入的向量为$z_i(i = 1,2,\\dots,n)$ 。\n\n更直观的参见下图\n\n![img](https://s2.loli.net/2024/06/07/XvLsuFKjBe39AaD.png)\n\n通过前面的特征提取到的特征向量为$(z_1,z_2,\\dots,z_k)$ ，将向量输入到`softmax`函数中，即可得到目标属于每个类别的概率，概率最大的就是预测得到的目标的类别。\n\n#### Cross Entropy Loss\n\n使用`softmax`函数可以将特征向量映射为所属类别的概率，可以看作是预测类别的概率分布$q(c_i)$ ，有\n$$\nq(c_i) = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\n$$\n其中$c_i$ 为某个类别。\n\n设训练数据中类别的概率分布为$p(c_i)$ ，那么目标分布$p(c_i)$ 和预测分布$q(c_i)$的交叉熵为\n\n$$H(p,q) =-\\sum_ip(c_i)\\log q(c_i) $$\n\n每个训练样本所属的类别是已知的，并且每个样本只会属于一个类别（概率为1），属于其他类别概率为0。具体的，可以假设有个三分类任务，三个类分别是：猫，猪，狗。现有一个训练样本类别为猫，则有：\n\n$$\\begin{align} p(cat) & = 1 \\\\ p(pig) &= 0 \\\\ p(dog) & = 0 \\end{align} $$\n\n通过预测得到的三个类别的概率分别为：$q(cat) = 0.6,q(pig) = 0.2,q(dog) = 0.2$ ，计算$p$ 和$q$ 的交叉熵为：\n$$\n\\begin{aligned} H(p,q) &= -(p(cat) \\log q(cat) + p(pig) + \\log q(pig) + \\log q(dog)) \\\\ &= - (1 \\cdot \\log 0.6 + 0 \\cdot \\log 0.2 +0 \\cdot \\log 0.2) \\\\ &= - \\log 0.6 \\\\ &= - \\log q(cat) \\end{aligned}\n$$\n利用这种特性，可以将样本的类别进行重新编码，就可以简化交叉熵的计算，这种编码方式就是**one-hot** 编码。以上面例子为例，\n$$\n\\begin{aligned} \\text{cat} &= (1 0 0) \\\\ \\text{pig} &= (010) \\\\ \\text{dog} &= (001) \\end{aligned}\n$$\n\n\n通过这种编码方式，在计算交叉熵时，只需要计算和训练样本对应类别预测概率的值，其他的项都是$0 \\cdot \\log q(c_i) = 0$ 。\n\n具体的，交叉熵计算公式变成如下：\n$$\n(p,q) = - \\log q(c_i)\n$$\n其中$c_i$ 为训练样本对应的类别，上式也被称为**负对数似然（negative log-likelihood,nll）**。\n\n#### PyTorch中的Cross Entropy\n\nPyTorch中实现交叉熵损失的有三个函数`torch.nn.CrossEntropyLoss`，`torch.nn.LogSoftmax`以及`torch.nn.NLLLoss`。\n\n- `torch.nn.functional.log_softmax` 比较简单，输入为$n$维向量，指定要计算的维度`dim`，输出为$log(Softmax(x))$。其计算公式如下：\n\n$$\n\\text{LogSoftmax}(x_i) = \\log (\\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)})\n$$\n\n没有额外的处理，就是对输入的$n$维向量的每个元素进行上述运算。\n\n- `torch.nn.functional.nll_loss` 负对数似然损失（Negative Log Likelihood Loss)，用于多分类，其输入的通常是`torch.nn.functional.log_softmax`的输出值。其函数如下\n\n```python\ntorch.nn.functional.nll_loss(input, target, weight=None, size_average=None, ignore_index=-100, reduce=None, reduction='mean')\n```\n\n`input` 也就是`log_softmax`的输出值，各个类别的对数概率。`target` 目标正确类别,`weight` 针对类别不平衡问题，可以为类别设置不同的权值；`ignore_index` 要忽略的类别，不参与loss的计算；比较重要的是`reduction` 的值，有三个取值：`none` 不做处理，输出的结果为向量；`mean` 将`none`结果求均值后输出；`sum` 将`none` 结果求和后输出。\n\n- `torch.nn.CrossEntropyLoss`就是上面两个函数的组合`nll_loss(log_softmax(input))`。\n\n### 二分类交叉熵\n\n多分类中使用`softmax`函数将最后的输出映射为每个类别的概率，而在二分类中则通常使用`sigmoid` 将输出映射为正样本的概率。这是因为二分类中，只有两个类别：{正样本，负样本}，只需要求得正样本的概率$q$,则$1-q$ 就是负样本的概率。这也是多分类和二分类不同的地方。\n\n$\\text{sigmoid}$ 函数的表达式如下：\n$$\n\\sigma(z) = \\frac{1}{1 + e^{-z}}\n$$\nsigmoid的输入为$z$ ，其输出为$(0,1)$ ，可以表示分类为正样本的概率。\n\n二分类的交叉熵可以看作是交叉熵损失的一个特列，交叉熵为\n$$\n\\text{$Cross\\_Entorpy$}(p,q) = -\\sum_i^m p(x_i) \\log q(x_i)\n$$\n这里只有两个类别$x \\in {x_1,x_2}$ ，则有\n$$\n\\begin{aligned}\\text{$Cross\\_Entorpy$}(p,q) &= -(p(x_1) \\log q(x_1) + p(x_2) \\log q(x_2)) \\end{aligned} \n$$\n\n\n因为只有两个选择，则有$p(x_1) + p(x_2) = 1,q(x_1) + q(x_2) = 1$ 。设，训练样本中$x_1$的概率为$p$，则$x_2$为$1-p$; 预测的$x_1$的概率为$q$，则$x_2$的预测概率为$1 - q$ 。则上式可改写为\n$$\n\\text{$Cross\\_Entropy$}(p,q) = -(p \\log q + (1-p) \\log (1-q))\n$$\n也就是二分类交叉熵的损失函数。\n\n### 总结\n\n相对熵可以用来度量两个分布相似性，假设分布$p$是训练样本的分布，$q$是预测得到的分布。分类训练的过程实际上就是最小化$D_{KL}(p \\parallel q)$，由于由于交叉熵\n$$\nH(p,q)= D_{KL}(p \\parallel q) + H(p)\n$$\n其中,$H(p)$是训练样本的熵，是一个已知的常量，这样最小化相对熵就等价于最小化交叉熵。\n\n从最大似然估计转化为最小化负对数似然\n$$\n\\theta_{ML} = -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta)\n$$\n也等价于最小化相对熵。\n\n## 回归问题\n\n回归：人们在测量事物的时候因为客观条件所限，求得的都是测量值，而不是事物真实的值，为了能够得到真实值，无限次的进行测量，最后通过这些测量数据计算**回归到真实值**，这就是回归的由来。\n\n回归分析的主要算法包括：\n\n1. 线性回归(Linear Regression)\n2. 逻辑回归（Logistic regressions）\n3. 多项式回归(Polynomial Regression)\n4. 逐步回归(Step Regression)\n5. 岭回归(Ridge Regression)\n6. 套索回归(Lasso Regression)\n7. 弹性网回归(ElasticNet)\n\n## 最大似然估计\n\nwiki定义：`在统计学中，最大似然估计（英语：maximum likelihood estimation，简作MLE），也称极大似然估计，是用来估计一个概率模型的参数的一种方法。`\n\n### 原理\n\n给定一个概率分布𝐷，已知其[概率密度函数](https://zh.wikipedia.org/wiki/概率密度函数)（连续分布）或[概率质量函数](https://zh.wikipedia.org/wiki/概率质量函数)（离散分布）为𝑓𝐷，以及一个分布参数𝜃，我们可以从这个分布中抽出一个具有𝑛个值的采样𝑋1,𝑋2,…,𝑋𝑛，利用𝑓𝐷计算出其[似然函数](https://zh.wikipedia.org/wiki/似然函数)：\n\n![{\\displaystyle {\\mbox{L}}(\\theta \\mid x_{1},\\dots ,x_{n})=f_{\\theta }(x_{1},\\dots ,x_{n}).}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a9702eeec5a8eb416883af66665ac11bd8151f0f)\n\n若𝐷是离散分布，𝑓𝜃即是在参数为𝜃时观测到这一采样的概率；若其是连续分布，𝑓𝜃则为𝑋1,𝑋2,…,𝑋𝑛联合分布的概率密度函数在观测值处的取值。一旦我们获得𝑋1,𝑋2,…,𝑋𝑛，我们就能求得一个关于𝜃的估计。最大似然估计会寻找关于𝜃的最可能的值（即，在所有可能的𝜃取值中，寻找一个值使这个采样的“可能性”最大化）。从数学上来说，我们可以在𝜃的所有可能取值中寻找一个值使得似然[函数](https://zh.wikipedia.org/wiki/函数)取到最大值。这个使可能性最大的$$\\hat 𝜃$$值即称为𝜃的**最大似然估计**。由定义，最大似然估计是样本的函数。\n\n[最大似然估计 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/最大似然估计)","slug":"special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc","published":1,"updated":"2024-08-16T08:59:11.713Z","_id":"clzwh7bb800al2wwvejv8ayh5","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"函数式自动微分\">函数式自动微分</h2>\r\n<blockquote>\r\n<p>神经网络的训练主要使用反向传播算法，模型预测值（logits）与正确标签（label）送入损失函数（loss\r\nfunction）获得loss，然后进行反向传播计算，求得梯度（gradients），最终更新至模型参数（parameters）。自动微分能够计算可导函数在某点处的导数值，是反向传播算法的一般化。自动微分主要解决的问题是将一个复杂的数学运算分解为一系列简单的基本运算，该功能对用户屏蔽了大量的求导细节和过程，大大降低了框架的使用门槛。</p>\r\n</blockquote>\r\n<span id=\"more\"></span>\r\n<blockquote>\r\n<p>MindSpore使用函数式自动微分的设计理念，提供更接近于数学语义的自动微分接口<code>grad</code>和<code>value_and_grad</code>。下面我们使用一个简单的单层线性变换模型进行介绍。</p>\r\n</blockquote>\r\n<p>这里总算是提到了反向传播，最近我看到了一系列视频有关Machine\r\nLearning，传送门如下：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1JbGczZ0dld1E1VQ==\">🔴 World of\r\nWarships / USS Des Moines cut (youtube.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>如果你试图看下去的话，可能会发现，事情好像突然变难了，似乎一群从未见过的知识组合在了一起，神经网络就像一个黑箱连着另一个黑箱，而你根本不知道如何优化它，使得黑箱在给定的输入下输出正确答案</p>\r\n<h2 id=\"神经网络到底代表了什么\">神经网络到底代表了什么</h2>\r\n<p>首先让我们定义什么是神经：他是一个携带一个浮点数的结构，然后让我们看向神经网络</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/MLN1Ap2wslU4SQB.jpg\" alt=\"R\" />\r\n<figcaption aria-hidden=\"true\">R</figcaption>\r\n</figure>\r\n<p>对于每一个点，我们从最后看起，显然，他们代表0-9，更准确的说，他们代表0-9的图像。为什么这样的网络是生效的呢？</p>\r\n<p><strong><em>因为分形思想</em></strong>，我们将一段连续的图像区分为一段一段，比如9是⚪在上而线条在下。4由多端线段1组成。而⚪和线条又可以继续再分，我们可以将神经网络中的每一个节点代表的数据想象成这种规律图案的集合。他们之间的传递就是图案在网络中不断组合。这也是为什么在网络中使用全连接的原因，因为每一个图案都能与其他任何图案组合。最终我们使图案变成了不断分形像素的组合。</p>\r\n<p>但如何做到这一点呢？ 考虑我们前面提到的参数，权值。</p>\r\n<figure>\r\n<img\r\nsrc=\"./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240607181215798.png\"\r\nalt=\"image-20240607181215798\" />\r\n<figcaption aria-hidden=\"true\">image-20240607181215798</figcaption>\r\n</figure>\r\n<p>这张图相信有很多人见过类似的图，实际上权值代表的就是神经网络之间的连线，假设我们让正权值在下表中为绿负权值在下表中为红，我们将这样描述一条“线段”：一段由红色包围的长条状绿色区域这样我们就能得出，如果这段线条是成立得话，比如确实原图这里存在一条线段，我们得到的这个神经节点上得值就会很接近1，否则就会很接近零。这就是权值得意义。但同时，我们会注意到神经得值是许多这样计算的累和，因此我们需要一个bias，偏差值将其计算到到0-1。</p>\r\n<p>注意这里得权值和偏差值均是变量，是训练出来的。并且注意，我们并不知道机器是如何分形得，这取决于学习数据和使用的算法，以上只为举例理解。</p>\r\n<p>如果将最初得神经网络拿去使用，你只会得到一大堆垃圾数据。我们都知道神经网络存在“进化”过程，但他是如何知道自己错得有多离谱的呢？</p>\r\n<h2 id=\"cost-functionmaybe-also-loss-function\">Cost Function（Maybe also\r\nloss function?）</h2>\r\n<p>初略的定义是他是输出的张量与正确的张量的差值平方和，比如，机器输出了一个全是0.5的10个数的张量，而正确答案是其中之一，那么\r\n<span class=\"math display\">\\[\r\n\\text{Cost} = (1-0.5) + 0.5*9\r\n\\]</span> 显然这个数字更接近0，说明结果更加准确</p>\r\n<p>考虑如何让模型表现得更好，显然是需要找到一组参数，使得每次输出的cost值最小。我们可以考虑这样一种方式，以参数作为输入，cost的值作为输出，而训练数据则是参数。</p>\r\n<h3 id=\"梯度下降-gradient-descent\">梯度下降 (Gradient Descent)</h3>\r\n<p>似乎难以理解，假设我们只有一个参数cost=f(c)，c是唯一的参数。于是变为了函数的最值问题，只需要求导数然后慢慢移动我们的初始点。很显然，一个函数在常数域上可能存在多个极大值而只有一个最大值。当我们从一个点出发寻找最大值时，很有可能（概率学上讲应该是绝对）我们只会找到一个极大值。即在神经网络中，我们不能保证我们的参数是最优的，只能保证我们的参数是局部最优的（这取决于我们的起始点）。</p>\r\n<p>变到多维，我们意识到，一个数的导数是否只有正或负两种信息有效（代表是应该增加这个数还是减少这个数）。假定两个变量在一个点上的导数其中一个是另一个的三倍，这至少说明在该点的邻域内，这一变量应该减少的更多是正确的。（可能有一些函数存在极端的尖点导致错误，但这在神经网络中是低概率的，掌控好更改数据的大小即可）。</p>\r\n<p>一个简单的例子是，维护好一个<span class=\"math display\">\\[\\nabla\r\nC\\]</span>矩阵，一阶导数对应的值高则其增加，反之则减少。</p>\r\n<h2 id=\"反向传播\">反向传播</h2>\r\n<p>从特殊到一般，我们先观察这样一个样例</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/SJ5Rf7m6cXFs8yN.png\"\r\nalt=\"image-20240607205110764\" />\r\n<figcaption aria-hidden=\"true\">image-20240607205110764</figcaption>\r\n</figure>\r\n<p>显然我们需要增加2，并且如果给我们要做的事情做出一个排序，增加2显然排在减少8之前。</p>\r\n<p>因此，让我们继续看增加2所涉及的值</p>\r\n<ol type=\"1\">\r\n<li>更改偏差值</li>\r\n<li>更改权值（根据节点值）</li>\r\n<li>更改上一层节点的值（根据权值）</li>\r\n</ol>\r\n<p>我们对权值和边权同时改变，并统计下一层节点需要的变化对上一层的节点影响的累和</p>\r\n<p>通过多组数据得出权值的总共改变值改变值。这就是随机梯度下降（Stochastic\r\ngradient descent）</p>\r\n<p>下面简单讲一讲其他的名词解释</p>\r\n<h2 id=\"mini-batches\">Mini-batches</h2>\r\n<p>和他的名字一样，这个技术就是将训练数据分为几组以提高收敛参数的效率</p>\r\n<h2 id=\"backpropagation\">Backpropagation</h2>\r\n<p>反向传播是一种梯度下降法的应用，通过链式法则计算损失函数相对于每个权重的梯度，然后利用这些梯度来更新权重。</p>\r\n<h2 id=\"函数与计算图\">函数与计算图</h2>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/iqHnjI12DSKR6P7.png\"\r\nalt=\"compute-graph\" />\r\n<figcaption aria-hidden=\"true\">compute-graph</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>计算图是用图论语言表示数学函数的一种方式，也是深度学习框架表达神经网络模型的统一方法。我们将根据下面的计算图构造计算函数和神经网络。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>在这个模型中，𝑥为输入，𝑦为正确值，𝑤和𝑏是我们需要优化的参数。</p>\r\n</blockquote>\r\n<ol type=\"1\">\r\n<li>𝑥为输入</li>\r\n<li>𝑦为正确值</li>\r\n<li>𝑤和𝑏是我们需要优化的参数</li>\r\n</ol>\r\n<p>即对应了原始数据，输出结果，权重和偏差</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = ops.ones(<span class=\"number\">5</span>, mindspore.float32)  <span class=\"comment\"># input tensor</span></span><br><span class=\"line\">y = ops.zeros(<span class=\"number\">3</span>, mindspore.float32)  <span class=\"comment\"># expected output</span></span><br><span class=\"line\">w = Parameter(Tensor(np.random.randn(<span class=\"number\">5</span>, <span class=\"number\">3</span>), mindspore.float32), name=<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"comment\"># weight</span></span><br><span class=\"line\">b = Parameter(Tensor(np.random.randn(<span class=\"number\">3</span>,), mindspore.float32), name=<span class=\"string\">&#x27;b&#x27;</span>) <span class=\"comment\"># bias</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>我们根据计算图描述的计算过程，构造计算函数。 其中，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLmJpbmFyeV9jcm9zc19lbnRyb3B5X3dpdGhfbG9naXRzLmh0bWw=\">binary_cross_entropy_with_logits<i class=\"fa fa-external-link-alt\"></i></span>\r\n是一个损失函数，计算预测值和目标值之间的二值交叉熵损失。</p>\r\n</blockquote>\r\n<p>解释一下Parameter(): <strong>Parameter</strong> 是 Tensor\r\n的子类，当它们被绑定为Cell的属性时，会自动添加到其参数列表中，并且可以通过Cell的某些方法获取，例如\r\ncell.get_<strong>parameter</strong>s() 。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\">loss = function(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(loss)</span><br></pre></td></tr></table></figure>\r\n<p>这里有复杂概念<a\r\nhref=\"#二值交叉熵损失\"><em>二值交叉熵损失</em></a>，如果你不想深究只需要这是一个对参数的函数，当这个函数值最低时，整体参数就是一个准确率较高的局部最优解即可。</p>\r\n<h2 id=\"微分函数与梯度计算\">微分函数与梯度计算</h2>\r\n<blockquote>\r\n<p>为了优化模型参数，需要求参数对loss的导数：<span\r\nclass=\"math display\">\\[\\frac{𝜕loss}{𝜕𝑤}\\]</span>和<span\r\nclass=\"math display\">\\[\\frac{𝜕loss}{𝜕𝑏}\\]</span>，此时我们调用<code>mindspore.grad</code>函数，来获得<code>function</code>的微分函数。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>这里使用了<code>grad</code>函数的两个入参，分别为：</p>\r\n<ul>\r\n<li><code>fn</code>：待求导的函数。</li>\r\n<li><code>grad_position</code>：指定求导输入位置的索引。</li>\r\n</ul>\r\n</blockquote>\r\n<blockquote>\r\n<p>由于我们对<span class=\"math display\">\\[𝑤\\]</span>和<span\r\nclass=\"math display\">\\[𝑏\\]</span>​求导，因此配置其在<code>function</code>入参对应的位置<code>(2, 3)</code>。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p><em>使用<code>grad</code>获得微分函数是一种函数变换，即输入为函数，输出也为函数。</em></p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grad_fn = mindspore.grad(function, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]]), Tensor(shape=[3], dtype=Float32, value= [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]))</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>执行微分函数，即可获得<span class=\"math display\">\\[𝑤\\]</span>、<span\r\nclass=\"math display\">\\[𝑏\\]</span>​对应的梯度。可以注意到w,b的梯度与最初始的梯度是一致的。</p>\r\n<h3 id=\"stop-gradient\">Stop Gradient</h3>\r\n<blockquote>\r\n<p>通常情况下，求导时会求loss对参数的导数，因此函数的输出只有loss一项。<strong>当我们希望函数输出多项时，微分函数会求所有输出项对参数的导数</strong>。此时如果想实现对某个输出项的梯度截断，或消除某个Tensor对梯度的影响，需要用到Stop\r\nGradient操作。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>这里我们将<code>function</code>改为同时输出loss和z的<code>function_with_logits</code>，获得微分函数并执行。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function_with_logits</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, z</span><br><span class=\"line\"></span><br><span class=\"line\">grad_fn = mindspore.grad(function_with_logits, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function_stop_gradient</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, ops.stop_gradient(z)</span><br><span class=\"line\"></span><br><span class=\"line\">grad_fn = mindspore.grad(function_stop_gradient, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p><code>ops.stop_gradient(z)</code>:重点在该函数，表示屏蔽了z对梯度的影响，即仍只求参数对loss的导数。</p>\r\n<p>这里解释一下一些api的含义</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mindspore.grad(fn, grad_position=<span class=\"number\">0</span>, weights=<span class=\"literal\">None</span>, has_aux=<span class=\"literal\">False</span>, return_ids=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZ3JhZC5odG1sP2hpZ2hsaWdodD1ncmFkI21pbmRzcG9yZS5ncmFk\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mindspore.numpy.matmul(x1, x2, dtype=None)</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL251bXB5L21pbmRzcG9yZS5udW1weS5tYXRtdWwuaHRtbD9oaWdobGlnaHQ9bWF0bXVsI21pbmRzcG9yZS5udW1weS5tYXRtdWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n</ul>\r\n<h3 id=\"auxiliary-data\">Auxiliary data</h3>\r\n<p>Auxiliary\r\ndata意为辅助数据，是函数除第一个输出项外的其他输出。通常我们会将函数的loss设置为函数的第一个输出，其他的输出即为辅助数据。</p>\r\n<p><code>grad</code>和<code>value_and_grad</code>提供<code>has_aux</code>参数，当其设置为<code>True</code>时，可以自动实现前文手动添加<code>stop_gradient</code>的功能，满足返回辅助数据的同时不影响梯度计算的效果。</p>\r\n<p>下面仍使用<code>function_with_logits</code>，配置<code>has_aux=True</code>，并执行。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grad_fn = mindspore.grad(function_with_logits, (<span class=\"number\">2</span>, <span class=\"number\">3</span>), has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\">grads, (z,) = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads, z)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"神经网络梯度计算\">神经网络梯度计算</h3>\r\n<blockquote>\r\n<p>前述章节主要根据计算图对应的函数介绍了MindSpore的函数式自动微分，但我们的神经网络构造是继承自面向对象编程范式的<code>nn.Cell</code>。接下来我们通过<code>Cell</code>构造同样的神经网络，利用函数式自动微分来实现反向传播。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>首先我们继承<code>nn.Cell</code>构造单层线性变换神经网络。这里我们直接使用前文的𝑤、𝑏作为模型参数，使用<code>mindspore.Parameter</code>进行包装后，作为内部属性，并在<code>construct</code>内实现相同的Tensor操作。</p>\r\n</blockquote>\r\n<p>这里出现了反向传播方法,并且是包装好的,建议读者仔细看一下代码并尝试自己运行一下。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义神经网络模型</span></span><br><span class=\"line\"><span class=\"comment\"># Define model</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.w = w</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.b = b</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        z = ops.matmul(x, <span class=\"variable language_\">self</span>.w) + <span class=\"variable language_\">self</span>.b</span><br><span class=\"line\">        <span class=\"keyword\">return</span> z</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Instantiate model</span></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"comment\"># Instantiate loss function</span></span><br><span class=\"line\">loss_fn = nn.BCEWithLogitsLoss()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">x, y</span>):</span><br><span class=\"line\">    z = model(x)</span><br><span class=\"line\">    loss = loss_fn(z, y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注入损失函数</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, weights=model.trainable_params())</span><br><span class=\"line\">loss, grads = grad_fn(x, y)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"总结输出单次\">总结输出（单次）</h3>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0.92031693</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br><span class=\"line\">计算多个参数的导数</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]]), Tensor(shape=[3], dtype=Float32, value= [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]))</span><br><span class=\"line\">消除部分张量对梯度的影响</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br><span class=\"line\">Auxiliary data 辅助数据测试</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01])) [ 0.8580145   0.62723386 -0.44728255]      </span><br><span class=\"line\">开始实测网络模型的反向传播</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>可见，除了在计算z的导数对梯度的影响情况下，均保持了相同的输出，并且可以观察到w,b的权值</p>\r\n<h2 id=\"二值交叉熵损失\">二值交叉熵损失</h2>\r\n<p><strong><em>以下的对数均为自然对数</em></strong></p>\r\n<p>Binary cross entropy 二元<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Lqk5Y+J54a1\">交叉熵<i class=\"fa fa-external-link-alt\"></i></span>是二分类问题中常用的一个Loss损失函数，在常见的机器学习模块中都有实现。就二元交叉熵这个损失函数的原理，简单地进行解释。下面是二元交叉熵损失函数的公式\r\n<span class=\"math display\">\\[\r\nL=-\\frac1N \\sum_{i=1}^{N}[y_ilog(p_i)+(1-y_i)log(1-p_i)]\r\n\\]</span> 先不尝试理解他，先看看他是如何运作的</p>\r\n<p><img src=\"https://s2.loli.net/2024/06/07/MAOZxqKodRSW6uy.jpg\"\r\nalt=\"img\" /> <span class=\"math display\">\\[\r\nL=\\frac13[(1*log0.8+(1-1)*log(1-0.8))+(0*log0.2+(1-0)*log(1-0.2))+(0*log0.4+(1-0)*log(1-0.4))]=0.319\r\n\\\\\r\n\\]</span> 对于以上的案例计算损失函数，结果是0.31903</p>\r\n<h3 id=\"从熵来看交叉熵损失\">从熵来看交叉熵损失</h3>\r\n<h4 id=\"信息量\">信息量</h4>\r\n<p>信息量来衡量一个事件的不确定性，一个事件发生的概率越大，不确定性越小，则其携带的信息量就越小。</p>\r\n<p>设<span\r\nclass=\"math display\">\\[X\\]</span>是一个离散型随机变量，其取值为集合<span\r\nclass=\"math display\">\\[X =\r\n{x_0,x_1,\\dots,x_n}\\]</span>，则其概率分布函数为<span\r\nclass=\"math display\">\\[p(x) = Pr(X = x),x \\in\r\nX\\]</span>，则定义事件<span\r\nclass=\"math display\">\\[X=x_0\\]</span>的信息量为： <span\r\nclass=\"math display\">\\[\r\nI(x_0) = -\\log(p(x_0))\r\n\\]</span> 当<span class=\"math display\">\\[p(x_0) =\r\n1\\]</span>时，其携带的信息量为0。</p>\r\n<h4 id=\"熵\">熵</h4>\r\n<p>熵用来衡量一个系统的混乱程度，代表系统中信息量的总和；熵值越大，表明这个系统的不确定性就越大。具体而数学的讲，熵就是一个系统中所有信息量的期望。</p>\r\n<p>信息量是衡量某个事件的不确定性，而熵是衡量一个系统（所有事件）的不确定性。</p>\r\n<p>熵的计算公式 <span class=\"math display\">\\[\r\nH(x) = -\\sum_{i=1}^np(x_i)\\log(p(x_i))\r\n\\]</span> 比较特殊的有二项分布熵 <span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nH(X)&amp;=&amp;-\\sum_{i=1}^n p(x_i)log(p(x_i))\\\\\r\n&amp;=&amp;-p(x)log(p(x))-(1-p(x))log(1-p(x))\r\n\\end{eqnarray}\r\n\\]</span> <em>熵也有其他类型的计算公式，这里是信息学上的定义</em></p>\r\n<p>其中<span\r\nclass=\"math display\">\\[p(x)\\]</span>为这件事发生的概率，<span\r\nclass=\"math display\">\\[-log(p(x_i))\\]</span>是事件<span\r\nclass=\"math display\">\\[x_i\\]</span>所携带的信息量。</p>\r\n<p>可以看出，熵是信息量的期望值，是一个随机变量（一个系统，事件所有可能性）不确定性的度量。熵值越大，随机变量的取值就越难确定，系统也就越不稳定；熵值越小，随机变量的取值也就越容易确定，系统越稳定。</p>\r\n<h4 id=\"相对熵-relative-entropy-kl散度\">相对熵 （Relative entropy）/\r\nKL散度</h4>\r\n<p>wiki对相对熵的定义如下：<code>In the context of machine learning, DKL(P‖Q) is often called the information gain achieved if P is used instead of Q.</code></p>\r\n<p>即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。</p>\r\n<p>在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。</p>\r\n<p>总结：相对熵也称为KL散度(Kullback-Leibler\r\ndivergence)，表示同一个随机变量的两个不同分布间的距离。</p>\r\n<p>设 <span class=\"math display\">\\[p(x),𝑞(𝑥)\\]</span>分别是\r\n离散随机变量<span\r\nclass=\"math display\">\\[X\\]</span>的两个概率分布，则<span\r\nclass=\"math display\">\\[p\\]</span>对<span\r\nclass=\"math display\">\\[q\\]</span>的相对熵是： <span\r\nclass=\"math display\">\\[\r\nD_{KL}(p \\parallel q) = \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\r\n\\]</span> 相对熵具有以下性质：</p>\r\n<ul>\r\n<li>如果p(x)和q(x)的分布相同，则其相对熵等于0</li>\r\n<li><span\r\nclass=\"math display\">\\[D_{KL}(p∥q)≠D_{KL}(q∥p)𝐷_{𝐾𝐿}(𝑝∥𝑞)≠𝐷_{𝐾𝐿}(𝑞∥𝑝)\\]</span>，也就是相对熵不具有对称性。</li>\r\n<li><span class=\"math display\">\\[D_{KL}(p∥q)≥0\\]</span></li>\r\n</ul>\r\n<p>总的来说，相对熵是用来衡量同一个随机变量的两个不同分布之间的距离。<strong>在实际应用中，假如p(x)是目标真实的分布，而q(x)是预测得来的分布，为了让这两个分布尽可能的相同的，就需要最小化KL散度。</strong></p>\r\n<h4 id=\"交叉熵-cross-entropy\">交叉熵 Cross Entropy</h4>\r\n<p>设<span class=\"math display\">\\[p(x),q(x)\\]</span>分别是\r\n离散随机变量<span\r\nclass=\"math display\">\\[X\\]</span>的两个概率分布，其中<span\r\nclass=\"math display\">\\[p(x)\\]</span>是目标分布，<span\r\nclass=\"math display\">\\[p\\]</span>和<span\r\nclass=\"math display\">\\[q\\]</span>的交叉熵可以看做是，使用分布<span\r\nclass=\"math display\">\\[q(x)\\]</span>表示目标分布<span\r\nclass=\"math display\">\\[p(x)\\]</span>的困难程度 <span\r\nclass=\"math display\">\\[\r\nH(p,q) = \\sum_ip(x_i)log\\frac{1}{\\log q(x_i)} = -\\sum_ip(x_i)\\log q(x_i)\r\n\\]</span> 将熵、相对熵以及交叉熵的公式放到一起， <span\r\nclass=\"math display\">\\[\r\n\\begin{align}\r\nH(p) &amp;= -\\sum_{i}p(x_i) \\log p(x_i) \\\\\r\nD_{KL}(p \\parallel q) &amp;= \\sum_{i}p(x_i)\\log \\frac{p(x_i)}{q(x_i)} =\r\n\\sum_i (p(x_i)\\log p(x_i) - p(x_i) \\log q(x_i)) \\\\\r\nH(p,q) &amp;=  -\\sum_ip(x_i)\\log q(x_i)\r\n\\end{align}\r\n\\]</span> 通过上面三个公式就可以得到 <span class=\"math display\">\\[\r\nD_{KL}(p,q) = H(p,q)- H(p)\r\n\\]</span> 其中，前一项<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>就是<span\r\nclass=\"math display\">\\[p,q\\]</span>的交叉熵。在机器学习中，目标的分布<span\r\nclass=\"math display\">\\[p(x)\\]</span>通常是训练数据的分布是固定，即是<span\r\nclass=\"math display\">\\[H(p)\\]</span>是一个常量。这样两个分布的交叉熵<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>也就等价于最小化这两个分布的相对熵<span\r\nclass=\"math display\">\\[D_{KL}(p \\parallel q)\\]</span></p>\r\n<p>设<span\r\nclass=\"math display\">\\[p(x)\\]</span>是目标分布（训练数据的分布），我们的目标的就让训练得到的分布<span\r\nclass=\"math display\">\\[q(x)\\]</span>尽可能的接近<span\r\nclass=\"math display\">\\[p(x)\\]</span>，这时候就可以最小化<span\r\nclass=\"math display\">\\[D_{KL}(p∥q)\\]</span>，等价于最小化交叉熵<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>​。</p>\r\n<h3 id=\"为什么要用交叉熵做loss函数\">为什么要用交叉熵做loss函数</h3>\r\n<p>在线性回归问题中，常常使用MSE（Mean Squared\r\nError）作为loss函数，比如： <span class=\"math display\">\\[\r\nloss = \\frac{1}{2m}\\sum_{i=1}^m(y_i-\\hat{y_i})^2\r\n\\]</span> 这里的m表示m个样本的，loss为m个样本的loss均值。 MSE在<a\r\nhref=\"#%20回归问题\">线性回归问题</a>中比较好用，那么在逻辑分类问题中还是如此么？</p>\r\n<h3 id=\"交叉熵在单分类问题中的使用\">交叉熵在单分类问题中的使用</h3>\r\n<p>这里的单类别是指，每一张图像样本只能有一个类别，比如只能是狗或只能是猫。\r\n交叉熵在单分类问题上基本是标配的方法 <span class=\"math display\">\\[\r\nloss=-\\sum_{i=1}^{n}y_ilog(\\hat{y_i})\r\n\\]</span> 上式为一张样本的loss计算方法。n代表着n种类别。\r\n举例说明,比如有如下样本</p>\r\n<p>对应的标签和预测值</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>*</th>\r\n<th>猫</th>\r\n<th>青蛙</th>\r\n<th>老鼠</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Label</td>\r\n<td>0</td>\r\n<td>1</td>\r\n<td>0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Pred</td>\r\n<td>0.3</td>\r\n<td>0.6</td>\r\n<td>0.1</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nloss&amp;=&amp;-(0\\times log(0.3)+1\\times log(0.6)+0\\times log(0.1)\\\\\r\n&amp;=&amp;-log(0.6)\r\n\\end{eqnarray}\r\n\\]</span> 对应的一个batch的loss就是 <span class=\"math display\">\\[\r\nloss=-\\frac{1}{m}\\sum_{j=1}^m\\sum_{i=1}^{n}y_{ji}log(\\hat{y_{ji}})\r\n\\]</span> m为当前batch的样本数</p>\r\n<h3 id=\"交叉熵在多分类问题中的使用\">交叉熵在多分类问题中的使用</h3>\r\n<p>这里的多类别是指，每一张图像样本可以有多个类别，比如同时包含一只猫和一只狗\r\n和单分类问题的标签不同，多分类的标签是n-hot。\r\n比如下面这张样本图，即有青蛙，又有老鼠，所以是一个多分类问题</p>\r\n<p>栗子</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>*</th>\r\n<th>猫</th>\r\n<th>青蛙</th>\r\n<th>老鼠</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Label</td>\r\n<td>0</td>\r\n<td>1</td>\r\n<td>1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Pred</td>\r\n<td>0.1</td>\r\n<td>0.7</td>\r\n<td>0.8</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>值得注意的是，这里的Pred不再是通过softmax计算的了，这里采用的是sigmoid。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。换句话说，就是每一个Label都是独立分布的，相互之间没有影响。所以交叉熵在这里是单独对每一个节点进行计算，每一个节点只有两种可能值，所以是一个二项分布。前面说过对于二项分布这种特殊的分布，熵的计算可以进行简化。</p>\r\n<p>同样的，交叉熵的计算也可以简化，即 <span class=\"math display\">\\[\r\nloss =-ylog(\\hat{y})-(1-y)log(1-\\hat{y})\r\n\\]</span>\r\n注意，上式只是针对一个节点的计算公式。这一点一定要和单分类loss区分开来。\r\n例子中可以计算为： <span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nloss_猫 &amp;=&amp;-0\\times log(0.1)-(1-0)log(1-0.1)=-log(0.9)\\\\\r\nloss_蛙 &amp;=&amp;-1\\times log(0.7)-(1-1)log(1-0.7)=-log(0.7)\\\\\r\nloss_鼠 &amp;=&amp;-1\\times log(0.8)-(1-1)log(1-0.8)=-log(0.8)\r\n\\end{eqnarray}\r\n\\]</span> 单张样本的loss即为 每一个batch的loss就是： <span\r\nclass=\"math display\">\\[\r\nloss\r\n=\\sum_{j=1}^{m}\\sum_{i=1}^{n}-y_{ji}log(\\hat{y_{ji}})-(1-y_{ji})log(1-\\hat{y_{ji}})\r\n\\]</span> 式中m为当前batch中的样本量，n为类别数。</p>\r\n<h3 id=\"从最大似然看交叉熵\">从<a\r\nhref=\"#%20最大似然估计\">最大似然</a>看交叉熵</h3>\r\n<p>设有一组训练样本<span class=\"math inline\">\\(X=\r\n\\{x_1,x_2,\\cdots,x_m\\}\\)</span> ,该样本的分布为<span\r\nclass=\"math inline\">\\(p(x)\\)</span> 。假设使用<span\r\nclass=\"math inline\">\\(\\theta\\)</span> 参数化模型得到<span\r\nclass=\"math inline\">\\(q(x;\\theta)\\)</span> ，现用这个模型来估计<span\r\nclass=\"math inline\">\\(X\\)</span> 的概率分布，得到似然函数 <span\r\nclass=\"math display\">\\[\r\nL(\\theta) = q(X; \\theta) = \\prod_i^mq(x_i;\\theta)\r\n\\]</span> 最大似然估计就是求得<span\r\nclass=\"math inline\">\\(\\theta\\)</span> 使得<span\r\nclass=\"math inline\">\\(L(\\theta)\\)</span> 的值最大，也就是 <span\r\nclass=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_{\\theta} \\prod_i^mq(x_i;\\theta)\r\n\\]</span> 对上式的两边同时取<span class=\"math inline\">\\(\\log\\)</span>\r\n，等价优化<span class=\"math inline\">\\(\\log\\)</span>\r\n的最大似然估计即<code>log-likelyhood</code> ，最大对数似然估计 <span\r\nclass=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_\\theta \\sum_i^m \\log q(x_i;\\theta)\r\n\\]</span> 对上式的右边进行缩放并不会改变<span class=\"math inline\">\\(arg\r\n\\max\\)</span> 的解，上式的右边除以样本的个数<span\r\nclass=\"math inline\">\\(m\\)</span> <span class=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_\\theta \\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\r\n\\]</span></p>\r\n<h4 id=\"和相对熵等价\">和相对熵等价</h4>\r\n<p>上式的最大化<span class=\"math inline\">\\(\\theta_{ML}\\)</span>\r\n是和没有训练样本没有关联的，就需要某种变换使其可以用训练的样本分布来表示，因为训练样本的分布可以看作是已知的，也是对最大化似然的一个约束条件。</p>\r\n<p>注意上式的 <span class=\"math display\">\\[\r\n\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\r\n\\]</span> 相当于<strong>求随机变量<span class=\"math inline\">\\(X\\)</span>\r\n的函数<span class=\"math inline\">\\(\\log (X;\\theta)\\)</span>\r\n的均值</strong>\r\n，根据大数定理，<strong>随着样本容量的增加，样本的算术平均值将趋近于随机变量的期望。</strong>\r\n也就是说 <span class=\"math display\">\\[\r\n\\frac{1}{m}\\sum_i^m \\log q(x_i;\\theta) \\rightarrow E_{x\\sim P}(\\log\r\nq(x;\\theta))\r\n\\]</span> 其中<span class=\"math inline\">\\(E_{X\\sim P}\\)</span>\r\n表示符合样本分布<span class=\"math inline\">\\(P\\)</span>\r\n的期望，这样就将最大似然估计使用真实样本的期望来表示 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned} \\theta_{ML} &amp;= arg \\max_{\\theta} E_{x\\sim P}({\\log\r\nq(x;\\theta)}) \\\\ &amp;= arg \\min_{\\theta} E_{x \\sim P}(- \\log\r\nq(x;\\theta)) \\end{aligned}\r\n\\]</span> 对右边取负号，将最大化变成最小化运算。</p>\r\n<blockquote>\r\n<p>上述的推导过程，可以参考 《Deep Learning》 的第五章。\r\n但是，在书中变为期望的只有一句话，将式子的右边除以样本数量<span\r\nclass=\"math inline\">\\(m\\)</span> 进行缩放，从而可以将其变为<span\r\nclass=\"math inline\">\\(E_{x \\sim p}\\log\r\nq(x;\\theta)\\)</span>，没有细节过程，也可能是作者默认上面的变换对读者是一直。\r\n确实是理解不了，查了很多文章，都是对这个变换的细节含糊其辞。一个周，对这个点一直耿耿于怀，就看了些关于概率论的科普书籍，其中共有介绍大数定理的：<strong>当样本容量趋于无穷时，样本的均值趋于其期望</strong>。</p>\r\n<p>针对上面公式，除以<span class=\"math inline\">\\(m\\)</span>后，<span\r\nclass=\"math inline\">\\(\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\\)</span>\r\n，确实是关于随机变量函数<span class=\"math inline\">\\(\\log q(x)\\)</span>\r\n的算术平均值，而<span class=\"math inline\">\\(x\\)</span>\r\n是训练样本其分布是已知的<span class=\"math inline\">\\(p(x)\\)</span>\r\n，这样就得到了<span class=\"math inline\">\\(E_{x \\sim p}(\\log\r\nq(x))\\)</span> 。</p>\r\n</blockquote>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned} D_{KL}(p \\parallel q) &amp;= \\sum_i p(x_i)\r\nlog(\\frac{p(x_i)}{q(x_i)})\\\\ &amp;= E_{x\\sim p}(\\log \\frac{p(x)}{q(x)})\r\n\\\\ &amp;= E_{x \\sim p}(\\log p(x) - \\log q(x)) \\\\ &amp;= E_{x \\sim\r\np}(\\log p(x)) - E_{x \\sim p} (\\log q(x)) \\end{aligned}\r\n\\]</span></p>\r\n<p>由于<span class=\"math inline\">\\(E_{x \\sim p} (\\log p(x))\\)</span>\r\n是训练样本的期望，是个固定的常数，在求最小值时可以忽略，所以最小化<span\r\nclass=\"math inline\">\\(D_{KL}(p \\parallel q)\\)</span> 就变成了最小化<span\r\nclass=\"math inline\">\\(-E_{x\\sim p}(\\log q(x))\\)</span>\r\n，这和最大似然估计是等价的。</p>\r\n<h4 id=\"和交叉熵等价\">和交叉熵等价</h4>\r\n<p>最大似然估计、相对熵、交叉熵的公式如下 <span class=\"math display\">\\[\r\n\\begin{aligned}\\theta_{ML} &amp;= -arg \\min_\\theta E_{x\\sim p}\\log\r\nq(x;\\theta) \\\\D_{KL} &amp;= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log\r\nq(x) \\\\H(p,q) &amp;= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log\r\nq(x)\\end{aligned}\\begin{aligned}\\theta_{ML} &amp;= arg \\min_\\theta\r\nE_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &amp;= E_{x \\sim p}\\log p(x) - E_{x\r\n\\sim p} \\log q(x) \\\\H(p,q) &amp;= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x\r\n\\sim p} \\log q(x)\\end{aligned}\r\n\\]</span> 从上面可以看出，最小化交叉熵，也就是最小化<span\r\nclass=\"math inline\">\\(D_{KL}\\)</span> ，从而预测的分布<span\r\nclass=\"math inline\">\\(q(x)\\)</span> 和训练样本的真实分布<span\r\nclass=\"math inline\">\\(p(x)\\)</span> 最接近。而最小化<span\r\nclass=\"math inline\">\\(D_{KL}\\)</span> 和最大似然估计是等价的。</p>\r\n<h3 id=\"多分类交叉熵\">多分类交叉熵</h3>\r\n<p>多分类任务中输出的是目标属于<strong>每个类别的概率，所有类别概率的和为1，其中概率最大的类别就是目标所属的分类。</strong>\r\n而<code>softmax</code> 函数能将一个向量的每个分量映射到<span\r\nclass=\"math inline\">\\([0,1]\\)</span>\r\n区间，并且对整个向量的输出做了归一化，保证所有分量输出的和为1，正好满足多分类任务的输出要求。所以，在多分类中，在最后就需要将提取的到特征经过<code>softmax</code>函数的，输出为每个类别的概率，然后再使用<strong>交叉熵</strong>\r\n作为损失函数。</p>\r\n<p><code>softmax</code>函数定义如下： <span class=\"math display\">\\[\r\nS_i = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\r\n\\]</span> 其中，输入的向量为<span class=\"math inline\">\\(z_i(i =\r\n1,2,\\dots,n)\\)</span> 。</p>\r\n<p>更直观的参见下图</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/XvLsuFKjBe39AaD.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>通过前面的特征提取到的特征向量为<span\r\nclass=\"math inline\">\\((z_1,z_2,\\dots,z_k)\\)</span>\r\n，将向量输入到<code>softmax</code>函数中，即可得到目标属于每个类别的概率，概率最大的就是预测得到的目标的类别。</p>\r\n<h4 id=\"cross-entropy-loss\">Cross Entropy Loss</h4>\r\n<p>使用<code>softmax</code>函数可以将特征向量映射为所属类别的概率，可以看作是预测类别的概率分布<span\r\nclass=\"math inline\">\\(q(c_i)\\)</span> ，有 <span class=\"math display\">\\[\r\nq(c_i) = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\r\n\\]</span> 其中<span class=\"math inline\">\\(c_i\\)</span> 为某个类别。</p>\r\n<p>设训练数据中类别的概率分布为<span\r\nclass=\"math inline\">\\(p(c_i)\\)</span> ，那么目标分布<span\r\nclass=\"math inline\">\\(p(c_i)\\)</span> 和预测分布<span\r\nclass=\"math inline\">\\(q(c_i)\\)</span>的交叉熵为</p>\r\n<p><span class=\"math display\">\\[H(p,q) =-\\sum_ip(c_i)\\log q(c_i)\r\n\\]</span></p>\r\n<p>每个训练样本所属的类别是已知的，并且每个样本只会属于一个类别（概率为1），属于其他类别概率为0。具体的，可以假设有个三分类任务，三个类分别是：猫，猪，狗。现有一个训练样本类别为猫，则有：</p>\r\n<p><span class=\"math display\">\\[\\begin{align} p(cat) &amp; = 1 \\\\ p(pig)\r\n&amp;= 0 \\\\ p(dog) &amp; = 0 \\end{align} \\]</span></p>\r\n<p>通过预测得到的三个类别的概率分别为：<span\r\nclass=\"math inline\">\\(q(cat) = 0.6,q(pig) = 0.2,q(dog) = 0.2\\)</span>\r\n，计算<span class=\"math inline\">\\(p\\)</span> 和<span\r\nclass=\"math inline\">\\(q\\)</span> 的交叉熵为： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned} H(p,q) &amp;= -(p(cat) \\log q(cat) + p(pig) + \\log\r\nq(pig) + \\log q(dog)) \\\\ &amp;= - (1 \\cdot \\log 0.6 + 0 \\cdot \\log 0.2\r\n+0 \\cdot \\log 0.2) \\\\ &amp;= - \\log 0.6 \\\\ &amp;= - \\log q(cat)\r\n\\end{aligned}\r\n\\]</span>\r\n利用这种特性，可以将样本的类别进行重新编码，就可以简化交叉熵的计算，这种编码方式就是<strong>one-hot</strong>\r\n编码。以上面例子为例， <span class=\"math display\">\\[\r\n\\begin{aligned} \\text{cat} &amp;= (1 0 0) \\\\ \\text{pig} &amp;= (010) \\\\\r\n\\text{dog} &amp;= (001) \\end{aligned}\r\n\\]</span></p>\r\n<p>通过这种编码方式，在计算交叉熵时，只需要计算和训练样本对应类别预测概率的值，其他的项都是<span\r\nclass=\"math inline\">\\(0 \\cdot \\log q(c_i) = 0\\)</span> 。</p>\r\n<p>具体的，交叉熵计算公式变成如下： <span class=\"math display\">\\[\r\n(p,q) = - \\log q(c_i)\r\n\\]</span> 其中<span class=\"math inline\">\\(c_i\\)</span>\r\n为训练样本对应的类别，上式也被称为<strong>负对数似然（negative\r\nlog-likelihood,nll）</strong>。</p>\r\n<h4 id=\"pytorch中的cross-entropy\">PyTorch中的Cross Entropy</h4>\r\n<p>PyTorch中实现交叉熵损失的有三个函数<code>torch.nn.CrossEntropyLoss</code>，<code>torch.nn.LogSoftmax</code>以及<code>torch.nn.NLLLoss</code>。</p>\r\n<ul>\r\n<li><code>torch.nn.functional.log_softmax</code> 比较简单，输入为<span\r\nclass=\"math inline\">\\(n\\)</span>维向量，指定要计算的维度<code>dim</code>，输出为<span\r\nclass=\"math inline\">\\(log(Softmax(x))\\)</span>。其计算公式如下：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\text{LogSoftmax}(x_i) = \\log (\\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)})\r\n\\]</span></p>\r\n<p>没有额外的处理，就是对输入的<span\r\nclass=\"math inline\">\\(n\\)</span>维向量的每个元素进行上述运算。</p>\r\n<ul>\r\n<li><code>torch.nn.functional.nll_loss</code> 负对数似然损失（Negative\r\nLog Likelihood\r\nLoss)，用于多分类，其输入的通常是<code>torch.nn.functional.log_softmax</code>的输出值。其函数如下</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">torch.nn.functional.nll_loss(<span class=\"built_in\">input</span>, target, weight=<span class=\"literal\">None</span>, size_average=<span class=\"literal\">None</span>, ignore_index=-<span class=\"number\">100</span>, reduce=<span class=\"literal\">None</span>, reduction=<span class=\"string\">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p><code>input</code>\r\n也就是<code>log_softmax</code>的输出值，各个类别的对数概率。<code>target</code>\r\n目标正确类别,<code>weight</code>\r\n针对类别不平衡问题，可以为类别设置不同的权值；<code>ignore_index</code>\r\n要忽略的类别，不参与loss的计算；比较重要的是<code>reduction</code>\r\n的值，有三个取值：<code>none</code>\r\n不做处理，输出的结果为向量；<code>mean</code>\r\n将<code>none</code>结果求均值后输出；<code>sum</code>\r\n将<code>none</code> 结果求和后输出。</p>\r\n<ul>\r\n<li><code>torch.nn.CrossEntropyLoss</code>就是上面两个函数的组合<code>nll_loss(log_softmax(input))</code>。</li>\r\n</ul>\r\n<h3 id=\"二分类交叉熵\">二分类交叉熵</h3>\r\n<p>多分类中使用<code>softmax</code>函数将最后的输出映射为每个类别的概率，而在二分类中则通常使用<code>sigmoid</code>\r\n将输出映射为正样本的概率。这是因为二分类中，只有两个类别：{正样本，负样本}，只需要求得正样本的概率<span\r\nclass=\"math inline\">\\(q\\)</span>,则<span\r\nclass=\"math inline\">\\(1-q\\)</span>\r\n就是负样本的概率。这也是多分类和二分类不同的地方。</p>\r\n<p><span class=\"math inline\">\\(\\text{sigmoid}\\)</span>\r\n函数的表达式如下： <span class=\"math display\">\\[\r\n\\sigma(z) = \\frac{1}{1 + e^{-z}}\r\n\\]</span> sigmoid的输入为<span class=\"math inline\">\\(z\\)</span>\r\n，其输出为<span class=\"math inline\">\\((0,1)\\)</span>\r\n，可以表示分类为正样本的概率。</p>\r\n<p>二分类的交叉熵可以看作是交叉熵损失的一个特列，交叉熵为 <span\r\nclass=\"math display\">\\[\r\n\\text{$Cross\\_Entorpy$}(p,q) = -\\sum_i^m p(x_i) \\log q(x_i)\r\n\\]</span> 这里只有两个类别<span class=\"math inline\">\\(x \\in\r\n{x_1,x_2}\\)</span> ，则有 <span class=\"math display\">\\[\r\n\\begin{aligned}\\text{$Cross\\_Entorpy$}(p,q) &amp;= -(p(x_1) \\log q(x_1)\r\n+ p(x_2) \\log q(x_2)) \\end{aligned}\r\n\\]</span></p>\r\n<p>因为只有两个选择，则有<span class=\"math inline\">\\(p(x_1) + p(x_2) =\r\n1,q(x_1) + q(x_2) = 1\\)</span> 。设，训练样本中<span\r\nclass=\"math inline\">\\(x_1\\)</span>的概率为<span\r\nclass=\"math inline\">\\(p\\)</span>，则<span\r\nclass=\"math inline\">\\(x_2\\)</span>为<span\r\nclass=\"math inline\">\\(1-p\\)</span>; 预测的<span\r\nclass=\"math inline\">\\(x_1\\)</span>的概率为<span\r\nclass=\"math inline\">\\(q\\)</span>，则<span\r\nclass=\"math inline\">\\(x_2\\)</span>的预测概率为<span\r\nclass=\"math inline\">\\(1 - q\\)</span> 。则上式可改写为 <span\r\nclass=\"math display\">\\[\r\n\\text{$Cross\\_Entropy$}(p,q) = -(p \\log q + (1-p) \\log (1-q))\r\n\\]</span> 也就是二分类交叉熵的损失函数。</p>\r\n<h3 id=\"总结\">总结</h3>\r\n<p>相对熵可以用来度量两个分布相似性，假设分布<span\r\nclass=\"math inline\">\\(p\\)</span>是训练样本的分布，<span\r\nclass=\"math inline\">\\(q\\)</span>是预测得到的分布。分类训练的过程实际上就是最小化<span\r\nclass=\"math inline\">\\(D_{KL}(p \\parallel q)\\)</span>，由于由于交叉熵\r\n<span class=\"math display\">\\[\r\nH(p,q)= D_{KL}(p \\parallel q) + H(p)\r\n\\]</span> 其中,<span\r\nclass=\"math inline\">\\(H(p)\\)</span>是训练样本的熵，是一个已知的常量，这样最小化相对熵就等价于最小化交叉熵。</p>\r\n<p>从最大似然估计转化为最小化负对数似然 <span class=\"math display\">\\[\r\n\\theta_{ML} = -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta)\r\n\\]</span> 也等价于最小化相对熵。</p>\r\n<h2 id=\"回归问题\">回归问题</h2>\r\n<p>回归：人们在测量事物的时候因为客观条件所限，求得的都是测量值，而不是事物真实的值，为了能够得到真实值，无限次的进行测量，最后通过这些测量数据计算<strong>回归到真实值</strong>，这就是回归的由来。</p>\r\n<p>回归分析的主要算法包括：</p>\r\n<ol type=\"1\">\r\n<li>线性回归(Linear Regression)</li>\r\n<li>逻辑回归（Logistic regressions）</li>\r\n<li>多项式回归(Polynomial Regression)</li>\r\n<li>逐步回归(Step Regression)</li>\r\n<li>岭回归(Ridge Regression)</li>\r\n<li>套索回归(Lasso Regression)</li>\r\n<li>弹性网回归(ElasticNet)</li>\r\n</ol>\r\n<h2 id=\"最大似然估计\">最大似然估计</h2>\r\n<p>wiki定义：<code>在统计学中，最大似然估计（英语：maximum likelihood estimation，简作MLE），也称极大似然估计，是用来估计一个概率模型的参数的一种方法。</code></p>\r\n<h3 id=\"原理\">原理</h3>\r\n<p>给定一个概率分布𝐷，已知其<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5qaC546H5a+G5bqm5Ye95pWw\">概率密度函数<i class=\"fa fa-external-link-alt\"></i></span>（连续分布）或<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5qaC546H6LSo6YeP5Ye95pWw\">概率质量函数<i class=\"fa fa-external-link-alt\"></i></span>（离散分布）为𝑓𝐷，以及一个分布参数𝜃，我们可以从这个分布中抽出一个具有𝑛个值的采样𝑋1,𝑋2,…,𝑋𝑛，利用𝑓𝐷计算出其<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Ly854S25Ye95pWw\">似然函数<i class=\"fa fa-external-link-alt\"></i></span>：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a9702eeec5a8eb416883af66665ac11bd8151f0f\"\r\nalt=\"{(x_{1},,x_{n})=f_{}(x_{1},,x_{n}).}\" />\r\n<figcaption\r\naria-hidden=\"true\">{(x_{1},,x_{n})=f_{}(x_{1},,x_{n}).}</figcaption>\r\n</figure>\r\n<p>若𝐷是离散分布，𝑓𝜃即是在参数为𝜃时观测到这一采样的概率；若其是连续分布，𝑓𝜃则为𝑋1,𝑋2,…,𝑋𝑛联合分布的概率密度函数在观测值处的取值。一旦我们获得𝑋1,𝑋2,…,𝑋𝑛，我们就能求得一个关于𝜃的估计。最大似然估计会寻找关于𝜃的最可能的值（即，在所有可能的𝜃取值中，寻找一个值使这个采样的“可能性”最大化）。从数学上来说，我们可以在𝜃的所有可能取值中寻找一个值使得似然<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Ye95pWw\">函数<i class=\"fa fa-external-link-alt\"></i></span>取到最大值。这个使可能性最大的<span\r\nclass=\"math display\">\\[\\hat\r\n𝜃\\]</span>值即称为𝜃的<strong>最大似然估计</strong>。由定义，最大似然估计是样本的函数。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5pyA5aSn5Ly854S25Lyw6K6h\">最大似然估计 -\r\n维基百科，自由的百科全书 (wikipedia.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n","length":8376,"excerpt":"<h2 id=\"函数式自动微分\">函数式自动微分</h2>\r\n<blockquote>\r\n<p>神经网络的训练主要使用反向传播算法，模型预测值（logits）与正确标签（label）送入损失函数（loss\r\nfunction）获得loss，然后进行反向传播计算，求得梯度（gradients），最终更新至模型参数（parameters）。自动微分能够计算可导函数在某点处的导数值，是反向传播算法的一般化。自动微分主要解决的问题是将一个复杂的数学运算分解为一系列简单的基本运算，该功能对用户屏蔽了大量的求导细节和过程，大大降低了框架的使用门槛。</p>\r\n</blockquote>","more":"<blockquote>\r\n<p>MindSpore使用函数式自动微分的设计理念，提供更接近于数学语义的自动微分接口<code>grad</code>和<code>value_and_grad</code>。下面我们使用一个简单的单层线性变换模型进行介绍。</p>\r\n</blockquote>\r\n<p>这里总算是提到了反向传播，最近我看到了一系列视频有关Machine\r\nLearning，传送门如下：</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1JbGczZ0dld1E1VQ==\">🔴 World of\r\nWarships / USS Des Moines cut (youtube.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>如果你试图看下去的话，可能会发现，事情好像突然变难了，似乎一群从未见过的知识组合在了一起，神经网络就像一个黑箱连着另一个黑箱，而你根本不知道如何优化它，使得黑箱在给定的输入下输出正确答案</p>\r\n<h2 id=\"神经网络到底代表了什么\">神经网络到底代表了什么</h2>\r\n<p>首先让我们定义什么是神经：他是一个携带一个浮点数的结构，然后让我们看向神经网络</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/MLN1Ap2wslU4SQB.jpg\" alt=\"R\" />\r\n<figcaption aria-hidden=\"true\">R</figcaption>\r\n</figure>\r\n<p>对于每一个点，我们从最后看起，显然，他们代表0-9，更准确的说，他们代表0-9的图像。为什么这样的网络是生效的呢？</p>\r\n<p><strong><em>因为分形思想</em></strong>，我们将一段连续的图像区分为一段一段，比如9是⚪在上而线条在下。4由多端线段1组成。而⚪和线条又可以继续再分，我们可以将神经网络中的每一个节点代表的数据想象成这种规律图案的集合。他们之间的传递就是图案在网络中不断组合。这也是为什么在网络中使用全连接的原因，因为每一个图案都能与其他任何图案组合。最终我们使图案变成了不断分形像素的组合。</p>\r\n<p>但如何做到这一点呢？ 考虑我们前面提到的参数，权值。</p>\r\n<figure>\r\n<img\r\nsrc=\"./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240607181215798.png\"\r\nalt=\"image-20240607181215798\" />\r\n<figcaption aria-hidden=\"true\">image-20240607181215798</figcaption>\r\n</figure>\r\n<p>这张图相信有很多人见过类似的图，实际上权值代表的就是神经网络之间的连线，假设我们让正权值在下表中为绿负权值在下表中为红，我们将这样描述一条“线段”：一段由红色包围的长条状绿色区域这样我们就能得出，如果这段线条是成立得话，比如确实原图这里存在一条线段，我们得到的这个神经节点上得值就会很接近1，否则就会很接近零。这就是权值得意义。但同时，我们会注意到神经得值是许多这样计算的累和，因此我们需要一个bias，偏差值将其计算到到0-1。</p>\r\n<p>注意这里得权值和偏差值均是变量，是训练出来的。并且注意，我们并不知道机器是如何分形得，这取决于学习数据和使用的算法，以上只为举例理解。</p>\r\n<p>如果将最初得神经网络拿去使用，你只会得到一大堆垃圾数据。我们都知道神经网络存在“进化”过程，但他是如何知道自己错得有多离谱的呢？</p>\r\n<h2 id=\"cost-functionmaybe-also-loss-function\">Cost Function（Maybe also\r\nloss function?）</h2>\r\n<p>初略的定义是他是输出的张量与正确的张量的差值平方和，比如，机器输出了一个全是0.5的10个数的张量，而正确答案是其中之一，那么\r\n<span class=\"math display\">\\[\r\n\\text{Cost} = (1-0.5) + 0.5*9\r\n\\]</span> 显然这个数字更接近0，说明结果更加准确</p>\r\n<p>考虑如何让模型表现得更好，显然是需要找到一组参数，使得每次输出的cost值最小。我们可以考虑这样一种方式，以参数作为输入，cost的值作为输出，而训练数据则是参数。</p>\r\n<h3 id=\"梯度下降-gradient-descent\">梯度下降 (Gradient Descent)</h3>\r\n<p>似乎难以理解，假设我们只有一个参数cost=f(c)，c是唯一的参数。于是变为了函数的最值问题，只需要求导数然后慢慢移动我们的初始点。很显然，一个函数在常数域上可能存在多个极大值而只有一个最大值。当我们从一个点出发寻找最大值时，很有可能（概率学上讲应该是绝对）我们只会找到一个极大值。即在神经网络中，我们不能保证我们的参数是最优的，只能保证我们的参数是局部最优的（这取决于我们的起始点）。</p>\r\n<p>变到多维，我们意识到，一个数的导数是否只有正或负两种信息有效（代表是应该增加这个数还是减少这个数）。假定两个变量在一个点上的导数其中一个是另一个的三倍，这至少说明在该点的邻域内，这一变量应该减少的更多是正确的。（可能有一些函数存在极端的尖点导致错误，但这在神经网络中是低概率的，掌控好更改数据的大小即可）。</p>\r\n<p>一个简单的例子是，维护好一个<span class=\"math display\">\\[\\nabla\r\nC\\]</span>矩阵，一阶导数对应的值高则其增加，反之则减少。</p>\r\n<h2 id=\"反向传播\">反向传播</h2>\r\n<p>从特殊到一般，我们先观察这样一个样例</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/SJ5Rf7m6cXFs8yN.png\"\r\nalt=\"image-20240607205110764\" />\r\n<figcaption aria-hidden=\"true\">image-20240607205110764</figcaption>\r\n</figure>\r\n<p>显然我们需要增加2，并且如果给我们要做的事情做出一个排序，增加2显然排在减少8之前。</p>\r\n<p>因此，让我们继续看增加2所涉及的值</p>\r\n<ol type=\"1\">\r\n<li>更改偏差值</li>\r\n<li>更改权值（根据节点值）</li>\r\n<li>更改上一层节点的值（根据权值）</li>\r\n</ol>\r\n<p>我们对权值和边权同时改变，并统计下一层节点需要的变化对上一层的节点影响的累和</p>\r\n<p>通过多组数据得出权值的总共改变值改变值。这就是随机梯度下降（Stochastic\r\ngradient descent）</p>\r\n<p>下面简单讲一讲其他的名词解释</p>\r\n<h2 id=\"mini-batches\">Mini-batches</h2>\r\n<p>和他的名字一样，这个技术就是将训练数据分为几组以提高收敛参数的效率</p>\r\n<h2 id=\"backpropagation\">Backpropagation</h2>\r\n<p>反向传播是一种梯度下降法的应用，通过链式法则计算损失函数相对于每个权重的梯度，然后利用这些梯度来更新权重。</p>\r\n<h2 id=\"函数与计算图\">函数与计算图</h2>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/iqHnjI12DSKR6P7.png\"\r\nalt=\"compute-graph\" />\r\n<figcaption aria-hidden=\"true\">compute-graph</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>计算图是用图论语言表示数学函数的一种方式，也是深度学习框架表达神经网络模型的统一方法。我们将根据下面的计算图构造计算函数和神经网络。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>在这个模型中，𝑥为输入，𝑦为正确值，𝑤和𝑏是我们需要优化的参数。</p>\r\n</blockquote>\r\n<ol type=\"1\">\r\n<li>𝑥为输入</li>\r\n<li>𝑦为正确值</li>\r\n<li>𝑤和𝑏是我们需要优化的参数</li>\r\n</ol>\r\n<p>即对应了原始数据，输出结果，权重和偏差</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = ops.ones(<span class=\"number\">5</span>, mindspore.float32)  <span class=\"comment\"># input tensor</span></span><br><span class=\"line\">y = ops.zeros(<span class=\"number\">3</span>, mindspore.float32)  <span class=\"comment\"># expected output</span></span><br><span class=\"line\">w = Parameter(Tensor(np.random.randn(<span class=\"number\">5</span>, <span class=\"number\">3</span>), mindspore.float32), name=<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"comment\"># weight</span></span><br><span class=\"line\">b = Parameter(Tensor(np.random.randn(<span class=\"number\">3</span>,), mindspore.float32), name=<span class=\"string\">&#x27;b&#x27;</span>) <span class=\"comment\"># bias</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>我们根据计算图描述的计算过程，构造计算函数。 其中，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLmJpbmFyeV9jcm9zc19lbnRyb3B5X3dpdGhfbG9naXRzLmh0bWw=\">binary_cross_entropy_with_logits<i class=\"fa fa-external-link-alt\"></i></span>\r\n是一个损失函数，计算预测值和目标值之间的二值交叉熵损失。</p>\r\n</blockquote>\r\n<p>解释一下Parameter(): <strong>Parameter</strong> 是 Tensor\r\n的子类，当它们被绑定为Cell的属性时，会自动添加到其参数列表中，并且可以通过Cell的某些方法获取，例如\r\ncell.get_<strong>parameter</strong>s() 。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\">loss = function(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(loss)</span><br></pre></td></tr></table></figure>\r\n<p>这里有复杂概念<a\r\nhref=\"#二值交叉熵损失\"><em>二值交叉熵损失</em></a>，如果你不想深究只需要这是一个对参数的函数，当这个函数值最低时，整体参数就是一个准确率较高的局部最优解即可。</p>\r\n<h2 id=\"微分函数与梯度计算\">微分函数与梯度计算</h2>\r\n<blockquote>\r\n<p>为了优化模型参数，需要求参数对loss的导数：<span\r\nclass=\"math display\">\\[\\frac{𝜕loss}{𝜕𝑤}\\]</span>和<span\r\nclass=\"math display\">\\[\\frac{𝜕loss}{𝜕𝑏}\\]</span>，此时我们调用<code>mindspore.grad</code>函数，来获得<code>function</code>的微分函数。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>这里使用了<code>grad</code>函数的两个入参，分别为：</p>\r\n<ul>\r\n<li><code>fn</code>：待求导的函数。</li>\r\n<li><code>grad_position</code>：指定求导输入位置的索引。</li>\r\n</ul>\r\n</blockquote>\r\n<blockquote>\r\n<p>由于我们对<span class=\"math display\">\\[𝑤\\]</span>和<span\r\nclass=\"math display\">\\[𝑏\\]</span>​求导，因此配置其在<code>function</code>入参对应的位置<code>(2, 3)</code>。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p><em>使用<code>grad</code>获得微分函数是一种函数变换，即输入为函数，输出也为函数。</em></p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grad_fn = mindspore.grad(function, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class=\"line\"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]]), Tensor(shape=[3], dtype=Float32, value= [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]))</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>执行微分函数，即可获得<span class=\"math display\">\\[𝑤\\]</span>、<span\r\nclass=\"math display\">\\[𝑏\\]</span>​对应的梯度。可以注意到w,b的梯度与最初始的梯度是一致的。</p>\r\n<h3 id=\"stop-gradient\">Stop Gradient</h3>\r\n<blockquote>\r\n<p>通常情况下，求导时会求loss对参数的导数，因此函数的输出只有loss一项。<strong>当我们希望函数输出多项时，微分函数会求所有输出项对参数的导数</strong>。此时如果想实现对某个输出项的梯度截断，或消除某个Tensor对梯度的影响，需要用到Stop\r\nGradient操作。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>这里我们将<code>function</code>改为同时输出loss和z的<code>function_with_logits</code>，获得微分函数并执行。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function_with_logits</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, z</span><br><span class=\"line\"></span><br><span class=\"line\">grad_fn = mindspore.grad(function_with_logits, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">function_stop_gradient</span>(<span class=\"params\">x, y, w, b</span>):</span><br><span class=\"line\">    z = ops.matmul(x, w) + b</span><br><span class=\"line\">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, ops.stop_gradient(z)</span><br><span class=\"line\"></span><br><span class=\"line\">grad_fn = mindspore.grad(function_stop_gradient, (<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">grads = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p><code>ops.stop_gradient(z)</code>:重点在该函数，表示屏蔽了z对梯度的影响，即仍只求参数对loss的导数。</p>\r\n<p>这里解释一下一些api的含义</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mindspore.grad(fn, grad_position=<span class=\"number\">0</span>, weights=<span class=\"literal\">None</span>, has_aux=<span class=\"literal\">False</span>, return_ids=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZ3JhZC5odG1sP2hpZ2hsaWdodD1ncmFkI21pbmRzcG9yZS5ncmFk\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mindspore.numpy.matmul(x1, x2, dtype=None)</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL251bXB5L21pbmRzcG9yZS5udW1weS5tYXRtdWwuaHRtbD9oaWdobGlnaHQ9bWF0bXVsI21pbmRzcG9yZS5udW1weS5tYXRtdWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n</ul>\r\n<h3 id=\"auxiliary-data\">Auxiliary data</h3>\r\n<p>Auxiliary\r\ndata意为辅助数据，是函数除第一个输出项外的其他输出。通常我们会将函数的loss设置为函数的第一个输出，其他的输出即为辅助数据。</p>\r\n<p><code>grad</code>和<code>value_and_grad</code>提供<code>has_aux</code>参数，当其设置为<code>True</code>时，可以自动实现前文手动添加<code>stop_gradient</code>的功能，满足返回辅助数据的同时不影响梯度计算的效果。</p>\r\n<p>下面仍使用<code>function_with_logits</code>，配置<code>has_aux=True</code>，并执行。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grad_fn = mindspore.grad(function_with_logits, (<span class=\"number\">2</span>, <span class=\"number\">3</span>), has_aux=<span class=\"literal\">True</span>)</span><br><span class=\"line\">grads, (z,) = grad_fn(x, y, w, b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads, z)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"神经网络梯度计算\">神经网络梯度计算</h3>\r\n<blockquote>\r\n<p>前述章节主要根据计算图对应的函数介绍了MindSpore的函数式自动微分，但我们的神经网络构造是继承自面向对象编程范式的<code>nn.Cell</code>。接下来我们通过<code>Cell</code>构造同样的神经网络，利用函数式自动微分来实现反向传播。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>首先我们继承<code>nn.Cell</code>构造单层线性变换神经网络。这里我们直接使用前文的𝑤、𝑏作为模型参数，使用<code>mindspore.Parameter</code>进行包装后，作为内部属性，并在<code>construct</code>内实现相同的Tensor操作。</p>\r\n</blockquote>\r\n<p>这里出现了反向传播方法,并且是包装好的,建议读者仔细看一下代码并尝试自己运行一下。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义神经网络模型</span></span><br><span class=\"line\"><span class=\"comment\"># Define model</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Network</span>(nn.Cell):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.w = w</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.b = b</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">construct</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        z = ops.matmul(x, <span class=\"variable language_\">self</span>.w) + <span class=\"variable language_\">self</span>.b</span><br><span class=\"line\">        <span class=\"keyword\">return</span> z</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Instantiate model</span></span><br><span class=\"line\">model = Network()</span><br><span class=\"line\"><span class=\"comment\"># Instantiate loss function</span></span><br><span class=\"line\">loss_fn = nn.BCEWithLogitsLoss()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Define forward function</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward_fn</span>(<span class=\"params\">x, y</span>):</span><br><span class=\"line\">    z = model(x)</span><br><span class=\"line\">    loss = loss_fn(z, y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注入损失函数</span></span><br><span class=\"line\">grad_fn = mindspore.value_and_grad(forward_fn, <span class=\"literal\">None</span>, weights=model.trainable_params())</span><br><span class=\"line\">loss, grads = grad_fn(x, y)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(grads)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"总结输出单次\">总结输出（单次）</h3>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0.92031693</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br><span class=\"line\">计算多个参数的导数</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class=\"line\"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]]), Tensor(shape=[3], dtype=Float32, value= [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]))</span><br><span class=\"line\">消除部分张量对梯度的影响</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br><span class=\"line\">Auxiliary data 辅助数据测试</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01])) [ 0.8580145   0.62723386 -0.44728255]      </span><br><span class=\"line\">开始实测网络模型的反向传播</span><br><span class=\"line\">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class=\"line\">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class=\"line\"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<p>可见，除了在计算z的导数对梯度的影响情况下，均保持了相同的输出，并且可以观察到w,b的权值</p>\r\n<h2 id=\"二值交叉熵损失\">二值交叉熵损失</h2>\r\n<p><strong><em>以下的对数均为自然对数</em></strong></p>\r\n<p>Binary cross entropy 二元<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Lqk5Y+J54a1\">交叉熵<i class=\"fa fa-external-link-alt\"></i></span>是二分类问题中常用的一个Loss损失函数，在常见的机器学习模块中都有实现。就二元交叉熵这个损失函数的原理，简单地进行解释。下面是二元交叉熵损失函数的公式\r\n<span class=\"math display\">\\[\r\nL=-\\frac1N \\sum_{i=1}^{N}[y_ilog(p_i)+(1-y_i)log(1-p_i)]\r\n\\]</span> 先不尝试理解他，先看看他是如何运作的</p>\r\n<p><img src=\"https://s2.loli.net/2024/06/07/MAOZxqKodRSW6uy.jpg\"\r\nalt=\"img\" /> <span class=\"math display\">\\[\r\nL=\\frac13[(1*log0.8+(1-1)*log(1-0.8))+(0*log0.2+(1-0)*log(1-0.2))+(0*log0.4+(1-0)*log(1-0.4))]=0.319\r\n\\\\\r\n\\]</span> 对于以上的案例计算损失函数，结果是0.31903</p>\r\n<h3 id=\"从熵来看交叉熵损失\">从熵来看交叉熵损失</h3>\r\n<h4 id=\"信息量\">信息量</h4>\r\n<p>信息量来衡量一个事件的不确定性，一个事件发生的概率越大，不确定性越小，则其携带的信息量就越小。</p>\r\n<p>设<span\r\nclass=\"math display\">\\[X\\]</span>是一个离散型随机变量，其取值为集合<span\r\nclass=\"math display\">\\[X =\r\n{x_0,x_1,\\dots,x_n}\\]</span>，则其概率分布函数为<span\r\nclass=\"math display\">\\[p(x) = Pr(X = x),x \\in\r\nX\\]</span>，则定义事件<span\r\nclass=\"math display\">\\[X=x_0\\]</span>的信息量为： <span\r\nclass=\"math display\">\\[\r\nI(x_0) = -\\log(p(x_0))\r\n\\]</span> 当<span class=\"math display\">\\[p(x_0) =\r\n1\\]</span>时，其携带的信息量为0。</p>\r\n<h4 id=\"熵\">熵</h4>\r\n<p>熵用来衡量一个系统的混乱程度，代表系统中信息量的总和；熵值越大，表明这个系统的不确定性就越大。具体而数学的讲，熵就是一个系统中所有信息量的期望。</p>\r\n<p>信息量是衡量某个事件的不确定性，而熵是衡量一个系统（所有事件）的不确定性。</p>\r\n<p>熵的计算公式 <span class=\"math display\">\\[\r\nH(x) = -\\sum_{i=1}^np(x_i)\\log(p(x_i))\r\n\\]</span> 比较特殊的有二项分布熵 <span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nH(X)&amp;=&amp;-\\sum_{i=1}^n p(x_i)log(p(x_i))\\\\\r\n&amp;=&amp;-p(x)log(p(x))-(1-p(x))log(1-p(x))\r\n\\end{eqnarray}\r\n\\]</span> <em>熵也有其他类型的计算公式，这里是信息学上的定义</em></p>\r\n<p>其中<span\r\nclass=\"math display\">\\[p(x)\\]</span>为这件事发生的概率，<span\r\nclass=\"math display\">\\[-log(p(x_i))\\]</span>是事件<span\r\nclass=\"math display\">\\[x_i\\]</span>所携带的信息量。</p>\r\n<p>可以看出，熵是信息量的期望值，是一个随机变量（一个系统，事件所有可能性）不确定性的度量。熵值越大，随机变量的取值就越难确定，系统也就越不稳定；熵值越小，随机变量的取值也就越容易确定，系统越稳定。</p>\r\n<h4 id=\"相对熵-relative-entropy-kl散度\">相对熵 （Relative entropy）/\r\nKL散度</h4>\r\n<p>wiki对相对熵的定义如下：<code>In the context of machine learning, DKL(P‖Q) is often called the information gain achieved if P is used instead of Q.</code></p>\r\n<p>即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。</p>\r\n<p>在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。</p>\r\n<p>总结：相对熵也称为KL散度(Kullback-Leibler\r\ndivergence)，表示同一个随机变量的两个不同分布间的距离。</p>\r\n<p>设 <span class=\"math display\">\\[p(x),𝑞(𝑥)\\]</span>分别是\r\n离散随机变量<span\r\nclass=\"math display\">\\[X\\]</span>的两个概率分布，则<span\r\nclass=\"math display\">\\[p\\]</span>对<span\r\nclass=\"math display\">\\[q\\]</span>的相对熵是： <span\r\nclass=\"math display\">\\[\r\nD_{KL}(p \\parallel q) = \\sum_i p(x_i) log(\\frac{p(x_i)}{q(x_i)})\r\n\\]</span> 相对熵具有以下性质：</p>\r\n<ul>\r\n<li>如果p(x)和q(x)的分布相同，则其相对熵等于0</li>\r\n<li><span\r\nclass=\"math display\">\\[D_{KL}(p∥q)≠D_{KL}(q∥p)𝐷_{𝐾𝐿}(𝑝∥𝑞)≠𝐷_{𝐾𝐿}(𝑞∥𝑝)\\]</span>，也就是相对熵不具有对称性。</li>\r\n<li><span class=\"math display\">\\[D_{KL}(p∥q)≥0\\]</span></li>\r\n</ul>\r\n<p>总的来说，相对熵是用来衡量同一个随机变量的两个不同分布之间的距离。<strong>在实际应用中，假如p(x)是目标真实的分布，而q(x)是预测得来的分布，为了让这两个分布尽可能的相同的，就需要最小化KL散度。</strong></p>\r\n<h4 id=\"交叉熵-cross-entropy\">交叉熵 Cross Entropy</h4>\r\n<p>设<span class=\"math display\">\\[p(x),q(x)\\]</span>分别是\r\n离散随机变量<span\r\nclass=\"math display\">\\[X\\]</span>的两个概率分布，其中<span\r\nclass=\"math display\">\\[p(x)\\]</span>是目标分布，<span\r\nclass=\"math display\">\\[p\\]</span>和<span\r\nclass=\"math display\">\\[q\\]</span>的交叉熵可以看做是，使用分布<span\r\nclass=\"math display\">\\[q(x)\\]</span>表示目标分布<span\r\nclass=\"math display\">\\[p(x)\\]</span>的困难程度 <span\r\nclass=\"math display\">\\[\r\nH(p,q) = \\sum_ip(x_i)log\\frac{1}{\\log q(x_i)} = -\\sum_ip(x_i)\\log q(x_i)\r\n\\]</span> 将熵、相对熵以及交叉熵的公式放到一起， <span\r\nclass=\"math display\">\\[\r\n\\begin{align}\r\nH(p) &amp;= -\\sum_{i}p(x_i) \\log p(x_i) \\\\\r\nD_{KL}(p \\parallel q) &amp;= \\sum_{i}p(x_i)\\log \\frac{p(x_i)}{q(x_i)} =\r\n\\sum_i (p(x_i)\\log p(x_i) - p(x_i) \\log q(x_i)) \\\\\r\nH(p,q) &amp;=  -\\sum_ip(x_i)\\log q(x_i)\r\n\\end{align}\r\n\\]</span> 通过上面三个公式就可以得到 <span class=\"math display\">\\[\r\nD_{KL}(p,q) = H(p,q)- H(p)\r\n\\]</span> 其中，前一项<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>就是<span\r\nclass=\"math display\">\\[p,q\\]</span>的交叉熵。在机器学习中，目标的分布<span\r\nclass=\"math display\">\\[p(x)\\]</span>通常是训练数据的分布是固定，即是<span\r\nclass=\"math display\">\\[H(p)\\]</span>是一个常量。这样两个分布的交叉熵<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>也就等价于最小化这两个分布的相对熵<span\r\nclass=\"math display\">\\[D_{KL}(p \\parallel q)\\]</span></p>\r\n<p>设<span\r\nclass=\"math display\">\\[p(x)\\]</span>是目标分布（训练数据的分布），我们的目标的就让训练得到的分布<span\r\nclass=\"math display\">\\[q(x)\\]</span>尽可能的接近<span\r\nclass=\"math display\">\\[p(x)\\]</span>，这时候就可以最小化<span\r\nclass=\"math display\">\\[D_{KL}(p∥q)\\]</span>，等价于最小化交叉熵<span\r\nclass=\"math display\">\\[H(p,q)\\]</span>​。</p>\r\n<h3 id=\"为什么要用交叉熵做loss函数\">为什么要用交叉熵做loss函数</h3>\r\n<p>在线性回归问题中，常常使用MSE（Mean Squared\r\nError）作为loss函数，比如： <span class=\"math display\">\\[\r\nloss = \\frac{1}{2m}\\sum_{i=1}^m(y_i-\\hat{y_i})^2\r\n\\]</span> 这里的m表示m个样本的，loss为m个样本的loss均值。 MSE在<a\r\nhref=\"#%20回归问题\">线性回归问题</a>中比较好用，那么在逻辑分类问题中还是如此么？</p>\r\n<h3 id=\"交叉熵在单分类问题中的使用\">交叉熵在单分类问题中的使用</h3>\r\n<p>这里的单类别是指，每一张图像样本只能有一个类别，比如只能是狗或只能是猫。\r\n交叉熵在单分类问题上基本是标配的方法 <span class=\"math display\">\\[\r\nloss=-\\sum_{i=1}^{n}y_ilog(\\hat{y_i})\r\n\\]</span> 上式为一张样本的loss计算方法。n代表着n种类别。\r\n举例说明,比如有如下样本</p>\r\n<p>对应的标签和预测值</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>*</th>\r\n<th>猫</th>\r\n<th>青蛙</th>\r\n<th>老鼠</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Label</td>\r\n<td>0</td>\r\n<td>1</td>\r\n<td>0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Pred</td>\r\n<td>0.3</td>\r\n<td>0.6</td>\r\n<td>0.1</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nloss&amp;=&amp;-(0\\times log(0.3)+1\\times log(0.6)+0\\times log(0.1)\\\\\r\n&amp;=&amp;-log(0.6)\r\n\\end{eqnarray}\r\n\\]</span> 对应的一个batch的loss就是 <span class=\"math display\">\\[\r\nloss=-\\frac{1}{m}\\sum_{j=1}^m\\sum_{i=1}^{n}y_{ji}log(\\hat{y_{ji}})\r\n\\]</span> m为当前batch的样本数</p>\r\n<h3 id=\"交叉熵在多分类问题中的使用\">交叉熵在多分类问题中的使用</h3>\r\n<p>这里的多类别是指，每一张图像样本可以有多个类别，比如同时包含一只猫和一只狗\r\n和单分类问题的标签不同，多分类的标签是n-hot。\r\n比如下面这张样本图，即有青蛙，又有老鼠，所以是一个多分类问题</p>\r\n<p>栗子</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>*</th>\r\n<th>猫</th>\r\n<th>青蛙</th>\r\n<th>老鼠</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Label</td>\r\n<td>0</td>\r\n<td>1</td>\r\n<td>1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Pred</td>\r\n<td>0.1</td>\r\n<td>0.7</td>\r\n<td>0.8</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>值得注意的是，这里的Pred不再是通过softmax计算的了，这里采用的是sigmoid。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。换句话说，就是每一个Label都是独立分布的，相互之间没有影响。所以交叉熵在这里是单独对每一个节点进行计算，每一个节点只有两种可能值，所以是一个二项分布。前面说过对于二项分布这种特殊的分布，熵的计算可以进行简化。</p>\r\n<p>同样的，交叉熵的计算也可以简化，即 <span class=\"math display\">\\[\r\nloss =-ylog(\\hat{y})-(1-y)log(1-\\hat{y})\r\n\\]</span>\r\n注意，上式只是针对一个节点的计算公式。这一点一定要和单分类loss区分开来。\r\n例子中可以计算为： <span class=\"math display\">\\[\r\n\\begin{eqnarray}\r\nloss_猫 &amp;=&amp;-0\\times log(0.1)-(1-0)log(1-0.1)=-log(0.9)\\\\\r\nloss_蛙 &amp;=&amp;-1\\times log(0.7)-(1-1)log(1-0.7)=-log(0.7)\\\\\r\nloss_鼠 &amp;=&amp;-1\\times log(0.8)-(1-1)log(1-0.8)=-log(0.8)\r\n\\end{eqnarray}\r\n\\]</span> 单张样本的loss即为 每一个batch的loss就是： <span\r\nclass=\"math display\">\\[\r\nloss\r\n=\\sum_{j=1}^{m}\\sum_{i=1}^{n}-y_{ji}log(\\hat{y_{ji}})-(1-y_{ji})log(1-\\hat{y_{ji}})\r\n\\]</span> 式中m为当前batch中的样本量，n为类别数。</p>\r\n<h3 id=\"从最大似然看交叉熵\">从<a\r\nhref=\"#%20最大似然估计\">最大似然</a>看交叉熵</h3>\r\n<p>设有一组训练样本<span class=\"math inline\">\\(X=\r\n\\{x_1,x_2,\\cdots,x_m\\}\\)</span> ,该样本的分布为<span\r\nclass=\"math inline\">\\(p(x)\\)</span> 。假设使用<span\r\nclass=\"math inline\">\\(\\theta\\)</span> 参数化模型得到<span\r\nclass=\"math inline\">\\(q(x;\\theta)\\)</span> ，现用这个模型来估计<span\r\nclass=\"math inline\">\\(X\\)</span> 的概率分布，得到似然函数 <span\r\nclass=\"math display\">\\[\r\nL(\\theta) = q(X; \\theta) = \\prod_i^mq(x_i;\\theta)\r\n\\]</span> 最大似然估计就是求得<span\r\nclass=\"math inline\">\\(\\theta\\)</span> 使得<span\r\nclass=\"math inline\">\\(L(\\theta)\\)</span> 的值最大，也就是 <span\r\nclass=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_{\\theta} \\prod_i^mq(x_i;\\theta)\r\n\\]</span> 对上式的两边同时取<span class=\"math inline\">\\(\\log\\)</span>\r\n，等价优化<span class=\"math inline\">\\(\\log\\)</span>\r\n的最大似然估计即<code>log-likelyhood</code> ，最大对数似然估计 <span\r\nclass=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_\\theta \\sum_i^m \\log q(x_i;\\theta)\r\n\\]</span> 对上式的右边进行缩放并不会改变<span class=\"math inline\">\\(arg\r\n\\max\\)</span> 的解，上式的右边除以样本的个数<span\r\nclass=\"math inline\">\\(m\\)</span> <span class=\"math display\">\\[\r\n\\theta_{ML} = arg \\max_\\theta \\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\r\n\\]</span></p>\r\n<h4 id=\"和相对熵等价\">和相对熵等价</h4>\r\n<p>上式的最大化<span class=\"math inline\">\\(\\theta_{ML}\\)</span>\r\n是和没有训练样本没有关联的，就需要某种变换使其可以用训练的样本分布来表示，因为训练样本的分布可以看作是已知的，也是对最大化似然的一个约束条件。</p>\r\n<p>注意上式的 <span class=\"math display\">\\[\r\n\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\r\n\\]</span> 相当于<strong>求随机变量<span class=\"math inline\">\\(X\\)</span>\r\n的函数<span class=\"math inline\">\\(\\log (X;\\theta)\\)</span>\r\n的均值</strong>\r\n，根据大数定理，<strong>随着样本容量的增加，样本的算术平均值将趋近于随机变量的期望。</strong>\r\n也就是说 <span class=\"math display\">\\[\r\n\\frac{1}{m}\\sum_i^m \\log q(x_i;\\theta) \\rightarrow E_{x\\sim P}(\\log\r\nq(x;\\theta))\r\n\\]</span> 其中<span class=\"math inline\">\\(E_{X\\sim P}\\)</span>\r\n表示符合样本分布<span class=\"math inline\">\\(P\\)</span>\r\n的期望，这样就将最大似然估计使用真实样本的期望来表示 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned} \\theta_{ML} &amp;= arg \\max_{\\theta} E_{x\\sim P}({\\log\r\nq(x;\\theta)}) \\\\ &amp;= arg \\min_{\\theta} E_{x \\sim P}(- \\log\r\nq(x;\\theta)) \\end{aligned}\r\n\\]</span> 对右边取负号，将最大化变成最小化运算。</p>\r\n<blockquote>\r\n<p>上述的推导过程，可以参考 《Deep Learning》 的第五章。\r\n但是，在书中变为期望的只有一句话，将式子的右边除以样本数量<span\r\nclass=\"math inline\">\\(m\\)</span> 进行缩放，从而可以将其变为<span\r\nclass=\"math inline\">\\(E_{x \\sim p}\\log\r\nq(x;\\theta)\\)</span>，没有细节过程，也可能是作者默认上面的变换对读者是一直。\r\n确实是理解不了，查了很多文章，都是对这个变换的细节含糊其辞。一个周，对这个点一直耿耿于怀，就看了些关于概率论的科普书籍，其中共有介绍大数定理的：<strong>当样本容量趋于无穷时，样本的均值趋于其期望</strong>。</p>\r\n<p>针对上面公式，除以<span class=\"math inline\">\\(m\\)</span>后，<span\r\nclass=\"math inline\">\\(\\frac{1}{m}\\sum_i^m\\log q(x_i;\\theta)\\)</span>\r\n，确实是关于随机变量函数<span class=\"math inline\">\\(\\log q(x)\\)</span>\r\n的算术平均值，而<span class=\"math inline\">\\(x\\)</span>\r\n是训练样本其分布是已知的<span class=\"math inline\">\\(p(x)\\)</span>\r\n，这样就得到了<span class=\"math inline\">\\(E_{x \\sim p}(\\log\r\nq(x))\\)</span> 。</p>\r\n</blockquote>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned} D_{KL}(p \\parallel q) &amp;= \\sum_i p(x_i)\r\nlog(\\frac{p(x_i)}{q(x_i)})\\\\ &amp;= E_{x\\sim p}(\\log \\frac{p(x)}{q(x)})\r\n\\\\ &amp;= E_{x \\sim p}(\\log p(x) - \\log q(x)) \\\\ &amp;= E_{x \\sim\r\np}(\\log p(x)) - E_{x \\sim p} (\\log q(x)) \\end{aligned}\r\n\\]</span></p>\r\n<p>由于<span class=\"math inline\">\\(E_{x \\sim p} (\\log p(x))\\)</span>\r\n是训练样本的期望，是个固定的常数，在求最小值时可以忽略，所以最小化<span\r\nclass=\"math inline\">\\(D_{KL}(p \\parallel q)\\)</span> 就变成了最小化<span\r\nclass=\"math inline\">\\(-E_{x\\sim p}(\\log q(x))\\)</span>\r\n，这和最大似然估计是等价的。</p>\r\n<h4 id=\"和交叉熵等价\">和交叉熵等价</h4>\r\n<p>最大似然估计、相对熵、交叉熵的公式如下 <span class=\"math display\">\\[\r\n\\begin{aligned}\\theta_{ML} &amp;= -arg \\min_\\theta E_{x\\sim p}\\log\r\nq(x;\\theta) \\\\D_{KL} &amp;= E_{x \\sim p}\\log p(x) - E_{x \\sim p} \\log\r\nq(x) \\\\H(p,q) &amp;= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x \\sim p} \\log\r\nq(x)\\end{aligned}\\begin{aligned}\\theta_{ML} &amp;= arg \\min_\\theta\r\nE_{x\\sim p}\\log q(x;\\theta) \\\\D_{KL} &amp;= E_{x \\sim p}\\log p(x) - E_{x\r\n\\sim p} \\log q(x) \\\\H(p,q) &amp;= -\\sum_i^m p(x_i) \\log q(x_i) = -E_{x\r\n\\sim p} \\log q(x)\\end{aligned}\r\n\\]</span> 从上面可以看出，最小化交叉熵，也就是最小化<span\r\nclass=\"math inline\">\\(D_{KL}\\)</span> ，从而预测的分布<span\r\nclass=\"math inline\">\\(q(x)\\)</span> 和训练样本的真实分布<span\r\nclass=\"math inline\">\\(p(x)\\)</span> 最接近。而最小化<span\r\nclass=\"math inline\">\\(D_{KL}\\)</span> 和最大似然估计是等价的。</p>\r\n<h3 id=\"多分类交叉熵\">多分类交叉熵</h3>\r\n<p>多分类任务中输出的是目标属于<strong>每个类别的概率，所有类别概率的和为1，其中概率最大的类别就是目标所属的分类。</strong>\r\n而<code>softmax</code> 函数能将一个向量的每个分量映射到<span\r\nclass=\"math inline\">\\([0,1]\\)</span>\r\n区间，并且对整个向量的输出做了归一化，保证所有分量输出的和为1，正好满足多分类任务的输出要求。所以，在多分类中，在最后就需要将提取的到特征经过<code>softmax</code>函数的，输出为每个类别的概率，然后再使用<strong>交叉熵</strong>\r\n作为损失函数。</p>\r\n<p><code>softmax</code>函数定义如下： <span class=\"math display\">\\[\r\nS_i = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\r\n\\]</span> 其中，输入的向量为<span class=\"math inline\">\\(z_i(i =\r\n1,2,\\dots,n)\\)</span> 。</p>\r\n<p>更直观的参见下图</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/06/07/XvLsuFKjBe39AaD.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>通过前面的特征提取到的特征向量为<span\r\nclass=\"math inline\">\\((z_1,z_2,\\dots,z_k)\\)</span>\r\n，将向量输入到<code>softmax</code>函数中，即可得到目标属于每个类别的概率，概率最大的就是预测得到的目标的类别。</p>\r\n<h4 id=\"cross-entropy-loss\">Cross Entropy Loss</h4>\r\n<p>使用<code>softmax</code>函数可以将特征向量映射为所属类别的概率，可以看作是预测类别的概率分布<span\r\nclass=\"math inline\">\\(q(c_i)\\)</span> ，有 <span class=\"math display\">\\[\r\nq(c_i) = \\frac{e^{z_i}}{\\sum^n_{i=1}e^{z_i}}\r\n\\]</span> 其中<span class=\"math inline\">\\(c_i\\)</span> 为某个类别。</p>\r\n<p>设训练数据中类别的概率分布为<span\r\nclass=\"math inline\">\\(p(c_i)\\)</span> ，那么目标分布<span\r\nclass=\"math inline\">\\(p(c_i)\\)</span> 和预测分布<span\r\nclass=\"math inline\">\\(q(c_i)\\)</span>的交叉熵为</p>\r\n<p><span class=\"math display\">\\[H(p,q) =-\\sum_ip(c_i)\\log q(c_i)\r\n\\]</span></p>\r\n<p>每个训练样本所属的类别是已知的，并且每个样本只会属于一个类别（概率为1），属于其他类别概率为0。具体的，可以假设有个三分类任务，三个类分别是：猫，猪，狗。现有一个训练样本类别为猫，则有：</p>\r\n<p><span class=\"math display\">\\[\\begin{align} p(cat) &amp; = 1 \\\\ p(pig)\r\n&amp;= 0 \\\\ p(dog) &amp; = 0 \\end{align} \\]</span></p>\r\n<p>通过预测得到的三个类别的概率分别为：<span\r\nclass=\"math inline\">\\(q(cat) = 0.6,q(pig) = 0.2,q(dog) = 0.2\\)</span>\r\n，计算<span class=\"math inline\">\\(p\\)</span> 和<span\r\nclass=\"math inline\">\\(q\\)</span> 的交叉熵为： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned} H(p,q) &amp;= -(p(cat) \\log q(cat) + p(pig) + \\log\r\nq(pig) + \\log q(dog)) \\\\ &amp;= - (1 \\cdot \\log 0.6 + 0 \\cdot \\log 0.2\r\n+0 \\cdot \\log 0.2) \\\\ &amp;= - \\log 0.6 \\\\ &amp;= - \\log q(cat)\r\n\\end{aligned}\r\n\\]</span>\r\n利用这种特性，可以将样本的类别进行重新编码，就可以简化交叉熵的计算，这种编码方式就是<strong>one-hot</strong>\r\n编码。以上面例子为例， <span class=\"math display\">\\[\r\n\\begin{aligned} \\text{cat} &amp;= (1 0 0) \\\\ \\text{pig} &amp;= (010) \\\\\r\n\\text{dog} &amp;= (001) \\end{aligned}\r\n\\]</span></p>\r\n<p>通过这种编码方式，在计算交叉熵时，只需要计算和训练样本对应类别预测概率的值，其他的项都是<span\r\nclass=\"math inline\">\\(0 \\cdot \\log q(c_i) = 0\\)</span> 。</p>\r\n<p>具体的，交叉熵计算公式变成如下： <span class=\"math display\">\\[\r\n(p,q) = - \\log q(c_i)\r\n\\]</span> 其中<span class=\"math inline\">\\(c_i\\)</span>\r\n为训练样本对应的类别，上式也被称为<strong>负对数似然（negative\r\nlog-likelihood,nll）</strong>。</p>\r\n<h4 id=\"pytorch中的cross-entropy\">PyTorch中的Cross Entropy</h4>\r\n<p>PyTorch中实现交叉熵损失的有三个函数<code>torch.nn.CrossEntropyLoss</code>，<code>torch.nn.LogSoftmax</code>以及<code>torch.nn.NLLLoss</code>。</p>\r\n<ul>\r\n<li><code>torch.nn.functional.log_softmax</code> 比较简单，输入为<span\r\nclass=\"math inline\">\\(n\\)</span>维向量，指定要计算的维度<code>dim</code>，输出为<span\r\nclass=\"math inline\">\\(log(Softmax(x))\\)</span>。其计算公式如下：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\text{LogSoftmax}(x_i) = \\log (\\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)})\r\n\\]</span></p>\r\n<p>没有额外的处理，就是对输入的<span\r\nclass=\"math inline\">\\(n\\)</span>维向量的每个元素进行上述运算。</p>\r\n<ul>\r\n<li><code>torch.nn.functional.nll_loss</code> 负对数似然损失（Negative\r\nLog Likelihood\r\nLoss)，用于多分类，其输入的通常是<code>torch.nn.functional.log_softmax</code>的输出值。其函数如下</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">torch.nn.functional.nll_loss(<span class=\"built_in\">input</span>, target, weight=<span class=\"literal\">None</span>, size_average=<span class=\"literal\">None</span>, ignore_index=-<span class=\"number\">100</span>, reduce=<span class=\"literal\">None</span>, reduction=<span class=\"string\">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p><code>input</code>\r\n也就是<code>log_softmax</code>的输出值，各个类别的对数概率。<code>target</code>\r\n目标正确类别,<code>weight</code>\r\n针对类别不平衡问题，可以为类别设置不同的权值；<code>ignore_index</code>\r\n要忽略的类别，不参与loss的计算；比较重要的是<code>reduction</code>\r\n的值，有三个取值：<code>none</code>\r\n不做处理，输出的结果为向量；<code>mean</code>\r\n将<code>none</code>结果求均值后输出；<code>sum</code>\r\n将<code>none</code> 结果求和后输出。</p>\r\n<ul>\r\n<li><code>torch.nn.CrossEntropyLoss</code>就是上面两个函数的组合<code>nll_loss(log_softmax(input))</code>。</li>\r\n</ul>\r\n<h3 id=\"二分类交叉熵\">二分类交叉熵</h3>\r\n<p>多分类中使用<code>softmax</code>函数将最后的输出映射为每个类别的概率，而在二分类中则通常使用<code>sigmoid</code>\r\n将输出映射为正样本的概率。这是因为二分类中，只有两个类别：{正样本，负样本}，只需要求得正样本的概率<span\r\nclass=\"math inline\">\\(q\\)</span>,则<span\r\nclass=\"math inline\">\\(1-q\\)</span>\r\n就是负样本的概率。这也是多分类和二分类不同的地方。</p>\r\n<p><span class=\"math inline\">\\(\\text{sigmoid}\\)</span>\r\n函数的表达式如下： <span class=\"math display\">\\[\r\n\\sigma(z) = \\frac{1}{1 + e^{-z}}\r\n\\]</span> sigmoid的输入为<span class=\"math inline\">\\(z\\)</span>\r\n，其输出为<span class=\"math inline\">\\((0,1)\\)</span>\r\n，可以表示分类为正样本的概率。</p>\r\n<p>二分类的交叉熵可以看作是交叉熵损失的一个特列，交叉熵为 <span\r\nclass=\"math display\">\\[\r\n\\text{$Cross\\_Entorpy$}(p,q) = -\\sum_i^m p(x_i) \\log q(x_i)\r\n\\]</span> 这里只有两个类别<span class=\"math inline\">\\(x \\in\r\n{x_1,x_2}\\)</span> ，则有 <span class=\"math display\">\\[\r\n\\begin{aligned}\\text{$Cross\\_Entorpy$}(p,q) &amp;= -(p(x_1) \\log q(x_1)\r\n+ p(x_2) \\log q(x_2)) \\end{aligned}\r\n\\]</span></p>\r\n<p>因为只有两个选择，则有<span class=\"math inline\">\\(p(x_1) + p(x_2) =\r\n1,q(x_1) + q(x_2) = 1\\)</span> 。设，训练样本中<span\r\nclass=\"math inline\">\\(x_1\\)</span>的概率为<span\r\nclass=\"math inline\">\\(p\\)</span>，则<span\r\nclass=\"math inline\">\\(x_2\\)</span>为<span\r\nclass=\"math inline\">\\(1-p\\)</span>; 预测的<span\r\nclass=\"math inline\">\\(x_1\\)</span>的概率为<span\r\nclass=\"math inline\">\\(q\\)</span>，则<span\r\nclass=\"math inline\">\\(x_2\\)</span>的预测概率为<span\r\nclass=\"math inline\">\\(1 - q\\)</span> 。则上式可改写为 <span\r\nclass=\"math display\">\\[\r\n\\text{$Cross\\_Entropy$}(p,q) = -(p \\log q + (1-p) \\log (1-q))\r\n\\]</span> 也就是二分类交叉熵的损失函数。</p>\r\n<h3 id=\"总结\">总结</h3>\r\n<p>相对熵可以用来度量两个分布相似性，假设分布<span\r\nclass=\"math inline\">\\(p\\)</span>是训练样本的分布，<span\r\nclass=\"math inline\">\\(q\\)</span>是预测得到的分布。分类训练的过程实际上就是最小化<span\r\nclass=\"math inline\">\\(D_{KL}(p \\parallel q)\\)</span>，由于由于交叉熵\r\n<span class=\"math display\">\\[\r\nH(p,q)= D_{KL}(p \\parallel q) + H(p)\r\n\\]</span> 其中,<span\r\nclass=\"math inline\">\\(H(p)\\)</span>是训练样本的熵，是一个已知的常量，这样最小化相对熵就等价于最小化交叉熵。</p>\r\n<p>从最大似然估计转化为最小化负对数似然 <span class=\"math display\">\\[\r\n\\theta_{ML} = -arg \\min_\\theta E_{x\\sim p}\\log q(x;\\theta)\r\n\\]</span> 也等价于最小化相对熵。</p>\r\n<h2 id=\"回归问题\">回归问题</h2>\r\n<p>回归：人们在测量事物的时候因为客观条件所限，求得的都是测量值，而不是事物真实的值，为了能够得到真实值，无限次的进行测量，最后通过这些测量数据计算<strong>回归到真实值</strong>，这就是回归的由来。</p>\r\n<p>回归分析的主要算法包括：</p>\r\n<ol type=\"1\">\r\n<li>线性回归(Linear Regression)</li>\r\n<li>逻辑回归（Logistic regressions）</li>\r\n<li>多项式回归(Polynomial Regression)</li>\r\n<li>逐步回归(Step Regression)</li>\r\n<li>岭回归(Ridge Regression)</li>\r\n<li>套索回归(Lasso Regression)</li>\r\n<li>弹性网回归(ElasticNet)</li>\r\n</ol>\r\n<h2 id=\"最大似然估计\">最大似然估计</h2>\r\n<p>wiki定义：<code>在统计学中，最大似然估计（英语：maximum likelihood estimation，简作MLE），也称极大似然估计，是用来估计一个概率模型的参数的一种方法。</code></p>\r\n<h3 id=\"原理\">原理</h3>\r\n<p>给定一个概率分布𝐷，已知其<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5qaC546H5a+G5bqm5Ye95pWw\">概率密度函数<i class=\"fa fa-external-link-alt\"></i></span>（连续分布）或<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5qaC546H6LSo6YeP5Ye95pWw\">概率质量函数<i class=\"fa fa-external-link-alt\"></i></span>（离散分布）为𝑓𝐷，以及一个分布参数𝜃，我们可以从这个分布中抽出一个具有𝑛个值的采样𝑋1,𝑋2,…,𝑋𝑛，利用𝑓𝐷计算出其<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Ly854S25Ye95pWw\">似然函数<i class=\"fa fa-external-link-alt\"></i></span>：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a9702eeec5a8eb416883af66665ac11bd8151f0f\"\r\nalt=\"{(x_{1},,x_{n})=f_{}(x_{1},,x_{n}).}\" />\r\n<figcaption\r\naria-hidden=\"true\">{(x_{1},,x_{n})=f_{}(x_{1},,x_{n}).}</figcaption>\r\n</figure>\r\n<p>若𝐷是离散分布，𝑓𝜃即是在参数为𝜃时观测到这一采样的概率；若其是连续分布，𝑓𝜃则为𝑋1,𝑋2,…,𝑋𝑛联合分布的概率密度函数在观测值处的取值。一旦我们获得𝑋1,𝑋2,…,𝑋𝑛，我们就能求得一个关于𝜃的估计。最大似然估计会寻找关于𝜃的最可能的值（即，在所有可能的𝜃取值中，寻找一个值使这个采样的“可能性”最大化）。从数学上来说，我们可以在𝜃的所有可能取值中寻找一个值使得似然<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Ye95pWw\">函数<i class=\"fa fa-external-link-alt\"></i></span>取到最大值。这个使可能性最大的<span\r\nclass=\"math display\">\\[\\hat\r\n𝜃\\]</span>值即称为𝜃的<strong>最大似然估计</strong>。由定义，最大似然估计是样本的函数。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5pyA5aSn5Ly854S25Lyw6K6h\">最大似然估计 -\r\n维基百科，自由的百科全书 (wikipedia.org)<i class=\"fa fa-external-link-alt\"></i></span></p>"},{"title":"MindSpore专题——第三章——张量","date":"2024-08-14T11:47:58.000Z","_content":"## 张量 Tensor\n\n​\t张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 $n$ 维空间内，有 $n^r$ 个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。$r$ 称为该张量的秩或阶（与矩阵的秩和阶均无关系）。\n\n<!--more-->\n\n​\t张量是一种特殊的数据结构，与数组和矩阵非常相似，他表示的是一种多维的“矩阵”的集合。张量（[Tensor](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.Tensor.html)）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。\n\n​\t*矩阵的秩或阶是人工智能中基础且常考的考点：一般形式是求矩阵秩是多少*\n\n下面是对张量在MindSpore中的实践\n\n### 创建张量\n\n1. **根据数据直接生成**\n\n```python\ndata = [1, 0, 1, 0]\nx_data = Tensor(data)\nprint(x_data, x_data.shape, x_data.dtype)\n```\n\n> [1 0 1 0] (4,) Int64\n\n2. **从NumPy数组生成**\n\n```python\nnp_array = np.array(data)\nx_np = Tensor(np_array)\nprint(x_np, x_np.shape, x_np.dtype)\n```\n\n> [1 0 1 0] (4,) Int64\n\n3. **使用init初始化器构造张量**\n\n​\t当使用`init`初始化器对张量进行初始化时，支持传入的参数有`init`、`shape`、`dtype`。\n\n   - `init`: 支持传入[initializer](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html)的子类。如：下方示例中的 [One()](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html#mindspore.common.initializer.One) 和 [Normal()](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html#mindspore.common.initializer.Normal)。\n\n  - `shape`: 支持传入 `list`、`tuple`、 `int`。\n\n  - `dtype`: 支持传入[mindspore.dtype](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.dtype.html#mindspore.dtype)。\n\n4. 继承张量并形成新的张量\n\n```python\nfrom mindspore import ops\n\nx_ones = ops.ones_like(x_data)\nprint(f\"Ones Tensor: \\n {x_ones} \\n\")\n\nx_zeros = ops.zeros_like(x_data)\nprint(f\"Zeros Tensor: \\n {x_zeros} \\n\")\n```\n\n### 张量的属性\n\n- 张量的属性包括形状、数据类型、转置张量、单个元素大小、占用字节数量、维数、元素个数和每一维步长。\n  - 形状（shape）：`Tensor`的shape，是一个tuple（元组，python中的数据类型标签）。\n  - 数据类型（dtype）：`Tensor`的dtype，是MindSpore的一个数据类型。\n  - 单个元素大小（itemsize）： `Tensor`中每一个元素占用字节数，是一个整数。\n  - 占用字节数量（nbytes）： `Tensor`占用的总字节数，是一个整数。\n  - 维数（ndim）： `Tensor`的秩，也就是len(tensor.shape)，是一个整数。\n  - 元素个数（size）： `Tensor`中所有元素的个数，是一个整数。\n  - 每一维步长（strides）： `Tensor`每一维所需要的字节数，是一个tuple。\n\n为更简单的理解shape的含义，我修改了一下官方文档中的x张量\n\n```python\nx = Tensor(np.array([[1, 2], [3, 4], [5, 6]]), mindspore.int32)\n\nprint(\"x_shape:\", x.shape)\nprint(\"x_dtype:\", x.dtype)\nprint(\"x_itemsize:\", x.itemsize)\nprint(\"x_nbytes:\", x.nbytes)\nprint(\"x_ndim:\", x.ndim)\nprint(\"x_size:\", x.size)\nprint(\"x_strides:\", x.strides)\n```\n\n> x_shape: (3, 2)\n> x_dtype: Int32\n> x_itemsize: 4\n> x_nbytes: 24\n> x_ndim: 2\n> x_size: 6\n> x_strides: (8, 4)\n\n### 张量的下标索引\n\nTensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号`:`和 `...`用于对数据进行切片。切片的意思是后面的参数是按行算的还是按列算的，详细请看代码\n\n```\ntensor = Tensor(np.array([[0, 1], [2, 3]]).astype(np.float32))\n\nprint(\"First row: {}\".format(tensor[0]))\nprint(\"value of bottom right corner: {}\".format(tensor[1, 1]))\nprint(\"Last column: {}\".format(tensor[:, -1]))\nprint(\"First column: {}\".format(tensor[..., 0]))\n```\n\n> First row: [0. 1.]\n> value of bottom right corner: 3.0\n> Last column: [1. 3.]\n> First column: [0. 2.]\n\n### 张量运算\n\n张量之间有很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，张量运算和NumPy的使用方式类似，下面介绍其中几种操作。\n\n> 普通算术运算有：加（+）、减（-）、乘（*）、除（/）、取模（%）、整除（//）。\n\n```python\nx = Tensor(np.array([1, 2, 3]), mindspore.float32)\ny = Tensor(np.array([4, 5, 6]), mindspore.float32)\n\noutput_add = x + y\noutput_sub = x - y\noutput_mul = x * y\noutput_div = y / x\noutput_mod = y % x\noutput_floordiv = y // x\n\nprint(\"add:\", output_add)\nprint(\"sub:\", output_sub)\nprint(\"mul:\", output_mul)\nprint(\"div:\", output_div)\nprint(\"mod:\", output_mod)\nprint(\"floordiv:\", output_floordiv)\n```\n\n> add: [5. 7. 9.]\n> sub: [-3. -3. -3.]\n> mul: [ 4. 10. 18.]\n> div: [4.  2.5 2. ]\n> mod: [0. 1. 0.]\n> floordiv: [4. 2. 2.]\n\n对于一些函数的使用，这里之贴出定义，详细运行库中代码（个人觉得没必要，知道这些函数即可，毕竟到处可见类似函数）\n\n[concat](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.concat.html)() : 将给定维度上的一系列张量连接起来，0表示最高得也就是直接通过`张量名[下标索引]`时的张量名所代表的元组。\n\n[stack](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.stack.html)()：则是从另一个维度上将两个张量合并起来。（新建一个维度）\n\n### Tensor与Numpy之间的相互转化\n\nTensor() : 将ndarray转化为Tensor\n\nasnumpy()：将Tensor转化为ndarray\n\n```python\nt = Tensor([1., 1., 1., 1., 1.])\nprint(f\"t: {t}\", type(t))\nn = t.asnumpy()\nprint(f\"n: {n}\", type(n))\n```\n\n> t: [1. 1. 1. 1. 1.] <class 'mindspore.common.tensor.Tensor'>\n> n: [1. 1. 1. 1. 1.] <class 'numpy.ndarray'>\n\n将NumPy变量转换为Tensor变量同样也不贴出来了，详情请运行本章代码对应部分查看\n\n有一个值得注意的点： \n\n当我们运行代码时调用了`np.add(n, 1, out=n)`函数，该函数**同时改变了我们的Numpy数据和Tensor数据**，这说明当我们进行转化时我们并没有创建新的变量，而是创建了新的变量指针。\n\n## 稀疏张量\n\n稀疏张量是一种特殊张量，其中绝大部分元素的值为零。\n\n在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。\n\n两种常用的稀疏张量格式\n\n1. CRS（Compressed Sparse Row）其中，非零元素的值存储在`values`中，非零元素的位置存储在`indptr`（行）和`indices`（列）中。\n2. COOCoordinate Format）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为`N`，被压缩的张量的维数为`ndims`。\n\n常用稀疏张量的表达形式是`<indices:Tensor, values:Tensor, shape:Tensor>`。其中，`indices`表示非零下标元素， `values`表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。在这个结构下，我们定义了三种稀疏张量结构：`CSRTensor`、`COOTensor`和`RowTensor`。\n\n### CSRTensor\n\n- `indptr`: 一维整数张量, 表示稀疏数据每一行的非零元素在`values`中的起始位置和终止位置, 索引数据类型支持int16、int32、int64。\n- `indices`: 一维整数张量，表示稀疏张量非零元素在列中的位置, 与`values`长度相等，索引数据类型支持int16、int32、int64。\n- `values`: 一维张量，表示`CSRTensor`相对应的非零元素的值，与`indices`长度相等。\n- `shape`: 表示被压缩的稀疏张量的形状，数据类型为`Tuple`，目前仅支持二维`CSRTensor`。\n\n### COOTensor\n\n- `indices`: 二维整数张量，每行代表非零元素下标。形状：`[N, ndims]`， 索引数据类型支持int16、int32、int64。\n- `values`: 一维张量，表示相对应的非零元素的值。形状：`[N]`。\n- `shape`: 表示被压缩的稀疏张量的形状，目前仅支持二维`COOTensor`。\n\n### 使用实例\n\n在源代码最后有CSRTensor、COOTensor的使用实例\n\n这里得给出代码，我做了一些修改，不然不好理解\n\n```python\n# CSRTensor 稀疏张量表实例\nindptr = Tensor([0, 1, 2])\nindices = Tensor([0, 1])\nvalues = Tensor([1, 2], dtype=mindspore.float32)\nshape = (2, 4)\n\n# Make a CSRTensor\ncsr_tensor = CSRTensor(indptr, indices, values, shape)\n\nprint(csr_tensor.astype(mindspore.float64).dtype)\n\nprint(csr_tensor)\n\nindices = Tensor([[0, 1], [1, 2]], dtype=mindspore.int32)\nvalues = Tensor([1, 2], dtype=mindspore.float32)\nshape = (3, 4)\n\n# Make a COOTensor\ncoo_tensor = COOTensor(indices, values, shape)\n\nprint(coo_tensor)\n\n```\n\n> Float64\n> CSRTensor(shape=[2, 4], \n>\n> dtype=Float32,\n>\n>  indptr=Tensor(shape=[3], dtype=Int64, value=[0 1 2]), \n>\n> indices=Tensor(shape=[2], dtype=Int64, value=[0 1]), \n>\n> values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))\n> COOTensor(shape=[3, 4], \n>\n> dtype=Float32, \n>\n> indices=Tensor(shape=[2, 2], dtype=Int32, value=[[0 1] [1 2]]), \n>\n> values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))\n\n其生成实例如下\n\nCSRTensor: \n$$\n\\begin{split}\\left[\n\\begin{matrix}\n  1 & 0 & 0 & 0 \\\\\n  0 & 2 & 0 & 0\n \\end{matrix}\n \\right]\\end{split}\n$$\nCOOTensor:\n$$\n\\begin{split}\\left[\n\\begin{matrix}\n  0 & 1 & 0 & 0 \\\\\n  0 & 0 & 2 & 0 \\\\\n  0 & 0 & 0 & 0\n \\end{matrix}\n \\right]\\end{split}\n$$\n\n- CSRTensor(indptr, indices, values, shape)： 构造一个CSR稀疏张量表\n- COOTensor(indices, values, shape) ：构造一个COO稀疏张量表\n\n理解不了CSR请参考:[MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.CSRTensor.html)\n\n理解不了COO请参考:[MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.COOTensor.html)\n","source":"_posts/special_subject/MindSpore/Chapters/Third_Tensor.md","raw":"---\ntitle: MindSpore专题——第三章——张量\ndate: 2024-08-14 19:47:58\ntags: [机器学习, MindSpore, 目录]\ncategories: \n\t- 专题\n\t- 机器学习\n\t- Mindspore\n\t- 基本概念\n---\n## 张量 Tensor\n\n​\t张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 $n$ 维空间内，有 $n^r$ 个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。$r$ 称为该张量的秩或阶（与矩阵的秩和阶均无关系）。\n\n<!--more-->\n\n​\t张量是一种特殊的数据结构，与数组和矩阵非常相似，他表示的是一种多维的“矩阵”的集合。张量（[Tensor](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.Tensor.html)）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。\n\n​\t*矩阵的秩或阶是人工智能中基础且常考的考点：一般形式是求矩阵秩是多少*\n\n下面是对张量在MindSpore中的实践\n\n### 创建张量\n\n1. **根据数据直接生成**\n\n```python\ndata = [1, 0, 1, 0]\nx_data = Tensor(data)\nprint(x_data, x_data.shape, x_data.dtype)\n```\n\n> [1 0 1 0] (4,) Int64\n\n2. **从NumPy数组生成**\n\n```python\nnp_array = np.array(data)\nx_np = Tensor(np_array)\nprint(x_np, x_np.shape, x_np.dtype)\n```\n\n> [1 0 1 0] (4,) Int64\n\n3. **使用init初始化器构造张量**\n\n​\t当使用`init`初始化器对张量进行初始化时，支持传入的参数有`init`、`shape`、`dtype`。\n\n   - `init`: 支持传入[initializer](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html)的子类。如：下方示例中的 [One()](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html#mindspore.common.initializer.One) 和 [Normal()](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore.common.initializer.html#mindspore.common.initializer.Normal)。\n\n  - `shape`: 支持传入 `list`、`tuple`、 `int`。\n\n  - `dtype`: 支持传入[mindspore.dtype](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.dtype.html#mindspore.dtype)。\n\n4. 继承张量并形成新的张量\n\n```python\nfrom mindspore import ops\n\nx_ones = ops.ones_like(x_data)\nprint(f\"Ones Tensor: \\n {x_ones} \\n\")\n\nx_zeros = ops.zeros_like(x_data)\nprint(f\"Zeros Tensor: \\n {x_zeros} \\n\")\n```\n\n### 张量的属性\n\n- 张量的属性包括形状、数据类型、转置张量、单个元素大小、占用字节数量、维数、元素个数和每一维步长。\n  - 形状（shape）：`Tensor`的shape，是一个tuple（元组，python中的数据类型标签）。\n  - 数据类型（dtype）：`Tensor`的dtype，是MindSpore的一个数据类型。\n  - 单个元素大小（itemsize）： `Tensor`中每一个元素占用字节数，是一个整数。\n  - 占用字节数量（nbytes）： `Tensor`占用的总字节数，是一个整数。\n  - 维数（ndim）： `Tensor`的秩，也就是len(tensor.shape)，是一个整数。\n  - 元素个数（size）： `Tensor`中所有元素的个数，是一个整数。\n  - 每一维步长（strides）： `Tensor`每一维所需要的字节数，是一个tuple。\n\n为更简单的理解shape的含义，我修改了一下官方文档中的x张量\n\n```python\nx = Tensor(np.array([[1, 2], [3, 4], [5, 6]]), mindspore.int32)\n\nprint(\"x_shape:\", x.shape)\nprint(\"x_dtype:\", x.dtype)\nprint(\"x_itemsize:\", x.itemsize)\nprint(\"x_nbytes:\", x.nbytes)\nprint(\"x_ndim:\", x.ndim)\nprint(\"x_size:\", x.size)\nprint(\"x_strides:\", x.strides)\n```\n\n> x_shape: (3, 2)\n> x_dtype: Int32\n> x_itemsize: 4\n> x_nbytes: 24\n> x_ndim: 2\n> x_size: 6\n> x_strides: (8, 4)\n\n### 张量的下标索引\n\nTensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号`:`和 `...`用于对数据进行切片。切片的意思是后面的参数是按行算的还是按列算的，详细请看代码\n\n```\ntensor = Tensor(np.array([[0, 1], [2, 3]]).astype(np.float32))\n\nprint(\"First row: {}\".format(tensor[0]))\nprint(\"value of bottom right corner: {}\".format(tensor[1, 1]))\nprint(\"Last column: {}\".format(tensor[:, -1]))\nprint(\"First column: {}\".format(tensor[..., 0]))\n```\n\n> First row: [0. 1.]\n> value of bottom right corner: 3.0\n> Last column: [1. 3.]\n> First column: [0. 2.]\n\n### 张量运算\n\n张量之间有很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，张量运算和NumPy的使用方式类似，下面介绍其中几种操作。\n\n> 普通算术运算有：加（+）、减（-）、乘（*）、除（/）、取模（%）、整除（//）。\n\n```python\nx = Tensor(np.array([1, 2, 3]), mindspore.float32)\ny = Tensor(np.array([4, 5, 6]), mindspore.float32)\n\noutput_add = x + y\noutput_sub = x - y\noutput_mul = x * y\noutput_div = y / x\noutput_mod = y % x\noutput_floordiv = y // x\n\nprint(\"add:\", output_add)\nprint(\"sub:\", output_sub)\nprint(\"mul:\", output_mul)\nprint(\"div:\", output_div)\nprint(\"mod:\", output_mod)\nprint(\"floordiv:\", output_floordiv)\n```\n\n> add: [5. 7. 9.]\n> sub: [-3. -3. -3.]\n> mul: [ 4. 10. 18.]\n> div: [4.  2.5 2. ]\n> mod: [0. 1. 0.]\n> floordiv: [4. 2. 2.]\n\n对于一些函数的使用，这里之贴出定义，详细运行库中代码（个人觉得没必要，知道这些函数即可，毕竟到处可见类似函数）\n\n[concat](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.concat.html)() : 将给定维度上的一系列张量连接起来，0表示最高得也就是直接通过`张量名[下标索引]`时的张量名所代表的元组。\n\n[stack](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/ops/mindspore.ops.stack.html)()：则是从另一个维度上将两个张量合并起来。（新建一个维度）\n\n### Tensor与Numpy之间的相互转化\n\nTensor() : 将ndarray转化为Tensor\n\nasnumpy()：将Tensor转化为ndarray\n\n```python\nt = Tensor([1., 1., 1., 1., 1.])\nprint(f\"t: {t}\", type(t))\nn = t.asnumpy()\nprint(f\"n: {n}\", type(n))\n```\n\n> t: [1. 1. 1. 1. 1.] <class 'mindspore.common.tensor.Tensor'>\n> n: [1. 1. 1. 1. 1.] <class 'numpy.ndarray'>\n\n将NumPy变量转换为Tensor变量同样也不贴出来了，详情请运行本章代码对应部分查看\n\n有一个值得注意的点： \n\n当我们运行代码时调用了`np.add(n, 1, out=n)`函数，该函数**同时改变了我们的Numpy数据和Tensor数据**，这说明当我们进行转化时我们并没有创建新的变量，而是创建了新的变量指针。\n\n## 稀疏张量\n\n稀疏张量是一种特殊张量，其中绝大部分元素的值为零。\n\n在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。\n\n两种常用的稀疏张量格式\n\n1. CRS（Compressed Sparse Row）其中，非零元素的值存储在`values`中，非零元素的位置存储在`indptr`（行）和`indices`（列）中。\n2. COOCoordinate Format）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为`N`，被压缩的张量的维数为`ndims`。\n\n常用稀疏张量的表达形式是`<indices:Tensor, values:Tensor, shape:Tensor>`。其中，`indices`表示非零下标元素， `values`表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。在这个结构下，我们定义了三种稀疏张量结构：`CSRTensor`、`COOTensor`和`RowTensor`。\n\n### CSRTensor\n\n- `indptr`: 一维整数张量, 表示稀疏数据每一行的非零元素在`values`中的起始位置和终止位置, 索引数据类型支持int16、int32、int64。\n- `indices`: 一维整数张量，表示稀疏张量非零元素在列中的位置, 与`values`长度相等，索引数据类型支持int16、int32、int64。\n- `values`: 一维张量，表示`CSRTensor`相对应的非零元素的值，与`indices`长度相等。\n- `shape`: 表示被压缩的稀疏张量的形状，数据类型为`Tuple`，目前仅支持二维`CSRTensor`。\n\n### COOTensor\n\n- `indices`: 二维整数张量，每行代表非零元素下标。形状：`[N, ndims]`， 索引数据类型支持int16、int32、int64。\n- `values`: 一维张量，表示相对应的非零元素的值。形状：`[N]`。\n- `shape`: 表示被压缩的稀疏张量的形状，目前仅支持二维`COOTensor`。\n\n### 使用实例\n\n在源代码最后有CSRTensor、COOTensor的使用实例\n\n这里得给出代码，我做了一些修改，不然不好理解\n\n```python\n# CSRTensor 稀疏张量表实例\nindptr = Tensor([0, 1, 2])\nindices = Tensor([0, 1])\nvalues = Tensor([1, 2], dtype=mindspore.float32)\nshape = (2, 4)\n\n# Make a CSRTensor\ncsr_tensor = CSRTensor(indptr, indices, values, shape)\n\nprint(csr_tensor.astype(mindspore.float64).dtype)\n\nprint(csr_tensor)\n\nindices = Tensor([[0, 1], [1, 2]], dtype=mindspore.int32)\nvalues = Tensor([1, 2], dtype=mindspore.float32)\nshape = (3, 4)\n\n# Make a COOTensor\ncoo_tensor = COOTensor(indices, values, shape)\n\nprint(coo_tensor)\n\n```\n\n> Float64\n> CSRTensor(shape=[2, 4], \n>\n> dtype=Float32,\n>\n>  indptr=Tensor(shape=[3], dtype=Int64, value=[0 1 2]), \n>\n> indices=Tensor(shape=[2], dtype=Int64, value=[0 1]), \n>\n> values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))\n> COOTensor(shape=[3, 4], \n>\n> dtype=Float32, \n>\n> indices=Tensor(shape=[2, 2], dtype=Int32, value=[[0 1] [1 2]]), \n>\n> values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))\n\n其生成实例如下\n\nCSRTensor: \n$$\n\\begin{split}\\left[\n\\begin{matrix}\n  1 & 0 & 0 & 0 \\\\\n  0 & 2 & 0 & 0\n \\end{matrix}\n \\right]\\end{split}\n$$\nCOOTensor:\n$$\n\\begin{split}\\left[\n\\begin{matrix}\n  0 & 1 & 0 & 0 \\\\\n  0 & 0 & 2 & 0 \\\\\n  0 & 0 & 0 & 0\n \\end{matrix}\n \\right]\\end{split}\n$$\n\n- CSRTensor(indptr, indices, values, shape)： 构造一个CSR稀疏张量表\n- COOTensor(indices, values, shape) ：构造一个COO稀疏张量表\n\n理解不了CSR请参考:[MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.CSRTensor.html)\n\n理解不了COO请参考:[MindSpore](https://www.mindspore.cn/docs/zh-CN/r2.2/api_python/mindspore/mindspore.COOTensor.html)\n","slug":"special_subject/MindSpore/Chapters/Third_Tensor","published":1,"updated":"2024-08-16T08:59:14.447Z","_id":"clzwh7bb800an2wwvfe57494z","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"张量-tensor\">张量 Tensor</h2>\r\n<p>​\r\n张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 <span\r\nclass=\"math inline\">\\(n\\)</span> 维空间内，有 <span\r\nclass=\"math inline\">\\(n^r\\)</span>\r\n个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。<span\r\nclass=\"math inline\">\\(r\\)</span>\r\n称为该张量的秩或阶（与矩阵的秩和阶均无关系）。</p>\r\n<span id=\"more\"></span>\r\n<p>​\r\n张量是一种特殊的数据结构，与数组和矩阵非常相似，他表示的是一种多维的“矩阵”的集合。张量（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuVGVuc29yLmh0bWw=\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。</p>\r\n<p>​\r\n<em>矩阵的秩或阶是人工智能中基础且常考的考点：一般形式是求矩阵秩是多少</em></p>\r\n<p>下面是对张量在MindSpore中的实践</p>\r\n<h3 id=\"创建张量\">创建张量</h3>\r\n<ol type=\"1\">\r\n<li><strong>根据数据直接生成</strong></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">x_data = Tensor(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_data, x_data.shape, x_data.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[1 0 1 0] (4,) Int64</p>\r\n</blockquote>\r\n<ol start=\"2\" type=\"1\">\r\n<li><strong>从NumPy数组生成</strong></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np_array = np.array(data)</span><br><span class=\"line\">x_np = Tensor(np_array)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_np, x_np.shape, x_np.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[1 0 1 0] (4,) Int64</p>\r\n</blockquote>\r\n<ol start=\"3\" type=\"1\">\r\n<li><strong>使用init初始化器构造张量</strong></li>\r\n</ol>\r\n<p>​\r\n当使用<code>init</code>初始化器对张量进行初始化时，支持传入的参数有<code>init</code>、<code>shape</code>、<code>dtype</code>。</p>\r\n<ul>\r\n<li><p><code>init</code>: 支持传入<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbA==\">initializer<i class=\"fa fa-external-link-alt\"></i></span>的子类。如：下方示例中的\r\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbCNtaW5kc3BvcmUuY29tbW9uLmluaXRpYWxpemVyLk9uZQ==\">One()<i class=\"fa fa-external-link-alt\"></i></span>\r\n和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbCNtaW5kc3BvcmUuY29tbW9uLmluaXRpYWxpemVyLk5vcm1hbA==\">Normal()<i class=\"fa fa-external-link-alt\"></i></span>。</p></li>\r\n<li><p><code>shape</code>: 支持传入\r\n<code>list</code>、<code>tuple</code>、 <code>int</code>。</p></li>\r\n<li><p><code>dtype</code>: 支持传入<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZHR5cGUuaHRtbCNtaW5kc3BvcmUuZHR5cGU=\">mindspore.dtype<i class=\"fa fa-external-link-alt\"></i></span>。</p></li>\r\n</ul>\r\n<ol start=\"4\" type=\"1\">\r\n<li>继承张量并形成新的张量</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> mindspore <span class=\"keyword\">import</span> ops</span><br><span class=\"line\"></span><br><span class=\"line\">x_ones = ops.ones_like(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Ones Tensor: \\n <span class=\"subst\">&#123;x_ones&#125;</span> \\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">x_zeros = ops.zeros_like(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Zeros Tensor: \\n <span class=\"subst\">&#123;x_zeros&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"张量的属性\">张量的属性</h3>\r\n<ul>\r\n<li>张量的属性包括形状、数据类型、转置张量、单个元素大小、占用字节数量、维数、元素个数和每一维步长。\r\n<ul>\r\n<li>形状（shape）：<code>Tensor</code>的shape，是一个tuple（元组，python中的数据类型标签）。</li>\r\n<li>数据类型（dtype）：<code>Tensor</code>的dtype，是MindSpore的一个数据类型。</li>\r\n<li>单个元素大小（itemsize）：\r\n<code>Tensor</code>中每一个元素占用字节数，是一个整数。</li>\r\n<li>占用字节数量（nbytes）：\r\n<code>Tensor</code>占用的总字节数，是一个整数。</li>\r\n<li>维数（ndim）：\r\n<code>Tensor</code>的秩，也就是len(tensor.shape)，是一个整数。</li>\r\n<li>元素个数（size）：\r\n<code>Tensor</code>中所有元素的个数，是一个整数。</li>\r\n<li>每一维步长（strides）：\r\n<code>Tensor</code>每一维所需要的字节数，是一个tuple。</li>\r\n</ul></li>\r\n</ul>\r\n<p>为更简单的理解shape的含义，我修改了一下官方文档中的x张量</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = Tensor(np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">5</span>, <span class=\"number\">6</span>]]), mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_shape:&quot;</span>, x.shape)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_dtype:&quot;</span>, x.dtype)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_itemsize:&quot;</span>, x.itemsize)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_nbytes:&quot;</span>, x.nbytes)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_ndim:&quot;</span>, x.ndim)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_size:&quot;</span>, x.size)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_strides:&quot;</span>, x.strides)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>x_shape: (3, 2) x_dtype: Int32 x_itemsize: 4 x_nbytes: 24 x_ndim: 2\r\nx_size: 6 x_strides: (8, 4)</p>\r\n</blockquote>\r\n<h3 id=\"张量的下标索引\">张量的下标索引</h3>\r\n<p>Tensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号<code>:</code>和\r\n<code>...</code>用于对数据进行切片。切片的意思是后面的参数是按行算的还是按列算的，详细请看代码</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tensor = Tensor(np.array([[0, 1], [2, 3]]).astype(np.float32))</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;First row: &#123;&#125;&quot;.format(tensor[0]))</span><br><span class=\"line\">print(&quot;value of bottom right corner: &#123;&#125;&quot;.format(tensor[1, 1]))</span><br><span class=\"line\">print(&quot;Last column: &#123;&#125;&quot;.format(tensor[:, -1]))</span><br><span class=\"line\">print(&quot;First column: &#123;&#125;&quot;.format(tensor[..., 0]))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>First row: [0. 1.] value of bottom right corner: 3.0 Last column: [1.\r\n3.] First column: [0. 2.]</p>\r\n</blockquote>\r\n<h3 id=\"张量运算\">张量运算</h3>\r\n<p>张量之间有很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，张量运算和NumPy的使用方式类似，下面介绍其中几种操作。</p>\r\n<blockquote>\r\n<p>普通算术运算有：加（+）、减（-）、乘（*）、除（/）、取模（%）、整除（//）。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = Tensor(np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]), mindspore.float32)</span><br><span class=\"line\">y = Tensor(np.array([<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]), mindspore.float32)</span><br><span class=\"line\"></span><br><span class=\"line\">output_add = x + y</span><br><span class=\"line\">output_sub = x - y</span><br><span class=\"line\">output_mul = x * y</span><br><span class=\"line\">output_div = y / x</span><br><span class=\"line\">output_mod = y % x</span><br><span class=\"line\">output_floordiv = y // x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;add:&quot;</span>, output_add)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;sub:&quot;</span>, output_sub)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;mul:&quot;</span>, output_mul)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;div:&quot;</span>, output_div)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;mod:&quot;</span>, output_mod)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;floordiv:&quot;</span>, output_floordiv)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>add: [5. 7. 9.] sub: [-3. -3. -3.] mul: [ 4. 10. 18.] div: [4. 2.5 2.\r\n] mod: [0. 1. 0.] floordiv: [4. 2. 2.]</p>\r\n</blockquote>\r\n<p>对于一些函数的使用，这里之贴出定义，详细运行库中代码（个人觉得没必要，知道这些函数即可，毕竟到处可见类似函数）</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLmNvbmNhdC5odG1s\">concat<i class=\"fa fa-external-link-alt\"></i></span>()\r\n:\r\n将给定维度上的一系列张量连接起来，0表示最高得也就是直接通过<code>张量名[下标索引]</code>时的张量名所代表的元组。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLnN0YWNrLmh0bWw=\">stack<i class=\"fa fa-external-link-alt\"></i></span>()：则是从另一个维度上将两个张量合并起来。（新建一个维度）</p>\r\n<h3 id=\"tensor与numpy之间的相互转化\">Tensor与Numpy之间的相互转化</h3>\r\n<p>Tensor() : 将ndarray转化为Tensor</p>\r\n<p>asnumpy()：将Tensor转化为ndarray</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = Tensor([<span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;t: <span class=\"subst\">&#123;t&#125;</span>&quot;</span>, <span class=\"built_in\">type</span>(t))</span><br><span class=\"line\">n = t.asnumpy()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;n: <span class=\"subst\">&#123;n&#125;</span>&quot;</span>, <span class=\"built_in\">type</span>(n))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>t: [1. 1. 1. 1. 1.] &lt;class 'mindspore.common.tensor.Tensor'&gt; n:\r\n[1. 1. 1. 1. 1.] &lt;class 'numpy.ndarray'&gt;</p>\r\n</blockquote>\r\n<p>将NumPy变量转换为Tensor变量同样也不贴出来了，详情请运行本章代码对应部分查看</p>\r\n<p>有一个值得注意的点：</p>\r\n<p>当我们运行代码时调用了<code>np.add(n, 1, out=n)</code>函数，该函数<strong>同时改变了我们的Numpy数据和Tensor数据</strong>，这说明当我们进行转化时我们并没有创建新的变量，而是创建了新的变量指针。</p>\r\n<h2 id=\"稀疏张量\">稀疏张量</h2>\r\n<p>稀疏张量是一种特殊张量，其中绝大部分元素的值为零。</p>\r\n<p>在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。</p>\r\n<p>两种常用的稀疏张量格式</p>\r\n<ol type=\"1\">\r\n<li>CRS（Compressed Sparse\r\nRow）其中，非零元素的值存储在<code>values</code>中，非零元素的位置存储在<code>indptr</code>（行）和<code>indices</code>（列）中。</li>\r\n<li>COOCoordinate\r\nFormat）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为<code>N</code>，被压缩的张量的维数为<code>ndims</code>。</li>\r\n</ol>\r\n<p>常用稀疏张量的表达形式是<code>&lt;indices:Tensor, values:Tensor, shape:Tensor&gt;</code>。其中，<code>indices</code>表示非零下标元素，\r\n<code>values</code>表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。在这个结构下，我们定义了三种稀疏张量结构：<code>CSRTensor</code>、<code>COOTensor</code>和<code>RowTensor</code>。</p>\r\n<h3 id=\"csrtensor\">CSRTensor</h3>\r\n<ul>\r\n<li><code>indptr</code>: 一维整数张量,\r\n表示稀疏数据每一行的非零元素在<code>values</code>中的起始位置和终止位置,\r\n索引数据类型支持int16、int32、int64。</li>\r\n<li><code>indices</code>:\r\n一维整数张量，表示稀疏张量非零元素在列中的位置,\r\n与<code>values</code>长度相等，索引数据类型支持int16、int32、int64。</li>\r\n<li><code>values</code>:\r\n一维张量，表示<code>CSRTensor</code>相对应的非零元素的值，与<code>indices</code>长度相等。</li>\r\n<li><code>shape</code>:\r\n表示被压缩的稀疏张量的形状，数据类型为<code>Tuple</code>，目前仅支持二维<code>CSRTensor</code>。</li>\r\n</ul>\r\n<h3 id=\"cootensor\">COOTensor</h3>\r\n<ul>\r\n<li><code>indices</code>:\r\n二维整数张量，每行代表非零元素下标。形状：<code>[N, ndims]</code>，\r\n索引数据类型支持int16、int32、int64。</li>\r\n<li><code>values</code>:\r\n一维张量，表示相对应的非零元素的值。形状：<code>[N]</code>。</li>\r\n<li><code>shape</code>:\r\n表示被压缩的稀疏张量的形状，目前仅支持二维<code>COOTensor</code>。</li>\r\n</ul>\r\n<h3 id=\"使用实例\">使用实例</h3>\r\n<p>在源代码最后有CSRTensor、COOTensor的使用实例</p>\r\n<p>这里得给出代码，我做了一些修改，不然不好理解</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CSRTensor 稀疏张量表实例</span></span><br><span class=\"line\">indptr = Tensor([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\">indices = Tensor([<span class=\"number\">0</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\">values = Tensor([<span class=\"number\">1</span>, <span class=\"number\">2</span>], dtype=mindspore.float32)</span><br><span class=\"line\">shape = (<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Make a CSRTensor</span></span><br><span class=\"line\">csr_tensor = CSRTensor(indptr, indices, values, shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(csr_tensor.astype(mindspore.float64).dtype)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(csr_tensor)</span><br><span class=\"line\"></span><br><span class=\"line\">indices = Tensor([[<span class=\"number\">0</span>, <span class=\"number\">1</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>]], dtype=mindspore.int32)</span><br><span class=\"line\">values = Tensor([<span class=\"number\">1</span>, <span class=\"number\">2</span>], dtype=mindspore.float32)</span><br><span class=\"line\">shape = (<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Make a COOTensor</span></span><br><span class=\"line\">coo_tensor = COOTensor(indices, values, shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(coo_tensor)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Float64 CSRTensor(shape=[2, 4],</p>\r\n<p>dtype=Float32,</p>\r\n<p>indptr=Tensor(shape=[3], dtype=Int64, value=[0 1 2]),</p>\r\n<p>indices=Tensor(shape=[2], dtype=Int64, value=[0 1]),</p>\r\n<p>values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00\r\n2.00000000e+00])) COOTensor(shape=[3, 4],</p>\r\n<p>dtype=Float32,</p>\r\n<p>indices=Tensor(shape=[2, 2], dtype=Int32, value=[[0 1] [1 2]]),</p>\r\n<p>values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00\r\n2.00000000e+00]))</p>\r\n</blockquote>\r\n<p>其生成实例如下</p>\r\n<p>CSRTensor: <span class=\"math display\">\\[\r\n\\begin{split}\\left[\r\n\\begin{matrix}\r\n  1 &amp; 0 &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 2 &amp; 0 &amp; 0\r\n\\end{matrix}\r\n\\right]\\end{split}\r\n\\]</span> COOTensor: <span class=\"math display\">\\[\r\n\\begin{split}\\left[\r\n\\begin{matrix}\r\n  0 &amp; 1 &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 2 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 0 &amp; 0\r\n\\end{matrix}\r\n\\right]\\end{split}\r\n\\]</span></p>\r\n<ul>\r\n<li>CSRTensor(indptr, indices, values, shape)：\r\n构造一个CSR稀疏张量表</li>\r\n<li>COOTensor(indices, values, shape) ：构造一个COO稀疏张量表</li>\r\n</ul>\r\n<p>理解不了CSR请参考:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuQ1NSVGVuc29yLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>理解不了COO请参考:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuQ09PVGVuc29yLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n","length":2017,"excerpt":"<h2 id=\"张量-tensor\">张量 Tensor</h2>\r\n<p>​\r\n张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 <span\r\nclass=\"math inline\">\\(n\\)</span> 维空间内，有 <span\r\nclass=\"math inline\">\\(n^r\\)</span>\r\n个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。<span\r\nclass=\"math inline\">\\(r\\)</span>\r\n称为该张量的秩或阶（与矩阵的秩和阶均无关系）。</p>","more":"<p>​\r\n张量是一种特殊的数据结构，与数组和矩阵非常相似，他表示的是一种多维的“矩阵”的集合。张量（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuVGVuc29yLmh0bWw=\">Tensor<i class=\"fa fa-external-link-alt\"></i></span>）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。</p>\r\n<p>​\r\n<em>矩阵的秩或阶是人工智能中基础且常考的考点：一般形式是求矩阵秩是多少</em></p>\r\n<p>下面是对张量在MindSpore中的实践</p>\r\n<h3 id=\"创建张量\">创建张量</h3>\r\n<ol type=\"1\">\r\n<li><strong>根据数据直接生成</strong></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">x_data = Tensor(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_data, x_data.shape, x_data.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[1 0 1 0] (4,) Int64</p>\r\n</blockquote>\r\n<ol start=\"2\" type=\"1\">\r\n<li><strong>从NumPy数组生成</strong></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np_array = np.array(data)</span><br><span class=\"line\">x_np = Tensor(np_array)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_np, x_np.shape, x_np.dtype)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>[1 0 1 0] (4,) Int64</p>\r\n</blockquote>\r\n<ol start=\"3\" type=\"1\">\r\n<li><strong>使用init初始化器构造张量</strong></li>\r\n</ol>\r\n<p>​\r\n当使用<code>init</code>初始化器对张量进行初始化时，支持传入的参数有<code>init</code>、<code>shape</code>、<code>dtype</code>。</p>\r\n<ul>\r\n<li><p><code>init</code>: 支持传入<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbA==\">initializer<i class=\"fa fa-external-link-alt\"></i></span>的子类。如：下方示例中的\r\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbCNtaW5kc3BvcmUuY29tbW9uLmluaXRpYWxpemVyLk9uZQ==\">One()<i class=\"fa fa-external-link-alt\"></i></span>\r\n和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbCNtaW5kc3BvcmUuY29tbW9uLmluaXRpYWxpemVyLk5vcm1hbA==\">Normal()<i class=\"fa fa-external-link-alt\"></i></span>。</p></li>\r\n<li><p><code>shape</code>: 支持传入\r\n<code>list</code>、<code>tuple</code>、 <code>int</code>。</p></li>\r\n<li><p><code>dtype</code>: 支持传入<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZHR5cGUuaHRtbCNtaW5kc3BvcmUuZHR5cGU=\">mindspore.dtype<i class=\"fa fa-external-link-alt\"></i></span>。</p></li>\r\n</ul>\r\n<ol start=\"4\" type=\"1\">\r\n<li>继承张量并形成新的张量</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> mindspore <span class=\"keyword\">import</span> ops</span><br><span class=\"line\"></span><br><span class=\"line\">x_ones = ops.ones_like(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Ones Tensor: \\n <span class=\"subst\">&#123;x_ones&#125;</span> \\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">x_zeros = ops.zeros_like(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Zeros Tensor: \\n <span class=\"subst\">&#123;x_zeros&#125;</span> \\n&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"张量的属性\">张量的属性</h3>\r\n<ul>\r\n<li>张量的属性包括形状、数据类型、转置张量、单个元素大小、占用字节数量、维数、元素个数和每一维步长。\r\n<ul>\r\n<li>形状（shape）：<code>Tensor</code>的shape，是一个tuple（元组，python中的数据类型标签）。</li>\r\n<li>数据类型（dtype）：<code>Tensor</code>的dtype，是MindSpore的一个数据类型。</li>\r\n<li>单个元素大小（itemsize）：\r\n<code>Tensor</code>中每一个元素占用字节数，是一个整数。</li>\r\n<li>占用字节数量（nbytes）：\r\n<code>Tensor</code>占用的总字节数，是一个整数。</li>\r\n<li>维数（ndim）：\r\n<code>Tensor</code>的秩，也就是len(tensor.shape)，是一个整数。</li>\r\n<li>元素个数（size）：\r\n<code>Tensor</code>中所有元素的个数，是一个整数。</li>\r\n<li>每一维步长（strides）：\r\n<code>Tensor</code>每一维所需要的字节数，是一个tuple。</li>\r\n</ul></li>\r\n</ul>\r\n<p>为更简单的理解shape的含义，我修改了一下官方文档中的x张量</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = Tensor(np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">5</span>, <span class=\"number\">6</span>]]), mindspore.int32)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_shape:&quot;</span>, x.shape)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_dtype:&quot;</span>, x.dtype)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_itemsize:&quot;</span>, x.itemsize)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_nbytes:&quot;</span>, x.nbytes)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_ndim:&quot;</span>, x.ndim)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_size:&quot;</span>, x.size)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x_strides:&quot;</span>, x.strides)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>x_shape: (3, 2) x_dtype: Int32 x_itemsize: 4 x_nbytes: 24 x_ndim: 2\r\nx_size: 6 x_strides: (8, 4)</p>\r\n</blockquote>\r\n<h3 id=\"张量的下标索引\">张量的下标索引</h3>\r\n<p>Tensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号<code>:</code>和\r\n<code>...</code>用于对数据进行切片。切片的意思是后面的参数是按行算的还是按列算的，详细请看代码</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tensor = Tensor(np.array([[0, 1], [2, 3]]).astype(np.float32))</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;First row: &#123;&#125;&quot;.format(tensor[0]))</span><br><span class=\"line\">print(&quot;value of bottom right corner: &#123;&#125;&quot;.format(tensor[1, 1]))</span><br><span class=\"line\">print(&quot;Last column: &#123;&#125;&quot;.format(tensor[:, -1]))</span><br><span class=\"line\">print(&quot;First column: &#123;&#125;&quot;.format(tensor[..., 0]))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>First row: [0. 1.] value of bottom right corner: 3.0 Last column: [1.\r\n3.] First column: [0. 2.]</p>\r\n</blockquote>\r\n<h3 id=\"张量运算\">张量运算</h3>\r\n<p>张量之间有很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，张量运算和NumPy的使用方式类似，下面介绍其中几种操作。</p>\r\n<blockquote>\r\n<p>普通算术运算有：加（+）、减（-）、乘（*）、除（/）、取模（%）、整除（//）。</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = Tensor(np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]), mindspore.float32)</span><br><span class=\"line\">y = Tensor(np.array([<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]), mindspore.float32)</span><br><span class=\"line\"></span><br><span class=\"line\">output_add = x + y</span><br><span class=\"line\">output_sub = x - y</span><br><span class=\"line\">output_mul = x * y</span><br><span class=\"line\">output_div = y / x</span><br><span class=\"line\">output_mod = y % x</span><br><span class=\"line\">output_floordiv = y // x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;add:&quot;</span>, output_add)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;sub:&quot;</span>, output_sub)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;mul:&quot;</span>, output_mul)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;div:&quot;</span>, output_div)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;mod:&quot;</span>, output_mod)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;floordiv:&quot;</span>, output_floordiv)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>add: [5. 7. 9.] sub: [-3. -3. -3.] mul: [ 4. 10. 18.] div: [4. 2.5 2.\r\n] mod: [0. 1. 0.] floordiv: [4. 2. 2.]</p>\r\n</blockquote>\r\n<p>对于一些函数的使用，这里之贴出定义，详细运行库中代码（个人觉得没必要，知道这些函数即可，毕竟到处可见类似函数）</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLmNvbmNhdC5odG1s\">concat<i class=\"fa fa-external-link-alt\"></i></span>()\r\n:\r\n将给定维度上的一系列张量连接起来，0表示最高得也就是直接通过<code>张量名[下标索引]</code>时的张量名所代表的元组。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLnN0YWNrLmh0bWw=\">stack<i class=\"fa fa-external-link-alt\"></i></span>()：则是从另一个维度上将两个张量合并起来。（新建一个维度）</p>\r\n<h3 id=\"tensor与numpy之间的相互转化\">Tensor与Numpy之间的相互转化</h3>\r\n<p>Tensor() : 将ndarray转化为Tensor</p>\r\n<p>asnumpy()：将Tensor转化为ndarray</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = Tensor([<span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;t: <span class=\"subst\">&#123;t&#125;</span>&quot;</span>, <span class=\"built_in\">type</span>(t))</span><br><span class=\"line\">n = t.asnumpy()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;n: <span class=\"subst\">&#123;n&#125;</span>&quot;</span>, <span class=\"built_in\">type</span>(n))</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>t: [1. 1. 1. 1. 1.] &lt;class 'mindspore.common.tensor.Tensor'&gt; n:\r\n[1. 1. 1. 1. 1.] &lt;class 'numpy.ndarray'&gt;</p>\r\n</blockquote>\r\n<p>将NumPy变量转换为Tensor变量同样也不贴出来了，详情请运行本章代码对应部分查看</p>\r\n<p>有一个值得注意的点：</p>\r\n<p>当我们运行代码时调用了<code>np.add(n, 1, out=n)</code>函数，该函数<strong>同时改变了我们的Numpy数据和Tensor数据</strong>，这说明当我们进行转化时我们并没有创建新的变量，而是创建了新的变量指针。</p>\r\n<h2 id=\"稀疏张量\">稀疏张量</h2>\r\n<p>稀疏张量是一种特殊张量，其中绝大部分元素的值为零。</p>\r\n<p>在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。</p>\r\n<p>两种常用的稀疏张量格式</p>\r\n<ol type=\"1\">\r\n<li>CRS（Compressed Sparse\r\nRow）其中，非零元素的值存储在<code>values</code>中，非零元素的位置存储在<code>indptr</code>（行）和<code>indices</code>（列）中。</li>\r\n<li>COOCoordinate\r\nFormat）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为<code>N</code>，被压缩的张量的维数为<code>ndims</code>。</li>\r\n</ol>\r\n<p>常用稀疏张量的表达形式是<code>&lt;indices:Tensor, values:Tensor, shape:Tensor&gt;</code>。其中，<code>indices</code>表示非零下标元素，\r\n<code>values</code>表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。在这个结构下，我们定义了三种稀疏张量结构：<code>CSRTensor</code>、<code>COOTensor</code>和<code>RowTensor</code>。</p>\r\n<h3 id=\"csrtensor\">CSRTensor</h3>\r\n<ul>\r\n<li><code>indptr</code>: 一维整数张量,\r\n表示稀疏数据每一行的非零元素在<code>values</code>中的起始位置和终止位置,\r\n索引数据类型支持int16、int32、int64。</li>\r\n<li><code>indices</code>:\r\n一维整数张量，表示稀疏张量非零元素在列中的位置,\r\n与<code>values</code>长度相等，索引数据类型支持int16、int32、int64。</li>\r\n<li><code>values</code>:\r\n一维张量，表示<code>CSRTensor</code>相对应的非零元素的值，与<code>indices</code>长度相等。</li>\r\n<li><code>shape</code>:\r\n表示被压缩的稀疏张量的形状，数据类型为<code>Tuple</code>，目前仅支持二维<code>CSRTensor</code>。</li>\r\n</ul>\r\n<h3 id=\"cootensor\">COOTensor</h3>\r\n<ul>\r\n<li><code>indices</code>:\r\n二维整数张量，每行代表非零元素下标。形状：<code>[N, ndims]</code>，\r\n索引数据类型支持int16、int32、int64。</li>\r\n<li><code>values</code>:\r\n一维张量，表示相对应的非零元素的值。形状：<code>[N]</code>。</li>\r\n<li><code>shape</code>:\r\n表示被压缩的稀疏张量的形状，目前仅支持二维<code>COOTensor</code>。</li>\r\n</ul>\r\n<h3 id=\"使用实例\">使用实例</h3>\r\n<p>在源代码最后有CSRTensor、COOTensor的使用实例</p>\r\n<p>这里得给出代码，我做了一些修改，不然不好理解</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CSRTensor 稀疏张量表实例</span></span><br><span class=\"line\">indptr = Tensor([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\">indices = Tensor([<span class=\"number\">0</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\">values = Tensor([<span class=\"number\">1</span>, <span class=\"number\">2</span>], dtype=mindspore.float32)</span><br><span class=\"line\">shape = (<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Make a CSRTensor</span></span><br><span class=\"line\">csr_tensor = CSRTensor(indptr, indices, values, shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(csr_tensor.astype(mindspore.float64).dtype)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(csr_tensor)</span><br><span class=\"line\"></span><br><span class=\"line\">indices = Tensor([[<span class=\"number\">0</span>, <span class=\"number\">1</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>]], dtype=mindspore.int32)</span><br><span class=\"line\">values = Tensor([<span class=\"number\">1</span>, <span class=\"number\">2</span>], dtype=mindspore.float32)</span><br><span class=\"line\">shape = (<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Make a COOTensor</span></span><br><span class=\"line\">coo_tensor = COOTensor(indices, values, shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(coo_tensor)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Float64 CSRTensor(shape=[2, 4],</p>\r\n<p>dtype=Float32,</p>\r\n<p>indptr=Tensor(shape=[3], dtype=Int64, value=[0 1 2]),</p>\r\n<p>indices=Tensor(shape=[2], dtype=Int64, value=[0 1]),</p>\r\n<p>values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00\r\n2.00000000e+00])) COOTensor(shape=[3, 4],</p>\r\n<p>dtype=Float32,</p>\r\n<p>indices=Tensor(shape=[2, 2], dtype=Int32, value=[[0 1] [1 2]]),</p>\r\n<p>values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00\r\n2.00000000e+00]))</p>\r\n</blockquote>\r\n<p>其生成实例如下</p>\r\n<p>CSRTensor: <span class=\"math display\">\\[\r\n\\begin{split}\\left[\r\n\\begin{matrix}\r\n  1 &amp; 0 &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 2 &amp; 0 &amp; 0\r\n\\end{matrix}\r\n\\right]\\end{split}\r\n\\]</span> COOTensor: <span class=\"math display\">\\[\r\n\\begin{split}\\left[\r\n\\begin{matrix}\r\n  0 &amp; 1 &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 2 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 0 &amp; 0\r\n\\end{matrix}\r\n\\right]\\end{split}\r\n\\]</span></p>\r\n<ul>\r\n<li>CSRTensor(indptr, indices, values, shape)：\r\n构造一个CSR稀疏张量表</li>\r\n<li>COOTensor(indices, values, shape) ：构造一个COO稀疏张量表</li>\r\n</ul>\r\n<p>理解不了CSR请参考:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuQ1NSVGVuc29yLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>理解不了COO请参考:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuQ09PVGVuc29yLmh0bWw=\">MindSpore<i class=\"fa fa-external-link-alt\"></i></span></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"clzwh7b9p00092wwv8bw92d9u","category_id":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7ba9002d2wwv187i1wyo"},{"post_id":"clzwh7b9p00092wwv8bw92d9u","category_id":"clzwh7b9v000o2wwv1v1tdkmt","_id":"clzwh7ba9002f2wwv1h1f5n2g"},{"post_id":"clzwh7b9p00092wwv8bw92d9u","category_id":"clzwh7ba700222wwvhrbe0s2c","_id":"clzwh7baa002h2wwv4ib25q2g"},{"post_id":"clzwh7b9i00012wwv3676e6cu","category_id":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7baa002o2wwvd15me06e"},{"post_id":"clzwh7b9i00012wwv3676e6cu","category_id":"clzwh7b9v000o2wwv1v1tdkmt","_id":"clzwh7bab002p2wwvearaako0"},{"post_id":"clzwh7b9i00012wwv3676e6cu","category_id":"clzwh7baa002i2wwv0cnj4h1b","_id":"clzwh7bab002s2wwv1apm7v2d"},{"post_id":"clzwh7b9q000b2wwv6gficzyi","category_id":"clzwh7b9x000y2wwv89nw77g9","_id":"clzwh7bab00312wwvc276hug9"},{"post_id":"clzwh7b9q000b2wwv6gficzyi","category_id":"clzwh7bab002r2wwv91exfqcs","_id":"clzwh7bac00322wwv5a1nb2q6"},{"post_id":"clzwh7b9z00152wwvdnteev4c","category_id":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7bac00352wwv4kky9ppf"},{"post_id":"clzwh7b9z00152wwvdnteev4c","category_id":"clzwh7b9v000o2wwv1v1tdkmt","_id":"clzwh7bad00392wwvdg5z4uo1"},{"post_id":"clzwh7b9z00152wwvdnteev4c","category_id":"clzwh7bab00302wwvgwllalty","_id":"clzwh7bad003b2wwv99j3fogz"},{"post_id":"clzwh7b9z00172wwvgavr3uvs","category_id":"clzwh7b9x000y2wwv89nw77g9","_id":"clzwh7bae003g2wwv3gsp199z"},{"post_id":"clzwh7b9z00172wwvgavr3uvs","category_id":"clzwh7bac00372wwvf2jc5an9","_id":"clzwh7bah003i2wwv9kqnappk"},{"post_id":"clzwh7b9l00032wwv1r3i2qgt","category_id":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7bai003n2wwvbu4f3xbg"},{"post_id":"clzwh7b9l00032wwv1r3i2qgt","category_id":"clzwh7b9v000o2wwv1v1tdkmt","_id":"clzwh7bai003p2wwv7aikhux1"},{"post_id":"clzwh7b9l00032wwv1r3i2qgt","category_id":"clzwh7bae003h2wwvb1kpd7ty","_id":"clzwh7bai003t2wwves896415"},{"post_id":"clzwh7b9t000i2wwv5p632p1t","category_id":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7baj00402wwv4h193mo2"},{"post_id":"clzwh7b9t000i2wwv5p632p1t","category_id":"clzwh7b9v000o2wwv1v1tdkmt","_id":"clzwh7baj00422wwvf2qq3wi8"},{"post_id":"clzwh7b9t000i2wwv5p632p1t","category_id":"clzwh7bae003h2wwvb1kpd7ty","_id":"clzwh7baj00442wwv8hsqcbmc"},{"post_id":"clzwh7b9o00072wwv2z3sbqf1","category_id":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7bam004k2wwv77zb7owc"},{"post_id":"clzwh7b9o00072wwv2z3sbqf1","category_id":"clzwh7b9v000o2wwv1v1tdkmt","_id":"clzwh7bam004m2wwv024y0gua"},{"post_id":"clzwh7b9o00072wwv2z3sbqf1","category_id":"clzwh7ba700222wwvhrbe0s2c","_id":"clzwh7bam004o2wwv523f1kwg"},{"post_id":"clzwh7b9v000r2wwvbjz88z49","category_id":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7bap00572wwvaw4eevk9"},{"post_id":"clzwh7b9v000r2wwvbjz88z49","category_id":"clzwh7ba6001v2wwvbf6b7e19","_id":"clzwh7bap00592wwv2upz5nep"},{"post_id":"clzwh7b9v000r2wwvbjz88z49","category_id":"clzwh7bao00512wwv1jg264z5","_id":"clzwh7bap005d2wwv8x6d57b1"},{"post_id":"clzwh7b9w000t2wwvfscq709t","category_id":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7baq005q2wwvb5271ez2"},{"post_id":"clzwh7b9w000t2wwvfscq709t","category_id":"clzwh7ba6001v2wwvbf6b7e19","_id":"clzwh7baq005s2wwv0xlgealp"},{"post_id":"clzwh7b9w000t2wwvfscq709t","category_id":"clzwh7bao00512wwv1jg264z5","_id":"clzwh7bar005u2wwv6vgpfjrr"},{"post_id":"clzwh7b9x000x2wwv4sww39ge","category_id":"clzwh7b9n00042wwv1cbu8qor","_id":"clzwh7bar005y2wwv8clp0n5t"},{"post_id":"clzwh7b9x000x2wwv4sww39ge","category_id":"clzwh7ba6001v2wwvbf6b7e19","_id":"clzwh7bar00612wwvhbymct4g"},{"post_id":"clzwh7b9x000x2wwv4sww39ge","category_id":"clzwh7baq005r2wwvh5av6aqr","_id":"clzwh7bas00642wwv875xc4kt"},{"post_id":"clzwh7b9s000g2wwv87817lyn","category_id":"clzwh7b9x000y2wwv89nw77g9","_id":"clzwh7bas006b2wwv3jwf4o5y"},{"post_id":"clzwh7b9s000g2wwv87817lyn","category_id":"clzwh7bac00342wwv3k4leq5u","_id":"clzwh7bas006d2wwv4bhzfspo"},{"post_id":"clzwh7b9s000g2wwv87817lyn","category_id":"clzwh7bas00652wwvhepe5m96","_id":"clzwh7bat006g2wwv6fph9t3f"},{"post_id":"clzwh7ba000192wwv734e6awe","category_id":"clzwh7b9x000y2wwv89nw77g9","_id":"clzwh7bat006j2wwvhby39wub"},{"post_id":"clzwh7ba000192wwv734e6awe","category_id":"clzwh7bad003d2wwv56ude8yh","_id":"clzwh7bat006m2wwve9cj7et5"},{"post_id":"clzwh7ba000192wwv734e6awe","category_id":"clzwh7bas00682wwv8tqd6gjl","_id":"clzwh7bat006p2wwvago9e8ec"},{"post_id":"clzwh7ba1001d2wwvaxlv0cdm","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bau006s2wwv6k0r0dmg"},{"post_id":"clzwh7ba1001d2wwvaxlv0cdm","category_id":"clzwh7baq005m2wwv8tcvag3k","_id":"clzwh7bau006u2wwv57gl82no"},{"post_id":"clzwh7ba1001f2wwv7fua3fl0","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bau006w2wwvbq1xfdmv"},{"post_id":"clzwh7ba1001f2wwv7fua3fl0","category_id":"clzwh7baq005m2wwv8tcvag3k","_id":"clzwh7bau006z2wwv7ke31sq2"},{"post_id":"clzwh7ba2001l2wwv4o5ibxv1","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bav00782wwvd76da7o7"},{"post_id":"clzwh7ba2001l2wwv4o5ibxv1","category_id":"clzwh7bau00722wwv6pxc4xwi","_id":"clzwh7bav007b2wwv8jnk91uk"},{"post_id":"clzwh7ba3001p2wwvgt63dcu9","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7baw007f2wwvebmlgd3d"},{"post_id":"clzwh7ba3001p2wwvgt63dcu9","category_id":"clzwh7bau00722wwv6pxc4xwi","_id":"clzwh7baw007i2wwve6nqdc0e"},{"post_id":"clzwh7ba4001s2wwv4a5d6879","category_id":"clzwh7bam004j2wwvew929fzz","_id":"clzwh7baw007l2wwvfbjc7w74"},{"post_id":"clzwh7ba4001s2wwv4a5d6879","category_id":"clzwh7bav007d2wwv8ouf3zi8","_id":"clzwh7baw007o2wwv7sruavxt"},{"post_id":"clzwh7b9v000n2wwv2iy4coh0","category_id":"clzwh7ba4001r2wwv5wmxfk8r","_id":"clzwh7bax007s2wwva8vv0y4l"},{"post_id":"clzwh7b9v000n2wwv2iy4coh0","category_id":"clzwh7ban004t2wwvaq9set3h","_id":"clzwh7bax007v2wwv6qf771pu"},{"post_id":"clzwh7b9v000n2wwv2iy4coh0","category_id":"clzwh7baw007k2wwv8h7q4gc4","_id":"clzwh7bax007x2wwv09dk47o4"},{"post_id":"clzwh7b9x000w2wwvgqa55m28","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bb0008i2wwv8mn9hn1c"},{"post_id":"clzwh7b9x000w2wwvgqa55m28","category_id":"clzwh7baq005m2wwv8tcvag3k","_id":"clzwh7bb1008l2wwvh68s2h5g"},{"post_id":"clzwh7b9x000w2wwvgqa55m28","category_id":"clzwh7bb0008b2wwvaaer8s27","_id":"clzwh7bb1008n2wwv1fu17awa"},{"post_id":"clzwh7b9y00102wwv9bc31tuf","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bb1008p2wwv2pk4etha"},{"post_id":"clzwh7b9y00102wwv9bc31tuf","category_id":"clzwh7bar005v2wwv8xda9wrn","_id":"clzwh7bb1008q2wwv34yp27a6"},{"post_id":"clzwh7b9y00102wwv9bc31tuf","category_id":"clzwh7bb0008e2wwvhwibgxid","_id":"clzwh7bb1008t2wwvaeaqdx8r"},{"post_id":"clzwh7b9y00122wwvg9fo4zy3","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bb1008v2wwv1p2chie0"},{"post_id":"clzwh7b9y00122wwvg9fo4zy3","category_id":"clzwh7baq005m2wwv8tcvag3k","_id":"clzwh7bb2008y2wwv18xqhgc1"},{"post_id":"clzwh7b9y00122wwvg9fo4zy3","category_id":"clzwh7bb1008j2wwv1jb2avpl","_id":"clzwh7bb2008z2wwv73lthb5w"},{"post_id":"clzwh7ba0001b2wwv49oac8vr","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bb200902wwveq2p1m7z"},{"post_id":"clzwh7ba0001b2wwv49oac8vr","category_id":"clzwh7bas006c2wwv7z088sy1","_id":"clzwh7bb200922wwv1t6o500a"},{"post_id":"clzwh7ba0001b2wwv49oac8vr","category_id":"clzwh7bb1008o2wwv6w98dh8p","_id":"clzwh7bb200932wwvc6i8fz4s"},{"post_id":"clzwh7ba2001i2wwv5lsx0zpp","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bb200952wwv72jqdo6w"},{"post_id":"clzwh7ba2001i2wwv5lsx0zpp","category_id":"clzwh7bau006r2wwv5h648zhk","_id":"clzwh7bb200962wwv5w0gemku"},{"post_id":"clzwh7ba2001i2wwv5lsx0zpp","category_id":"clzwh7bb1008s2wwvhmx77kv1","_id":"clzwh7bb200982wwvefr7eo2z"},{"post_id":"clzwh7b9u000l2wwv2t31e5gs","category_id":"clzwh7b9x000y2wwv89nw77g9","_id":"clzwh7bb200992wwv82od7tur"},{"post_id":"clzwh7b9u000l2wwv2t31e5gs","category_id":"clzwh7bac00342wwv3k4leq5u","_id":"clzwh7bb2009b2wwv31zu47yq"},{"post_id":"clzwh7b9u000l2wwv2t31e5gs","category_id":"clzwh7bau006x2wwvcs3s49ht","_id":"clzwh7bb3009c2wwv2fkm92h9"},{"post_id":"clzwh7b9u000l2wwv2t31e5gs","category_id":"clzwh7bb2008x2wwv5n2k0o6t","_id":"clzwh7bb3009e2wwvd8758nus"},{"post_id":"clzwh7ba3001o2wwvd6bjc7ze","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bb3009f2wwv25ib15r8"},{"post_id":"clzwh7ba3001o2wwvd6bjc7ze","category_id":"clzwh7bau00722wwv6pxc4xwi","_id":"clzwh7bb3009h2wwvbjc3d0si"},{"post_id":"clzwh7ba3001o2wwvd6bjc7ze","category_id":"clzwh7bb200912wwv811xep16","_id":"clzwh7bb3009i2wwvhu684ikq"},{"post_id":"clzwh7ba5001t2wwv7hip63a6","category_id":"clzwh7ba9002c2wwvfozfgdwq","_id":"clzwh7bb3009k2wwvay2ea4x6"},{"post_id":"clzwh7ba5001t2wwv7hip63a6","category_id":"clzwh7bau00722wwv6pxc4xwi","_id":"clzwh7bb3009l2wwvd7lp2l05"},{"post_id":"clzwh7ba5001t2wwv7hip63a6","category_id":"clzwh7bb200942wwvdnog25au","_id":"clzwh7bb3009n2wwvch73awe2"},{"post_id":"clzwh7ba6001w2wwv8cah6cid","category_id":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7bb4009r2wwv41nbcod6"},{"post_id":"clzwh7ba6001w2wwv8cah6cid","category_id":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb4009s2wwvggvt5mjx"},{"post_id":"clzwh7ba6001w2wwv8cah6cid","category_id":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb4009u2wwv16dnhvst"},{"post_id":"clzwh7ba6001w2wwv8cah6cid","category_id":"clzwh7bb3009o2wwva0s7fotm","_id":"clzwh7bb4009v2wwvbm76hgzr"},{"post_id":"clzwh7ba6001y2wwv11b87osw","category_id":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7bb4009x2wwv6v08gqqs"},{"post_id":"clzwh7ba6001y2wwv11b87osw","category_id":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb5009y2wwvdryb596f"},{"post_id":"clzwh7ba6001y2wwv11b87osw","category_id":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb500a02wwveznv1smh"},{"post_id":"clzwh7ba6001y2wwv11b87osw","category_id":"clzwh7bb3009o2wwva0s7fotm","_id":"clzwh7bb500a12wwvdr8g3msk"},{"post_id":"clzwh7ba700212wwvgo593hks","category_id":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7bb500a22wwvfahn6yrf"},{"post_id":"clzwh7ba700212wwvgo593hks","category_id":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb500a32wwv8dhdej0w"},{"post_id":"clzwh7ba700212wwvgo593hks","category_id":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb500a42wwvd822b93n"},{"post_id":"clzwh7ba700212wwvgo593hks","category_id":"clzwh7bb3009o2wwva0s7fotm","_id":"clzwh7bb500a52wwv9wxn4jxu"},{"post_id":"clzwh7ba700242wwvaaf2bver","category_id":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7bb500a62wwv6plc7pu7"},{"post_id":"clzwh7ba700242wwvaaf2bver","category_id":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb500a72wwv5l333io1"},{"post_id":"clzwh7ba700242wwvaaf2bver","category_id":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb500a82wwv2y26ama3"},{"post_id":"clzwh7ba700242wwvaaf2bver","category_id":"clzwh7bb3009o2wwva0s7fotm","_id":"clzwh7bb500a92wwvgtbj3shs"},{"post_id":"clzwh7ba800262wwv54oofvcu","category_id":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7bb500aa2wwvhmmz84hz"},{"post_id":"clzwh7ba800262wwv54oofvcu","category_id":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb500ab2wwv3rurhj5m"},{"post_id":"clzwh7ba800262wwv54oofvcu","category_id":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb500ac2wwv152g3id1"},{"post_id":"clzwh7ba800262wwv54oofvcu","category_id":"clzwh7bb3009o2wwva0s7fotm","_id":"clzwh7bb500ad2wwv31s3ddtm"},{"post_id":"clzwh7ba800292wwv2i6icy12","category_id":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7bb500ae2wwvbgdl2xmx"},{"post_id":"clzwh7ba800292wwv2i6icy12","category_id":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb600af2wwvc4x9e6z1"},{"post_id":"clzwh7ba800292wwv2i6icy12","category_id":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb600ag2wwv0wja8apj"},{"post_id":"clzwh7ba800292wwv2i6icy12","category_id":"clzwh7bb3009o2wwva0s7fotm","_id":"clzwh7bb600ah2wwv54x40yfx"},{"post_id":"clzwh7bb700ai2wwv9irs5ump","category_id":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7bb900ao2wwvc6akeewd"},{"post_id":"clzwh7bb700ai2wwv9irs5ump","category_id":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb900aq2wwvdv8474mn"},{"post_id":"clzwh7bb700ai2wwv9irs5ump","category_id":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb900as2wwv2i56gjjr"},{"post_id":"clzwh7bb700ai2wwv9irs5ump","category_id":"clzwh7bb3009o2wwva0s7fotm","_id":"clzwh7bb900au2wwv8eo3eeo7"},{"post_id":"clzwh7bb700aj2wwv7g6a9t4v","category_id":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7bb900aw2wwvfd606q0o"},{"post_id":"clzwh7bb700aj2wwv7g6a9t4v","category_id":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb900ay2wwvbszk0lrg"},{"post_id":"clzwh7bb700aj2wwv7g6a9t4v","category_id":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb900b02wwv4ks7co5g"},{"post_id":"clzwh7bb700aj2wwv7g6a9t4v","category_id":"clzwh7bb3009o2wwva0s7fotm","_id":"clzwh7bb900b22wwv13su0qqx"},{"post_id":"clzwh7bb800al2wwvejv8ayh5","category_id":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7bb900b42wwv3w4f85vd"},{"post_id":"clzwh7bb800al2wwvejv8ayh5","category_id":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb900b62wwv1a1q4lg2"},{"post_id":"clzwh7bb800al2wwvejv8ayh5","category_id":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb900b82wwv0y1v5j1m"},{"post_id":"clzwh7bb800al2wwvejv8ayh5","category_id":"clzwh7bb3009o2wwva0s7fotm","_id":"clzwh7bb900b92wwv65nfg9q9"},{"post_id":"clzwh7bb800an2wwvfe57494z","category_id":"clzwh7ban004w2wwv3ooa48wo","_id":"clzwh7bb900ba2wwv75p1bcty"},{"post_id":"clzwh7bb800an2wwvfe57494z","category_id":"clzwh7baw007q2wwvdi9t957d","_id":"clzwh7bb900bb2wwv42hw41g4"},{"post_id":"clzwh7bb800an2wwvfe57494z","category_id":"clzwh7bb200972wwv1gnba94m","_id":"clzwh7bb900bc2wwv57ld9rdx"},{"post_id":"clzwh7bb800an2wwvfe57494z","category_id":"clzwh7bb3009o2wwva0s7fotm","_id":"clzwh7bb900bd2wwv8pr56ril"}],"PostTag":[{"post_id":"clzwh7b9p00092wwv8bw92d9u","tag_id":"clzwh7b9o00052wwv1r5vdh64","_id":"clzwh7b9s000e2wwvhzseh0k9"},{"post_id":"clzwh7b9i00012wwv3676e6cu","tag_id":"clzwh7b9o00052wwv1r5vdh64","_id":"clzwh7b9t000h2wwv39bs3nab"},{"post_id":"clzwh7b9l00032wwv1r3i2qgt","tag_id":"clzwh7b9r000d2wwv2olm0tsb","_id":"clzwh7b9u000m2wwvfed654gd"},{"post_id":"clzwh7b9t000i2wwv5p632p1t","tag_id":"clzwh7b9r000d2wwv2olm0tsb","_id":"clzwh7b9v000p2wwvhq6meg90"},{"post_id":"clzwh7b9o00072wwv2z3sbqf1","tag_id":"clzwh7b9o00052wwv1r5vdh64","_id":"clzwh7b9w000s2wwvhhst0p0a"},{"post_id":"clzwh7b9q000b2wwv6gficzyi","tag_id":"clzwh7b9v000q2wwvh40261ad","_id":"clzwh7b9y00112wwv59ild6ue"},{"post_id":"clzwh7b9q000b2wwv6gficzyi","tag_id":"clzwh7b9x000v2wwv9hoob9mr","_id":"clzwh7b9y00142wwv36gnepnd"},{"post_id":"clzwh7b9s000g2wwv87817lyn","tag_id":"clzwh7b9y000z2wwv2kmv6w98","_id":"clzwh7ba2001g2wwvb3ejfdyo"},{"post_id":"clzwh7b9s000g2wwv87817lyn","tag_id":"clzwh7b9z00162wwv137k9qgh","_id":"clzwh7ba2001j2wwv473d5on6"},{"post_id":"clzwh7b9s000g2wwv87817lyn","tag_id":"clzwh7ba0001a2wwvbuszfjgp","_id":"clzwh7ba3001m2wwvg4va4f57"},{"post_id":"clzwh7b9u000l2wwv2t31e5gs","tag_id":"clzwh7ba1001e2wwvesrn5v7n","_id":"clzwh7ba6001x2wwv7q7t4dud"},{"post_id":"clzwh7b9u000l2wwv2t31e5gs","tag_id":"clzwh7ba2001k2wwv0a5ibgqi","_id":"clzwh7ba6001z2wwv9gv4f37d"},{"post_id":"clzwh7b9u000l2wwv2t31e5gs","tag_id":"clzwh7ba4001q2wwvazx95gyt","_id":"clzwh7ba700232wwvfuy60bt3"},{"post_id":"clzwh7b9v000n2wwv2iy4coh0","tag_id":"clzwh7b9y000z2wwv2kmv6w98","_id":"clzwh7ba800282wwvb4wggrvd"},{"post_id":"clzwh7b9v000n2wwv2iy4coh0","tag_id":"clzwh7ba600202wwvf9ffewqs","_id":"clzwh7ba9002a2wwv8811gz4p"},{"post_id":"clzwh7b9v000r2wwvbjz88z49","tag_id":"clzwh7ba800252wwv0li4895m","_id":"clzwh7ba9002e2wwv5u0e3imq"},{"post_id":"clzwh7b9w000t2wwvfscq709t","tag_id":"clzwh7ba800252wwv0li4895m","_id":"clzwh7baa002j2wwv4ow7fyoj"},{"post_id":"clzwh7b9x000w2wwvgqa55m28","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7bab002t2wwv3s7k7cos"},{"post_id":"clzwh7b9x000w2wwvgqa55m28","tag_id":"clzwh7baa002k2wwvclrxhifj","_id":"clzwh7bab002u2wwv7r0u82gm"},{"post_id":"clzwh7b9x000w2wwvgqa55m28","tag_id":"clzwh7baa002m2wwvdyq0fen8","_id":"clzwh7bab002x2wwvf3x32xlu"},{"post_id":"clzwh7b9x000x2wwv4sww39ge","tag_id":"clzwh7bab002q2wwvei5gcqts","_id":"clzwh7bab002y2wwvglvg0mwv"},{"post_id":"clzwh7b9y00102wwv9bc31tuf","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7bad00382wwvdt7918zw"},{"post_id":"clzwh7b9y00102wwv9bc31tuf","tag_id":"clzwh7bab002z2wwv1ist6wrt","_id":"clzwh7bad003a2wwvgovxe6ok"},{"post_id":"clzwh7b9y00102wwv9bc31tuf","tag_id":"clzwh7bac00332wwv56d4cx6c","_id":"clzwh7bad003e2wwv7mld219a"},{"post_id":"clzwh7b9y00122wwvg9fo4zy3","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7bai003o2wwvg2st3025"},{"post_id":"clzwh7b9y00122wwvg9fo4zy3","tag_id":"clzwh7baa002k2wwvclrxhifj","_id":"clzwh7bai003q2wwvgxhme52x"},{"post_id":"clzwh7b9y00122wwvg9fo4zy3","tag_id":"clzwh7bad003f2wwv8lqc8nj9","_id":"clzwh7bai003u2wwv7ltwc81z"},{"post_id":"clzwh7b9y00122wwvg9fo4zy3","tag_id":"clzwh7bah003j2wwv7xcr6ete","_id":"clzwh7bai003v2wwvgcs1fclk"},{"post_id":"clzwh7b9z00152wwvdnteev4c","tag_id":"clzwh7bah003l2wwvfophavll","_id":"clzwh7baj003y2wwv880s0by5"},{"post_id":"clzwh7b9z00172wwvgavr3uvs","tag_id":"clzwh7bai003r2wwvab120gp3","_id":"clzwh7bak00462wwvc0li5s5r"},{"post_id":"clzwh7b9z00172wwvgavr3uvs","tag_id":"clzwh7bai003x2wwvawhrhf3k","_id":"clzwh7bak00482wwv21gqcayc"},{"post_id":"clzwh7b9z00172wwvgavr3uvs","tag_id":"clzwh7baj00412wwvhplwf7vx","_id":"clzwh7bak004a2wwv1hw60d55"},{"post_id":"clzwh7ba000192wwv734e6awe","tag_id":"clzwh7bak00452wwvb2d5a9us","_id":"clzwh7bal004g2wwvgusng8ad"},{"post_id":"clzwh7ba000192wwv734e6awe","tag_id":"clzwh7bak00492wwv7i2ygm30","_id":"clzwh7bal004h2wwv6lgp8w8p"},{"post_id":"clzwh7ba000192wwv734e6awe","tag_id":"clzwh7bal004c2wwvazka2ngq","_id":"clzwh7bam004l2wwv0r32e4wz"},{"post_id":"clzwh7ba0001b2wwv49oac8vr","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7bam004q2wwv3fizepnc"},{"post_id":"clzwh7ba0001b2wwv49oac8vr","tag_id":"clzwh7bal004i2wwvgy0zc7u7","_id":"clzwh7bam004r2wwv9vekdyfc"},{"post_id":"clzwh7ba1001d2wwvaxlv0cdm","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7ban004v2wwvg1jefffm"},{"post_id":"clzwh7ba1001d2wwvaxlv0cdm","tag_id":"clzwh7baa002k2wwvclrxhifj","_id":"clzwh7ban004x2wwvhbd31lce"},{"post_id":"clzwh7ba1001f2wwv7fua3fl0","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7bao00552wwv9pzmgfe2"},{"post_id":"clzwh7ba1001f2wwv7fua3fl0","tag_id":"clzwh7baa002k2wwvclrxhifj","_id":"clzwh7bap00582wwv2i8kh1fc"},{"post_id":"clzwh7ba1001f2wwv7fua3fl0","tag_id":"clzwh7bao00502wwvdfp9apoq","_id":"clzwh7bap005b2wwv6xopfuqs"},{"post_id":"clzwh7ba1001f2wwv7fua3fl0","tag_id":"clzwh7bao00522wwv945n52rb","_id":"clzwh7bap005e2wwv6zlzdj9d"},{"post_id":"clzwh7ba2001i2wwv5lsx0zpp","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7bap005h2wwvc19468bl"},{"post_id":"clzwh7ba2001i2wwv5lsx0zpp","tag_id":"clzwh7bap005a2wwvasvk5az6","_id":"clzwh7bap005i2wwvaqa8g26k"},{"post_id":"clzwh7ba2001l2wwv4o5ibxv1","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7baq005n2wwv0vljewf3"},{"post_id":"clzwh7ba2001l2wwv4o5ibxv1","tag_id":"clzwh7bah003j2wwv7xcr6ete","_id":"clzwh7baq005o2wwv3lz10zlr"},{"post_id":"clzwh7ba3001o2wwvd6bjc7ze","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7bar005x2wwv1ennbgt7"},{"post_id":"clzwh7ba3001o2wwvd6bjc7ze","tag_id":"clzwh7bah003j2wwv7xcr6ete","_id":"clzwh7bar00602wwv1ast5om4"},{"post_id":"clzwh7ba3001o2wwvd6bjc7ze","tag_id":"clzwh7baq005t2wwv36464vru","_id":"clzwh7bas00632wwv4u6hfy16"},{"post_id":"clzwh7ba3001p2wwvgt63dcu9","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7bas00672wwverwo6ra3"},{"post_id":"clzwh7ba3001p2wwvgt63dcu9","tag_id":"clzwh7bah003j2wwv7xcr6ete","_id":"clzwh7bas00692wwv53jjblxd"},{"post_id":"clzwh7ba4001s2wwv4a5d6879","tag_id":"clzwh7b9y000z2wwv2kmv6w98","_id":"clzwh7bat006f2wwvbsl21vfl"},{"post_id":"clzwh7ba4001s2wwv4a5d6879","tag_id":"clzwh7bas00662wwv3edq8h15","_id":"clzwh7bat006i2wwv42r0bspc"},{"post_id":"clzwh7ba4001s2wwv4a5d6879","tag_id":"clzwh7ba0001a2wwvbuszfjgp","_id":"clzwh7bat006l2wwvcl1t5gyx"},{"post_id":"clzwh7ba4001s2wwv4a5d6879","tag_id":"clzwh7bas006a2wwvexud4amp","_id":"clzwh7bat006o2wwvd8cd0dwu"},{"post_id":"clzwh7ba5001t2wwv7hip63a6","tag_id":"clzwh7ba9002g2wwvf8ze6210","_id":"clzwh7bau006v2wwv3e4q7hk7"},{"post_id":"clzwh7ba5001t2wwv7hip63a6","tag_id":"clzwh7bah003j2wwv7xcr6ete","_id":"clzwh7bau006y2wwv44tj5b84"},{"post_id":"clzwh7ba5001t2wwv7hip63a6","tag_id":"clzwh7bat006q2wwv70d12hrw","_id":"clzwh7bau00712wwveu7e4ce9"},{"post_id":"clzwh7ba6001w2wwv8cah6cid","tag_id":"clzwh7bau006t2wwvcuupa0f0","_id":"clzwh7bav00762wwv94lk08ne"},{"post_id":"clzwh7ba6001w2wwv8cah6cid","tag_id":"clzwh7bau00702wwvgdcz395p","_id":"clzwh7bav00792wwvgejnb7mu"},{"post_id":"clzwh7ba6001w2wwv8cah6cid","tag_id":"clzwh7bau00732wwvdadl22fz","_id":"clzwh7bav007c2wwv575p4am7"},{"post_id":"clzwh7ba6001y2wwv11b87osw","tag_id":"clzwh7bau006t2wwvcuupa0f0","_id":"clzwh7baw007j2wwv7vtfe59m"},{"post_id":"clzwh7ba6001y2wwv11b87osw","tag_id":"clzwh7bau00702wwvgdcz395p","_id":"clzwh7baw007m2wwvhc10cozr"},{"post_id":"clzwh7ba6001y2wwv11b87osw","tag_id":"clzwh7bau00732wwvdadl22fz","_id":"clzwh7baw007p2wwv2leu9bz6"},{"post_id":"clzwh7ba700212wwvgo593hks","tag_id":"clzwh7bau006t2wwvcuupa0f0","_id":"clzwh7bax007w2wwvavge2uuf"},{"post_id":"clzwh7ba700212wwvgo593hks","tag_id":"clzwh7bau00702wwvgdcz395p","_id":"clzwh7bax007y2wwvaqubg5wc"},{"post_id":"clzwh7ba700212wwvgo593hks","tag_id":"clzwh7bau00732wwvdadl22fz","_id":"clzwh7bay00812wwv7l25dt5r"},{"post_id":"clzwh7ba700242wwvaaf2bver","tag_id":"clzwh7bau006t2wwvcuupa0f0","_id":"clzwh7baz00862wwv6aewbony"},{"post_id":"clzwh7ba700242wwvaaf2bver","tag_id":"clzwh7bau00702wwvgdcz395p","_id":"clzwh7baz00872wwv17rdgqp8"},{"post_id":"clzwh7ba700242wwvaaf2bver","tag_id":"clzwh7bau00732wwvdadl22fz","_id":"clzwh7bb0008a2wwv303h9nxc"},{"post_id":"clzwh7ba800262wwv54oofvcu","tag_id":"clzwh7bau006t2wwvcuupa0f0","_id":"clzwh7bb0008f2wwvfzhjdr6l"},{"post_id":"clzwh7ba800262wwv54oofvcu","tag_id":"clzwh7bau00702wwvgdcz395p","_id":"clzwh7bb0008g2wwv5qpnc9da"},{"post_id":"clzwh7ba800262wwv54oofvcu","tag_id":"clzwh7bau00732wwvdadl22fz","_id":"clzwh7bb1008k2wwv16gc8g4v"},{"post_id":"clzwh7ba800292wwv2i6icy12","tag_id":"clzwh7bau006t2wwvcuupa0f0","_id":"clzwh7bb1008r2wwv3djngdb9"},{"post_id":"clzwh7ba800292wwv2i6icy12","tag_id":"clzwh7bau00702wwvgdcz395p","_id":"clzwh7bb1008u2wwv83qw076z"},{"post_id":"clzwh7ba800292wwv2i6icy12","tag_id":"clzwh7bau00732wwvdadl22fz","_id":"clzwh7bb2008w2wwvbtc34hg9"},{"post_id":"clzwh7bb700ai2wwv9irs5ump","tag_id":"clzwh7bau006t2wwvcuupa0f0","_id":"clzwh7bb800ak2wwvajxg1krq"},{"post_id":"clzwh7bb700ai2wwv9irs5ump","tag_id":"clzwh7bau00702wwvgdcz395p","_id":"clzwh7bb800am2wwvays7dbqo"},{"post_id":"clzwh7bb700ai2wwv9irs5ump","tag_id":"clzwh7bau00732wwvdadl22fz","_id":"clzwh7bb900ap2wwv7gkvhpbb"},{"post_id":"clzwh7bb700aj2wwv7g6a9t4v","tag_id":"clzwh7bau006t2wwvcuupa0f0","_id":"clzwh7bb900ar2wwv034y2dp8"},{"post_id":"clzwh7bb700aj2wwv7g6a9t4v","tag_id":"clzwh7bau00702wwvgdcz395p","_id":"clzwh7bb900at2wwv9484eygp"},{"post_id":"clzwh7bb700aj2wwv7g6a9t4v","tag_id":"clzwh7bau00732wwvdadl22fz","_id":"clzwh7bb900av2wwv6k65emqm"},{"post_id":"clzwh7bb800al2wwvejv8ayh5","tag_id":"clzwh7bau006t2wwvcuupa0f0","_id":"clzwh7bb900ax2wwvcaz51b2u"},{"post_id":"clzwh7bb800al2wwvejv8ayh5","tag_id":"clzwh7bau00702wwvgdcz395p","_id":"clzwh7bb900az2wwv6frc38az"},{"post_id":"clzwh7bb800al2wwvejv8ayh5","tag_id":"clzwh7bau00732wwvdadl22fz","_id":"clzwh7bb900b12wwv5mtq8wfe"},{"post_id":"clzwh7bb800an2wwvfe57494z","tag_id":"clzwh7bau006t2wwvcuupa0f0","_id":"clzwh7bb900b32wwvhpra95bv"},{"post_id":"clzwh7bb800an2wwvfe57494z","tag_id":"clzwh7bau00702wwvgdcz395p","_id":"clzwh7bb900b52wwvcn0ncgvp"},{"post_id":"clzwh7bb800an2wwvfe57494z","tag_id":"clzwh7bau00732wwvdadl22fz","_id":"clzwh7bb900b72wwvfpht3lpq"}],"Tag":[{"name":"icpc","_id":"clzwh7b9o00052wwv1r5vdh64"},{"name":"ccpc","_id":"clzwh7b9r000d2wwv2olm0tsb"},{"name":"Latex","_id":"clzwh7b9v000q2wwvh40261ad"},{"name":"图像处理","_id":"clzwh7b9x000v2wwv9hoob9mr"},{"name":"信息安全","_id":"clzwh7b9y000z2wwv2kmv6w98"},{"name":"软件","_id":"clzwh7b9z00162wwv137k9qgh"},{"name":"Miracl","_id":"clzwh7ba0001a2wwvbuszfjgp"},{"name":"nodejs","_id":"clzwh7ba1001e2wwvesrn5v7n"},{"name":"gcc","_id":"clzwh7ba2001k2wwv0a5ibgqi"},{"name":"linux","_id":"clzwh7ba4001q2wwvazx95gyt"},{"name":"数学","_id":"clzwh7ba600202wwvf9ffewqs"},{"name":"newcoder","_id":"clzwh7ba800252wwv0li4895m"},{"name":"算法","_id":"clzwh7ba9002g2wwvf8ze6210"},{"name":"思维题","_id":"clzwh7baa002k2wwvclrxhifj"},{"name":"模运算","_id":"clzwh7baa002m2wwvdyq0fen8"},{"name":"atcoder","_id":"clzwh7bab002q2wwvei5gcqts"},{"name":"博弈论","_id":"clzwh7bab002z2wwv1ist6wrt"},{"name":"不等式","_id":"clzwh7bac00332wwv56d4cx6c"},{"name":"贪心","_id":"clzwh7bad003f2wwv8lqc8nj9"},{"name":"状态转移","_id":"clzwh7bah003j2wwv7xcr6ete"},{"name":"luogu","_id":"clzwh7bah003l2wwvfophavll"},{"name":"开发","_id":"clzwh7bai003r2wwvab120gp3"},{"name":"文档","_id":"clzwh7bai003x2wwvawhrhf3k"},{"name":"学校","_id":"clzwh7baj00412wwvhplwf7vx"},{"name":"Typora","_id":"clzwh7bak00452wwvb2d5a9us"},{"name":"Markdown","_id":"clzwh7bak00492wwv7i2ygm30"},{"name":"随笔","_id":"clzwh7bal004c2wwvazka2ngq"},{"name":"子序列自动机","_id":"clzwh7bal004i2wwvgy0zc7u7"},{"name":"坐标系转换","_id":"clzwh7bao00502wwvdfp9apoq"},{"name":"几何问题","_id":"clzwh7bao00522wwv945n52rb"},{"name":"树问题，哈希算法","_id":"clzwh7bap005a2wwvasvk5az6"},{"name":"异或问题","_id":"clzwh7baq005t2wwv36464vru"},{"name":"加密算法","_id":"clzwh7bas00662wwv3edq8h15"},{"name":"ECC","_id":"clzwh7bas006a2wwvexud4amp"},{"name":"离散化","_id":"clzwh7bat006q2wwv70d12hrw"},{"name":"机器学习","_id":"clzwh7bau006t2wwvcuupa0f0"},{"name":"MindSpore","_id":"clzwh7bau00702wwvgdcz395p"},{"name":"目录","_id":"clzwh7bau00732wwvdadl22fz"}]}}