{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/beian.png","path":"images/beian.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/qq-contact.png","path":"images/qq-contact.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechat_channel.jpg","path":"images/wechat_channel.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","path":"uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","modified":1,"renderable":0},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","path":"uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","modified":1,"renderable":0}],"Cache":[{"_id":"source/_data/languages.yml","hash":"f50fd6ebe8c97b9abe5b7ee3ac6f887383b93ccd","modified":1723628579090},{"_id":"source/404/404.md","hash":"8376757f89e049a3a5685b5fa9539c91713ae513","modified":1723613990887},{"_id":"source/about/index.md","hash":"7768e8a05c4eec51618ec4766fe01e964af83c15","modified":1723643469539},{"_id":"source/categories/index.md","hash":"60b226af341348b28c0b119ebdccc5e58c802085","modified":1723618837565},{"_id":"source/schedule/index.md","hash":"95b3ff5bf09f7e8fe31b55662d015636f60f8f5a","modified":1723637034657},{"_id":"source/tags/index.md","hash":"008e0978586bfc95819e8dbb86b9e75efcdf1a3c","modified":1723612488261},{"_id":"source/_posts/2024武汉ICPC邀请赛VP.md","hash":"7bfed8d9740898ecd20111a8c288020e105b9ee9","modified":1723693754747},{"_id":"source/_posts/2024江苏CCPC邀请赛-VP.md","hash":"04635a838e41c486f50ae2f71c96da45ab930a10","modified":1723693749691},{"_id":"source/_posts/2024河南CCPC邀请赛-VP.md","hash":"15b49b609f15170a09529d8e110a34b9d341655a","modified":1723693741699},{"_id":"source/_posts/2024黑龙江省赛-VP.md","hash":"4dca0032b20c391fe042f00251da84fade6a9c2c","modified":1723693728181},{"_id":"source/_posts/Nodejs安装简要建议.md","hash":"3304dfbc52bba040d869ed0a11166f21479c4b53","modified":1723689685517},{"_id":"source/_posts/Latex宏包pgfplots做矩形函数图像.md","hash":"2ae33665d3b6959a0cda695463a815240d90026d","modified":1723642724943},{"_id":"source/_posts/RSA涉及算法与数论知识.md","hash":"7dff17cb7672c0377af29bea3d01a1475bc8670c","modified":1723642736431},{"_id":"source/_posts/Xiaobai93D-E.md","hash":"869b9da9ca19956b914649da8a05d39cf6dff885","modified":1723693700236},{"_id":"source/_posts/Miracl的配置ForCentos7.md","hash":"14615d5987afb985413cbf71dc7f01ce28ffe67d","modified":1723642728720},{"_id":"source/_posts/Xiaobai94.md","hash":"c7f74a35246893469e4d0646ebdb1516e49221ad","modified":1723693693820},{"_id":"source/_posts/abc353.md","hash":"b5b97dc740ed4a90b8226ab82cac0b4fd4055a16","modified":1723693721734},{"_id":"source/_posts/abc354.md","hash":"068c8b0400f8f87c8e7e79f3b476e965d234da0e","modified":1723693715418},{"_id":"source/_posts/cf-edu165C.md","hash":"3a658423bfd445b6ed264884d2d8f7ef1ab96e85","modified":1723687027026},{"_id":"source/_posts/cf-edu165D.md","hash":"b8e5ae16b118e0c9ec1c17900bbe41f47db311cd","modified":1723642717760},{"_id":"source/_posts/luogu蓝桥5_19.md","hash":"0f233b36b563b733555a9cff47b8fcaea165ab9a","modified":1723693709907},{"_id":"source/_posts/三种操作系统模拟软件使用手册.md","hash":"55a62f88e91ba3c22a78219edc42b4806c0830cb","modified":1723642739744},{"_id":"source/_posts/为什么我用Typora——Typora与其他markdown的比较.md","hash":"e673ce8b6cec57ed2c9938b87275a33af259b54b","modified":1723642742327},{"_id":"source/_posts/思维题习题1.md","hash":"59e08f4ab9b2e15029969301e74228501388a190","modified":1723642748223},{"_id":"source/_posts/字符串习题1.md","hash":"c2ba5a4d92e4706d8b41cba1256b756709d55735","modified":1723642745118},{"_id":"source/_posts/数学距离问题1.md","hash":"869e8e6da900e6cc0921f94c610c2ba77750ba72","modified":1723642751945},{"_id":"source/_posts/树上回文问题.md","hash":"dfd074c9f52e28e0ffe3b4cc206d952909d0261e","modified":1723642754786},{"_id":"source/_posts/状态转移习题1.md","hash":"0800a8b4b867afc04b64c70d5677977db61504e0","modified":1723642758757},{"_id":"source/_posts/状态转移习题2.md","hash":"a92936db6b29a809a3aaeeec47e92221aa44e70a","modified":1723642761942},{"_id":"source/_posts/状态转移习题3.md","hash":"27d66b4c473e9f7eb306276aa0048289589cb185","modified":1723642765704},{"_id":"source/_posts/状态转移习题4.md","hash":"6fcd363634ac1e626ced2477d2755d4c76eb1a89","modified":1723642769254},{"_id":"source/_posts/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估.md","hash":"ecd50b1924c7280964f592c34665a4d9c1456d91","modified":1723690718900},{"_id":"source/_posts/2024湖北省赛VP.md","hash":"b426e2548012fa8f19e21fadabca2d3fee50a239","modified":1723697330921},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1723449052458},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1723449052458},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1723449052459},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1723449052464},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1723449052463},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1723449052464},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1723449052465},{"_id":"themes/next/_config.yml","hash":"541beb62711eae4cda63c6423867fefd0e2007cf","modified":1723694340133},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1723449052465},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1723449052476},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1723449052509},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1723449052459},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1723449052460},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1723449052461},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1723449052461},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1723449052461},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1723449052462},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1723449052462},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1723449052462},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1723449052463},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1723449052463},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1723449052463},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1723449052466},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1723449052466},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1723449052467},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1723449052467},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1723449052469},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1723449052469},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1723449052469},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1723449052470},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1723449052470},{"_id":"themes/next/img/custom-logo.jpg","hash":"d62188109038d7c4552b03b44edaee3c106dc86b","modified":1591248668000},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1723449052477},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1723449052477},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1723449052477},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1723449052477},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1723449052478},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1723449052478},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1723449052479},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1723449052479},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1723449052479},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1723449052479},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1723449052480},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1723449052480},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1723449052481},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1723449052480},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1723449052482},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1723449052482},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1723449052481},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1723449052482},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1723449052483},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1723449052483},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1723449052484},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1723449052484},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1723449052484},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1723449052507},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1723449052508},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1723686435818},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1723449052508},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1723449052509},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1723449052509},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1723449052516},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1723449052460},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1723449052460},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1723449052460},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1723449052461},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1723449052471},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1723449052471},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1723449052472},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1723449052471},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1723449052473},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1723449052473},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1723449052474},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1723449052474},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1723449052474},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1723449052475},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1723449052475},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1723449052476},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1723449052476},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1723449052485},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1723449052485},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1723449052486},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5a6633e365bad3a291f6295d1c2dfced54bc9bf6","modified":1723686327948},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1723449052486},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1723449052489},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1723449052490},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1723449052493},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1723449052493},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1723449052494},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1723449052495},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1723449052496},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1723449052497},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1723449052499},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1723449052503},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1723449052504},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1723449052504},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1723449052519},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1723449052541},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1723449052549},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1723449052550},{"_id":"themes/next/source/images/apple-touch-icon.png","hash":"64a9ea04f5bb7fef316fa416a7bf9e5e9489c291","modified":1723611091895},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1723449052550},{"_id":"themes/next/source/images/beian.png","hash":"797721756b99b7841cee366f62ac52a1207cdcb7","modified":1723622021068},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1723449052550},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1723449052551},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1723449052551},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1723449052552},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1723449052551},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1723449052552},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1723449052552},{"_id":"themes/next/source/images/favicon-16x16.png","hash":"c3cc1168e2d338fbefc5f8da977a73a7b9a4975c","modified":1723611046112},{"_id":"themes/next/source/images/favicon-32x32.png","hash":"8be81b95697df7f526646702889ca5483f51ccad","modified":1723611046142},{"_id":"themes/next/source/images/logo.svg","hash":"d0ed8b5372385b71b533c985d0a3d84de851dfaf","modified":1723611161346},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1723449052554},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1723449052554},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1723449052554},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1723449052555},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1723449052555},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1723449052556},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1723449052557},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1723449052510},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1723449052513},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1723449052513},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1723449052513},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1723449052514},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1723449052514},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1723449052514},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1723449052515},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1723449052515},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1723449052515},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1723449052516},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1723449052516},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1723449052517},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1723449052517},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1723449052517},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1723449052517},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1723449052518},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1723449052518},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1723449052518},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1723449052519},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"4f907daa560d6c81087a6f13d2768918cc1ff6fb","modified":1723643922647},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1723449052487},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1723449052487},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1723449052488},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1723449052488},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1723449052488},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1723449052489},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1723449052487},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1723449052489},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1723449052490},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1723449052490},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1723449052490},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1723449052491},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1723449052491},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1723449052491},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1723449052492},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1723449052492},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1723449052492},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1723449052493},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1723449052494},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1723449052495},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1723449052495},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1723449052496},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1723449052496},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1723449052497},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1723449052498},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1723449052498},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1723449052499},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1723449052498},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1723449052500},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1723449052500},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"4cc27a45ef0a5b9278a7e404735e844e0291611e","modified":1723643963839},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1723449052502},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1723449052502},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1723449052502},{"_id":"themes/next/layout/_third-party/comments/utterances.swig","hash":"30d87a130c5696e56375d47f6896dabacfd28df1","modified":1723686263652},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1723449052502},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1723449052503},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1723449052503},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1723449052504},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1723449052504},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1723449052505},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1723449052505},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1723449052505},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1723449052506},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1723449052506},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1723449052506},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1723449052507},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1723449052507},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1723449052507},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1723449052548},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1723449052548},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1723449052548},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1723449052549},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1723449052549},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1723449052556},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1723449052555},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1723449052560},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1723449052560},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1723449052510},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1723449052510},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1723449052510},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1723449052511},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1723449052511},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1723449052511},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1723449052512},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1723449052512},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1723449052511},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1723449052512},{"_id":"themes/next/scripts/filters/comment/utterance.js","hash":"b6f7d2d039a69534a5f238fecdb9341361b03e54","modified":1723686313485},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1723449052513},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1723449052520},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1723449052520},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1723449052520},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1723449052526},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1723449052530},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1723449052531},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1723449052542},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1723449052535},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1723449052535},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1723449052536},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1723449052537},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1723449052538},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1723449052538},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1723449052541},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1723449052542},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1723449052538},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1723449052543},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1723449052543},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1723449052543},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1723449052543},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1723449052544},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1723449052544},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1723449052544},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1723449052545},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1723449052545},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1723449052546},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1723449052546},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1723449052545},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1723449052546},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1723449052546},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1723449052547},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1723449052547},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1723449052559},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1723449052557},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1723449052523},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1723449052523},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1723449052524},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1723449052523},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1723449052524},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1723449052524},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1723449052524},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1723449052525},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1723449052525},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1723449052525},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1723449052525},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1723449052526},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1723449052521},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1723449052526},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1723449052521},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1723449052522},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1723449052522},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1723449052527},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1723449052527},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1723449052522},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1723449052527},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1723449052528},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1723449052528},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1723449052529},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1723449052529},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1723449052530},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1723449052529},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1723449052529},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1723449052530},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1723449052530},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1723449052530},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1723449052532},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1723449052532},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1723449052533},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1723449052533},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1723449052533},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1723449052534},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1723449052534},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1723449052534},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1723449052534},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1723449052535},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1723449052536},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1723449052536},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1723449052537},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1723449052537},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1723449052539},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1723449052539},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1723449052539},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1723449052539},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1723449052540},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1723449052540},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1723449052540},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1723449052558},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1723449052559},{"_id":"themes/next/source/images/wechat_channel.jpg","hash":"25d7ebd0b18bb44a9013adbe2b6cd82919f4c291","modified":1723623826348},{"_id":"themes/next/source/images/alipay.jpg","hash":"1d531329226cfd0fde8e936f9019eec57169945b","modified":1723623544434},{"_id":"themes/next/source/images/qq-contact.png","hash":"255274d1b43901c2a5a14daaa540346dc62602c4","modified":1723620583638},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"28bab154ea159faf803c3c832cc7da5eb62c7396","modified":1723623544590},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","hash":"ea8a10b275222aa4fe6004ea90dfb8b7619893ca","modified":1723645068416},{"_id":"source/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","hash":"85ea4d5ef41451cc6d78520f9b8e9c934f3c45f6","modified":1723644997204},{"_id":"public/search.xml","hash":"289543b37584789619da1dc4201bf050bf806187","modified":1723697333137},{"_id":"public/categories/index.html","hash":"9bd650a15599d2168a8cf4d131fb09397e6471cf","modified":1723697333137},{"_id":"public/404/404.html","hash":"636905f1491a94b50deba83e3e8f286e71b6f7c8","modified":1723697333137},{"_id":"public/2024/08/15/Nodejs安装简要建议/index.html","hash":"f5f625cbe1df3c4e7ec7cce42b777a2cc0ee7411","modified":1723697333137},{"_id":"public/2024/08/14/Miracl的配置ForCentos7/index.html","hash":"285f56d25626250b0c7ddac23f6ea3315020e759","modified":1723697333137},{"_id":"public/2024/08/14/RSA涉及算法与数论知识/index.html","hash":"53b2660f820f9cf471c6d866ff7b5f016ca2781e","modified":1723697333137},{"_id":"public/about/index.html","hash":"843a39bc5dfae5196e758eecf745119eb783a5fd","modified":1723697333137},{"_id":"public/2024/08/14/Latex宏包pgfplots做矩形函数图像/index.html","hash":"6bf0cc7208a3496187503ed3a7aff3e9a11354d9","modified":1723697333137},{"_id":"public/2024/08/14/2024武汉ICPC邀请赛VP/index.html","hash":"8fc4737d1fe81ed3553b51cceaf26e3db8927ad7","modified":1723697333137},{"_id":"public/2024/08/14/2024江苏CCPC邀请赛-VP/index.html","hash":"b6336d7fb0f32ba4cb84b9f08fccc3c12928ae74","modified":1723697333137},{"_id":"public/schedule/index.html","hash":"96a1b6e3e15d180f31c9896e491879224ec848be","modified":1723697333137},{"_id":"public/2024/08/14/2024河南CCPC邀请赛-VP/index.html","hash":"4e3f34e64eef2ef2c6ed5932fb584705a61ca524","modified":1723697333137},{"_id":"public/2024/08/14/2024湖北省赛VP/index.html","hash":"538638534eb8d3b61b5e9d2b126cbd1065141f46","modified":1723697333137},{"_id":"public/2024/08/14/Xiaobai93D-E/index.html","hash":"167a64943c24d006160f678f80bc3f0aec1b2f49","modified":1723697333137},{"_id":"public/2024/08/14/Xiaobai94/index.html","hash":"d4b1b5ebf309b5cfb60e98496a81cb0c2b2b97e0","modified":1723697333137},{"_id":"public/2024/08/14/2024黑龙江省赛-VP/index.html","hash":"0335cad028cc2ea008d0accd0cef0c8c5d9f4c56","modified":1723697333137},{"_id":"public/2024/08/14/abc354/index.html","hash":"15959ebd556efa1ba3361d8b9820a2546afff58e","modified":1723697333137},{"_id":"public/2024/08/14/abc353/index.html","hash":"ccced8e4d8663cfd251193a9612bfbcdd0677f41","modified":1723697333137},{"_id":"public/2024/08/14/cf-edu165C/index.html","hash":"4dad63ebb938821576a9ee33c8445f35afbbbf3e","modified":1723697333137},{"_id":"public/tags/index.html","hash":"8810c8d703d5e6962f4ca1690094f6d7b8a5058d","modified":1723697333137},{"_id":"public/2024/08/14/cf-edu165D/index.html","hash":"efc3376616789a1cc3e7ca876fd8b18a27853a69","modified":1723697333137},{"_id":"public/2024/08/14/luogu蓝桥5_19/index.html","hash":"c52e56b475a353aacfaeb67e9b10e05a671a22c2","modified":1723697333137},{"_id":"public/2024/08/14/数学距离问题1/index.html","hash":"cdae5a8ff0e16c9eb80d89cb0f7d69c95cfd61cf","modified":1723697333137},{"_id":"public/2024/08/14/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/index.html","hash":"8c83ce48994105c9b4205f6e4aec1544ee66adfd","modified":1723697333137},{"_id":"public/2024/08/14/树上回文问题/index.html","hash":"b9da61b6807cadb223eaf791afd54a48d3477c0f","modified":1723697333137},{"_id":"public/2024/08/14/状态转移习题4/index.html","hash":"ae6bdeaa26b85ca390dfc1d12489333574ebd82d","modified":1723697333137},{"_id":"public/2024/08/14/状态转移习题3/index.html","hash":"384f4ea2f3005cb6412418eac04614d181f9ec81","modified":1723697333137},{"_id":"public/2024/08/14/思维题习题1/index.html","hash":"7b953b39833b5797020ef846d70a207022e4785b","modified":1723697333137},{"_id":"public/2024/08/14/字符串习题1/index.html","hash":"c57697afee041509809432155f2a36b7b8b46093","modified":1723697333137},{"_id":"public/2024/08/14/状态转移习题2/index.html","hash":"509d1d31cd58a4e661d12dff689a9d80c02eafe2","modified":1723697333137},{"_id":"public/2024/05/13/三种操作系统模拟软件使用手册/index.html","hash":"e37c3f3c56086816a28bab940fd5f15d4a960137","modified":1723697333137},{"_id":"public/archives/index.html","hash":"5b973a1476a1b667569c8f173a50727f4e6ca118","modified":1723697333137},{"_id":"public/2023/08/13/为什么我用Typora——Typora与其他markdown的比较/index.html","hash":"799adf5965d77af83a0ecc78e0e4785b18aef5d1","modified":1723697333137},{"_id":"public/archives/page/2/index.html","hash":"e13cfff5cfffc75e071795f1cbef4bac58b6e2ce","modified":1723697333137},{"_id":"public/2024/08/14/状态转移习题1/index.html","hash":"7a2cd49367ac72bd6be69c7434a9564e6bd56ad6","modified":1723697333137},{"_id":"public/archives/page/3/index.html","hash":"e183d4f259adbbc0a62ae5ecebc028ccce3c870b","modified":1723697333137},{"_id":"public/archives/2023/index.html","hash":"521172c052600c05a7113c4c1efe3fed224226b6","modified":1723697333137},{"_id":"public/archives/2023/08/index.html","hash":"8bfdab3b3a7936063c8eaed46558245f105f1223","modified":1723697333137},{"_id":"public/archives/2024/page/2/index.html","hash":"e970d3ca383bcfdd63b7da6aace4267249dbea68","modified":1723697333137},{"_id":"public/archives/2024/index.html","hash":"e324068bdb226814173a0a8658c8199bfbc7b624","modified":1723697333137},{"_id":"public/archives/2024/05/index.html","hash":"cfaf28688c11a2f04259ac3ab79bf6d7d8fe7406","modified":1723697333137},{"_id":"public/archives/2024/page/3/index.html","hash":"bc8c8729693bf8c6f15d9280f36377d55d80a0ac","modified":1723697333137},{"_id":"public/archives/2024/08/page/2/index.html","hash":"bd7ec6c2652af1b17d44a400452e8a1061b1182a","modified":1723697333137},{"_id":"public/archives/2024/08/index.html","hash":"6273c3aac71ac4ee11866a9ad9597570bb9023d5","modified":1723697333137},{"_id":"public/archives/2024/08/page/3/index.html","hash":"00a2e8de720e5c8977dd8bf66cae0b9d5a679f95","modified":1723697333137},{"_id":"public/en/404/404.html","hash":"8eadbb5cd095bd71901cf40909dff5eec244ad27","modified":1723697333137},{"_id":"public/ja/404/404.html","hash":"6840360f8232105d32bee0beb864f2c791d898b2","modified":1723697333137},{"_id":"public/ru/404/404.html","hash":"3062c029169a6fbb615ad6873e7c256a79d0e4e0","modified":1723697333137},{"_id":"public/en/categories/index.html","hash":"1158bb101a8088dfa64f2190a89ae1e34daa88f9","modified":1723697333137},{"_id":"public/ru/categories/index.html","hash":"26378754c1c940b8c940f08275eb405336c0231f","modified":1723697333137},{"_id":"public/ja/about/index.html","hash":"1070a369dcb1dbdb2cb2593ab6869a10f7615df3","modified":1723697333137},{"_id":"public/en/about/index.html","hash":"579f118a05f52a9c32649a9cacad51299889456d","modified":1723697333137},{"_id":"public/ja/categories/index.html","hash":"8b72ec640e6cdf0d89a738d87f3d623493d55a15","modified":1723697333137},{"_id":"public/en/schedule/index.html","hash":"4dbb3c6478ded95a50bfa206ffd0da283ac7882d","modified":1723697333137},{"_id":"public/ru/about/index.html","hash":"8c0cb4bfafd6c3fcd1c623c32ff4f779ea6b219c","modified":1723697333137},{"_id":"public/ja/schedule/index.html","hash":"77372473e05b2f2a1b356b0c75cdfd749ed7f6c9","modified":1723697333137},{"_id":"public/ru/schedule/index.html","hash":"dbd88ef48d759ac5c9dc612b78f8a89b72e3dce6","modified":1723697333137},{"_id":"public/en/tags/index.html","hash":"d45d7bfc80319fd27d25354f94fcd8d135900d7e","modified":1723697333137},{"_id":"public/ja/tags/index.html","hash":"425468454b8a9fa0eb2b6d11d5411db42b45cd1f","modified":1723697333137},{"_id":"public/ru/tags/index.html","hash":"675a5d9a505496de022f8d7e53dc7e1d1002db39","modified":1723697333137},{"_id":"public/ja/2024/08/14/2024武汉ICPC邀请赛VP/index.html","hash":"e20af5fdb2e1491cae0ca43c4685dba8d5615eb2","modified":1723697333137},{"_id":"public/en/2024/08/14/2024武汉ICPC邀请赛VP/index.html","hash":"ff0d5cc0577389ad4c066ab0df17b89daf2666a2","modified":1723697333137},{"_id":"public/ru/2024/08/14/2024武汉ICPC邀请赛VP/index.html","hash":"a3f29db31d95b3dbb7ba91ed1d6c484c0f343214","modified":1723697333137},{"_id":"public/en/2024/08/14/2024江苏CCPC邀请赛-VP/index.html","hash":"15144b041dc01ac3b6e54203981435d8da0cb33c","modified":1723697333137},{"_id":"public/ja/2024/08/14/2024江苏CCPC邀请赛-VP/index.html","hash":"b8579444ceae9945ebeaca991a3f96396aad690f","modified":1723697333137},{"_id":"public/ru/2024/08/14/2024江苏CCPC邀请赛-VP/index.html","hash":"17b62b16960dfa144a844954c311005cd798699a","modified":1723697333137},{"_id":"public/en/2024/08/14/2024河南CCPC邀请赛-VP/index.html","hash":"aa2b8071317f191f82ba5e61730ad9abba6fe778","modified":1723697333137},{"_id":"public/ja/2024/08/14/2024河南CCPC邀请赛-VP/index.html","hash":"de2e173f2e338c36b0595baf7ca4544e4720adf3","modified":1723697333137},{"_id":"public/ru/2024/08/14/2024河南CCPC邀请赛-VP/index.html","hash":"19d1db99b83970639cc43fdf44932b03769b4871","modified":1723697333137},{"_id":"public/en/2024/08/14/2024湖北省赛VP/index.html","hash":"9e27b296a4ec454f2815bcb6dbec98eb64a2d1bc","modified":1723697333137},{"_id":"public/ja/2024/08/14/2024湖北省赛VP/index.html","hash":"344fe6da1c1d1a43f7d045f5fd990e200712670b","modified":1723697333137},{"_id":"public/ru/2024/08/14/2024湖北省赛VP/index.html","hash":"36643b41f200f59d8d7de1b09f9e50d8c0b0fd91","modified":1723697333137},{"_id":"public/en/2024/08/14/2024黑龙江省赛-VP/index.html","hash":"4f6cd6aa9f193d2f00059130ca6fc0a1006582f8","modified":1723697333137},{"_id":"public/ja/2024/08/14/2024黑龙江省赛-VP/index.html","hash":"f5e4fd6f7abd26ea011730bd1e209fecf0af8163","modified":1723697333137},{"_id":"public/ru/2024/08/14/2024黑龙江省赛-VP/index.html","hash":"6a5995eb4e16680f45fd0891b293b37581bb404e","modified":1723697333137},{"_id":"public/en/2024/08/14/Latex宏包pgfplots做矩形函数图像/index.html","hash":"4f50fc22a991bf7dc20556d40bcf1ebb6789663f","modified":1723697333137},{"_id":"public/ja/2024/08/14/Latex宏包pgfplots做矩形函数图像/index.html","hash":"55be862e63f68971a0b81fc70fe0807d483a2623","modified":1723697333137},{"_id":"public/en/2024/08/15/Nodejs安装简要建议/index.html","hash":"160bbd3040c48fe0a658a5752f507d65c079a464","modified":1723697333137},{"_id":"public/ja/2024/08/15/Nodejs安装简要建议/index.html","hash":"10c6b8cb03609be5034b0fc28eee7be8e32661a7","modified":1723697333137},{"_id":"public/ru/2024/08/14/Latex宏包pgfplots做矩形函数图像/index.html","hash":"5b23f43903da7786a2286da13b240ee59cfef9e3","modified":1723697333137},{"_id":"public/ru/2024/08/15/Nodejs安装简要建议/index.html","hash":"81bc635ce93e11c2237d7207642d997b311070b7","modified":1723697333137},{"_id":"public/en/2024/08/14/Miracl的配置ForCentos7/index.html","hash":"7f2eb5f9d5924198b7e61a0ef63bcc63f59e9967","modified":1723697333137},{"_id":"public/ja/2024/08/14/Miracl的配置ForCentos7/index.html","hash":"950b1354bff67959be6e1bf3975f792e8799945d","modified":1723697333137},{"_id":"public/en/2024/08/14/RSA涉及算法与数论知识/index.html","hash":"211bd5cccc974d45b4a3c7e732597632e275c864","modified":1723697333137},{"_id":"public/ru/2024/08/14/Miracl的配置ForCentos7/index.html","hash":"7a47fe8587742055d5d4f2c0854198e7b61817b1","modified":1723697333137},{"_id":"public/ja/2024/08/14/RSA涉及算法与数论知识/index.html","hash":"9d8e641df5fe3c20087e1fdf74f2d15a34808713","modified":1723697333137},{"_id":"public/ru/2024/08/14/RSA涉及算法与数论知识/index.html","hash":"6d465e732bb73586ff32b8603dac693ae4b0ca61","modified":1723697333137},{"_id":"public/en/2024/08/14/Xiaobai93D-E/index.html","hash":"8b3ee070a8a558a82027a74ded60d9be7b0f5ef9","modified":1723697333137},{"_id":"public/ja/2024/08/14/Xiaobai93D-E/index.html","hash":"0f1502402cc8269c3935201f6021fcab8ab68735","modified":1723697333137},{"_id":"public/ru/2024/08/14/Xiaobai93D-E/index.html","hash":"32e5b0d136a677c38e7c0da0122f571a11cc7bb3","modified":1723697333137},{"_id":"public/ja/2024/08/14/Xiaobai94/index.html","hash":"d4015c5b803a90da4e8fc8b44dc930ab8cd9fd5d","modified":1723697333137},{"_id":"public/en/2024/08/14/Xiaobai94/index.html","hash":"0fb84f5fec47238879bb0baaaab31ac191c6e15b","modified":1723697333137},{"_id":"public/en/2024/08/14/abc353/index.html","hash":"e92bdbac23bccf60fd3d34f018e74e2e2266b5e2","modified":1723697333137},{"_id":"public/ru/2024/08/14/Xiaobai94/index.html","hash":"5a792198ee39cfe37a3c3b96893003029b32b677","modified":1723697333137},{"_id":"public/ja/2024/08/14/abc353/index.html","hash":"a9b4fe435cbd34743cf82c37cd557df269a626a9","modified":1723697333137},{"_id":"public/ru/2024/08/14/abc353/index.html","hash":"fe8b319d618ec167524c2a3303f728fbd3624df4","modified":1723697333137},{"_id":"public/en/2024/08/14/abc354/index.html","hash":"ef37a0280e1b01849ea41582fbcb2541d30b6ac7","modified":1723697333137},{"_id":"public/ru/2024/08/14/abc354/index.html","hash":"ed08f05847ad4b882e69955ecaf633a45ba27453","modified":1723697333137},{"_id":"public/en/2024/08/14/cf-edu165C/index.html","hash":"bef71f6e72d8d47817f5536d2d524f645fa4cfd8","modified":1723697333137},{"_id":"public/ja/2024/08/14/abc354/index.html","hash":"acd0bd8ff60ffce8abec49109bc139f1dde22620","modified":1723697333137},{"_id":"public/ja/2024/08/14/cf-edu165C/index.html","hash":"de7fc071fa42c693968df2c84f0e501e919f60e5","modified":1723697333137},{"_id":"public/en/2024/08/14/cf-edu165D/index.html","hash":"335055c4ec0e319466090366a18ee3643e693092","modified":1723697333137},{"_id":"public/ru/2024/08/14/cf-edu165C/index.html","hash":"5080c39ebf3140cd2ea04fc6a95e79f1bfa47ccc","modified":1723697333137},{"_id":"public/ru/2024/08/14/cf-edu165D/index.html","hash":"1669dfedcc4789dd8f261a31e3dd368cc92b2ebb","modified":1723697333137},{"_id":"public/ja/2024/08/14/cf-edu165D/index.html","hash":"4350d9e1c4db3c2abe1b6ede34095a0319478bfc","modified":1723697333137},{"_id":"public/en/2024/08/14/luogu蓝桥5_19/index.html","hash":"4635c8758524e5245aaf90ed831bf4628ee5c165","modified":1723697333137},{"_id":"public/ja/2024/08/14/luogu蓝桥5_19/index.html","hash":"136182038e91a5b2c21368690b935807fbc2a41a","modified":1723697333137},{"_id":"public/ru/2024/08/14/luogu蓝桥5_19/index.html","hash":"5ec4ab72ba4e75fc97d68f1ab1f588ee23b60026","modified":1723697333137},{"_id":"public/ja/2024/05/13/三种操作系统模拟软件使用手册/index.html","hash":"02ab1dcd197db10a828eb8c477b69739fe9604c7","modified":1723697333137},{"_id":"public/en/2024/05/13/三种操作系统模拟软件使用手册/index.html","hash":"0b668209b450801ff558779bf01e118598f0ccc0","modified":1723697333137},{"_id":"public/en/2023/08/13/为什么我用Typora——Typora与其他markdown的比较/index.html","hash":"fee13a71eb29812f6b6559753c920c28a855099c","modified":1723697333137},{"_id":"public/ru/2024/05/13/三种操作系统模拟软件使用手册/index.html","hash":"c7c88f01674b03b78e2b7ecb44f71aef2eceb2c3","modified":1723697333137},{"_id":"public/ja/2023/08/13/为什么我用Typora——Typora与其他markdown的比较/index.html","hash":"ad551c3b11828d86465a6cdb4b8f370052211ae8","modified":1723697333137},{"_id":"public/en/2024/08/14/字符串习题1/index.html","hash":"e1b751195a8babeaf9612765437423b841853adc","modified":1723697333137},{"_id":"public/ru/2023/08/13/为什么我用Typora——Typora与其他markdown的比较/index.html","hash":"9aff1c6cee7da8e9bc4865fde306a40247b1e7ab","modified":1723697333137},{"_id":"public/ja/2024/08/14/字符串习题1/index.html","hash":"857d7fcd57cc82449a9b06c09ae33a670073463b","modified":1723697333137},{"_id":"public/ru/2024/08/14/字符串习题1/index.html","hash":"6e487e86992a65e01a7e8698dd973f525b682fd9","modified":1723697333137},{"_id":"public/en/2024/08/14/思维题习题1/index.html","hash":"92c4958c27e40461d63a6b6a1312a0e49d4679e2","modified":1723697333137},{"_id":"public/ru/2024/08/14/思维题习题1/index.html","hash":"d4c32a559ccc850e36d3302caddc970d3be8d87f","modified":1723697333137},{"_id":"public/ja/2024/08/14/思维题习题1/index.html","hash":"f25b5dcc56d0486ba2ffaded09df019c0102d9e0","modified":1723697333137},{"_id":"public/ja/2024/08/14/数学距离问题1/index.html","hash":"a1816a9bcdc24bf1a894e558194496943c599b5c","modified":1723697333137},{"_id":"public/en/2024/08/14/数学距离问题1/index.html","hash":"31430f9d8a7d95ce6bae2dda43736ce3c47f5d50","modified":1723697333137},{"_id":"public/ru/2024/08/14/数学距离问题1/index.html","hash":"bf7537c0d832b360a51ffb4a4327217024d3e5c3","modified":1723697333137},{"_id":"public/ja/2024/08/14/树上回文问题/index.html","hash":"ea2644889a0a200353778c6f2933d8574b0ae3b5","modified":1723697333137},{"_id":"public/en/2024/08/14/树上回文问题/index.html","hash":"fbac495b638039210e8d40f3caff46597d677f46","modified":1723697333137},{"_id":"public/en/2024/08/14/状态转移习题1/index.html","hash":"08b5d7a51e816abd6964b509268433348ae985aa","modified":1723697333137},{"_id":"public/ru/2024/08/14/树上回文问题/index.html","hash":"c5f19feeb9daa4c7043c858176a78ec087c7edf8","modified":1723697333137},{"_id":"public/ja/2024/08/14/状态转移习题1/index.html","hash":"03d1627c52dc68cf84274f29c4826abbe1f42e03","modified":1723697333137},{"_id":"public/en/2024/08/14/状态转移习题2/index.html","hash":"3e5eb65ca199656704baa4576c0624a8cd9c4557","modified":1723697333137},{"_id":"public/ru/2024/08/14/状态转移习题1/index.html","hash":"d480724dd57ea6a7eff388acb036b7154b0f0bf3","modified":1723697333137},{"_id":"public/ja/2024/08/14/状态转移习题2/index.html","hash":"554c1143a3c47d8734b529f33b8b84ad81866c68","modified":1723697333137},{"_id":"public/en/2024/08/14/状态转移习题3/index.html","hash":"29b330769b97e24b74b29ba2f72b62d2963ae87a","modified":1723697333137},{"_id":"public/ja/2024/08/14/状态转移习题3/index.html","hash":"93c15452dbf73a4d4bf86a66e450b5f0b6ec1159","modified":1723697333137},{"_id":"public/ru/2024/08/14/状态转移习题3/index.html","hash":"c8dbfb720f3e608ad82603e8ceadb24d24d63fbc","modified":1723697333137},{"_id":"public/en/2024/08/14/状态转移习题4/index.html","hash":"206c50723c544525c1948b69e1cadde958e36d29","modified":1723697333137},{"_id":"public/ja/2024/08/14/状态转移习题4/index.html","hash":"6728a25807b932a5d4560205f126f6ff062a7e97","modified":1723697333137},{"_id":"public/ru/2024/08/14/状态转移习题2/index.html","hash":"fcf54d6688c29d50d9b52d7da34d19a787c648b5","modified":1723697333137},{"_id":"public/en/2024/08/14/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/index.html","hash":"1ba59eb5dcc52f7bd18a92e0cbecf88eb37aa7ef","modified":1723697333137},{"_id":"public/ru/2024/08/14/状态转移习题4/index.html","hash":"c51948fcdc64d5a757a46edef6f07bdfc331f88e","modified":1723697333137},{"_id":"public/ja/2024/08/14/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/index.html","hash":"90a244c84e92824b2ac0cc3b6f2bba479cb668fb","modified":1723697333137},{"_id":"public/en/archives/index.html","hash":"a059685785b456e64bca2acd41e6d2e3272ced6e","modified":1723697333137},{"_id":"public/ru/2024/08/14/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估/index.html","hash":"2f8424beb131f75db8dd7397d89bdcd09ea3ee4b","modified":1723697333137},{"_id":"public/ru/archives/index.html","hash":"0cb977a3bcbe96a2b5830c2b36a182951bf63012","modified":1723697333137},{"_id":"public/ja/archives/index.html","hash":"3b575d0cc8aca7c87addcfd5e2028d7dea764529","modified":1723697333137},{"_id":"public/en/archives/page/2/index.html","hash":"577ac043cfb5906fa7b5170368f65ddbab6a9cd2","modified":1723697333137},{"_id":"public/ja/archives/page/2/index.html","hash":"bae8a5b722d220c94fa428432ad7c376514938d6","modified":1723697333137},{"_id":"public/en/archives/page/3/index.html","hash":"d2dd4b2112f793bbabd0ad899718e68855fb7528","modified":1723697333137},{"_id":"public/ru/archives/page/2/index.html","hash":"d70f9e270b44841ae8794155a4b85cd812ad2e1c","modified":1723697333137},{"_id":"public/ja/archives/page/3/index.html","hash":"ba433cc4b7821bb7efa992227ffa97344481639f","modified":1723697333137},{"_id":"public/en/archives/2023/index.html","hash":"0f32044899523264bef1f9033faab04c804ca39c","modified":1723697333137},{"_id":"public/ru/archives/page/3/index.html","hash":"f9e5dabbd3e1306b7f2d8e93760481156dce2067","modified":1723697333137},{"_id":"public/ja/archives/2023/index.html","hash":"3908e784124d5a4346d5c0bcc4676f85d987f382","modified":1723697333137},{"_id":"public/ru/archives/2023/index.html","hash":"a4c8654d2ff3c70dbc38b0b227f8d58fdc98969c","modified":1723697333137},{"_id":"public/en/archives/2023/08/index.html","hash":"201f0b10d557b5ca6a37d1969153ac7db10338c0","modified":1723697333137},{"_id":"public/ru/archives/2023/08/index.html","hash":"9a1e6b87d27136bde02b66408dbb45124f06d24d","modified":1723697333137},{"_id":"public/en/archives/2024/index.html","hash":"6d813599f11c2fa5f1abff8e16e7c4d0372f161a","modified":1723697333137},{"_id":"public/ja/archives/2023/08/index.html","hash":"6607ca37f9d4b4f40707256541929810c4674683","modified":1723697333137},{"_id":"public/ru/archives/2024/index.html","hash":"32bdedb219aaf0cf41b947f81df9d00bf08a0f82","modified":1723697333137},{"_id":"public/ja/archives/2024/index.html","hash":"88f32c53d69bef7665ee6a50df6e72c59a2aa288","modified":1723697333137},{"_id":"public/en/archives/2024/page/2/index.html","hash":"7ba2d54b6f09443c3fc2f6a06d7eaec715bce487","modified":1723697333137},{"_id":"public/ja/archives/2024/page/2/index.html","hash":"115a88d1e99c110687ab7f5ada27517f2247d7aa","modified":1723697333137},{"_id":"public/ru/archives/2024/page/2/index.html","hash":"98aa00c9731c14a25097aa29d3cd3eddb91a9ed3","modified":1723697333137},{"_id":"public/en/archives/2024/page/3/index.html","hash":"cc13108c2d084b20fa4b45d1da818567d6298a82","modified":1723697333137},{"_id":"public/ja/archives/2024/page/3/index.html","hash":"ebb8702d641939fcbadcc55566d704459c0031d1","modified":1723697333137},{"_id":"public/ru/archives/2024/page/3/index.html","hash":"e45249d0fe948d5045608df0193877547e564e3e","modified":1723697333137},{"_id":"public/en/archives/2024/05/index.html","hash":"7774047b81f2aadb7160e0f1d6247b4ae8799bf2","modified":1723697333137},{"_id":"public/ru/archives/2024/05/index.html","hash":"0ad794254646940ededae5714c140dad3f897732","modified":1723697333137},{"_id":"public/ja/archives/2024/05/index.html","hash":"3dea4e9a7679c6dfbed5e49f9331ad029b53bd0c","modified":1723697333137},{"_id":"public/ja/archives/2024/08/index.html","hash":"28bc41f89500084285636e48a1a582150b16438c","modified":1723697333137},{"_id":"public/en/archives/2024/08/index.html","hash":"df41ec6fbb6827228e10767371e415915b33bbff","modified":1723697333137},{"_id":"public/ru/archives/2024/08/index.html","hash":"14a5c03a3393409683778bc1240dbbae9d2aa190","modified":1723697333137},{"_id":"public/en/archives/2024/08/page/2/index.html","hash":"0e962fc4679d9f90230eeff034f1a82a4302d9ed","modified":1723697333137},{"_id":"public/ja/archives/2024/08/page/2/index.html","hash":"7cf7eef45f25931445730620da3cb9d8701713ad","modified":1723697333137},{"_id":"public/en/archives/2024/08/page/3/index.html","hash":"626bb671bbf08e47ba3c33000f080515ed9ec3d7","modified":1723697333137},{"_id":"public/ja/archives/2024/08/page/3/index.html","hash":"281c5de6c0678043dd3dc83ecb2c7e3f938b4b2c","modified":1723697333137},{"_id":"public/ru/archives/2024/08/page/2/index.html","hash":"a4ff9a89295b59c38da6944541d714621883df64","modified":1723697333137},{"_id":"public/ru/archives/2024/08/page/3/index.html","hash":"0fa441bc4fa2dfde8035bbbf21551581359e2509","modified":1723697333137},{"_id":"public/ja/tags/icpc/index.html","hash":"a970bbdf51874632863a0c608477617a57a025af","modified":1723697333137},{"_id":"public/en/tags/icpc/index.html","hash":"f41cf76ec6964e53567137bf867abb5d1907d9b3","modified":1723697333137},{"_id":"public/en/tags/ccpc/index.html","hash":"7a7ab691c32b0243b2cbeaf8fe1541d5d3948f76","modified":1723697333137},{"_id":"public/ru/tags/icpc/index.html","hash":"0bbb938a3b7e66a95eaeb80780c88a9b0d85ed17","modified":1723697333137},{"_id":"public/ja/tags/ccpc/index.html","hash":"bc126e12d27a7afc0a18055c7fd99545b6137e9a","modified":1723697333137},{"_id":"public/en/tags/Latex/index.html","hash":"6b5abfc0d44c57af4edeff36a6c55844f3513673","modified":1723697333137},{"_id":"public/ru/tags/ccpc/index.html","hash":"cc8d98d9e89953a3d1b6dbc2b4a2ce822f4cc7f0","modified":1723697333137},{"_id":"public/ru/tags/Latex/index.html","hash":"17d606c155c76f2411a6dc9dee8c813de3148022","modified":1723697333137},{"_id":"public/ja/tags/Latex/index.html","hash":"36601d73c16c94357ceee467a834c6619d610836","modified":1723697333137},{"_id":"public/en/tags/图像处理/index.html","hash":"5a3e7de537d84f20ac59300f83916232ed90a094","modified":1723697333137},{"_id":"public/ja/tags/图像处理/index.html","hash":"335c9f0e14897454596e59bdf195346355b8284f","modified":1723697333137},{"_id":"public/ru/tags/图像处理/index.html","hash":"7f28e8d11936862dc5c72bb440e2ba2162dfa58d","modified":1723697333137},{"_id":"public/en/tags/nodejs/index.html","hash":"4ca9e27aa06d51967793974c39cb9402b139caf4","modified":1723697333137},{"_id":"public/ja/tags/nodejs/index.html","hash":"02314d93daaacac86a5fb3aa6aa7b7390745f301","modified":1723697333137},{"_id":"public/ru/tags/nodejs/index.html","hash":"c3fac5ef813029793e07d7d005cf616d8cb1d864","modified":1723697333137},{"_id":"public/en/tags/gcc/index.html","hash":"9afa2964c5475fa67556afd37f68a1ff286ad7fb","modified":1723697333137},{"_id":"public/ru/tags/gcc/index.html","hash":"4c388110d9b0ff27205c93c76362918fb96007e4","modified":1723697333137},{"_id":"public/en/tags/linux/index.html","hash":"4291cb9b2f9dcc8ca6bb7071ec0ae1bcf63b54c4","modified":1723697333137},{"_id":"public/ja/tags/gcc/index.html","hash":"b6f096cda45819f64f9c8c547b11d112b3259b24","modified":1723697333137},{"_id":"public/ja/tags/linux/index.html","hash":"9d4a3b03ebbc900b1fed594fadd031e0053dd8e9","modified":1723697333137},{"_id":"public/en/tags/信息安全/index.html","hash":"a2ddaace6cbd7762ca7e82c20953be627d12c7aa","modified":1723697333137},{"_id":"public/ru/tags/linux/index.html","hash":"a47c4136227086d4b9298cc6d628cd555d9477c8","modified":1723697333137},{"_id":"public/ja/tags/信息安全/index.html","hash":"f6dd4baf24ec7c8ce514c85e49b4099cd6416247","modified":1723697333137},{"_id":"public/ru/tags/信息安全/index.html","hash":"7eff633aeaac178ffac042c30f130db401a8caf8","modified":1723697333137},{"_id":"public/en/tags/软件/index.html","hash":"e3fb214e3acd98c367e0ad644c7c65afffaad1dc","modified":1723697333137},{"_id":"public/ja/tags/软件/index.html","hash":"e199bccd0096786fc6f9be91300214b3d6c98e21","modified":1723697333137},{"_id":"public/en/tags/Miracl/index.html","hash":"1e2105154bf2c1c1dbc6600b78538f4e081e11b9","modified":1723697333137},{"_id":"public/ru/tags/软件/index.html","hash":"452e4f5acb648eb5d0e1ae15883c42cfcc209e95","modified":1723697333137},{"_id":"public/ru/tags/Miracl/index.html","hash":"4a57f9a097404795a4b903bffb9bdffbe1226866","modified":1723697333137},{"_id":"public/ja/tags/Miracl/index.html","hash":"a8d3afdd4073d3ae54d8b6295110d388d4625c9c","modified":1723697333137},{"_id":"public/en/tags/数学/index.html","hash":"dc18b8405dd173b64d722d37e95e49ad2ff29fc6","modified":1723697333137},{"_id":"public/ru/tags/数学/index.html","hash":"393f6b3e13bb1d9a7f33f9cf21a0d8b48d7d587e","modified":1723697333137},{"_id":"public/ja/tags/数学/index.html","hash":"8d0e09ff6b1d6932eb1d01bff630515816a6f421","modified":1723697333137},{"_id":"public/en/tags/newcoder/index.html","hash":"10302959fde3db58dc2a57dc17458ebc4d1813ae","modified":1723697333137},{"_id":"public/ja/tags/newcoder/index.html","hash":"963483e894442bfd5464e04ebcf239596f3063b3","modified":1723697333137},{"_id":"public/ru/tags/newcoder/index.html","hash":"a4054aeff81224d0521bf2d765eb931304102e7e","modified":1723697333137},{"_id":"public/en/tags/算法/index.html","hash":"3550bc5261f6f3c6c65a99ee0471fb9e58333a13","modified":1723697333137},{"_id":"public/ja/tags/算法/index.html","hash":"eb1f04caf24b6b18e487a94feab31ff6077ca840","modified":1723697333137},{"_id":"public/ru/tags/算法/index.html","hash":"cd6a7adfebd1deb8b132154b506172e5d232d5df","modified":1723697333137},{"_id":"public/en/tags/算法/page/2/index.html","hash":"05c53718a7fa903118959e3353523a0acb3a716b","modified":1723697333137},{"_id":"public/ja/tags/算法/page/2/index.html","hash":"6a293bdb2f7ade81402585332d375d2191673c6a","modified":1723697333137},{"_id":"public/ru/tags/算法/page/2/index.html","hash":"c6f8f5ba68ffd94c169eb17306ea952ed0ad8f34","modified":1723697333137},{"_id":"public/en/tags/思维题/index.html","hash":"de542e83c534c4b5939a45b04c7074f5d10d3d07","modified":1723697333137},{"_id":"public/ja/tags/思维题/index.html","hash":"19d860308fc7f0bc888654a90262a75a0e4c3ed2","modified":1723697333137},{"_id":"public/ru/tags/思维题/index.html","hash":"9ee7b1e46cf054b661d81b40f9132ba99977f30f","modified":1723697333137},{"_id":"public/en/tags/模运算/index.html","hash":"083a05320f25d280efec534358fb3f048e739986","modified":1723697333137},{"_id":"public/ja/tags/模运算/index.html","hash":"220e2489ef7e2bdfc8e5bb3983cd85521283550e","modified":1723697333137},{"_id":"public/ru/tags/模运算/index.html","hash":"fba0876f74d3f51f5d78bc7e8ad29f4b01a7e4fb","modified":1723697333137},{"_id":"public/en/tags/atcoder/index.html","hash":"f59a753a07a26cd111b125a0bdbad2f1e2b61c04","modified":1723697333137},{"_id":"public/ja/tags/atcoder/index.html","hash":"ca506c61f53ab683dc29ea8a220e313fb1948258","modified":1723697333137},{"_id":"public/ru/tags/atcoder/index.html","hash":"feb8d16f4fa120b6fd5f9508e279ec14ee58b9a1","modified":1723697333137},{"_id":"public/en/tags/贪心，状态转移/index.html","hash":"49e9b5da6663af47fe016c8cbdffa31f64a922d7","modified":1723697333137},{"_id":"public/ja/tags/贪心，状态转移/index.html","hash":"bc1bddff36442164ebae2e77b6bd369b1676fa97","modified":1723697333137},{"_id":"public/ru/tags/贪心，状态转移/index.html","hash":"f4228873b8f538b526cdf674db3863cf08979ed1","modified":1723697333137},{"_id":"public/en/tags/博弈论/index.html","hash":"21dd2b2869112869911856316bb3481993038715","modified":1723697333137},{"_id":"public/ja/tags/博弈论/index.html","hash":"ef3b9b317065eddf22521436e1d1e0740589c13a","modified":1723697333137},{"_id":"public/ru/tags/博弈论/index.html","hash":"a66ebc8d0bdfe7c079ea682e2bd92ff8b1c32f6d","modified":1723697333137},{"_id":"public/en/tags/不等式/index.html","hash":"68ec8355ab1eb6cf3bfc5d860129e13f984a48b1","modified":1723697333137},{"_id":"public/ja/tags/不等式/index.html","hash":"a7a08d98d841a3445f1c82eb9d853c327181070b","modified":1723697333137},{"_id":"public/ru/tags/不等式/index.html","hash":"49f843c4de46099f993354dd8fb931d66c03727c","modified":1723697333137},{"_id":"public/en/tags/luogu/index.html","hash":"ba0aedb21a0286b9441e8b9f8f1a3b950f7a673b","modified":1723697333137},{"_id":"public/ja/tags/luogu/index.html","hash":"5c73ae575d3d26e1a2de29c147a6ddbb6a8f7436","modified":1723697333137},{"_id":"public/ru/tags/luogu/index.html","hash":"3d4f937f452a127aeca0dcd65d332235c9d5e0e4","modified":1723697333137},{"_id":"public/en/tags/开发/index.html","hash":"ef2a6208d1c7b2ff700089e44949fc129ffd3fc6","modified":1723697333137},{"_id":"public/ja/tags/开发/index.html","hash":"2d4f93cc19eb071b2c9bd4ccc348e4d8fe54eee3","modified":1723697333137},{"_id":"public/ru/tags/开发/index.html","hash":"b05a10fe96c7a8c695de51486628c46c5bef19c1","modified":1723697333137},{"_id":"public/en/tags/文档/index.html","hash":"0862c0c0b8c72c112b25180746fee3ed7caac6d1","modified":1723697333137},{"_id":"public/ja/tags/文档/index.html","hash":"804971591907a15dc6efd65894f04f59b42509d7","modified":1723697333137},{"_id":"public/ru/tags/文档/index.html","hash":"8b61c9e50445c558a1a051eeff8a7b9bc431287d","modified":1723697333137},{"_id":"public/en/tags/学校/index.html","hash":"030368a5277fc6be4f90c5f0a2a3e68e4b77ad07","modified":1723697333137},{"_id":"public/ja/tags/学校/index.html","hash":"b202ba1374cb300d6841b3d3a08c595ea85dbfb5","modified":1723697333137},{"_id":"public/ru/tags/学校/index.html","hash":"3c4e34f0e22ca5f8160f6d4f105425315b839872","modified":1723697333137},{"_id":"public/en/tags/Typora/index.html","hash":"2a5d490119f632986897cc862c97eb981416ede4","modified":1723697333137},{"_id":"public/ja/tags/Typora/index.html","hash":"79cb5d8151a5b9778a6eae40c0b9a0698a0c86ff","modified":1723697333137},{"_id":"public/ru/tags/Typora/index.html","hash":"cf44efb1a9ebd4d86fcc28f1b521cad2bad89c70","modified":1723697333137},{"_id":"public/en/tags/Markdown/index.html","hash":"2417dd193ea7e75dd1db22401109ee0edc70b5d6","modified":1723697333137},{"_id":"public/ja/tags/Markdown/index.html","hash":"21d365131369bacdc725dca5093b816c62529ba3","modified":1723697333137},{"_id":"public/ru/tags/Markdown/index.html","hash":"3c44113300e61dcce61616a84f5dc409902dbdd3","modified":1723697333137},{"_id":"public/en/tags/随笔/index.html","hash":"f03da40f61e0ce606858607baeff1a35065793db","modified":1723697333137},{"_id":"public/ja/tags/随笔/index.html","hash":"60fe8834513e42fb30d410184be33a57d789d5f7","modified":1723697333137},{"_id":"public/ru/tags/随笔/index.html","hash":"15547de3077f18135c2db7fbec72fd754c787906","modified":1723697333137},{"_id":"public/en/tags/子序列自动机/index.html","hash":"6c2036d148638f519d38b04b68331fcfddfe3c30","modified":1723697333137},{"_id":"public/ja/tags/子序列自动机/index.html","hash":"ccb1ff7514fa343dfa7425550b2f46c795ae4d55","modified":1723697333137},{"_id":"public/ru/tags/子序列自动机/index.html","hash":"2ec1c9788ea588fbe146f8d2578647caf58ecf98","modified":1723697333137},{"_id":"public/en/tags/坐标系转换/index.html","hash":"e2a9875aba124bcf3a463c531f09f9666cf6dbf5","modified":1723697333137},{"_id":"public/ja/tags/坐标系转换/index.html","hash":"008dd9735d949d99d20fbe1ff195c1fe155c2fa6","modified":1723697333137},{"_id":"public/ru/tags/坐标系转换/index.html","hash":"dd68d1ca4fd9255985753ca72f2293a74df8bbca","modified":1723697333137},{"_id":"public/en/tags/几何问题/index.html","hash":"30c25124546c2f655772d4f7f3beeef13638838b","modified":1723697333137},{"_id":"public/ja/tags/几何问题/index.html","hash":"1f4fa4701bf600a220a30b5f884935e844d1f511","modified":1723697333137},{"_id":"public/ru/tags/几何问题/index.html","hash":"a5019339d39e09736719831cc69c77651cc18095","modified":1723697333137},{"_id":"public/en/tags/树问题，哈希算法/index.html","hash":"bdca7f3282b07b70af1c3b56a4a1086286e68c53","modified":1723697333137},{"_id":"public/ja/tags/树问题，哈希算法/index.html","hash":"c3eddc5b15b4180062a838e5d61d41bdd7ebc690","modified":1723697333137},{"_id":"public/ru/tags/树问题，哈希算法/index.html","hash":"00d250e96f9604bfae57372f8a174a3f04ca491a","modified":1723697333137},{"_id":"public/en/tags/状态转移/index.html","hash":"e34a391059777683cfb2d0356d77866f149ace28","modified":1723697333137},{"_id":"public/ja/tags/状态转移/index.html","hash":"81cb348768f1d8ce35e2fa3aa3500d36e04a0aa0","modified":1723697333137},{"_id":"public/ru/tags/状态转移/index.html","hash":"ae1d49ab238204f3d997f0ae297d1a9d85495981","modified":1723697333137},{"_id":"public/en/tags/异或问题/index.html","hash":"936991408cfc6b5fa1d0a0d0b42022e32e45027d","modified":1723697333137},{"_id":"public/ja/tags/异或问题/index.html","hash":"0c87a633d4f655b16d7eeae41e4a9a1750e9c107","modified":1723697333137},{"_id":"public/ru/tags/异或问题/index.html","hash":"b5dfe80bbd1876232d8a8a9e869b1ce10feede1d","modified":1723697333137},{"_id":"public/en/tags/离散化/index.html","hash":"2f4a2c27dbc4a03193e00ed9dd591fa52da7a0a6","modified":1723697333137},{"_id":"public/ja/tags/离散化/index.html","hash":"50640eb666f7b3d62f2b0d877d37b12f0f206f20","modified":1723697333137},{"_id":"public/ru/tags/离散化/index.html","hash":"1cfe28b679b1e25191289dc660e7c89e04ae8ff6","modified":1723697333137},{"_id":"public/en/tags/加密算法/index.html","hash":"af82fce6f5d73ccb6cb82acc6b756c698ba40ac1","modified":1723697333137},{"_id":"public/ja/tags/加密算法/index.html","hash":"22acc5f6f988d0f2add184bfeb696c85c9a66ea5","modified":1723697333137},{"_id":"public/ru/tags/加密算法/index.html","hash":"d995a547ce01fefbd5923fcc139e5b5424b56322","modified":1723697333137},{"_id":"public/en/tags/ECC/index.html","hash":"b7ccd8212e145786e8201dfabbbf2b76c6355c62","modified":1723697333137},{"_id":"public/ja/tags/ECC/index.html","hash":"eecd2b5bf0fefd1a4baf666c683a8beb0fdb7dc4","modified":1723697333137},{"_id":"public/ru/tags/ECC/index.html","hash":"19650e256bb2d2b8efe5b5fea4975fc99d722a41","modified":1723697333137},{"_id":"public/categories/比赛/index.html","hash":"0bbd00f7763ef8f8c901ab3e19845aada187d170","modified":1723697333137},{"_id":"public/categories/比赛/模拟赛/index.html","hash":"f3a0d216771187514a2bcd92781733bd1dc7be78","modified":1723697333137},{"_id":"public/categories/软件/index.html","hash":"8ff489f48df692f12c5a15b560b5aaaae8303db4","modified":1723697333137},{"_id":"public/categories/信息安全/index.html","hash":"c5f5cc3c7caa6cf3d5eb32769ba0d16b4ec72872","modified":1723697333137},{"_id":"public/categories/比赛/日常赛/index.html","hash":"f55741a12f2e344d34774e96a41b353fed53f361","modified":1723697333137},{"_id":"public/categories/比赛/模拟赛/icpc省赛/index.html","hash":"fabeb711206a3d1848a094e6f7f24ddf9bdc2cbf","modified":1723697333137},{"_id":"public/categories/算法/index.html","hash":"3ad16ece0c3175d4cee05577d0b4184ad3240346","modified":1723697333137},{"_id":"public/categories/算法/page/2/index.html","hash":"f1c88319f34306a36290240c3b83b8e2d97b55d8","modified":1723697333137},{"_id":"public/categories/比赛/模拟赛/icpc邀请赛/index.html","hash":"568028019a882224b246ccc69d38ddefb9350e5f","modified":1723697333137},{"_id":"public/categories/比赛/模拟赛/蓝桥模拟/index.html","hash":"285836440e212f419fc7a931e08db5d67d2c0d14","modified":1723697333137},{"_id":"public/categories/软件/工具类软件/index.html","hash":"42ac014ec636e43c8730dda2e69641805311a803","modified":1723697333137},{"_id":"public/categories/软件/手册/index.html","hash":"227598ce6307461043210119145fa0ffc64bafbc","modified":1723697333137},{"_id":"public/categories/软件/编辑器/index.html","hash":"ffdbeff78e392ab02137555cb8d0df5e491c2d1b","modified":1723697333137},{"_id":"public/categories/比赛/模拟赛/ccpc邀请赛/index.html","hash":"ec74d87f14a1e100332ed5de807540d54c23b6c9","modified":1723697333137},{"_id":"public/categories/软件/经典库/index.html","hash":"0778bbb4082651427bef0e9fa26825b884ffda88","modified":1723697333137},{"_id":"public/categories/信息安全/加密算法/index.html","hash":"1582f88979ab3cf60ea8a32e806d3274a8a885fb","modified":1723697333137},{"_id":"public/categories/比赛/日常赛/newcoder/index.html","hash":"3c7a81d69e46979df082b62d13be0fb309915589","modified":1723697333137},{"_id":"public/categories/算法/思维题/index.html","hash":"c4206f9de412aec6400834eb2b5e579eb4c6a061","modified":1723697333137},{"_id":"public/categories/比赛/日常赛/atcoder/index.html","hash":"98f33a140d274b940ab139c1fe67d896fd6c0934","modified":1723697333137},{"_id":"public/categories/算法/数学/index.html","hash":"e3456009e2ce11a4b897d69294f347c28dd7d7a8","modified":1723697333137},{"_id":"public/categories/软件/编辑器/Markdown/index.html","hash":"dbb5ed5eabc4ce5d255bb907342d786aed6bd0d3","modified":1723697333137},{"_id":"public/categories/算法/字符串/index.html","hash":"cc99ba8774ae7c039e19dfc6bec66842fc964b7b","modified":1723697333137},{"_id":"public/categories/软件/经典库/前端/index.html","hash":"a00a0042033ab98a965a0544f1344adedc1e3679","modified":1723697333137},{"_id":"public/categories/算法/图论/index.html","hash":"ca2f4ba2db7d09b1c1f3d3a92efc5cb94c7de68b","modified":1723697333137},{"_id":"public/categories/软件/经典库/信息安全/index.html","hash":"ca30552036dda621105522610d82d5f9cbc10eca","modified":1723697333137},{"_id":"public/categories/算法/状态转移/index.html","hash":"a2fd9aa65225347d70db2515aecb91040602029a","modified":1723697333137},{"_id":"public/categories/信息安全/加密算法/数学/index.html","hash":"24b9cbcff1ad68bcfbee7a1afce159a8934def50","modified":1723697333137},{"_id":"public/categories/算法/思维题/模运算/index.html","hash":"efa425a7165b88adf3147fa82d42889b4f3d8baa","modified":1723697333137},{"_id":"public/categories/算法/思维题/贪心/index.html","hash":"4d41c3830241f592a8a4e898a4bfec1d23cea185","modified":1723697333137},{"_id":"public/categories/算法/数学/博弈论/index.html","hash":"31c0b23e892e6f4a37e5f565c20c01a69e979871","modified":1723697333137},{"_id":"public/categories/算法/字符串/子序列自动机/index.html","hash":"a292eb2c2d63707983fc957a625baab5514bb45c","modified":1723697333137},{"_id":"public/categories/软件/经典库/前端/node/index.html","hash":"3ab1927da1567137e50941598d07114b14ea779a","modified":1723697333137},{"_id":"public/categories/算法/图论/图论中的回文问题/index.html","hash":"40a62eaa9901238dad71ecdae2b19cc392d9b372","modified":1723697333137},{"_id":"public/categories/算法/状态转移/状态转移中的异或问题/index.html","hash":"47080a2091922d82354163124fe62ec6d22514fb","modified":1723697333137},{"_id":"public/categories/算法/状态转移/复杂状态转移与优化/index.html","hash":"49dcc20fd30d8df311a25d49da1a4c9a170b7868","modified":1723697333137},{"_id":"public/categories/学术/index.html","hash":"b6a97a345c4e521f4102435ec8287bf590af64ce","modified":1723697333137},{"_id":"public/index.html","hash":"1b964d8fb67d4abc172949243a67b3f259645234","modified":1723697333137},{"_id":"public/categories/学术/综述/index.html","hash":"50cbe52173467d873ee61841842edc7d60a55054","modified":1723697333137},{"_id":"public/page/3/index.html","hash":"f3eff515b0864fd9bf57722877d65dc4a24aae31","modified":1723697333137},{"_id":"public/page/2/index.html","hash":"ad0ce6bd8e611957471d703314e00c0ad0939a2f","modified":1723697333137},{"_id":"public/tags/ccpc/index.html","hash":"897b1348b2fb4a2c0cd59550352c743885031f3b","modified":1723697333137},{"_id":"public/tags/icpc/index.html","hash":"23533f242f9c894785979068705b9f08da42b899","modified":1723697333137},{"_id":"public/tags/Latex/index.html","hash":"3c52d927ce2186b41a0edc7a198a823de82c2747","modified":1723697333137},{"_id":"public/tags/图像处理/index.html","hash":"1e34b03cce39aea1547f8c7f82884e13e6cc01bd","modified":1723697333137},{"_id":"public/tags/nodejs/index.html","hash":"27e40ae9ab04723e4c13fcba156d449b7285693b","modified":1723697333137},{"_id":"public/tags/gcc/index.html","hash":"aab04c873e99a24b32d3714af4fb5e5a8468897e","modified":1723697333137},{"_id":"public/tags/linux/index.html","hash":"5962d2e28f8d6d79bec479585e206cd90f8bc2cd","modified":1723697333137},{"_id":"public/tags/信息安全/index.html","hash":"26c57df1e73b5eac785531b218187a0c42d9f50d","modified":1723697333137},{"_id":"public/tags/软件/index.html","hash":"f3e6cc1861e9f46b633c8ba29474217c125b6b32","modified":1723697333137},{"_id":"public/tags/Miracl/index.html","hash":"eb8a57e249e88fd573a74385823773b2ea2974ac","modified":1723697333137},{"_id":"public/tags/数学/index.html","hash":"2b04b2ebfa283a1d85ceb3044c927556f7cc8f8e","modified":1723697333137},{"_id":"public/tags/newcoder/index.html","hash":"e4a06074e10695e34bf34e3bfd8362e85401ef2a","modified":1723697333137},{"_id":"public/tags/算法/index.html","hash":"b6bc3a60e8a3b883457d7d6e418f4b7f325728f2","modified":1723697333137},{"_id":"public/tags/算法/page/2/index.html","hash":"e4050204ae85a63849dda399f034ebecd907e8ac","modified":1723697333137},{"_id":"public/tags/思维题/index.html","hash":"ce0065b67b40eca8aa2ed0a3b779f135ba4aa678","modified":1723697333137},{"_id":"public/tags/模运算/index.html","hash":"2c900753611c15b3e73f06b8a1921d9e20812c17","modified":1723697333137},{"_id":"public/tags/atcoder/index.html","hash":"d27be195dd78114f2a72502e3495c9f75a8ffdb5","modified":1723697333137},{"_id":"public/tags/贪心，状态转移/index.html","hash":"ac7559e1aa824a44ff67b9b29185ca5debed723f","modified":1723697333137},{"_id":"public/tags/不等式/index.html","hash":"b8164016b7dc1ff7691e5e682946624a0b882d4d","modified":1723697333137},{"_id":"public/tags/luogu/index.html","hash":"cab0b2f5ca76fb02b44df8ea55da3880fe2e6d48","modified":1723697333137},{"_id":"public/tags/开发/index.html","hash":"b1f1774be2fe84951b42d429d82575d5b3e33a12","modified":1723697333137},{"_id":"public/tags/博弈论/index.html","hash":"3bfd96ddad0a9d5d2bbde055b3e99f93584b3930","modified":1723697333137},{"_id":"public/tags/文档/index.html","hash":"6cfe503466fb55551ff3c88f164e3657eb904326","modified":1723697333137},{"_id":"public/tags/学校/index.html","hash":"027edd1fcbaa2b0fe8a6038e6f0c3e0fa2822031","modified":1723697333137},{"_id":"public/tags/Typora/index.html","hash":"781c3a8dfebe9d03c96315801061c14e4fc364c2","modified":1723697333137},{"_id":"public/tags/Markdown/index.html","hash":"2e71b1cf2b8bd7f15a7fd869fcf0d994c1b2672c","modified":1723697333137},{"_id":"public/tags/随笔/index.html","hash":"200835657b4d6dbdbcdbd2a471363963558f748b","modified":1723697333137},{"_id":"public/tags/子序列自动机/index.html","hash":"982a08ecfffba7f0e405d251d0f334a23399b57c","modified":1723697333137},{"_id":"public/tags/坐标系转换/index.html","hash":"186174de3fa6d87b88bba4f0cbe919fd61bc1f52","modified":1723697333137},{"_id":"public/tags/几何问题/index.html","hash":"ba2d142c631a6d4f9ca0e40f60e083d65149ee05","modified":1723697333137},{"_id":"public/tags/异或问题/index.html","hash":"26e751b8c666948ac0c5438736d52135e97e9fae","modified":1723697333137},{"_id":"public/tags/树问题，哈希算法/index.html","hash":"6a221c07c78c479170117f634a95d048794412a7","modified":1723697333137},{"_id":"public/tags/状态转移/index.html","hash":"01d7ef1fcd657be8b2356cc4599bc88cdd660146","modified":1723697333137},{"_id":"public/tags/离散化/index.html","hash":"907ac69c4c3b5a644ef32680f15fcec3bcf38da1","modified":1723697333137},{"_id":"public/tags/加密算法/index.html","hash":"1d4d3814d9403f1618a73fadfde5ceb27d4738a8","modified":1723697333137},{"_id":"public/tags/ECC/index.html","hash":"ff7965975389c7bb992a2aba65b9f9b5ddd1abb1","modified":1723697333137},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1723697333137},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1723697333137},{"_id":"public/images/apple-touch-icon.png","hash":"64a9ea04f5bb7fef316fa416a7bf9e5e9489c291","modified":1723697333137},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1723697333137},{"_id":"public/images/beian.png","hash":"797721756b99b7841cee366f62ac52a1207cdcb7","modified":1723697333137},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1723697333137},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1723697333137},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1723697333137},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1723697333137},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1723697333137},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1723697333137},{"_id":"public/images/favicon-16x16.png","hash":"c3cc1168e2d338fbefc5f8da977a73a7b9a4975c","modified":1723697333137},{"_id":"public/images/favicon-32x32.png","hash":"8be81b95697df7f526646702889ca5483f51ccad","modified":1723697333137},{"_id":"public/images/logo.svg","hash":"d0ed8b5372385b71b533c985d0a3d84de851dfaf","modified":1723697333137},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1723697333137},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1723697333137},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1723697333137},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1723697333137},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1723697333137},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1723697333137},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1723697333137},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1723697333137},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1723697333137},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1723697333137},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1723697333137},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1723697333137},{"_id":"public/css/main.css","hash":"b0208657419e3fd00100206977f88ab27071ebd0","modified":1723697333137},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1723697333137},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1723697333137},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1723697333137},{"_id":"public/images/wechat_channel.jpg","hash":"25d7ebd0b18bb44a9013adbe2b6cd82919f4c291","modified":1723697333137},{"_id":"public/images/qq-contact.png","hash":"255274d1b43901c2a5a14daaa540346dc62602c4","modified":1723697333137},{"_id":"public/images/wechatpay.jpg","hash":"28bab154ea159faf803c3c832cc7da5eb62c7396","modified":1723697333137},{"_id":"public/images/alipay.jpg","hash":"1d531329226cfd0fde8e936f9019eec57169945b","modified":1723697333137},{"_id":"public/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf","hash":"ea8a10b275222aa4fe6004ea90dfb8b7619893ca","modified":1723697333137},{"_id":"public/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.docx","hash":"85ea4d5ef41451cc6d78520f9b8e9c934f3c45f6","modified":1723697333137}],"Category":[{"name":"比赛","_id":"clzusvysz0004wwwvhxacdrvf"},{"name":"模拟赛","parent":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvyt7000owwwv1plj0vlu"},{"name":"软件","_id":"clzusvyta0012wwwvfcu79rlz"},{"name":"信息安全","_id":"clzusvytf001owwwvh5icgxt1"},{"name":"日常赛","parent":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvytf001qwwwv7062dehh"},{"name":"icpc省赛","parent":"clzusvyt7000owwwv1plj0vlu","_id":"clzusvytg001uwwwvgecz9yop"},{"name":"算法","_id":"clzusvyth0021wwwv7s1sf96h"},{"name":"icpc邀请赛","parent":"clzusvyt7000owwwv1plj0vlu","_id":"clzusvyth0027wwwvflpfdi18"},{"name":"蓝桥模拟","parent":"clzusvyt7000owwwv1plj0vlu","_id":"clzusvytj002owwwvd69vakna"},{"name":"工具类软件","parent":"clzusvyta0012wwwvfcu79rlz","_id":"clzusvytj002uwwwv63ecedss"},{"name":"手册","parent":"clzusvyta0012wwwvfcu79rlz","_id":"clzusvytk002xwwwvbaehf5nn"},{"name":"编辑器","parent":"clzusvyta0012wwwvfcu79rlz","_id":"clzusvytk0033wwwv1za5aj1n"},{"name":"ccpc邀请赛","parent":"clzusvyt7000owwwv1plj0vlu","_id":"clzusvytk0038wwwv9ibz4nsu"},{"name":"经典库","parent":"clzusvyta0012wwwvfcu79rlz","_id":"clzusvytm003lwwwvhiehe10g"},{"name":"加密算法","parent":"clzusvytf001owwwvh5icgxt1","_id":"clzusvytn0042wwwvbfl222kf"},{"name":"newcoder","parent":"clzusvytf001qwwwv7062dehh","_id":"clzusvyto0047wwwv806jdrhz"},{"name":"思维题","parent":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvyto004fwwwv70tt99m9"},{"name":"atcoder","parent":"clzusvytf001qwwwv7062dehh","_id":"clzusvytp004lwwwvei36hzx5"},{"name":"数学","parent":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvytq004twwwv8ihv1qon"},{"name":"Markdown","parent":"clzusvytk0033wwwv1za5aj1n","_id":"clzusvytq004ywwwv9164g23f"},{"name":"字符串","parent":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvytq0051wwwvfoer5mzc"},{"name":"前端","parent":"clzusvytm003lwwwvhiehe10g","_id":"clzusvytr005cwwwv1bw5fhb0"},{"name":"图论","parent":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvyts005jwwwv47o8a00v"},{"name":"信息安全","parent":"clzusvytm003lwwwvhiehe10g","_id":"clzusvyts005mwwwvh4w11xhc"},{"name":"状态转移","parent":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvyts005owwwv45nq3dxf"},{"name":"数学","parent":"clzusvytn0042wwwvbfl222kf","_id":"clzusvyts005qwwwv066u3k2m"},{"name":"模运算","parent":"clzusvyto004fwwwv70tt99m9","_id":"clzusvyts005twwwv8l8yhe1g"},{"name":"贪心","parent":"clzusvyto004fwwwv70tt99m9","_id":"clzusvyts005wwwwvhpkd9was"},{"name":"博弈论","parent":"clzusvytq004twwwv8ihv1qon","_id":"clzusvytt005zwwwv44d8c54s"},{"name":"子序列自动机","parent":"clzusvytq0051wwwvfoer5mzc","_id":"clzusvytt0063wwwvb91y370i"},{"name":"node","parent":"clzusvytr005cwwwv1bw5fhb0","_id":"clzusvytt0066wwwv49x03pa8"},{"name":"图论中的回文问题","parent":"clzusvyts005jwwwv47o8a00v","_id":"clzusvytt0069wwwv2nv8e05r"},{"name":"状态转移中的异或问题","parent":"clzusvyts005owwwv45nq3dxf","_id":"clzusvyu0006uwwwvhchv985a"},{"name":"复杂状态转移与优化","parent":"clzusvyts005owwwv45nq3dxf","_id":"clzusvyu1006ywwwv83xl6u23"},{"name":"学术","_id":"clzusvyu10073wwwvcbpxf4di"},{"name":"综述","parent":"clzusvyu10073wwwvcbpxf4di","_id":"clzusvyu2007cwwwv59fm884d"}],"Data":[{"_id":"languages","data":{"zh-CN":{"post":{"copyright":{"author":"本文博主"},"comments":{"disqus":"评论"}}},"en":{"menu":{"schedule":"Calendar"}}}}],"Page":[{"title":"404","date":"2014-12-22T04:39:04.000Z","comments":0,"_content":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","source":"404/404.md","raw":"---\ntitle: '404'\ndate: 2014-12-22 12:39:04\ncomments: false\n---\n<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","updated":"2024-08-14T05:39:50.887Z","path":"404/404.html","layout":"page","_id":"clzusvyst0000wwwv3rno3kwy","content":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\r\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\r\n</script>\r\n","length":17,"excerpt":"","more":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\r\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\r\n</script>\r\n"},{"title":"categories","date":"2024-08-14T07:00:25.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2024-08-14 15:00:25\ntype: categories\n---\n","updated":"2024-08-14T07:00:37.565Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clzusvysx0002wwwv1v5z2tm9","content":"\r\n","length":0,"excerpt":"","more":"\r\n"},{"title":"关于","date":"2024-08-14T07:06:43.000Z","_content":"\n# 注意事项\n***网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主***\nps：我也将尽力保留数据\n\n这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链\n\n## **Little Resume**\n\n博主: Deepcity\n\n职业: 研究生\n\n电子邮箱: f1159472899@163.com\n\n## 友链\n\n{% linkgrid %}\nBraumAce | https://blog.braumace.cn/ByteLighting/ | 一个后端开发者 | https://blog.braumace.cn/ByteLighting/BraumAce.jpg\n{% endlinkgrid %}\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2024-08-14 15:06:43\n---\n\n# 注意事项\n***网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主***\nps：我也将尽力保留数据\n\n这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链\n\n## **Little Resume**\n\n博主: Deepcity\n\n职业: 研究生\n\n电子邮箱: f1159472899@163.com\n\n## 友链\n\n{% linkgrid %}\nBraumAce | https://blog.braumace.cn/ByteLighting/ | 一个后端开发者 | https://blog.braumace.cn/ByteLighting/BraumAce.jpg\n{% endlinkgrid %}\n","updated":"2024-08-14T13:51:09.539Z","path":"about/index.html","comments":1,"layout":"page","_id":"clzusvyt00006wwwv7amj20dy","content":"<h1 id=\"注意事项\">注意事项</h1>\r\n<p><strong><em>网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主</em></strong>\r\nps：我也将尽力保留数据</p>\r\n<p>这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链</p>\r\n<h2 id=\"little-resume\"><strong>Little Resume</strong></h2>\r\n<p>博主: Deepcity</p>\r\n<p>职业: 研究生</p>\r\n<p>电子邮箱: f1159472899@163.com</p>\r\n<h2 id=\"友链\">友链</h2>\r\n<div class=\"link-grid\"><div>\n\t\t\t<img src=\"https://blog.braumace.cn/ByteLighting/BraumAce.jpg\" onerror=\"this.src='/images/avatar.gif';\">\n\t\t\t<p>BraumAce</p><p>一个后端开发者</p>\n\t\t\t<a href=\"https://blog.braumace.cn/ByteLighting/\"></a>\n\t\t</div></div>\r\n","length":143,"excerpt":"","more":"<h1 id=\"注意事项\">注意事项</h1>\r\n<p><strong><em>网站目前处于刚刚建立内容更发与结构调整维护时期，内容可能将大幅度变动,如果您需要在网站上保存一些您没有备份的数据，请联系博主</em></strong>\r\nps：我也将尽力保留数据</p>\r\n<p>这是一个刚刚起步的个人小站，分享个人文章和一些杂谈，末尾是博主朋友的友链</p>\r\n<h2 id=\"little-resume\"><strong>Little Resume</strong></h2>\r\n<p>博主: Deepcity</p>\r\n<p>职业: 研究生</p>\r\n<p>电子邮箱: f1159472899@163.com</p>\r\n<h2 id=\"友链\">友链</h2>\r\n<div class=\"link-grid\"><div>\n\t\t\t<img src=\"https://blog.braumace.cn/ByteLighting/BraumAce.jpg\" onerror=\"this.src='/images/avatar.gif';\">\n\t\t\t<p>BraumAce</p><p>一个后端开发者</p>\n\t\t\t<a href=\"https://blog.braumace.cn/ByteLighting/\"></a>\n\t\t</div></div>\r\n"},{"title":"服务器日历","date":"2024-08-14T05:13:45.000Z","type":"schedule","_content":"","source":"schedule/index.md","raw":"---\ntitle: 服务器日历\ndate: 2024-08-14 13:13:45\ntype: schedule\n---\n","updated":"2024-08-14T12:03:54.657Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"clzusvyt10008wwwv3qou6l4e","content":"\r\n","length":0,"excerpt":"","more":"\r\n"},{"title":"标签","date":"2024-08-14T05:02:25.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2024-08-14 13:02:25\ntype: tags\n---","updated":"2024-08-14T05:14:48.261Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clzusvyt2000awwwv3ane17oa","content":"\r\n","length":0,"excerpt":"","more":"\r\n"}],"Post":[{"title":"2024武汉ICPC邀请赛VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 武汉邀请赛VP\n\n### I.[Cyclic Apple Strings](https://codeforces.com/gym/105143/problem/I)\n\n计算第一个1后的0的段数\n\n```cpp\nvoid slove() {\n\tstring s;cin>>s;\n\tint f =0,cnt = 0;\n\tfor(int i = 0;i < s.size(); i ++)\n\t{\n\t\tf|=(s[i] == '1');\n\t\tif(s[i]=='0')\n\t\twhile(i+1 < s.size() && s[i+1] == '0')\n\t\t\ti++;\n\t\tif(f && s[i] =='0') cnt++;\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\nK.[Party Games](https://codeforces.com/gym/105143/problem/K)\n\n打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tint r = n % 4;\n\tif(r==0 || r==1) cout<<\"Fluttershy\\n\";\n\telse if(r==2 || r==3) cout<<\"Pinkie Pie\\n\";\n}\n```\n\nF. [Custom-Made Clothes](https://codeforces.com/gym/105143/problem/F)\n\n简单二分或者二分套二分(另一个二分二分第一次的下标)\n\n注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到$$n \\le 1000$$。\n\n考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。\n\n```cpp\nint query(int x,int y,int v){\n\tif(g[x][y]) return g[x][y] <= v;\n\tcout<<\"?\"<<x<<' '<<y<<' '<<v<<endl;\n\tcout.flush();\n\tint res ;cin>>res;\n\treturn res;\n}\n\nint get(int x,int y,int l=1,int r=mx){\n\tif(!g[x][y]) return g[x][y];\n\twhile(l<r){\n\t\tint mid=  l+r>>1;\n\t\tif(query(x,y,mid)) r=mid;\n\t\telse l = mid+1;\n\t}\n\treturn g[x][y] = l;\n}\n\nvoid slove() {\n\tcin>>n>>k;\n\tmx = n * n;\n\tint l=1,r=mx;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\tint now = n;\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\twhile(now && !query(now,i,mid))now--;\n\t\t\tcnt += now;\n\t\t\tif(!now) break;\n\t\t}\n\t\tif(cnt < k) r=mid;\n\t\telse l=mid+1; \n\t}\n\tcout<<r<<endl;\n}\n```\n\n\n\nB. [Countless Me](https://codeforces.com/gym/105143/problem/B)\n\n很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：\n\n取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。\n\n维护sum值，将高位的1拆分给低位。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tint ans =0;\n  for (ll i = 30; i >= 0; i--) {\n      if (((1ll << i) - 1) * n >= sum) continue;\n      ll num = min(n, sum / (1ll << i));\n      if (num == 0) continue;\n      sum -= num * (1ll << i);\n      ans |= 1ll <<  i;\n  }\n\tcout<<ans<<endl;\n}\n```\n\n下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。\n\nhack数据\n\n```txt\n2\n3 0\n-------\n2\n7 3\n```\n\n```cpp\nvoid slove() {\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int sum = 0;\n    for(int i=1;i<=n;i++) sum += a[i];\n\n    int ans =0,cnt = 0;\n    for(int i=31;~i;i--){\n        cnt = (cnt<<1) + (sum >>i &1);\n        if(cnt >= n) ans += (sum >> i &1) <<i;\n    }\n    cout<<ans<<endl;\n}\n```\n\nD.[ICPC](https://codeforces.com/gym/105143/problem/D)\n\nICPC!!!，估计很多人一看到这个名字和答案求法就跑了。\n\n但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。\n\n思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。\n\ndp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++) pre[i] = pre[i-1] + a[i];\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(pre[i] - pre[max(i-j-1,0)]\n\t\t\t\t,pre[min(n,i+j)]- pre[i-1]);\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(f1[i][j],f1[i-1][j-1]);\n\t\t}\n\t}\n\n\tfor(int i=n;i;i--) {\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf2[i][j] = max(f1[i][j],f2[i+1][j-1]);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tll t = 0;\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tt ^= j*max(f1[i][j],f2[i][j]);\n\t\t}\n\t\tans ^= (i+ t);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n","source":"_posts/2024武汉ICPC邀请赛VP.md","raw":"---\ntitle: 2024武汉ICPC邀请赛VP\ndate: 2024-08-14 19:46:31\ntags: [icpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- icpc邀请赛\n---\n\n## 武汉邀请赛VP\n\n### I.[Cyclic Apple Strings](https://codeforces.com/gym/105143/problem/I)\n\n计算第一个1后的0的段数\n\n```cpp\nvoid slove() {\n\tstring s;cin>>s;\n\tint f =0,cnt = 0;\n\tfor(int i = 0;i < s.size(); i ++)\n\t{\n\t\tf|=(s[i] == '1');\n\t\tif(s[i]=='0')\n\t\twhile(i+1 < s.size() && s[i+1] == '0')\n\t\t\ti++;\n\t\tif(f && s[i] =='0') cnt++;\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\nK.[Party Games](https://codeforces.com/gym/105143/problem/K)\n\n打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tint r = n % 4;\n\tif(r==0 || r==1) cout<<\"Fluttershy\\n\";\n\telse if(r==2 || r==3) cout<<\"Pinkie Pie\\n\";\n}\n```\n\nF. [Custom-Made Clothes](https://codeforces.com/gym/105143/problem/F)\n\n简单二分或者二分套二分(另一个二分二分第一次的下标)\n\n注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到$$n \\le 1000$$。\n\n考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。\n\n```cpp\nint query(int x,int y,int v){\n\tif(g[x][y]) return g[x][y] <= v;\n\tcout<<\"?\"<<x<<' '<<y<<' '<<v<<endl;\n\tcout.flush();\n\tint res ;cin>>res;\n\treturn res;\n}\n\nint get(int x,int y,int l=1,int r=mx){\n\tif(!g[x][y]) return g[x][y];\n\twhile(l<r){\n\t\tint mid=  l+r>>1;\n\t\tif(query(x,y,mid)) r=mid;\n\t\telse l = mid+1;\n\t}\n\treturn g[x][y] = l;\n}\n\nvoid slove() {\n\tcin>>n>>k;\n\tmx = n * n;\n\tint l=1,r=mx;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\tint now = n;\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\twhile(now && !query(now,i,mid))now--;\n\t\t\tcnt += now;\n\t\t\tif(!now) break;\n\t\t}\n\t\tif(cnt < k) r=mid;\n\t\telse l=mid+1; \n\t}\n\tcout<<r<<endl;\n}\n```\n\n\n\nB. [Countless Me](https://codeforces.com/gym/105143/problem/B)\n\n很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：\n\n取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。\n\n维护sum值，将高位的1拆分给低位。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tint ans =0;\n  for (ll i = 30; i >= 0; i--) {\n      if (((1ll << i) - 1) * n >= sum) continue;\n      ll num = min(n, sum / (1ll << i));\n      if (num == 0) continue;\n      sum -= num * (1ll << i);\n      ans |= 1ll <<  i;\n  }\n\tcout<<ans<<endl;\n}\n```\n\n下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。\n\nhack数据\n\n```txt\n2\n3 0\n-------\n2\n7 3\n```\n\n```cpp\nvoid slove() {\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int sum = 0;\n    for(int i=1;i<=n;i++) sum += a[i];\n\n    int ans =0,cnt = 0;\n    for(int i=31;~i;i--){\n        cnt = (cnt<<1) + (sum >>i &1);\n        if(cnt >= n) ans += (sum >> i &1) <<i;\n    }\n    cout<<ans<<endl;\n}\n```\n\nD.[ICPC](https://codeforces.com/gym/105143/problem/D)\n\nICPC!!!，估计很多人一看到这个名字和答案求法就跑了。\n\n但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。\n\n思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。\n\ndp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++) pre[i] = pre[i-1] + a[i];\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(pre[i] - pre[max(i-j-1,0)]\n\t\t\t\t,pre[min(n,i+j)]- pre[i-1]);\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf1[i][j] = max(f1[i][j],f1[i-1][j-1]);\n\t\t}\n\t}\n\n\tfor(int i=n;i;i--) {\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tf2[i][j] = max(f1[i][j],f2[i+1][j-1]);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tll t = 0;\n\t\tfor(int j=1;j<=n<<1;j++){\n\t\t\tt ^= j*max(f1[i][j],f2[i][j]);\n\t\t}\n\t\tans ^= (i+ t);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n","slug":"2024武汉ICPC邀请赛VP","published":1,"updated":"2024-08-15T03:49:14.747Z","comments":1,"layout":"post","photos":[],"_id":"clzusvysv0001wwwv1nmh880t","content":"<h2 id=\"武汉邀请赛vp\">武汉邀请赛VP</h2>\r\n<h3 id=\"i.cyclic-apple-strings\">I.<a\r\nhref=\"https://codeforces.com/gym/105143/problem/I\">Cyclic Apple\r\nStrings</a></h3>\r\n<p>计算第一个1后的0的段数</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"type\">int</span> f =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i &lt; s.<span class=\"built_in\">size</span>(); i ++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tf|=(s[i] == <span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i<span class=\"number\">+1</span> &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; s[i<span class=\"number\">+1</span>] == <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f &amp;&amp; s[i] ==<span class=\"string\">&#x27;0&#x27;</span>) cnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>K.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSw==\">Party\r\nGames<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r = n % <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(r==<span class=\"number\">0</span> || r==<span class=\"number\">1</span>) cout&lt;&lt;<span class=\"string\">&quot;Fluttershy\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(r==<span class=\"number\">2</span> || r==<span class=\"number\">3</span>) cout&lt;&lt;<span class=\"string\">&quot;Pinkie Pie\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>F. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRg==\">Custom-Made\r\nClothes<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>简单二分或者二分套二分(另一个二分二分第一次的下标)</p>\r\n<p>注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到<span\r\nclass=\"math display\">\\[n \\le 1000\\]</span>。</p>\r\n<p>考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(g[x][y]) <span class=\"keyword\">return</span> g[x][y] &lt;= v;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;?&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;v&lt;&lt;endl;</span><br><span class=\"line\">\tcout.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> res ;cin&gt;&gt;res;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> l=<span class=\"number\">1</span>,<span class=\"type\">int</span> r=mx)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!g[x][y]) <span class=\"keyword\">return</span> g[x][y];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid=  l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">query</span>(x,y,mid)) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g[x][y] = l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\tmx = n * n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l=<span class=\"number\">1</span>,r=mx;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = n;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(now &amp;&amp; !<span class=\"built_in\">query</span>(now,i,mid))now--;</span><br><span class=\"line\">\t\t\tcnt += now;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!now) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &lt; k) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l=mid<span class=\"number\">+1</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>B. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vQg==\">Countless\r\nMe<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：</p>\r\n<p>取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。</p>\r\n<p>维护sum值，将高位的1拆分给低位。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans =<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (ll i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((<span class=\"number\">1ll</span> &lt;&lt; i) - <span class=\"number\">1</span>) * n &gt;= sum) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      ll num = <span class=\"built_in\">min</span>(n, sum / (<span class=\"number\">1ll</span> &lt;&lt; i));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      sum -= num * (<span class=\"number\">1ll</span> &lt;&lt; i);</span><br><span class=\"line\">      ans |= <span class=\"number\">1ll</span> &lt;&lt;  i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。</p>\r\n<p>hack数据</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">3 0</span><br><span class=\"line\">-------</span><br><span class=\"line\">2</span><br><span class=\"line\">7 3</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">31</span>;~i;i--)&#123;</span><br><span class=\"line\">        cnt = (cnt&lt;&lt;<span class=\"number\">1</span>) + (sum &gt;&gt;i &amp;<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt;= n) ans += (sum &gt;&gt; i &amp;<span class=\"number\">1</span>) &lt;&lt;i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>D.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRA==\">ICPC<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>ICPC!!!，估计很多人一看到这个名字和答案求法就跑了。</p>\r\n<p>但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。</p>\r\n<p>思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。</p>\r\n<p>dp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(pre[i] - pre[<span class=\"built_in\">max</span>(i-j<span class=\"number\">-1</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">\t\t\t\t,pre[<span class=\"built_in\">min</span>(n,i+j)]- pre[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f1[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf2[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f2[i<span class=\"number\">+1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tll t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tt ^= j*<span class=\"built_in\">max</span>(f1[i][j],f2[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans ^= (i+ t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1149,"excerpt":"","more":"<h2 id=\"武汉邀请赛vp\">武汉邀请赛VP</h2>\r\n<h3 id=\"i.cyclic-apple-strings\">I.<a\r\nhref=\"https://codeforces.com/gym/105143/problem/I\">Cyclic Apple\r\nStrings</a></h3>\r\n<p>计算第一个1后的0的段数</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"type\">int</span> f =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i &lt; s.<span class=\"built_in\">size</span>(); i ++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tf|=(s[i] == <span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i<span class=\"number\">+1</span> &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; s[i<span class=\"number\">+1</span>] == <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f &amp;&amp; s[i] ==<span class=\"string\">&#x27;0&#x27;</span>) cnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>K.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSw==\">Party\r\nGames<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r = n % <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(r==<span class=\"number\">0</span> || r==<span class=\"number\">1</span>) cout&lt;&lt;<span class=\"string\">&quot;Fluttershy\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(r==<span class=\"number\">2</span> || r==<span class=\"number\">3</span>) cout&lt;&lt;<span class=\"string\">&quot;Pinkie Pie\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>F. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRg==\">Custom-Made\r\nClothes<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>简单二分或者二分套二分(另一个二分二分第一次的下标)</p>\r\n<p>注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到<span\r\nclass=\"math display\">\\[n \\le 1000\\]</span>。</p>\r\n<p>考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(g[x][y]) <span class=\"keyword\">return</span> g[x][y] &lt;= v;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;?&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;v&lt;&lt;endl;</span><br><span class=\"line\">\tcout.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> res ;cin&gt;&gt;res;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> l=<span class=\"number\">1</span>,<span class=\"type\">int</span> r=mx)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!g[x][y]) <span class=\"keyword\">return</span> g[x][y];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid=  l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">query</span>(x,y,mid)) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g[x][y] = l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\tmx = n * n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l=<span class=\"number\">1</span>,r=mx;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = n;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(now &amp;&amp; !<span class=\"built_in\">query</span>(now,i,mid))now--;</span><br><span class=\"line\">\t\t\tcnt += now;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!now) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &lt; k) r=mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l=mid<span class=\"number\">+1</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>B. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vQg==\">Countless\r\nMe<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：</p>\r\n<p>取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。</p>\r\n<p>维护sum值，将高位的1拆分给低位。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans =<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (ll i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((<span class=\"number\">1ll</span> &lt;&lt; i) - <span class=\"number\">1</span>) * n &gt;= sum) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      ll num = <span class=\"built_in\">min</span>(n, sum / (<span class=\"number\">1ll</span> &lt;&lt; i));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      sum -= num * (<span class=\"number\">1ll</span> &lt;&lt; i);</span><br><span class=\"line\">      ans |= <span class=\"number\">1ll</span> &lt;&lt;  i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。</p>\r\n<p>hack数据</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">3 0</span><br><span class=\"line\">-------</span><br><span class=\"line\">2</span><br><span class=\"line\">7 3</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans =<span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">31</span>;~i;i--)&#123;</span><br><span class=\"line\">        cnt = (cnt&lt;&lt;<span class=\"number\">1</span>) + (sum &gt;&gt;i &amp;<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt;= n) ans += (sum &gt;&gt; i &amp;<span class=\"number\">1</span>) &lt;&lt;i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>D.<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRA==\">ICPC<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>ICPC!!!，估计很多人一看到这个名字和答案求法就跑了。</p>\r\n<p>但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。</p>\r\n<p>思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。</p>\r\n<p>dp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(pre[i] - pre[<span class=\"built_in\">max</span>(i-j<span class=\"number\">-1</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">\t\t\t\t,pre[<span class=\"built_in\">min</span>(n,i+j)]- pre[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf1[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f1[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tf2[i][j] = <span class=\"built_in\">max</span>(f1[i][j],f2[i<span class=\"number\">+1</span>][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tll t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n&lt;&lt;<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tt ^= j*<span class=\"built_in\">max</span>(f1[i][j],f2[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans ^= (i+ t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2024江苏CCPC邀请赛-VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 江苏CCPC-VP\n\n## F. Download Speed Monitor\n\n[Problem - F - Codeforces](https://codeforces.com/gym/105161/problem/F)\n\n### 题意：\n\n您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。\n\n下载速度监视器的工作原理如下：从 $$(k-1)$$$ (秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 $$$k$$ (秒)开始，监视器将显示从 $$(i-k+1)$$$$ (秒)到 $$$$i$$(秒)再到 $$i$$ (秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于 $$1024$$ KiBps 时，下载速度监视器将以 MiBps 为单位显示结果。\n\n您的下载任务将持续 $$n$$ 秒。考虑到平均速度的计算间隔为 $$k$$ ，您想知道从 $k$$$ (秒)到 $$$$n$$ (秒)，监控器上将显示什么。\n\nNote: $$1$$$ MiBps $$$=1024$$$$ KiBps$$​.\n\n### 题解：\n\n签到题，双指针扫一下即可\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tll sum  = 0;\n\tfor(int i=1,j=1;i<=n;i++)\n\t{\n\t\tsum += a[i];\n\t\tif(i - j >= k) sum -= a[j ++];\n\t\tif(i - j + 1 < k) continue;\n\t\t// cout<<i<< ' '<<j<< ' ' <<sum<<endl;\n\t\tdouble spd = double(1.0 * sum / k);\n\t\tstring ad = \"KiBps\";\n\t\tif(spd >= 1024) spd /= 1024, ad = \"MiBps\";\n\t\tprintf(\"%.6lf\", spd);\n\t\tcout<<' '<<ad<<endl;\n\t}\n}\n```\n\n## G. Download Time Monitor\n\n[Problem - G - Codeforces](https://codeforces.com/gym/105161/problem/G)\n\n### 题意：\n\n您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。\n\n您使用的网络带宽为 $$B$$ MiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 $t_1$ 秒，大小为 $$a_1$$ MiB，而第二个文件开始下载的时间为 $$t_2$$ 秒，大小为 $$a_2$$ MiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在 $$B$$ MiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 $$\\frac{B}{2}$$ MiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。\n\n现在，您想知道两个文件完成下载各需要多长时间。\n\n### 题解：\n\n出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）\n\n这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。\n\n注意是下载花费时间而不是总时间\n\n这题浮点运算常数较大，开O2和解同步会比较好\n\n```cpp\n#pragma GCC optimize(2)\n#define FIO std::ios::sync_with_stdio(false);std::cin.tie(0);\n```\n\n```cpp\nvoid slove() {\n\tint B,t1,t2,a1,a2;\n\tcin>>B>>t1>>a1>>t2>>a2;\n\n\tint f = 0;\n\n\tif(t1 > t2){\n\t\tswap(t1,t2);swap(a1,a2);\n\t\tf=1;\n\t}\n\n\tdouble d = t2-t1;\n\tdouble a,b;\n\n\tif(d * B > a1){\n\t\ta = 1.0 *a1 / B;\n\t\tb = 1.0 *a2 / B;\n\t\td=0;\n\t}else {\n\t\ta1 -= d * B;\n\t\tif(a1 > a2) f^= 1,swap(a1,a2);\n\t\t// cout<<a1<< ' '<<a2<<endl;\n\t\ta = 1.0 *a1 / (1.0 *B/2);\n\t\tb = 1.0 *a1 / (1.0 *B/2) + 1.0 *(a2 - a1) /B;\n\t}\n\n\tif(!f) printf(\"%.9lf %.9lf\\n\",a + d, b);\n\telse printf(\"%.9lf %.9lf\\n\",b + d,a);\n}\n```\n\n## K. Number Deletion Game\n\n[Problem - K - Codeforces](https://codeforces.com/gym/105161/problem/K)\n\n### 题意：\n\n爱丽丝和鲍勃正在玩一个数字删除游戏。\n\n一开始，有 $$n$$$ 个整数 $$$a_ 1,a _ 2, \\ldots ,a _n$$ 。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除**大的数字**$$x$$$ ，并选择一个比 $$$x$$**小的非负整数 $$y$$$ ，然后在数字 $$$1,2,\\ldots, y$$$ 中各加一个。特别是可以选择 $$$y=0$$ ，在这种情况下不会添加任何数字。也就是说，删除 $$1$$ 时，不能添加任何数字。删除最后一个数字的人获胜。\n\n双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。\n\n### 题解：\n\n注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。\n\n另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。\n\n​\t那么对于最大值取$$1 \\to k$$成立，试证明对k+1成立，分类讨论\n\n\t1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\n\t1. k+1为偶数个，同理，Bob胜\n\ncoding\n\n```CPP\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tsort(a+1,a+1+n);\n\tint num = -1;\n\tfor(int i=n;i;i--)\n\t\tif(a[i] != a[n]) {\n\t\t\tnum = n-i;\n\t\t\tbreak;\n\t\t}\n\tif(num == -1) num = n;\n\t// cout<<num<<endl;\n\tif(num&1) puts(\"Alice\");\n\telse puts(\"Bob\");\n}\n```\n\n## I. Integer Reaction\n\n[Problem - I - Codeforces](https://codeforces.com/gym/105161/problem/I)\n\n###　题意：\n\n有一个由 $$n$$ 个整数组成的序列，从左到右编号为 $$1$$ 到 $$n$$ 。这些整数有两种颜色，分别是 $$0$$ 和 $$1$$ ，每个整数正好有一种颜色。这些整数按照从 $$1$$到 $$n$$ 的编号顺序进入多集合 $$S_1$$ 。\n\n每当一个新的整数 $$x$$ 进入 $$S_1$$ 时，你必须在 $$S_1$$ 中选择一个颜色与 $$x$$ 不同的整数 $$y$$ 与 $$x$$ 发生反应，使得 $$x$$ 和 $$y$$ 消失，反应产物 $$x+y$$ 插入另一个集合 $$S_2$$ 中。如果不存在这样的 $$y$$ ，则不会发生反应，只有 $$x$$ 会插入 $$S_1$$ 。\n\n给定整数序列和每个整数的颜色，求处理最后一个元素后 $$S_2$$​ 中最小元素的最大可能值。\n\n### 题解\n\n很简单，二分答案贪心维护$$S_1$$即可\n\n```cpp\nint ck(int x){\n\t// cout<<x<<endl;\n\tmultiset<int> ms;\n\tint c = -1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(c==-1){\n\t\t\tms.insert(a[i].x);\n\t\t\tc = a[i].y;\n\t\t}else {\n\t\t\tif(c == a[i].y){\n\t\t\t\tms.insert(a[i].x);\n\t\t\t}else if(ms.size()){\n\t\t\t\t// cout<<x-a[i].y<<endl;\n\t\t\t\tauto it = lower_bound(all(ms), x - a[i].x);\n\t\t\t\tif(it == ms.end()) return 0;\n\t\t\t\t// if(x==7)cout<<*it<<endl;\n\t\t\t\tms.erase(it);\n\t\t\t}else {\n\t\t\t\tms.insert(a[i].x);\n\t\t\t\tc = a[i].y;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n};\n\nvoid slove() {\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].x);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].y);\n\n\tint l = 1,r = INF;\n\twhile(l<r){\n\t\tint mid = l+r+1 >> 1;\n\t\tif(ck(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\n\tprintf(\"%d\\n\",l);\n}\n```\n\n","source":"_posts/2024江苏CCPC邀请赛-VP.md","raw":"---\ntitle: 2024江苏CCPC邀请赛-VP\ndate: 2024-08-14 19:46:31\ntags: [ccpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- ccpc邀请赛\n---\n\n## 江苏CCPC-VP\n\n## F. Download Speed Monitor\n\n[Problem - F - Codeforces](https://codeforces.com/gym/105161/problem/F)\n\n### 题意：\n\n您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。\n\n下载速度监视器的工作原理如下：从 $$(k-1)$$$ (秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 $$$k$$ (秒)开始，监视器将显示从 $$(i-k+1)$$$$ (秒)到 $$$$i$$(秒)再到 $$i$$ (秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于 $$1024$$ KiBps 时，下载速度监视器将以 MiBps 为单位显示结果。\n\n您的下载任务将持续 $$n$$ 秒。考虑到平均速度的计算间隔为 $$k$$ ，您想知道从 $k$$$ (秒)到 $$$$n$$ (秒)，监控器上将显示什么。\n\nNote: $$1$$$ MiBps $$$=1024$$$$ KiBps$$​.\n\n### 题解：\n\n签到题，双指针扫一下即可\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tll sum  = 0;\n\tfor(int i=1,j=1;i<=n;i++)\n\t{\n\t\tsum += a[i];\n\t\tif(i - j >= k) sum -= a[j ++];\n\t\tif(i - j + 1 < k) continue;\n\t\t// cout<<i<< ' '<<j<< ' ' <<sum<<endl;\n\t\tdouble spd = double(1.0 * sum / k);\n\t\tstring ad = \"KiBps\";\n\t\tif(spd >= 1024) spd /= 1024, ad = \"MiBps\";\n\t\tprintf(\"%.6lf\", spd);\n\t\tcout<<' '<<ad<<endl;\n\t}\n}\n```\n\n## G. Download Time Monitor\n\n[Problem - G - Codeforces](https://codeforces.com/gym/105161/problem/G)\n\n### 题意：\n\n您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。\n\n您使用的网络带宽为 $$B$$ MiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 $t_1$ 秒，大小为 $$a_1$$ MiB，而第二个文件开始下载的时间为 $$t_2$$ 秒，大小为 $$a_2$$ MiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在 $$B$$ MiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 $$\\frac{B}{2}$$ MiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。\n\n现在，您想知道两个文件完成下载各需要多长时间。\n\n### 题解：\n\n出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）\n\n这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。\n\n注意是下载花费时间而不是总时间\n\n这题浮点运算常数较大，开O2和解同步会比较好\n\n```cpp\n#pragma GCC optimize(2)\n#define FIO std::ios::sync_with_stdio(false);std::cin.tie(0);\n```\n\n```cpp\nvoid slove() {\n\tint B,t1,t2,a1,a2;\n\tcin>>B>>t1>>a1>>t2>>a2;\n\n\tint f = 0;\n\n\tif(t1 > t2){\n\t\tswap(t1,t2);swap(a1,a2);\n\t\tf=1;\n\t}\n\n\tdouble d = t2-t1;\n\tdouble a,b;\n\n\tif(d * B > a1){\n\t\ta = 1.0 *a1 / B;\n\t\tb = 1.0 *a2 / B;\n\t\td=0;\n\t}else {\n\t\ta1 -= d * B;\n\t\tif(a1 > a2) f^= 1,swap(a1,a2);\n\t\t// cout<<a1<< ' '<<a2<<endl;\n\t\ta = 1.0 *a1 / (1.0 *B/2);\n\t\tb = 1.0 *a1 / (1.0 *B/2) + 1.0 *(a2 - a1) /B;\n\t}\n\n\tif(!f) printf(\"%.9lf %.9lf\\n\",a + d, b);\n\telse printf(\"%.9lf %.9lf\\n\",b + d,a);\n}\n```\n\n## K. Number Deletion Game\n\n[Problem - K - Codeforces](https://codeforces.com/gym/105161/problem/K)\n\n### 题意：\n\n爱丽丝和鲍勃正在玩一个数字删除游戏。\n\n一开始，有 $$n$$$ 个整数 $$$a_ 1,a _ 2, \\ldots ,a _n$$ 。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除**大的数字**$$x$$$ ，并选择一个比 $$$x$$**小的非负整数 $$y$$$ ，然后在数字 $$$1,2,\\ldots, y$$$ 中各加一个。特别是可以选择 $$$y=0$$ ，在这种情况下不会添加任何数字。也就是说，删除 $$1$$ 时，不能添加任何数字。删除最后一个数字的人获胜。\n\n双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。\n\n### 题解：\n\n注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。\n\n另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。\n\n​\t那么对于最大值取$$1 \\to k$$成立，试证明对k+1成立，分类讨论\n\n\t1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\n\t1. k+1为偶数个，同理，Bob胜\n\ncoding\n\n```CPP\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tsort(a+1,a+1+n);\n\tint num = -1;\n\tfor(int i=n;i;i--)\n\t\tif(a[i] != a[n]) {\n\t\t\tnum = n-i;\n\t\t\tbreak;\n\t\t}\n\tif(num == -1) num = n;\n\t// cout<<num<<endl;\n\tif(num&1) puts(\"Alice\");\n\telse puts(\"Bob\");\n}\n```\n\n## I. Integer Reaction\n\n[Problem - I - Codeforces](https://codeforces.com/gym/105161/problem/I)\n\n###　题意：\n\n有一个由 $$n$$ 个整数组成的序列，从左到右编号为 $$1$$ 到 $$n$$ 。这些整数有两种颜色，分别是 $$0$$ 和 $$1$$ ，每个整数正好有一种颜色。这些整数按照从 $$1$$到 $$n$$ 的编号顺序进入多集合 $$S_1$$ 。\n\n每当一个新的整数 $$x$$ 进入 $$S_1$$ 时，你必须在 $$S_1$$ 中选择一个颜色与 $$x$$ 不同的整数 $$y$$ 与 $$x$$ 发生反应，使得 $$x$$ 和 $$y$$ 消失，反应产物 $$x+y$$ 插入另一个集合 $$S_2$$ 中。如果不存在这样的 $$y$$ ，则不会发生反应，只有 $$x$$ 会插入 $$S_1$$ 。\n\n给定整数序列和每个整数的颜色，求处理最后一个元素后 $$S_2$$​ 中最小元素的最大可能值。\n\n### 题解\n\n很简单，二分答案贪心维护$$S_1$$即可\n\n```cpp\nint ck(int x){\n\t// cout<<x<<endl;\n\tmultiset<int> ms;\n\tint c = -1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(c==-1){\n\t\t\tms.insert(a[i].x);\n\t\t\tc = a[i].y;\n\t\t}else {\n\t\t\tif(c == a[i].y){\n\t\t\t\tms.insert(a[i].x);\n\t\t\t}else if(ms.size()){\n\t\t\t\t// cout<<x-a[i].y<<endl;\n\t\t\t\tauto it = lower_bound(all(ms), x - a[i].x);\n\t\t\t\tif(it == ms.end()) return 0;\n\t\t\t\t// if(x==7)cout<<*it<<endl;\n\t\t\t\tms.erase(it);\n\t\t\t}else {\n\t\t\t\tms.insert(a[i].x);\n\t\t\t\tc = a[i].y;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n};\n\nvoid slove() {\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].x);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&a[i].y);\n\n\tint l = 1,r = INF;\n\twhile(l<r){\n\t\tint mid = l+r+1 >> 1;\n\t\tif(ck(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\n\tprintf(\"%d\\n\",l);\n}\n```\n\n","slug":"2024江苏CCPC邀请赛-VP","published":1,"updated":"2024-08-15T03:49:09.691Z","comments":1,"layout":"post","photos":[],"_id":"clzusvysy0003wwwv9os61wwm","content":"<h2 id=\"江苏ccpc-vp\">江苏CCPC-VP</h2>\r\n<h2 id=\"f.-download-speed-monitor\">F. Download Speed Monitor</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRg==\">Problem - F -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意\">题意：</h3>\r\n<p>您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。</p>\r\n<p>下载速度监视器的工作原理如下：从 <span\r\nclass=\"math display\">\\[(k-1)\\]</span>$\r\n(秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 <span\r\nclass=\"math display\">\\[$k\\]</span> (秒)开始，监视器将显示从 <span\r\nclass=\"math display\">\\[(i-k+1)\\]</span><span class=\"math display\">\\[\r\n(秒)到 \\]</span><span class=\"math display\">\\[i\\]</span>(秒)再到 <span\r\nclass=\"math display\">\\[i\\]</span>\r\n(秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于\r\n<span class=\"math display\">\\[1024\\]</span> KiBps 时，下载速度监视器将以\r\nMiBps 为单位显示结果。</p>\r\n<p>您的下载任务将持续 <span class=\"math display\">\\[n\\]</span>\r\n秒。考虑到平均速度的计算间隔为 <span class=\"math display\">\\[k\\]</span>\r\n，您想知道从 <span class=\"math inline\">\\(k\\)</span><span\r\nclass=\"math display\">\\[ (秒)到 \\]</span><span\r\nclass=\"math display\">\\[n\\]</span> (秒)，监控器上将显示什么。</p>\r\n<p>Note: <span class=\"math display\">\\[1\\]</span>$ MiBps <span\r\nclass=\"math display\">\\[$=1024\\]</span><span class=\"math display\">\\[\r\nKiBps\\]</span>​.</p>\r\n<h3 id=\"题解\">题解：</h3>\r\n<p>签到题，双指针扫一下即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum  = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum += a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j &gt;= k) sum -= a[j ++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j + <span class=\"number\">1</span> &lt; k) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt; &#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">double</span> spd = <span class=\"built_in\">double</span>(<span class=\"number\">1.0</span> * sum / k);</span><br><span class=\"line\">\t\tstring ad = <span class=\"string\">&quot;KiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(spd &gt;= <span class=\"number\">1024</span>) spd /= <span class=\"number\">1024</span>, ad = <span class=\"string\">&quot;MiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.6lf&quot;</span>, spd);</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ad&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g.-download-time-monitor\">G. Download Time Monitor</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRw==\">Problem - G -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-1\">题意：</h3>\r\n<p>您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。</p>\r\n<p>您使用的网络带宽为 <span class=\"math display\">\\[B\\]</span>\r\nMiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 <span\r\nclass=\"math inline\">\\(t_1\\)</span> 秒，大小为 <span\r\nclass=\"math display\">\\[a_1\\]</span> MiB，而第二个文件开始下载的时间为\r\n<span class=\"math display\">\\[t_2\\]</span> 秒，大小为 <span\r\nclass=\"math display\">\\[a_2\\]</span>\r\nMiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在\r\n<span class=\"math display\">\\[B\\]</span>\r\nMiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 <span\r\nclass=\"math display\">\\[\\frac{B}{2}\\]</span>\r\nMiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。</p>\r\n<p>现在，您想知道两个文件完成下载各需要多长时间。</p>\r\n<h3 id=\"题解-1\">题解：</h3>\r\n<p>出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）</p>\r\n<p>这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。</p>\r\n<p>注意是下载花费时间而不是总时间</p>\r\n<p>这题浮点运算常数较大，开O2和解同步会比较好</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> GCC optimize(2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIO std::ios::sync_with_stdio(false);std::cin.tie(0);</span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> B,t1,t2,a1,a2;</span><br><span class=\"line\">\tcin&gt;&gt;B&gt;&gt;t1&gt;&gt;a1&gt;&gt;t2&gt;&gt;a2;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t1 &gt; t2)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(t1,t2);<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\tf=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">double</span> d = t2-t1;</span><br><span class=\"line\">\t<span class=\"type\">double</span> a,b;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(d * B &gt; a1)&#123;</span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / B;</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a2 / B;</span><br><span class=\"line\">\t\td=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\ta1 -= d * B;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a1 &gt; a2) f^= <span class=\"number\">1</span>,<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;a1&lt;&lt; &#x27; &#x27;&lt;&lt;a2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>) + <span class=\"number\">1.0</span> *(a2 - a1) /B;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,a + d, b);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,b + d,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-number-deletion-game\">K. Number Deletion Game</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSw==\">Problem - K -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-2\">题意：</h3>\r\n<p>爱丽丝和鲍勃正在玩一个数字删除游戏。</p>\r\n<p>一开始，有 <span class=\"math display\">\\[n\\]</span>$ 个整数 <span\r\nclass=\"math display\">\\[$a_ 1,a _ 2, \\ldots ,a _n\\]</span>\r\n。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除<strong>大的数字</strong><span\r\nclass=\"math display\">\\[x\\]</span>$ ，并选择一个比 <span\r\nclass=\"math display\">\\[$x\\]</span>**小的非负整数 <span\r\nclass=\"math display\">\\[y\\]</span>$ ，然后在数字 <span\r\nclass=\"math display\">\\[$1,2,\\ldots, y\\]</span>$\r\n中各加一个。特别是可以选择 <span class=\"math display\">\\[$y=0\\]</span>\r\n，在这种情况下不会添加任何数字。也就是说，删除 <span\r\nclass=\"math display\">\\[1\\]</span>\r\n时，不能添加任何数字。删除最后一个数字的人获胜。</p>\r\n<p>双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。</p>\r\n<h3 id=\"题解-2\">题解：</h3>\r\n<p>注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。</p>\r\n<p>另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。</p>\r\n<p>​ 那么对于最大值取<span class=\"math display\">\\[1 \\to\r\nk\\]</span>成立，试证明对k+1成立，分类讨论</p>\r\n<pre><code>1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\r\n1. k+1为偶数个，同理，Bob胜</code></pre>\r\n<p>coding</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> num = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i] != a[n]) &#123;</span><br><span class=\"line\">\t\t\tnum = n-i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num == <span class=\"number\">-1</span>) num = n;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;num&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num&amp;<span class=\"number\">1</span>) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"i.-integer-reaction\">I. Integer Reaction</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSQ==\">Problem - I -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>###　题意：</p>\r\n<p>有一个由 <span class=\"math display\">\\[n\\]</span>\r\n个整数组成的序列，从左到右编号为 <span class=\"math display\">\\[1\\]</span>\r\n到 <span class=\"math display\">\\[n\\]</span> 。这些整数有两种颜色，分别是\r\n<span class=\"math display\">\\[0\\]</span> 和 <span\r\nclass=\"math display\">\\[1\\]</span>\r\n，每个整数正好有一种颜色。这些整数按照从 <span\r\nclass=\"math display\">\\[1\\]</span>到 <span\r\nclass=\"math display\">\\[n\\]</span> 的编号顺序进入多集合 <span\r\nclass=\"math display\">\\[S_1\\]</span> 。</p>\r\n<p>每当一个新的整数 <span class=\"math display\">\\[x\\]</span> 进入 <span\r\nclass=\"math display\">\\[S_1\\]</span> 时，你必须在 <span\r\nclass=\"math display\">\\[S_1\\]</span> 中选择一个颜色与 <span\r\nclass=\"math display\">\\[x\\]</span> 不同的整数 <span\r\nclass=\"math display\">\\[y\\]</span> 与 <span\r\nclass=\"math display\">\\[x\\]</span> 发生反应，使得 <span\r\nclass=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> 消失，反应产物 <span\r\nclass=\"math display\">\\[x+y\\]</span> 插入另一个集合 <span\r\nclass=\"math display\">\\[S_2\\]</span> 中。如果不存在这样的 <span\r\nclass=\"math display\">\\[y\\]</span> ，则不会发生反应，只有 <span\r\nclass=\"math display\">\\[x\\]</span> 会插入 <span\r\nclass=\"math display\">\\[S_1\\]</span> 。</p>\r\n<p>给定整数序列和每个整数的颜色，求处理最后一个元素后 <span\r\nclass=\"math display\">\\[S_2\\]</span>​ 中最小元素的最大可能值。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>很简单，二分答案贪心维护<span\r\nclass=\"math display\">\\[S_1\\]</span>即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ck</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class=\"line\">\tmultiset&lt;<span class=\"type\">int</span>&gt; ms;</span><br><span class=\"line\">\t<span class=\"type\">int</span> c = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(c == a[i].y)&#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ms.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// cout&lt;&lt;x-a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">auto</span> it = <span class=\"built_in\">lower_bound</span>(<span class=\"built_in\">all</span>(ms), x - a[i].x);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(it == ms.<span class=\"built_in\">end</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// if(x==7)cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].x);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].y);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">1</span>,r = INF;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r<span class=\"number\">+1</span> &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">ck</span>(mid)) l = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1555,"excerpt":"","more":"<h2 id=\"江苏ccpc-vp\">江苏CCPC-VP</h2>\r\n<h2 id=\"f.-download-speed-monitor\">F. Download Speed Monitor</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRg==\">Problem - F -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意\">题意：</h3>\r\n<p>您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。</p>\r\n<p>下载速度监视器的工作原理如下：从 <span\r\nclass=\"math display\">\\[(k-1)\\]</span>$\r\n(秒)开始，下载速度监视器将始终显示 \"正在加载\"，但从 <span\r\nclass=\"math display\">\\[$k\\]</span> (秒)开始，监视器将显示从 <span\r\nclass=\"math display\">\\[(i-k+1)\\]</span><span class=\"math display\">\\[\r\n(秒)到 \\]</span><span class=\"math display\">\\[i\\]</span>(秒)再到 <span\r\nclass=\"math display\">\\[i\\]</span>\r\n(秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于\r\n<span class=\"math display\">\\[1024\\]</span> KiBps 时，下载速度监视器将以\r\nMiBps 为单位显示结果。</p>\r\n<p>您的下载任务将持续 <span class=\"math display\">\\[n\\]</span>\r\n秒。考虑到平均速度的计算间隔为 <span class=\"math display\">\\[k\\]</span>\r\n，您想知道从 <span class=\"math inline\">\\(k\\)</span><span\r\nclass=\"math display\">\\[ (秒)到 \\]</span><span\r\nclass=\"math display\">\\[n\\]</span> (秒)，监控器上将显示什么。</p>\r\n<p>Note: <span class=\"math display\">\\[1\\]</span>$ MiBps <span\r\nclass=\"math display\">\\[$=1024\\]</span><span class=\"math display\">\\[\r\nKiBps\\]</span>​.</p>\r\n<h3 id=\"题解\">题解：</h3>\r\n<p>签到题，双指针扫一下即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum  = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum += a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j &gt;= k) sum -= a[j ++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i - j + <span class=\"number\">1</span> &lt; k) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt; &#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">double</span> spd = <span class=\"built_in\">double</span>(<span class=\"number\">1.0</span> * sum / k);</span><br><span class=\"line\">\t\tstring ad = <span class=\"string\">&quot;KiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(spd &gt;= <span class=\"number\">1024</span>) spd /= <span class=\"number\">1024</span>, ad = <span class=\"string\">&quot;MiBps&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.6lf&quot;</span>, spd);</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ad&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g.-download-time-monitor\">G. Download Time Monitor</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRw==\">Problem - G -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-1\">题意：</h3>\r\n<p>您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。</p>\r\n<p>您使用的网络带宽为 <span class=\"math display\">\\[B\\]</span>\r\nMiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 <span\r\nclass=\"math inline\">\\(t_1\\)</span> 秒，大小为 <span\r\nclass=\"math display\">\\[a_1\\]</span> MiB，而第二个文件开始下载的时间为\r\n<span class=\"math display\">\\[t_2\\]</span> 秒，大小为 <span\r\nclass=\"math display\">\\[a_2\\]</span>\r\nMiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在\r\n<span class=\"math display\">\\[B\\]</span>\r\nMiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 <span\r\nclass=\"math display\">\\[\\frac{B}{2}\\]</span>\r\nMiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。</p>\r\n<p>现在，您想知道两个文件完成下载各需要多长时间。</p>\r\n<h3 id=\"题解-1\">题解：</h3>\r\n<p>出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）</p>\r\n<p>这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。</p>\r\n<p>注意是下载花费时间而不是总时间</p>\r\n<p>这题浮点运算常数较大，开O2和解同步会比较好</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> GCC optimize(2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIO std::ios::sync_with_stdio(false);std::cin.tie(0);</span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> B,t1,t2,a1,a2;</span><br><span class=\"line\">\tcin&gt;&gt;B&gt;&gt;t1&gt;&gt;a1&gt;&gt;t2&gt;&gt;a2;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(t1 &gt; t2)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(t1,t2);<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\tf=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">double</span> d = t2-t1;</span><br><span class=\"line\">\t<span class=\"type\">double</span> a,b;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(d * B &gt; a1)&#123;</span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / B;</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a2 / B;</span><br><span class=\"line\">\t\td=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\ta1 -= d * B;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a1 &gt; a2) f^= <span class=\"number\">1</span>,<span class=\"built_in\">swap</span>(a1,a2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;a1&lt;&lt; &#x27; &#x27;&lt;&lt;a2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ta = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tb = <span class=\"number\">1.0</span> *a1 / (<span class=\"number\">1.0</span> *B/<span class=\"number\">2</span>) + <span class=\"number\">1.0</span> *(a2 - a1) /B;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,a + d, b);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.9lf %.9lf\\n&quot;</span>,b + d,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-number-deletion-game\">K. Number Deletion Game</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSw==\">Problem - K -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h3 id=\"题意-2\">题意：</h3>\r\n<p>爱丽丝和鲍勃正在玩一个数字删除游戏。</p>\r\n<p>一开始，有 <span class=\"math display\">\\[n\\]</span>$ 个整数 <span\r\nclass=\"math display\">\\[$a_ 1,a _ 2, \\ldots ,a _n\\]</span>\r\n。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除<strong>大的数字</strong><span\r\nclass=\"math display\">\\[x\\]</span>$ ，并选择一个比 <span\r\nclass=\"math display\">\\[$x\\]</span>**小的非负整数 <span\r\nclass=\"math display\">\\[y\\]</span>$ ，然后在数字 <span\r\nclass=\"math display\">\\[$1,2,\\ldots, y\\]</span>$\r\n中各加一个。特别是可以选择 <span class=\"math display\">\\[$y=0\\]</span>\r\n，在这种情况下不会添加任何数字。也就是说，删除 <span\r\nclass=\"math display\">\\[1\\]</span>\r\n时，不能添加任何数字。删除最后一个数字的人获胜。</p>\r\n<p>双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。</p>\r\n<h3 id=\"题解-2\">题解：</h3>\r\n<p>注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。</p>\r\n<p>另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。</p>\r\n<p>​ 那么对于最大值取<span class=\"math display\">\\[1 \\to\r\nk\\]</span>成立，试证明对k+1成立，分类讨论</p>\r\n<pre><code>1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶\r\n1. k+1为偶数个，同理，Bob胜</code></pre>\r\n<p>coding</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> num = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i] != a[n]) &#123;</span><br><span class=\"line\">\t\t\tnum = n-i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num == <span class=\"number\">-1</span>) num = n;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;num&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(num&amp;<span class=\"number\">1</span>) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"i.-integer-reaction\">I. Integer Reaction</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSQ==\">Problem - I -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>###　题意：</p>\r\n<p>有一个由 <span class=\"math display\">\\[n\\]</span>\r\n个整数组成的序列，从左到右编号为 <span class=\"math display\">\\[1\\]</span>\r\n到 <span class=\"math display\">\\[n\\]</span> 。这些整数有两种颜色，分别是\r\n<span class=\"math display\">\\[0\\]</span> 和 <span\r\nclass=\"math display\">\\[1\\]</span>\r\n，每个整数正好有一种颜色。这些整数按照从 <span\r\nclass=\"math display\">\\[1\\]</span>到 <span\r\nclass=\"math display\">\\[n\\]</span> 的编号顺序进入多集合 <span\r\nclass=\"math display\">\\[S_1\\]</span> 。</p>\r\n<p>每当一个新的整数 <span class=\"math display\">\\[x\\]</span> 进入 <span\r\nclass=\"math display\">\\[S_1\\]</span> 时，你必须在 <span\r\nclass=\"math display\">\\[S_1\\]</span> 中选择一个颜色与 <span\r\nclass=\"math display\">\\[x\\]</span> 不同的整数 <span\r\nclass=\"math display\">\\[y\\]</span> 与 <span\r\nclass=\"math display\">\\[x\\]</span> 发生反应，使得 <span\r\nclass=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> 消失，反应产物 <span\r\nclass=\"math display\">\\[x+y\\]</span> 插入另一个集合 <span\r\nclass=\"math display\">\\[S_2\\]</span> 中。如果不存在这样的 <span\r\nclass=\"math display\">\\[y\\]</span> ，则不会发生反应，只有 <span\r\nclass=\"math display\">\\[x\\]</span> 会插入 <span\r\nclass=\"math display\">\\[S_1\\]</span> 。</p>\r\n<p>给定整数序列和每个整数的颜色，求处理最后一个元素后 <span\r\nclass=\"math display\">\\[S_2\\]</span>​ 中最小元素的最大可能值。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>很简单，二分答案贪心维护<span\r\nclass=\"math display\">\\[S_1\\]</span>即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ck</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class=\"line\">\tmultiset&lt;<span class=\"type\">int</span>&gt; ms;</span><br><span class=\"line\">\t<span class=\"type\">int</span> c = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(c == a[i].y)&#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ms.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// cout&lt;&lt;x-a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">auto</span> it = <span class=\"built_in\">lower_bound</span>(<span class=\"built_in\">all</span>(ms), x - a[i].x);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(it == ms.<span class=\"built_in\">end</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// if(x==7)cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tms.<span class=\"built_in\">insert</span>(a[i].x);</span><br><span class=\"line\">\t\t\t\tc = a[i].y;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].x);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i].y);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">1</span>,r = INF;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r<span class=\"number\">+1</span> &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">ck</span>(mid)) l = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2024河南CCPC邀请赛-VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 河南CCPC-VP\n\n[Dashboard - 2024 National Invitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate Programming Contest - Codeforces](https://codeforces.com/gym/105158)\n\n## J. [排列与合数](https://codeforces.com/gym/105158/problem/J)\n\n### 题意：\n\n​\t小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。 与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关 的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的： 给定一个有且仅有5 位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位， 但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′ 能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345 时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以 重新排列数位得到合数n′=97531=7×13933。 一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。 现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？\n\n### 题解：\n\n​\t签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tstring s;cin>>s;\n\t\tsort(all(s));\n\t\tbool flag= 0;\n\t\tdo{\n\t\t\tint t = 0;\n\t\t\tfor(int i=0;i<5;i++)\n\t\t\t\tt = t * 10 + (s[i] - '0');\n\t\t\tif(t <=10000) continue;\n\t\t\tint f = 1;\n\t\t\tfor(int i=2;i*i<=t;i++)\n\t\t\t\tif(t % i == 0){\n\t\t\t\t\tf=0;break;\n\t\t\t\t}\n\t\t\tif(!f) {cout<<t<<endl;flag =1;break;}\n\t\t}while(next_permutation(all(s)));\n\t\tif(!flag) cout<<-1<<endl;\n\t}\n}\n```\n\n## B.[扫雷 1](https://codeforces.com/gym/105158/problem/B)\n\n### 题意：\n\n​\t T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。 具体来说，T0xel 会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫 雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci 枚扫 雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。 现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？\n\n### 题解\n\n注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tc[i] = a[i].x;\n\t\ta[i].y = i;\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint flag = 0;\n\tint now = 0, ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tnow ++;\n\t\twhile(a[flag].y < i) flag++;\n\t\tif(a[flag].y == i){\n\t\t\tans += now / c[i];\n\t\t\tnow = now % c[i];\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F.[优秀字符串](https://codeforces.com/gym/105158/problem/F)\n\n### 题意：\n\n小A认为，一个字符串S是优秀字符串，当且仅当：\n\n- S 的长度|S|恰好为5\n- S 的第三个字符与第五个字符相同\n- S 的前四个字符互不相同。 \n\n例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query 的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue 的前四个字符中u出现了两次。 现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中 优秀字符串的数量\n\n### 题解\n\n签到，不做阐述\n\n```cpp\nvoid slove() {\n\tcin>>n;int cnt = 0;\n\tfor(int i=1;i<=n;i++){\n\tstring s;cin>>s;\n\t\tif(s.size()!=5){\n\t\t\tcontinue;\n\t\t}else {\n\t\t\tset<char> S;\n\t\t\tfor(int i=0;i<4;i++)S.insert(s[i]);\n\n\t\t\tif(S.size()!=4){\n\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\tif(s[2] != s[4]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tcnt ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\n## M. [有效算法](https://codeforces.com/gym/105158/problem/M)\n\n### 题意：\n\n给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：\n\n- 将ai 变成满足|ai−x|≤k×bi 的任意整数x。 \n\n请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。\n\n### 题解：\n\n分情况讨论绝对值，即可得出以下两个不等式组\n$$\na_i \\le x \\le a_i + k * b_i\\\\\na_i - k * b_i \\le x \\le a_i\n$$\n考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数\n\n考虑暴力一下，枚举的mn到mx为x，发现\n$$\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}\n$$\n但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。\n\n转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。\n\n如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。\n\n我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。\n\n注意可能有极端情况$$a_i$$​均相等\n\n神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。\n\n下面是code\n\n```cpp\nint check(int x){\n\tL.clear(),R.clear(),ves.clear();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tL.push_back(a[i].x - x * a[i].y);\n\t\tR.push_back(a[i].x + x * a[i].y);\n\t}\n\t// cout<<mx<<' '<<mn<<endl;\n\tint l = mn, r = mx;\n\tfor(int i =0; i < n; i++){\n\t\t// cout<< L[i]<<endl;\n\t\tl = max(L[i],l);\n\t\tr = min(r,R[i]);\n\t}\n\t// cout<<x<< ' ' <<l<< ' ' <<r<<endl;\n\tif(l<=r) return 1;\n\telse return 0;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tmx=max(a[i].x,mx);\n\t\tmn=min(a[i].x,mn);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].y;\n\t}\n\n\t// for(int i=1;i<=n;i++) cout<<a[i].x<<'-'<<a[i].y<<endl;\n\n\tll l = 0, r = mx-mn;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\t// cout<<mid<<endl;\n\t\tif(check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tcout<<r<<endl;\n}\n\n```\n\n## H.[随机栈](https://codeforces.com/gym/105158/problem/H)\n\n### 题意：\n\n​\tToxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集 S，从一个非空的随机栈 S 中取出一个 元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会 从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有 2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel 正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插 入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合 非空。Toxel 想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增 的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。 由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。\n\n### 题解：\n\n题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。\n\ncode\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nll inv(ll x){return qmi(x,MOD-2);}\n\nvoid init(){}\n\nvoid slove() {\n\tcin>>n;\n\tvector<int> a,ords;\n\tfor(int i=1;i<=(n<<1);i++){\n\t\tint op;\n\t\tcin>>op;\n\t\tif(~op) a.pb(op);\n\t\tords.pb(op);\n\t}\n\tsort(all(a));\n\n\tint flag= 0;\n\tint ans = 1;\n\tfor(auto op : ords){\n\t\tif(op==-1){\n\t\t\t// cout<<cnt[a[flag]]<< ' '<<sum<<endl;\n\t\t\tans *= cnt[a[flag]] * inv(sum) % MOD;\n\t\t\tans %= MOD;\n\t\t\tcnt[a[flag]]--;\n\t\t\tflag++;\n\t\t\tsum--;\n\t\t}else {\n\t\t\tcnt[op] ++;sum ++;\n\t\t}\n\t}\n\n\tcout<<ans % MOD<<endl;\n}\n```\n\n待续。。。。笔者吃饭去了\n\n## L. [Toxel 与 PCPC II](https://codeforces.com/gym/105158/problem/L)\n\n### 题面：\n\n​\t Toxel 正在参加 PCPC（Pokémon Center Programming Contest）比赛。它写的一段代码中有不少 bug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁 定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。 Toxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1 行开始，顺序运行完 第i行后退出。Toxel 可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i 秒。接下来，Toxel 会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修 复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4 秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC 的赛场争分夺秒。请你帮Toxel 计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？\n\n### 题解：\n\n考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d = j - i，则花费差为\n$$\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\ \n\\Delta = (x+1)^4 - x^4 - i - 1\n$$\n注意到$$i+1$$是常数，但对$$(x+1) ^4- x^4$$ 这个值可能随着我们前面先debug一段而减少。\n\n让我们贪心的考虑，存在前缀，如果我们有$$(x+1)^4 - x^4 \\le i+1$$ ，则我们一定会向后拓展吗？如果不扩展，我们首先损失了$$\\Delta$$，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。\n\n实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展\n\n```cpp\nfor(int i=1;i<=m;i++){\n\t\tint s = 1;\n\t\twhile(i < m && a[i] + 1 >= qmi((s+1),4) - qmi(s,4) ){\n\t\t\ts ++;\n\t\t\ti ++;\n\t\t}\n\n\t\tans += (a[i] + qmi(s,4));\n\t\tcout<<i<<' ' <<ans<<nline;\n\t}\n}\n```\n\n该代码在样例\n\n```cpp\n20 20\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n```\n\n计算答案为\n\n```cpp\n224\n```\n\n但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用$$(x+1)^4 - x^4$$去换$$i+1$$的成本量，相同情况下当然希望后面的扩展越多越好，此时$$i$$更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。\n\n但还是wa， 考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp\n\n根据上面的公式，状态表示为\n$$\nf_i 前i个bug修改所需最小代价\n$$\n状态转移表示为\n$$\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) <= a[i-j] + 1 \\&\\& i-j+1 > 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}\n$$\n暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。\n\ncoding。。。\n\n```cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i =1;i<=m;i++) cin>>a[i];\n\n\tmemset(f,0x3f,sizeof f);\n\tf[0] = 0;\n\n\tint ans = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tf[i] = f[i-1] + a[i] + 1;\n\t\t// cout<<\"#\"<<i<< ' ' <<f[i]<<endl; \n\t\tfor(int j=2;qmi(j,4)- qmi(j-1,4) <= a[i-j+1] + 1 && i-j+1 > 0; j++)\n\t\t{\n\n\t\t\tf[i] = min(f[i-j] + qmi(j,4) + a[i],f[i]);\n\t\t\t// cout<<i<<' '<<j<< ' ' << f[i] <<endl;\n\t\t}\n\t}\n\tcout<<f[m]<<endl;\n}\n```\n\n## K. [树上问题](https://codeforces.com/gym/105158/problem/K)\n\n### 题意:\n\n​\t378QAQ 有一棵由 n 个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ 认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其 点权都.不 .小 .于其父亲节点的点权的 1 2。 请你计算出有多少个节点是美丽节点。\n\n### 题解：\n\n​\t若：\n$$\na >= b/2\n$$\n​\t则：\n$$\n2*a >= b \\rightarrow \\{a/2<=b<=2*a\\}\n$$\n​\t即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。\n\n​\t考虑更换顶点对点关系的影响：\n\n1. 原根节点与新的根节点之间一定是父子关系\n2. 更换根节点仅更改了原根到新根路径上的节点的父子关系。\n\n​\t于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。\n\n​\t显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。\n\n​\t一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。\n\ncoding\n\n```cpp\nint tarjan(int u){\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u, istk[u] = 1;\n    for(int v: e[u]){\n        if(!dfn[v]){\n            tarjan(v);\n            low[u] = min(low[u],low[v]);\n        }else if(istk[v]){\n            low[u] = min(low[u],dfn[v]);\n        }\n    }\n\n    if(low[u] == dfn[u]){\n        int p;\n        scou++;\n        do{\n            p = stk[top--];\n            istk[p] = 0;\n            scnt[scou]++;\n            id[p] = scou;\n        }while(p!=u);\n    }\n}\n\nvoid slove() {\n\tcin>>n;\n\n    scou = top = timestamp = 0;\n    for(int i=1;i<=n;i++) e[i].clear(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = 0;\n\n    for(int i=1;i<=n;i++) cin>>w[i];\n\n    for(int i=1;i<=n-1;i++)\n    {\n        int a,b;cin>>a>>b;\n        // cout<<a<<' '<<b<<endl;\n        if(ceil(1.0*w[a]/2) <= w[b] && w[b] <= (w[a] * 2)){\n            // cout<<a<< ' '<<b<<endl;\n            e[a].pb(b);\n            e[b].pb(a);\n        }else {\n            if(w[a] > w[b]) swap(a,b);\n            e[a].pb(b);\n            // cout<<\"###\"<<a<< ' '<< b<<endl;\n        }\n    }\n    // cout<<nline;\n\n    for(int i=1;i<=n;i++) {\n        if(!dfn[i]){\n            tarjan(i);\n        }\n    }\n\n    for(int i=1;i<=scou;i++) din[i] = 0;\n\n    multiset<ull> rcd;\n    for(int i=1;i<=n;i++) {\n        // cout<<\"---\"<<i<< ' ' <<e[i].size()<<endl;\n        for(auto j: e[i]){\n            int a = id[i], b = id[j];\n            // cout<<i<<' ' << a<<endl;\n            // cout<<j<<' ' << b<<endl;\n            if(a != b && !rcd.count(a * 100000 + b)){\n                rcd.insert(a * 100000+b);\n                din[b] ++;\n            }\n        }\n    }\n\n    // for(int i=1;i<=n;i++){\n    //     cout<<id[i]<<' ';\n    // }\n    // cout<<nline;\n\n    // for(int i=1;i<=scou;i++){\n    //     cout<<scnt[i]<<' '<<din[i]<<endl;\n    // }\n    // cout<<endl;\n\n    int cnt =0,ans=0;\n    for(int i=1;i<=scou;i++){\n        if(!din[i] && !ans) ans = scnt[i];\n        else if(!din[i] && ans){\n            cout<<0<<endl;\n            return ;\n        }\n    }\n    cout<<ans<<endl;\n    return ;\n}\n```\n\n\n\n​\t\n","source":"_posts/2024河南CCPC邀请赛-VP.md","raw":"---\ntitle: 2024河南CCPC邀请赛-VP\ndate: 2024-08-14 19:46:31\ntags: [ccpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- ccpc邀请赛\n---\n\n## 河南CCPC-VP\n\n[Dashboard - 2024 National Invitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate Programming Contest - Codeforces](https://codeforces.com/gym/105158)\n\n## J. [排列与合数](https://codeforces.com/gym/105158/problem/J)\n\n### 题意：\n\n​\t小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。 与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关 的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的： 给定一个有且仅有5 位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位， 但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′ 能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345 时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以 重新排列数位得到合数n′=97531=7×13933。 一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。 现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？\n\n### 题解：\n\n​\t签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tstring s;cin>>s;\n\t\tsort(all(s));\n\t\tbool flag= 0;\n\t\tdo{\n\t\t\tint t = 0;\n\t\t\tfor(int i=0;i<5;i++)\n\t\t\t\tt = t * 10 + (s[i] - '0');\n\t\t\tif(t <=10000) continue;\n\t\t\tint f = 1;\n\t\t\tfor(int i=2;i*i<=t;i++)\n\t\t\t\tif(t % i == 0){\n\t\t\t\t\tf=0;break;\n\t\t\t\t}\n\t\t\tif(!f) {cout<<t<<endl;flag =1;break;}\n\t\t}while(next_permutation(all(s)));\n\t\tif(!flag) cout<<-1<<endl;\n\t}\n}\n```\n\n## B.[扫雷 1](https://codeforces.com/gym/105158/problem/B)\n\n### 题意：\n\n​\t T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。 具体来说，T0xel 会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫 雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci 枚扫 雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。 现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？\n\n### 题解\n\n注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tc[i] = a[i].x;\n\t\ta[i].y = i;\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint flag = 0;\n\tint now = 0, ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tnow ++;\n\t\twhile(a[flag].y < i) flag++;\n\t\tif(a[flag].y == i){\n\t\t\tans += now / c[i];\n\t\t\tnow = now % c[i];\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F.[优秀字符串](https://codeforces.com/gym/105158/problem/F)\n\n### 题意：\n\n小A认为，一个字符串S是优秀字符串，当且仅当：\n\n- S 的长度|S|恰好为5\n- S 的第三个字符与第五个字符相同\n- S 的前四个字符互不相同。 \n\n例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query 的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue 的前四个字符中u出现了两次。 现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中 优秀字符串的数量\n\n### 题解\n\n签到，不做阐述\n\n```cpp\nvoid slove() {\n\tcin>>n;int cnt = 0;\n\tfor(int i=1;i<=n;i++){\n\tstring s;cin>>s;\n\t\tif(s.size()!=5){\n\t\t\tcontinue;\n\t\t}else {\n\t\t\tset<char> S;\n\t\t\tfor(int i=0;i<4;i++)S.insert(s[i]);\n\n\t\t\tif(S.size()!=4){\n\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\tif(s[2] != s[4]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tcnt ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}\n```\n\n## M. [有效算法](https://codeforces.com/gym/105158/problem/M)\n\n### 题意：\n\n给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：\n\n- 将ai 变成满足|ai−x|≤k×bi 的任意整数x。 \n\n请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。\n\n### 题解：\n\n分情况讨论绝对值，即可得出以下两个不等式组\n$$\na_i \\le x \\le a_i + k * b_i\\\\\na_i - k * b_i \\le x \\le a_i\n$$\n考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数\n\n考虑暴力一下，枚举的mn到mx为x，发现\n$$\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}\n$$\n但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。\n\n转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。\n\n如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。\n\n我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。\n\n注意可能有极端情况$$a_i$$​均相等\n\n神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。\n\n下面是code\n\n```cpp\nint check(int x){\n\tL.clear(),R.clear(),ves.clear();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tL.push_back(a[i].x - x * a[i].y);\n\t\tR.push_back(a[i].x + x * a[i].y);\n\t}\n\t// cout<<mx<<' '<<mn<<endl;\n\tint l = mn, r = mx;\n\tfor(int i =0; i < n; i++){\n\t\t// cout<< L[i]<<endl;\n\t\tl = max(L[i],l);\n\t\tr = min(r,R[i]);\n\t}\n\t// cout<<x<< ' ' <<l<< ' ' <<r<<endl;\n\tif(l<=r) return 1;\n\telse return 0;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tmx=max(a[i].x,mx);\n\t\tmn=min(a[i].x,mn);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].y;\n\t}\n\n\t// for(int i=1;i<=n;i++) cout<<a[i].x<<'-'<<a[i].y<<endl;\n\n\tll l = 0, r = mx-mn;\n\twhile(l<r){\n\t\tint mid = l+r>>1;\n\t\t// cout<<mid<<endl;\n\t\tif(check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tcout<<r<<endl;\n}\n\n```\n\n## H.[随机栈](https://codeforces.com/gym/105158/problem/H)\n\n### 题意：\n\n​\tToxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集 S，从一个非空的随机栈 S 中取出一个 元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会 从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有 2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel 正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插 入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合 非空。Toxel 想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增 的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。 由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。\n\n### 题解：\n\n题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。\n\ncode\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nll inv(ll x){return qmi(x,MOD-2);}\n\nvoid init(){}\n\nvoid slove() {\n\tcin>>n;\n\tvector<int> a,ords;\n\tfor(int i=1;i<=(n<<1);i++){\n\t\tint op;\n\t\tcin>>op;\n\t\tif(~op) a.pb(op);\n\t\tords.pb(op);\n\t}\n\tsort(all(a));\n\n\tint flag= 0;\n\tint ans = 1;\n\tfor(auto op : ords){\n\t\tif(op==-1){\n\t\t\t// cout<<cnt[a[flag]]<< ' '<<sum<<endl;\n\t\t\tans *= cnt[a[flag]] * inv(sum) % MOD;\n\t\t\tans %= MOD;\n\t\t\tcnt[a[flag]]--;\n\t\t\tflag++;\n\t\t\tsum--;\n\t\t}else {\n\t\t\tcnt[op] ++;sum ++;\n\t\t}\n\t}\n\n\tcout<<ans % MOD<<endl;\n}\n```\n\n待续。。。。笔者吃饭去了\n\n## L. [Toxel 与 PCPC II](https://codeforces.com/gym/105158/problem/L)\n\n### 题面：\n\n​\t Toxel 正在参加 PCPC（Pokémon Center Programming Contest）比赛。它写的一段代码中有不少 bug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁 定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。 Toxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1 行开始，顺序运行完 第i行后退出。Toxel 可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i 秒。接下来，Toxel 会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修 复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4 秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC 的赛场争分夺秒。请你帮Toxel 计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？\n\n### 题解：\n\n考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d = j - i，则花费差为\n$$\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\ \n\\Delta = (x+1)^4 - x^4 - i - 1\n$$\n注意到$$i+1$$是常数，但对$$(x+1) ^4- x^4$$ 这个值可能随着我们前面先debug一段而减少。\n\n让我们贪心的考虑，存在前缀，如果我们有$$(x+1)^4 - x^4 \\le i+1$$ ，则我们一定会向后拓展吗？如果不扩展，我们首先损失了$$\\Delta$$，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。\n\n实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展\n\n```cpp\nfor(int i=1;i<=m;i++){\n\t\tint s = 1;\n\t\twhile(i < m && a[i] + 1 >= qmi((s+1),4) - qmi(s,4) ){\n\t\t\ts ++;\n\t\t\ti ++;\n\t\t}\n\n\t\tans += (a[i] + qmi(s,4));\n\t\tcout<<i<<' ' <<ans<<nline;\n\t}\n}\n```\n\n该代码在样例\n\n```cpp\n20 20\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n```\n\n计算答案为\n\n```cpp\n224\n```\n\n但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用$$(x+1)^4 - x^4$$去换$$i+1$$的成本量，相同情况下当然希望后面的扩展越多越好，此时$$i$$更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。\n\n但还是wa， 考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp\n\n根据上面的公式，状态表示为\n$$\nf_i 前i个bug修改所需最小代价\n$$\n状态转移表示为\n$$\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) <= a[i-j] + 1 \\&\\& i-j+1 > 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}\n$$\n暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。\n\ncoding。。。\n\n```cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i =1;i<=m;i++) cin>>a[i];\n\n\tmemset(f,0x3f,sizeof f);\n\tf[0] = 0;\n\n\tint ans = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tf[i] = f[i-1] + a[i] + 1;\n\t\t// cout<<\"#\"<<i<< ' ' <<f[i]<<endl; \n\t\tfor(int j=2;qmi(j,4)- qmi(j-1,4) <= a[i-j+1] + 1 && i-j+1 > 0; j++)\n\t\t{\n\n\t\t\tf[i] = min(f[i-j] + qmi(j,4) + a[i],f[i]);\n\t\t\t// cout<<i<<' '<<j<< ' ' << f[i] <<endl;\n\t\t}\n\t}\n\tcout<<f[m]<<endl;\n}\n```\n\n## K. [树上问题](https://codeforces.com/gym/105158/problem/K)\n\n### 题意:\n\n​\t378QAQ 有一棵由 n 个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ 认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其 点权都.不 .小 .于其父亲节点的点权的 1 2。 请你计算出有多少个节点是美丽节点。\n\n### 题解：\n\n​\t若：\n$$\na >= b/2\n$$\n​\t则：\n$$\n2*a >= b \\rightarrow \\{a/2<=b<=2*a\\}\n$$\n​\t即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。\n\n​\t考虑更换顶点对点关系的影响：\n\n1. 原根节点与新的根节点之间一定是父子关系\n2. 更换根节点仅更改了原根到新根路径上的节点的父子关系。\n\n​\t于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。\n\n​\t显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。\n\n​\t一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。\n\ncoding\n\n```cpp\nint tarjan(int u){\n    dfn[u] = low[u] = ++timestamp;\n    stk[++top] = u, istk[u] = 1;\n    for(int v: e[u]){\n        if(!dfn[v]){\n            tarjan(v);\n            low[u] = min(low[u],low[v]);\n        }else if(istk[v]){\n            low[u] = min(low[u],dfn[v]);\n        }\n    }\n\n    if(low[u] == dfn[u]){\n        int p;\n        scou++;\n        do{\n            p = stk[top--];\n            istk[p] = 0;\n            scnt[scou]++;\n            id[p] = scou;\n        }while(p!=u);\n    }\n}\n\nvoid slove() {\n\tcin>>n;\n\n    scou = top = timestamp = 0;\n    for(int i=1;i<=n;i++) e[i].clear(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = 0;\n\n    for(int i=1;i<=n;i++) cin>>w[i];\n\n    for(int i=1;i<=n-1;i++)\n    {\n        int a,b;cin>>a>>b;\n        // cout<<a<<' '<<b<<endl;\n        if(ceil(1.0*w[a]/2) <= w[b] && w[b] <= (w[a] * 2)){\n            // cout<<a<< ' '<<b<<endl;\n            e[a].pb(b);\n            e[b].pb(a);\n        }else {\n            if(w[a] > w[b]) swap(a,b);\n            e[a].pb(b);\n            // cout<<\"###\"<<a<< ' '<< b<<endl;\n        }\n    }\n    // cout<<nline;\n\n    for(int i=1;i<=n;i++) {\n        if(!dfn[i]){\n            tarjan(i);\n        }\n    }\n\n    for(int i=1;i<=scou;i++) din[i] = 0;\n\n    multiset<ull> rcd;\n    for(int i=1;i<=n;i++) {\n        // cout<<\"---\"<<i<< ' ' <<e[i].size()<<endl;\n        for(auto j: e[i]){\n            int a = id[i], b = id[j];\n            // cout<<i<<' ' << a<<endl;\n            // cout<<j<<' ' << b<<endl;\n            if(a != b && !rcd.count(a * 100000 + b)){\n                rcd.insert(a * 100000+b);\n                din[b] ++;\n            }\n        }\n    }\n\n    // for(int i=1;i<=n;i++){\n    //     cout<<id[i]<<' ';\n    // }\n    // cout<<nline;\n\n    // for(int i=1;i<=scou;i++){\n    //     cout<<scnt[i]<<' '<<din[i]<<endl;\n    // }\n    // cout<<endl;\n\n    int cnt =0,ans=0;\n    for(int i=1;i<=scou;i++){\n        if(!din[i] && !ans) ans = scnt[i];\n        else if(!din[i] && ans){\n            cout<<0<<endl;\n            return ;\n        }\n    }\n    cout<<ans<<endl;\n    return ;\n}\n```\n\n\n\n​\t\n","slug":"2024河南CCPC邀请赛-VP","published":1,"updated":"2024-08-15T03:49:01.699Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt10007wwwv5h4ocr0z","content":"<h2 id=\"河南ccpc-vp\">河南CCPC-VP</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4\">Dashboard - 2024 National\r\nInvitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate\r\nProgramming Contest - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h2 id=\"j.-排列与合数\">J. <a\r\nhref=\"https://codeforces.com/gym/105158/problem/J\">排列与合数</a></h2>\r\n<h3 id=\"题意\">题意：</h3>\r\n<p>​\r\n小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。\r\n与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关\r\n的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的：\r\n给定一个有且仅有5\r\n位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位，\r\n但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′\r\n能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345\r\n时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以\r\n重新排列数位得到合数n′=97531=7×13933。\r\n一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。\r\n现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？</p>\r\n<h3 id=\"题解\">题解：</h3>\r\n<p>​\r\n签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(s));</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)</span><br><span class=\"line\">\t\t\t\tt = t * <span class=\"number\">10</span> + (s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &lt;=<span class=\"number\">10000</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i*i&lt;=t;i++)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(t % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf=<span class=\"number\">0</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;t&lt;&lt;endl;flag =<span class=\"number\">1</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(<span class=\"built_in\">all</span>(s)));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!flag) cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"b.扫雷-1\">B.<a\r\nhref=\"https://codeforces.com/gym/105158/problem/B\">扫雷 1</a></h2>\r\n<h3 id=\"题意-1\">题意：</h3>\r\n<p>​ T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。\r\n具体来说，T0xel\r\n会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫\r\n雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci\r\n枚扫\r\n雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。\r\n现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tc[i] = a[i].x;</span><br><span class=\"line\">\t\ta[i].y = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tnow ++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(a[flag].y &lt; i) flag++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[flag].y == i)&#123;</span><br><span class=\"line\">\t\t\tans += now / c[i];</span><br><span class=\"line\">\t\t\tnow = now % c[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f.优秀字符串\">F.<a\r\nhref=\"https://codeforces.com/gym/105158/problem/F\">优秀字符串</a></h2>\r\n<h3 id=\"题意-2\">题意：</h3>\r\n<p>小A认为，一个字符串S是优秀字符串，当且仅当：</p>\r\n<ul>\r\n<li>S 的长度|S|恰好为5</li>\r\n<li>S 的第三个字符与第五个字符相同</li>\r\n<li>S 的前四个字符互不相同。</li>\r\n</ul>\r\n<p>例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query\r\n的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue\r\n的前四个字符中u出现了两次。\r\n现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中\r\n优秀字符串的数量</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>签到，不做阐述</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>()!=<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tset&lt;<span class=\"type\">char</span>&gt; S;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)S.<span class=\"built_in\">insert</span>(s[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(S.<span class=\"built_in\">size</span>()!=<span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(s[<span class=\"number\">2</span>] != s[<span class=\"number\">4</span>])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tcnt ++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"m.-有效算法\">M. <a\r\nhref=\"https://codeforces.com/gym/105158/problem/M\">有效算法</a></h2>\r\n<h3 id=\"题意-3\">题意：</h3>\r\n<p>给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：</p>\r\n<ul>\r\n<li>将ai 变成满足|ai−x|≤k×bi 的任意整数x。</li>\r\n</ul>\r\n<p>请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。</p>\r\n<h3 id=\"题解-3\">题解：</h3>\r\n<p>分情况讨论绝对值，即可得出以下两个不等式组 <span\r\nclass=\"math display\">\\[\r\na_i \\le x \\le a_i + k * b_i\\\\\r\na_i - k * b_i \\le x \\le a_i\r\n\\]</span>\r\n考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数</p>\r\n<p>考虑暴力一下，枚举的mn到mx为x，发现 <span class=\"math display\">\\[\r\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}\r\n\\]</span>\r\n但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。</p>\r\n<p>转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。</p>\r\n<p>如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。</p>\r\n<p>我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。</p>\r\n<p>注意可能有极端情况<span class=\"math display\">\\[a_i\\]</span>​均相等</p>\r\n<p>神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。</p>\r\n<p>下面是code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tL.<span class=\"built_in\">clear</span>(),R.<span class=\"built_in\">clear</span>(),ves.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tL.<span class=\"built_in\">push_back</span>(a[i].x - x * a[i].y);</span><br><span class=\"line\">\t\tR.<span class=\"built_in\">push_back</span>(a[i].x + x * a[i].y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;mn&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = mn, r = mx;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt; L[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tl = <span class=\"built_in\">max</span>(L[i],l);</span><br><span class=\"line\">\t\tr = <span class=\"built_in\">min</span>(r,R[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt; &#x27; &#x27; &lt;&lt;l&lt;&lt; &#x27; &#x27; &lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;=r) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tmx=<span class=\"built_in\">max</span>(a[i].x,mx);</span><br><span class=\"line\">\t\tmn=<span class=\"built_in\">min</span>(a[i].x,mn);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].x&lt;&lt;&#x27;-&#x27;&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tll l = <span class=\"number\">0</span>, r = mx-mn;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(mid)) r = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"h.随机栈\">H.<a\r\nhref=\"https://codeforces.com/gym/105158/problem/H\">随机栈</a></h2>\r\n<h3 id=\"题意-4\">题意：</h3>\r\n<p>​ Toxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集\r\nS，从一个非空的随机栈 S 中取出一个\r\n元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会\r\n从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有\r\n2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel\r\n正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插\r\n入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合\r\n非空。Toxel\r\n想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增\r\n的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。\r\n由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。</p>\r\n<h3 id=\"题解-4\">题解：</h3>\r\n<p>题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。</p>\r\n<p>code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">inv</span><span class=\"params\">(ll x)</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">qmi</span>(x,MOD<span class=\"number\">-2</span>);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; a,ords;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=(n&lt;&lt;<span class=\"number\">1</span>);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op;</span><br><span class=\"line\">\t\tcin&gt;&gt;op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(~op) a.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t\tords.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(a));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> op : ords)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt[a[flag]]&lt;&lt; &#x27; &#x27;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tans *= cnt[a[flag]] * <span class=\"built_in\">inv</span>(sum) % MOD;</span><br><span class=\"line\">\t\t\tans %= MOD;</span><br><span class=\"line\">\t\t\tcnt[a[flag]]--;</span><br><span class=\"line\">\t\t\tflag++;</span><br><span class=\"line\">\t\t\tsum--;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcnt[op] ++;sum ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>待续。。。。笔者吃饭去了</p>\r\n<h2 id=\"l.-toxel-与-pcpc-ii\">L. <a\r\nhref=\"https://codeforces.com/gym/105158/problem/L\">Toxel 与 PCPC\r\nII</a></h2>\r\n<h3 id=\"题面\">题面：</h3>\r\n<p>​ Toxel 正在参加 PCPC（Pokémon Center Programming\r\nContest）比赛。它写的一段代码中有不少\r\nbug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁\r\n定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。\r\nToxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1\r\n行开始，顺序运行完 第i行后退出。Toxel\r\n可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i\r\n秒。接下来，Toxel\r\n会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修\r\n复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4\r\n秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC\r\n的赛场争分夺秒。请你帮Toxel\r\n计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？</p>\r\n<h3 id=\"题解-5\">题解：</h3>\r\n<p>考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d\r\n= j - i，则花费差为 <span class=\"math display\">\\[\r\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\\r\n\\Delta = (x+1)^4 - x^4 - i - 1\r\n\\]</span> 注意到<span\r\nclass=\"math display\">\\[i+1\\]</span>是常数，但对<span\r\nclass=\"math display\">\\[(x+1) ^4- x^4\\]</span>\r\n这个值可能随着我们前面先debug一段而减少。</p>\r\n<p>让我们贪心的考虑，存在前缀，如果我们有<span\r\nclass=\"math display\">\\[(x+1)^4 - x^4 \\le i+1\\]</span>\r\n，则我们一定会向后拓展吗？如果不扩展，我们首先损失了<span\r\nclass=\"math display\">\\[\\Delta\\]</span>，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。</p>\r\n<p>实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> s = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; m &amp;&amp; a[i] + <span class=\"number\">1</span> &gt;= <span class=\"built_in\">qmi</span>((s<span class=\"number\">+1</span>),<span class=\"number\">4</span>) - <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>) )&#123;</span><br><span class=\"line\">\t\t\ts ++;</span><br><span class=\"line\">\t\t\ti ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tans += (a[i] + <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>));</span><br><span class=\"line\">\t\tcout&lt;&lt;i&lt;&lt;<span class=\"string\">&#x27; &#x27;</span> &lt;&lt;ans&lt;&lt;nline;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>该代码在样例</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span> <span class=\"number\">20</span></span><br><span class=\"line\"> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">10</span> <span class=\"number\">11</span> <span class=\"number\">12</span> <span class=\"number\">13</span> <span class=\"number\">14</span> <span class=\"number\">15</span> <span class=\"number\">16</span> <span class=\"number\">17</span> <span class=\"number\">18</span> <span class=\"number\">19</span> <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\r\n<p>计算答案为</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">224</span></span><br></pre></td></tr></table></figure>\r\n<p>但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用<span\r\nclass=\"math display\">\\[(x+1)^4 - x^4\\]</span>去换<span\r\nclass=\"math display\">\\[i+1\\]</span>的成本量，相同情况下当然希望后面的扩展越多越好，此时<span\r\nclass=\"math display\">\\[i\\]</span>更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。</p>\r\n<p>但还是wa，\r\n考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp</p>\r\n<p>根据上面的公式，状态表示为 <span class=\"math display\">\\[\r\nf_i 前i个bug修改所需最小代价\r\n\\]</span> 状态转移表示为 <span class=\"math display\">\\[\r\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) &lt;= a[i-j] + 1\r\n\\&amp;\\&amp; i-j+1 &gt; 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}\r\n\\]</span>\r\n暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。</p>\r\n<p>coding。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tf[i] = f[i<span class=\"number\">-1</span>] + a[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;f[i]&lt;&lt;endl; </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">2</span>;<span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>)- <span class=\"built_in\">qmi</span>(j<span class=\"number\">-1</span>,<span class=\"number\">4</span>) &lt;= a[i-j<span class=\"number\">+1</span>] + <span class=\"number\">1</span> &amp;&amp; i-j<span class=\"number\">+1</span> &gt; <span class=\"number\">0</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tf[i] = <span class=\"built_in\">min</span>(f[i-j] + <span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>) + a[i],f[i]);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt; f[i] &lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-树上问题\">K. <a\r\nhref=\"https://codeforces.com/gym/105158/problem/K\">树上问题</a></h2>\r\n<h3 id=\"题意-5\">题意:</h3>\r\n<p>​ 378QAQ 有一棵由 n\r\n个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ\r\n认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其\r\n点权都.不 .小 .于其父亲节点的点权的 1 2。\r\n请你计算出有多少个节点是美丽节点。</p>\r\n<h3 id=\"题解-6\">题解：</h3>\r\n<p>​ 若： <span class=\"math display\">\\[\r\na &gt;= b/2\r\n\\]</span> ​ 则： <span class=\"math display\">\\[\r\n2*a &gt;= b \\rightarrow \\{a/2&lt;=b&lt;=2*a\\}\r\n\\]</span> ​\r\n即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。</p>\r\n<p>​ 考虑更换顶点对点关系的影响：</p>\r\n<ol type=\"1\">\r\n<li>原根节点与新的根节点之间一定是父子关系</li>\r\n<li>更换根节点仅更改了原根到新根路径上的节点的父子关系。</li>\r\n</ol>\r\n<p>​\r\n于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。</p>\r\n<p>​\r\n显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。</p>\r\n<p>​\r\n一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。</p>\r\n<p>coding</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    dfn[u] = low[u] = ++timestamp;</span><br><span class=\"line\">    stk[++top] = u, istk[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[v])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(v);</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(istk[v])&#123;</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low[u] == dfn[u])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p;</span><br><span class=\"line\">        scou++;</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            p = stk[top--];</span><br><span class=\"line\">            istk[p] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            scnt[scou]++;</span><br><span class=\"line\">            id[p] = scou;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(p!=u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    scou = top = timestamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) e[i].<span class=\"built_in\">clear</span>(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;a&lt;&lt;&#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">ceil</span>(<span class=\"number\">1.0</span>*w[a]/<span class=\"number\">2</span>) &lt;= w[b] &amp;&amp; w[b] &lt;= (w[a] * <span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w[a] &gt; w[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[i])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++) din[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    multiset&lt;ull&gt; rcd;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;e[i].size()&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j: e[i])&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = id[i], b = id[j];</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27; &lt;&lt; a&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;j&lt;&lt;&#x27; &#x27; &lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a != b &amp;&amp; !rcd.<span class=\"built_in\">count</span>(a * <span class=\"number\">100000</span> + b))&#123;</span><br><span class=\"line\">                rcd.<span class=\"built_in\">insert</span>(a * <span class=\"number\">100000</span>+b);</span><br><span class=\"line\">                din[b] ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;id[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=scou;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;scnt[i]&lt;&lt;&#x27; &#x27;&lt;&lt;din[i]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> cnt =<span class=\"number\">0</span>,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!din[i] &amp;&amp; !ans) ans = scnt[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!din[i] &amp;&amp; ans)&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>​</p>\r\n","length":3745,"excerpt":"","more":"<h2 id=\"河南ccpc-vp\">河南CCPC-VP</h2>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4\">Dashboard - 2024 National\r\nInvitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate\r\nProgramming Contest - Codeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h2 id=\"j.-排列与合数\">J. <a\r\nhref=\"https://codeforces.com/gym/105158/problem/J\">排列与合数</a></h2>\r\n<h3 id=\"题意\">题意：</h3>\r\n<p>​\r\n小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。\r\n与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关\r\n的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的：\r\n给定一个有且仅有5\r\n位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位，\r\n但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′\r\n能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345\r\n时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以\r\n重新排列数位得到合数n′=97531=7×13933。\r\n一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。\r\n现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？</p>\r\n<h3 id=\"题解\">题解：</h3>\r\n<p>​\r\n签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(s));</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)</span><br><span class=\"line\">\t\t\t\tt = t * <span class=\"number\">10</span> + (s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &lt;=<span class=\"number\">10000</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i*i&lt;=t;i++)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(t % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf=<span class=\"number\">0</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;t&lt;&lt;endl;flag =<span class=\"number\">1</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(<span class=\"built_in\">all</span>(s)));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!flag) cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"b.扫雷-1\">B.<a\r\nhref=\"https://codeforces.com/gym/105158/problem/B\">扫雷 1</a></h2>\r\n<h3 id=\"题意-1\">题意：</h3>\r\n<p>​ T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。\r\n具体来说，T0xel\r\n会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫\r\n雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci\r\n枚扫\r\n雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。\r\n现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tc[i] = a[i].x;</span><br><span class=\"line\">\t\ta[i].y = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tnow ++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(a[flag].y &lt; i) flag++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[flag].y == i)&#123;</span><br><span class=\"line\">\t\t\tans += now / c[i];</span><br><span class=\"line\">\t\t\tnow = now % c[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f.优秀字符串\">F.<a\r\nhref=\"https://codeforces.com/gym/105158/problem/F\">优秀字符串</a></h2>\r\n<h3 id=\"题意-2\">题意：</h3>\r\n<p>小A认为，一个字符串S是优秀字符串，当且仅当：</p>\r\n<ul>\r\n<li>S 的长度|S|恰好为5</li>\r\n<li>S 的第三个字符与第五个字符相同</li>\r\n<li>S 的前四个字符互不相同。</li>\r\n</ul>\r\n<p>例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query\r\n的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue\r\n的前四个字符中u出现了两次。\r\n现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中\r\n优秀字符串的数量</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>签到，不做阐述</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\tstring s;cin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>()!=<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tset&lt;<span class=\"type\">char</span>&gt; S;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)S.<span class=\"built_in\">insert</span>(s[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(S.<span class=\"built_in\">size</span>()!=<span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(s[<span class=\"number\">2</span>] != s[<span class=\"number\">4</span>])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tcnt ++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"m.-有效算法\">M. <a\r\nhref=\"https://codeforces.com/gym/105158/problem/M\">有效算法</a></h2>\r\n<h3 id=\"题意-3\">题意：</h3>\r\n<p>给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：</p>\r\n<ul>\r\n<li>将ai 变成满足|ai−x|≤k×bi 的任意整数x。</li>\r\n</ul>\r\n<p>请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。</p>\r\n<h3 id=\"题解-3\">题解：</h3>\r\n<p>分情况讨论绝对值，即可得出以下两个不等式组 <span\r\nclass=\"math display\">\\[\r\na_i \\le x \\le a_i + k * b_i\\\\\r\na_i - k * b_i \\le x \\le a_i\r\n\\]</span>\r\n考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数</p>\r\n<p>考虑暴力一下，枚举的mn到mx为x，发现 <span class=\"math display\">\\[\r\nans = max_{x=mn}^{mx}\\{max_{i=1}^{n}\\{ceil(abs(a_i - x)/b_i)\\}\\}\r\n\\]</span>\r\n但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。</p>\r\n<p>转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。</p>\r\n<p>如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。</p>\r\n<p>我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。</p>\r\n<p>注意可能有极端情况<span class=\"math display\">\\[a_i\\]</span>​均相等</p>\r\n<p>神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。</p>\r\n<p>下面是code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tL.<span class=\"built_in\">clear</span>(),R.<span class=\"built_in\">clear</span>(),ves.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tL.<span class=\"built_in\">push_back</span>(a[i].x - x * a[i].y);</span><br><span class=\"line\">\t\tR.<span class=\"built_in\">push_back</span>(a[i].x + x * a[i].y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;mn&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> l = mn, r = mx;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt; L[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tl = <span class=\"built_in\">max</span>(L[i],l);</span><br><span class=\"line\">\t\tr = <span class=\"built_in\">min</span>(r,R[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;x&lt;&lt; &#x27; &#x27; &lt;&lt;l&lt;&lt; &#x27; &#x27; &lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&lt;=r) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\tmx=<span class=\"built_in\">max</span>(a[i].x,mx);</span><br><span class=\"line\">\t\tmn=<span class=\"built_in\">min</span>(a[i].x,mn);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].x&lt;&lt;&#x27;-&#x27;&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tll l = <span class=\"number\">0</span>, r = mx-mn;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = l+r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(mid)) r = mid;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"h.随机栈\">H.<a\r\nhref=\"https://codeforces.com/gym/105158/problem/H\">随机栈</a></h2>\r\n<h3 id=\"题意-4\">题意：</h3>\r\n<p>​ Toxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集\r\nS，从一个非空的随机栈 S 中取出一个\r\n元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会\r\n从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有\r\n2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel\r\n正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插\r\n入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合\r\n非空。Toxel\r\n想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增\r\n的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。\r\n由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。</p>\r\n<h3 id=\"题解-4\">题解：</h3>\r\n<p>题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。</p>\r\n<p>code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">inv</span><span class=\"params\">(ll x)</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">qmi</span>(x,MOD<span class=\"number\">-2</span>);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; a,ords;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=(n&lt;&lt;<span class=\"number\">1</span>);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op;</span><br><span class=\"line\">\t\tcin&gt;&gt;op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(~op) a.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t\tords.<span class=\"built_in\">pb</span>(op);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(a));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> flag= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> op : ords)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt[a[flag]]&lt;&lt; &#x27; &#x27;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tans *= cnt[a[flag]] * <span class=\"built_in\">inv</span>(sum) % MOD;</span><br><span class=\"line\">\t\t\tans %= MOD;</span><br><span class=\"line\">\t\t\tcnt[a[flag]]--;</span><br><span class=\"line\">\t\t\tflag++;</span><br><span class=\"line\">\t\t\tsum--;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcnt[op] ++;sum ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>待续。。。。笔者吃饭去了</p>\r\n<h2 id=\"l.-toxel-与-pcpc-ii\">L. <a\r\nhref=\"https://codeforces.com/gym/105158/problem/L\">Toxel 与 PCPC\r\nII</a></h2>\r\n<h3 id=\"题面\">题面：</h3>\r\n<p>​ Toxel 正在参加 PCPC（Pokémon Center Programming\r\nContest）比赛。它写的一段代码中有不少\r\nbug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁\r\n定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。\r\nToxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1\r\n行开始，顺序运行完 第i行后退出。Toxel\r\n可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i\r\n秒。接下来，Toxel\r\n会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修\r\n复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4\r\n秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC\r\n的赛场争分夺秒。请你帮Toxel\r\n计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？</p>\r\n<h3 id=\"题解-5\">题解：</h3>\r\n<p>考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d\r\n= j - i，则花费差为 <span class=\"math display\">\\[\r\n\\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\\\\r\n\\Delta = (x+1)^4 - x^4 - i - 1\r\n\\]</span> 注意到<span\r\nclass=\"math display\">\\[i+1\\]</span>是常数，但对<span\r\nclass=\"math display\">\\[(x+1) ^4- x^4\\]</span>\r\n这个值可能随着我们前面先debug一段而减少。</p>\r\n<p>让我们贪心的考虑，存在前缀，如果我们有<span\r\nclass=\"math display\">\\[(x+1)^4 - x^4 \\le i+1\\]</span>\r\n，则我们一定会向后拓展吗？如果不扩展，我们首先损失了<span\r\nclass=\"math display\">\\[\\Delta\\]</span>，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。</p>\r\n<p>实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> s = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; m &amp;&amp; a[i] + <span class=\"number\">1</span> &gt;= <span class=\"built_in\">qmi</span>((s<span class=\"number\">+1</span>),<span class=\"number\">4</span>) - <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>) )&#123;</span><br><span class=\"line\">\t\t\ts ++;</span><br><span class=\"line\">\t\t\ti ++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tans += (a[i] + <span class=\"built_in\">qmi</span>(s,<span class=\"number\">4</span>));</span><br><span class=\"line\">\t\tcout&lt;&lt;i&lt;&lt;<span class=\"string\">&#x27; &#x27;</span> &lt;&lt;ans&lt;&lt;nline;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>该代码在样例</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span> <span class=\"number\">20</span></span><br><span class=\"line\"> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">10</span> <span class=\"number\">11</span> <span class=\"number\">12</span> <span class=\"number\">13</span> <span class=\"number\">14</span> <span class=\"number\">15</span> <span class=\"number\">16</span> <span class=\"number\">17</span> <span class=\"number\">18</span> <span class=\"number\">19</span> <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\r\n<p>计算答案为</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">224</span></span><br></pre></td></tr></table></figure>\r\n<p>但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用<span\r\nclass=\"math display\">\\[(x+1)^4 - x^4\\]</span>去换<span\r\nclass=\"math display\">\\[i+1\\]</span>的成本量，相同情况下当然希望后面的扩展越多越好，此时<span\r\nclass=\"math display\">\\[i\\]</span>更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。</p>\r\n<p>但还是wa，\r\n考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp</p>\r\n<p>根据上面的公式，状态表示为 <span class=\"math display\">\\[\r\nf_i 前i个bug修改所需最小代价\r\n\\]</span> 状态转移表示为 <span class=\"math display\">\\[\r\nf_i = max_{j=min\\{1\\}}^{j\\{|qmi(j,4)- qmi(j-1,4) &lt;= a[i-j] + 1\r\n\\&amp;\\&amp; i-j+1 &gt; 0\\}}\\{f_i,f_{i-j} + qmi(j,4) + a[i]\\}\r\n\\]</span>\r\n暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。</p>\r\n<p>coding。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tf[i] = f[i<span class=\"number\">-1</span>] + a[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;f[i]&lt;&lt;endl; </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">2</span>;<span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>)- <span class=\"built_in\">qmi</span>(j<span class=\"number\">-1</span>,<span class=\"number\">4</span>) &lt;= a[i-j<span class=\"number\">+1</span>] + <span class=\"number\">1</span> &amp;&amp; i-j<span class=\"number\">+1</span> &gt; <span class=\"number\">0</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tf[i] = <span class=\"built_in\">min</span>(f[i-j] + <span class=\"built_in\">qmi</span>(j,<span class=\"number\">4</span>) + a[i],f[i]);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt; f[i] &lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-树上问题\">K. <a\r\nhref=\"https://codeforces.com/gym/105158/problem/K\">树上问题</a></h2>\r\n<h3 id=\"题意-5\">题意:</h3>\r\n<p>​ 378QAQ 有一棵由 n\r\n个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ\r\n认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其\r\n点权都.不 .小 .于其父亲节点的点权的 1 2。\r\n请你计算出有多少个节点是美丽节点。</p>\r\n<h3 id=\"题解-6\">题解：</h3>\r\n<p>​ 若： <span class=\"math display\">\\[\r\na &gt;= b/2\r\n\\]</span> ​ 则： <span class=\"math display\">\\[\r\n2*a &gt;= b \\rightarrow \\{a/2&lt;=b&lt;=2*a\\}\r\n\\]</span> ​\r\n即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。</p>\r\n<p>​ 考虑更换顶点对点关系的影响：</p>\r\n<ol type=\"1\">\r\n<li>原根节点与新的根节点之间一定是父子关系</li>\r\n<li>更换根节点仅更改了原根到新根路径上的节点的父子关系。</li>\r\n</ol>\r\n<p>​\r\n于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。</p>\r\n<p>​\r\n显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。</p>\r\n<p>​\r\n一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。</p>\r\n<p>coding</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">tarjan</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    dfn[u] = low[u] = ++timestamp;</span><br><span class=\"line\">    stk[++top] = u, istk[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[v])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(v);</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(istk[v])&#123;</span><br><span class=\"line\">            low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low[u] == dfn[u])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p;</span><br><span class=\"line\">        scou++;</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            p = stk[top--];</span><br><span class=\"line\">            istk[p] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            scnt[scou]++;</span><br><span class=\"line\">            id[p] = scou;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(p!=u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    scou = top = timestamp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) e[i].<span class=\"built_in\">clear</span>(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;a&lt;&lt;&#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">ceil</span>(<span class=\"number\">1.0</span>*w[a]/<span class=\"number\">2</span>) &lt;= w[b] &amp;&amp; w[b] &lt;= (w[a] * <span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(w[a] &gt; w[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">            e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dfn[i])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">tarjan</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++) din[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    multiset&lt;ull&gt; rcd;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;e[i].size()&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j: e[i])&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = id[i], b = id[j];</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27; &lt;&lt; a&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;j&lt;&lt;&#x27; &#x27; &lt;&lt; b&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a != b &amp;&amp; !rcd.<span class=\"built_in\">count</span>(a * <span class=\"number\">100000</span> + b))&#123;</span><br><span class=\"line\">                rcd.<span class=\"built_in\">insert</span>(a * <span class=\"number\">100000</span>+b);</span><br><span class=\"line\">                din[b] ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;id[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=scou;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;scnt[i]&lt;&lt;&#x27; &#x27;&lt;&lt;din[i]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> cnt =<span class=\"number\">0</span>,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scou;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!din[i] &amp;&amp; !ans) ans = scnt[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!din[i] &amp;&amp; ans)&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>​</p>\r\n"},{"title":"2024湖北省赛VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## 湖北省赛VP\n\nhttps://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf\n\n## E. Spicy or Grilled?\n\n### 题意\n\n由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。\n\n![2aceebec00a61b0864fce9d24f11213aab3fc731](https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png)\n\n在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 $n$ 名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是 $a$ 元。但由于有些人像 Walk Alone 一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 $b$ 美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 $x$ 。\n\n但是，\"独行侠 \"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。\n\n### 题解\n\n我觉得麦当劳不素之霸更好吃，谁赞成，谁反对\n\n```cpp\nvoid slove() {\n\tint n,a,b,x;\n\tcin>>n>>x>>a>>b;\n\n\tcout<<1ll * (n-x) * a + x * b<<endl;\n}\n```\n\n## J. Points on the Number Axis A\n\n### 题意\n\n爱丽丝正在数轴上玩单人游戏。\n\n数轴上有 $n$ 个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是 $x_i$ 和 $x_j$，那么操作后将添加 $\\dfrac{x_i+x_j}{2}$ 。\n\n为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。\n\n现在爱丽丝有一个问题：最后一个点的预期位置在哪里？\n\n可以证明答案可以用 $\\dfrac{p}{q}$ 的形式表示，只需输出 $p\\cdot q^{-1} \\bmod 998,244,353$ 的值即可。\n\n### 题意\n\n其实就是所有点的平均值位置\n\n下面是证明：\n\n现在，假设我们有n个点，它们的坐标是$x_1, x_2, …, x_n$，并且我们已经证明了对于任意的$i$和$j$，点 $x_i$和$x_j$的中点的期望坐标是$\\frac{x_i + x_j}{2}$。那么，对于这$n$个点，我们可以计算它们所有可能中点的平均值：\n$$\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n$$\n\n以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的$x_i$它出现在了中点计算公式中出现了$n-1$次，因此后面的二重求和可以变为:\n$$\n \\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i\n$$\n剩下的就很好理解了。\n\n数学推导对这样的“显然解”证明，有着更好的一套方法：\n\n没能够看懂题解上得公式。。。。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tcout<<sum %MOD * qmi(n,MOD-2) % MOD<<endl;\n}\n```\n\n## A. Long Live\n\n### 题意\n\n在《我的世界》中，简单的世界有三个维度，其中一个维度被称为 \"终结\"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。\n\n![](https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png)\n\n现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下\n\n给定两个正整数 $x$ 和 $y$ ，请找出两个整数 $a$ 和 $b$ ，使得\n\n$$\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}\n$$\n\n并使 $a \\cdot b$ 最大。\n\n这里， $\\gcd(a,b)$ 表示 $a,b$ 的最大公约数，而 $\\rm lcm(a,b)$ 表示 $a,b$ 的最小公倍数。\n\n### 题意\n\n如果你的数学功底很好肯定可以极快的打出这一场的签到\n\n简单的数学带入推到公式得到\n\n$$\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}\n$$\n\n```cpp\nvoid slove() {\n\tint x,y;cin>>x>>y;\n\n\tint gc = gcd(x,y);\n\tint lc = lcm(x,y);\n\tcout<<1<<' '<<lc/gc<<endl;\n}\n```","source":"_posts/2024湖北省赛VP.md","raw":"---\ntitle: 2024湖北省赛VP\ndate: 2024-08-14 19:46:31\ntags: [icpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- icpc省赛\n---\n\n## 湖北省赛VP\n\nhttps://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf\n\n## E. Spicy or Grilled?\n\n### 题意\n\n由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。\n\n![2aceebec00a61b0864fce9d24f11213aab3fc731](https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png)\n\n在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 $n$ 名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是 $a$ 元。但由于有些人像 Walk Alone 一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 $b$ 美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 $x$ 。\n\n但是，\"独行侠 \"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。\n\n### 题解\n\n我觉得麦当劳不素之霸更好吃，谁赞成，谁反对\n\n```cpp\nvoid slove() {\n\tint n,a,b,x;\n\tcin>>n>>x>>a>>b;\n\n\tcout<<1ll * (n-x) * a + x * b<<endl;\n}\n```\n\n## J. Points on the Number Axis A\n\n### 题意\n\n爱丽丝正在数轴上玩单人游戏。\n\n数轴上有 $n$ 个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是 $x_i$ 和 $x_j$，那么操作后将添加 $\\dfrac{x_i+x_j}{2}$ 。\n\n为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。\n\n现在爱丽丝有一个问题：最后一个点的预期位置在哪里？\n\n可以证明答案可以用 $\\dfrac{p}{q}$ 的形式表示，只需输出 $p\\cdot q^{-1} \\bmod 998,244,353$ 的值即可。\n\n### 题意\n\n其实就是所有点的平均值位置\n\n下面是证明：\n\n现在，假设我们有n个点，它们的坐标是$x_1, x_2, …, x_n$，并且我们已经证明了对于任意的$i$和$j$，点 $x_i$和$x_j$的中点的期望坐标是$\\frac{x_i + x_j}{2}$。那么，对于这$n$个点，我们可以计算它们所有可能中点的平均值：\n$$\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i + x_j}{2}\n$$\n\n$$\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n$$\n\n以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的$x_i$它出现在了中点计算公式中出现了$n-1$次，因此后面的二重求和可以变为:\n$$\n \\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i\n$$\n剩下的就很好理解了。\n\n数学推导对这样的“显然解”证明，有着更好的一套方法：\n\n没能够看懂题解上得公式。。。。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tcout<<sum %MOD * qmi(n,MOD-2) % MOD<<endl;\n}\n```\n\n## A. Long Live\n\n### 题意\n\n在《我的世界》中，简单的世界有三个维度，其中一个维度被称为 \"终结\"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。\n\n![](https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png)\n\n现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下\n\n给定两个正整数 $x$ 和 $y$ ，请找出两个整数 $a$ 和 $b$ ，使得\n\n$$\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}\n$$\n\n并使 $a \\cdot b$ 最大。\n\n这里， $\\gcd(a,b)$ 表示 $a,b$ 的最大公约数，而 $\\rm lcm(a,b)$ 表示 $a,b$ 的最小公倍数。\n\n### 题意\n\n如果你的数学功底很好肯定可以极快的打出这一场的签到\n\n简单的数学带入推到公式得到\n\n$$\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}\n$$\n\n```cpp\nvoid slove() {\n\tint x,y;cin>>x>>y;\n\n\tint gc = gcd(x,y);\n\tint lc = lcm(x,y);\n\tcout<<1<<' '<<lc/gc<<endl;\n}\n```","slug":"2024湖北省赛VP","published":1,"updated":"2024-08-15T04:48:50.921Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt20009wwwvd8z48qh3","content":"<h2 id=\"湖北省赛vp\">湖北省赛VP</h2>\r\n<p>https://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf</p>\r\n<h2 id=\"e.-spicy-or-grilled\">E. Spicy or Grilled?</h2>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png\"\r\nalt=\"2aceebec00a61b0864fce9d24f11213aab3fc731\" />\r\n<figcaption\r\naria-hidden=\"true\">2aceebec00a61b0864fce9d24f11213aab3fc731</figcaption>\r\n</figure>\r\n<p>在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 <span\r\nclass=\"math inline\">\\(n\\)</span>\r\n名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是\r\n<span class=\"math inline\">\\(a\\)</span> 元。但由于有些人像 Walk Alone\r\n一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 <span\r\nclass=\"math inline\">\\(b\\)</span>\r\n美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 <span\r\nclass=\"math inline\">\\(x\\)</span> 。</p>\r\n<p>但是，\"独行侠\r\n\"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>我觉得麦当劳不素之霸更好吃，谁赞成，谁反对</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n,a,b,x;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1ll</span> * (n-x) * a + x * b&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"j.-points-on-the-number-axis-a\">J. Points on the Number Axis\r\nA</h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>爱丽丝正在数轴上玩单人游戏。</p>\r\n<p>数轴上有 <span class=\"math inline\">\\(n\\)</span>\r\n个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是\r\n<span class=\"math inline\">\\(x_i\\)</span> 和 <span\r\nclass=\"math inline\">\\(x_j\\)</span>，那么操作后将添加 <span\r\nclass=\"math inline\">\\(\\dfrac{x_i+x_j}{2}\\)</span> 。</p>\r\n<p>为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。</p>\r\n<p>现在爱丽丝有一个问题：最后一个点的预期位置在哪里？</p>\r\n<p>可以证明答案可以用 <span class=\"math inline\">\\(\\dfrac{p}{q}\\)</span>\r\n的形式表示，只需输出 <span class=\"math inline\">\\(p\\cdot q^{-1} \\bmod\r\n998,244,353\\)</span> 的值即可。</p>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>其实就是所有点的平均值位置</p>\r\n<p>下面是证明：</p>\r\n<p>现在，假设我们有n个点，它们的坐标是<span class=\"math inline\">\\(x_1,\r\nx_2, …, x_n\\)</span>，并且我们已经证明了对于任意的<span\r\nclass=\"math inline\">\\(i\\)</span>和<span\r\nclass=\"math inline\">\\(j\\)</span>，点 <span\r\nclass=\"math inline\">\\(x_i\\)</span>和<span\r\nclass=\"math inline\">\\(x_j\\)</span>的中点的期望坐标是<span\r\nclass=\"math inline\">\\(\\frac{x_i + x_j}{2}\\)</span>。那么，对于这<span\r\nclass=\"math inline\">\\(n\\)</span>个点，我们可以计算它们所有可能中点的平均值：\r\n<span class=\"math display\">\\[\r\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i +\r\nx_j}{2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i +\r\nx_j}{2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i\r\n\\]</span></p>\r\n<p>以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的<span\r\nclass=\"math inline\">\\(x_i\\)</span>它出现在了中点计算公式中出现了<span\r\nclass=\"math inline\">\\(n-1\\)</span>次，因此后面的二重求和可以变为: <span\r\nclass=\"math display\">\\[\r\n\\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i\r\n\\]</span> 剩下的就很好理解了。</p>\r\n<p>数学推导对这样的“显然解”证明，有着更好的一套方法：</p>\r\n<p>没能够看懂题解上得公式。。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum %<span class=\"function\">MOD * <span class=\"title\">qmi</span><span class=\"params\">(n,MOD<span class=\"number\">-2</span>)</span> % MOD&lt;&lt;endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"a.-long-live\">A. Long Live</h2>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p>在《我的世界》中，简单的世界有三个维度，其中一个维度被称为\r\n\"终结\"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png\" /></p>\r\n<p>现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下</p>\r\n<p>给定两个正整数 <span class=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(y\\)</span> ，请找出两个整数 <span\r\nclass=\"math inline\">\\(a\\)</span> 和 <span\r\nclass=\"math inline\">\\(b\\)</span> ，使得</p>\r\n<p><span class=\"math display\">\\[\r\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}\r\n\\]</span></p>\r\n<p>并使 <span class=\"math inline\">\\(a \\cdot b\\)</span> 最大。</p>\r\n<p>这里， <span class=\"math inline\">\\(\\gcd(a,b)\\)</span> 表示 <span\r\nclass=\"math inline\">\\(a,b\\)</span> 的最大公约数，而 <span\r\nclass=\"math inline\">\\(\\rm lcm(a,b)\\)</span> 表示 <span\r\nclass=\"math inline\">\\(a,b\\)</span> 的最小公倍数。</p>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>如果你的数学功底很好肯定可以极快的打出这一场的签到</p>\r\n<p>简单的数学带入推到公式得到</p>\r\n<p><span class=\"math display\">\\[\r\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}\r\n\\]</span></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> gc = <span class=\"built_in\">gcd</span>(x,y);</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = <span class=\"built_in\">lcm</span>(x,y);</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;lc/gc&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":994,"excerpt":"","more":"<h2 id=\"湖北省赛vp\">湖北省赛VP</h2>\r\n<p>https://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf</p>\r\n<h2 id=\"e.-spicy-or-grilled\">E. Spicy or Grilled?</h2>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png\"\r\nalt=\"2aceebec00a61b0864fce9d24f11213aab3fc731\" />\r\n<figcaption\r\naria-hidden=\"true\">2aceebec00a61b0864fce9d24f11213aab3fc731</figcaption>\r\n</figure>\r\n<p>在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 <span\r\nclass=\"math inline\">\\(n\\)</span>\r\n名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是\r\n<span class=\"math inline\">\\(a\\)</span> 元。但由于有些人像 Walk Alone\r\n一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 <span\r\nclass=\"math inline\">\\(b\\)</span>\r\n美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 <span\r\nclass=\"math inline\">\\(x\\)</span> 。</p>\r\n<p>但是，\"独行侠\r\n\"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>我觉得麦当劳不素之霸更好吃，谁赞成，谁反对</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n,a,b,x;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1ll</span> * (n-x) * a + x * b&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"j.-points-on-the-number-axis-a\">J. Points on the Number Axis\r\nA</h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>爱丽丝正在数轴上玩单人游戏。</p>\r\n<p>数轴上有 <span class=\"math inline\">\\(n\\)</span>\r\n个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是\r\n<span class=\"math inline\">\\(x_i\\)</span> 和 <span\r\nclass=\"math inline\">\\(x_j\\)</span>，那么操作后将添加 <span\r\nclass=\"math inline\">\\(\\dfrac{x_i+x_j}{2}\\)</span> 。</p>\r\n<p>为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。</p>\r\n<p>现在爱丽丝有一个问题：最后一个点的预期位置在哪里？</p>\r\n<p>可以证明答案可以用 <span class=\"math inline\">\\(\\dfrac{p}{q}\\)</span>\r\n的形式表示，只需输出 <span class=\"math inline\">\\(p\\cdot q^{-1} \\bmod\r\n998,244,353\\)</span> 的值即可。</p>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>其实就是所有点的平均值位置</p>\r\n<p>下面是证明：</p>\r\n<p>现在，假设我们有n个点，它们的坐标是<span class=\"math inline\">\\(x_1,\r\nx_2, …, x_n\\)</span>，并且我们已经证明了对于任意的<span\r\nclass=\"math inline\">\\(i\\)</span>和<span\r\nclass=\"math inline\">\\(j\\)</span>，点 <span\r\nclass=\"math inline\">\\(x_i\\)</span>和<span\r\nclass=\"math inline\">\\(x_j\\)</span>的中点的期望坐标是<span\r\nclass=\"math inline\">\\(\\frac{x_i + x_j}{2}\\)</span>。那么，对于这<span\r\nclass=\"math inline\">\\(n\\)</span>个点，我们可以计算它们所有可能中点的平均值：\r\n<span class=\"math display\">\\[\r\nE = \\frac{1}{\\binom{n}{2}} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i +\r\nx_j}{2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nE = \\frac{2}{n(n-1)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{x_i +\r\nx_j}{2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nE = \\frac{1}{n} \\sum_{i=1}^{n} x_i\r\n\\]</span></p>\r\n<p>以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的<span\r\nclass=\"math inline\">\\(x_i\\)</span>它出现在了中点计算公式中出现了<span\r\nclass=\"math inline\">\\(n-1\\)</span>次，因此后面的二重求和可以变为: <span\r\nclass=\"math display\">\\[\r\n\\frac{(n-1)}{2}\\sum_{i=1}^{n} x_i\r\n\\]</span> 剩下的就很好理解了。</p>\r\n<p>数学推导对这样的“显然解”证明，有着更好的一套方法：</p>\r\n<p>没能够看懂题解上得公式。。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum %<span class=\"function\">MOD * <span class=\"title\">qmi</span><span class=\"params\">(n,MOD<span class=\"number\">-2</span>)</span> % MOD&lt;&lt;endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"a.-long-live\">A. Long Live</h2>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p>在《我的世界》中，简单的世界有三个维度，其中一个维度被称为\r\n\"终结\"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png\" /></p>\r\n<p>现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下</p>\r\n<p>给定两个正整数 <span class=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(y\\)</span> ，请找出两个整数 <span\r\nclass=\"math inline\">\\(a\\)</span> 和 <span\r\nclass=\"math inline\">\\(b\\)</span> ，使得</p>\r\n<p><span class=\"math display\">\\[\r\n\\sqrt{\\frac{lcm(x,y)}{gcd(x,y)}} = a \\sqrt{b}\r\n\\]</span></p>\r\n<p>并使 <span class=\"math inline\">\\(a \\cdot b\\)</span> 最大。</p>\r\n<p>这里， <span class=\"math inline\">\\(\\gcd(a,b)\\)</span> 表示 <span\r\nclass=\"math inline\">\\(a,b\\)</span> 的最大公约数，而 <span\r\nclass=\"math inline\">\\(\\rm lcm(a,b)\\)</span> 表示 <span\r\nclass=\"math inline\">\\(a,b\\)</span> 的最小公倍数。</p>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>如果你的数学功底很好肯定可以极快的打出这一场的签到</p>\r\n<p>简单的数学带入推到公式得到</p>\r\n<p><span class=\"math display\">\\[\r\na \\cdot b ={\\frac{lcm(x,y)}{a\\cdot gcd(x,y)}}\r\n\\]</span></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> gc = <span class=\"built_in\">gcd</span>(x,y);</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = <span class=\"built_in\">lcm</span>(x,y);</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;lc/gc&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2024黑龙江省赛-VP","date":"2024-08-14T11:46:31.000Z","_content":"\n## I.[This is an easy problem](https://codeforces.com/gym/105163/problem/I)\n\n超级无敌简单的签到\n\n```cpp\nvoid slove() {\n\tint x;\n\tcin>>x;\n\tint s = 0;\n\twhile(x) x-=x&-x, s++;\n\tcout<<s<<endl;\n}\n```\n\n##B.[String](https://codeforces.com/gym/105163/problem/B)\n\n### 题意\n\n斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。\n\n### 题解\n\n可以注意到一种典型的\n\n```cpp\naabcccbba\n```\n\n这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列\n\n```cpp\nvoid slove() {\n\tstring s;\n\tcin>>s;\n\tn = s.size();\n\tfor(int i=0;i<n;++i){\n\t\tstk[++top] = s[i];\n\n\t\t// for(int i=1;i<=top;i++) cout<<stk[i];\n\t\t// \tcout<<endl;\n\n\t\tint cc = 0;\n\t\tfor(int j = top;j>=top-2&& j > 0; --j){\n\t\t\tcc++;\n\t\t\tif(stk[j-1] != stk[j]) break;\n\t\t}\n\n\t\tif(cc == 3){\n\t\t\ttop-=3;\n\t\t}\n\t}\n\n\tif(!top) cout<<\"NAN\"<<endl;\n\tfor(int i=1;i<=top;i++) cout<<stk[i];\n\treturn;\n}\n```\n\n## J.[Trade](https://codeforces.com/gym/105163/problem/J)\n\n在一个繁荣的国家，金斯诺决定从事贸易。\n\n这个国家由 $$n*m$$ 座城市组成。每个城市由一对整数 $$(x, y)$$ 表示，其中 $$1\\leq x\\leq n$$ 和 $$1\\leq y\\leq m$$ 表示其在网格中的位置。在城市 $$(x,y)$$ 中，物品的价格用 $$a[x][y]$$ 表示，到达该城市的旅行费用用 $b[x][y]$ 表示。\n\n在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：\n\n- 路线的起点必须是位于第一行第一列的城市，即 $$(1, 1)$$ 。\n- 路线的终点必须是位于最后一行（ $$x = n$$ ）或最后一列（ $y = m$ ）的城市。\n- 金斯诺只能从城市 $$(x_i, y_i)$$ 移动到 $$(x_i+1, y_i)$$ 或 $$(x_i, y_i+1)$$ 。因此，对于路线中的每一步 $i$ （路线中的最后一步除外）， $$(x_{i+1}, y_{i+1})$$ 必须选择在 $$(x_i, y_i)$$ 的正下方或正右方。\n\n进入路线后，Kingsnow 将在路线的第一个城市 $$(1, 1)$$ 购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。\n\n也就是说，对于任何给定的路线 $$(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)$$ ，Kingsnow 都会从区间 $$[2, k]$$ 中任意选择一个整数 $t$ 。他在城市 $(x_t, y_t)$ 出售商品的利润计算公式为 $$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。\n\n### 题解\n\n然我们重新看一看这个式子\n\n$$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n我们把它简单变换一下\n$$\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]\n$$\n简单思考一下，我们似乎并不关心$$a[x_t][y_t]$$每一个的值，只关心他是否大于右边这个值\n\n再看一看$$n,m \\le 1000$$这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。\n\n```cpp\nint dfs(int x,int y){\n\tif(x==n && y == m) return 1;\n\tif(x >n || y> m || (!st[x][y])) return 0;\n\tst[x][y] = 0;\n\n\tif(dfs(x+1,y)) return 1;\n\tif(dfs(x,y+1)) return 1;\n\n\treturn 0;\n}\n\nvoid slove() {\n\tmemset(f,0x3f,sizeof f);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>a[i][j];\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>b[i][j];\n\n\tf[1][0] = f[0] [1] = 0; \n\tfor(int i = 1;i<=n;i++) for(int j=1;j<=m;j++){\n\t\tf[i][j] = min(f[i-1][j] + b[i][j], f[i][j-1] + b[i][j]);\n\t}\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<f[i][j]<<'\\t';\n\t// \tcout<<endl;\n\t// }\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;++j){\n\t\tif(f[i][j] + a[1][1] <= a[i][j]){\n\t\t\tst[i][j]  = 1;\n\t\t}\n\t}\n\n\tst[1][1] = st[n][m] = 1;\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<st[i][j];\n\t// \tcout<<endl;\n\t// }\n\n\tif(dfs(1,1)) puts(\"YES\");\n\telse puts(\"NO\");\n}\n```\n\n## K. [Puzzle](https://codeforces.com/gym/105163/problem/K)\n\n### 题意\n\n24 字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为 24。\n\nNerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。\n\nNerifish 有四张扑克牌，每张牌上的数字都是 $$a,b,c,d(1\\leq a,b,c,d\\leq 13)$$ 。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含 4 个整数和 3 个运算符。\n\nNerifish 想知道他能得到多少结果。\n\n### 题解\n\n简单的计算可得$$2^8 = 256$$\n\n暴力！\n\n```cpp\nvoid dfs(int u,stack<int> s,set<int>& S){\n\tif(u==3) {\n\t\tint ans = 0;\n\t\twhile(s.size()) ans += s.top(),s.pop();\n\t\t// cout<<ans<<endl;\n\t\tS.insert(ans);\n\t\treturn ;\n\t}\n\tif(u==0) s.push(a[u]);\n\tfor(int i=0;i<3;++i){\n\t\tif(i==0) {\n\t\t\ts.push(a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse if(i == 1) {\n\t\t\ts.push(-a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse {\n\t\t\tint t = s.top();s.pop();\n\t\t\ts.push(t * a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t}\n\treturn ;\n}\n\nvoid slove() {\n\tfor(int i=0;i<4;i++) cin>>a[i];\n\n\tsort(a,a+4);\n\n\tset<int> S;\n\tdo{\n\t\t// for(int i=0;i<4;++i) cout<<a[i] << ' ';\n\t\t// \tcout<<endl;\n\t\tstack<int> t;\n\t\tdfs(0,t, S);\n\t}while(next_permutation(a,a+4));\n\n\tcout<<S.size();\n\treturn ;\n}\n```\n\n## D.[Card Game](https://codeforces.com/gym/105163/problem/D)\n\n### 题意\n\n甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做 *hpa* 和 *hpb* 。每个玩家开始时都有 *n* 张牌，分别叫做 $$a_1, a_2... a_n $$和 *b*1, $$b_1,b_2...b_n$$ ，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。\n\n回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。\n\n我们称 A 打出的牌序列为 $$p_1, p_2... p_n $$，称 B 打出的牌序列为 $$q_1, q_2... q_n$$ ，它们是从 1 到 *n* 的排列。如果在 *i* - *th* 回合之前游戏还没有结束，那么在 *i* - *th* 回合，甲会下 *a**p**i* ，乙会下 *b**q**i* 。\n\n现在你知道了 A 和 B 的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。\n\n### 题解\n\n","source":"_posts/2024黑龙江省赛-VP.md","raw":"---\ntitle: 2024黑龙江省赛-VP\ndate: 2024-08-14 19:46:31\ntags: [icpc]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- icpc省赛\n---\n\n## I.[This is an easy problem](https://codeforces.com/gym/105163/problem/I)\n\n超级无敌简单的签到\n\n```cpp\nvoid slove() {\n\tint x;\n\tcin>>x;\n\tint s = 0;\n\twhile(x) x-=x&-x, s++;\n\tcout<<s<<endl;\n}\n```\n\n##B.[String](https://codeforces.com/gym/105163/problem/B)\n\n### 题意\n\n斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。\n\n### 题解\n\n可以注意到一种典型的\n\n```cpp\naabcccbba\n```\n\n这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列\n\n```cpp\nvoid slove() {\n\tstring s;\n\tcin>>s;\n\tn = s.size();\n\tfor(int i=0;i<n;++i){\n\t\tstk[++top] = s[i];\n\n\t\t// for(int i=1;i<=top;i++) cout<<stk[i];\n\t\t// \tcout<<endl;\n\n\t\tint cc = 0;\n\t\tfor(int j = top;j>=top-2&& j > 0; --j){\n\t\t\tcc++;\n\t\t\tif(stk[j-1] != stk[j]) break;\n\t\t}\n\n\t\tif(cc == 3){\n\t\t\ttop-=3;\n\t\t}\n\t}\n\n\tif(!top) cout<<\"NAN\"<<endl;\n\tfor(int i=1;i<=top;i++) cout<<stk[i];\n\treturn;\n}\n```\n\n## J.[Trade](https://codeforces.com/gym/105163/problem/J)\n\n在一个繁荣的国家，金斯诺决定从事贸易。\n\n这个国家由 $$n*m$$ 座城市组成。每个城市由一对整数 $$(x, y)$$ 表示，其中 $$1\\leq x\\leq n$$ 和 $$1\\leq y\\leq m$$ 表示其在网格中的位置。在城市 $$(x,y)$$ 中，物品的价格用 $$a[x][y]$$ 表示，到达该城市的旅行费用用 $b[x][y]$ 表示。\n\n在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：\n\n- 路线的起点必须是位于第一行第一列的城市，即 $$(1, 1)$$ 。\n- 路线的终点必须是位于最后一行（ $$x = n$$ ）或最后一列（ $y = m$ ）的城市。\n- 金斯诺只能从城市 $$(x_i, y_i)$$ 移动到 $$(x_i+1, y_i)$$ 或 $$(x_i, y_i+1)$$ 。因此，对于路线中的每一步 $i$ （路线中的最后一步除外）， $$(x_{i+1}, y_{i+1})$$ 必须选择在 $$(x_i, y_i)$$ 的正下方或正右方。\n\n进入路线后，Kingsnow 将在路线的第一个城市 $$(1, 1)$$ 购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。\n\n也就是说，对于任何给定的路线 $$(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)$$ ，Kingsnow 都会从区间 $$[2, k]$$ 中任意选择一个整数 $t$ 。他在城市 $(x_t, y_t)$ 出售商品的利润计算公式为 $$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。\n\n### 题解\n\n然我们重新看一看这个式子\n\n$$ \\text{Profit} = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^t b[x_i][y_i]$$\n\n我们把它简单变换一下\n$$\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]\n$$\n简单思考一下，我们似乎并不关心$$a[x_t][y_t]$$每一个的值，只关心他是否大于右边这个值\n\n再看一看$$n,m \\le 1000$$这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。\n\n```cpp\nint dfs(int x,int y){\n\tif(x==n && y == m) return 1;\n\tif(x >n || y> m || (!st[x][y])) return 0;\n\tst[x][y] = 0;\n\n\tif(dfs(x+1,y)) return 1;\n\tif(dfs(x,y+1)) return 1;\n\n\treturn 0;\n}\n\nvoid slove() {\n\tmemset(f,0x3f,sizeof f);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>a[i][j];\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n\t\tcin>>b[i][j];\n\n\tf[1][0] = f[0] [1] = 0; \n\tfor(int i = 1;i<=n;i++) for(int j=1;j<=m;j++){\n\t\tf[i][j] = min(f[i-1][j] + b[i][j], f[i][j-1] + b[i][j]);\n\t}\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<f[i][j]<<'\\t';\n\t// \tcout<<endl;\n\t// }\n\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;++j){\n\t\tif(f[i][j] + a[1][1] <= a[i][j]){\n\t\t\tst[i][j]  = 1;\n\t\t}\n\t}\n\n\tst[1][1] = st[n][m] = 1;\n\n\t// for(int i=1;i<=n;++i) {\n\t// \tfor(int j=1;j<=m;++j)\n\t// \t\tcout<<st[i][j];\n\t// \tcout<<endl;\n\t// }\n\n\tif(dfs(1,1)) puts(\"YES\");\n\telse puts(\"NO\");\n}\n```\n\n## K. [Puzzle](https://codeforces.com/gym/105163/problem/K)\n\n### 题意\n\n24 字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为 24。\n\nNerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。\n\nNerifish 有四张扑克牌，每张牌上的数字都是 $$a,b,c,d(1\\leq a,b,c,d\\leq 13)$$ 。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含 4 个整数和 3 个运算符。\n\nNerifish 想知道他能得到多少结果。\n\n### 题解\n\n简单的计算可得$$2^8 = 256$$\n\n暴力！\n\n```cpp\nvoid dfs(int u,stack<int> s,set<int>& S){\n\tif(u==3) {\n\t\tint ans = 0;\n\t\twhile(s.size()) ans += s.top(),s.pop();\n\t\t// cout<<ans<<endl;\n\t\tS.insert(ans);\n\t\treturn ;\n\t}\n\tif(u==0) s.push(a[u]);\n\tfor(int i=0;i<3;++i){\n\t\tif(i==0) {\n\t\t\ts.push(a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse if(i == 1) {\n\t\t\ts.push(-a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t\telse {\n\t\t\tint t = s.top();s.pop();\n\t\t\ts.push(t * a[u+1]);\n\t\t\tdfs(u+1,s,S);\n\t\t\ts.pop();\n\t\t}\n\t}\n\treturn ;\n}\n\nvoid slove() {\n\tfor(int i=0;i<4;i++) cin>>a[i];\n\n\tsort(a,a+4);\n\n\tset<int> S;\n\tdo{\n\t\t// for(int i=0;i<4;++i) cout<<a[i] << ' ';\n\t\t// \tcout<<endl;\n\t\tstack<int> t;\n\t\tdfs(0,t, S);\n\t}while(next_permutation(a,a+4));\n\n\tcout<<S.size();\n\treturn ;\n}\n```\n\n## D.[Card Game](https://codeforces.com/gym/105163/problem/D)\n\n### 题意\n\n甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做 *hpa* 和 *hpb* 。每个玩家开始时都有 *n* 张牌，分别叫做 $$a_1, a_2... a_n $$和 *b*1, $$b_1,b_2...b_n$$ ，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。\n\n回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。\n\n我们称 A 打出的牌序列为 $$p_1, p_2... p_n $$，称 B 打出的牌序列为 $$q_1, q_2... q_n$$ ，它们是从 1 到 *n* 的排列。如果在 *i* - *th* 回合之前游戏还没有结束，那么在 *i* - *th* 回合，甲会下 *a**p**i* ，乙会下 *b**q**i* 。\n\n现在你知道了 A 和 B 的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。\n\n### 题解\n\n","slug":"2024黑龙江省赛-VP","published":1,"updated":"2024-08-15T03:48:48.181Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt2000bwwwv3eo93ppa","content":"<h2 id=\"i.this-is-an-easy-problem\">I.<a\r\nhref=\"https://codeforces.com/gym/105163/problem/I\">This is an easy\r\nproblem</a></h2>\r\n<p>超级无敌简单的签到</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\tcin&gt;&gt;x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(x) x-=x&amp;-x, s++;</span><br><span class=\"line\">\tcout&lt;&lt;s&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>##B.<a\r\nhref=\"https://codeforces.com/gym/105163/problem/B\">String</a></p>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>可以注意到一种典型的</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aabcccbba</span><br></pre></td></tr></table></figure>\r\n<p>这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;</span><br><span class=\"line\">\tcin&gt;&gt;s;</span><br><span class=\"line\">\tn = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">\t\tstk[++top] = s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=1;i&lt;=top;i++) cout&lt;&lt;stk[i];</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cc = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = top;j&gt;=top<span class=\"number\">-2</span>&amp;&amp; j &gt; <span class=\"number\">0</span>; --j)&#123;</span><br><span class=\"line\">\t\t\tcc++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stk[j<span class=\"number\">-1</span>] != stk[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cc == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\ttop-=<span class=\"number\">3</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!top) cout&lt;&lt;<span class=\"string\">&quot;NAN&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=top;i++) cout&lt;&lt;stk[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"j.trade\">J.<a\r\nhref=\"https://codeforces.com/gym/105163/problem/J\">Trade</a></h2>\r\n<p>在一个繁荣的国家，金斯诺决定从事贸易。</p>\r\n<p>这个国家由 <span class=\"math display\">\\[n*m\\]</span>\r\n座城市组成。每个城市由一对整数 <span class=\"math display\">\\[(x,\r\ny)\\]</span> 表示，其中 <span class=\"math display\">\\[1\\leq x\\leq\r\nn\\]</span> 和 <span class=\"math display\">\\[1\\leq y\\leq m\\]</span>\r\n表示其在网格中的位置。在城市 <span class=\"math display\">\\[(x,y)\\]</span>\r\n中，物品的价格用 <span class=\"math display\">\\[a[x][y]\\]</span>\r\n表示，到达该城市的旅行费用用 <span\r\nclass=\"math inline\">\\(b[x][y]\\)</span> 表示。</p>\r\n<p>在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：</p>\r\n<ul>\r\n<li>路线的起点必须是位于第一行第一列的城市，即 <span\r\nclass=\"math display\">\\[(1, 1)\\]</span> 。</li>\r\n<li>路线的终点必须是位于最后一行（ <span class=\"math display\">\\[x =\r\nn\\]</span> ）或最后一列（ <span class=\"math inline\">\\(y = m\\)</span>\r\n）的城市。</li>\r\n<li>金斯诺只能从城市 <span class=\"math display\">\\[(x_i, y_i)\\]</span>\r\n移动到 <span class=\"math display\">\\[(x_i+1, y_i)\\]</span> 或 <span\r\nclass=\"math display\">\\[(x_i, y_i+1)\\]</span> 。因此，对于路线中的每一步\r\n<span class=\"math inline\">\\(i\\)</span> （路线中的最后一步除外）， <span\r\nclass=\"math display\">\\[(x_{i+1}, y_{i+1})\\]</span> 必须选择在 <span\r\nclass=\"math display\">\\[(x_i, y_i)\\]</span> 的正下方或正右方。</li>\r\n</ul>\r\n<p>进入路线后，Kingsnow 将在路线的第一个城市 <span\r\nclass=\"math display\">\\[(1, 1)\\]</span>\r\n购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。</p>\r\n<p>也就是说，对于任何给定的路线 <span class=\"math display\">\\[(x_1, y_1),\r\n(x_2, y_2), ..., (x_k, y_k)\\]</span> ，Kingsnow 都会从区间 <span\r\nclass=\"math display\">\\[[2, k]\\]</span> 中任意选择一个整数 <span\r\nclass=\"math inline\">\\(t\\)</span> 。他在城市 <span\r\nclass=\"math inline\">\\((x_t, y_t)\\)</span> 出售商品的利润计算公式为 <span\r\nclass=\"math display\">\\[ \\text{Profit} = a[x_t][y_t] - a[1][1] -\r\n\\sum_{i=1}^t b[x_i][y_i]\\]</span></p>\r\n<p>金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>然我们重新看一看这个式子</p>\r\n<p><span class=\"math display\">\\[ \\text{Profit} = a[x_t][y_t] - a[1][1] -\r\n\\sum_{i=1}^t b[x_i][y_i]\\]</span></p>\r\n<p>我们把它简单变换一下 <span class=\"math display\">\\[\r\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\r\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\r\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]\r\n\\]</span> 简单思考一下，我们似乎并不关心<span\r\nclass=\"math display\">\\[a[x_t][y_t]\\]</span>每一个的值，只关心他是否大于右边这个值</p>\r\n<p>再看一看<span class=\"math display\">\\[n,m \\le\r\n1000\\]</span>这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x==n &amp;&amp; y == m) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt;n || y&gt; m || (!st[x][y])) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tst[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>,y)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x,y<span class=\"number\">+1</span>)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;b[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\tf[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = f[<span class=\"number\">0</span>] [<span class=\"number\">1</span>] = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\tf[i][j] = <span class=\"built_in\">min</span>(f[i<span class=\"number\">-1</span>][j] + b[i][j], f[i][j<span class=\"number\">-1</span>] + b[i][j]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;f[i][j]&lt;&lt;&#x27;\\t&#x27;;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i][j] + a[<span class=\"number\">1</span>][<span class=\"number\">1</span>] &lt;= a[i][j])&#123;</span><br><span class=\"line\">\t\t\tst[i][j]  = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tst[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = st[n][m] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;st[i][j];</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>)) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-puzzle\">K. <a\r\nhref=\"https://codeforces.com/gym/105163/problem/K\">Puzzle</a></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>24\r\n字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为\r\n24。</p>\r\n<p>Nerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。</p>\r\n<p>Nerifish 有四张扑克牌，每张牌上的数字都是 <span\r\nclass=\"math display\">\\[a,b,c,d(1\\leq a,b,c,d\\leq 13)\\]</span>\r\n。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含\r\n4 个整数和 3 个运算符。</p>\r\n<p>Nerifish 想知道他能得到多少结果。</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>简单的计算可得<span class=\"math display\">\\[2^8 = 256\\]</span></p>\r\n<p>暴力！</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,stack&lt;<span class=\"type\">int</span>&gt; s,set&lt;<span class=\"type\">int</span>&gt;&amp; S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(s.<span class=\"built_in\">size</span>()) ans += s.<span class=\"built_in\">top</span>(),s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tS.<span class=\"built_in\">insert</span>(ans);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">0</span>) s.<span class=\"built_in\">push</span>(a[u]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(-a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = s.<span class=\"built_in\">top</span>();s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(t * a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a,a<span class=\"number\">+4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tset&lt;<span class=\"type\">int</span>&gt; S;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=0;i&lt;4;++i) cout&lt;&lt;a[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tstack&lt;<span class=\"type\">int</span>&gt; t;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,t, S);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(a,a<span class=\"number\">+4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;S.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d.card-game\">D.<a\r\nhref=\"https://codeforces.com/gym/105163/problem/D\">Card Game</a></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做\r\n<em>hpa</em> 和 <em>hpb</em> 。每个玩家开始时都有 <em>n</em>\r\n张牌，分别叫做 <span class=\"math display\">\\[a_1, a_2... a_n \\]</span>和\r\n<em>b</em>1, <span class=\"math display\">\\[b_1,b_2...b_n\\]</span>\r\n，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。</p>\r\n<p>回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。</p>\r\n<p>我们称 A 打出的牌序列为 <span class=\"math display\">\\[p_1, p_2... p_n\r\n\\]</span>，称 B 打出的牌序列为 <span class=\"math display\">\\[q_1, q_2...\r\nq_n\\]</span> ，它们是从 1 到 <em>n</em> 的排列。如果在\r\n<em>i</em> - <em>th</em> 回合之前游戏还没有结束，那么在\r\n<em>i</em> - <em>th</em> 回合，甲会下 <em>a<strong>p</strong>i</em>\r\n，乙会下 <em>b<strong>q</strong>i</em> 。</p>\r\n<p>现在你知道了 A 和 B\r\n的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n","length":1795,"excerpt":"","more":"<h2 id=\"i.this-is-an-easy-problem\">I.<a\r\nhref=\"https://codeforces.com/gym/105163/problem/I\">This is an easy\r\nproblem</a></h2>\r\n<p>超级无敌简单的签到</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\tcin&gt;&gt;x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(x) x-=x&amp;-x, s++;</span><br><span class=\"line\">\tcout&lt;&lt;s&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>##B.<a\r\nhref=\"https://codeforces.com/gym/105163/problem/B\">String</a></p>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>可以注意到一种典型的</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aabcccbba</span><br></pre></td></tr></table></figure>\r\n<p>这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstring s;</span><br><span class=\"line\">\tcin&gt;&gt;s;</span><br><span class=\"line\">\tn = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">\t\tstk[++top] = s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=1;i&lt;=top;i++) cout&lt;&lt;stk[i];</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cc = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = top;j&gt;=top<span class=\"number\">-2</span>&amp;&amp; j &gt; <span class=\"number\">0</span>; --j)&#123;</span><br><span class=\"line\">\t\t\tcc++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stk[j<span class=\"number\">-1</span>] != stk[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cc == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\ttop-=<span class=\"number\">3</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!top) cout&lt;&lt;<span class=\"string\">&quot;NAN&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=top;i++) cout&lt;&lt;stk[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"j.trade\">J.<a\r\nhref=\"https://codeforces.com/gym/105163/problem/J\">Trade</a></h2>\r\n<p>在一个繁荣的国家，金斯诺决定从事贸易。</p>\r\n<p>这个国家由 <span class=\"math display\">\\[n*m\\]</span>\r\n座城市组成。每个城市由一对整数 <span class=\"math display\">\\[(x,\r\ny)\\]</span> 表示，其中 <span class=\"math display\">\\[1\\leq x\\leq\r\nn\\]</span> 和 <span class=\"math display\">\\[1\\leq y\\leq m\\]</span>\r\n表示其在网格中的位置。在城市 <span class=\"math display\">\\[(x,y)\\]</span>\r\n中，物品的价格用 <span class=\"math display\">\\[a[x][y]\\]</span>\r\n表示，到达该城市的旅行费用用 <span\r\nclass=\"math inline\">\\(b[x][y]\\)</span> 表示。</p>\r\n<p>在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：</p>\r\n<ul>\r\n<li>路线的起点必须是位于第一行第一列的城市，即 <span\r\nclass=\"math display\">\\[(1, 1)\\]</span> 。</li>\r\n<li>路线的终点必须是位于最后一行（ <span class=\"math display\">\\[x =\r\nn\\]</span> ）或最后一列（ <span class=\"math inline\">\\(y = m\\)</span>\r\n）的城市。</li>\r\n<li>金斯诺只能从城市 <span class=\"math display\">\\[(x_i, y_i)\\]</span>\r\n移动到 <span class=\"math display\">\\[(x_i+1, y_i)\\]</span> 或 <span\r\nclass=\"math display\">\\[(x_i, y_i+1)\\]</span> 。因此，对于路线中的每一步\r\n<span class=\"math inline\">\\(i\\)</span> （路线中的最后一步除外）， <span\r\nclass=\"math display\">\\[(x_{i+1}, y_{i+1})\\]</span> 必须选择在 <span\r\nclass=\"math display\">\\[(x_i, y_i)\\]</span> 的正下方或正右方。</li>\r\n</ul>\r\n<p>进入路线后，Kingsnow 将在路线的第一个城市 <span\r\nclass=\"math display\">\\[(1, 1)\\]</span>\r\n购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。</p>\r\n<p>也就是说，对于任何给定的路线 <span class=\"math display\">\\[(x_1, y_1),\r\n(x_2, y_2), ..., (x_k, y_k)\\]</span> ，Kingsnow 都会从区间 <span\r\nclass=\"math display\">\\[[2, k]\\]</span> 中任意选择一个整数 <span\r\nclass=\"math inline\">\\(t\\)</span> 。他在城市 <span\r\nclass=\"math inline\">\\((x_t, y_t)\\)</span> 出售商品的利润计算公式为 <span\r\nclass=\"math display\">\\[ \\text{Profit} = a[x_t][y_t] - a[1][1] -\r\n\\sum_{i=1}^t b[x_i][y_i]\\]</span></p>\r\n<p>金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>然我们重新看一看这个式子</p>\r\n<p><span class=\"math display\">\\[ \\text{Profit} = a[x_t][y_t] - a[1][1] -\r\n\\sum_{i=1}^t b[x_i][y_i]\\]</span></p>\r\n<p>我们把它简单变换一下 <span class=\"math display\">\\[\r\nProfit = a[x_t][y_t] - a[1][1] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge 0\\\\\r\n\\rightarrow a[x_t][y_t] - \\sum_{i=1}^{t} b[x_i][y_i]\\ge a[1][1] \\\\\r\n\\rightarrow a[x_t][y_t] \\ge a[1][1]+\\sum_{i=1}^{t} b[x_i][y_i]\r\n\\]</span> 简单思考一下，我们似乎并不关心<span\r\nclass=\"math display\">\\[a[x_t][y_t]\\]</span>每一个的值，只关心他是否大于右边这个值</p>\r\n<p>再看一看<span class=\"math display\">\\[n,m \\le\r\n1000\\]</span>这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x==n &amp;&amp; y == m) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt;n || y&gt; m || (!st[x][y])) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tst[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>,y)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(x,y<span class=\"number\">+1</span>)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> f);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">\t\tcin&gt;&gt;b[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">\tf[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = f[<span class=\"number\">0</span>] [<span class=\"number\">1</span>] = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\tf[i][j] = <span class=\"built_in\">min</span>(f[i<span class=\"number\">-1</span>][j] + b[i][j], f[i][j<span class=\"number\">-1</span>] + b[i][j]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;f[i][j]&lt;&lt;&#x27;\\t&#x27;;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i][j] + a[<span class=\"number\">1</span>][<span class=\"number\">1</span>] &lt;= a[i][j])&#123;</span><br><span class=\"line\">\t\t\tst[i][j]  = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tst[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = st[n][m] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tfor(int j=1;j&lt;=m;++j)</span></span><br><span class=\"line\">\t<span class=\"comment\">// \t\tcout&lt;&lt;st[i][j];</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>)) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"k.-puzzle\">K. <a\r\nhref=\"https://codeforces.com/gym/105163/problem/K\">Puzzle</a></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>24\r\n字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为\r\n24。</p>\r\n<p>Nerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。</p>\r\n<p>Nerifish 有四张扑克牌，每张牌上的数字都是 <span\r\nclass=\"math display\">\\[a,b,c,d(1\\leq a,b,c,d\\leq 13)\\]</span>\r\n。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含\r\n4 个整数和 3 个运算符。</p>\r\n<p>Nerifish 想知道他能得到多少结果。</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>简单的计算可得<span class=\"math display\">\\[2^8 = 256\\]</span></p>\r\n<p>暴力！</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,stack&lt;<span class=\"type\">int</span>&gt; s,set&lt;<span class=\"type\">int</span>&gt;&amp; S)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(s.<span class=\"built_in\">size</span>()) ans += s.<span class=\"built_in\">top</span>(),s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tS.<span class=\"built_in\">insert</span>(ans);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(u==<span class=\"number\">0</span>) s.<span class=\"built_in\">push</span>(a[u]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(-a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> t = s.<span class=\"built_in\">top</span>();s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">push</span>(t * a[u<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(u<span class=\"number\">+1</span>,s,S);</span><br><span class=\"line\">\t\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a,a<span class=\"number\">+4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tset&lt;<span class=\"type\">int</span>&gt; S;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// for(int i=0;i&lt;4;++i) cout&lt;&lt;a[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tcout&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tstack&lt;<span class=\"type\">int</span>&gt; t;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,t, S);</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(a,a<span class=\"number\">+4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;S.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d.card-game\">D.<a\r\nhref=\"https://codeforces.com/gym/105163/problem/D\">Card Game</a></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做\r\n<em>hpa</em> 和 <em>hpb</em> 。每个玩家开始时都有 <em>n</em>\r\n张牌，分别叫做 <span class=\"math display\">\\[a_1, a_2... a_n \\]</span>和\r\n<em>b</em>1, <span class=\"math display\">\\[b_1,b_2...b_n\\]</span>\r\n，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。</p>\r\n<p>回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。</p>\r\n<p>我们称 A 打出的牌序列为 <span class=\"math display\">\\[p_1, p_2... p_n\r\n\\]</span>，称 B 打出的牌序列为 <span class=\"math display\">\\[q_1, q_2...\r\nq_n\\]</span> ，它们是从 1 到 <em>n</em> 的排列。如果在\r\n<em>i</em> - <em>th</em> 回合之前游戏还没有结束，那么在\r\n<em>i</em> - <em>th</em> 回合，甲会下 <em>a<strong>p</strong>i</em>\r\n，乙会下 <em>b<strong>q</strong>i</em> 。</p>\r\n<p>现在你知道了 A 和 B\r\n的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n"},{"title":"Latex宏包pgfplots做矩形函数图像","date":"2024-08-14T11:47:58.000Z","_content":"持续更新遇到的问题，完结或不再使用该包将删除这句话\n\n## pgfplots\n\nPgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。\n\n<!--more-->\n\n### 实例一、通过函数方程绘制函数图像\n\n```latex\n%Ex1:f(x)=exp(x)\n\\begin{tikzpicture}\n\\begin{axis}\n\\addplot[color=red]{exp(x)};\n\\end{axis}\n\\end{tikzpicture}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png)\n\n其中绘制图像的语法如下：\n\n```latex\n\\addplot[option] {expression of 2D function};\n```\n\n在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 **;** 结尾。\n\n### 实例二、坐标系的绘制以及3d函数图像\n\n```latex\n\\documentclass{ctexart}\n\\pagestyle{empty}\n\\usepackage{pgfplots}\n\\begin{document}\n%Ex2: put the 2D plot and the 3D plot together\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot[color=red]{exp(x)};\n\t\\end{axis}\n\\end{tikzpicture}\n%Here ends the furst 2D plot\n\n\\hskip 10pt\n\n%Here begins the 3d plot\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot3[\n\t\tsurf,\n\t\t]\n\t\t{exp(-x^2-y^2)*x};\n\t\\end{axis}\n\\end{tikzpicture}\n\\end{document}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png)\n\n```latex\n\\addplot3[\n    surf,\n]\n{exp(-x^2-y^2)*x};\n```\n\n注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。\n\n可以看到对多个图像只需要设定多个tikzpicture作用域即可\n\n#### 坐标系图像中的常用命令、参数与特性\n\n- xlabel、ylabel：设定x,y坐标轴上的标志。\n- 多个addplot可在同一个图中多次作图\n- $$\\tt{domian = a:b}$$设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；\n- $$\\tt{axis\\,\\, lines = left}$$这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；\n- \\addlegendentry{$function（x)$​} 添加函数标签 \n- \\legend 按顺序批量谭家函数标签\n- title在axis中为图像添加标题\n\n### 实例三、数据图\n\n```latex\n%Ex6:plot from data\n\\begin{tikzpicture}\n\t\\begin{axis}[\n\t\ttitle={Temperature dependence of CuSO$_4\\cdot$5H$_2$O solubility},\n\t\txlabel={Temperature [\\textcelsius]},\n\t\tylabel={Solubility [g per 100 g water]},\n\t\txmin=0, xmax=100,\n\t\tymin=0, ymax=120,\n\t\txtick={0,20,40,60,80,100},\n\t\tytick={0,20,40,60,80,100,120},\n\t\tlegend pos=north west,\n\t\tymajorgrids=true,\n\t\tgrid style=dashed,\n\t\t]\n\t\t\n\t\t\\addplot[\n\t\tcolor=blue,\n\t\tmark=square,\n\t\t]\n\t\tcoordinates {\n\t\t\t(0,23.1)\n\t\t\t(10,27.5)\n\t\t\t(20,32)\n\t\t\t(30,37.8)\n\t\t\t(40,44.6)\n\t\t\t(60,61.8)\n\t\t\t(80,83.8)\n\t\t\t(100,114)\n\t\t};\n\t\t\\legend{CuSO$_4\\cdot$5H$_2$O}\n\t\t\n\t\\end{axis}\n\\end{tikzpicture}\n```\n\n\n\n#### 数据图像中的常用命令、参数与特性![test-1-crop-1](https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png)\n\n- mark：设定图像点的形状；如square、triangle、x等\n- $$\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}$$​启用/禁用 𝑦,𝑥 轴上**刻度线位置上**的网格线；\n- $$\\tt{xmin=a, xmax=b, ymin=c, ymax=d}$$​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；\n- $$\\tt{coordinates \\{\\}}$$​设定坐标点画折线图\n- \\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图\n\n### 其他图像\n\npgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。\n\n### 导言区的一些设定\n\n```latex\n\\pgfplotsset{width=10cm}\n```\n\n这里指定了每一张图的宽度为10cm\n\n```tex\n\\usepgfplotslibrary{external}\n\\tikzexternalize \n```\n\n由于$$LATEX$$ 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。","source":"_posts/Latex宏包pgfplots做矩形函数图像.md","raw":"---\ntitle: Latex宏包pgfplots做矩形函数图像\ndate: 2024-08-14 19:47:58\ntags: [Latex, 图像处理]\ncategories: \n\t- 软件\n\t- 工具类软件\n---\n持续更新遇到的问题，完结或不再使用该包将删除这句话\n\n## pgfplots\n\nPgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。\n\n<!--more-->\n\n### 实例一、通过函数方程绘制函数图像\n\n```latex\n%Ex1:f(x)=exp(x)\n\\begin{tikzpicture}\n\\begin{axis}\n\\addplot[color=red]{exp(x)};\n\\end{axis}\n\\end{tikzpicture}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png)\n\n其中绘制图像的语法如下：\n\n```latex\n\\addplot[option] {expression of 2D function};\n```\n\n在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 **;** 结尾。\n\n### 实例二、坐标系的绘制以及3d函数图像\n\n```latex\n\\documentclass{ctexart}\n\\pagestyle{empty}\n\\usepackage{pgfplots}\n\\begin{document}\n%Ex2: put the 2D plot and the 3D plot together\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot[color=red]{exp(x)};\n\t\\end{axis}\n\\end{tikzpicture}\n%Here ends the furst 2D plot\n\n\\hskip 10pt\n\n%Here begins the 3d plot\n\\begin{tikzpicture}\n\t\\begin{axis}\n\t\t\\addplot3[\n\t\tsurf,\n\t\t]\n\t\t{exp(-x^2-y^2)*x};\n\t\\end{axis}\n\\end{tikzpicture}\n\\end{document}\n```\n\n![test-1-crop-1](https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png)\n\n```latex\n\\addplot3[\n    surf,\n]\n{exp(-x^2-y^2)*x};\n```\n\n注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。\n\n可以看到对多个图像只需要设定多个tikzpicture作用域即可\n\n#### 坐标系图像中的常用命令、参数与特性\n\n- xlabel、ylabel：设定x,y坐标轴上的标志。\n- 多个addplot可在同一个图中多次作图\n- $$\\tt{domian = a:b}$$设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；\n- $$\\tt{axis\\,\\, lines = left}$$这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；\n- \\addlegendentry{$function（x)$​} 添加函数标签 \n- \\legend 按顺序批量谭家函数标签\n- title在axis中为图像添加标题\n\n### 实例三、数据图\n\n```latex\n%Ex6:plot from data\n\\begin{tikzpicture}\n\t\\begin{axis}[\n\t\ttitle={Temperature dependence of CuSO$_4\\cdot$5H$_2$O solubility},\n\t\txlabel={Temperature [\\textcelsius]},\n\t\tylabel={Solubility [g per 100 g water]},\n\t\txmin=0, xmax=100,\n\t\tymin=0, ymax=120,\n\t\txtick={0,20,40,60,80,100},\n\t\tytick={0,20,40,60,80,100,120},\n\t\tlegend pos=north west,\n\t\tymajorgrids=true,\n\t\tgrid style=dashed,\n\t\t]\n\t\t\n\t\t\\addplot[\n\t\tcolor=blue,\n\t\tmark=square,\n\t\t]\n\t\tcoordinates {\n\t\t\t(0,23.1)\n\t\t\t(10,27.5)\n\t\t\t(20,32)\n\t\t\t(30,37.8)\n\t\t\t(40,44.6)\n\t\t\t(60,61.8)\n\t\t\t(80,83.8)\n\t\t\t(100,114)\n\t\t};\n\t\t\\legend{CuSO$_4\\cdot$5H$_2$O}\n\t\t\n\t\\end{axis}\n\\end{tikzpicture}\n```\n\n\n\n#### 数据图像中的常用命令、参数与特性![test-1-crop-1](https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png)\n\n- mark：设定图像点的形状；如square、triangle、x等\n- $$\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}$$​启用/禁用 𝑦,𝑥 轴上**刻度线位置上**的网格线；\n- $$\\tt{xmin=a, xmax=b, ymin=c, ymax=d}$$​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；\n- $$\\tt{coordinates \\{\\}}$$​设定坐标点画折线图\n- \\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图\n\n### 其他图像\n\npgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。\n\n### 导言区的一些设定\n\n```latex\n\\pgfplotsset{width=10cm}\n```\n\n这里指定了每一张图的宽度为10cm\n\n```tex\n\\usepgfplotslibrary{external}\n\\tikzexternalize \n```\n\n由于$$LATEX$$ 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。","slug":"Latex宏包pgfplots做矩形函数图像","published":1,"updated":"2024-08-14T13:38:44.943Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt4000fwwwv6yxn3a12","content":"<p>持续更新遇到的问题，完结或不再使用该包将删除这句话</p>\r\n<h2 id=\"pgfplots\">pgfplots</h2>\r\n<p>Pgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots\r\n宏包会帮助用户绘制响应的图像。</p>\r\n<span id=\"more\"></span>\r\n<h3\r\nid=\"实例一通过函数方程绘制函数图像\">实例一、通过函数方程绘制函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex1:f(x)=exp(x)</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<p>其中绘制图像的语法如下：</p>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>[option] &#123;expression of 2D function&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D\r\n函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥)\r\n。最后最重要的是该命令必须以分号 <strong>;</strong> 结尾。</p>\r\n<h3\r\nid=\"实例二坐标系的绘制以及3d函数图像\">实例二、坐标系的绘制以及3d函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\documentclass</span>&#123;ctexart&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\pagestyle</span>&#123;empty&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\usepackage</span>&#123;pgfplots&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;document&#125;</span><br><span class=\"line\"><span class=\"comment\">%Ex2: put the 2D plot and the 3D plot together</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"comment\">%Here ends the furst 2D plot</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">\\hskip</span> 10pt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%Here begins the 3d plot</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">\t\tsurf,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">    surf,</span><br><span class=\"line\">]</span><br><span class=\"line\">&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。</p>\r\n<p>可以看到对多个图像只需要设定多个tikzpicture作用域即可</p>\r\n<h4\r\nid=\"坐标系图像中的常用命令参数与特性\">坐标系图像中的常用命令、参数与特性</h4>\r\n<ul>\r\n<li>xlabel、ylabel：设定x,y坐标轴上的标志。</li>\r\n<li>多个addplot可在同一个图中多次作图</li>\r\n<li><span class=\"math display\">\\[\\tt{domian = a:b}\\]</span>设置 𝑥\r\n的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；</li>\r\n<li><span class=\"math display\">\\[\\tt{axis\\,\\, lines =\r\nleft}\\]</span>这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；</li>\r\n<li> 添加函数标签</li>\r\n<li>按顺序批量谭家函数标签</li>\r\n<li>title在axis中为图像添加标题</li>\r\n</ul>\r\n<h3 id=\"实例三数据图\">实例三、数据图</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex6:plot from data</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;[</span><br><span class=\"line\">\t\ttitle=&#123;Temperature dependence of CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O solubility&#125;,</span><br><span class=\"line\">\t\txlabel=&#123;Temperature [<span class=\"keyword\">\\textcelsius</span>]&#125;,</span><br><span class=\"line\">\t\tylabel=&#123;Solubility [g per 100 g water]&#125;,</span><br><span class=\"line\">\t\txmin=0, xmax=100,</span><br><span class=\"line\">\t\tymin=0, ymax=120,</span><br><span class=\"line\">\t\txtick=&#123;0,20,40,60,80,100&#125;,</span><br><span class=\"line\">\t\tytick=&#123;0,20,40,60,80,100,120&#125;,</span><br><span class=\"line\">\t\tlegend pos=north west,</span><br><span class=\"line\">\t\tymajorgrids=true,</span><br><span class=\"line\">\t\tgrid style=dashed,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[</span><br><span class=\"line\">\t\tcolor=blue,</span><br><span class=\"line\">\t\tmark=square,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\tcoordinates &#123;</span><br><span class=\"line\">\t\t\t(0,23.1)</span><br><span class=\"line\">\t\t\t(10,27.5)</span><br><span class=\"line\">\t\t\t(20,32)</span><br><span class=\"line\">\t\t\t(30,37.8)</span><br><span class=\"line\">\t\t\t(40,44.6)</span><br><span class=\"line\">\t\t\t(60,61.8)</span><br><span class=\"line\">\t\t\t(80,83.8)</span><br><span class=\"line\">\t\t\t(100,114)</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\legend</span>&#123;CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<h4\r\nid=\"数据图像中的常用命令参数与特性test-1-crop-1\">数据图像中的常用命令、参数与特性<img\r\nsrc=\"https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png\"\r\nalt=\"test-1-crop-1\" /></h4>\r\n<ul>\r\n<li>mark：设定图像点的形状；如square、triangle、x等</li>\r\n<li><span\r\nclass=\"math display\">\\[\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}\\]</span>​启用/禁用\r\n𝑦,𝑥 轴上<strong>刻度线位置上</strong>的网格线；</li>\r\n<li><span class=\"math display\">\\[\\tt{xmin=a, xmax=b, ymin=c,\r\nymax=d}\\]</span>​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐\r\n，最大值为 𝑑 ；</li>\r\n<li><span class=\"math display\">\\[\\tt{coordinates\r\n\\{\\}}\\]</span>​设定坐标点画折线图</li>\r\n<li>table {file_with_the_data.dat},使用该命令可直接通过dat数据画图</li>\r\n</ul>\r\n<h3 id=\"其他图像\">其他图像</h3>\r\n<p>pgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。</p>\r\n<h3 id=\"导言区的一些设定\">导言区的一些设定</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\pgfplotsset</span>&#123;width=10cm&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这里指定了每一张图的宽度为10cm</p>\r\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\usepgfplotslibrary</span>&#123;external&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\tikzexternalize</span> </span><br></pre></td></tr></table></figure>\r\n<p>由于<span class=\"math display\">\\[LATEX\\]</span>\r\n诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。</p>\r\n","length":929,"excerpt":"<p>持续更新遇到的问题，完结或不再使用该包将删除这句话</p>\r\n<h2 id=\"pgfplots\">pgfplots</h2>\r\n<p>Pgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots\r\n宏包会帮助用户绘制响应的图像。</p>","more":"<h3\r\nid=\"实例一通过函数方程绘制函数图像\">实例一、通过函数方程绘制函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex1:f(x)=exp(x)</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<p>其中绘制图像的语法如下：</p>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>[option] &#123;expression of 2D function&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D\r\n函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥)\r\n。最后最重要的是该命令必须以分号 <strong>;</strong> 结尾。</p>\r\n<h3\r\nid=\"实例二坐标系的绘制以及3d函数图像\">实例二、坐标系的绘制以及3d函数图像</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\documentclass</span>&#123;ctexart&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\pagestyle</span>&#123;empty&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\usepackage</span>&#123;pgfplots&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;document&#125;</span><br><span class=\"line\"><span class=\"comment\">%Ex2: put the 2D plot and the 3D plot together</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"comment\">%Here ends the furst 2D plot</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">\\hskip</span> 10pt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%Here begins the 3d plot</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">\t\tsurf,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png\"\r\nalt=\"test-1-crop-1\" />\r\n<figcaption aria-hidden=\"true\">test-1-crop-1</figcaption>\r\n</figure>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\addplot</span>3[</span><br><span class=\"line\">    surf,</span><br><span class=\"line\">]</span><br><span class=\"line\">&#123;exp(-x<span class=\"built_in\">^</span>2-y<span class=\"built_in\">^</span>2)*x&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。</p>\r\n<p>可以看到对多个图像只需要设定多个tikzpicture作用域即可</p>\r\n<h4\r\nid=\"坐标系图像中的常用命令参数与特性\">坐标系图像中的常用命令、参数与特性</h4>\r\n<ul>\r\n<li>xlabel、ylabel：设定x,y坐标轴上的标志。</li>\r\n<li>多个addplot可在同一个图中多次作图</li>\r\n<li><span class=\"math display\">\\[\\tt{domian = a:b}\\]</span>设置 𝑥\r\n的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；</li>\r\n<li><span class=\"math display\">\\[\\tt{axis\\,\\, lines =\r\nleft}\\]</span>这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；</li>\r\n<li> 添加函数标签</li>\r\n<li>按顺序批量谭家函数标签</li>\r\n<li>title在axis中为图像添加标题</li>\r\n</ul>\r\n<h3 id=\"实例三数据图\">实例三、数据图</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%Ex6:plot from data</span></span><br><span class=\"line\"><span class=\"keyword\">\\begin</span>&#123;tikzpicture&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">\\begin</span>&#123;axis&#125;[</span><br><span class=\"line\">\t\ttitle=&#123;Temperature dependence of CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O solubility&#125;,</span><br><span class=\"line\">\t\txlabel=&#123;Temperature [<span class=\"keyword\">\\textcelsius</span>]&#125;,</span><br><span class=\"line\">\t\tylabel=&#123;Solubility [g per 100 g water]&#125;,</span><br><span class=\"line\">\t\txmin=0, xmax=100,</span><br><span class=\"line\">\t\tymin=0, ymax=120,</span><br><span class=\"line\">\t\txtick=&#123;0,20,40,60,80,100&#125;,</span><br><span class=\"line\">\t\tytick=&#123;0,20,40,60,80,100,120&#125;,</span><br><span class=\"line\">\t\tlegend pos=north west,</span><br><span class=\"line\">\t\tymajorgrids=true,</span><br><span class=\"line\">\t\tgrid style=dashed,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\addplot</span>[</span><br><span class=\"line\">\t\tcolor=blue,</span><br><span class=\"line\">\t\tmark=square,</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t\tcoordinates &#123;</span><br><span class=\"line\">\t\t\t(0,23.1)</span><br><span class=\"line\">\t\t\t(10,27.5)</span><br><span class=\"line\">\t\t\t(20,32)</span><br><span class=\"line\">\t\t\t(30,37.8)</span><br><span class=\"line\">\t\t\t(40,44.6)</span><br><span class=\"line\">\t\t\t(60,61.8)</span><br><span class=\"line\">\t\t\t(80,83.8)</span><br><span class=\"line\">\t\t\t(100,114)</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">\\legend</span>&#123;CuSO<span class=\"built_in\">$</span><span class=\"built_in\">_</span>4<span class=\"keyword\">\\cdot</span><span class=\"built_in\">$</span>5H<span class=\"built_in\">$</span><span class=\"built_in\">_</span>2<span class=\"built_in\">$</span>O&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">\\end</span>&#123;axis&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>\r\n<h4\r\nid=\"数据图像中的常用命令参数与特性test-1-crop-1\">数据图像中的常用命令、参数与特性<img\r\nsrc=\"https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png\"\r\nalt=\"test-1-crop-1\" /></h4>\r\n<ul>\r\n<li>mark：设定图像点的形状；如square、triangle、x等</li>\r\n<li><span\r\nclass=\"math display\">\\[\\tt{ymajorgrids=true/false\\,,xmajorgrids=true/false}\\]</span>​启用/禁用\r\n𝑦,𝑥 轴上<strong>刻度线位置上</strong>的网格线；</li>\r\n<li><span class=\"math display\">\\[\\tt{xmin=a, xmax=b, ymin=c,\r\nymax=d}\\]</span>​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐\r\n，最大值为 𝑑 ；</li>\r\n<li><span class=\"math display\">\\[\\tt{coordinates\r\n\\{\\}}\\]</span>​设定坐标点画折线图</li>\r\n<li>table {file_with_the_data.dat},使用该命令可直接通过dat数据画图</li>\r\n</ul>\r\n<h3 id=\"其他图像\">其他图像</h3>\r\n<p>pgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。</p>\r\n<h3 id=\"导言区的一些设定\">导言区的一些设定</h3>\r\n<figure class=\"highlight latex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\pgfplotsset</span>&#123;width=10cm&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这里指定了每一张图的宽度为10cm</p>\r\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">\\usepgfplotslibrary</span>&#123;external&#125;</span><br><span class=\"line\"><span class=\"keyword\">\\tikzexternalize</span> </span><br></pre></td></tr></table></figure>\r\n<p>由于<span class=\"math display\">\\[LATEX\\]</span>\r\n诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。</p>"},{"title":"Nodejs安装简要建议","date":"2024-08-15T02:28:48.000Z","_content":"## NodeJS\n\n### 什么是Nodejs\n\n[Node.js — Run JavaScript Everywhere](https://nodejs.org/)这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。\n\n具体的讲，如下。。\n\n>  Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n\n<!--more-->\n\n### 下载时一步步涉及到的包管理\n\nnvm——Node Version Manager\n\nfnm——Fast Node Manager\n\nnvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm 就没这个问题。并且 Windows 上的 [nvm](https://github.com/nvm-sh/nvm) 与 macOS 上的 [nvm](https://github.com/coreybutler/nvm-windows) 实际上并不是同一个，Windows 的只是借了 nvm 的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm 在三大系统上都是同一个，这保证了 API 的一致性。\n\n下面以fnm为例\n\n### fnm 下载\n\n```\ncurl -fsSL https://fnm.vercel.app/install | bash\n```\n\n如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：\n\n[fnm.zip](https://objects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-streamobjects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-stream)\n\n### NodeJS18版本以上的gcc&make版本要求\n\n要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make install即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。\n\n以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog\n\n[OSError: /lib64/libm.so.6: version `GLIBC_2.27' not found (required by xxx.so) ——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n在make过程中通常涉及\n\n```\nld-linux-x86-64.so.2\\libc.so.6\n```\n\n两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n最后记得设置环境变量，切勿随意删除系统gcc文件。\n\n>  许多blog在configure中设置--profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）\n\n安装NodeJS详细步骤建议参考官方：[Node.js — Download Node.js® (nodejs.org)](https://nodejs.org/en/download/package-manager)\n\n注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素\n\n### NodeJS验证\n\n```\nnode -v\nnpm -v\n```\n\n两条指令均正常即说明程序成功安装\n","source":"_posts/Nodejs安装简要建议.md","raw":"---\ntitle: Nodejs安装简要建议\ndate: 2024-08-15 10:28:48\ntags: [nodejs, gcc, linux]\ncategories: \n\t- 软件\n\t- 经典库\n\t- 前端\n\t- node\n---\n## NodeJS\n\n### 什么是Nodejs\n\n[Node.js — Run JavaScript Everywhere](https://nodejs.org/)这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。\n\n具体的讲，如下。。\n\n>  Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n\n<!--more-->\n\n### 下载时一步步涉及到的包管理\n\nnvm——Node Version Manager\n\nfnm——Fast Node Manager\n\nnvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm 就没这个问题。并且 Windows 上的 [nvm](https://github.com/nvm-sh/nvm) 与 macOS 上的 [nvm](https://github.com/coreybutler/nvm-windows) 实际上并不是同一个，Windows 的只是借了 nvm 的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm 在三大系统上都是同一个，这保证了 API 的一致性。\n\n下面以fnm为例\n\n### fnm 下载\n\n```\ncurl -fsSL https://fnm.vercel.app/install | bash\n```\n\n如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：\n\n[fnm.zip](https://objects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-streamobjects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240529T083324Z&X-Amz-Expires=300&X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&X-Amz-SignedHeaders=host&actor_id=91273161&key_id=0&repo_id=166045424&response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&response-content-type=application%2Foctet-stream)\n\n### NodeJS18版本以上的gcc&make版本要求\n\n要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make install即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。\n\n以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog\n\n[OSError: /lib64/libm.so.6: version `GLIBC_2.27' not found (required by xxx.so) ——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n在make过程中通常涉及\n\n```\nld-linux-x86-64.so.2\\libc.so.6\n```\n\n两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)\n\n最后记得设置环境变量，切勿随意删除系统gcc文件。\n\n>  许多blog在configure中设置--profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）\n\n安装NodeJS详细步骤建议参考官方：[Node.js — Download Node.js® (nodejs.org)](https://nodejs.org/en/download/package-manager)\n\n注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素\n\n### NodeJS验证\n\n```\nnode -v\nnpm -v\n```\n\n两条指令均正常即说明程序成功安装\n","slug":"Nodejs安装简要建议","published":1,"updated":"2024-08-15T02:41:25.517Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt5000hwwwv0cbbc8x5","content":"<h2 id=\"nodejs\">NodeJS</h2>\r\n<h3 id=\"什么是nodejs\">什么是Nodejs</h3>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnLw==\">Node.js — Run JavaScript\r\nEverywhere<i class=\"fa fa-external-link-alt\"></i></span>这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。</p>\r\n<p>具体的讲，如下。。</p>\r\n<blockquote>\r\n<p>Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome\r\nJavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端\r\nJavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript\r\n的速度非常快，性能非常好。</p>\r\n</blockquote>\r\n<span id=\"more\"></span>\r\n<h3 id=\"下载时一步步涉及到的包管理\">下载时一步步涉及到的包管理</h3>\r\n<p>nvm——Node Version Manager</p>\r\n<p>fnm——Fast Node Manager</p>\r\n<p>nvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm\r\n就没这个问题。并且 Windows 上的 <a\r\nhref=\"https://github.com/nvm-sh/nvm\">nvm</a> 与 macOS 上的 <a\r\nhref=\"https://github.com/coreybutler/nvm-windows\">nvm</a>\r\n实际上并不是同一个，Windows 的只是借了 nvm\r\n的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm\r\n在三大系统上都是同一个，这保证了 API 的一致性。</p>\r\n<p>下面以fnm为例</p>\r\n<h3 id=\"fnm-下载\">fnm 下载</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://fnm.vercel.app/install | bash</span><br></pre></td></tr></table></figure>\r\n<p>如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：</p>\r\n<p><a\r\nhref=\"https://objects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20240529T083324Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&amp;X-Amz-SignedHeaders=host&amp;actor_id=91273161&amp;key_id=0&amp;repo_id=166045424&amp;response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&amp;response-content-type=application%2Foctet-streamobjects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20240529T083324Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&amp;X-Amz-SignedHeaders=host&amp;actor_id=91273161&amp;key_id=0&amp;repo_id=166045424&amp;response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&amp;response-content-type=application%2Foctet-stream\">fnm.zip</a></p>\r\n<h3\r\nid=\"nodejs18版本以上的gccmake版本要求\">NodeJS18版本以上的gcc&amp;make版本要求</h3>\r\n<p>要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make\r\ninstall即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。</p>\r\n<p>以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog</p>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh\">OSError:\r\n/lib64/libm.so.6: version `GLIBC_2.27' not found (required by xxx.so)\r\n——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)</a></p>\r\n<p>在make过程中通常涉及</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld-linux-x86-64.so.2\\libc.so.6</span><br></pre></td></tr></table></figure>\r\n<p>两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)</p>\r\n<p>最后记得设置环境变量，切勿随意删除系统gcc文件。</p>\r\n<blockquote>\r\n<p>许多blog在configure中设置--profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）</p>\r\n</blockquote>\r\n<p>安装NodeJS详细步骤建议参考官方：<a\r\nhref=\"https://nodejs.org/en/download/package-manager\">Node.js — Download\r\nNode.js® (nodejs.org)</a></p>\r\n<p>注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素</p>\r\n<h3 id=\"nodejs验证\">NodeJS验证</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\r\n<p>两条指令均正常即说明程序成功安装</p>\r\n","length":731,"excerpt":"<h2 id=\"nodejs\">NodeJS</h2>\r\n<h3 id=\"什么是nodejs\">什么是Nodejs</h3>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnLw==\">Node.js — Run JavaScript\r\nEverywhere<i class=\"fa fa-external-link-alt\"></i></span>这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。</p>\r\n<p>具体的讲，如下。。</p>\r\n<blockquote>\r\n<p>Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome\r\nJavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端\r\nJavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript\r\n的速度非常快，性能非常好。</p>\r\n</blockquote>","more":"<h3 id=\"下载时一步步涉及到的包管理\">下载时一步步涉及到的包管理</h3>\r\n<p>nvm——Node Version Manager</p>\r\n<p>fnm——Fast Node Manager</p>\r\n<p>nvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm\r\n就没这个问题。并且 Windows 上的 <a\r\nhref=\"https://github.com/nvm-sh/nvm\">nvm</a> 与 macOS 上的 <a\r\nhref=\"https://github.com/coreybutler/nvm-windows\">nvm</a>\r\n实际上并不是同一个，Windows 的只是借了 nvm\r\n的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm\r\n在三大系统上都是同一个，这保证了 API 的一致性。</p>\r\n<p>下面以fnm为例</p>\r\n<h3 id=\"fnm-下载\">fnm 下载</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://fnm.vercel.app/install | bash</span><br></pre></td></tr></table></figure>\r\n<p>如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：</p>\r\n<p><a\r\nhref=\"https://objects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20240529T083324Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&amp;X-Amz-SignedHeaders=host&amp;actor_id=91273161&amp;key_id=0&amp;repo_id=166045424&amp;response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&amp;response-content-type=application%2Foctet-streamobjects.githubusercontent.com/github-production-release-asset-2e65be/166045424/4c0a9e2a-9b22-4ebe-b026-de5e78de9351?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=releaseassetproduction%2F20240529%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20240529T083324Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=d5e13763b9750727bd45b014d12aa7e3a893ffe2758189710d8c11d874eb9e66&amp;X-Amz-SignedHeaders=host&amp;actor_id=91273161&amp;key_id=0&amp;repo_id=166045424&amp;response-content-disposition=attachment%3B%20filename%3Dfnm-linux.zip&amp;response-content-type=application%2Foctet-stream\">fnm.zip</a></p>\r\n<h3\r\nid=\"nodejs18版本以上的gccmake版本要求\">NodeJS18版本以上的gcc&amp;make版本要求</h3>\r\n<p>要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make\r\ninstall即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。</p>\r\n<p>以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog</p>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh\">OSError:\r\n/lib64/libm.so.6: version `GLIBC_2.27' not found (required by xxx.so)\r\n——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)</a></p>\r\n<p>在make过程中通常涉及</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld-linux-x86-64.so.2\\libc.so.6</span><br></pre></td></tr></table></figure>\r\n<p>两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh)</p>\r\n<p>最后记得设置环境变量，切勿随意删除系统gcc文件。</p>\r\n<blockquote>\r\n<p>许多blog在configure中设置--profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）</p>\r\n</blockquote>\r\n<p>安装NodeJS详细步骤建议参考官方：<a\r\nhref=\"https://nodejs.org/en/download/package-manager\">Node.js — Download\r\nNode.js® (nodejs.org)</a></p>\r\n<p>注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素</p>\r\n<h3 id=\"nodejs验证\">NodeJS验证</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\r\n<p>两条指令均正常即说明程序成功安装</p>"},{"title":"Miracl的配置ForCentos7","date":"2024-08-14T11:55:03.000Z","_content":"Miracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).\n\nMiracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的\n\n<!--more-->\n\n```cpp\nextern \"C\"\n{\n     #include \"miracl.h\"\n}\n```\n\n实现兼容。\n\n下面是对miracl在c++环境下部署的简单步骤\n\n第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输\n\n`````shell\nwget https://github.com/miracl/MIRACL/archive/master.zip\n`````\n\n第二步、创建一个文件夹用来存放解压文件\n\n```shell\nmkdir miracl\n```\n\n第三步、复制并解压\n\n```shell\ncp master.zip ./miracl\ncd miracl/\nunzip -j -aa -L master.zip\n```\n\n第四步、验证解压并运行linux64（若32位运行linux）\n\n```shell\nls\nbash linux64\nll | grep miracl.a\n```\n\n第五步、运行官方程序\n\n```shell\n./pk-demo\n```\n\n第六步、一般情况下、复制一下文件到你的源代码目录下\n\n````shell\ncp ../miracl/miracl.a miracl.a\ncp ../miracl/miracl.h miracl.h\ncp ../miracl/mirdef.h mirdef.h\n````\n\n完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：\n\n[静态库文件](https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ)","source":"_posts/Miracl的配置ForCentos7.md","raw":"---\ntitle: Miracl的配置ForCentos7\ndate: 2024-08-14 19:55:03\ntags: [信息安全, 软件, Miracl]\ncategories: \n\t- 软件\n\t- 经典库\n\t- 信息安全\n---\nMiracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).\n\nMiracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的\n\n<!--more-->\n\n```cpp\nextern \"C\"\n{\n     #include \"miracl.h\"\n}\n```\n\n实现兼容。\n\n下面是对miracl在c++环境下部署的简单步骤\n\n第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输\n\n`````shell\nwget https://github.com/miracl/MIRACL/archive/master.zip\n`````\n\n第二步、创建一个文件夹用来存放解压文件\n\n```shell\nmkdir miracl\n```\n\n第三步、复制并解压\n\n```shell\ncp master.zip ./miracl\ncd miracl/\nunzip -j -aa -L master.zip\n```\n\n第四步、验证解压并运行linux64（若32位运行linux）\n\n```shell\nls\nbash linux64\nll | grep miracl.a\n```\n\n第五步、运行官方程序\n\n```shell\n./pk-demo\n```\n\n第六步、一般情况下、复制一下文件到你的源代码目录下\n\n````shell\ncp ../miracl/miracl.a miracl.a\ncp ../miracl/miracl.h miracl.h\ncp ../miracl/mirdef.h mirdef.h\n````\n\n完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：\n\n[静态库文件](https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ)","slug":"Miracl的配置ForCentos7","published":1,"updated":"2024-08-14T13:38:48.720Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt6000lwwwv9vii957j","content":"<p>Miracl is Multiprecision Integer and Rational Arithmetic\r\nCryptographic Library – the MIRACL Crypto SDK – is a C software library\r\nthat is widely regarded by developers as the gold standard open source\r\nSDK for elliptic curve cryptography (ECC).</p>\r\n<p>Miracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C\r\n软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源\r\nSDK。也可在c++环境下通过对c库的</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;miracl.h&quot;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>实现兼容。</p>\r\n<p>下面是对miracl在c++环境下部署的简单步骤</p>\r\n<p>第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/miracl/MIRACL/archive/master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第二步、创建一个文件夹用来存放解压文件</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir miracl</span><br></pre></td></tr></table></figure>\r\n<p>第三步、复制并解压</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp master.zip ./miracl</span><br><span class=\"line\">cd miracl/</span><br><span class=\"line\">unzip -j -aa -L master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第四步、验证解压并运行linux64（若32位运行linux）</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">bash linux64</span><br><span class=\"line\">ll | grep miracl.a</span><br></pre></td></tr></table></figure>\r\n<p>第五步、运行官方程序</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./pk-demo</span><br></pre></td></tr></table></figure>\r\n<p>第六步、一般情况下、复制一下文件到你的源代码目录下</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ../miracl/miracl.a miracl.a</span><br><span class=\"line\">cp ../miracl/miracl.h miracl.h</span><br><span class=\"line\">cp ../miracl/mirdef.h mirdef.h</span><br></pre></td></tr></table></figure>\r\n<p>完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：</p>\r\n<p><a\r\nhref=\"https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ\">静态库文件</a></p>\r\n","length":411,"excerpt":"<p>Miracl is Multiprecision Integer and Rational Arithmetic\r\nCryptographic Library – the MIRACL Crypto SDK – is a C software library\r\nthat is widely regarded by developers as the gold standard open source\r\nSDK for elliptic curve cryptography (ECC).</p>\r\n<p>Miracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C\r\n软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源\r\nSDK。也可在c++环境下通过对c库的</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;miracl.h&quot;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>实现兼容。</p>\r\n<p>下面是对miracl在c++环境下部署的简单步骤</p>\r\n<p>第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/miracl/MIRACL/archive/master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第二步、创建一个文件夹用来存放解压文件</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir miracl</span><br></pre></td></tr></table></figure>\r\n<p>第三步、复制并解压</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp master.zip ./miracl</span><br><span class=\"line\">cd miracl/</span><br><span class=\"line\">unzip -j -aa -L master.zip</span><br></pre></td></tr></table></figure>\r\n<p>第四步、验证解压并运行linux64（若32位运行linux）</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">bash linux64</span><br><span class=\"line\">ll | grep miracl.a</span><br></pre></td></tr></table></figure>\r\n<p>第五步、运行官方程序</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./pk-demo</span><br></pre></td></tr></table></figure>\r\n<p>第六步、一般情况下、复制一下文件到你的源代码目录下</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ../miracl/miracl.a miracl.a</span><br><span class=\"line\">cp ../miracl/miracl.h miracl.h</span><br><span class=\"line\">cp ../miracl/mirdef.h mirdef.h</span><br></pre></td></tr></table></figure>\r\n<p>完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：</p>\r\n<p><a\r\nhref=\"https://1drv.ms/f/s!Ap-enY7ckLANgoNMIQysXRVS8LdGyQ\">静态库文件</a></p>"},{"title":"RSA涉及算法与数论知识","date":"2024-08-14T11:51:58.000Z","_content":"**RSA** (**Rivest–Shamir–Adleman**) is a [public-key cryptosystem](https://en.wikipedia.org/wiki/Public-key_cryptography), one of the oldest widely used for secure data transmission.\n\nRSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。\n\n<!--more-->\n\n## 基础数论知识纲要\n\n传送门：[MH3210 - NTU - Number Theory - Studocu](https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934)\n\n知乎blog：[基础数论学习笔记（1）- Divisibility 整除 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/635332658)\n\n讲义：[NanYang Technological University MH1300ANDMH3210](https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg) \n\n## 概念定义\n\n**费马小定理**：选一个**素数p**，再选一个和p不成倍数关系的整数β，必然满足**β的p次幂**和**β**对p同余。公式如下。\n$$\n\\beta^p \\equiv \\beta (modp)\n$$\n**二次剩余**： 取定 $$𝑎\\perp 𝑝$$, 假若存在着 $x$使得\n$$\nx^2 \\equiv a (modp)\n$$\n\n则称$$a$$是$$modp$$的特殊剩余，否则则是$$modp$$的二次非剩余\n\n**欧拉准则**：元素β是**模奇素数p**的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\n$$\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\n$$\n\n> 欧拉准则证明：\n> 设$$r^2 = \\beta$$则有 $$r^{p-1} \\equiv 1 (modp)$$,利用费马小定理即可得证。\n\n**勒让德符号**：$$(\\frac{a}{p})$$ 若$$a$$ 是$$modp$$的平方剩余 则 $$(\\frac{a}{p}) = 1$$ ，若不是，则$$(\\frac{a}{p})= -1$$ 若$$a$$和$$p$$是整除关系则$$(\\frac{a}{p})=0$$ ,如下列公式\n$$\n(\\frac{a}{p}) = \n\\begin{cases}\n1,\\quad x^2 \\equiv a(modp)\\\\\n0, \\quad a \\equiv 0 (modp) \\\\\n-1, \\quad x^2 \\not\\equiv a(modp)\n\\end{cases}\n\\tag{1}\n$$\nSolovay-Strassen算法：若n是一个素数，那么勒让德符号$$(\\frac{β}{n})\\equiv β^{(n-1)/2}mod n$$。\n\n> Strassen算法证明：根据欧拉准则**β的(n-1)/2次方和1对n不同余**，根据费马小定理，**β的n-1次方**和1对n同余，根据平方差公式，$$β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)$$ 。由于$（β^{(n-1)/2}-1）$ 无法被n整除，所以$$（β^{(n-1)/2}+1）$$ 必然能被n整除，进而得到$$β^{(n-1)/2}\\equiv-1  (mod n)$$。\n\n**该命题的逆命题是不成立的**\n\n**二次互反律**：$$\\mathbb Z_p^\\times\\to\\mathbb Z_2$$​ \n\n**Miller-Rabin算法**：\n\n输入待测试大数$$n$$，对$$n-1$$不断地进行除$$2$$操作，直到得到一个**奇数t**。\n\n于是这可以写成 $$n-1 = 2^s \\cdot t$$ 。显然的，待测试大数$n$肯定是个奇数（废话，是偶数还测个锤子了），那么$$n-1$$肯定是个偶数，故$$s\\not=0$$。\n\n选择**随机种子$$a$$**，$$a＜n$$且与$$n$$互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）\n\n先设$$m=t$$。计算 $$b \\equiv a^t(modn)$$ ：\n\n- 情况①：当 $$m=2^s \\cdot t = n -1$$时，停机，输出“n是一个合数”。\n\n- 情况②：当 $$b \\equiv -1 (modn)$$ 时，停机，换一个随机种子a再次进行测试。\n\n- 情况③：当$$b \\equiv -1(modn)$$不成立时，重新设$b$为$$b²(mod n)$$，$$m$$为$$2m$$​；继续循环，直到得到情况①或情况②为止。\n\n## 计算方法\n\n**快速幂**：通过二进制的快速幂优化\n\n**计算勒让德符号$$(\\frac{\\beta}{n})$$​** ：二次互反\n\n**大整数除法中对小除数的优化**：移位计算小除数的商\n\n**大整数除法中对大除数的优化**：二分查找对每次计算试商的优化","source":"_posts/RSA涉及算法与数论知识.md","raw":"---\ntitle: RSA涉及算法与数论知识\ndate: 2024-08-14 19:51:58\ntags: [信息安全, 数学]\ncategories:\n\t- 信息安全\n\t- 加密算法\n\t- 数学\n---\n**RSA** (**Rivest–Shamir–Adleman**) is a [public-key cryptosystem](https://en.wikipedia.org/wiki/Public-key_cryptography), one of the oldest widely used for secure data transmission.\n\nRSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。\n\n<!--more-->\n\n## 基础数论知识纲要\n\n传送门：[MH3210 - NTU - Number Theory - Studocu](https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934)\n\n知乎blog：[基础数论学习笔记（1）- Divisibility 整除 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/635332658)\n\n讲义：[NanYang Technological University MH1300ANDMH3210](https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg) \n\n## 概念定义\n\n**费马小定理**：选一个**素数p**，再选一个和p不成倍数关系的整数β，必然满足**β的p次幂**和**β**对p同余。公式如下。\n$$\n\\beta^p \\equiv \\beta (modp)\n$$\n**二次剩余**： 取定 $$𝑎\\perp 𝑝$$, 假若存在着 $x$使得\n$$\nx^2 \\equiv a (modp)\n$$\n\n则称$$a$$是$$modp$$的特殊剩余，否则则是$$modp$$的二次非剩余\n\n**欧拉准则**：元素β是**模奇素数p**的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\n$$\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\n$$\n\n> 欧拉准则证明：\n> 设$$r^2 = \\beta$$则有 $$r^{p-1} \\equiv 1 (modp)$$,利用费马小定理即可得证。\n\n**勒让德符号**：$$(\\frac{a}{p})$$ 若$$a$$ 是$$modp$$的平方剩余 则 $$(\\frac{a}{p}) = 1$$ ，若不是，则$$(\\frac{a}{p})= -1$$ 若$$a$$和$$p$$是整除关系则$$(\\frac{a}{p})=0$$ ,如下列公式\n$$\n(\\frac{a}{p}) = \n\\begin{cases}\n1,\\quad x^2 \\equiv a(modp)\\\\\n0, \\quad a \\equiv 0 (modp) \\\\\n-1, \\quad x^2 \\not\\equiv a(modp)\n\\end{cases}\n\\tag{1}\n$$\nSolovay-Strassen算法：若n是一个素数，那么勒让德符号$$(\\frac{β}{n})\\equiv β^{(n-1)/2}mod n$$。\n\n> Strassen算法证明：根据欧拉准则**β的(n-1)/2次方和1对n不同余**，根据费马小定理，**β的n-1次方**和1对n同余，根据平方差公式，$$β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)$$ 。由于$（β^{(n-1)/2}-1）$ 无法被n整除，所以$$（β^{(n-1)/2}+1）$$ 必然能被n整除，进而得到$$β^{(n-1)/2}\\equiv-1  (mod n)$$。\n\n**该命题的逆命题是不成立的**\n\n**二次互反律**：$$\\mathbb Z_p^\\times\\to\\mathbb Z_2$$​ \n\n**Miller-Rabin算法**：\n\n输入待测试大数$$n$$，对$$n-1$$不断地进行除$$2$$操作，直到得到一个**奇数t**。\n\n于是这可以写成 $$n-1 = 2^s \\cdot t$$ 。显然的，待测试大数$n$肯定是个奇数（废话，是偶数还测个锤子了），那么$$n-1$$肯定是个偶数，故$$s\\not=0$$。\n\n选择**随机种子$$a$$**，$$a＜n$$且与$$n$$互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）\n\n先设$$m=t$$。计算 $$b \\equiv a^t(modn)$$ ：\n\n- 情况①：当 $$m=2^s \\cdot t = n -1$$时，停机，输出“n是一个合数”。\n\n- 情况②：当 $$b \\equiv -1 (modn)$$ 时，停机，换一个随机种子a再次进行测试。\n\n- 情况③：当$$b \\equiv -1(modn)$$不成立时，重新设$b$为$$b²(mod n)$$，$$m$$为$$2m$$​；继续循环，直到得到情况①或情况②为止。\n\n## 计算方法\n\n**快速幂**：通过二进制的快速幂优化\n\n**计算勒让德符号$$(\\frac{\\beta}{n})$$​** ：二次互反\n\n**大整数除法中对小除数的优化**：移位计算小除数的商\n\n**大整数除法中对大除数的优化**：二分查找对每次计算试商的优化","slug":"RSA涉及算法与数论知识","published":1,"updated":"2024-08-14T13:38:56.431Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt6000nwwwvf9on6fru","content":"<p><strong>RSA</strong> (<strong>Rivest–Shamir–Adleman</strong>) is a <a\r\nhref=\"https://en.wikipedia.org/wiki/Public-key_cryptography\">public-key\r\ncryptosystem</a>, one of the oldest widely used for secure data\r\ntransmission.</p>\r\n<p>RSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"基础数论知识纲要\">基础数论知识纲要</h2>\r\n<p>传送门：<a\r\nhref=\"https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934\">MH3210\r\n- NTU - Number Theory - Studocu</a></p>\r\n<p>知乎blog：<a\r\nhref=\"https://zhuanlan.zhihu.com/p/635332658\">基础数论学习笔记（1）-\r\nDivisibility 整除 - 知乎 (zhihu.com)</a></p>\r\n<p>讲义：<a\r\nhref=\"https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg\">NanYang\r\nTechnological University MH1300ANDMH3210</a></p>\r\n<h2 id=\"概念定义\">概念定义</h2>\r\n<p><strong>费马小定理</strong>：选一个<strong>素数p</strong>，再选一个和p不成倍数关系的整数β，必然满足<strong>β的p次幂</strong>和<strong>β</strong>对p同余。公式如下。\r\n<span class=\"math display\">\\[\r\n\\beta^p \\equiv \\beta (modp)\r\n\\]</span> <strong>二次剩余</strong>： 取定 <span\r\nclass=\"math display\">\\[𝑎\\perp 𝑝\\]</span>, 假若存在着 <span\r\nclass=\"math inline\">\\(x\\)</span>使得 <span class=\"math display\">\\[\r\nx^2 \\equiv a (modp)\r\n\\]</span></p>\r\n<p>则称<span class=\"math display\">\\[a\\]</span>是<span\r\nclass=\"math display\">\\[modp\\]</span>的特殊剩余，否则则是<span\r\nclass=\"math display\">\\[modp\\]</span>的二次非剩余</p>\r\n<p><strong>欧拉准则</strong>：元素β是<strong>模奇素数p</strong>的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\r\n<span class=\"math display\">\\[\r\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\r\n\\]</span></p>\r\n<blockquote>\r\n<p>欧拉准则证明： 设<span class=\"math display\">\\[r^2 =\r\n\\beta\\]</span>则有 <span class=\"math display\">\\[r^{p-1} \\equiv 1\r\n(modp)\\]</span>,利用费马小定理即可得证。</p>\r\n</blockquote>\r\n<p><strong>勒让德符号</strong>：<span\r\nclass=\"math display\">\\[(\\frac{a}{p})\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span> 是<span\r\nclass=\"math display\">\\[modp\\]</span>的平方剩余 则 <span\r\nclass=\"math display\">\\[(\\frac{a}{p}) = 1\\]</span> ，若不是，则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})= -1\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span>和<span\r\nclass=\"math display\">\\[p\\]</span>是整除关系则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})=0\\]</span> ,如下列公式 <span\r\nclass=\"math display\">\\[\r\n(\\frac{a}{p}) =\r\n\\begin{cases}\r\n1,\\quad x^2 \\equiv a(modp)\\\\\r\n0, \\quad a \\equiv 0 (modp) \\\\\r\n-1, \\quad x^2 \\not\\equiv a(modp)\r\n\\end{cases}\r\n\\tag{1}\r\n\\]</span> Solovay-Strassen算法：若n是一个素数，那么勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{β}{n})\\equiv β^{(n-1)/2}mod\r\nn\\]</span>。</p>\r\n<blockquote>\r\n<p>Strassen算法证明：根据欧拉准则<strong>β的(n-1)/2次方和1对n不同余</strong>，根据费马小定理，<strong>β的n-1次方</strong>和1对n同余，根据平方差公式，<span\r\nclass=\"math display\">\\[β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)\\]</span>\r\n。由于<span class=\"math inline\">\\(（β^{(n-1)/2}-1）\\)</span>\r\n无法被n整除，所以<span class=\"math display\">\\[（β^{(n-1)/2}+1）\\]</span>\r\n必然能被n整除，进而得到<span\r\nclass=\"math display\">\\[β^{(n-1)/2}\\equiv-1  (mod n)\\]</span>。</p>\r\n</blockquote>\r\n<p><strong>该命题的逆命题是不成立的</strong></p>\r\n<p><strong>二次互反律</strong>：<span class=\"math display\">\\[\\mathbb\r\nZ_p^\\times\\to\\mathbb Z_2\\]</span>​</p>\r\n<p><strong>Miller-Rabin算法</strong>：</p>\r\n<p>输入待测试大数<span class=\"math display\">\\[n\\]</span>，对<span\r\nclass=\"math display\">\\[n-1\\]</span>不断地进行除<span\r\nclass=\"math display\">\\[2\\]</span>操作，直到得到一个<strong>奇数t</strong>。</p>\r\n<p>于是这可以写成 <span class=\"math display\">\\[n-1 = 2^s \\cdot\r\nt\\]</span> 。显然的，待测试大数<span\r\nclass=\"math inline\">\\(n\\)</span>肯定是个奇数（废话，是偶数还测个锤子了），那么<span\r\nclass=\"math display\">\\[n-1\\]</span>肯定是个偶数，故<span\r\nclass=\"math display\">\\[s\\not=0\\]</span>。</p>\r\n<p>选择<strong>随机种子<span\r\nclass=\"math display\">\\[a\\]</span></strong>，<span\r\nclass=\"math display\">\\[a＜n\\]</span>且与<span\r\nclass=\"math display\">\\[n\\]</span>互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）</p>\r\n<p>先设<span class=\"math display\">\\[m=t\\]</span>。计算 <span\r\nclass=\"math display\">\\[b \\equiv a^t(modn)\\]</span> ：</p>\r\n<ul>\r\n<li><p>情况①：当 <span class=\"math display\">\\[m=2^s \\cdot t = n\r\n-1\\]</span>时，停机，输出“n是一个合数”。</p></li>\r\n<li><p>情况②：当 <span class=\"math display\">\\[b \\equiv -1\r\n(modn)\\]</span> 时，停机，换一个随机种子a再次进行测试。</p></li>\r\n<li><p>情况③：当<span class=\"math display\">\\[b \\equiv\r\n-1(modn)\\]</span>不成立时，重新设<span\r\nclass=\"math inline\">\\(b\\)</span>为<span class=\"math display\">\\[b²(mod\r\nn)\\]</span>，<span class=\"math display\">\\[m\\]</span>为<span\r\nclass=\"math display\">\\[2m\\]</span>​；继续循环，直到得到情况①或情况②为止。</p></li>\r\n</ul>\r\n<h2 id=\"计算方法\">计算方法</h2>\r\n<p><strong>快速幂</strong>：通过二进制的快速幂优化</p>\r\n<p><strong>计算勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{\\beta}{n})\\]</span>​</strong>\r\n：二次互反</p>\r\n<p><strong>大整数除法中对小除数的优化</strong>：移位计算小除数的商</p>\r\n<p><strong>大整数除法中对大除数的优化</strong>：二分查找对每次计算试商的优化</p>\r\n","length":831,"excerpt":"<p><strong>RSA</strong> (<strong>Rivest–Shamir–Adleman</strong>) is a <a\r\nhref=\"https://en.wikipedia.org/wiki/Public-key_cryptography\">public-key\r\ncryptosystem</a>, one of the oldest widely used for secure data\r\ntransmission.</p>\r\n<p>RSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。</p>","more":"<h2 id=\"基础数论知识纲要\">基础数论知识纲要</h2>\r\n<p>传送门：<a\r\nhref=\"https://www.studocu.com/sg/course/nanyang-technological-university/number-theory/3031934\">MH3210\r\n- NTU - Number Theory - Studocu</a></p>\r\n<p>知乎blog：<a\r\nhref=\"https://zhuanlan.zhihu.com/p/635332658\">基础数论学习笔记（1）-\r\nDivisibility 整除 - 知乎 (zhihu.com)</a></p>\r\n<p>讲义：<a\r\nhref=\"https://1drv.ms/f/s!Ap-enY7ckLANgoNHotzq3SRTafp4pg\">NanYang\r\nTechnological University MH1300ANDMH3210</a></p>\r\n<h2 id=\"概念定义\">概念定义</h2>\r\n<p><strong>费马小定理</strong>：选一个<strong>素数p</strong>，再选一个和p不成倍数关系的整数β，必然满足<strong>β的p次幂</strong>和<strong>β</strong>对p同余。公式如下。\r\n<span class=\"math display\">\\[\r\n\\beta^p \\equiv \\beta (modp)\r\n\\]</span> <strong>二次剩余</strong>： 取定 <span\r\nclass=\"math display\">\\[𝑎\\perp 𝑝\\]</span>, 假若存在着 <span\r\nclass=\"math inline\">\\(x\\)</span>使得 <span class=\"math display\">\\[\r\nx^2 \\equiv a (modp)\r\n\\]</span></p>\r\n<p>则称<span class=\"math display\">\\[a\\]</span>是<span\r\nclass=\"math display\">\\[modp\\]</span>的特殊剩余，否则则是<span\r\nclass=\"math display\">\\[modp\\]</span>的二次非剩余</p>\r\n<p><strong>欧拉准则</strong>：元素β是<strong>模奇素数p</strong>的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式\r\n<span class=\"math display\">\\[\r\n\\beta ^ {(p-1)/2} \\equiv 1 (mod p) | p \\equiv 1 (mod2)\r\n\\]</span></p>\r\n<blockquote>\r\n<p>欧拉准则证明： 设<span class=\"math display\">\\[r^2 =\r\n\\beta\\]</span>则有 <span class=\"math display\">\\[r^{p-1} \\equiv 1\r\n(modp)\\]</span>,利用费马小定理即可得证。</p>\r\n</blockquote>\r\n<p><strong>勒让德符号</strong>：<span\r\nclass=\"math display\">\\[(\\frac{a}{p})\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span> 是<span\r\nclass=\"math display\">\\[modp\\]</span>的平方剩余 则 <span\r\nclass=\"math display\">\\[(\\frac{a}{p}) = 1\\]</span> ，若不是，则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})= -1\\]</span> 若<span\r\nclass=\"math display\">\\[a\\]</span>和<span\r\nclass=\"math display\">\\[p\\]</span>是整除关系则<span\r\nclass=\"math display\">\\[(\\frac{a}{p})=0\\]</span> ,如下列公式 <span\r\nclass=\"math display\">\\[\r\n(\\frac{a}{p}) =\r\n\\begin{cases}\r\n1,\\quad x^2 \\equiv a(modp)\\\\\r\n0, \\quad a \\equiv 0 (modp) \\\\\r\n-1, \\quad x^2 \\not\\equiv a(modp)\r\n\\end{cases}\r\n\\tag{1}\r\n\\]</span> Solovay-Strassen算法：若n是一个素数，那么勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{β}{n})\\equiv β^{(n-1)/2}mod\r\nn\\]</span>。</p>\r\n<blockquote>\r\n<p>Strassen算法证明：根据欧拉准则<strong>β的(n-1)/2次方和1对n不同余</strong>，根据费马小定理，<strong>β的n-1次方</strong>和1对n同余，根据平方差公式，<span\r\nclass=\"math display\">\\[β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)\\]</span>\r\n。由于<span class=\"math inline\">\\(（β^{(n-1)/2}-1）\\)</span>\r\n无法被n整除，所以<span class=\"math display\">\\[（β^{(n-1)/2}+1）\\]</span>\r\n必然能被n整除，进而得到<span\r\nclass=\"math display\">\\[β^{(n-1)/2}\\equiv-1  (mod n)\\]</span>。</p>\r\n</blockquote>\r\n<p><strong>该命题的逆命题是不成立的</strong></p>\r\n<p><strong>二次互反律</strong>：<span class=\"math display\">\\[\\mathbb\r\nZ_p^\\times\\to\\mathbb Z_2\\]</span>​</p>\r\n<p><strong>Miller-Rabin算法</strong>：</p>\r\n<p>输入待测试大数<span class=\"math display\">\\[n\\]</span>，对<span\r\nclass=\"math display\">\\[n-1\\]</span>不断地进行除<span\r\nclass=\"math display\">\\[2\\]</span>操作，直到得到一个<strong>奇数t</strong>。</p>\r\n<p>于是这可以写成 <span class=\"math display\">\\[n-1 = 2^s \\cdot\r\nt\\]</span> 。显然的，待测试大数<span\r\nclass=\"math inline\">\\(n\\)</span>肯定是个奇数（废话，是偶数还测个锤子了），那么<span\r\nclass=\"math display\">\\[n-1\\]</span>肯定是个偶数，故<span\r\nclass=\"math display\">\\[s\\not=0\\]</span>。</p>\r\n<p>选择<strong>随机种子<span\r\nclass=\"math display\">\\[a\\]</span></strong>，<span\r\nclass=\"math display\">\\[a＜n\\]</span>且与<span\r\nclass=\"math display\">\\[n\\]</span>互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）</p>\r\n<p>先设<span class=\"math display\">\\[m=t\\]</span>。计算 <span\r\nclass=\"math display\">\\[b \\equiv a^t(modn)\\]</span> ：</p>\r\n<ul>\r\n<li><p>情况①：当 <span class=\"math display\">\\[m=2^s \\cdot t = n\r\n-1\\]</span>时，停机，输出“n是一个合数”。</p></li>\r\n<li><p>情况②：当 <span class=\"math display\">\\[b \\equiv -1\r\n(modn)\\]</span> 时，停机，换一个随机种子a再次进行测试。</p></li>\r\n<li><p>情况③：当<span class=\"math display\">\\[b \\equiv\r\n-1(modn)\\]</span>不成立时，重新设<span\r\nclass=\"math inline\">\\(b\\)</span>为<span class=\"math display\">\\[b²(mod\r\nn)\\]</span>，<span class=\"math display\">\\[m\\]</span>为<span\r\nclass=\"math display\">\\[2m\\]</span>​；继续循环，直到得到情况①或情况②为止。</p></li>\r\n</ul>\r\n<h2 id=\"计算方法\">计算方法</h2>\r\n<p><strong>快速幂</strong>：通过二进制的快速幂优化</p>\r\n<p><strong>计算勒让德符号<span\r\nclass=\"math display\">\\[(\\frac{\\beta}{n})\\]</span>​</strong>\r\n：二次互反</p>\r\n<p><strong>大整数除法中对小除数的优化</strong>：移位计算小除数的商</p>\r\n<p><strong>大整数除法中对大除数的优化</strong>：二分查找对每次计算试商的优化</p>"},{"title":"Xiaobai93D-E","date":"2024-08-14T11:46:31.000Z","_content":"\n## [D-幻兽帕鲁_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/D)\n\n### 题意\n\n在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。  \n\n你有 $$2^n$$ 只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 $$[0,2^n-1]$$ 工号的顺序排成一队。  \n\n当我们对区间 $$[l,r]$$ 的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 $$[0,r-l]$$ ，记 $$mid = \\lfloor\\frac{l + r}{2}\\rfloor$$，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间 $$[l,mid]$$ 和 $$[mid + 1,r]$$ ，并递归对这两个区间进行上述操作，直到区间长度为 $1$ 。  \n\n现在我们对 $$[0,2^n-1]$$ 的幻兽进行一次操作，然后给你 $m$ 次询问，每次询问 $x$​ 位置的帕鲁工号是多少？\n\n### 题解\n\n简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。\n\n于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1<<(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。\n\n````cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tll x;\n\t\tcin>>x;\n\t\tll ans = 0;\n\t\twhile(x){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(x < (1ll<<(n-i-1))) continue;\n\t\t\t\tx-= (1ll<<(n-i-1));\n\t\t\t\tans += (1ll<<i);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n````\n\n\n\n## [E-奏绝_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/E)\n\n### **题意：**\n\n你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。  \n\n对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为 0。  \n\n区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。  \n\n对于 m 次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对  998244353 取模。\n\n[E-奏绝_牛客小白月赛93（重现赛）](https://ac.nowcoder.com/acm/contest/82821/E)\n\n### **题解**\n\n**不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积**\n\n奏绝，我直接肘击！\n\n题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。\n\n```cpp\nstruct Node\n{\n\tint x, y, id;\n};\n\nbool cmp(const Node& x,const Node& y){\n\tif(x.x/ blk != y.x /blk) return x.x/blk < y.x/blk;\n\telse {\n\t\tif(x.x != y.x) return x.x < y.x;\n\t\telse {\n\t\t\treturn x.y < y.y;\n\t\t}\n\t}\n}\n\nvoid move(int x,int c)\n{\n\tsum1 += (s[x] == '1'? x: 0) * c;\n\tcnt1 += (s[x] == '1') * c;\n\tsum2 += (s[x] == '0'? x: 0) * c;\n\tcnt2 += (s[x] == '0') * c;\n}\n\nvoid updateL(int x,int c){\n\tif(s[x]=='1'){\n\t\tans += (sum2 - x * cnt2) * c% MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x]=='0'){\n\t\tans += (sum1 - x * cnt1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"!\"<<x<<' '<<ans<<endl;\n}\nvoid updateR(int x,int c){\n\tif(s[x] == '0'){\n\t\tans += (x * cnt1 - sum1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x] == '1'){\n\t\tans += (x * cnt2 - sum2) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"#\"<<x<<' '<<ans<<endl;\n}\n```","source":"_posts/Xiaobai93D-E.md","raw":"title: Xiaobai93D-E\ndate: 2024-08-14 19:46:31\ntags: [newcoder]\ncategories: \n\t- 比赛\n\t- 日常赛\n\t- newcoder\n---\n\n## [D-幻兽帕鲁_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/D)\n\n### 题意\n\n在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。  \n\n你有 $$2^n$$ 只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 $$[0,2^n-1]$$ 工号的顺序排成一队。  \n\n当我们对区间 $$[l,r]$$ 的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 $$[0,r-l]$$ ，记 $$mid = \\lfloor\\frac{l + r}{2}\\rfloor$$，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间 $$[l,mid]$$ 和 $$[mid + 1,r]$$ ，并递归对这两个区间进行上述操作，直到区间长度为 $1$ 。  \n\n现在我们对 $$[0,2^n-1]$$ 的幻兽进行一次操作，然后给你 $m$ 次询问，每次询问 $x$​ 位置的帕鲁工号是多少？\n\n### 题解\n\n简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。\n\n于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1<<(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。\n\n````cpp\nvoid slove() {\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tll x;\n\t\tcin>>x;\n\t\tll ans = 0;\n\t\twhile(x){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(x < (1ll<<(n-i-1))) continue;\n\t\t\t\tx-= (1ll<<(n-i-1));\n\t\t\t\tans += (1ll<<i);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n````\n\n\n\n## [E-奏绝_牛客小白月赛93 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82401/E)\n\n### **题意：**\n\n你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。  \n\n对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为 0。  \n\n区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。  \n\n对于 m 次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对  998244353 取模。\n\n[E-奏绝_牛客小白月赛93（重现赛）](https://ac.nowcoder.com/acm/contest/82821/E)\n\n### **题解**\n\n**不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积**\n\n奏绝，我直接肘击！\n\n题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。\n\n```cpp\nstruct Node\n{\n\tint x, y, id;\n};\n\nbool cmp(const Node& x,const Node& y){\n\tif(x.x/ blk != y.x /blk) return x.x/blk < y.x/blk;\n\telse {\n\t\tif(x.x != y.x) return x.x < y.x;\n\t\telse {\n\t\t\treturn x.y < y.y;\n\t\t}\n\t}\n}\n\nvoid move(int x,int c)\n{\n\tsum1 += (s[x] == '1'? x: 0) * c;\n\tcnt1 += (s[x] == '1') * c;\n\tsum2 += (s[x] == '0'? x: 0) * c;\n\tcnt2 += (s[x] == '0') * c;\n}\n\nvoid updateL(int x,int c){\n\tif(s[x]=='1'){\n\t\tans += (sum2 - x * cnt2) * c% MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x]=='0'){\n\t\tans += (sum1 - x * cnt1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"!\"<<x<<' '<<ans<<endl;\n}\nvoid updateR(int x,int c){\n\tif(s[x] == '0'){\n\t\tans += (x * cnt1 - sum1) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}else if(s[x] == '1'){\n\t\tans += (x * cnt2 - sum2) * c % MOD;\n\t\tans = (ans + MOD) % MOD;\n\t}\n\t// cout<<\"#\"<<x<<' '<<ans<<endl;\n}\n```","slug":"Xiaobai93D-E","published":1,"updated":"2024-08-15T03:48:20.236Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt7000qwwwvdcaa1gq0","content":"<h2 id=\"d-幻兽帕鲁_牛客小白月赛93-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82401/D\">D-幻兽帕鲁_牛客小白月赛93\r\n(nowcoder.com)</a></h2>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。</p>\r\n<p>你有 <span class=\"math display\">\\[2^n\\]</span>\r\n只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 <span\r\nclass=\"math display\">\\[[0,2^n-1]\\]</span> 工号的顺序排成一队。</p>\r\n<p>当我们对区间 <span class=\"math display\">\\[[l,r]\\]</span>\r\n的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 <span\r\nclass=\"math display\">\\[[0,r-l]\\]</span> ，记 <span\r\nclass=\"math display\">\\[mid = \\lfloor\\frac{l +\r\nr}{2}\\rfloor\\]</span>，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间\r\n<span class=\"math display\">\\[[l,mid]\\]</span> 和 <span\r\nclass=\"math display\">\\[[mid + 1,r]\\]</span>\r\n，并递归对这两个区间进行上述操作，直到区间长度为 <span\r\nclass=\"math inline\">\\(1\\)</span> 。</p>\r\n<p>现在我们对 <span class=\"math display\">\\[[0,2^n-1]\\]</span>\r\n的幻兽进行一次操作，然后给你 <span class=\"math inline\">\\(m\\)</span>\r\n次询问，每次询问 <span class=\"math inline\">\\(x\\)</span>​\r\n位置的帕鲁工号是多少？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。</p>\r\n<p>于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1&lt;&lt;(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tll x;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(x)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(x &lt; (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>))) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\tx-= (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t\t\t\tans += (<span class=\"number\">1ll</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e-奏绝_牛客小白月赛93-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82401/E\">E-奏绝_牛客小白月赛93\r\n(nowcoder.com)</a></h2>\r\n<h3 id=\"题意-1\"><strong>题意：</strong></h3>\r\n<p>你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。</p>\r\n<p>对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为\r\n0。</p>\r\n<p>区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。</p>\r\n<p>对于 m\r\n次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对\r\n998244353 取模。</p>\r\n<p><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82821/E\">E-奏绝_牛客小白月赛93（重现赛）</a></p>\r\n<h3 id=\"题解-1\"><strong>题解</strong></h3>\r\n<p><strong>不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积</strong></p>\r\n<p>奏绝，我直接肘击！</p>\r\n<p>题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y, id;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> Node&amp; x,<span class=\"type\">const</span> Node&amp; y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x.x/ blk != y.x /blk) <span class=\"keyword\">return</span> x.x/blk &lt; y.x/blk;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x.x != y.x) <span class=\"keyword\">return</span> x.x &lt; y.x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x.y &lt; y.y;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tsum1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>) * c;</span><br><span class=\"line\">\tsum2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>) * c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateL</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum2 - x * cnt2) * c% MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum1 - x * cnt1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;!&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateR</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt1 - sum1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt2 - sum2) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":915,"excerpt":"","more":"<h2 id=\"d-幻兽帕鲁_牛客小白月赛93-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82401/D\">D-幻兽帕鲁_牛客小白月赛93\r\n(nowcoder.com)</a></h2>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。</p>\r\n<p>你有 <span class=\"math display\">\\[2^n\\]</span>\r\n只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 <span\r\nclass=\"math display\">\\[[0,2^n-1]\\]</span> 工号的顺序排成一队。</p>\r\n<p>当我们对区间 <span class=\"math display\">\\[[l,r]\\]</span>\r\n的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 <span\r\nclass=\"math display\">\\[[0,r-l]\\]</span> ，记 <span\r\nclass=\"math display\">\\[mid = \\lfloor\\frac{l +\r\nr}{2}\\rfloor\\]</span>，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间\r\n<span class=\"math display\">\\[[l,mid]\\]</span> 和 <span\r\nclass=\"math display\">\\[[mid + 1,r]\\]</span>\r\n，并递归对这两个区间进行上述操作，直到区间长度为 <span\r\nclass=\"math inline\">\\(1\\)</span> 。</p>\r\n<p>现在我们对 <span class=\"math display\">\\[[0,2^n-1]\\]</span>\r\n的幻兽进行一次操作，然后给你 <span class=\"math inline\">\\(m\\)</span>\r\n次询问，每次询问 <span class=\"math inline\">\\(x\\)</span>​\r\n位置的帕鲁工号是多少？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。</p>\r\n<p>于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1&lt;&lt;(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tll x;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(x)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(x &lt; (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>))) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\tx-= (<span class=\"number\">1ll</span>&lt;&lt;(n-i<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t\t\t\tans += (<span class=\"number\">1ll</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e-奏绝_牛客小白月赛93-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82401/E\">E-奏绝_牛客小白月赛93\r\n(nowcoder.com)</a></h2>\r\n<h3 id=\"题意-1\"><strong>题意：</strong></h3>\r\n<p>你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。</p>\r\n<p>对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为\r\n0。</p>\r\n<p>区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。</p>\r\n<p>对于 m\r\n次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对\r\n998244353 取模。</p>\r\n<p><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82821/E\">E-奏绝_牛客小白月赛93（重现赛）</a></p>\r\n<h3 id=\"题解-1\"><strong>题解</strong></h3>\r\n<p><strong>不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积</strong></p>\r\n<p>奏绝，我直接肘击！</p>\r\n<p>题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y, id;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> Node&amp; x,<span class=\"type\">const</span> Node&amp; y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x.x/ blk != y.x /blk) <span class=\"keyword\">return</span> x.x/blk &lt; y.x/blk;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x.x != y.x) <span class=\"keyword\">return</span> x.x &lt; y.x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x.y &lt; y.y;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tsum1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt1 += (s[x] == <span class=\"string\">&#x27;1&#x27;</span>) * c;</span><br><span class=\"line\">\tsum2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>? x: <span class=\"number\">0</span>) * c;</span><br><span class=\"line\">\tcnt2 += (s[x] == <span class=\"string\">&#x27;0&#x27;</span>) * c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateL</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum2 - x * cnt2) * c% MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (sum1 - x * cnt1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;!&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateR</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt1 - sum1) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[x] == <span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tans += (x * cnt2 - sum2) * c % MOD;</span><br><span class=\"line\">\t\tans = (ans + MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;&quot;#&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"Xiaobai94","date":"2024-08-14T11:46:31.000Z","_content":"\n## [B-小苯的好数组_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/B)\n\n### 题意\n\n大白熊给了小苯一个长度为 $n$ 的数组 $a$，这次他希望小苯从数组中选择一个**子序列**（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。  \n\n大白熊定义好数组是：如果一个数组按升序排序后和原来**不完全相同**，则其是一个好数组。例如 $[3,2,2]$ 升序排序后是 $[2, 2, 3]$，和原来不完全相同，因此**是**一个好数组，而 $[1,2,2]$ **不是**一个好数组。\n\n  \n\n小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？\n\n### 题解\n\n误入签到，答案只有0和n两种，很好判断\n\n```cpp\nvoid slove() {\n\tvector<int> ve;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tint x;cin>>x;\n\t\tve.pb(x);\n\t}\n\tint ls = 0,flag = 0;\n\tfor(int v:ve){\n\t\tif(v < ls)flag = 1;\n\t\tls = max(v,ls);\n\t}\n\tif(flag) cout<<n<<endl;\n\telse cout<<0<<endl;\n}\n```\n\n## [C-小苯的数字合并_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/C)\n\n### 题意\n\n大白熊给了小苯一个长度为 $$n$$ 的数组 $$a$$，小苯想要**最大化** $$a$$ 的极差。\n\n具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：  \n\n  \n\n$\\bullet$ 选择一个正整数 $$i \\ (1 \\leq i <n)$$，接着将 $$a_i$$ 与 $$a_{i+1}$$ 合并为一个数字，结果为二者的和。\n\n（即：将 $$a_i$$ 变为 $$a_i + a_{i+1}$$，然后删去 $$a_{i+1}$$，当然操作完后 $a$ 的长度也会减一。）\n\n\n小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。\n\n### 题解\n\n注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++)\n\t\tpre[i] = pre[i-1] + a[i];\n\n\tfor(int i=n;i;i--)\n\t\trep[i] = rep[i+1] + a[i];\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = max(pre[i-1] ,rep[i+1]);\n\t\tans = max(ans,mx - a[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## [D-小苯的排列构造_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/D)\n\n### 题意\n\n格格有一个长度为 $$n$$ 的排列 $$p$$，但她不记得 $$p$$ 具体的样子，她只记得数组 $$a$$。  \n其中：$$a_i = gcd(p_1, p_2,...,p_i)$$，也就是说，$$a_i$$ 表示排列 $$p$$ 中前 $$i$$ 个数字的最大公约数。  \n\n\n现在，她希望小苯将排列 $$p$$ 复原出来，请你帮帮他吧。\n\n（但有可能无解，这意味着格格给出的 $$a$$ 数组可能是不正确的，此时输出 $$-1$$ 即可。）\n\n### 题解\n\n公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。\n\n如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。\n\n如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可\n\n注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\n\tint f = 1;\n\tfor(int i = 1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tif(i > 1 && a[i-1] % a[i] != 0) f = 0;\n\t}\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tint c = 1, s = a[i];\n\t\twhile(i < n && a[i+1] == a[i])i ++,c ++;\n\t\tint t = s;\n\t\twhile(c && t <= n) {\n\t\t\twhile(st[t]) t+=s;\n\t\t\tif(t > n) break;\n\t\t\tves.push_back(t);\n\t\t\tst[t] = 1;\n\t\t\t// cout<<t<<endl;\n\t\t\tt+=s,c--;\n\t\t}\n\t\tif(c) {f = 0;break;}\n\t}\n\n\tif(!f) {cout<<-1<<endl; return ;}\n\n\tfor(int v: ves) cout<<v<<' ';\n\t\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [E-小苯的01背包（easy）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/E)\n\n##[F-小苯的01背包（hard）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/F)\n\n### 题意\n\n**注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。**  \n\n\n小苯有一个容量为 $k$ 的背包，现在有 $n$ 个物品，每个物品有一个体积 $v$ 和价值 $w$，他想知道在体积不超过 $k$ 的前提下，他最多能装价值为多少的物品。\n\n本问题中，物品的总体积定义为所装物品的体积的 $\\&$（按位与），总价值也定义为所装物品的价值的 $\\&$（按位与）。\n\n（如果不选物品，则价值为 0，所占体积也为 0。）\n\n### 题解\n\n按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）\n\n比如对于二进制下物品价值\n\n```\n101101\n110010\n101011\n110110\n```\n\n不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。\n\n构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑$$O(n\\times 4e3)$$即可，注意初始状态为(1<<14)-1，但是这样跑出来是过93%，哪里有问题？\n\n一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。\n\n官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\n\tfor(int i=1;i<=n;i++) cin>>v[i]>>w[i];\n\n\tint ans = 0;\n    for (int i = 0; i <= 2000; i++) {\n        int V = (1 << 20) - 1;\n        for (int j = 1; j <= n; j++) {\n            if ((i & w[j]) == i) {\n                V &= v[j];\n            }\n        }\n        if (V <= k)\n            ans = max(ans, i);\n    }\n    cout<<ans<<endl;\n}\n```\n\n不得不说这个写法更简洁也更正确\n\nhard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。\n\n```cpp\nvoid slove() {\n\tint i, j, k;\n     \n    cin >> n >> k;\n     \n    for (i = 1; i <= n; i++) {\n        cin >> w[i] >> v[i];\n        q[0].push({w[i], v[i]});\n    }\n    int ans = 0;\n    for (i = 30; i >= 0; i--) {\n        int ww = 0x7fffffff;\n        int now = q[0].size();\n        for (j = 0; j < now; j++) {\n            auto x = q[0].front();\n            q[0].pop();\n            if ((x.y >> i) & 1) {\n                q[1].push(x);\n                ww &= x.x;\n            } else {\n                q[0].push(x);\n            }\n        }\n         \n        if (ww <= k) {\n            ans |= (1 << i);\n            while (!q[0].empty()) {\n                q[0].pop();\n            }\n        }\n        while (!q[1].empty()) {\n            q[0].push(q[1].front());\n            q[1].pop();\n        }\n    }\n    cout << ans << endl;\n}\n```\n\n","source":"_posts/Xiaobai94.md","raw":"title: Xiaobai94\ndate: 2024-08-14 19:46:31\ntags: [newcoder]\ncategories: \n\t- 比赛\n\t- 日常赛\n\t- newcoder\n---\n\n## [B-小苯的好数组_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/B)\n\n### 题意\n\n大白熊给了小苯一个长度为 $n$ 的数组 $a$，这次他希望小苯从数组中选择一个**子序列**（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。  \n\n大白熊定义好数组是：如果一个数组按升序排序后和原来**不完全相同**，则其是一个好数组。例如 $[3,2,2]$ 升序排序后是 $[2, 2, 3]$，和原来不完全相同，因此**是**一个好数组，而 $[1,2,2]$ **不是**一个好数组。\n\n  \n\n小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？\n\n### 题解\n\n误入签到，答案只有0和n两种，很好判断\n\n```cpp\nvoid slove() {\n\tvector<int> ve;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tint x;cin>>x;\n\t\tve.pb(x);\n\t}\n\tint ls = 0,flag = 0;\n\tfor(int v:ve){\n\t\tif(v < ls)flag = 1;\n\t\tls = max(v,ls);\n\t}\n\tif(flag) cout<<n<<endl;\n\telse cout<<0<<endl;\n}\n```\n\n## [C-小苯的数字合并_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/C)\n\n### 题意\n\n大白熊给了小苯一个长度为 $$n$$ 的数组 $$a$$，小苯想要**最大化** $$a$$ 的极差。\n\n具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：  \n\n  \n\n$\\bullet$ 选择一个正整数 $$i \\ (1 \\leq i <n)$$，接着将 $$a_i$$ 与 $$a_{i+1}$$ 合并为一个数字，结果为二者的和。\n\n（即：将 $$a_i$$ 变为 $$a_i + a_{i+1}$$，然后删去 $$a_{i+1}$$，当然操作完后 $a$ 的长度也会减一。）\n\n\n小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。\n\n### 题解\n\n注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tfor(int i=1;i<=n;i++)\n\t\tpre[i] = pre[i-1] + a[i];\n\n\tfor(int i=n;i;i--)\n\t\trep[i] = rep[i+1] + a[i];\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = max(pre[i-1] ,rep[i+1]);\n\t\tans = max(ans,mx - a[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## [D-小苯的排列构造_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/D)\n\n### 题意\n\n格格有一个长度为 $$n$$ 的排列 $$p$$，但她不记得 $$p$$ 具体的样子，她只记得数组 $$a$$。  \n其中：$$a_i = gcd(p_1, p_2,...,p_i)$$，也就是说，$$a_i$$ 表示排列 $$p$$ 中前 $$i$$ 个数字的最大公约数。  \n\n\n现在，她希望小苯将排列 $$p$$ 复原出来，请你帮帮他吧。\n\n（但有可能无解，这意味着格格给出的 $$a$$ 数组可能是不正确的，此时输出 $$-1$$ 即可。）\n\n### 题解\n\n公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。\n\n如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。\n\n如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可\n\n注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\n\tint f = 1;\n\tfor(int i = 1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tif(i > 1 && a[i-1] % a[i] != 0) f = 0;\n\t}\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tint c = 1, s = a[i];\n\t\twhile(i < n && a[i+1] == a[i])i ++,c ++;\n\t\tint t = s;\n\t\twhile(c && t <= n) {\n\t\t\twhile(st[t]) t+=s;\n\t\t\tif(t > n) break;\n\t\t\tves.push_back(t);\n\t\t\tst[t] = 1;\n\t\t\t// cout<<t<<endl;\n\t\t\tt+=s,c--;\n\t\t}\n\t\tif(c) {f = 0;break;}\n\t}\n\n\tif(!f) {cout<<-1<<endl; return ;}\n\n\tfor(int v: ves) cout<<v<<' ';\n\t\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [E-小苯的01背包（easy）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/E)\n\n##[F-小苯的01背包（hard）_牛客小白月赛94 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/82957/F)\n\n### 题意\n\n**注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。**  \n\n\n小苯有一个容量为 $k$ 的背包，现在有 $n$ 个物品，每个物品有一个体积 $v$ 和价值 $w$，他想知道在体积不超过 $k$ 的前提下，他最多能装价值为多少的物品。\n\n本问题中，物品的总体积定义为所装物品的体积的 $\\&$（按位与），总价值也定义为所装物品的价值的 $\\&$（按位与）。\n\n（如果不选物品，则价值为 0，所占体积也为 0。）\n\n### 题解\n\n按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）\n\n比如对于二进制下物品价值\n\n```\n101101\n110010\n101011\n110110\n```\n\n不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。\n\n构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑$$O(n\\times 4e3)$$即可，注意初始状态为(1<<14)-1，但是这样跑出来是过93%，哪里有问题？\n\n一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。\n\n官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k\n\n```cpp\nvoid slove() {\n\tcin>>n>>k;\n\n\tfor(int i=1;i<=n;i++) cin>>v[i]>>w[i];\n\n\tint ans = 0;\n    for (int i = 0; i <= 2000; i++) {\n        int V = (1 << 20) - 1;\n        for (int j = 1; j <= n; j++) {\n            if ((i & w[j]) == i) {\n                V &= v[j];\n            }\n        }\n        if (V <= k)\n            ans = max(ans, i);\n    }\n    cout<<ans<<endl;\n}\n```\n\n不得不说这个写法更简洁也更正确\n\nhard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。\n\n```cpp\nvoid slove() {\n\tint i, j, k;\n     \n    cin >> n >> k;\n     \n    for (i = 1; i <= n; i++) {\n        cin >> w[i] >> v[i];\n        q[0].push({w[i], v[i]});\n    }\n    int ans = 0;\n    for (i = 30; i >= 0; i--) {\n        int ww = 0x7fffffff;\n        int now = q[0].size();\n        for (j = 0; j < now; j++) {\n            auto x = q[0].front();\n            q[0].pop();\n            if ((x.y >> i) & 1) {\n                q[1].push(x);\n                ww &= x.x;\n            } else {\n                q[0].push(x);\n            }\n        }\n         \n        if (ww <= k) {\n            ans |= (1 << i);\n            while (!q[0].empty()) {\n                q[0].pop();\n            }\n        }\n        while (!q[1].empty()) {\n            q[0].push(q[1].front());\n            q[1].pop();\n        }\n    }\n    cout << ans << endl;\n}\n```\n\n","slug":"Xiaobai94","published":1,"updated":"2024-08-15T03:48:13.820Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt8000swwwv1cdaf0ij","content":"<h2 id=\"b-小苯的好数组_牛客小白月赛94-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82957/B\">B-小苯的好数组_牛客小白月赛94\r\n(nowcoder.com)</a></h2>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>大白熊给了小苯一个长度为 <span class=\"math inline\">\\(n\\)</span>\r\n的数组 <span\r\nclass=\"math inline\">\\(a\\)</span>，这次他希望小苯从数组中选择一个<strong>子序列</strong>（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。</p>\r\n<p>大白熊定义好数组是：如果一个数组按升序排序后和原来<strong>不完全相同</strong>，则其是一个好数组。例如\r\n<span class=\"math inline\">\\([3,2,2]\\)</span> 升序排序后是 <span\r\nclass=\"math inline\">\\([2, 2,\r\n3]\\)</span>，和原来不完全相同，因此<strong>是</strong>一个好数组，而\r\n<span class=\"math inline\">\\([1,2,2]\\)</span>\r\n<strong>不是</strong>一个好数组。</p>\r\n<p>小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>误入签到，答案只有0和n两种，很好判断</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ve;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x;cin&gt;&gt;x;</span><br><span class=\"line\">\t\tve.<span class=\"built_in\">pb</span>(x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ls = <span class=\"number\">0</span>,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v:ve)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(v &lt; ls)flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tls = <span class=\"built_in\">max</span>(v,ls);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flag) cout&lt;&lt;n&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"c-小苯的数字合并_牛客小白月赛94-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82957/C\">C-小苯的数字合并_牛客小白月赛94\r\n(nowcoder.com)</a></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>大白熊给了小苯一个长度为 <span class=\"math display\">\\[n\\]</span>\r\n的数组 <span\r\nclass=\"math display\">\\[a\\]</span>，小苯想要<strong>最大化</strong> <span\r\nclass=\"math display\">\\[a\\]</span> 的极差。</p>\r\n<p>具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：</p>\r\n<p><span class=\"math inline\">\\(\\bullet\\)</span> 选择一个正整数 <span\r\nclass=\"math display\">\\[i \\ (1 \\leq i &lt;n)\\]</span>，接着将 <span\r\nclass=\"math display\">\\[a_i\\]</span> 与 <span\r\nclass=\"math display\">\\[a_{i+1}\\]</span>\r\n合并为一个数字，结果为二者的和。</p>\r\n<p>（即：将 <span class=\"math display\">\\[a_i\\]</span> 变为 <span\r\nclass=\"math display\">\\[a_i + a_{i+1}\\]</span>，然后删去 <span\r\nclass=\"math display\">\\[a_{i+1}\\]</span>，当然操作完后 <span\r\nclass=\"math inline\">\\(a\\)</span> 的长度也会减一。）</p>\r\n<p>小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\tpre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\trep[i] = rep[i<span class=\"number\">+1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(pre[i<span class=\"number\">-1</span>] ,rep[i<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\tans = <span class=\"built_in\">max</span>(ans,mx - a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d-小苯的排列构造_牛客小白月赛94-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82957/D\">D-小苯的排列构造_牛客小白月赛94\r\n(nowcoder.com)</a></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>格格有一个长度为 <span class=\"math display\">\\[n\\]</span> 的排列 <span\r\nclass=\"math display\">\\[p\\]</span>，但她不记得 <span\r\nclass=\"math display\">\\[p\\]</span> 具体的样子，她只记得数组 <span\r\nclass=\"math display\">\\[a\\]</span>。<br />\r\n其中：<span class=\"math display\">\\[a_i = gcd(p_1,\r\np_2,...,p_i)\\]</span>，也就是说，<span\r\nclass=\"math display\">\\[a_i\\]</span> 表示排列 <span\r\nclass=\"math display\">\\[p\\]</span> 中前 <span\r\nclass=\"math display\">\\[i\\]</span> 个数字的最大公约数。</p>\r\n<p>现在，她希望小苯将排列 <span class=\"math display\">\\[p\\]</span>\r\n复原出来，请你帮帮他吧。</p>\r\n<p>（但有可能无解，这意味着格格给出的 <span\r\nclass=\"math display\">\\[a\\]</span> 数组可能是不正确的，此时输出 <span\r\nclass=\"math display\">\\[-1\\]</span> 即可。）</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。</p>\r\n<p>如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。</p>\r\n<p>如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可</p>\r\n<p>注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i &gt; <span class=\"number\">1</span> &amp;&amp; a[i<span class=\"number\">-1</span>] % a[i] != <span class=\"number\">0</span>) f = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = <span class=\"number\">1</span>, s = a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; n &amp;&amp; a[i<span class=\"number\">+1</span>] == a[i])i ++,c ++;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(c &amp;&amp; t &lt;= n) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(st[t]) t+=s;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &gt; n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tves.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">\t\t\tst[t] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;t&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tt+=s,c--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c) &#123;f = <span class=\"number\">0</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ves) cout&lt;&lt;v&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e-小苯的01背包easy_牛客小白月赛94-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82957/E\">E-小苯的01背包（easy）_牛客小白月赛94\r\n(nowcoder.com)</a></h2>\r\n<p>##<a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82957/F\">F-小苯的01背包（hard）_牛客小白月赛94\r\n(nowcoder.com)</a></p>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p><strong>注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。</strong></p>\r\n<p>小苯有一个容量为 <span class=\"math inline\">\\(k\\)</span>\r\n的背包，现在有 <span class=\"math inline\">\\(n\\)</span>\r\n个物品，每个物品有一个体积 <span class=\"math inline\">\\(v\\)</span> 和价值\r\n<span class=\"math inline\">\\(w\\)</span>，他想知道在体积不超过 <span\r\nclass=\"math inline\">\\(k\\)</span>\r\n的前提下，他最多能装价值为多少的物品。</p>\r\n<p>本问题中，物品的总体积定义为所装物品的体积的 <span\r\nclass=\"math inline\">\\(\\&amp;\\)</span>（按位与），总价值也定义为所装物品的价值的\r\n<span class=\"math inline\">\\(\\&amp;\\)</span>（按位与）。</p>\r\n<p>（如果不选物品，则价值为 0，所占体积也为 0。）</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）</p>\r\n<p>比如对于二进制下物品价值</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">101101</span><br><span class=\"line\">110010</span><br><span class=\"line\">101011</span><br><span class=\"line\">110110</span><br></pre></td></tr></table></figure>\r\n<p>不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。</p>\r\n<p>构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑<span\r\nclass=\"math display\">\\[O(n\\times\r\n4e3)\\]</span>即可，注意初始状态为(1&lt;&lt;14)-1，但是这样跑出来是过93%，哪里有问题？</p>\r\n<p>一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。</p>\r\n<p>官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">2000</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> V = (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">20</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((i &amp; w[j]) == i) &#123;</span><br><span class=\"line\">                V &amp;= v[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (V &lt;= k)</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>不得不说这个写法更简洁也更正确</p>\r\n<p>hard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, j, k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class=\"line\">        q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(&#123;w[i], v[i]&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ww = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> now = q[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; now; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> x = q[<span class=\"number\">0</span>].<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((x.y &gt;&gt; i) &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">1</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">                ww &amp;= x.x;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ww &lt;= k) &#123;</span><br><span class=\"line\">            ans |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!q[<span class=\"number\">0</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q[<span class=\"number\">1</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(q[<span class=\"number\">1</span>].<span class=\"built_in\">front</span>());</span><br><span class=\"line\">            q[<span class=\"number\">1</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1737,"excerpt":"","more":"<h2 id=\"b-小苯的好数组_牛客小白月赛94-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82957/B\">B-小苯的好数组_牛客小白月赛94\r\n(nowcoder.com)</a></h2>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>大白熊给了小苯一个长度为 <span class=\"math inline\">\\(n\\)</span>\r\n的数组 <span\r\nclass=\"math inline\">\\(a\\)</span>，这次他希望小苯从数组中选择一个<strong>子序列</strong>（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。</p>\r\n<p>大白熊定义好数组是：如果一个数组按升序排序后和原来<strong>不完全相同</strong>，则其是一个好数组。例如\r\n<span class=\"math inline\">\\([3,2,2]\\)</span> 升序排序后是 <span\r\nclass=\"math inline\">\\([2, 2,\r\n3]\\)</span>，和原来不完全相同，因此<strong>是</strong>一个好数组，而\r\n<span class=\"math inline\">\\([1,2,2]\\)</span>\r\n<strong>不是</strong>一个好数组。</p>\r\n<p>小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>误入签到，答案只有0和n两种，很好判断</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ve;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x;cin&gt;&gt;x;</span><br><span class=\"line\">\t\tve.<span class=\"built_in\">pb</span>(x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ls = <span class=\"number\">0</span>,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v:ve)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(v &lt; ls)flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tls = <span class=\"built_in\">max</span>(v,ls);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flag) cout&lt;&lt;n&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"c-小苯的数字合并_牛客小白月赛94-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82957/C\">C-小苯的数字合并_牛客小白月赛94\r\n(nowcoder.com)</a></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>大白熊给了小苯一个长度为 <span class=\"math display\">\\[n\\]</span>\r\n的数组 <span\r\nclass=\"math display\">\\[a\\]</span>，小苯想要<strong>最大化</strong> <span\r\nclass=\"math display\">\\[a\\]</span> 的极差。</p>\r\n<p>具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：</p>\r\n<p><span class=\"math inline\">\\(\\bullet\\)</span> 选择一个正整数 <span\r\nclass=\"math display\">\\[i \\ (1 \\leq i &lt;n)\\]</span>，接着将 <span\r\nclass=\"math display\">\\[a_i\\]</span> 与 <span\r\nclass=\"math display\">\\[a_{i+1}\\]</span>\r\n合并为一个数字，结果为二者的和。</p>\r\n<p>（即：将 <span class=\"math display\">\\[a_i\\]</span> 变为 <span\r\nclass=\"math display\">\\[a_i + a_{i+1}\\]</span>，然后删去 <span\r\nclass=\"math display\">\\[a_{i+1}\\]</span>，当然操作完后 <span\r\nclass=\"math inline\">\\(a\\)</span> 的长度也会减一。）</p>\r\n<p>小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\tpre[i] = pre[i<span class=\"number\">-1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)</span><br><span class=\"line\">\t\trep[i] = rep[i<span class=\"number\">+1</span>] + a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(pre[i<span class=\"number\">-1</span>] ,rep[i<span class=\"number\">+1</span>]);</span><br><span class=\"line\">\t\tans = <span class=\"built_in\">max</span>(ans,mx - a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d-小苯的排列构造_牛客小白月赛94-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82957/D\">D-小苯的排列构造_牛客小白月赛94\r\n(nowcoder.com)</a></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>格格有一个长度为 <span class=\"math display\">\\[n\\]</span> 的排列 <span\r\nclass=\"math display\">\\[p\\]</span>，但她不记得 <span\r\nclass=\"math display\">\\[p\\]</span> 具体的样子，她只记得数组 <span\r\nclass=\"math display\">\\[a\\]</span>。<br />\r\n其中：<span class=\"math display\">\\[a_i = gcd(p_1,\r\np_2,...,p_i)\\]</span>，也就是说，<span\r\nclass=\"math display\">\\[a_i\\]</span> 表示排列 <span\r\nclass=\"math display\">\\[p\\]</span> 中前 <span\r\nclass=\"math display\">\\[i\\]</span> 个数字的最大公约数。</p>\r\n<p>现在，她希望小苯将排列 <span class=\"math display\">\\[p\\]</span>\r\n复原出来，请你帮帮他吧。</p>\r\n<p>（但有可能无解，这意味着格格给出的 <span\r\nclass=\"math display\">\\[a\\]</span> 数组可能是不正确的，此时输出 <span\r\nclass=\"math display\">\\[-1\\]</span> 即可。）</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。</p>\r\n<p>如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。</p>\r\n<p>如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可</p>\r\n<p>注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i &gt; <span class=\"number\">1</span> &amp;&amp; a[i<span class=\"number\">-1</span>] % a[i] != <span class=\"number\">0</span>) f = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = <span class=\"number\">1</span>, s = a[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; n &amp;&amp; a[i<span class=\"number\">+1</span>] == a[i])i ++,c ++;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(c &amp;&amp; t &lt;= n) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(st[t]) t+=s;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(t &gt; n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tves.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">\t\t\tst[t] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;t&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\tt+=s,c--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c) &#123;f = <span class=\"number\">0</span>;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f) &#123;cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ves) cout&lt;&lt;v&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e-小苯的01背包easy_牛客小白月赛94-nowcoder.com\"><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82957/E\">E-小苯的01背包（easy）_牛客小白月赛94\r\n(nowcoder.com)</a></h2>\r\n<p>##<a\r\nhref=\"https://ac.nowcoder.com/acm/contest/82957/F\">F-小苯的01背包（hard）_牛客小白月赛94\r\n(nowcoder.com)</a></p>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p><strong>注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。</strong></p>\r\n<p>小苯有一个容量为 <span class=\"math inline\">\\(k\\)</span>\r\n的背包，现在有 <span class=\"math inline\">\\(n\\)</span>\r\n个物品，每个物品有一个体积 <span class=\"math inline\">\\(v\\)</span> 和价值\r\n<span class=\"math inline\">\\(w\\)</span>，他想知道在体积不超过 <span\r\nclass=\"math inline\">\\(k\\)</span>\r\n的前提下，他最多能装价值为多少的物品。</p>\r\n<p>本问题中，物品的总体积定义为所装物品的体积的 <span\r\nclass=\"math inline\">\\(\\&amp;\\)</span>（按位与），总价值也定义为所装物品的价值的\r\n<span class=\"math inline\">\\(\\&amp;\\)</span>（按位与）。</p>\r\n<p>（如果不选物品，则价值为 0，所占体积也为 0。）</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）</p>\r\n<p>比如对于二进制下物品价值</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">101101</span><br><span class=\"line\">110010</span><br><span class=\"line\">101011</span><br><span class=\"line\">110110</span><br></pre></td></tr></table></figure>\r\n<p>不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。</p>\r\n<p>构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑<span\r\nclass=\"math display\">\\[O(n\\times\r\n4e3)\\]</span>即可，注意初始状态为(1&lt;&lt;14)-1，但是这样跑出来是过93%，哪里有问题？</p>\r\n<p>一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。</p>\r\n<p>官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">2000</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> V = (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">20</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((i &amp; w[j]) == i) &#123;</span><br><span class=\"line\">                V &amp;= v[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (V &lt;= k)</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>不得不说这个写法更简洁也更正确</p>\r\n<p>hard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, j, k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class=\"line\">        q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(&#123;w[i], v[i]&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ww = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> now = q[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; now; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> x = q[<span class=\"number\">0</span>].<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((x.y &gt;&gt; i) &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">1</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">                ww &amp;= x.x;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ww &lt;= k) &#123;</span><br><span class=\"line\">            ans |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!q[<span class=\"number\">0</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                q[<span class=\"number\">0</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q[<span class=\"number\">1</span>].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            q[<span class=\"number\">0</span>].<span class=\"built_in\">push</span>(q[<span class=\"number\">1</span>].<span class=\"built_in\">front</span>());</span><br><span class=\"line\">            q[<span class=\"number\">1</span>].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"abc353","date":"2024-08-14T11:46:31.000Z","_content":"\n[abc353 (atcoder.jp)](https://atcoder.jp/contests/abc353/tasks)\n\n## **C- Sigma Problem**\n\n第一个记录的abcC题\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 为 $$(x + y)$ 除以 $$10^8$ 的余数。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n### 题解\n\n注意题目并非是完全模运算，注意到$N\\times N\\times A_i$刚刚好在longlong 边界上。并且$A_i\\times A_i$ 最多减少一次Mod，我们只需要找出mod1e8的次数即可。\n\n刚刚开始我想的是二分，但实际上对于\n\n```text\n1 50000000 5000000 9999999 9999999 999999 999999 999999 \n```\n\n\n\n这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。\n\n我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。\n\ncode\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint cnt = 0;\n\tfor(int i=1,j=n;i<=n;i++)\n\t{\n\t\twhile(i<j && a[i] + a[j] >= MOD) j--;\n\t\tcnt += min(n-i,n-j);\n\t\t// cout<<i<<' '<<j<<endl;\n\t}\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tsum *= (n-1);\n\t// cout<<sum<<endl;\n\n\tcout<<sum - cnt * MOD<<endl;\n}\n```\n\n## **D - Another Sigma Problem**\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 如下：\n\n- 将 $$x$$ 和 $z$ 的十进制表示解释为字符串，并按此顺序连接，得到字符串 $$z$$ 。将 $$f(x, y)$$ 解释为十进制整数时，其值就是 $$z$$ 的值。\n\n例如， $$f(3, 14) = 314$$ 和 $$f(100, 1) = 1001$$ 。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式取模 $998244353$ 的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n\n### 题解\n\n写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。\n\n下面是代码code\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tint t= a[i].x,s=0;\n\t\twhile(t){\n\t\t\ts++;\n\t\t\tt/=10;\n\t\t}\n\t\ta[i].y = s;\n\t}\n\n\tfor(int i=n;i;i--){\n\t\trep[i] = (rep[i+1] + qmi(10,a[i].y)) % MOD;\n\t\t// cout<<rep[i]<<' '; \n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans = (ans + (rep[i+1] + (i-1)) * a[i].x % MOD) % MOD;\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## **E - Yet Another Sigma Problem**\n\n### 题意\n\n对于字符串 $x$ 和 $y$ ，定义 $$f(x, y)$$ 如下：\n\n- $$f(x, y)$$ 是 $$x$$ 和 $$y$$ 的最长公共前缀的长度。\n\n给你一个由小写英文字母组成的 $N$ 字符串 $$(S_1, \\ldots, S_N)$$ 。求以下表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)$$ .\n\n### 题解\n\n还是注意到同样的$O(N^2)$是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。\n\n很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案\n\n```cpp\nint build(string& s){\n\tint p = 0;\n\tint last = -1 ,res = 0;\n\tfor(int i=0;i<s.size();i++){\n\t\tint ip = s[i] - 'a';\n\t\t// cout<<ip<<endl;\n\t\tif(!son[p][ip]) son[p][ip] = ++idx;\n\t\t// cout<<s<< \"====\"<<last<< ' ' << cnt[son[p][ip]]<<nline;\n\t\tif(last == -1) last = cnt[son[p][ip]];\n\t\tif(cnt[son[p][ip]]!= last){\n\t\t\tres += (last - cnt[son[p][ip]]) * i;\n\t\t\tlast = cnt[son[p][ip]];\n\t\t}\n\t\tcnt[son[p][ip]]++;\n\t\tp = son[p][ip];\n\t}\n\tif(cnt[p]!=1){\n\t\tres +=(cnt[p] - 1)*s.size();\n\t}\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>s[i];\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans += build(s[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## **F - Tile Distance**\n\n### 题意\n\n#### 问题陈述\n\n瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 $$1\\times1$$ 的小瓦片和尺寸为 $$K\\times K$$ 的大瓦片，它们按以下规则摆放：\n\n- 对于每一对整数 $(i,j)$ ，正方形 $$\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge j\\leq y\\leq j+1\\rbrace$$ 要么包含在一块小方砖中，要么包含在一块大方砖中。\n    - 如果 $$\\left\\lfloor\\dfrac iK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor$$ 是偶数，则它包含在一个小方格中。\n    - 否则，它被包含在一个大瓦片中。\n\n瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。\n\n例如，当 $K=3$ 时，瓦片的布局如下：\n\n![](https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png)\n\n高桥开始于坐标平面上的点 $$(S_x+0.5,S_y+0.5)$$ 。\n\n他可以重复下面的动作任意多次：\n\n- 选择一个方向（上、下、左或右）和一个正整数 $$n$$ 。向该方向移动 $n$ 个单位。\n\n每次他从一张牌移动到另一张牌时，必须支付 $1$ 的过路费。\n\n求高桥到达点 $$(T_x+0.5,T_y+0.5)$$​ 所需的最小通行费。\n\n### 题解\n\n首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。\n\n然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。\n\n可以发现，不断走最大瓷砖是最优的。                  \n\n![70275E94F5C12B97C927177CEB804E4C](https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg)\n\n即上图所示的路径是最短的。\n\n显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：\n$$\ndistance = \\frac{d_s-d_a}{k} \\times 2 -1\n$$\n其中定义$$d_s$$为走过直线长度，$$d_a$$ 为两端长度，保证$$d_s - d_a \\equiv k$$​\n\n可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即$$\\frac{2}{k}$$，再减去$$1$$\n\n但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。\n\n根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k>=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。\n\n最后的结果形式上是切比雪夫距离\n\n于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小\n\n```cpp\nvoid slove() {\n\tlong k,sx,sy,tx,ty;\n\tcin>>k;\n\tcin>>sx>>sy;\n\tcin>>tx>>ty;\n\tlong ans=LLINF;\n\tint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\tfor(int i=0;i<4;++i)for(int j=0;j<4;++j)\n\t{\n\t\tlong x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=0;\n\t\tif((x+y)%2==0&&(X+Y)%2==0&&x==X&&y==Y)ans=min(ans,abs(sx-tx)+abs(sy-ty));\n\t\tif((x+y)%2==0)\n\t\t{\n\t\t\tif(dx[i]==-1)c+=sx-x*k+1;\n\t\t\tif(dx[i]==1)c+=k*(long)(x+1)-sx;\n\t\t\tif(dy[i]==-1)c+=sy-y*k+1;\n\t\t\tif(dy[i]==1)c+=k*(long)(y+1)-sy;\n\t\t\tif(k!=1)x+=dx[i],y+=dy[i];\n\t\t}\n\t\tif((X+Y)%2==0)\n\t\t{\n\t\t\tif(dx[j]==-1)c+=tx-X*k+1;\n\t\t\tif(dx[j]==1)c+=k*(long)(X+1)-tx;\n\t\t\tif(dy[j]==-1)c+=ty-Y*k+1;\n\t\t\tif(dy[j]==1)c+=k*(long)(Y+1)-ty;\n\t\t\tif(k!=1)X+=dx[j],Y+=dy[j];\n\t\t}\n\t\tif(k==1)c=abs(x-X)+abs(y-Y);\n\t\telse if(k==2)\n\t\t{\n\t\t\tlong d=min(abs(x-X),abs(y-Y));\n\t\t\tc+=d*(long)2;\n\t\t\tc+=(abs(x-X)-d)*(long)3/(long)2;\n\t\t\tc+=(abs(y-Y)-d)*(long)3/(long)2;\n\t\t}\n\t\telse c+=max(abs(x-X),abs(y-Y))*(long)2;\n\t\tans=min(ans,c);\n\t}\n\tcout<<ans;\n}\n```\n\n## **G - Merchant Takahashi**\n\n### 题意\n\nAtCoder 王国有 $N$ 个城镇：城镇 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。从 $i$ 镇到 $j$ 镇，必须支付 $C \\times |i-j|$ 日元的过路费。\n\n商人高桥正在考虑参加 $M$ 个或更多即将到来的市场。\n\n$i$ /-市场 $$(1 \\leq i \\leq M)$$ 由一对整数 $$(T_i, P_i)$$ 描述，其中市场在城镇 $$T_i$$ 举行，如果他参加将赚取 $$P_i$$ 日元。\n\n对于所有 $$1 \\leq i < M$$ ， $$i$$ 次市场在 $$(i+1)$$ 次市场开始之前结束。他移动的时间可以忽略不计。\n\n他从 $$10^{10^{100}}$$ 日元开始，最初在 $$1$$ 镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。\n\n形式上，如果他在 $$M$$ 个市场后获得最大资金额，那么 $$10^{10^{100}} + X$$ 就是他的最终资金额。求 $$X$$ 。\n\n### 题解\n\n显然的dp问题，如果你看不出来这是个dp问题建议你看一看[再看最著名的 NP 问题之 TSP 旅行商问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/659884622)，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。\n\n详细到这一题，很简单的状态表示为\n$$\nf_i:到i城的最大profit\n$$\n状态转移为：\n$$\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}\n$$\n对绝对值正负进行分类\n$$\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}\n$$\n提出取最大中的常数项：\n$$\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C\n$$\n接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。\n\n```cpp\n\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = -LLINF; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = -LLINF,ri = -LLINF;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>c;\n\tcin>>m;\n\tbuild(1,n,1,tr1);\n\tbuild(1,n,1,tr2);\n\n\tmodify(1,c,1,tr1);\n\tmodify(1,-c,1,tr2);\n\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>t[i]>>p[i];\n\t\tint l = query(1,t[i],1,tr1);\n\t\tint r = query(t[i],n,1,tr2);\n\t\t// cout<<l<<' '<<r<<endl;\n\t\tint mx = max(l+p[i]-t[i]*c,r+p[i]+t[i]*c);\n\t\tf[t[i]] = mx;\n\t\t// cout<<t[i]<< ' ' <<f[t[i]]<<nline;\n\t\tmodify(t[i],f[t[i]] + t[i] * c,1,tr1);\n\t\tmodify(t[i],f[t[i]] - t[i] * c,1,tr2);\n\t}\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) ans =max(ans,f[i]);\n\n\tcout<<ans<<endl;\n\treturn ;\n}\n```\n\n","source":"_posts/abc353.md","raw":"---\ntitle: abc353\ndate: 2024-08-14 19:46:31\ntags: [算法, 思维题, 模运算]\ncategories: \n\t- 算法\n\t- 思维题\n\t- 模运算\n---\n\n[abc353 (atcoder.jp)](https://atcoder.jp/contests/abc353/tasks)\n\n## **C- Sigma Problem**\n\n第一个记录的abcC题\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 为 $$(x + y)$ 除以 $$10^8$ 的余数。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n### 题解\n\n注意题目并非是完全模运算，注意到$N\\times N\\times A_i$刚刚好在longlong 边界上。并且$A_i\\times A_i$ 最多减少一次Mod，我们只需要找出mod1e8的次数即可。\n\n刚刚开始我想的是二分，但实际上对于\n\n```text\n1 50000000 5000000 9999999 9999999 999999 999999 999999 \n```\n\n\n\n这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。\n\n我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。\n\ncode\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a+1,a+1+n);\n\n\tint cnt = 0;\n\tfor(int i=1,j=n;i<=n;i++)\n\t{\n\t\twhile(i<j && a[i] + a[j] >= MOD) j--;\n\t\tcnt += min(n-i,n-j);\n\t\t// cout<<i<<' '<<j<<endl;\n\t}\n\n\tll sum = 0;\n\tfor(int i=1;i<=n;i++) sum += a[i];\n\n\tsum *= (n-1);\n\t// cout<<sum<<endl;\n\n\tcout<<sum - cnt * MOD<<endl;\n}\n```\n\n## **D - Another Sigma Problem**\n\n### 题意\n\n对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 如下：\n\n- 将 $$x$$ 和 $z$ 的十进制表示解释为字符串，并按此顺序连接，得到字符串 $$z$$ 。将 $$f(x, y)$$ 解释为十进制整数时，其值就是 $$z$$ 的值。\n\n例如， $$f(3, 14) = 314$$ 和 $$f(100, 1) = 1001$$ 。\n\n给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \\ldots, A_N)$$ 。求下面表达式取模 $998244353$ 的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)$$​ .\n\n### 题解\n\n写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。\n\n下面是代码code\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i].x;\n\t\tint t= a[i].x,s=0;\n\t\twhile(t){\n\t\t\ts++;\n\t\t\tt/=10;\n\t\t}\n\t\ta[i].y = s;\n\t}\n\n\tfor(int i=n;i;i--){\n\t\trep[i] = (rep[i+1] + qmi(10,a[i].y)) % MOD;\n\t\t// cout<<rep[i]<<' '; \n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans = (ans + (rep[i+1] + (i-1)) * a[i].x % MOD) % MOD;\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## **E - Yet Another Sigma Problem**\n\n### 题意\n\n对于字符串 $x$ 和 $y$ ，定义 $$f(x, y)$$ 如下：\n\n- $$f(x, y)$$ 是 $$x$$ 和 $$y$$ 的最长公共前缀的长度。\n\n给你一个由小写英文字母组成的 $N$ 字符串 $$(S_1, \\ldots, S_N)$$ 。求以下表达式的值：\n\n$$\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)$$ .\n\n### 题解\n\n还是注意到同样的$O(N^2)$是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。\n\n很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案\n\n```cpp\nint build(string& s){\n\tint p = 0;\n\tint last = -1 ,res = 0;\n\tfor(int i=0;i<s.size();i++){\n\t\tint ip = s[i] - 'a';\n\t\t// cout<<ip<<endl;\n\t\tif(!son[p][ip]) son[p][ip] = ++idx;\n\t\t// cout<<s<< \"====\"<<last<< ' ' << cnt[son[p][ip]]<<nline;\n\t\tif(last == -1) last = cnt[son[p][ip]];\n\t\tif(cnt[son[p][ip]]!= last){\n\t\t\tres += (last - cnt[son[p][ip]]) * i;\n\t\t\tlast = cnt[son[p][ip]];\n\t\t}\n\t\tcnt[son[p][ip]]++;\n\t\tp = son[p][ip];\n\t}\n\tif(cnt[p]!=1){\n\t\tres +=(cnt[p] - 1)*s.size();\n\t}\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>s[i];\n\t}\n\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tans += build(s[i]);\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## **F - Tile Distance**\n\n### 题意\n\n#### 问题陈述\n\n瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 $$1\\times1$$ 的小瓦片和尺寸为 $$K\\times K$$ 的大瓦片，它们按以下规则摆放：\n\n- 对于每一对整数 $(i,j)$ ，正方形 $$\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge j\\leq y\\leq j+1\\rbrace$$ 要么包含在一块小方砖中，要么包含在一块大方砖中。\n    - 如果 $$\\left\\lfloor\\dfrac iK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor$$ 是偶数，则它包含在一个小方格中。\n    - 否则，它被包含在一个大瓦片中。\n\n瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。\n\n例如，当 $K=3$ 时，瓦片的布局如下：\n\n![](https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png)\n\n高桥开始于坐标平面上的点 $$(S_x+0.5,S_y+0.5)$$ 。\n\n他可以重复下面的动作任意多次：\n\n- 选择一个方向（上、下、左或右）和一个正整数 $$n$$ 。向该方向移动 $n$ 个单位。\n\n每次他从一张牌移动到另一张牌时，必须支付 $1$ 的过路费。\n\n求高桥到达点 $$(T_x+0.5,T_y+0.5)$$​ 所需的最小通行费。\n\n### 题解\n\n首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。\n\n然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。\n\n可以发现，不断走最大瓷砖是最优的。                  \n\n![70275E94F5C12B97C927177CEB804E4C](https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg)\n\n即上图所示的路径是最短的。\n\n显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：\n$$\ndistance = \\frac{d_s-d_a}{k} \\times 2 -1\n$$\n其中定义$$d_s$$为走过直线长度，$$d_a$$ 为两端长度，保证$$d_s - d_a \\equiv k$$​\n\n可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即$$\\frac{2}{k}$$，再减去$$1$$\n\n但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。\n\n根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k>=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。\n\n最后的结果形式上是切比雪夫距离\n\n于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小\n\n```cpp\nvoid slove() {\n\tlong k,sx,sy,tx,ty;\n\tcin>>k;\n\tcin>>sx>>sy;\n\tcin>>tx>>ty;\n\tlong ans=LLINF;\n\tint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\tfor(int i=0;i<4;++i)for(int j=0;j<4;++j)\n\t{\n\t\tlong x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=0;\n\t\tif((x+y)%2==0&&(X+Y)%2==0&&x==X&&y==Y)ans=min(ans,abs(sx-tx)+abs(sy-ty));\n\t\tif((x+y)%2==0)\n\t\t{\n\t\t\tif(dx[i]==-1)c+=sx-x*k+1;\n\t\t\tif(dx[i]==1)c+=k*(long)(x+1)-sx;\n\t\t\tif(dy[i]==-1)c+=sy-y*k+1;\n\t\t\tif(dy[i]==1)c+=k*(long)(y+1)-sy;\n\t\t\tif(k!=1)x+=dx[i],y+=dy[i];\n\t\t}\n\t\tif((X+Y)%2==0)\n\t\t{\n\t\t\tif(dx[j]==-1)c+=tx-X*k+1;\n\t\t\tif(dx[j]==1)c+=k*(long)(X+1)-tx;\n\t\t\tif(dy[j]==-1)c+=ty-Y*k+1;\n\t\t\tif(dy[j]==1)c+=k*(long)(Y+1)-ty;\n\t\t\tif(k!=1)X+=dx[j],Y+=dy[j];\n\t\t}\n\t\tif(k==1)c=abs(x-X)+abs(y-Y);\n\t\telse if(k==2)\n\t\t{\n\t\t\tlong d=min(abs(x-X),abs(y-Y));\n\t\t\tc+=d*(long)2;\n\t\t\tc+=(abs(x-X)-d)*(long)3/(long)2;\n\t\t\tc+=(abs(y-Y)-d)*(long)3/(long)2;\n\t\t}\n\t\telse c+=max(abs(x-X),abs(y-Y))*(long)2;\n\t\tans=min(ans,c);\n\t}\n\tcout<<ans;\n}\n```\n\n## **G - Merchant Takahashi**\n\n### 题意\n\nAtCoder 王国有 $N$ 个城镇：城镇 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。从 $i$ 镇到 $j$ 镇，必须支付 $C \\times |i-j|$ 日元的过路费。\n\n商人高桥正在考虑参加 $M$ 个或更多即将到来的市场。\n\n$i$ /-市场 $$(1 \\leq i \\leq M)$$ 由一对整数 $$(T_i, P_i)$$ 描述，其中市场在城镇 $$T_i$$ 举行，如果他参加将赚取 $$P_i$$ 日元。\n\n对于所有 $$1 \\leq i < M$$ ， $$i$$ 次市场在 $$(i+1)$$ 次市场开始之前结束。他移动的时间可以忽略不计。\n\n他从 $$10^{10^{100}}$$ 日元开始，最初在 $$1$$ 镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。\n\n形式上，如果他在 $$M$$ 个市场后获得最大资金额，那么 $$10^{10^{100}} + X$$ 就是他的最终资金额。求 $$X$$ 。\n\n### 题解\n\n显然的dp问题，如果你看不出来这是个dp问题建议你看一看[再看最著名的 NP 问题之 TSP 旅行商问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/659884622)，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。\n\n详细到这一题，很简单的状态表示为\n$$\nf_i:到i城的最大profit\n$$\n状态转移为：\n$$\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}\n$$\n对绝对值正负进行分类\n$$\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}\n$$\n提出取最大中的常数项：\n$$\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C\n$$\n接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。\n\n```cpp\n\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = -LLINF; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = -LLINF,ri = -LLINF;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>c;\n\tcin>>m;\n\tbuild(1,n,1,tr1);\n\tbuild(1,n,1,tr2);\n\n\tmodify(1,c,1,tr1);\n\tmodify(1,-c,1,tr2);\n\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>t[i]>>p[i];\n\t\tint l = query(1,t[i],1,tr1);\n\t\tint r = query(t[i],n,1,tr2);\n\t\t// cout<<l<<' '<<r<<endl;\n\t\tint mx = max(l+p[i]-t[i]*c,r+p[i]+t[i]*c);\n\t\tf[t[i]] = mx;\n\t\t// cout<<t[i]<< ' ' <<f[t[i]]<<nline;\n\t\tmodify(t[i],f[t[i]] + t[i] * c,1,tr1);\n\t\tmodify(t[i],f[t[i]] - t[i] * c,1,tr2);\n\t}\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) ans =max(ans,f[i]);\n\n\tcout<<ans<<endl;\n\treturn ;\n}\n```\n\n","slug":"abc353","published":1,"updated":"2024-08-15T03:48:41.734Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt8000vwwwv9e641ysw","content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1My90YXNrcw==\">abc353\r\n(atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h2 id=\"c--sigma-problem\"><strong>C- Sigma Problem</strong></h2>\r\n<p>第一个记录的abcC题</p>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>对于正整数 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 为 <span\r\nclass=\"math display\">\\[(x + y)$ 除以 \\]</span>10^8$ 的余数。</p>\r\n<p>给你一个长度为 <span class=\"math inline\">\\(N\\)</span> 的正整数序列\r\n<span class=\"math display\">\\[A = (A_1, \\ldots, A_N)\\]</span>\r\n。求下面表达式的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)\\]</span>​ . ### 题解</p>\r\n<p>注意题目并非是完全模运算，注意到<span class=\"math inline\">\\(N\\times\r\nN\\times A_i\\)</span>刚刚好在longlong 边界上。并且<span\r\nclass=\"math inline\">\\(A_i\\times A_i\\)</span>\r\n最多减少一次Mod，我们只需要找出mod1e8的次数即可。</p>\r\n<p>刚刚开始我想的是二分，但实际上对于</p>\r\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 50000000 5000000 9999999 9999999 999999 999999 999999 </span><br></pre></td></tr></table></figure>\r\n<p>这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。</p>\r\n<p>我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。</p>\r\n<p>code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=n;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i&lt;j &amp;&amp; a[i] + a[j] &gt;= MOD) j--;</span><br><span class=\"line\">\t\tcnt += <span class=\"built_in\">min</span>(n-i,n-j);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tsum *= (n<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum - cnt * MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d---another-sigma-problem\"><strong>D - Another Sigma\r\nProblem</strong></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>对于正整数 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 如下：</p>\r\n<ul>\r\n<li>将 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span>\r\n的十进制表示解释为字符串，并按此顺序连接，得到字符串 <span\r\nclass=\"math display\">\\[z\\]</span> 。将 <span class=\"math display\">\\[f(x,\r\ny)\\]</span> 解释为十进制整数时，其值就是 <span\r\nclass=\"math display\">\\[z\\]</span> 的值。</li>\r\n</ul>\r\n<p>例如， <span class=\"math display\">\\[f(3, 14) = 314\\]</span> 和 <span\r\nclass=\"math display\">\\[f(100, 1) = 1001\\]</span> 。</p>\r\n<p>给你一个长度为 <span class=\"math inline\">\\(N\\)</span> 的正整数序列\r\n<span class=\"math display\">\\[A = (A_1, \\ldots, A_N)\\]</span>\r\n。求下面表达式取模 <span class=\"math inline\">\\(998244353\\)</span>\r\n的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)\\]</span>​ .</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。</p>\r\n<p>下面是代码code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t= a[i].x,s=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(t)&#123;</span><br><span class=\"line\">\t\t\ts++;</span><br><span class=\"line\">\t\t\tt/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ta[i].y = s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\trep[i] = (rep[i<span class=\"number\">+1</span>] + <span class=\"built_in\">qmi</span>(<span class=\"number\">10</span>,a[i].y)) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;rep[i]&lt;&lt;&#x27; &#x27;; </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans = (ans + (rep[i<span class=\"number\">+1</span>] + (i<span class=\"number\">-1</span>)) * a[i].x % MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e---yet-another-sigma-problem\"><strong>E - Yet Another Sigma\r\nProblem</strong></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>对于字符串 <span class=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(y\\)</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 如下：</p>\r\n<ul>\r\n<li><span class=\"math display\">\\[f(x, y)\\]</span> 是 <span\r\nclass=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> 的最长公共前缀的长度。</li>\r\n</ul>\r\n<p>给你一个由小写英文字母组成的 <span class=\"math inline\">\\(N\\)</span>\r\n字符串 <span class=\"math display\">\\[(S_1, \\ldots, S_N)\\]</span>\r\n。求以下表达式的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)\\]</span> .</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>还是注意到同样的<span\r\nclass=\"math inline\">\\(O(N^2)\\)</span>是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。</p>\r\n<p>很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">build</span><span class=\"params\">(string&amp; s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> last = <span class=\"number\">-1</span> ,res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ip = s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ip&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!son[p][ip]) son[p][ip] = ++idx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;s&lt;&lt; &quot;====&quot;&lt;&lt;last&lt;&lt; &#x27; &#x27; &lt;&lt; cnt[son[p][ip]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(last == <span class=\"number\">-1</span>) last = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt[son[p][ip]]!= last)&#123;</span><br><span class=\"line\">\t\t\tres += (last - cnt[son[p][ip]]) * i;</span><br><span class=\"line\">\t\t\tlast = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt[son[p][ip]]++;</span><br><span class=\"line\">\t\tp = son[p][ip];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(cnt[p]!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tres +=(cnt[p] - <span class=\"number\">1</span>)*s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;s[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans += <span class=\"built_in\">build</span>(s[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f---tile-distance\"><strong>F - Tile Distance</strong></h2>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<h4 id=\"问题陈述\">问题陈述</h4>\r\n<p>瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 <span\r\nclass=\"math display\">\\[1\\times1\\]</span> 的小瓦片和尺寸为 <span\r\nclass=\"math display\">\\[K\\times K\\]</span>\r\n的大瓦片，它们按以下规则摆放：</p>\r\n<ul>\r\n<li>对于每一对整数 <span class=\"math inline\">\\((i,j)\\)</span> ，正方形\r\n<span class=\"math display\">\\[\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge\r\nj\\leq y\\leq j+1\\rbrace\\]</span>\r\n要么包含在一块小方砖中，要么包含在一块大方砖中。\r\n<ul>\r\n<li>如果 <span class=\"math display\">\\[\\left\\lfloor\\dfrac\r\niK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor\\]</span>\r\n是偶数，则它包含在一个小方格中。</li>\r\n<li>否则，它被包含在一个大瓦片中。</li>\r\n</ul></li>\r\n</ul>\r\n<p>瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。</p>\r\n<p>例如，当 <span class=\"math inline\">\\(K=3\\)</span>\r\n时，瓦片的布局如下：</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png\" /></p>\r\n<p>高桥开始于坐标平面上的点 <span\r\nclass=\"math display\">\\[(S_x+0.5,S_y+0.5)\\]</span> 。</p>\r\n<p>他可以重复下面的动作任意多次：</p>\r\n<ul>\r\n<li>选择一个方向（上、下、左或右）和一个正整数 <span\r\nclass=\"math display\">\\[n\\]</span> 。向该方向移动 <span\r\nclass=\"math inline\">\\(n\\)</span> 个单位。</li>\r\n</ul>\r\n<p>每次他从一张牌移动到另一张牌时，必须支付 <span\r\nclass=\"math inline\">\\(1\\)</span> 的过路费。</p>\r\n<p>求高桥到达点 <span class=\"math display\">\\[(T_x+0.5,T_y+0.5)\\]</span>​\r\n所需的最小通行费。</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。</p>\r\n<p>然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。</p>\r\n<p>可以发现，不断走最大瓷砖是最优的。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg\"\r\nalt=\"70275E94F5C12B97C927177CEB804E4C\" />\r\n<figcaption\r\naria-hidden=\"true\">70275E94F5C12B97C927177CEB804E4C</figcaption>\r\n</figure>\r\n<p>即上图所示的路径是最短的。</p>\r\n<p>显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：\r\n<span class=\"math display\">\\[\r\ndistance = \\frac{d_s-d_a}{k} \\times 2 -1\r\n\\]</span> 其中定义<span\r\nclass=\"math display\">\\[d_s\\]</span>为走过直线长度，<span\r\nclass=\"math display\">\\[d_a\\]</span> 为两端长度，保证<span\r\nclass=\"math display\">\\[d_s - d_a \\equiv k\\]</span>​</p>\r\n<p>可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即<span\r\nclass=\"math display\">\\[\\frac{2}{k}\\]</span>，再减去<span\r\nclass=\"math display\">\\[1\\]</span></p>\r\n<p>但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。</p>\r\n<p>根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k&gt;=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。</p>\r\n<p>最后的结果形式上是切比雪夫距离</p>\r\n<p>于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> k,sx,sy,tx,ty;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\tcin&gt;&gt;sx&gt;&gt;sy;</span><br><span class=\"line\">\tcin&gt;&gt;tx&gt;&gt;ty;</span><br><span class=\"line\">\t<span class=\"type\">long</span> ans=LLINF;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;++i)<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">4</span>;++j)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;(X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;x==X&amp;&amp;y==Y)ans=<span class=\"built_in\">min</span>(ans,<span class=\"built_in\">abs</span>(sx-tx)+<span class=\"built_in\">abs</span>(sy-ty));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">-1</span>)c+=sx-x*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(x<span class=\"number\">+1</span>)-sx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">-1</span>)c+=sy-y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(y<span class=\"number\">+1</span>)-sy;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)x+=dx[i],y+=dy[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">-1</span>)c+=tx-X*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(X<span class=\"number\">+1</span>)-tx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">-1</span>)c+=ty-Y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(Y<span class=\"number\">+1</span>)-ty;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)X+=dx[j],Y+=dy[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(k==<span class=\"number\">1</span>)c=<span class=\"built_in\">abs</span>(x-X)+<span class=\"built_in\">abs</span>(y-Y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k==<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">long</span> d=<span class=\"built_in\">min</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y));</span><br><span class=\"line\">\t\t\tc+=d*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(x-X)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(y-Y)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c+=<span class=\"built_in\">max</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y))*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tans=<span class=\"built_in\">min</span>(ans,c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g---merchant-takahashi\"><strong>G - Merchant\r\nTakahashi</strong></h2>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>AtCoder 王国有 <span class=\"math inline\">\\(N\\)</span> 个城镇：城镇\r\n<span class=\"math inline\">\\(1\\)</span> 、 <span\r\nclass=\"math inline\">\\(2\\)</span> 、 <span\r\nclass=\"math inline\">\\(\\ldots\\)</span> 、 <span\r\nclass=\"math inline\">\\(N\\)</span> 。从 <span\r\nclass=\"math inline\">\\(i\\)</span> 镇到 <span\r\nclass=\"math inline\">\\(j\\)</span> 镇，必须支付 <span\r\nclass=\"math inline\">\\(C \\times |i-j|\\)</span> 日元的过路费。</p>\r\n<p>商人高桥正在考虑参加 <span class=\"math inline\">\\(M\\)</span>\r\n个或更多即将到来的市场。</p>\r\n<p><span class=\"math inline\">\\(i\\)</span> /-市场 <span\r\nclass=\"math display\">\\[(1 \\leq i \\leq M)\\]</span> 由一对整数 <span\r\nclass=\"math display\">\\[(T_i, P_i)\\]</span> 描述，其中市场在城镇 <span\r\nclass=\"math display\">\\[T_i\\]</span> 举行，如果他参加将赚取 <span\r\nclass=\"math display\">\\[P_i\\]</span> 日元。</p>\r\n<p>对于所有 <span class=\"math display\">\\[1 \\leq i &lt; M\\]</span> ，\r\n<span class=\"math display\">\\[i\\]</span> 次市场在 <span\r\nclass=\"math display\">\\[(i+1)\\]</span>\r\n次市场开始之前结束。他移动的时间可以忽略不计。</p>\r\n<p>他从 <span class=\"math display\">\\[10^{10^{100}}\\]</span>\r\n日元开始，最初在 <span class=\"math display\">\\[1\\]</span>\r\n镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。</p>\r\n<p>形式上，如果他在 <span class=\"math display\">\\[M\\]</span>\r\n个市场后获得最大资金额，那么 <span class=\"math display\">\\[10^{10^{100}}\r\n+ X\\]</span> 就是他的最终资金额。求 <span\r\nclass=\"math display\">\\[X\\]</span> 。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>显然的dp问题，如果你看不出来这是个dp问题建议你看一看<a\r\nhref=\"https://zhuanlan.zhihu.com/p/659884622\">再看最著名的 NP 问题之 TSP\r\n旅行商问题 - 知乎\r\n(zhihu.com)</a>，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。</p>\r\n<p>详细到这一题，很简单的状态表示为 <span class=\"math display\">\\[\r\nf_i:到i城的最大profit\r\n\\]</span> 状态转移为： <span class=\"math display\">\\[\r\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}\r\n\\]</span> 对绝对值正负进行分类 <span class=\"math display\">\\[\r\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\r\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}\r\n\\]</span> 提出取最大中的常数项： <span class=\"math display\">\\[\r\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\r\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C\r\n\\]</span>\r\n接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = -LLINF; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = -LLINF,ri = -LLINF;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;c;</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,-c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t[i]&gt;&gt;p[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,t[i],<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r = <span class=\"built_in\">query</span>(t[i],n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(l+p[i]-t[i]*c,r+p[i]+t[i]*c);</span><br><span class=\"line\">\t\tf[t[i]] = mx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;t[i]&lt;&lt; &#x27; &#x27; &lt;&lt;f[t[i]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] + t[i] * c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] - t[i] * c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans =<span class=\"built_in\">max</span>(ans,f[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":2757,"excerpt":"","more":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1My90YXNrcw==\">abc353\r\n(atcoder.jp)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<h2 id=\"c--sigma-problem\"><strong>C- Sigma Problem</strong></h2>\r\n<p>第一个记录的abcC题</p>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>对于正整数 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 为 <span\r\nclass=\"math display\">\\[(x + y)$ 除以 \\]</span>10^8$ 的余数。</p>\r\n<p>给你一个长度为 <span class=\"math inline\">\\(N\\)</span> 的正整数序列\r\n<span class=\"math display\">\\[A = (A_1, \\ldots, A_N)\\]</span>\r\n。求下面表达式的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)\\]</span>​ . ### 题解</p>\r\n<p>注意题目并非是完全模运算，注意到<span class=\"math inline\">\\(N\\times\r\nN\\times A_i\\)</span>刚刚好在longlong 边界上。并且<span\r\nclass=\"math inline\">\\(A_i\\times A_i\\)</span>\r\n最多减少一次Mod，我们只需要找出mod1e8的次数即可。</p>\r\n<p>刚刚开始我想的是二分，但实际上对于</p>\r\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 50000000 5000000 9999999 9999999 999999 999999 999999 </span><br></pre></td></tr></table></figure>\r\n<p>这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。</p>\r\n<p>我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。</p>\r\n<p>code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j=n;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i&lt;j &amp;&amp; a[i] + a[j] &gt;= MOD) j--;</span><br><span class=\"line\">\t\tcnt += <span class=\"built_in\">min</span>(n-i,n-j);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\tsum *= (n<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;sum - cnt * MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d---another-sigma-problem\"><strong>D - Another Sigma\r\nProblem</strong></h2>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>对于正整数 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 如下：</p>\r\n<ul>\r\n<li>将 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span>\r\n的十进制表示解释为字符串，并按此顺序连接，得到字符串 <span\r\nclass=\"math display\">\\[z\\]</span> 。将 <span class=\"math display\">\\[f(x,\r\ny)\\]</span> 解释为十进制整数时，其值就是 <span\r\nclass=\"math display\">\\[z\\]</span> 的值。</li>\r\n</ul>\r\n<p>例如， <span class=\"math display\">\\[f(3, 14) = 314\\]</span> 和 <span\r\nclass=\"math display\">\\[f(100, 1) = 1001\\]</span> 。</p>\r\n<p>给你一个长度为 <span class=\"math inline\">\\(N\\)</span> 的正整数序列\r\n<span class=\"math display\">\\[A = (A_1, \\ldots, A_N)\\]</span>\r\n。求下面表达式取模 <span class=\"math inline\">\\(998244353\\)</span>\r\n的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(A_i,A_j)\\]</span>​ .</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。</p>\r\n<p>下面是代码code</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t= a[i].x,s=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(t)&#123;</span><br><span class=\"line\">\t\t\ts++;</span><br><span class=\"line\">\t\t\tt/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ta[i].y = s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\trep[i] = (rep[i<span class=\"number\">+1</span>] + <span class=\"built_in\">qmi</span>(<span class=\"number\">10</span>,a[i].y)) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;rep[i]&lt;&lt;&#x27; &#x27;; </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans = (ans + (rep[i<span class=\"number\">+1</span>] + (i<span class=\"number\">-1</span>)) * a[i].x % MOD) % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e---yet-another-sigma-problem\"><strong>E - Yet Another Sigma\r\nProblem</strong></h2>\r\n<h3 id=\"题意-2\">题意</h3>\r\n<p>对于字符串 <span class=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(y\\)</span> ，定义 <span\r\nclass=\"math display\">\\[f(x, y)\\]</span> 如下：</p>\r\n<ul>\r\n<li><span class=\"math display\">\\[f(x, y)\\]</span> 是 <span\r\nclass=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> 的最长公共前缀的长度。</li>\r\n</ul>\r\n<p>给你一个由小写英文字母组成的 <span class=\"math inline\">\\(N\\)</span>\r\n字符串 <span class=\"math display\">\\[(S_1, \\ldots, S_N)\\]</span>\r\n。求以下表达式的值：</p>\r\n<p><span class=\"math display\">\\[\\displaystyle\r\n\\sum_{i=1}^{N-1}\\sum_{j=i+1}^N f(S_i,S_j)\\]</span> .</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>还是注意到同样的<span\r\nclass=\"math inline\">\\(O(N^2)\\)</span>是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。</p>\r\n<p>很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">build</span><span class=\"params\">(string&amp; s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> last = <span class=\"number\">-1</span> ,res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ip = s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;ip&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!son[p][ip]) son[p][ip] = ++idx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;s&lt;&lt; &quot;====&quot;&lt;&lt;last&lt;&lt; &#x27; &#x27; &lt;&lt; cnt[son[p][ip]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(last == <span class=\"number\">-1</span>) last = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt[son[p][ip]]!= last)&#123;</span><br><span class=\"line\">\t\t\tres += (last - cnt[son[p][ip]]) * i;</span><br><span class=\"line\">\t\t\tlast = cnt[son[p][ip]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt[son[p][ip]]++;</span><br><span class=\"line\">\t\tp = son[p][ip];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(cnt[p]!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tres +=(cnt[p] - <span class=\"number\">1</span>)*s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;s[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans += <span class=\"built_in\">build</span>(s[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f---tile-distance\"><strong>F - Tile Distance</strong></h2>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<h4 id=\"问题陈述\">问题陈述</h4>\r\n<p>瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 <span\r\nclass=\"math display\">\\[1\\times1\\]</span> 的小瓦片和尺寸为 <span\r\nclass=\"math display\">\\[K\\times K\\]</span>\r\n的大瓦片，它们按以下规则摆放：</p>\r\n<ul>\r\n<li>对于每一对整数 <span class=\"math inline\">\\((i,j)\\)</span> ，正方形\r\n<span class=\"math display\">\\[\\lbrace(x,y)\\mid i\\leq x\\leq i+1\\wedge\r\nj\\leq y\\leq j+1\\rbrace\\]</span>\r\n要么包含在一块小方砖中，要么包含在一块大方砖中。\r\n<ul>\r\n<li>如果 <span class=\"math display\">\\[\\left\\lfloor\\dfrac\r\niK\\right\\rfloor+\\left\\lfloor\\dfrac jK\\right\\rfloor\\]</span>\r\n是偶数，则它包含在一个小方格中。</li>\r\n<li>否则，它被包含在一个大瓦片中。</li>\r\n</ul></li>\r\n</ul>\r\n<p>瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。</p>\r\n<p>例如，当 <span class=\"math inline\">\\(K=3\\)</span>\r\n时，瓦片的布局如下：</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png\" /></p>\r\n<p>高桥开始于坐标平面上的点 <span\r\nclass=\"math display\">\\[(S_x+0.5,S_y+0.5)\\]</span> 。</p>\r\n<p>他可以重复下面的动作任意多次：</p>\r\n<ul>\r\n<li>选择一个方向（上、下、左或右）和一个正整数 <span\r\nclass=\"math display\">\\[n\\]</span> 。向该方向移动 <span\r\nclass=\"math inline\">\\(n\\)</span> 个单位。</li>\r\n</ul>\r\n<p>每次他从一张牌移动到另一张牌时，必须支付 <span\r\nclass=\"math inline\">\\(1\\)</span> 的过路费。</p>\r\n<p>求高桥到达点 <span class=\"math display\">\\[(T_x+0.5,T_y+0.5)\\]</span>​\r\n所需的最小通行费。</p>\r\n<h3 id=\"题解-2\">题解</h3>\r\n<p>首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。</p>\r\n<p>然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。</p>\r\n<p>可以发现，不断走最大瓷砖是最优的。</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg\"\r\nalt=\"70275E94F5C12B97C927177CEB804E4C\" />\r\n<figcaption\r\naria-hidden=\"true\">70275E94F5C12B97C927177CEB804E4C</figcaption>\r\n</figure>\r\n<p>即上图所示的路径是最短的。</p>\r\n<p>显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：\r\n<span class=\"math display\">\\[\r\ndistance = \\frac{d_s-d_a}{k} \\times 2 -1\r\n\\]</span> 其中定义<span\r\nclass=\"math display\">\\[d_s\\]</span>为走过直线长度，<span\r\nclass=\"math display\">\\[d_a\\]</span> 为两端长度，保证<span\r\nclass=\"math display\">\\[d_s - d_a \\equiv k\\]</span>​</p>\r\n<p>可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即<span\r\nclass=\"math display\">\\[\\frac{2}{k}\\]</span>，再减去<span\r\nclass=\"math display\">\\[1\\]</span></p>\r\n<p>但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。</p>\r\n<p>根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k&gt;=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。</p>\r\n<p>最后的结果形式上是切比雪夫距离</p>\r\n<p>于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> k,sx,sy,tx,ty;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\tcin&gt;&gt;sx&gt;&gt;sy;</span><br><span class=\"line\">\tcin&gt;&gt;tx&gt;&gt;ty;</span><br><span class=\"line\">\t<span class=\"type\">long</span> ans=LLINF;</span><br><span class=\"line\">\t<span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;++i)<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">4</span>;++j)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;(X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;x==X&amp;&amp;y==Y)ans=<span class=\"built_in\">min</span>(ans,<span class=\"built_in\">abs</span>(sx-tx)+<span class=\"built_in\">abs</span>(sy-ty));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((x+y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">-1</span>)c+=sx-x*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(x<span class=\"number\">+1</span>)-sx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">-1</span>)c+=sy-y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[i]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(y<span class=\"number\">+1</span>)-sy;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)x+=dx[i],y+=dy[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((X+Y)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">-1</span>)c+=tx-X*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dx[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(X<span class=\"number\">+1</span>)-tx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">-1</span>)c+=ty-Y*k<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(dy[j]==<span class=\"number\">1</span>)c+=k*(<span class=\"type\">long</span>)(Y<span class=\"number\">+1</span>)-ty;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k!=<span class=\"number\">1</span>)X+=dx[j],Y+=dy[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(k==<span class=\"number\">1</span>)c=<span class=\"built_in\">abs</span>(x-X)+<span class=\"built_in\">abs</span>(y-Y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k==<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">long</span> d=<span class=\"built_in\">min</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y));</span><br><span class=\"line\">\t\t\tc+=d*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(x-X)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tc+=(<span class=\"built_in\">abs</span>(y-Y)-d)*(<span class=\"type\">long</span>)<span class=\"number\">3</span>/(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> c+=<span class=\"built_in\">max</span>(<span class=\"built_in\">abs</span>(x-X),<span class=\"built_in\">abs</span>(y-Y))*(<span class=\"type\">long</span>)<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tans=<span class=\"built_in\">min</span>(ans,c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g---merchant-takahashi\"><strong>G - Merchant\r\nTakahashi</strong></h2>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>AtCoder 王国有 <span class=\"math inline\">\\(N\\)</span> 个城镇：城镇\r\n<span class=\"math inline\">\\(1\\)</span> 、 <span\r\nclass=\"math inline\">\\(2\\)</span> 、 <span\r\nclass=\"math inline\">\\(\\ldots\\)</span> 、 <span\r\nclass=\"math inline\">\\(N\\)</span> 。从 <span\r\nclass=\"math inline\">\\(i\\)</span> 镇到 <span\r\nclass=\"math inline\">\\(j\\)</span> 镇，必须支付 <span\r\nclass=\"math inline\">\\(C \\times |i-j|\\)</span> 日元的过路费。</p>\r\n<p>商人高桥正在考虑参加 <span class=\"math inline\">\\(M\\)</span>\r\n个或更多即将到来的市场。</p>\r\n<p><span class=\"math inline\">\\(i\\)</span> /-市场 <span\r\nclass=\"math display\">\\[(1 \\leq i \\leq M)\\]</span> 由一对整数 <span\r\nclass=\"math display\">\\[(T_i, P_i)\\]</span> 描述，其中市场在城镇 <span\r\nclass=\"math display\">\\[T_i\\]</span> 举行，如果他参加将赚取 <span\r\nclass=\"math display\">\\[P_i\\]</span> 日元。</p>\r\n<p>对于所有 <span class=\"math display\">\\[1 \\leq i &lt; M\\]</span> ，\r\n<span class=\"math display\">\\[i\\]</span> 次市场在 <span\r\nclass=\"math display\">\\[(i+1)\\]</span>\r\n次市场开始之前结束。他移动的时间可以忽略不计。</p>\r\n<p>他从 <span class=\"math display\">\\[10^{10^{100}}\\]</span>\r\n日元开始，最初在 <span class=\"math display\">\\[1\\]</span>\r\n镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。</p>\r\n<p>形式上，如果他在 <span class=\"math display\">\\[M\\]</span>\r\n个市场后获得最大资金额，那么 <span class=\"math display\">\\[10^{10^{100}}\r\n+ X\\]</span> 就是他的最终资金额。求 <span\r\nclass=\"math display\">\\[X\\]</span> 。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>显然的dp问题，如果你看不出来这是个dp问题建议你看一看<a\r\nhref=\"https://zhuanlan.zhihu.com/p/659884622\">再看最著名的 NP 问题之 TSP\r\n旅行商问题 - 知乎\r\n(zhihu.com)</a>，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。</p>\r\n<p>详细到这一题，很简单的状态表示为 <span class=\"math display\">\\[\r\nf_i:到i城的最大profit\r\n\\]</span> 状态转移为： <span class=\"math display\">\\[\r\nf_i=max_{j=1}^n \\left\\{f_j-|i-j|\\times C +p\\right\\}\r\n\\]</span> 对绝对值正负进行分类 <span class=\"math display\">\\[\r\nf_i=max_{j=1}^i \\left\\{f_j-i\\times C+j\\times C +p\\right\\}\\\\\r\nf_i=max_{j=i}^n \\left\\{f_j-j\\times C+i\\times C +p\\right\\}\r\n\\]</span> 提出取最大中的常数项： <span class=\"math display\">\\[\r\nf_i=max_{j=1}^i \\left\\{f_j+j\\times C \\right\\}+p-i\\times C\\\\\r\nf_i=max_{j=i}^{n} \\left\\{f_j-j\\times C \\right\\}+p+i\\times C\r\n\\]</span>\r\n接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = -LLINF; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = -LLINF,ri = -LLINF;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;c;</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,-c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t[i]&gt;&gt;p[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,t[i],<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r = <span class=\"built_in\">query</span>(t[i],n,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">max</span>(l+p[i]-t[i]*c,r+p[i]+t[i]*c);</span><br><span class=\"line\">\t\tf[t[i]] = mx;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;t[i]&lt;&lt; &#x27; &#x27; &lt;&lt;f[t[i]]&lt;&lt;nline;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] + t[i] * c,<span class=\"number\">1</span>,tr1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(t[i],f[t[i]] - t[i] * c,<span class=\"number\">1</span>,tr2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans =<span class=\"built_in\">max</span>(ans,f[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"abc354","date":"2024-08-14T11:46:31.000Z","_content":"\n##  [C - AtCoder Magics](https://atcoder.jp/contests/abc354/tasks/abc354_c)\n\n## 题意\n\n高桥有 $$N$$ 张纸牌，来自纸牌游戏 \"AtCoder Magics\"。其中的 $$i$$ 张卡将被称为 $$i$$ 张卡。每张卡都有两个参数：强度和成本。卡片 $$i$$ 的强度为 $$A_i$$ ，成本为 $$C_i$$ 。\n\n他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：\n\n- 选择两张牌 $$x$$ 和 $$y$$ ，即 $$A_x > A_y$$ 和 $$C_x < C_y$$ 。弃牌 $$y$$ 。\n\n可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。\n\n## 题解\n\n对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i].x.y>>a[i].x.x,a[i].y = i;\n\n\tsort(a+1,a+1+n);\n\t// for(int i=1;i<=n;i++) cout<<a[i].y<<endl;\n\n\tstd::vector<int> ans;\n\tint mx = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tint j = i;\n\t\tint t = 0;\n\t\tif(a[j].x.y > mx) ans.push_back(a[j].y);\n\t\tt = max(t, a[j].x.y);\n\t\t// while(j<n && a[j+1].x.x == a[j].x.x){\n\t\t// \tif(a[j].x.y > mx) {\n\t\t// \t\t// cout<<a[j].y<<endl;\n\t\t// \t\tans.push_back(a[j].y);\n\t\t// \t}\n\t\t// \tt = max(t, a[j].x.y);\n\t\t// \tj++;\n\t\t// }\n\t\tmx = max(t,mx);\n\t\t// cout<<mx<<endl;\n\t\ti = j;\n\t}\n\tsort(all(ans));\n\n\tcout<<ans.size()<<endl;\n\n\tfor(int idx: ans) cout<<idx<<' ';\n\t\tcout<<endl;\n}\n```\n\n##  [D - AtCoder Wallpaper](https://atcoder.jp/contests/abc354/tasks/abc354_d)\n\n## 题意\n\nAtCoder 的壁纸图案可以在 $xy$ (平面)上表示如下：\n\n- 该平面由以下三种线段划分：\n    - $$x = n$$ (其中 $n$ 为整数)\n    - $$y = n$$ (其中 $n$ 为偶数)\n    - $$x + y = n$$ (其中 $n$ 为偶数)\n- 每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。\n- 包含 $$(0.5, 0.5)$$ 的区域被涂成黑色。\n\n下图显示了图案的一部分。\n\n![](https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png)\n\n给你整数 $$A, B, C, D$$ 。考虑一个边平行于 $$x$$ \\- 和 $$y$$ \\- 轴的矩形，它的左下顶点在 $$(A, B)$$ ，右上顶点在 $(C, D)$ 。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。\n\n可以证明输出值将是一个整数。\n\n## 题解\n\n构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。\n\n对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。\n\n加上偏移量以确保两个数的正负号问题。\n\n```cpp\nvoid slove() {\n\tint a,b,c,d;\n\n    cin>>a>>b>>c>>d;\n\n    ll ans = 0;\n    for(int i = 0; i<2 ; i++){\n        for(int j = 0; j<4; j++){\n            ll x1 = (a - j + 3 + B)/4, x2 = (c - j + 3 + B)/4;\n            int coux = x2 - x1;\n            ll y1 = (b - i + 1 + B)/2, y2 = (d - i + 1 + B)/2;\n            int couy = y2 - y1;\n            ans += coux * couy * p[i][j];\n        }\n    }\n\n    cout<<ans<<endl;\n}\n```\n\n## [E - Remove Pairs (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_e)\n\n## 题意\n\n高桥和青木正在玩一个使用 $$N$$ 张卡片的游戏。 $￥$ 这张牌的正面写着 $$A_i$$ ，背面写着 $$B_i$$ 。最初， $$N$$ 这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：\n\n- 从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。\n\n最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？\n\n## 题解\n\n乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是$$N \\leq 18$$!\n\n于是直接暴力位dp即可\n\n但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i].x>>a[i].y;\n\n\n\tfor(int i=0;i<(1<<n);i++){\n\t\tfor(int x=0;x<n;x++)\n\t\t{\n\t\t\tfor(int y=x+1;y<n;y++){\n\t\t\t\tif((i >> x & 1) && (i >> y & 1) &&\n\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y))){\n\t\t\t\t\tf[i] |= !f[i^(1<<x)^(1<<y)];\n\t\t\t\t\t// cout<<i<<' '<<x<< ' '<<y<<' '\n\t\t\t\t\t// \t<<(i^(1<<x)^(1<<y))<<' '<<f[i^(1<<x)^(1<<y)]<<endl;\n\t\t\t\t\t// cout<<f[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(f[(1<<n)-1]) cout<<\"Takahashi\\n\";\n\telse cout<<\"Aoki\\n\";\n}\n```\n\n## [F - Useless for LIS (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_f)\n\n## 题意\n\n给你一个长度为 $$N$$ 的整数序列 $$A$$ 。\n\n对于每个 $$t = 1, 2, \\dots, N$$ ，判断 $$A_t$$ 是否包含在 $$A$$ 的最长递增子序列中。\n\n这里，当且仅当以下条件成立时， $$A_t$$ 才包含在 $A$ 的最长递增子序列中：\n\n- 设 $$L$$ 是 $$A$$ 的最长递增子序列的长度。存在一个严格递增整数序列 $$i = (i_1, i_2, \\dots, i_L)  (i_1 < i_2 < \\dots < i_ L)$$ ，其中每个元素都介于 $$1$$ 与 $$N$$ 之间，且满足以下所有条件：\n  \n    - $$A_{i_1}<A_{i_2}<\\dots<A _{i _L}$$ .\n    - $$i_k = t$$ 为某个 $$k (1 \\leq k \\leq L)$$ 。\n\n给你 $T$ 个测试用例，请逐个求解。\n\n什么是最长递增子序列？\n\n序列 $A$ 的子序列是指从 $A$ 中提取一些元素而不改变顺序所得到的序列。\n\n序列 $A$ 的最长递增子序列是 $A$ 的子序列，它以最大可能的长度严格递增。\n\n## 题解\n\n求不包含在样最长上升子序列中的数的下标集合\n\n回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值\n\n这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。\n\n可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。\n\n最后，数据范围离散化\n\n```cpp\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = 0; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = 0,ri = 0;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\n\nvoid slove() {\n\tcin>>n;\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tves.push_back(a[i]);\n\t}\n\n\tsort(all(ves));\n\tves.erase(unique(all(ves)),ves.end());\n\n\tfor(int i=0;i<ves.size();i++){\n\t\tmp[ves[i]] = i+1;\n\t}\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = query(1,mp[a[i]]-1,1,tr);\n\t\tf[i] = mx+1;\n\t\tmodify(mp[a[i]],f[i],1,tr);\n\t}\n\n\tint maxx = query(1,n,1,tr);\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=n;i;i--){\n\t\tint mx = query(mp[a[i]]+1,n,1,tr);\n\t\trf[i] = mx+1;\n\t\tmodify(mp[a[i]],rf[i],1,tr);\n\t}\n\n\t// cout<<maxx<<endl;\n\n\t// for(int i=1;i<=n;i++){\n\t// \tcout<<f[i]<< ' ' << rf[i]<<endl;\n\t// }\n\n\tvector<int> ans;\n\tfor(int i=1;i<=n;i++)\n\t\tif(f[i] + rf[i] - 1 == maxx){\n\t\t\tans.push_back(i);\n\t\t}\n\n\tcout<<ans.size()<<endl;\n\tfor(int v: ans) cout<<v<< ' ';\n\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [G - Select Strings (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_g)\n\n## 题意\n\n\n\n## 题解\n\n","source":"_posts/abc354.md","raw":"---\ntitle: abc354\ndate: 2024-08-14 19:46:31\ntags: [atcoder]\ncategories: \n\t- 比赛\n\t- 日常赛\n\t- atcoder\n---\n\n##  [C - AtCoder Magics](https://atcoder.jp/contests/abc354/tasks/abc354_c)\n\n## 题意\n\n高桥有 $$N$$ 张纸牌，来自纸牌游戏 \"AtCoder Magics\"。其中的 $$i$$ 张卡将被称为 $$i$$ 张卡。每张卡都有两个参数：强度和成本。卡片 $$i$$ 的强度为 $$A_i$$ ，成本为 $$C_i$$ 。\n\n他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：\n\n- 选择两张牌 $$x$$ 和 $$y$$ ，即 $$A_x > A_y$$ 和 $$C_x < C_y$$ 。弃牌 $$y$$ 。\n\n可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。\n\n## 题解\n\n对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i].x.y>>a[i].x.x,a[i].y = i;\n\n\tsort(a+1,a+1+n);\n\t// for(int i=1;i<=n;i++) cout<<a[i].y<<endl;\n\n\tstd::vector<int> ans;\n\tint mx = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tint j = i;\n\t\tint t = 0;\n\t\tif(a[j].x.y > mx) ans.push_back(a[j].y);\n\t\tt = max(t, a[j].x.y);\n\t\t// while(j<n && a[j+1].x.x == a[j].x.x){\n\t\t// \tif(a[j].x.y > mx) {\n\t\t// \t\t// cout<<a[j].y<<endl;\n\t\t// \t\tans.push_back(a[j].y);\n\t\t// \t}\n\t\t// \tt = max(t, a[j].x.y);\n\t\t// \tj++;\n\t\t// }\n\t\tmx = max(t,mx);\n\t\t// cout<<mx<<endl;\n\t\ti = j;\n\t}\n\tsort(all(ans));\n\n\tcout<<ans.size()<<endl;\n\n\tfor(int idx: ans) cout<<idx<<' ';\n\t\tcout<<endl;\n}\n```\n\n##  [D - AtCoder Wallpaper](https://atcoder.jp/contests/abc354/tasks/abc354_d)\n\n## 题意\n\nAtCoder 的壁纸图案可以在 $xy$ (平面)上表示如下：\n\n- 该平面由以下三种线段划分：\n    - $$x = n$$ (其中 $n$ 为整数)\n    - $$y = n$$ (其中 $n$ 为偶数)\n    - $$x + y = n$$ (其中 $n$ 为偶数)\n- 每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。\n- 包含 $$(0.5, 0.5)$$ 的区域被涂成黑色。\n\n下图显示了图案的一部分。\n\n![](https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png)\n\n给你整数 $$A, B, C, D$$ 。考虑一个边平行于 $$x$$ \\- 和 $$y$$ \\- 轴的矩形，它的左下顶点在 $$(A, B)$$ ，右上顶点在 $(C, D)$ 。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。\n\n可以证明输出值将是一个整数。\n\n## 题解\n\n构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。\n\n对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。\n\n加上偏移量以确保两个数的正负号问题。\n\n```cpp\nvoid slove() {\n\tint a,b,c,d;\n\n    cin>>a>>b>>c>>d;\n\n    ll ans = 0;\n    for(int i = 0; i<2 ; i++){\n        for(int j = 0; j<4; j++){\n            ll x1 = (a - j + 3 + B)/4, x2 = (c - j + 3 + B)/4;\n            int coux = x2 - x1;\n            ll y1 = (b - i + 1 + B)/2, y2 = (d - i + 1 + B)/2;\n            int couy = y2 - y1;\n            ans += coux * couy * p[i][j];\n        }\n    }\n\n    cout<<ans<<endl;\n}\n```\n\n## [E - Remove Pairs (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_e)\n\n## 题意\n\n高桥和青木正在玩一个使用 $$N$$ 张卡片的游戏。 $￥$ 这张牌的正面写着 $$A_i$$ ，背面写着 $$B_i$$ 。最初， $$N$$ 这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：\n\n- 从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。\n\n最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？\n\n## 题解\n\n乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是$$N \\leq 18$$!\n\n于是直接暴力位dp即可\n\n但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）\n\n```cpp\nvoid slove() {\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i].x>>a[i].y;\n\n\n\tfor(int i=0;i<(1<<n);i++){\n\t\tfor(int x=0;x<n;x++)\n\t\t{\n\t\t\tfor(int y=x+1;y<n;y++){\n\t\t\t\tif((i >> x & 1) && (i >> y & 1) &&\n\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y))){\n\t\t\t\t\tf[i] |= !f[i^(1<<x)^(1<<y)];\n\t\t\t\t\t// cout<<i<<' '<<x<< ' '<<y<<' '\n\t\t\t\t\t// \t<<(i^(1<<x)^(1<<y))<<' '<<f[i^(1<<x)^(1<<y)]<<endl;\n\t\t\t\t\t// cout<<f[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(f[(1<<n)-1]) cout<<\"Takahashi\\n\";\n\telse cout<<\"Aoki\\n\";\n}\n```\n\n## [F - Useless for LIS (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_f)\n\n## 题意\n\n给你一个长度为 $$N$$ 的整数序列 $$A$$ 。\n\n对于每个 $$t = 1, 2, \\dots, N$$ ，判断 $$A_t$$ 是否包含在 $$A$$ 的最长递增子序列中。\n\n这里，当且仅当以下条件成立时， $$A_t$$ 才包含在 $A$ 的最长递增子序列中：\n\n- 设 $$L$$ 是 $$A$$ 的最长递增子序列的长度。存在一个严格递增整数序列 $$i = (i_1, i_2, \\dots, i_L)  (i_1 < i_2 < \\dots < i_ L)$$ ，其中每个元素都介于 $$1$$ 与 $$N$$ 之间，且满足以下所有条件：\n  \n    - $$A_{i_1}<A_{i_2}<\\dots<A _{i _L}$$ .\n    - $$i_k = t$$ 为某个 $$k (1 \\leq k \\leq L)$$ 。\n\n给你 $T$ 个测试用例，请逐个求解。\n\n什么是最长递增子序列？\n\n序列 $A$ 的子序列是指从 $A$ 中提取一些元素而不改变顺序所得到的序列。\n\n序列 $A$ 的最长递增子序列是 $A$ 的子序列，它以最大可能的长度严格递增。\n\n## 题解\n\n求不包含在样最长上升子序列中的数的下标集合\n\n回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值\n\n这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。\n\n可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。\n\n最后，数据范围离散化\n\n```cpp\nvoid push_up(Node* rt, Node* l,Node* r){\n\trt->val = max(l->val,r->val);\n}\n\nvoid push_up(int u,Node* tr){\n\tpush_up(tr+u,tr+(u<<1),tr+ (u<<1|1));\n}\n\nvoid build(int l,int r,int u,Node* tr){\n\ttr[u]={l,r};\n\tif(l==r) {tr[u].val = 0; return ;}\n\tint mid = l + r >> 1;\n\tbuild(l,mid,u<<1,tr); build(mid+1,r,u<<1|1,tr);\n\tpush_up(u,tr);\n\t// cout<<tr[u].val<<endl;\n\treturn ;\n}\n\nint query(int l,int r,int u,Node* tr){\n\tif(l <= tr[u].l && r >= tr[u].r){\n\t\treturn tr[u].val;\n\t}else {\n\t\tint mid = tr[u].l +tr[u].r >> 1;\n\t\tint le = 0,ri = 0;\n\t\tif(l<= mid) le = query(l,r,u<<1,tr);\n\t\tif(r > mid) ri = query(l,r,u<<1|1,tr);\n\t\treturn max(le,ri);\n\t}\n}\n\nvoid modify(int x,int c,int u,Node* tr){\n\tif(tr[u].l == tr[u].r && tr[u].l == x){\n\t\ttr[u].val = c;\n\t\treturn;\n\t}else {\n\t\tint mid = tr[u].l + tr[u].r>>1;\n\t\tif(x <= mid) modify(x,c,u<<1,tr);\n\t\telse modify(x,c,u<<1|1,tr);\n\t\tpush_up(u,tr);\n\t\treturn ;\n\t}\n}\n\n\nvoid slove() {\n\tcin>>n;\n\n\tvector<int> ves;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tves.push_back(a[i]);\n\t}\n\n\tsort(all(ves));\n\tves.erase(unique(all(ves)),ves.end());\n\n\tfor(int i=0;i<ves.size();i++){\n\t\tmp[ves[i]] = i+1;\n\t}\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx = query(1,mp[a[i]]-1,1,tr);\n\t\tf[i] = mx+1;\n\t\tmodify(mp[a[i]],f[i],1,tr);\n\t}\n\n\tint maxx = query(1,n,1,tr);\n\n\tbuild(1,n,1,tr);\n\n\tfor(int i=n;i;i--){\n\t\tint mx = query(mp[a[i]]+1,n,1,tr);\n\t\trf[i] = mx+1;\n\t\tmodify(mp[a[i]],rf[i],1,tr);\n\t}\n\n\t// cout<<maxx<<endl;\n\n\t// for(int i=1;i<=n;i++){\n\t// \tcout<<f[i]<< ' ' << rf[i]<<endl;\n\t// }\n\n\tvector<int> ans;\n\tfor(int i=1;i<=n;i++)\n\t\tif(f[i] + rf[i] - 1 == maxx){\n\t\t\tans.push_back(i);\n\t\t}\n\n\tcout<<ans.size()<<endl;\n\tfor(int v: ans) cout<<v<< ' ';\n\tcout<<endl;\n\n\treturn ;\n}\n```\n\n## [G - Select Strings (atcoder.jp)](https://atcoder.jp/contests/abc354/tasks/abc354_g)\n\n## 题意\n\n\n\n## 题解\n\n","slug":"abc354","published":1,"updated":"2024-08-15T03:48:35.418Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt9000wwwwv3lzl3qjs","content":"<h2 id=\"c---atcoder-magics\"><a\r\nhref=\"https://atcoder.jp/contests/abc354/tasks/abc354_c\">C - AtCoder\r\nMagics</a></h2>\r\n<h2 id=\"题意\">题意</h2>\r\n<p>高桥有 <span class=\"math display\">\\[N\\]</span> 张纸牌，来自纸牌游戏\r\n\"AtCoder Magics\"。其中的 <span class=\"math display\">\\[i\\]</span>\r\n张卡将被称为 <span class=\"math display\">\\[i\\]</span>\r\n张卡。每张卡都有两个参数：强度和成本。卡片 <span\r\nclass=\"math display\">\\[i\\]</span> 的强度为 <span\r\nclass=\"math display\">\\[A_i\\]</span> ，成本为 <span\r\nclass=\"math display\">\\[C_i\\]</span> 。</p>\r\n<p>他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：</p>\r\n<ul>\r\n<li>选择两张牌 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，即 <span class=\"math display\">\\[A_x\r\n&gt; A_y\\]</span> 和 <span class=\"math display\">\\[C_x &lt; C_y\\]</span>\r\n。弃牌 <span class=\"math display\">\\[y\\]</span> 。</li>\r\n</ul>\r\n<p>可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x.y&gt;&gt;a[i].x.x,a[i].y = i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = i;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[j].x.y &gt; mx) ans.<span class=\"built_in\">push_back</span>(a[j].y);</span><br><span class=\"line\">\t\tt = <span class=\"built_in\">max</span>(t, a[j].x.y);</span><br><span class=\"line\">\t\t<span class=\"comment\">// while(j&lt;n &amp;&amp; a[j+1].x.x == a[j].x.x)&#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tif(a[j].x.y &gt; mx) &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\t// cout&lt;&lt;a[j].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\tans.push_back(a[j].y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tt = max(t, a[j].x.y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tj++;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\">\t\tmx = <span class=\"built_in\">max</span>(t,mx);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ans));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> idx: ans) cout&lt;&lt;idx&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d---atcoder-wallpaper\"><a\r\nhref=\"https://atcoder.jp/contests/abc354/tasks/abc354_d\">D - AtCoder\r\nWallpaper</a></h2>\r\n<h2 id=\"题意-1\">题意</h2>\r\n<p>AtCoder 的壁纸图案可以在 <span class=\"math inline\">\\(xy\\)</span>\r\n(平面)上表示如下：</p>\r\n<ul>\r\n<li>该平面由以下三种线段划分：\r\n<ul>\r\n<li><span class=\"math display\">\\[x = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为整数)</li>\r\n<li><span class=\"math display\">\\[y = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为偶数)</li>\r\n<li><span class=\"math display\">\\[x + y = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为偶数)</li>\r\n</ul></li>\r\n<li>每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。</li>\r\n<li>包含 <span class=\"math display\">\\[(0.5, 0.5)\\]</span>\r\n的区域被涂成黑色。</li>\r\n</ul>\r\n<p>下图显示了图案的一部分。</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png\" /></p>\r\n<p>给你整数 <span class=\"math display\">\\[A, B, C, D\\]</span>\r\n。考虑一个边平行于 <span class=\"math display\">\\[x\\]</span> - 和 <span\r\nclass=\"math display\">\\[y\\]</span> - 轴的矩形，它的左下顶点在 <span\r\nclass=\"math display\">\\[(A, B)\\]</span> ，右上顶点在 <span\r\nclass=\"math inline\">\\((C, D)\\)</span>\r\n。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。</p>\r\n<p>可以证明输出值将是一个整数。</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。</p>\r\n<p>对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。</p>\r\n<p>加上偏移量以确保两个数的正负号问题。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a,b,c,d;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">2</span> ; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j&lt;<span class=\"number\">4</span>; j++)&#123;</span><br><span class=\"line\">            ll x1 = (a - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>, x2 = (c - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> coux = x2 - x1;</span><br><span class=\"line\">            ll y1 = (b - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>, y2 = (d - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> couy = y2 - y1;</span><br><span class=\"line\">            ans += coux * couy * p[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e---remove-pairs-atcoder.jp\"><a\r\nhref=\"https://atcoder.jp/contests/abc354/tasks/abc354_e\">E - Remove\r\nPairs (atcoder.jp)</a></h2>\r\n<h2 id=\"题意-2\">题意</h2>\r\n<p>高桥和青木正在玩一个使用 <span class=\"math display\">\\[N\\]</span>\r\n张卡片的游戏。 <span class=\"math inline\">\\(￥\\)</span> 这张牌的正面写着\r\n<span class=\"math display\">\\[A_i\\]</span> ，背面写着 <span\r\nclass=\"math display\">\\[B_i\\]</span> 。最初， <span\r\nclass=\"math display\">\\[N\\]</span>\r\n这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：</p>\r\n<ul>\r\n<li>从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。</li>\r\n</ul>\r\n<p>最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是<span\r\nclass=\"math display\">\\[N \\leq 18\\]</span>!</p>\r\n<p>于是直接暴力位dp即可</p>\r\n<p>但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>;x&lt;n;x++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> y=x<span class=\"number\">+1</span>;y&lt;n;y++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>((i &gt;&gt; x &amp; <span class=\"number\">1</span>) &amp;&amp; (i &gt;&gt; y &amp; <span class=\"number\">1</span>) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y)))&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i] |= !f[i^(<span class=\"number\">1</span>&lt;&lt;x)^(<span class=\"number\">1</span>&lt;&lt;y)];</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;x&lt;&lt; &#x27; &#x27;&lt;&lt;y&lt;&lt;&#x27; &#x27;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// \t&lt;&lt;(i^(1&lt;&lt;x)^(1&lt;&lt;y))&lt;&lt;&#x27; &#x27;&lt;&lt;f[i^(1&lt;&lt;x)^(1&lt;&lt;y)]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(f[(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]) cout&lt;&lt;<span class=\"string\">&quot;Takahashi\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;Aoki\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f---useless-for-lis-atcoder.jp\"><a\r\nhref=\"https://atcoder.jp/contests/abc354/tasks/abc354_f\">F - Useless for\r\nLIS (atcoder.jp)</a></h2>\r\n<h2 id=\"题意-3\">题意</h2>\r\n<p>给你一个长度为 <span class=\"math display\">\\[N\\]</span> 的整数序列\r\n<span class=\"math display\">\\[A\\]</span> 。</p>\r\n<p>对于每个 <span class=\"math display\">\\[t = 1, 2, \\dots, N\\]</span>\r\n，判断 <span class=\"math display\">\\[A_t\\]</span> 是否包含在 <span\r\nclass=\"math display\">\\[A\\]</span> 的最长递增子序列中。</p>\r\n<p>这里，当且仅当以下条件成立时， <span\r\nclass=\"math display\">\\[A_t\\]</span> 才包含在 <span\r\nclass=\"math inline\">\\(A\\)</span> 的最长递增子序列中：</p>\r\n<ul>\r\n<li><p>设 <span class=\"math display\">\\[L\\]</span> 是 <span\r\nclass=\"math display\">\\[A\\]</span>\r\n的最长递增子序列的长度。存在一个严格递增整数序列 <span\r\nclass=\"math display\">\\[i = (i_1, i_2, \\dots, i_L)  (i_1 &lt; i_2 &lt;\r\n\\dots &lt; i_ L)\\]</span> ，其中每个元素都介于 <span\r\nclass=\"math display\">\\[1\\]</span> 与 <span\r\nclass=\"math display\">\\[N\\]</span> 之间，且满足以下所有条件：</p>\r\n<ul>\r\n<li><span class=\"math display\">\\[A_{i_1}&lt;A_{i_2}&lt;\\dots&lt;A _{i\r\n_L}\\]</span> .</li>\r\n<li><span class=\"math display\">\\[i_k = t\\]</span> 为某个 <span\r\nclass=\"math display\">\\[k (1 \\leq k \\leq L)\\]</span> 。</li>\r\n</ul></li>\r\n</ul>\r\n<p>给你 <span class=\"math inline\">\\(T\\)</span>\r\n个测试用例，请逐个求解。</p>\r\n<p>什么是最长递增子序列？</p>\r\n<p>序列 <span class=\"math inline\">\\(A\\)</span> 的子序列是指从 <span\r\nclass=\"math inline\">\\(A\\)</span>\r\n中提取一些元素而不改变顺序所得到的序列。</p>\r\n<p>序列 <span class=\"math inline\">\\(A\\)</span> 的最长递增子序列是 <span\r\nclass=\"math inline\">\\(A\\)</span>\r\n的子序列，它以最大可能的长度严格递增。</p>\r\n<h2 id=\"题解-3\">题解</h2>\r\n<p>求不包含在样最长上升子序列中的数的下标集合</p>\r\n<p>回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值</p>\r\n<p>这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。</p>\r\n<p>可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。</p>\r\n<p>最后，数据范围离散化</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = <span class=\"number\">0</span>; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = <span class=\"number\">0</span>,ri = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tves.<span class=\"built_in\">push_back</span>(a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ves));</span><br><span class=\"line\">\tves.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(ves)),ves.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;ves.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\tmp[ves[i]] = i<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,mp[a[i]]<span class=\"number\">-1</span>,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\tf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],f[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> maxx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(mp[a[i]]<span class=\"number\">+1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\trf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],rf[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;maxx&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;f[i]&lt;&lt; &#x27; &#x27; &lt;&lt; rf[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i] + rf[i] - <span class=\"number\">1</span> == maxx)&#123;</span><br><span class=\"line\">\t\t\tans.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ans) cout&lt;&lt;v&lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g---select-strings-atcoder.jp\"><a\r\nhref=\"https://atcoder.jp/contests/abc354/tasks/abc354_g\">G - Select\r\nStrings (atcoder.jp)</a></h2>\r\n<h2 id=\"题意-4\">题意</h2>\r\n<h2 id=\"题解-4\">题解</h2>\r\n","length":1929,"excerpt":"","more":"<h2 id=\"c---atcoder-magics\"><a\r\nhref=\"https://atcoder.jp/contests/abc354/tasks/abc354_c\">C - AtCoder\r\nMagics</a></h2>\r\n<h2 id=\"题意\">题意</h2>\r\n<p>高桥有 <span class=\"math display\">\\[N\\]</span> 张纸牌，来自纸牌游戏\r\n\"AtCoder Magics\"。其中的 <span class=\"math display\">\\[i\\]</span>\r\n张卡将被称为 <span class=\"math display\">\\[i\\]</span>\r\n张卡。每张卡都有两个参数：强度和成本。卡片 <span\r\nclass=\"math display\">\\[i\\]</span> 的强度为 <span\r\nclass=\"math display\">\\[A_i\\]</span> ，成本为 <span\r\nclass=\"math display\">\\[C_i\\]</span> 。</p>\r\n<p>他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：</p>\r\n<ul>\r\n<li>选择两张牌 <span class=\"math display\">\\[x\\]</span> 和 <span\r\nclass=\"math display\">\\[y\\]</span> ，即 <span class=\"math display\">\\[A_x\r\n&gt; A_y\\]</span> 和 <span class=\"math display\">\\[C_x &lt; C_y\\]</span>\r\n。弃牌 <span class=\"math display\">\\[y\\]</span> 。</li>\r\n</ul>\r\n<p>可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x.y&gt;&gt;a[i].x.x,a[i].y = i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>,a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = i;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[j].x.y &gt; mx) ans.<span class=\"built_in\">push_back</span>(a[j].y);</span><br><span class=\"line\">\t\tt = <span class=\"built_in\">max</span>(t, a[j].x.y);</span><br><span class=\"line\">\t\t<span class=\"comment\">// while(j&lt;n &amp;&amp; a[j+1].x.x == a[j].x.x)&#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tif(a[j].x.y &gt; mx) &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\t// cout&lt;&lt;a[j].y&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t\tans.push_back(a[j].y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tt = max(t, a[j].x.y);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// \tj++;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\">\t\tmx = <span class=\"built_in\">max</span>(t,mx);</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ans));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> idx: ans) cout&lt;&lt;idx&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"d---atcoder-wallpaper\"><a\r\nhref=\"https://atcoder.jp/contests/abc354/tasks/abc354_d\">D - AtCoder\r\nWallpaper</a></h2>\r\n<h2 id=\"题意-1\">题意</h2>\r\n<p>AtCoder 的壁纸图案可以在 <span class=\"math inline\">\\(xy\\)</span>\r\n(平面)上表示如下：</p>\r\n<ul>\r\n<li>该平面由以下三种线段划分：\r\n<ul>\r\n<li><span class=\"math display\">\\[x = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为整数)</li>\r\n<li><span class=\"math display\">\\[y = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为偶数)</li>\r\n<li><span class=\"math display\">\\[x + y = n\\]</span> (其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 为偶数)</li>\r\n</ul></li>\r\n<li>每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。</li>\r\n<li>包含 <span class=\"math display\">\\[(0.5, 0.5)\\]</span>\r\n的区域被涂成黑色。</li>\r\n</ul>\r\n<p>下图显示了图案的一部分。</p>\r\n<p><img src=\"https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png\" /></p>\r\n<p>给你整数 <span class=\"math display\">\\[A, B, C, D\\]</span>\r\n。考虑一个边平行于 <span class=\"math display\">\\[x\\]</span> - 和 <span\r\nclass=\"math display\">\\[y\\]</span> - 轴的矩形，它的左下顶点在 <span\r\nclass=\"math display\">\\[(A, B)\\]</span> ，右上顶点在 <span\r\nclass=\"math inline\">\\((C, D)\\)</span>\r\n。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。</p>\r\n<p>可以证明输出值将是一个整数。</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。</p>\r\n<p>对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。</p>\r\n<p>加上偏移量以确保两个数的正负号问题。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a,b,c,d;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">2</span> ; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j&lt;<span class=\"number\">4</span>; j++)&#123;</span><br><span class=\"line\">            ll x1 = (a - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>, x2 = (c - j + <span class=\"number\">3</span> + B)/<span class=\"number\">4</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> coux = x2 - x1;</span><br><span class=\"line\">            ll y1 = (b - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>, y2 = (d - i + <span class=\"number\">1</span> + B)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> couy = y2 - y1;</span><br><span class=\"line\">            ans += coux * couy * p[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e---remove-pairs-atcoder.jp\"><a\r\nhref=\"https://atcoder.jp/contests/abc354/tasks/abc354_e\">E - Remove\r\nPairs (atcoder.jp)</a></h2>\r\n<h2 id=\"题意-2\">题意</h2>\r\n<p>高桥和青木正在玩一个使用 <span class=\"math display\">\\[N\\]</span>\r\n张卡片的游戏。 <span class=\"math inline\">\\(￥\\)</span> 这张牌的正面写着\r\n<span class=\"math display\">\\[A_i\\]</span> ，背面写着 <span\r\nclass=\"math display\">\\[B_i\\]</span> 。最初， <span\r\nclass=\"math display\">\\[N\\]</span>\r\n这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：</p>\r\n<ul>\r\n<li>从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。</li>\r\n</ul>\r\n<p>最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是<span\r\nclass=\"math display\">\\[N \\leq 18\\]</span>!</p>\r\n<p>于是直接暴力位dp即可</p>\r\n<p>但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>;x&lt;n;x++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> y=x<span class=\"number\">+1</span>;y&lt;n;y++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>((i &gt;&gt; x &amp; <span class=\"number\">1</span>) &amp;&amp; (i &gt;&gt; y &amp; <span class=\"number\">1</span>) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t ((a[x].x==a[y].x) || (a[x].y == a[y].y)))&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i] |= !f[i^(<span class=\"number\">1</span>&lt;&lt;x)^(<span class=\"number\">1</span>&lt;&lt;y)];</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;x&lt;&lt; &#x27; &#x27;&lt;&lt;y&lt;&lt;&#x27; &#x27;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// \t&lt;&lt;(i^(1&lt;&lt;x)^(1&lt;&lt;y))&lt;&lt;&#x27; &#x27;&lt;&lt;f[i^(1&lt;&lt;x)^(1&lt;&lt;y)]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(f[(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]) cout&lt;&lt;<span class=\"string\">&quot;Takahashi\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;Aoki\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f---useless-for-lis-atcoder.jp\"><a\r\nhref=\"https://atcoder.jp/contests/abc354/tasks/abc354_f\">F - Useless for\r\nLIS (atcoder.jp)</a></h2>\r\n<h2 id=\"题意-3\">题意</h2>\r\n<p>给你一个长度为 <span class=\"math display\">\\[N\\]</span> 的整数序列\r\n<span class=\"math display\">\\[A\\]</span> 。</p>\r\n<p>对于每个 <span class=\"math display\">\\[t = 1, 2, \\dots, N\\]</span>\r\n，判断 <span class=\"math display\">\\[A_t\\]</span> 是否包含在 <span\r\nclass=\"math display\">\\[A\\]</span> 的最长递增子序列中。</p>\r\n<p>这里，当且仅当以下条件成立时， <span\r\nclass=\"math display\">\\[A_t\\]</span> 才包含在 <span\r\nclass=\"math inline\">\\(A\\)</span> 的最长递增子序列中：</p>\r\n<ul>\r\n<li><p>设 <span class=\"math display\">\\[L\\]</span> 是 <span\r\nclass=\"math display\">\\[A\\]</span>\r\n的最长递增子序列的长度。存在一个严格递增整数序列 <span\r\nclass=\"math display\">\\[i = (i_1, i_2, \\dots, i_L)  (i_1 &lt; i_2 &lt;\r\n\\dots &lt; i_ L)\\]</span> ，其中每个元素都介于 <span\r\nclass=\"math display\">\\[1\\]</span> 与 <span\r\nclass=\"math display\">\\[N\\]</span> 之间，且满足以下所有条件：</p>\r\n<ul>\r\n<li><span class=\"math display\">\\[A_{i_1}&lt;A_{i_2}&lt;\\dots&lt;A _{i\r\n_L}\\]</span> .</li>\r\n<li><span class=\"math display\">\\[i_k = t\\]</span> 为某个 <span\r\nclass=\"math display\">\\[k (1 \\leq k \\leq L)\\]</span> 。</li>\r\n</ul></li>\r\n</ul>\r\n<p>给你 <span class=\"math inline\">\\(T\\)</span>\r\n个测试用例，请逐个求解。</p>\r\n<p>什么是最长递增子序列？</p>\r\n<p>序列 <span class=\"math inline\">\\(A\\)</span> 的子序列是指从 <span\r\nclass=\"math inline\">\\(A\\)</span>\r\n中提取一些元素而不改变顺序所得到的序列。</p>\r\n<p>序列 <span class=\"math inline\">\\(A\\)</span> 的最长递增子序列是 <span\r\nclass=\"math inline\">\\(A\\)</span>\r\n的子序列，它以最大可能的长度严格递增。</p>\r\n<h2 id=\"题解-3\">题解</h2>\r\n<p>求不包含在样最长上升子序列中的数的下标集合</p>\r\n<p>回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值</p>\r\n<p>这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。</p>\r\n<p>可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。</p>\r\n<p>最后，数据范围离散化</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class=\"line\">\trt-&gt;val = <span class=\"built_in\">max</span>(l-&gt;val,r-&gt;val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(tr+u,tr+(u&lt;&lt;<span class=\"number\">1</span>),tr+ (u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\ttr[u]=&#123;l,r&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r) &#123;tr[u].val = <span class=\"number\">0</span>; <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(l,mid,u&lt;&lt;<span class=\"number\">1</span>,tr); <span class=\"built_in\">build</span>(mid<span class=\"number\">+1</span>,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tr[u].val;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> le = <span class=\"number\">0</span>,ri = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(l&lt;= mid) le = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(r &gt; mid) ri = <span class=\"built_in\">query</span>(l,r,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(le,ri);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> c,<span class=\"type\">int</span> u,Node* tr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class=\"line\">\t\ttr[u].val = c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x &lt;= mid) <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">modify</span>(x,c,u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push_up</span>(u,tr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ves;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tves.<span class=\"built_in\">push_back</span>(a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(ves));</span><br><span class=\"line\">\tves.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(ves)),ves.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;ves.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\tmp[ves[i]] = i<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,mp[a[i]]<span class=\"number\">-1</span>,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\tf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],f[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> maxx = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = <span class=\"built_in\">query</span>(mp[a[i]]<span class=\"number\">+1</span>,n,<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t\trf[i] = mx<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">modify</span>(mp[a[i]],rf[i],<span class=\"number\">1</span>,tr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;maxx&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// \tcout&lt;&lt;f[i]&lt;&lt; &#x27; &#x27; &lt;&lt; rf[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(f[i] + rf[i] - <span class=\"number\">1</span> == maxx)&#123;</span><br><span class=\"line\">\t\t\tans.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: ans) cout&lt;&lt;v&lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\tcout&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g---select-strings-atcoder.jp\"><a\r\nhref=\"https://atcoder.jp/contests/abc354/tasks/abc354_g\">G - Select\r\nStrings (atcoder.jp)</a></h2>\r\n<h2 id=\"题意-4\">题意</h2>\r\n<h2 id=\"题解-4\">题解</h2>\r\n"},{"title":"cf-edu165C","date":"2024-08-14T11:46:31.000Z","_content":"## 题意：\n\n有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。\n\n[Problem - C - Codeforces](https://codeforces.com/contest/1969/problem/C)\n\n<!--more-->\n\n## 题解：\n\n教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。\n\n但为什么不能采用别的解法呢？\n\n考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1\n\n> 2,1,1,2,5\n\n显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。\n\n注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。\n\n于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。\n\n考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。\n\n> [x,a,b,c,y] -> [x,x,x,x,y]->[x,x,y,y,y] 其中含有无意义的两步操作\n\n再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。\n\n下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。\n\n> 对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于$$a_k|k>ii \\&\\& k <= i$$，因此所需操作数为i-ii-1\n\n最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）\n\n```cpp\nvoid slove() {\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=m;j++)f[i][j] = LLINF;\n\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) pre[i] = a[i] + pre[i-1];\n    f[0][0] = 0;\n    for(int i=1;i<=n;i++) {\n        for(int ii=i-1;ii>=0 && i-ii-1 <= m;ii--) {\n            int t = i-ii-1;\n            for(int j=t;j<=m;j++) {\n                for(int k=ii+1;k<=i;k++) {\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    // cout<<i<<' '<<j<<' '<< f[i][j]<<nline;\n                }\n            }\n        }\n    }\n\n    int ans = LLINF;\n    for(int i=0;i<=m;i++) ans = min(ans,f[n][i]);\n    cout<<ans<<endl;\n}\n```\n","source":"_posts/cf-edu165C.md","raw":"---\ntitle: cf-edu165C\ndate: 2024-08-14 19:46:31\ntags: [算法, 思维题, 贪心，状态转移]\ncategories: \n\t- 算法\n\t- 思维题\n\t- 贪心\n---\n## 题意：\n\n有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。\n\n[Problem - C - Codeforces](https://codeforces.com/contest/1969/problem/C)\n\n<!--more-->\n\n## 题解：\n\n教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。\n\n但为什么不能采用别的解法呢？\n\n考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1\n\n> 2,1,1,2,5\n\n显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。\n\n注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。\n\n于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。\n\n考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。\n\n> [x,a,b,c,y] -> [x,x,x,x,y]->[x,x,y,y,y] 其中含有无意义的两步操作\n\n再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。\n\n下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。\n\n> 对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于$$a_k|k>ii \\&\\& k <= i$$，因此所需操作数为i-ii-1\n\n最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）\n\n```cpp\nvoid slove() {\n    cin>>n>>m;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=m;j++)f[i][j] = LLINF;\n\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) pre[i] = a[i] + pre[i-1];\n    f[0][0] = 0;\n    for(int i=1;i<=n;i++) {\n        for(int ii=i-1;ii>=0 && i-ii-1 <= m;ii--) {\n            int t = i-ii-1;\n            for(int j=t;j<=m;j++) {\n                for(int k=ii+1;k<=i;k++) {\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    f[i][j] = min(f[i][j],f[ii][j-t] + a[k] * (i-ii));\n                    // cout<<i<<' '<<j<<' '<< f[i][j]<<nline;\n                }\n            }\n        }\n    }\n\n    int ans = LLINF;\n    for(int i=0;i<=m;i++) ans = min(ans,f[n][i]);\n    cout<<ans<<endl;\n}\n```\n","slug":"cf-edu165C","published":1,"updated":"2024-08-15T01:57:07.026Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyt9000zwwwv47wre4sj","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9D\">Problem - C -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:)\r\n假的！），很容易想到用dp做法可以解。</p>\r\n<p>但为什么不能采用别的解法呢？</p>\r\n<p>考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1</p>\r\n<blockquote>\r\n<p>2,1,1,2,5</p>\r\n</blockquote>\r\n<p>显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。</p>\r\n<p>注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗?\r\n考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。</p>\r\n<p>于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。</p>\r\n<p>考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。</p>\r\n<blockquote>\r\n<p>[x,a,b,c,y] -&gt; [x,x,x,x,y]-&gt;[x,x,y,y,y]\r\n其中含有无意义的两步操作</p>\r\n</blockquote>\r\n<p>再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。</p>\r\n<p>下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。</p>\r\n<blockquote>\r\n<p>对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于<span\r\nclass=\"math display\">\\[a_k|k&gt;ii \\&amp;\\&amp; k &lt;=\r\ni\\]</span>，因此所需操作数为i-ii-1</p>\r\n</blockquote>\r\n<p>最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;j++)f[i][j] = LLINF;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = a[i] + pre[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=i<span class=\"number\">-1</span>;ii&gt;=<span class=\"number\">0</span> &amp;&amp; i-ii<span class=\"number\">-1</span> &lt;= m;ii--) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = i-ii<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=t;j&lt;=m;j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=ii<span class=\"number\">+1</span>;k&lt;=i;k++) &#123;</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt; f[i][j]&lt;&lt;nline;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans = LLINF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++) ans = <span class=\"built_in\">min</span>(ans,f[n][i]);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":875,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9D\">Problem - C -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:)\r\n假的！），很容易想到用dp做法可以解。</p>\r\n<p>但为什么不能采用别的解法呢？</p>\r\n<p>考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1</p>\r\n<blockquote>\r\n<p>2,1,1,2,5</p>\r\n</blockquote>\r\n<p>显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。</p>\r\n<p>注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗?\r\n考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。</p>\r\n<p>于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。</p>\r\n<p>考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。</p>\r\n<blockquote>\r\n<p>[x,a,b,c,y] -&gt; [x,x,x,x,y]-&gt;[x,x,y,y,y]\r\n其中含有无意义的两步操作</p>\r\n</blockquote>\r\n<p>再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。</p>\r\n<p>下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。</p>\r\n<blockquote>\r\n<p>对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于<span\r\nclass=\"math display\">\\[a_k|k&gt;ii \\&amp;\\&amp; k &lt;=\r\ni\\]</span>，因此所需操作数为i-ii-1</p>\r\n</blockquote>\r\n<p>最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;j++)f[i][j] = LLINF;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = a[i] + pre[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=i<span class=\"number\">-1</span>;ii&gt;=<span class=\"number\">0</span> &amp;&amp; i-ii<span class=\"number\">-1</span> &lt;= m;ii--) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = i-ii<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=t;j&lt;=m;j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=ii<span class=\"number\">+1</span>;k&lt;=i;k++) &#123;</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    f[i][j] = <span class=\"built_in\">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class=\"line\">                    <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt; f[i][j]&lt;&lt;nline;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ans = LLINF;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++) ans = <span class=\"built_in\">min</span>(ans,f[n][i]);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"cf-edu165D","date":"2024-08-14T11:45:21.000Z","_content":"## 题意：\n\n爱丽丝和鲍勃正在商店里玩游戏。商店里有 $$n$$ 件商品；每件商品有两个参数： $$a_i$$ （爱丽丝的物品价格）和 $$b_i$$ （鲍勃的物品价格）。\n\n爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：\n\n- 如果爱丽丝购买的物品少于 $$k$$ ，则鲍勃可以免费拿走所有物品；\n- 否则，他会免费拿走爱丽丝购买的$$k$$ 个物品（由鲍勃选择是哪个 $$k$$ 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 $$b_i$$。\n\n爱丽丝的利润等于 $$\\sum\\limits_{i \\in S} b_i - \\sum\\limits_{j \\in T} a_j$$ ，其中$$S$$ 是鲍勃从爱丽丝处购买的物品集， $$T$$ 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。\n\n爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。\n\n[Problem - D - Codeforces](https://codeforces.com/contest/1969/problem/D)\n\n<!--more-->\n\n## 题解：\n\n注意到，Bob在选择免费的时候显然是直接免费最大的$$b_i$$，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的$$b_i - a_i$$尽可能的大。\n\n先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n>count($$a_i<b_i$$)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。\n\n对于一个物品$$i$$，我们可以证明在$$a_i < b_i$$时该物品是必选的吗？如果我们选了这个物品：\n\n1. 并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它\n\n2. 被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。\n\n综上，无法确定在$$a_i < b_i$$时该物品是必选，对这个不等式的反也成立的物品也成立。\n\n注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。\n\n```cpp\nvoid slove() {\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) cin >> b[i];\n    vector<int> id(n);\n    for(int i=0;i<n;i++) id[i] = i;\n    sort(id.begin(), id.end(), [&](int x, int y){\n        if (b[x] != b[y]) return b[x] > b[y];\n        return a[x] < a[y];\n    });\n\n    // for(int i=0;i<n;i++) cout<<a[id[i]]<<' '<<b[id[i]]<<endl;\n    // cout<<nline;\n\n    ll s1 = 0, s2 = 0, ans = 0;\n    set<int> s;\n    for(int i = 0; i < k; i++){\n        s.insert(a[id[i]]);\n        s1 += a[id[i]];\n    }\n    for(int i = k; i < n; i++){\n        if (b[id[i]] > a[id[i]]){\n            s2 += b[id[i]] - a[id[i]];\n        }\n    }\n    for(int i = k; i < n; i++){\n        ans = max(ans, s2 - s1);\n        if (b[id[i]] > a[id[i]]){\n            s2 -= b[id[i]] - a[id[i]];\n        }\n        s.insert({a[id[i]], id[i]});\n        s1 += a[id[i]];\n        s1 -= *(--s.end());\n        s.erase(--s.end());\n    }\n    cout << ans << '\\n';\n}\n```\n","source":"_posts/cf-edu165D.md","raw":"---\ntitle: cf-edu165D\ndate: 2024-08-14 19:45:21\ntags: [算法, 博弈论, 不等式]\ncategories: \n\t- 算法\n\t- 数学\n\t- 博弈论\n---\n## 题意：\n\n爱丽丝和鲍勃正在商店里玩游戏。商店里有 $$n$$ 件商品；每件商品有两个参数： $$a_i$$ （爱丽丝的物品价格）和 $$b_i$$ （鲍勃的物品价格）。\n\n爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：\n\n- 如果爱丽丝购买的物品少于 $$k$$ ，则鲍勃可以免费拿走所有物品；\n- 否则，他会免费拿走爱丽丝购买的$$k$$ 个物品（由鲍勃选择是哪个 $$k$$ 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 $$b_i$$。\n\n爱丽丝的利润等于 $$\\sum\\limits_{i \\in S} b_i - \\sum\\limits_{j \\in T} a_j$$ ，其中$$S$$ 是鲍勃从爱丽丝处购买的物品集， $$T$$ 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。\n\n爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。\n\n[Problem - D - Codeforces](https://codeforces.com/contest/1969/problem/D)\n\n<!--more-->\n\n## 题解：\n\n注意到，Bob在选择免费的时候显然是直接免费最大的$$b_i$$，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的$$b_i - a_i$$尽可能的大。\n\n先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n>count($$a_i<b_i$$)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。\n\n对于一个物品$$i$$，我们可以证明在$$a_i < b_i$$时该物品是必选的吗？如果我们选了这个物品：\n\n1. 并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它\n\n2. 被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。\n\n综上，无法确定在$$a_i < b_i$$时该物品是必选，对这个不等式的反也成立的物品也成立。\n\n注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。\n\n```cpp\nvoid slove() {\n    cin >> n >> k;\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) cin >> b[i];\n    vector<int> id(n);\n    for(int i=0;i<n;i++) id[i] = i;\n    sort(id.begin(), id.end(), [&](int x, int y){\n        if (b[x] != b[y]) return b[x] > b[y];\n        return a[x] < a[y];\n    });\n\n    // for(int i=0;i<n;i++) cout<<a[id[i]]<<' '<<b[id[i]]<<endl;\n    // cout<<nline;\n\n    ll s1 = 0, s2 = 0, ans = 0;\n    set<int> s;\n    for(int i = 0; i < k; i++){\n        s.insert(a[id[i]]);\n        s1 += a[id[i]];\n    }\n    for(int i = k; i < n; i++){\n        if (b[id[i]] > a[id[i]]){\n            s2 += b[id[i]] - a[id[i]];\n        }\n    }\n    for(int i = k; i < n; i++){\n        ans = max(ans, s2 - s1);\n        if (b[id[i]] > a[id[i]]){\n            s2 -= b[id[i]] - a[id[i]];\n        }\n        s.insert({a[id[i]], id[i]});\n        s1 += a[id[i]];\n        s1 -= *(--s.end());\n        s.erase(--s.end());\n    }\n    cout << ans << '\\n';\n}\n```\n","slug":"cf-edu165D","published":1,"updated":"2024-08-14T13:38:37.760Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyta0011wwwvdmaie1c7","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>爱丽丝和鲍勃正在商店里玩游戏。商店里有 <span\r\nclass=\"math display\">\\[n\\]</span> 件商品；每件商品有两个参数： <span\r\nclass=\"math display\">\\[a_i\\]</span> （爱丽丝的物品价格）和 <span\r\nclass=\"math display\">\\[b_i\\]</span> （鲍勃的物品价格）。</p>\r\n<p>爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob\r\n会执行以下操作：</p>\r\n<ul>\r\n<li>如果爱丽丝购买的物品少于 <span class=\"math display\">\\[k\\]</span>\r\n，则鲍勃可以免费拿走所有物品；</li>\r\n<li>否则，他会免费拿走爱丽丝购买的<span\r\nclass=\"math display\">\\[k\\]</span> 个物品（由鲍勃选择是哪个 <span\r\nclass=\"math display\">\\[k\\]</span>\r\n个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 <span\r\nclass=\"math inline\">\\(i\\)</span> -个物品支付 <span\r\nclass=\"math display\">\\[b_i\\]</span>。</li>\r\n</ul>\r\n<p>爱丽丝的利润等于 <span class=\"math display\">\\[\\sum\\limits_{i \\in S}\r\nb_i - \\sum\\limits_{j \\in T} a_j\\]</span> ，其中<span\r\nclass=\"math display\">\\[S\\]</span> 是鲍勃从爱丽丝处购买的物品集， <span\r\nclass=\"math display\">\\[T\\]</span>\r\n是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。</p>\r\n<p>爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9E\">Problem - D -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>注意到，Bob在选择免费的时候显然是直接免费最大的<span\r\nclass=\"math display\">\\[b_i\\]</span>，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的<span\r\nclass=\"math display\">\\[b_i - a_i\\]</span>尽可能的大。</p>\r\n<p>先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n&gt;count(<span\r\nclass=\"math display\">\\[a_i&lt;b_i\\]</span>)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。</p>\r\n<p>对于一个物品<span\r\nclass=\"math display\">\\[i\\]</span>，我们可以证明在<span\r\nclass=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选的吗？如果我们选了这个物品：</p>\r\n<ol type=\"1\">\r\n<li><p>并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它</p></li>\r\n<li><p>被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。</p></li>\r\n</ol>\r\n<p>综上，无法确定在<span class=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选，对这个不等式的反也成立的物品也成立。</p>\r\n<p>注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span>, <span class=\"title\">b</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">id</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) id[i] = i;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(id.<span class=\"built_in\">begin</span>(), id.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[x] != b[y]) <span class=\"keyword\">return</span> b[x] &gt; b[y];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[x] &lt; a[y];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=0;i&lt;n;i++) cout&lt;&lt;a[id[i]]&lt;&lt;&#x27; &#x27;&lt;&lt;b[id[i]]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ll s1 = <span class=\"number\">0</span>, s2 = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++)&#123;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(a[id[i]]);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 += b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, s2 - s1);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 -= b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(&#123;a[id[i]], id[i]&#125;);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">        s1 -= *(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        s.<span class=\"built_in\">erase</span>(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":959,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>爱丽丝和鲍勃正在商店里玩游戏。商店里有 <span\r\nclass=\"math display\">\\[n\\]</span> 件商品；每件商品有两个参数： <span\r\nclass=\"math display\">\\[a_i\\]</span> （爱丽丝的物品价格）和 <span\r\nclass=\"math display\">\\[b_i\\]</span> （鲍勃的物品价格）。</p>\r\n<p>爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob\r\n会执行以下操作：</p>\r\n<ul>\r\n<li>如果爱丽丝购买的物品少于 <span class=\"math display\">\\[k\\]</span>\r\n，则鲍勃可以免费拿走所有物品；</li>\r\n<li>否则，他会免费拿走爱丽丝购买的<span\r\nclass=\"math display\">\\[k\\]</span> 个物品（由鲍勃选择是哪个 <span\r\nclass=\"math display\">\\[k\\]</span>\r\n个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 <span\r\nclass=\"math inline\">\\(i\\)</span> -个物品支付 <span\r\nclass=\"math display\">\\[b_i\\]</span>。</li>\r\n</ul>\r\n<p>爱丽丝的利润等于 <span class=\"math display\">\\[\\sum\\limits_{i \\in S}\r\nb_i - \\sum\\limits_{j \\in T} a_j\\]</span> ，其中<span\r\nclass=\"math display\">\\[S\\]</span> 是鲍勃从爱丽丝处购买的物品集， <span\r\nclass=\"math display\">\\[T\\]</span>\r\n是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。</p>\r\n<p>爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9E\">Problem - D -\r\nCodeforces<i class=\"fa fa-external-link-alt\"></i></span></p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>注意到，Bob在选择免费的时候显然是直接免费最大的<span\r\nclass=\"math display\">\\[b_i\\]</span>，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的<span\r\nclass=\"math display\">\\[b_i - a_i\\]</span>尽可能的大。</p>\r\n<p>先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n&gt;count(<span\r\nclass=\"math display\">\\[a_i&lt;b_i\\]</span>)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。</p>\r\n<p>对于一个物品<span\r\nclass=\"math display\">\\[i\\]</span>，我们可以证明在<span\r\nclass=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选的吗？如果我们选了这个物品：</p>\r\n<ol type=\"1\">\r\n<li><p>并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它</p></li>\r\n<li><p>被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。</p></li>\r\n</ol>\r\n<p>综上，无法确定在<span class=\"math display\">\\[a_i &lt;\r\nb_i\\]</span>时该物品是必选，对这个不等式的反也成立的物品也成立。</p>\r\n<p>注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span>, <span class=\"title\">b</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">id</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) id[i] = i;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(id.<span class=\"built_in\">begin</span>(), id.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[x] != b[y]) <span class=\"keyword\">return</span> b[x] &gt; b[y];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[x] &lt; a[y];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=0;i&lt;n;i++) cout&lt;&lt;a[id[i]]&lt;&lt;&#x27; &#x27;&lt;&lt;b[id[i]]&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ll s1 = <span class=\"number\">0</span>, s2 = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++)&#123;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(a[id[i]]);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 += b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, s2 - s1);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class=\"line\">            s2 -= b[id[i]] - a[id[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(&#123;a[id[i]], id[i]&#125;);</span><br><span class=\"line\">        s1 += a[id[i]];</span><br><span class=\"line\">        s1 -= *(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        s.<span class=\"built_in\">erase</span>(--s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"luogu蓝桥5_19","date":"2024-08-14T11:46:31.000Z","_content":"\n## B. 停车场\n\n[P10509 停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10509?contestId=174155)\n\n### 题意\n\n你有一片空地。这片空地可以视作一个一个 𝑛×𝑛 的正方形。空地外一圈为墙壁，你无法拆除它们。\n\n现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 1×1的正方形，且正方形的每条边与墙壁平行或者垂直。\n\n每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。\n\n下图为 𝑛=4 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png)\n\n请问 𝑛=2023 下最多能安排多少个停车位？\n\n### 题解\n\n这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸\n\n[云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/17rwjfcz)\n\n洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。\n\n这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png)\n\n直接构造可得\n\n答案为(2022+2021*(674*2-1)+673*2*2+3)\n\n## D. 方差\n\n[P10511 方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10511?contestId=174155)\n\n### 题意\n\n小 S 认为数学很简单，于是小 R 想要考考她。\n\n小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 `l r b`，表示 $a_l,a_{l+1},\\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。\n\n现在，小 R 有 $q$ 个问题。形如 `l r`，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。\n\n由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\\cdot s^2\\bmod 998244353$。可以证明 $(r-l+1)^2\\cdot s^2$ 一定是整数。\n\n作为小 S 的好朋友，你能帮帮她吗？\n\n### 题解\n\n推导一下公式发现结果是\n\n$$(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 - sum^2$$\n\n预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。\n\n但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题\n\n```cpp\nvoid slove() {\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++) {\n\t\tcin>>seg[i].l>>seg[i].r>>seg[i].v;\n\t\tseg[i].l %= MOD;\n\t\tseg[i].r %= MOD;\n\t\tseg[i].v %= MOD;\n\t}\n\n\t// sort(seg+1,seg+1+m);\n\n\tfor(int i=1;i<=m;i++){\n\t\tsegs[i] = segs[i-1] + ((((seg[i].r - seg[i].l  + 1) %MOD + MOD) %MOD) * seg[i].v) % MOD;\n\t\tsegs[i] %= MOD;\n\t\tsegs2[i] = segs2[i-1] + (((((seg[i].r - seg[i].l + 1) %MOD + MOD)%MOD) * seg[i].v %MOD)\n\t\t\t\t* seg[i].v) % MOD;\n\t\tsegs2[i] %= MOD;\n\t}\n\n\t// for(int i=1;i<=m;i++) cout<<segs[i]<<' '<<segs2[i]<<endl;\n\n\twhile(k--){\n\t\tint l,r;cin>>l>>r;\n\t\tint li = upper_bound(seg+1,seg+1+m,(Segment){l,0,0}) - seg - 1;\n\t\tint ri = upper_bound(seg+1,seg+1+m,(Segment){r,0,0}) - seg - 1;\n\t\t// cout<<\"###\"<<li<< ' ' << ri<<endl;\n\n\t\tif(li== ri)\n    \t{\n      \t\tcout<<0<<\"\\n\";\n      \t\tcontinue;\n    \t}\n\n\t\tint msum = ((segs[ri-1] - segs[li])%MOD + MOD) % MOD;\n\t\tmsum %= MOD;\n\t\tint rsum = (((r - seg[ri].l + 1) % MOD + MOD) % MOD * seg[ri].v) % MOD;\n\t\trsum %= MOD;\n\t\tint lsum = ((seg[li].r - l + 1 + MOD) % MOD * seg[li].v) % MOD;\n\t\tlsum %= MOD;\n\t\tint msum2 = ((segs2[ri-1] - segs2[li])%MOD + MOD) %MOD;\n\t\tmsum %=MOD;\n\t\tint rsum2 = ((((r - seg[ri].l + 1)%MOD + MOD) % MOD * seg[ri].v) % MOD\n\t\t\t\t* seg[ri].v) % MOD;\n\t\trsum2%=MOD;\n\t\tint lsum2 = ((((seg[li].r - l + 1) %MOD + MOD) % MOD * seg[li].v) % MOD\n\t\t\t\t*seg[li].v) %MOD;\n\t\tlsum2 %=MOD;\n\t\t// cout<<\"---\"<<lsum << ' '<<msum<< ' '<<rsum<<endl;\n\t\tint sum = lsum + msum % MOD + rsum %MOD;\n\t\tsum %=MOD;\n\t\tint sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;\n\t\tsum2%=MOD;\n\t\t// cout<<\"####\"<<sum<< ' '<< sum2<<endl;\n\t\tcout<<(((((r-l+1) %MOD + MOD) % MOD * sum2) % MOD -\n\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD<<endl;\n\t}\n}\n```\n\n## E. 序列合并\n\nhttps://www.luogu.com.cn/problem/P10512?contestId=174155\n\n## 题意\n\n给定一个长度为 𝑛的非负整数序列 {$$𝑎_𝑛$$}，你可以进行 𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。\n\n形式化地，一次操作中，你选择一个下标 𝑖*i*（1≤𝑖<𝑛1≤*i*<*n*），然后把原序列变成$${a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}$$。\n\n求 𝑘次操作后所有数按位与的最大值。\n\n## 题解\n\n首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大\n\n注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。\n\n要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。\n\n我觉得比取模题简单\n\n```CPP\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint ans = 0;\n\tfor(int i=29;~i;i--){\n\t\tint t = ans | (1<<i);\n\n\t\tint x = 0,cnt = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx |= a[i];\n\t\t\tif((x & t) == t) cnt++,x=0;\n\t\t}\n\t\tif(cnt >= n - k) {\n\t\t\tans = t;\n\t\t\t// cout<<cnt<<endl;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F. 括号\n\nhttps://www.luogu.com.cn/problem/P10513?contestId=174155\n\n### 题意\n\n圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 ```(``` 和 ```)``` 构成。\n\n她会对其做 $m$ 次操作，操作有两种类型：\n\n1. ```1 l r```，她会翻转 $l$ 到 $r$ 的括号，即 ```(``` 变 ```)```，```)``` 变 ```(```。\n1. ```2 l r```，她想知道区间 $\\left[ l,r\\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。\n\n\n圆认为以下的括号序列是合法的：\n\n1. 空序列是一个合法序列。\n\n1. 如果 ```A``` 是一个合法序列，则 ```(A)```  也是一个合法序列。\n\n1. 如果 ```A``` 和 ```B``` 都是合法序列，则 ```AB``` 也是一个合法序列。\n\n圆认为，序列 $a$ 的子序列是满足 $1\\le i_1<i_2<···<i_k \\le n$ 的序列 $[a_{i_1},a_{i_2},...a_{i_k}]$。\n\n由于操作太多了，她算不过来，请你帮帮她吧。\n\n### 题解\n\n洛谷真的要吓死我了，第六题线段树\n\n对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即\n\n$$ans=左边括号序列+右边括号序列+横跨中间的括号序列$$\n\n如何维护交换这一操作呢？\n\n我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。\n\n```cpp\nstruct node {\n\tint l,r,ans;\n\tnode(int x=0,int y=0,int z=0){l=x,r=y,ans=z;}\n};\nstruct tree{int tag;node t1,t2;}t[N<<2];\nchar s[N];\n\nnode merge(node x,node y)\n{\n    int cnt=min(x.l,y.r);\n    return {x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt};\n}\ninline void pushup(int p){t[p].t1=merge(t[ls].t1,t[rs].t1);t[p].t2=merge(t[ls].t2,t[rs].t2);}\ninline void pushson(int p){swap(t[p].t1,t[p].t2);t[p].tag^=1;}\ninline void pushdown(int p){if(!t[p].tag) return;pushson(ls),pushson(rs);t[p].tag=0;}\ninline void build(int p,int l,int r)\n{\n    if(l==r) return t[p].t2.r=t[p].t1.l=(s[l]=='('),t[p].t2.l=t[p].t1.r=(s[l]==')'),void();\n    build(ls,l,mid);build(rs,mid+1,r);pushup(p);\n}\ninline void modify(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return pushson(p);pushdown(p);\n    if(mid>=s) modify(ls,l,mid,s,e);if(mid<e) modify(rs,mid+1,r,s,e);\n    pushup(p);\n}\ninline node query(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return t[p].t1;pushdown(p);\n    if(e<=mid) return query(ls,l,mid,s,e);\n    if(s>mid) return query(rs,mid+1,r,s,e);\n    return merge(query(ls,l,mid,s,e),query(rs,mid+1,r,s,e));\n}\n\nvoid slove() {\n\tcin>>n;\n\tcin>>s+1;\n\tbuild(1,1,n);\n\tcin>>m;\n\twhile(m--){\n\t\tint op,l,r;cin>>op>>l>>r;\n\t\tif(op == 1) {\n\t\t\tmodify(1,1,n,l,r);\n\t\t}else {\n\t\t\tcout<<query(1,1,n,l,r).ans<<endl;\n\t\t}\n\t}\n}\n```\n\n## G.考试\n\nhttps://www.luogu.com.cn/problem/P10514?contestId=174155\n\n### 题意\n\n有 $n$ 名同学去参加考试，考试有 $m$ 道题。\n\n每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。\n\n考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。\n\n### 题解\n\n数学题。。。 懒得打公式了，如下\n\n![image-20240527221944431](https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png)\n\n预处理阶乘，快速幂分母时间复杂度为log(m)+n\n\n处理分子时间复杂度为mlog(n)\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tfac[0] = infac[0] = 1;\n\tfor(int i=1;i<N;i++){\n\t\tfac[i] = fac[i-1] *i % MOD;\n\t\tinfac[i] = infac[i-1] * qmi(i,MOD-2,MOD) % MOD;\n\t\t// cout<<fac[i]<<' ' <<infac[i]<<endl;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>m>>k;\n\n\tint mx = 0;\n\tfor(int i=1;i<=m;i++) cin>>a[i], mx= max(mx,a[i]);\n\n\tif(mx + k > n) {cout<<0<<endl;return ;}\n\n\tint inv = qmi(qmi(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD-2,MOD);\n\n\tint factor = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;\n\t}\n\n\tcout<<factor*inv % MOD<<endl;\n}\n```\n\n## H. 转圈、按钮P4861\n\nhttps://www.luogu.com.cn/problem/P10515?contestId=174155\n\n### 题意\n\n小 $\\delta$ 喜欢转圈圈。\n\n他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \\times m$，他现在站在第一个格子上。\n\n接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。\n\n求最终被小 $\\delta$ 踩到过的格子的数量。由于小 $\\delta$ 有很多圈圈，所以他会问你很多次。\n\n### 题解\n\n这题和P4861撞了，所以我干脆贴这题了\n\n根据欧拉定理$$a^{\\phi(p)}= 1 (modp)$$\n\n因此$$\\phi(p)$$一定是答案的倍数，我们只需要枚举它的因子即可\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\nint gcd(int x,int y){return y? gcd(y,x%y): x;}\n\nvoid init(){}\n\nint get_phi(int x){\n\tint res = x;\n\tif(!(x&1)) res >>= 1;\n\n\tfor(int i=3;i*i<=x; i+= 2){\n\t\tif(x % i == 0){\n\t\t\tres -= res /i;\n\t\t\twhile(x % i == 0) x/=i;\n\t\t}\n\t}\n\tif(x > 1) res -= res / x;\n\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n>>m;\n\tif(gcd(n,m)!=1)puts(\"Let's go Blue Jays!\");//无解\n    else{\n        int p=get_phi(n);//得到phi\n        int mm=p;\n        int tot = 0;\n        for(int i=2;(i*i)<=mm;i++){\n            if(mm%i)continue;\n            pri[++tot]=i;\n            while(mm%i==0){\n                mm/=i;\n                tim[tot]++;\n            }\n        }\n        if(mm!=1){\n            pri[++tot]=mm;\n            tim[tot]=1;\n        }\n\n        int ss=1,qq=p;\n        while(ss<=tot){\n            for(int i=1;i<=tim[ss];i++){\n                if(qmi(m,qq/pri[ss],n)==1)qq/=pri[ss];\n                else break;\n            }\n            ss++;\n        }\n        cout<<qq<<endl;\n    }\n}\n```\n","source":"_posts/luogu蓝桥5_19.md","raw":"---\ntitle: luogu蓝桥5_19\ndate: 2024-08-14 19:46:31\ntags: [luogu]\ncategories: \n\t- 比赛\n\t- 模拟赛\n\t- 蓝桥模拟\n---\n\n## B. 停车场\n\n[P10509 停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10509?contestId=174155)\n\n### 题意\n\n你有一片空地。这片空地可以视作一个一个 𝑛×𝑛 的正方形。空地外一圈为墙壁，你无法拆除它们。\n\n现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 1×1的正方形，且正方形的每条边与墙壁平行或者垂直。\n\n每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。\n\n下图为 𝑛=4 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png)\n\n请问 𝑛=2023 下最多能安排多少个停车位？\n\n### 题解\n\n这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸\n\n[云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/17rwjfcz)\n\n洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。\n\n这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png)\n\n直接构造可得\n\n答案为(2022+2021*(674*2-1)+673*2*2+3)\n\n## D. 方差\n\n[P10511 方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10511?contestId=174155)\n\n### 题意\n\n小 S 认为数学很简单，于是小 R 想要考考她。\n\n小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 `l r b`，表示 $a_l,a_{l+1},\\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。\n\n现在，小 R 有 $q$ 个问题。形如 `l r`，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。\n\n由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\\cdot s^2\\bmod 998244353$。可以证明 $(r-l+1)^2\\cdot s^2$ 一定是整数。\n\n作为小 S 的好朋友，你能帮帮她吗？\n\n### 题解\n\n推导一下公式发现结果是\n\n$$(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 - sum^2$$\n\n预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。\n\n但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题\n\n```cpp\nvoid slove() {\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++) {\n\t\tcin>>seg[i].l>>seg[i].r>>seg[i].v;\n\t\tseg[i].l %= MOD;\n\t\tseg[i].r %= MOD;\n\t\tseg[i].v %= MOD;\n\t}\n\n\t// sort(seg+1,seg+1+m);\n\n\tfor(int i=1;i<=m;i++){\n\t\tsegs[i] = segs[i-1] + ((((seg[i].r - seg[i].l  + 1) %MOD + MOD) %MOD) * seg[i].v) % MOD;\n\t\tsegs[i] %= MOD;\n\t\tsegs2[i] = segs2[i-1] + (((((seg[i].r - seg[i].l + 1) %MOD + MOD)%MOD) * seg[i].v %MOD)\n\t\t\t\t* seg[i].v) % MOD;\n\t\tsegs2[i] %= MOD;\n\t}\n\n\t// for(int i=1;i<=m;i++) cout<<segs[i]<<' '<<segs2[i]<<endl;\n\n\twhile(k--){\n\t\tint l,r;cin>>l>>r;\n\t\tint li = upper_bound(seg+1,seg+1+m,(Segment){l,0,0}) - seg - 1;\n\t\tint ri = upper_bound(seg+1,seg+1+m,(Segment){r,0,0}) - seg - 1;\n\t\t// cout<<\"###\"<<li<< ' ' << ri<<endl;\n\n\t\tif(li== ri)\n    \t{\n      \t\tcout<<0<<\"\\n\";\n      \t\tcontinue;\n    \t}\n\n\t\tint msum = ((segs[ri-1] - segs[li])%MOD + MOD) % MOD;\n\t\tmsum %= MOD;\n\t\tint rsum = (((r - seg[ri].l + 1) % MOD + MOD) % MOD * seg[ri].v) % MOD;\n\t\trsum %= MOD;\n\t\tint lsum = ((seg[li].r - l + 1 + MOD) % MOD * seg[li].v) % MOD;\n\t\tlsum %= MOD;\n\t\tint msum2 = ((segs2[ri-1] - segs2[li])%MOD + MOD) %MOD;\n\t\tmsum %=MOD;\n\t\tint rsum2 = ((((r - seg[ri].l + 1)%MOD + MOD) % MOD * seg[ri].v) % MOD\n\t\t\t\t* seg[ri].v) % MOD;\n\t\trsum2%=MOD;\n\t\tint lsum2 = ((((seg[li].r - l + 1) %MOD + MOD) % MOD * seg[li].v) % MOD\n\t\t\t\t*seg[li].v) %MOD;\n\t\tlsum2 %=MOD;\n\t\t// cout<<\"---\"<<lsum << ' '<<msum<< ' '<<rsum<<endl;\n\t\tint sum = lsum + msum % MOD + rsum %MOD;\n\t\tsum %=MOD;\n\t\tint sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;\n\t\tsum2%=MOD;\n\t\t// cout<<\"####\"<<sum<< ' '<< sum2<<endl;\n\t\tcout<<(((((r-l+1) %MOD + MOD) % MOD * sum2) % MOD -\n\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD<<endl;\n\t}\n}\n```\n\n## E. 序列合并\n\nhttps://www.luogu.com.cn/problem/P10512?contestId=174155\n\n## 题意\n\n给定一个长度为 𝑛的非负整数序列 {$$𝑎_𝑛$$}，你可以进行 𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。\n\n形式化地，一次操作中，你选择一个下标 𝑖*i*（1≤𝑖<𝑛1≤*i*<*n*），然后把原序列变成$${a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}$$。\n\n求 𝑘次操作后所有数按位与的最大值。\n\n## 题解\n\n首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大\n\n注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。\n\n要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。\n\n我觉得比取模题简单\n\n```CPP\nvoid slove() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\n\tint ans = 0;\n\tfor(int i=29;~i;i--){\n\t\tint t = ans | (1<<i);\n\n\t\tint x = 0,cnt = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx |= a[i];\n\t\t\tif((x & t) == t) cnt++,x=0;\n\t\t}\n\t\tif(cnt >= n - k) {\n\t\t\tans = t;\n\t\t\t// cout<<cnt<<endl;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n}\n```\n\n## F. 括号\n\nhttps://www.luogu.com.cn/problem/P10513?contestId=174155\n\n### 题意\n\n圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 ```(``` 和 ```)``` 构成。\n\n她会对其做 $m$ 次操作，操作有两种类型：\n\n1. ```1 l r```，她会翻转 $l$ 到 $r$ 的括号，即 ```(``` 变 ```)```，```)``` 变 ```(```。\n1. ```2 l r```，她想知道区间 $\\left[ l,r\\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。\n\n\n圆认为以下的括号序列是合法的：\n\n1. 空序列是一个合法序列。\n\n1. 如果 ```A``` 是一个合法序列，则 ```(A)```  也是一个合法序列。\n\n1. 如果 ```A``` 和 ```B``` 都是合法序列，则 ```AB``` 也是一个合法序列。\n\n圆认为，序列 $a$ 的子序列是满足 $1\\le i_1<i_2<···<i_k \\le n$ 的序列 $[a_{i_1},a_{i_2},...a_{i_k}]$。\n\n由于操作太多了，她算不过来，请你帮帮她吧。\n\n### 题解\n\n洛谷真的要吓死我了，第六题线段树\n\n对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即\n\n$$ans=左边括号序列+右边括号序列+横跨中间的括号序列$$\n\n如何维护交换这一操作呢？\n\n我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。\n\n```cpp\nstruct node {\n\tint l,r,ans;\n\tnode(int x=0,int y=0,int z=0){l=x,r=y,ans=z;}\n};\nstruct tree{int tag;node t1,t2;}t[N<<2];\nchar s[N];\n\nnode merge(node x,node y)\n{\n    int cnt=min(x.l,y.r);\n    return {x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt};\n}\ninline void pushup(int p){t[p].t1=merge(t[ls].t1,t[rs].t1);t[p].t2=merge(t[ls].t2,t[rs].t2);}\ninline void pushson(int p){swap(t[p].t1,t[p].t2);t[p].tag^=1;}\ninline void pushdown(int p){if(!t[p].tag) return;pushson(ls),pushson(rs);t[p].tag=0;}\ninline void build(int p,int l,int r)\n{\n    if(l==r) return t[p].t2.r=t[p].t1.l=(s[l]=='('),t[p].t2.l=t[p].t1.r=(s[l]==')'),void();\n    build(ls,l,mid);build(rs,mid+1,r);pushup(p);\n}\ninline void modify(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return pushson(p);pushdown(p);\n    if(mid>=s) modify(ls,l,mid,s,e);if(mid<e) modify(rs,mid+1,r,s,e);\n    pushup(p);\n}\ninline node query(int p,int l,int r,int s,int e)\n{\n    if(l>=s&&r<=e) return t[p].t1;pushdown(p);\n    if(e<=mid) return query(ls,l,mid,s,e);\n    if(s>mid) return query(rs,mid+1,r,s,e);\n    return merge(query(ls,l,mid,s,e),query(rs,mid+1,r,s,e));\n}\n\nvoid slove() {\n\tcin>>n;\n\tcin>>s+1;\n\tbuild(1,1,n);\n\tcin>>m;\n\twhile(m--){\n\t\tint op,l,r;cin>>op>>l>>r;\n\t\tif(op == 1) {\n\t\t\tmodify(1,1,n,l,r);\n\t\t}else {\n\t\t\tcout<<query(1,1,n,l,r).ans<<endl;\n\t\t}\n\t}\n}\n```\n\n## G.考试\n\nhttps://www.luogu.com.cn/problem/P10514?contestId=174155\n\n### 题意\n\n有 $n$ 名同学去参加考试，考试有 $m$ 道题。\n\n每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。\n\n考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。\n\n### 题解\n\n数学题。。。 懒得打公式了，如下\n\n![image-20240527221944431](https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png)\n\n预处理阶乘，快速幂分母时间复杂度为log(m)+n\n\n处理分子时间复杂度为mlog(n)\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tfac[0] = infac[0] = 1;\n\tfor(int i=1;i<N;i++){\n\t\tfac[i] = fac[i-1] *i % MOD;\n\t\tinfac[i] = infac[i-1] * qmi(i,MOD-2,MOD) % MOD;\n\t\t// cout<<fac[i]<<' ' <<infac[i]<<endl;\n\t}\n}\n\nvoid slove() {\n\tcin>>n>>m>>k;\n\n\tint mx = 0;\n\tfor(int i=1;i<=m;i++) cin>>a[i], mx= max(mx,a[i]);\n\n\tif(mx + k > n) {cout<<0<<endl;return ;}\n\n\tint inv = qmi(qmi(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD-2,MOD);\n\n\tint factor = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;\n\t}\n\n\tcout<<factor*inv % MOD<<endl;\n}\n```\n\n## H. 转圈、按钮P4861\n\nhttps://www.luogu.com.cn/problem/P10515?contestId=174155\n\n### 题意\n\n小 $\\delta$ 喜欢转圈圈。\n\n他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \\times m$，他现在站在第一个格子上。\n\n接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。\n\n求最终被小 $\\delta$ 踩到过的格子的数量。由于小 $\\delta$ 有很多圈圈，所以他会问你很多次。\n\n### 题解\n\n这题和P4861撞了，所以我干脆贴这题了\n\n根据欧拉定理$$a^{\\phi(p)}= 1 (modp)$$\n\n因此$$\\phi(p)$$一定是答案的倍数，我们只需要枚举它的因子即可\n\n```cpp\nll qmi(ll a,ll b,ll mod = MOD){\n\tll res = 1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\nint gcd(int x,int y){return y? gcd(y,x%y): x;}\n\nvoid init(){}\n\nint get_phi(int x){\n\tint res = x;\n\tif(!(x&1)) res >>= 1;\n\n\tfor(int i=3;i*i<=x; i+= 2){\n\t\tif(x % i == 0){\n\t\t\tres -= res /i;\n\t\t\twhile(x % i == 0) x/=i;\n\t\t}\n\t}\n\tif(x > 1) res -= res / x;\n\n\treturn res;\n}\n\nvoid slove() {\n\tcin>>n>>m;\n\tif(gcd(n,m)!=1)puts(\"Let's go Blue Jays!\");//无解\n    else{\n        int p=get_phi(n);//得到phi\n        int mm=p;\n        int tot = 0;\n        for(int i=2;(i*i)<=mm;i++){\n            if(mm%i)continue;\n            pri[++tot]=i;\n            while(mm%i==0){\n                mm/=i;\n                tim[tot]++;\n            }\n        }\n        if(mm!=1){\n            pri[++tot]=mm;\n            tim[tot]=1;\n        }\n\n        int ss=1,qq=p;\n        while(ss<=tot){\n            for(int i=1;i<=tim[ss];i++){\n                if(qmi(m,qq/pri[ss],n)==1)qq/=pri[ss];\n                else break;\n            }\n            ss++;\n        }\n        cout<<qq<<endl;\n    }\n}\n```\n","slug":"luogu蓝桥5_19","published":1,"updated":"2024-08-15T03:48:29.907Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyta0014wwwv8t978845","content":"<h2 id=\"b.-停车场\">B. 停车场</h2>\r\n<p><a\r\nhref=\"https://www.luogu.com.cn/problem/P10509?contestId=174155\">P10509\r\n停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>你有一片空地。这片空地可以视作一个一个 𝑛×𝑛\r\n的正方形。空地外一圈为墙壁，你无法拆除它们。</p>\r\n<p>现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是\r\n1×1的正方形，且正方形的每条边与墙壁平行或者垂直。</p>\r\n<p>每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。</p>\r\n<p>下图为 𝑛=4\r\n时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。</p>\r\n<figure>\r\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>请问 𝑛=2023 下最多能安排多少个停车位？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Bhc3RlLzE3cndqZmN6\">云剪贴板 - 洛谷 |\r\n计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。</p>\r\n<p>这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种</p>\r\n<figure>\r\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>直接构造可得</p>\r\n<p>答案为(2022+2021<em>(674</em>2-1)+673<em>2</em>2+3)</p>\r\n<h2 id=\"d.-方差\">D. 方差</h2>\r\n<p><a\r\nhref=\"https://www.luogu.com.cn/problem/P10511?contestId=174155\">P10511\r\n方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>小 S 认为数学很简单，于是小 R 想要考考她。</p>\r\n<p>小 R 给了小 S 一个序列 <span\r\nclass=\"math inline\">\\(a\\)</span>，这个序列由 <span\r\nclass=\"math inline\">\\(m\\)</span> 段构成，第 <span\r\nclass=\"math inline\">\\(i\\)</span> 段被表示为 <code>l r b</code>，表示\r\n<span class=\"math inline\">\\(a_l,a_{l+1},\\ldots,a_r\\)</span> 为 <span\r\nclass=\"math inline\">\\(b\\)</span>，保证给出的任意两个区间不相交。</p>\r\n<p>现在，小 R 有 <span class=\"math inline\">\\(q\\)</span> 个问题。形如\r\n<code>l r</code>，想让你查询区间 <span\r\nclass=\"math inline\">\\([l,r]\\)</span> 的方差 <span\r\nclass=\"math inline\">\\(s^2\\)</span>（需要注意：<span\r\nclass=\"math inline\">\\(l\\)</span> 可能等于 <span\r\nclass=\"math inline\">\\(r\\)</span>，此时该段方差为 <span\r\nclass=\"math inline\">\\(0\\)</span>）。</p>\r\n<p>由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出\r\n<span class=\"math inline\">\\((r-l+1)^2\\cdot s^2\\bmod\r\n998244353\\)</span>。可以证明 <span class=\"math inline\">\\((r-l+1)^2\\cdot\r\ns^2\\)</span> 一定是整数。</p>\r\n<p>作为小 S 的好朋友，你能帮帮她吗？</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>推导一下公式发现结果是</p>\r\n<p><span class=\"math display\">\\[(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 -\r\nsum^2\\]</span></p>\r\n<p>预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。</p>\r\n<p>但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;seg[i].l&gt;&gt;seg[i].r&gt;&gt;seg[i].v;</span><br><span class=\"line\">\t\tseg[i].l %= MOD;</span><br><span class=\"line\">\t\tseg[i].r %= MOD;</span><br><span class=\"line\">\t\tseg[i].v %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sort(seg+1,seg+1+m);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tsegs[i] = segs[i<span class=\"number\">-1</span>] + ((((seg[i].r - seg[i].l  + <span class=\"number\">1</span>) %MOD + MOD) %MOD) * seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs[i] %= MOD;</span><br><span class=\"line\">\t\tsegs2[i] = segs2[i<span class=\"number\">-1</span>] + (((((seg[i].r - seg[i].l + <span class=\"number\">1</span>) %MOD + MOD)%MOD) * seg[i].v %MOD)</span><br><span class=\"line\">\t\t\t\t* seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs2[i] %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=m;i++) cout&lt;&lt;segs[i]&lt;&lt;&#x27; &#x27;&lt;&lt;segs2[i]&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(k--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> li = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;l,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ri = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;r,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;li&lt;&lt; &#x27; &#x27; &lt;&lt; ri&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(li== ri)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">      \t\tcout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum = ((segs[ri<span class=\"number\">-1</span>] - segs[li])%MOD + MOD) % MOD;</span><br><span class=\"line\">\t\tmsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum = (((r - seg[ri].l + <span class=\"number\">1</span>) % MOD + MOD) % MOD * seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum = ((seg[li].r - l + <span class=\"number\">1</span> + MOD) % MOD * seg[li].v) % MOD;</span><br><span class=\"line\">\t\tlsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum2 = ((segs2[ri<span class=\"number\">-1</span>] - segs2[li])%MOD + MOD) %MOD;</span><br><span class=\"line\">\t\tmsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum2 = ((((r - seg[ri].l + <span class=\"number\">1</span>)%MOD + MOD) % MOD * seg[ri].v) % MOD</span><br><span class=\"line\">\t\t\t\t* seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum2 = ((((seg[li].r - l + <span class=\"number\">1</span>) %MOD + MOD) % MOD * seg[li].v) % MOD</span><br><span class=\"line\">\t\t\t\t*seg[li].v) %MOD;</span><br><span class=\"line\">\t\tlsum2 %=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;lsum &lt;&lt; &#x27; &#x27;&lt;&lt;msum&lt;&lt; &#x27; &#x27;&lt;&lt;rsum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum = lsum + msum % MOD + rsum %MOD;</span><br><span class=\"line\">\t\tsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;</span><br><span class=\"line\">\t\tsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;####&quot;&lt;&lt;sum&lt;&lt; &#x27; &#x27;&lt;&lt; sum2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tcout&lt;&lt;(((((r-l<span class=\"number\">+1</span>) %MOD + MOD) % MOD * sum2) % MOD -</span><br><span class=\"line\">\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e.-序列合并\">E. 序列合并</h2>\r\n<p>https://www.luogu.com.cn/problem/P10512?contestId=174155</p>\r\n<h2 id=\"题意-2\">题意</h2>\r\n<p>给定一个长度为 𝑛的非负整数序列 {<span\r\nclass=\"math display\">\\[𝑎_𝑛\\]</span>}，你可以进行\r\n𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。</p>\r\n<p>形式化地，一次操作中，你选择一个下标\r\n𝑖<em>i</em>（1≤𝑖&lt;𝑛1≤<em>i</em>&lt;<em>n</em>），然后把原序列变成<span\r\nclass=\"math display\">\\[{a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}\\]</span>。</p>\r\n<p>求 𝑘次操作后所有数按位与的最大值。</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大</p>\r\n<p>注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。</p>\r\n<p>要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。</p>\r\n<p>我觉得比取模题简单</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">29</span>;~i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = ans | (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tx |= a[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((x &amp; t) == t) cnt++,x=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &gt;= n - k) &#123;</span><br><span class=\"line\">\t\t\tans = t;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f.-括号\">F. 括号</h2>\r\n<p>https://www.luogu.com.cn/problem/P10513?contestId=174155</p>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p>圆给了你一个长度为 <span class=\"math inline\">\\(n\\)</span> 的字符串\r\n<span class=\"math inline\">\\(S\\)</span>，<span\r\nclass=\"math inline\">\\(S\\)</span> 仅由 <code>(</code> 和 <code>)</code>\r\n构成。</p>\r\n<p>她会对其做 <span class=\"math inline\">\\(m\\)</span>\r\n次操作，操作有两种类型：</p>\r\n<ol type=\"1\">\r\n<li><code>1 l r</code>，她会翻转 <span class=\"math inline\">\\(l\\)</span>\r\n到 <span class=\"math inline\">\\(r\\)</span> 的括号，即 <code>(</code> 变\r\n<code>)</code>，<code>)</code> 变 <code>(</code>。</li>\r\n<li><code>2 l r</code>，她想知道区间 <span class=\"math inline\">\\(\\left[\r\nl,r\\right]\\)</span> 中最长合法括号子序列的长度除以 <span\r\nclass=\"math inline\">\\(2\\)</span> 的答案。</li>\r\n</ol>\r\n<p>圆认为以下的括号序列是合法的：</p>\r\n<ol type=\"1\">\r\n<li><p>空序列是一个合法序列。</p></li>\r\n<li><p>如果 <code>A</code> 是一个合法序列，则 <code>(A)</code>\r\n也是一个合法序列。</p></li>\r\n<li><p>如果 <code>A</code> 和 <code>B</code> 都是合法序列，则\r\n<code>AB</code> 也是一个合法序列。</p></li>\r\n</ol>\r\n<p>圆认为，序列 <span class=\"math inline\">\\(a\\)</span> 的子序列是满足\r\n<span class=\"math inline\">\\(1\\le i_1&lt;i_2&lt;···&lt;i_k \\le n\\)</span>\r\n的序列 <span\r\nclass=\"math inline\">\\([a_{i_1},a_{i_2},...a_{i_k}]\\)</span>。</p>\r\n<p>由于操作太多了，她算不过来，请你帮帮她吧。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>洛谷真的要吓死我了，第六题线段树</p>\r\n<p>对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即</p>\r\n<p><span\r\nclass=\"math display\">\\[ans=左边括号序列+右边括号序列+横跨中间的括号序列\\]</span></p>\r\n<p>如何维护交换这一操作呢？</p>\r\n<p>我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,ans;</span><br><span class=\"line\">\t<span class=\"built_in\">node</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>,<span class=\"type\">int</span> y=<span class=\"number\">0</span>,<span class=\"type\">int</span> z=<span class=\"number\">0</span>)&#123;l=x,r=y,ans=z;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tree</span>&#123;<span class=\"type\">int</span> tag;node t1,t2;&#125;t[N&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">merge</span><span class=\"params\">(node x,node y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt=<span class=\"built_in\">min</span>(x.l,y.r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;t[p].t1=<span class=\"built_in\">merge</span>(t[ls].t1,t[rs].t1);t[p].t2=<span class=\"built_in\">merge</span>(t[ls].t2,t[rs].t2);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushson</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"built_in\">swap</span>(t[p].t1,t[p].t2);t[p].tag^=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"keyword\">if</span>(!t[p].tag) <span class=\"keyword\">return</span>;<span class=\"built_in\">pushson</span>(ls),<span class=\"built_in\">pushson</span>(rs);t[p].tag=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r) <span class=\"keyword\">return</span> t[p].t<span class=\"number\">2.</span>r=t[p].t<span class=\"number\">1.l</span>=(s[l]==<span class=\"string\">&#x27;(&#x27;</span>),t[p].t<span class=\"number\">2.l</span>=t[p].t<span class=\"number\">1.</span>r=(s[l]==<span class=\"string\">&#x27;)&#x27;</span>),<span class=\"built_in\">void</span>();</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(ls,l,mid);<span class=\"built_in\">build</span>(rs,mid<span class=\"number\">+1</span>,r);<span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> <span class=\"built_in\">pushson</span>(p);<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&gt;=s) <span class=\"built_in\">modify</span>(ls,l,mid,s,e);<span class=\"keyword\">if</span>(mid&lt;e) <span class=\"built_in\">modify</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> t[p].t1;<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e&lt;=mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(ls,l,mid,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s&gt;mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">merge</span>(<span class=\"built_in\">query</span>(ls,l,mid,s,e),<span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tcin&gt;&gt;s<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op,l,r;cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r).ans&lt;&lt;endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g.考试\">G.考试</h2>\r\n<p>https://www.luogu.com.cn/problem/P10514?contestId=174155</p>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>有 <span class=\"math inline\">\\(n\\)</span> 名同学去参加考试，考试有\r\n<span class=\"math inline\">\\(m\\)</span> 道题。</p>\r\n<p>每个学生的实力是相同的，但是每道题的难度可能不同。第 <span\r\nclass=\"math inline\">\\(i\\)</span> 道题会有随机的 <span\r\nclass=\"math inline\">\\(a_i\\)</span> 名同学做错。</p>\r\n<p>考试结束后，随机选出 <span class=\"math inline\">\\(k\\)</span>\r\n名同学，求出这些同学全部做对的概率。答案对 <span\r\nclass=\"math inline\">\\(998244353\\)</span> 取模。</p>\r\n<h3 id=\"题解-4\">题解</h3>\r\n<p>数学题。。。 懒得打公式了，如下</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png\"\r\nalt=\"image-20240527221944431\" />\r\n<figcaption aria-hidden=\"true\">image-20240527221944431</figcaption>\r\n</figure>\r\n<p>预处理阶乘，快速幂分母时间复杂度为log(m)+n</p>\r\n<p>处理分子时间复杂度为mlog(n)</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tfac[<span class=\"number\">0</span>] = infac[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">\t\tfac[i] = fac[i<span class=\"number\">-1</span>] *i % MOD;</span><br><span class=\"line\">\t\tinfac[i] = infac[i<span class=\"number\">-1</span>] * <span class=\"built_in\">qmi</span>(i,MOD<span class=\"number\">-2</span>,MOD) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;fac[i]&lt;&lt;&#x27; &#x27; &lt;&lt;infac[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i], mx= <span class=\"built_in\">max</span>(mx,a[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(mx + k &gt; n) &#123;cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;<span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> inv = <span class=\"built_in\">qmi</span>(<span class=\"built_in\">qmi</span>(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD<span class=\"number\">-2</span>,MOD);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> factor = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;factor*inv % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"h.-转圈按钮p4861\">H. 转圈、按钮P4861</h2>\r\n<p>https://www.luogu.com.cn/problem/P10515?contestId=174155</p>\r\n<h3 id=\"题意-5\">题意</h3>\r\n<p>小 <span class=\"math inline\">\\(\\delta\\)</span> 喜欢转圈圈。</p>\r\n<p>他有一个圈，被均匀分成了 <span class=\"math inline\">\\(n\\)</span>\r\n个格子，神奇的是，<span class=\"math inline\">\\(n\\)</span> 是一个质数。第\r\n<span class=\"math inline\">\\(i\\)</span> 个格子上写着一个数 <span\r\nclass=\"math inline\">\\(i \\times m\\)</span>，他现在站在第一个格子上。</p>\r\n<p>接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。</p>\r\n<p>求最终被小 <span class=\"math inline\">\\(\\delta\\)</span>\r\n踩到过的格子的数量。由于小 <span class=\"math inline\">\\(\\delta\\)</span>\r\n有很多圈圈，所以他会问你很多次。</p>\r\n<h3 id=\"题解-5\">题解</h3>\r\n<p>这题和P4861撞了，所以我干脆贴这题了</p>\r\n<p>根据欧拉定理<span class=\"math display\">\\[a^{\\phi(p)}= 1\r\n(modp)\\]</span></p>\r\n<p>因此<span\r\nclass=\"math display\">\\[\\phi(p)\\]</span>一定是答案的倍数，我们只需要枚举它的因子即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;<span class=\"keyword\">return</span> y? <span class=\"built_in\">gcd</span>(y,x%y): x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_phi</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> res = x;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(x&amp;<span class=\"number\">1</span>)) res &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">3</span>;i*i&lt;=x; i+= <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tres -= res /i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(x % i == <span class=\"number\">0</span>) x/=i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt; <span class=\"number\">1</span>) res -= res / x;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">gcd</span>(n,m)!=<span class=\"number\">1</span>)<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Let&#x27;s go Blue Jays!&quot;</span>);<span class=\"comment\">//无解</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p=<span class=\"built_in\">get_phi</span>(n);<span class=\"comment\">//得到phi</span></span><br><span class=\"line\">        <span class=\"type\">int</span> mm=p;</span><br><span class=\"line\">        <span class=\"type\">int</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;(i*i)&lt;=mm;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mm%i)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            pri[++tot]=i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(mm%i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                mm/=i;</span><br><span class=\"line\">                tim[tot]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mm!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            pri[++tot]=mm;</span><br><span class=\"line\">            tim[tot]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ss=<span class=\"number\">1</span>,qq=p;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ss&lt;=tot)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tim[ss];i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">qmi</span>(m,qq/pri[ss],n)==<span class=\"number\">1</span>)qq/=pri[ss];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ss++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;qq&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":2695,"excerpt":"","more":"<h2 id=\"b.-停车场\">B. 停车场</h2>\r\n<p><a\r\nhref=\"https://www.luogu.com.cn/problem/P10509?contestId=174155\">P10509\r\n停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>\r\n<h3 id=\"题意\">题意</h3>\r\n<p>你有一片空地。这片空地可以视作一个一个 𝑛×𝑛\r\n的正方形。空地外一圈为墙壁，你无法拆除它们。</p>\r\n<p>现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是\r\n1×1的正方形，且正方形的每条边与墙壁平行或者垂直。</p>\r\n<p>每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。</p>\r\n<p>下图为 𝑛=4\r\n时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。</p>\r\n<figure>\r\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>请问 𝑛=2023 下最多能安排多少个停车位？</p>\r\n<h3 id=\"题解\">题解</h3>\r\n<p>这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸</p>\r\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Bhc3RlLzE3cndqZmN6\">云剪贴板 - 洛谷 |\r\n计算机科学教育新生态 (luogu.com.cn)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。</p>\r\n<p>这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种</p>\r\n<figure>\r\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>直接构造可得</p>\r\n<p>答案为(2022+2021<em>(674</em>2-1)+673<em>2</em>2+3)</p>\r\n<h2 id=\"d.-方差\">D. 方差</h2>\r\n<p><a\r\nhref=\"https://www.luogu.com.cn/problem/P10511?contestId=174155\">P10511\r\n方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>\r\n<h3 id=\"题意-1\">题意</h3>\r\n<p>小 S 认为数学很简单，于是小 R 想要考考她。</p>\r\n<p>小 R 给了小 S 一个序列 <span\r\nclass=\"math inline\">\\(a\\)</span>，这个序列由 <span\r\nclass=\"math inline\">\\(m\\)</span> 段构成，第 <span\r\nclass=\"math inline\">\\(i\\)</span> 段被表示为 <code>l r b</code>，表示\r\n<span class=\"math inline\">\\(a_l,a_{l+1},\\ldots,a_r\\)</span> 为 <span\r\nclass=\"math inline\">\\(b\\)</span>，保证给出的任意两个区间不相交。</p>\r\n<p>现在，小 R 有 <span class=\"math inline\">\\(q\\)</span> 个问题。形如\r\n<code>l r</code>，想让你查询区间 <span\r\nclass=\"math inline\">\\([l,r]\\)</span> 的方差 <span\r\nclass=\"math inline\">\\(s^2\\)</span>（需要注意：<span\r\nclass=\"math inline\">\\(l\\)</span> 可能等于 <span\r\nclass=\"math inline\">\\(r\\)</span>，此时该段方差为 <span\r\nclass=\"math inline\">\\(0\\)</span>）。</p>\r\n<p>由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出\r\n<span class=\"math inline\">\\((r-l+1)^2\\cdot s^2\\bmod\r\n998244353\\)</span>。可以证明 <span class=\"math inline\">\\((r-l+1)^2\\cdot\r\ns^2\\)</span> 一定是整数。</p>\r\n<p>作为小 S 的好朋友，你能帮帮她吗？</p>\r\n<h3 id=\"题解-1\">题解</h3>\r\n<p>推导一下公式发现结果是</p>\r\n<p><span class=\"math display\">\\[(r-l+1) \\sum_{i=l}^{r-l+1}a_i^2 -\r\nsum^2\\]</span></p>\r\n<p>预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。</p>\r\n<p>但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;seg[i].l&gt;&gt;seg[i].r&gt;&gt;seg[i].v;</span><br><span class=\"line\">\t\tseg[i].l %= MOD;</span><br><span class=\"line\">\t\tseg[i].r %= MOD;</span><br><span class=\"line\">\t\tseg[i].v %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sort(seg+1,seg+1+m);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tsegs[i] = segs[i<span class=\"number\">-1</span>] + ((((seg[i].r - seg[i].l  + <span class=\"number\">1</span>) %MOD + MOD) %MOD) * seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs[i] %= MOD;</span><br><span class=\"line\">\t\tsegs2[i] = segs2[i<span class=\"number\">-1</span>] + (((((seg[i].r - seg[i].l + <span class=\"number\">1</span>) %MOD + MOD)%MOD) * seg[i].v %MOD)</span><br><span class=\"line\">\t\t\t\t* seg[i].v) % MOD;</span><br><span class=\"line\">\t\tsegs2[i] %= MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for(int i=1;i&lt;=m;i++) cout&lt;&lt;segs[i]&lt;&lt;&#x27; &#x27;&lt;&lt;segs2[i]&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(k--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> li = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;l,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ri = <span class=\"built_in\">upper_bound</span>(seg<span class=\"number\">+1</span>,seg<span class=\"number\">+1</span>+m,(Segment)&#123;r,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;) - seg - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;###&quot;&lt;&lt;li&lt;&lt; &#x27; &#x27; &lt;&lt; ri&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(li== ri)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">      \t\tcout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum = ((segs[ri<span class=\"number\">-1</span>] - segs[li])%MOD + MOD) % MOD;</span><br><span class=\"line\">\t\tmsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum = (((r - seg[ri].l + <span class=\"number\">1</span>) % MOD + MOD) % MOD * seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum = ((seg[li].r - l + <span class=\"number\">1</span> + MOD) % MOD * seg[li].v) % MOD;</span><br><span class=\"line\">\t\tlsum %= MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> msum2 = ((segs2[ri<span class=\"number\">-1</span>] - segs2[li])%MOD + MOD) %MOD;</span><br><span class=\"line\">\t\tmsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> rsum2 = ((((r - seg[ri].l + <span class=\"number\">1</span>)%MOD + MOD) % MOD * seg[ri].v) % MOD</span><br><span class=\"line\">\t\t\t\t* seg[ri].v) % MOD;</span><br><span class=\"line\">\t\trsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lsum2 = ((((seg[li].r - l + <span class=\"number\">1</span>) %MOD + MOD) % MOD * seg[li].v) % MOD</span><br><span class=\"line\">\t\t\t\t*seg[li].v) %MOD;</span><br><span class=\"line\">\t\tlsum2 %=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;---&quot;&lt;&lt;lsum &lt;&lt; &#x27; &#x27;&lt;&lt;msum&lt;&lt; &#x27; &#x27;&lt;&lt;rsum&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum = lsum + msum % MOD + rsum %MOD;</span><br><span class=\"line\">\t\tsum %=MOD;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;</span><br><span class=\"line\">\t\tsum2%=MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;&quot;####&quot;&lt;&lt;sum&lt;&lt; &#x27; &#x27;&lt;&lt; sum2&lt;&lt;endl;</span></span><br><span class=\"line\">\t\tcout&lt;&lt;(((((r-l<span class=\"number\">+1</span>) %MOD + MOD) % MOD * sum2) % MOD -</span><br><span class=\"line\">\t\t\t\t\t\t\t(sum*sum) %MOD) % MOD +MOD) %MOD&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"e.-序列合并\">E. 序列合并</h2>\r\n<p>https://www.luogu.com.cn/problem/P10512?contestId=174155</p>\r\n<h2 id=\"题意-2\">题意</h2>\r\n<p>给定一个长度为 𝑛的非负整数序列 {<span\r\nclass=\"math display\">\\[𝑎_𝑛\\]</span>}，你可以进行\r\n𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。</p>\r\n<p>形式化地，一次操作中，你选择一个下标\r\n𝑖<em>i</em>（1≤𝑖&lt;𝑛1≤<em>i</em>&lt;<em>n</em>），然后把原序列变成<span\r\nclass=\"math display\">\\[{a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}\\]</span>。</p>\r\n<p>求 𝑘次操作后所有数按位与的最大值。</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大</p>\r\n<p>注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。</p>\r\n<p>要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。</p>\r\n<p>我觉得比取模题简单</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">29</span>;~i;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = ans | (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tx |= a[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((x &amp; t) == t) cnt++,x=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &gt;= n - k) &#123;</span><br><span class=\"line\">\t\t\tans = t;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"f.-括号\">F. 括号</h2>\r\n<p>https://www.luogu.com.cn/problem/P10513?contestId=174155</p>\r\n<h3 id=\"题意-3\">题意</h3>\r\n<p>圆给了你一个长度为 <span class=\"math inline\">\\(n\\)</span> 的字符串\r\n<span class=\"math inline\">\\(S\\)</span>，<span\r\nclass=\"math inline\">\\(S\\)</span> 仅由 <code>(</code> 和 <code>)</code>\r\n构成。</p>\r\n<p>她会对其做 <span class=\"math inline\">\\(m\\)</span>\r\n次操作，操作有两种类型：</p>\r\n<ol type=\"1\">\r\n<li><code>1 l r</code>，她会翻转 <span class=\"math inline\">\\(l\\)</span>\r\n到 <span class=\"math inline\">\\(r\\)</span> 的括号，即 <code>(</code> 变\r\n<code>)</code>，<code>)</code> 变 <code>(</code>。</li>\r\n<li><code>2 l r</code>，她想知道区间 <span class=\"math inline\">\\(\\left[\r\nl,r\\right]\\)</span> 中最长合法括号子序列的长度除以 <span\r\nclass=\"math inline\">\\(2\\)</span> 的答案。</li>\r\n</ol>\r\n<p>圆认为以下的括号序列是合法的：</p>\r\n<ol type=\"1\">\r\n<li><p>空序列是一个合法序列。</p></li>\r\n<li><p>如果 <code>A</code> 是一个合法序列，则 <code>(A)</code>\r\n也是一个合法序列。</p></li>\r\n<li><p>如果 <code>A</code> 和 <code>B</code> 都是合法序列，则\r\n<code>AB</code> 也是一个合法序列。</p></li>\r\n</ol>\r\n<p>圆认为，序列 <span class=\"math inline\">\\(a\\)</span> 的子序列是满足\r\n<span class=\"math inline\">\\(1\\le i_1&lt;i_2&lt;···&lt;i_k \\le n\\)</span>\r\n的序列 <span\r\nclass=\"math inline\">\\([a_{i_1},a_{i_2},...a_{i_k}]\\)</span>。</p>\r\n<p>由于操作太多了，她算不过来，请你帮帮她吧。</p>\r\n<h3 id=\"题解-3\">题解</h3>\r\n<p>洛谷真的要吓死我了，第六题线段树</p>\r\n<p>对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即</p>\r\n<p><span\r\nclass=\"math display\">\\[ans=左边括号序列+右边括号序列+横跨中间的括号序列\\]</span></p>\r\n<p>如何维护交换这一操作呢？</p>\r\n<p>我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,ans;</span><br><span class=\"line\">\t<span class=\"built_in\">node</span>(<span class=\"type\">int</span> x=<span class=\"number\">0</span>,<span class=\"type\">int</span> y=<span class=\"number\">0</span>,<span class=\"type\">int</span> z=<span class=\"number\">0</span>)&#123;l=x,r=y,ans=z;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tree</span>&#123;<span class=\"type\">int</span> tag;node t1,t2;&#125;t[N&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">merge</span><span class=\"params\">(node x,node y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt=<span class=\"built_in\">min</span>(x.l,y.r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;t[p].t1=<span class=\"built_in\">merge</span>(t[ls].t1,t[rs].t1);t[p].t2=<span class=\"built_in\">merge</span>(t[ls].t2,t[rs].t2);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushson</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"built_in\">swap</span>(t[p].t1,t[p].t2);t[p].tag^=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"type\">int</span> p)</span></span>&#123;<span class=\"keyword\">if</span>(!t[p].tag) <span class=\"keyword\">return</span>;<span class=\"built_in\">pushson</span>(ls),<span class=\"built_in\">pushson</span>(rs);t[p].tag=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r) <span class=\"keyword\">return</span> t[p].t<span class=\"number\">2.</span>r=t[p].t<span class=\"number\">1.l</span>=(s[l]==<span class=\"string\">&#x27;(&#x27;</span>),t[p].t<span class=\"number\">2.l</span>=t[p].t<span class=\"number\">1.</span>r=(s[l]==<span class=\"string\">&#x27;)&#x27;</span>),<span class=\"built_in\">void</span>();</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(ls,l,mid);<span class=\"built_in\">build</span>(rs,mid<span class=\"number\">+1</span>,r);<span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> <span class=\"built_in\">pushson</span>(p);<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&gt;=s) <span class=\"built_in\">modify</span>(ls,l,mid,s,e);<span class=\"keyword\">if</span>(mid&lt;e) <span class=\"built_in\">modify</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> p,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> s,<span class=\"type\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class=\"keyword\">return</span> t[p].t1;<span class=\"built_in\">pushdown</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e&lt;=mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(ls,l,mid,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s&gt;mid) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">merge</span>(<span class=\"built_in\">query</span>(ls,l,mid,s,e),<span class=\"built_in\">query</span>(rs,mid<span class=\"number\">+1</span>,r,s,e));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\tcin&gt;&gt;s<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op,l,r;cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(op == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">modify</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r).ans&lt;&lt;endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"g.考试\">G.考试</h2>\r\n<p>https://www.luogu.com.cn/problem/P10514?contestId=174155</p>\r\n<h3 id=\"题意-4\">题意</h3>\r\n<p>有 <span class=\"math inline\">\\(n\\)</span> 名同学去参加考试，考试有\r\n<span class=\"math inline\">\\(m\\)</span> 道题。</p>\r\n<p>每个学生的实力是相同的，但是每道题的难度可能不同。第 <span\r\nclass=\"math inline\">\\(i\\)</span> 道题会有随机的 <span\r\nclass=\"math inline\">\\(a_i\\)</span> 名同学做错。</p>\r\n<p>考试结束后，随机选出 <span class=\"math inline\">\\(k\\)</span>\r\n名同学，求出这些同学全部做对的概率。答案对 <span\r\nclass=\"math inline\">\\(998244353\\)</span> 取模。</p>\r\n<h3 id=\"题解-4\">题解</h3>\r\n<p>数学题。。。 懒得打公式了，如下</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png\"\r\nalt=\"image-20240527221944431\" />\r\n<figcaption aria-hidden=\"true\">image-20240527221944431</figcaption>\r\n</figure>\r\n<p>预处理阶乘，快速幂分母时间复杂度为log(m)+n</p>\r\n<p>处理分子时间复杂度为mlog(n)</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tfac[<span class=\"number\">0</span>] = infac[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">\t\tfac[i] = fac[i<span class=\"number\">-1</span>] *i % MOD;</span><br><span class=\"line\">\t\tinfac[i] = infac[i<span class=\"number\">-1</span>] * <span class=\"built_in\">qmi</span>(i,MOD<span class=\"number\">-2</span>,MOD) % MOD;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cout&lt;&lt;fac[i]&lt;&lt;&#x27; &#x27; &lt;&lt;infac[i]&lt;&lt;endl;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i], mx= <span class=\"built_in\">max</span>(mx,a[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(mx + k &gt; n) &#123;cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;endl;<span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> inv = <span class=\"built_in\">qmi</span>(<span class=\"built_in\">qmi</span>(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD<span class=\"number\">-2</span>,MOD);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> factor = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tfactor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;factor*inv % MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"h.-转圈按钮p4861\">H. 转圈、按钮P4861</h2>\r\n<p>https://www.luogu.com.cn/problem/P10515?contestId=174155</p>\r\n<h3 id=\"题意-5\">题意</h3>\r\n<p>小 <span class=\"math inline\">\\(\\delta\\)</span> 喜欢转圈圈。</p>\r\n<p>他有一个圈，被均匀分成了 <span class=\"math inline\">\\(n\\)</span>\r\n个格子，神奇的是，<span class=\"math inline\">\\(n\\)</span> 是一个质数。第\r\n<span class=\"math inline\">\\(i\\)</span> 个格子上写着一个数 <span\r\nclass=\"math inline\">\\(i \\times m\\)</span>，他现在站在第一个格子上。</p>\r\n<p>接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。</p>\r\n<p>求最终被小 <span class=\"math inline\">\\(\\delta\\)</span>\r\n踩到过的格子的数量。由于小 <span class=\"math inline\">\\(\\delta\\)</span>\r\n有很多圈圈，所以他会问你很多次。</p>\r\n<h3 id=\"题解-5\">题解</h3>\r\n<p>这题和P4861撞了，所以我干脆贴这题了</p>\r\n<p>根据欧拉定理<span class=\"math display\">\\[a^{\\phi(p)}= 1\r\n(modp)\\]</span></p>\r\n<p>因此<span\r\nclass=\"math display\">\\[\\phi(p)\\]</span>一定是答案的倍数，我们只需要枚举它的因子即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qmi</span><span class=\"params\">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class=\"line\">\tll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;b;b&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res = res * a % mod;</span><br><span class=\"line\">\t\ta = a * a % mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;<span class=\"keyword\">return</span> y? <span class=\"built_in\">gcd</span>(y,x%y): x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_phi</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> res = x;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(x&amp;<span class=\"number\">1</span>)) res &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">3</span>;i*i&lt;=x; i+= <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tres -= res /i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(x % i == <span class=\"number\">0</span>) x/=i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x &gt; <span class=\"number\">1</span>) res -= res / x;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">gcd</span>(n,m)!=<span class=\"number\">1</span>)<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Let&#x27;s go Blue Jays!&quot;</span>);<span class=\"comment\">//无解</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p=<span class=\"built_in\">get_phi</span>(n);<span class=\"comment\">//得到phi</span></span><br><span class=\"line\">        <span class=\"type\">int</span> mm=p;</span><br><span class=\"line\">        <span class=\"type\">int</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;(i*i)&lt;=mm;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mm%i)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            pri[++tot]=i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(mm%i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                mm/=i;</span><br><span class=\"line\">                tim[tot]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mm!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            pri[++tot]=mm;</span><br><span class=\"line\">            tim[tot]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ss=<span class=\"number\">1</span>,qq=p;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ss&lt;=tot)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tim[ss];i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">qmi</span>(m,qq/pri[ss],n)==<span class=\"number\">1</span>)qq/=pri[ss];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ss++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;qq&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"三种操作系统模拟软件使用手册","date":"2024-05-13T09:07:09.000Z","_content":"\n# 三种操作系统简单模拟使用手册\n\n## 可运行程序图标\n\nhttps://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw\n\n![image-20240525143542993](https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png)\n\n<!--more-->\n\n## 安装\n\n程序提供了三种安装形式。\n\n### exe模式\n\n第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考[Java官网](https://www.java.com/zh-CN/download/manual.jsp)\n\n### JAR模式\n\n第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用\n\n<!--more-->\n\n### install安装包模式\n\n第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。\n\n## 卸载方式\n\n通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。\n\n## 程序使用指南\n\n### 开源协议窗口\n\n![image-20240525143707804](https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png)\n\n该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。\n\n\n\n### 导航菜单界面\n\n![image-20240525143849896](https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png)\n\n该界面为程序主题界面，可通过界面导航到三个算法界面\n\n### 生产者消费者\n\n![image-20240525144036276](https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png)\n\n该界面可实现生产者消费者业务功能\n\n使用方式为：\n\n1. 按照程序显示按钮进行操作，请勿输入未指定的，空数据。\n\n1.0.1 版本常见问题为：\n\n1. 该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。\n\n### 银行家算法\n\n   ![image-20240525144551258](https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png)\n\n该界面为银行家算法界面，可实现银行家算法的功能与设计\n\n使用方式为：\n\n1. 给定总进程与总资源数\n2. 设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵\n3. 是否继续请求\n\n1.0.1版本可能遇到的问题：\n\n1. 设定过多进程与资源数导致无法输入\n2. ![image-20240525145256829](https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png)\n\n### 调度算法模拟\n\n![image-20240525144538081](https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png)\n\n调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能\n\n![image-20240525144654678](https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png)\n\n六种调度算法全称分别是\n\n1. 先到先执行\n2. 非抢占式短作业优先\n3. 最短剩余时间优先（抢占式最短作业优先）\n4. 非抢占式优先级优先\n5. 抢占式优先级优先\n6. 时间片轮转算法\n\n使用方法为：\n\n1. 输入每个进程的前四列信息\n2. 选择算法\n3. 点击计算\n\n1.0.1版本可能遇到的问题：\n\n1. 请勿设置相同进程号\n2. 请勿设置小数时间片轮转或设置为0\n3. 给定的完成时间，周转时间，等待时间将被忽略","source":"_posts/三种操作系统模拟软件使用手册.md","raw":"---\ntitle: 三种操作系统模拟软件使用手册\ndate: 2024-05-13 17:07:09\ntags: [开发, 文档, 学校]\ncategories: \n   - 软件\n   - 手册\n---\n\n# 三种操作系统简单模拟使用手册\n\n## 可运行程序图标\n\nhttps://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw\n\n![image-20240525143542993](https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png)\n\n<!--more-->\n\n## 安装\n\n程序提供了三种安装形式。\n\n### exe模式\n\n第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考[Java官网](https://www.java.com/zh-CN/download/manual.jsp)\n\n### JAR模式\n\n第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用\n\n<!--more-->\n\n### install安装包模式\n\n第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。\n\n## 卸载方式\n\n通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。\n\n## 程序使用指南\n\n### 开源协议窗口\n\n![image-20240525143707804](https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png)\n\n该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。\n\n\n\n### 导航菜单界面\n\n![image-20240525143849896](https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png)\n\n该界面为程序主题界面，可通过界面导航到三个算法界面\n\n### 生产者消费者\n\n![image-20240525144036276](https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png)\n\n该界面可实现生产者消费者业务功能\n\n使用方式为：\n\n1. 按照程序显示按钮进行操作，请勿输入未指定的，空数据。\n\n1.0.1 版本常见问题为：\n\n1. 该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。\n\n### 银行家算法\n\n   ![image-20240525144551258](https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png)\n\n该界面为银行家算法界面，可实现银行家算法的功能与设计\n\n使用方式为：\n\n1. 给定总进程与总资源数\n2. 设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵\n3. 是否继续请求\n\n1.0.1版本可能遇到的问题：\n\n1. 设定过多进程与资源数导致无法输入\n2. ![image-20240525145256829](https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png)\n\n### 调度算法模拟\n\n![image-20240525144538081](https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png)\n\n调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能\n\n![image-20240525144654678](https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png)\n\n六种调度算法全称分别是\n\n1. 先到先执行\n2. 非抢占式短作业优先\n3. 最短剩余时间优先（抢占式最短作业优先）\n4. 非抢占式优先级优先\n5. 抢占式优先级优先\n6. 时间片轮转算法\n\n使用方法为：\n\n1. 输入每个进程的前四列信息\n2. 选择算法\n3. 点击计算\n\n1.0.1版本可能遇到的问题：\n\n1. 请勿设置相同进程号\n2. 请勿设置小数时间片轮转或设置为0\n3. 给定的完成时间，周转时间，等待时间将被忽略","slug":"三种操作系统模拟软件使用手册","published":1,"updated":"2024-08-14T13:38:59.744Z","comments":1,"layout":"post","photos":[],"_id":"clzusvytb0016wwwv94w40v0e","content":"<h1 id=\"三种操作系统简单模拟使用手册\">三种操作系统简单模拟使用手册</h1>\r\n<h2 id=\"可运行程序图标\">可运行程序图标</h2>\r\n<p>https://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png\"\r\nalt=\"image-20240525143542993\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143542993</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h2 id=\"安装\">安装</h2>\r\n<p>程序提供了三种安装形式。</p>\r\n<h3 id=\"exe模式\">exe模式</h3>\r\n<p>第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考<a\r\nhref=\"https://www.java.com/zh-CN/download/manual.jsp\">Java官网</a></p>\r\n<h3 id=\"jar模式\">JAR模式</h3>\r\n<p>第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java\r\n-jar直接调用，也可以通过ide导入为库调用</p>\r\n<!--more-->\r\n<h3 id=\"install安装包模式\">install安装包模式</h3>\r\n<p>第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。</p>\r\n<h2 id=\"卸载方式\">卸载方式</h2>\r\n<p>通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。</p>\r\n<h2 id=\"程序使用指南\">程序使用指南</h2>\r\n<h3 id=\"开源协议窗口\">开源协议窗口</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png\"\r\nalt=\"image-20240525143707804\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143707804</figcaption>\r\n</figure>\r\n<p>该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。</p>\r\n<h3 id=\"导航菜单界面\">导航菜单界面</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png\"\r\nalt=\"image-20240525143849896\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143849896</figcaption>\r\n</figure>\r\n<p>该界面为程序主题界面，可通过界面导航到三个算法界面</p>\r\n<h3 id=\"生产者消费者\">生产者消费者</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png\"\r\nalt=\"image-20240525144036276\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144036276</figcaption>\r\n</figure>\r\n<p>该界面可实现生产者消费者业务功能</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>按照程序显示按钮进行操作，请勿输入未指定的，空数据。</li>\r\n</ol>\r\n<p>1.0.1 版本常见问题为：</p>\r\n<ol type=\"1\">\r\n<li>该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。</li>\r\n</ol>\r\n<h3 id=\"银行家算法\">银行家算法</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png\"\r\nalt=\"image-20240525144551258\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144551258</figcaption>\r\n</figure>\r\n<p>该界面为银行家算法界面，可实现银行家算法的功能与设计</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>给定总进程与总资源数</li>\r\n<li>设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵</li>\r\n<li>是否继续请求</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>设定过多进程与资源数导致无法输入</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png\"\r\nalt=\"image-20240525145256829\" />\r\n<figcaption aria-hidden=\"true\">image-20240525145256829</figcaption>\r\n</figure></li>\r\n</ol>\r\n<h3 id=\"调度算法模拟\">调度算法模拟</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png\"\r\nalt=\"image-20240525144538081\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144538081</figcaption>\r\n</figure>\r\n<p>调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png\"\r\nalt=\"image-20240525144654678\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144654678</figcaption>\r\n</figure>\r\n<p>六种调度算法全称分别是</p>\r\n<ol type=\"1\">\r\n<li>先到先执行</li>\r\n<li>非抢占式短作业优先</li>\r\n<li>最短剩余时间优先（抢占式最短作业优先）</li>\r\n<li>非抢占式优先级优先</li>\r\n<li>抢占式优先级优先</li>\r\n<li>时间片轮转算法</li>\r\n</ol>\r\n<p>使用方法为：</p>\r\n<ol type=\"1\">\r\n<li>输入每个进程的前四列信息</li>\r\n<li>选择算法</li>\r\n<li>点击计算</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>请勿设置相同进程号</li>\r\n<li>请勿设置小数时间片轮转或设置为0</li>\r\n<li>给定的完成时间，周转时间，等待时间将被忽略</li>\r\n</ol>\r\n","length":830,"excerpt":"<h1 id=\"三种操作系统简单模拟使用手册\">三种操作系统简单模拟使用手册</h1>\r\n<h2 id=\"可运行程序图标\">可运行程序图标</h2>\r\n<p>https://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png\"\r\nalt=\"image-20240525143542993\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143542993</figcaption>\r\n</figure>","more":"<h2 id=\"安装\">安装</h2>\r\n<p>程序提供了三种安装形式。</p>\r\n<h3 id=\"exe模式\">exe模式</h3>\r\n<p>第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考<a\r\nhref=\"https://www.java.com/zh-CN/download/manual.jsp\">Java官网</a></p>\r\n<h3 id=\"jar模式\">JAR模式</h3>\r\n<p>第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java\r\n-jar直接调用，也可以通过ide导入为库调用</p>\r\n<!--more-->\r\n<h3 id=\"install安装包模式\">install安装包模式</h3>\r\n<p>第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。</p>\r\n<h2 id=\"卸载方式\">卸载方式</h2>\r\n<p>通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。</p>\r\n<h2 id=\"程序使用指南\">程序使用指南</h2>\r\n<h3 id=\"开源协议窗口\">开源协议窗口</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png\"\r\nalt=\"image-20240525143707804\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143707804</figcaption>\r\n</figure>\r\n<p>该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。</p>\r\n<h3 id=\"导航菜单界面\">导航菜单界面</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png\"\r\nalt=\"image-20240525143849896\" />\r\n<figcaption aria-hidden=\"true\">image-20240525143849896</figcaption>\r\n</figure>\r\n<p>该界面为程序主题界面，可通过界面导航到三个算法界面</p>\r\n<h3 id=\"生产者消费者\">生产者消费者</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png\"\r\nalt=\"image-20240525144036276\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144036276</figcaption>\r\n</figure>\r\n<p>该界面可实现生产者消费者业务功能</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>按照程序显示按钮进行操作，请勿输入未指定的，空数据。</li>\r\n</ol>\r\n<p>1.0.1 版本常见问题为：</p>\r\n<ol type=\"1\">\r\n<li>该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。</li>\r\n</ol>\r\n<h3 id=\"银行家算法\">银行家算法</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png\"\r\nalt=\"image-20240525144551258\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144551258</figcaption>\r\n</figure>\r\n<p>该界面为银行家算法界面，可实现银行家算法的功能与设计</p>\r\n<p>使用方式为：</p>\r\n<ol type=\"1\">\r\n<li>给定总进程与总资源数</li>\r\n<li>设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵</li>\r\n<li>是否继续请求</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>设定过多进程与资源数导致无法输入</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png\"\r\nalt=\"image-20240525145256829\" />\r\n<figcaption aria-hidden=\"true\">image-20240525145256829</figcaption>\r\n</figure></li>\r\n</ol>\r\n<h3 id=\"调度算法模拟\">调度算法模拟</h3>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png\"\r\nalt=\"image-20240525144538081\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144538081</figcaption>\r\n</figure>\r\n<p>调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能</p>\r\n<figure>\r\n<img src=\"https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png\"\r\nalt=\"image-20240525144654678\" />\r\n<figcaption aria-hidden=\"true\">image-20240525144654678</figcaption>\r\n</figure>\r\n<p>六种调度算法全称分别是</p>\r\n<ol type=\"1\">\r\n<li>先到先执行</li>\r\n<li>非抢占式短作业优先</li>\r\n<li>最短剩余时间优先（抢占式最短作业优先）</li>\r\n<li>非抢占式优先级优先</li>\r\n<li>抢占式优先级优先</li>\r\n<li>时间片轮转算法</li>\r\n</ol>\r\n<p>使用方法为：</p>\r\n<ol type=\"1\">\r\n<li>输入每个进程的前四列信息</li>\r\n<li>选择算法</li>\r\n<li>点击计算</li>\r\n</ol>\r\n<p>1.0.1版本可能遇到的问题：</p>\r\n<ol type=\"1\">\r\n<li>请勿设置相同进程号</li>\r\n<li>请勿设置小数时间片轮转或设置为0</li>\r\n<li>给定的完成时间，周转时间，等待时间将被忽略</li>\r\n</ol>"},{"title":"为什么我用Typora——Typora与其他markdown的比较","date":"2023-08-13T07:20:34.000Z","_content":"## Typora\n\n​\tTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。\n\n<!--more-->\n\n## Typora的Markdown语法\n\n​\tTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。\n\n​\t但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在**Latex语法格式**。\n\n​\t因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。\n\n> ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化\n\n<!--more-->\n\n### 代码块语法\n\n​\t代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行\n\n### Html、js、css\n\n​\tTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。\n\n​\t通过html也可以实现索引官方的方式是 `[这样]()`\n\n## Typora中的Mermaid，Latex\n\n​\tMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。\n\n​\t但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此**Typora并未bundle Fontawesome**。因此无法使用fa: fa-xxx表示图标。\n\n## Typora中的媒体\n\n​\tTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：\n\n1. 以ssms图床为例[Image Upload - SM.MS - Simple Free Image Hosting](https://sm.ms/)\n2. 到ssms官网注册张航并拿到apikey\n3. 填入picgo插件的配置文件\n4. ![配置图](https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png)\n\n> ```\n> {\n>   \"picBed\": {\n>     \"current\": \"smms\",\n>     \"smms\": {\n>       \"token\": \"xxx\"\n>     }\n>   },\n>   \"picgoPlugins\": {}\n> }\n> ```\n\n5. 测试并运行\n\n## Typora的文档保存机制\n\n​\t当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失\n\n## Typora的个性化主题\n\n​\tTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。\n\n## 总结\n\n​\t对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。\n\n## 一些比较实用的不在Typora文档中的使用技巧\n\n1. 通过html标签扩展typora的显示格式\n\n   如`<details></details>`标签可以显示一个展开栏，做错题本时很好用\n\n2. 一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin\n\n   [obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)](https://github.com/obgnail/typora_plugin)\n\n---\n\n待更新","source":"_posts/为什么我用Typora——Typora与其他markdown的比较.md","raw":"---\ntitle: 为什么我用Typora——Typora与其他markdown的比较\ndate: 2023-08-13 15:20:34\ntags: [Typora, Markdown, 随笔]\ncategories:\n   - 软件\n   - 编辑器\n   - Markdown\n---\n## Typora\n\n​\tTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。\n\n<!--more-->\n\n## Typora的Markdown语法\n\n​\tTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。\n\n​\t但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在**Latex语法格式**。\n\n​\t因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。\n\n> ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化\n\n<!--more-->\n\n### 代码块语法\n\n​\t代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行\n\n### Html、js、css\n\n​\tTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。\n\n​\t通过html也可以实现索引官方的方式是 `[这样]()`\n\n## Typora中的Mermaid，Latex\n\n​\tMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。\n\n​\t但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此**Typora并未bundle Fontawesome**。因此无法使用fa: fa-xxx表示图标。\n\n## Typora中的媒体\n\n​\tTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：\n\n1. 以ssms图床为例[Image Upload - SM.MS - Simple Free Image Hosting](https://sm.ms/)\n2. 到ssms官网注册张航并拿到apikey\n3. 填入picgo插件的配置文件\n4. ![配置图](https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png)\n\n> ```\n> {\n>   \"picBed\": {\n>     \"current\": \"smms\",\n>     \"smms\": {\n>       \"token\": \"xxx\"\n>     }\n>   },\n>   \"picgoPlugins\": {}\n> }\n> ```\n\n5. 测试并运行\n\n## Typora的文档保存机制\n\n​\t当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失\n\n## Typora的个性化主题\n\n​\tTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。\n\n## 总结\n\n​\t对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。\n\n## 一些比较实用的不在Typora文档中的使用技巧\n\n1. 通过html标签扩展typora的显示格式\n\n   如`<details></details>`标签可以显示一个展开栏，做错题本时很好用\n\n2. 一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin\n\n   [obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)](https://github.com/obgnail/typora_plugin)\n\n---\n\n待更新","slug":"为什么我用Typora——Typora与其他markdown的比较","published":1,"updated":"2024-08-14T13:39:02.327Z","comments":1,"layout":"post","photos":[],"_id":"clzusvytb0018wwwvguru9cku","content":"<h2 id=\"typora\">Typora</h2>\r\n<p>​\r\nTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"typora的markdown语法\">Typora的Markdown语法</h2>\r\n<p>​\r\nTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。</p>\r\n<p>​\r\n但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在<strong>Latex语法格式</strong>。</p>\r\n<p>​\r\n因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。</p>\r\n<blockquote>\r\n<p>ps:\r\n根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化</p>\r\n</blockquote>\r\n<!--more-->\r\n<h3 id=\"代码块语法\">代码块语法</h3>\r\n<p>​ 代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行</p>\r\n<h3 id=\"htmljscss\">Html、js、css</h3>\r\n<p>​\r\nTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。</p>\r\n<p>​ 通过html也可以实现索引官方的方式是 <code>[这样]()</code></p>\r\n<h2 id=\"typora中的mermaidlatex\">Typora中的Mermaid，Latex</h2>\r\n<p>​\r\nMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。</p>\r\n<p>​ 但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest\r\nversion为v6，因此<strong>Typora并未bundle\r\nFontawesome</strong>。因此无法使用fa: fa-xxx表示图标。</p>\r\n<h2 id=\"typora中的媒体\">Typora中的媒体</h2>\r\n<p>​\r\nTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：</p>\r\n<ol type=\"1\">\r\n<li>以ssms图床为例<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zbS5tcy8=\">Image Upload - SM.MS - Simple\r\nFree Image Hosting<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n<li>到ssms官网注册张航并拿到apikey</li>\r\n<li>填入picgo插件的配置文件</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png\"\r\nalt=\"配置图\" />\r\n<figcaption aria-hidden=\"true\">配置图</figcaption>\r\n</figure></li>\r\n</ol>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;picBed&quot;: &#123;</span><br><span class=\"line\">    &quot;current&quot;: &quot;smms&quot;,</span><br><span class=\"line\">    &quot;smms&quot;: &#123;</span><br><span class=\"line\">      &quot;token&quot;: &quot;xxx&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;picgoPlugins&quot;: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<ol start=\"5\" type=\"1\">\r\n<li>测试并运行</li>\r\n</ol>\r\n<h2 id=\"typora的文档保存机制\">Typora的文档保存机制</h2>\r\n<p>​\r\n当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失</p>\r\n<h2 id=\"typora的个性化主题\">Typora的个性化主题</h2>\r\n<p>​\r\nTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。</p>\r\n<h2 id=\"总结\">总结</h2>\r\n<p>​\r\n对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。</p>\r\n<h2\r\nid=\"一些比较实用的不在typora文档中的使用技巧\">一些比较实用的不在Typora文档中的使用技巧</h2>\r\n<ol type=\"1\">\r\n<li><p>通过html标签扩展typora的显示格式</p>\r\n<p>如<code>&lt;details&gt;&lt;/details&gt;</code>标签可以显示一个展开栏，做错题本时很好用</p></li>\r\n<li><p>一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin</p>\r\n<p><a\r\nhref=\"https://github.com/obgnail/typora_plugin\">obgnail/typora_plugin:\r\nTypora plugin. Feature enhancement tool | Typora 插件，功能增强工具\r\n(github.com)</a></p></li>\r\n</ol>\r\n<hr />\r\n<p>待更新</p>\r\n","length":1122,"excerpt":"<h2 id=\"typora\">Typora</h2>\r\n<p>​\r\nTypora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。</p>","more":"<h2 id=\"typora的markdown语法\">Typora的Markdown语法</h2>\r\n<p>​\r\nTypora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。</p>\r\n<p>​\r\n但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在<strong>Latex语法格式</strong>。</p>\r\n<p>​\r\n因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。</p>\r\n<blockquote>\r\n<p>ps:\r\n根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化</p>\r\n</blockquote>\r\n<!--more-->\r\n<h3 id=\"代码块语法\">代码块语法</h3>\r\n<p>​ 代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行</p>\r\n<h3 id=\"htmljscss\">Html、js、css</h3>\r\n<p>​\r\nTypora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。</p>\r\n<p>​ 通过html也可以实现索引官方的方式是 <code>[这样]()</code></p>\r\n<h2 id=\"typora中的mermaidlatex\">Typora中的Mermaid，Latex</h2>\r\n<p>​\r\nMarkdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。</p>\r\n<p>​ 但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest\r\nversion为v6，因此<strong>Typora并未bundle\r\nFontawesome</strong>。因此无法使用fa: fa-xxx表示图标。</p>\r\n<h2 id=\"typora中的媒体\">Typora中的媒体</h2>\r\n<p>​\r\nTypora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：</p>\r\n<ol type=\"1\">\r\n<li>以ssms图床为例<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zbS5tcy8=\">Image Upload - SM.MS - Simple\r\nFree Image Hosting<i class=\"fa fa-external-link-alt\"></i></span></li>\r\n<li>到ssms官网注册张航并拿到apikey</li>\r\n<li>填入picgo插件的配置文件</li>\r\n<li><figure>\r\n<img src=\"https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png\"\r\nalt=\"配置图\" />\r\n<figcaption aria-hidden=\"true\">配置图</figcaption>\r\n</figure></li>\r\n</ol>\r\n<blockquote>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;picBed&quot;: &#123;</span><br><span class=\"line\">    &quot;current&quot;: &quot;smms&quot;,</span><br><span class=\"line\">    &quot;smms&quot;: &#123;</span><br><span class=\"line\">      &quot;token&quot;: &quot;xxx&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;picgoPlugins&quot;: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<ol start=\"5\" type=\"1\">\r\n<li>测试并运行</li>\r\n</ol>\r\n<h2 id=\"typora的文档保存机制\">Typora的文档保存机制</h2>\r\n<p>​\r\n当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失</p>\r\n<h2 id=\"typora的个性化主题\">Typora的个性化主题</h2>\r\n<p>​\r\nTypora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。</p>\r\n<h2 id=\"总结\">总结</h2>\r\n<p>​\r\n对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。</p>\r\n<h2\r\nid=\"一些比较实用的不在typora文档中的使用技巧\">一些比较实用的不在Typora文档中的使用技巧</h2>\r\n<ol type=\"1\">\r\n<li><p>通过html标签扩展typora的显示格式</p>\r\n<p>如<code>&lt;details&gt;&lt;/details&gt;</code>标签可以显示一个展开栏，做错题本时很好用</p></li>\r\n<li><p>一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin</p>\r\n<p><a\r\nhref=\"https://github.com/obgnail/typora_plugin\">obgnail/typora_plugin:\r\nTypora plugin. Feature enhancement tool | Typora 插件，功能增强工具\r\n(github.com)</a></p></li>\r\n</ol>\r\n<hr />\r\n<p>待更新</p>"},{"title":"字符串","date":"2024-08-14T11:37:01.000Z","_content":"# 题意：\n\n给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。\n\n# 题解：\n\n子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。\n\n子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt\\[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。\n\n这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。\n\n<!--more-->\n\n```cpp\nvoid get_next(){\n    for(int i=n;i>=0;i--){\n        for(int j=0;j<26;j++){\n            if(i==n) nxt[i][j]=n;\n            else nxt[i][j]=nxt[i+1][j];\n        }\n        if(i!=n) nxt[i][s[i]-'A']=i;\n    }\n}\n\nint get_pos(int st,string s){\n    int first=1;\n    for(auto ch:s){\n        if(first) st=nxt[st][ch-'A'];\n        else st=nxt[st+1][ch-'A'];\n        first=0;\n        if(st==n) return st;\n    }\n    return st;\n}\n\nvoid slove(){\n    cin>>n>>k>>s;\n    get_next();\n    string ac=\"ACCEPT\",wa=\"WA\";\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        int r1=get_pos(i,ac),r2=get_pos(i,wa);\n        r1=max(r1,i+k-1);\n        ans=ans+max(r2-r1,0ll);\n    }\n    cout<<ans<<endl;\n}\n```\n\n","source":"_posts/字符串习题1.md","raw":"---\ntitle: 字符串\ndate: 2024-08-14 19:37:01\ntags: [算法, 子序列自动机]\ncategories: \n\t- 算法\n\t- 字符串\n\t- 子序列自动机\n---\n# 题意：\n\n给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。\n\n# 题解：\n\n子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。\n\n子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt\\[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。\n\n这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。\n\n<!--more-->\n\n```cpp\nvoid get_next(){\n    for(int i=n;i>=0;i--){\n        for(int j=0;j<26;j++){\n            if(i==n) nxt[i][j]=n;\n            else nxt[i][j]=nxt[i+1][j];\n        }\n        if(i!=n) nxt[i][s[i]-'A']=i;\n    }\n}\n\nint get_pos(int st,string s){\n    int first=1;\n    for(auto ch:s){\n        if(first) st=nxt[st][ch-'A'];\n        else st=nxt[st+1][ch-'A'];\n        first=0;\n        if(st==n) return st;\n    }\n    return st;\n}\n\nvoid slove(){\n    cin>>n>>k>>s;\n    get_next();\n    string ac=\"ACCEPT\",wa=\"WA\";\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        int r1=get_pos(i,ac),r2=get_pos(i,wa);\n        r1=max(r1,i+k-1);\n        ans=ans+max(r2-r1,0ll);\n    }\n    cout<<ans<<endl;\n}\n```\n\n","slug":"字符串习题1","published":1,"updated":"2024-08-14T13:39:05.118Z","comments":1,"layout":"post","photos":[],"_id":"clzusvytc001awwwv4frf919s","content":"<h1 id=\"题意\">题意：</h1>\r\n<p>给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。</p>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。</p>\r\n<p>子序列自动机的基本概念是用二维数组保存对于i位置\r\nj字符第一次出现的位置为nxt[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。</p>\r\n<p>这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">26</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==n) nxt[i][j]=n;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nxt[i][j]=nxt[i<span class=\"number\">+1</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=n) nxt[i][s[i]-<span class=\"string\">&#x27;A&#x27;</span>]=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pos</span><span class=\"params\">(<span class=\"type\">int</span> st,string s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> first=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> ch:s)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first) st=nxt[st][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> st=nxt[st<span class=\"number\">+1</span>][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        first=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st==n) <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">get_next</span>();</span><br><span class=\"line\">    string ac=<span class=\"string\">&quot;ACCEPT&quot;</span>,wa=<span class=\"string\">&quot;WA&quot;</span>;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> r1=<span class=\"built_in\">get_pos</span>(i,ac),r2=<span class=\"built_in\">get_pos</span>(i,wa);</span><br><span class=\"line\">        r1=<span class=\"built_in\">max</span>(r1,i+k<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ans=ans+<span class=\"built_in\">max</span>(r2-r1,<span class=\"number\">0ll</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":310,"excerpt":"<h1 id=\"题意\">题意：</h1>\r\n<p>给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。</p>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。</p>\r\n<p>子序列自动机的基本概念是用二维数组保存对于i位置\r\nj字符第一次出现的位置为nxt[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。</p>\r\n<p>这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA\"，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">26</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==n) nxt[i][j]=n;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nxt[i][j]=nxt[i<span class=\"number\">+1</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=n) nxt[i][s[i]-<span class=\"string\">&#x27;A&#x27;</span>]=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pos</span><span class=\"params\">(<span class=\"type\">int</span> st,string s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> first=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> ch:s)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first) st=nxt[st][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> st=nxt[st<span class=\"number\">+1</span>][ch-<span class=\"string\">&#x27;A&#x27;</span>];</span><br><span class=\"line\">        first=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st==n) <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">get_next</span>();</span><br><span class=\"line\">    string ac=<span class=\"string\">&quot;ACCEPT&quot;</span>,wa=<span class=\"string\">&quot;WA&quot;</span>;</span><br><span class=\"line\">    ll ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> r1=<span class=\"built_in\">get_pos</span>(i,ac),r2=<span class=\"built_in\">get_pos</span>(i,wa);</span><br><span class=\"line\">        r1=<span class=\"built_in\">max</span>(r1,i+k<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ans=ans+<span class=\"built_in\">max</span>(r2-r1,<span class=\"number\">0ll</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"思维题1","date":"2024-08-14T11:35:22.000Z","_content":"# 题意\n题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小\n\n# 题解\n题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt->ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。\n\n<!--more-->\n\n```cpp\nvoid slove(){\n    cin>>n;\n    string s;\n    cin>>s;\n    int cnt = 0,ans = 0;\n\n    for(int i=0;i<n;i++){\n        if(s[i]=='0'){\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2)%MOD;\n        }else if(s[i]&1){\n            cnt=(cnt*2+1)%MOD;\n        }else{\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2+1)%MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。\n\n对于每一个偶数计算它的贡献值为$$2^{i-1}$$，对于每一个0计算它的贡献为$$-2^{n-i}$$，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。","source":"_posts/思维题习题1.md","raw":"---\ntitle: 思维题1\ndate: 2024-08-14 19:35:22\ntags: [算法, 思维题]\ncategories: \n\t- 算法\n\t- 思维题\n---\n# 题意\n题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小\n\n# 题解\n题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt->ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。\n\n<!--more-->\n\n```cpp\nvoid slove(){\n    cin>>n;\n    string s;\n    cin>>s;\n    int cnt = 0,ans = 0;\n\n    for(int i=0;i<n;i++){\n        if(s[i]=='0'){\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2)%MOD;\n        }else if(s[i]&1){\n            cnt=(cnt*2+1)%MOD;\n        }else{\n            ans=(ans+cnt+1)%MOD;\n            cnt=(cnt*2+1)%MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。\n\n对于每一个偶数计算它的贡献值为$$2^{i-1}$$，对于每一个0计算它的贡献为$$-2^{n-i}$$，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。","slug":"思维题习题1","published":1,"updated":"2024-08-14T13:39:08.223Z","comments":1,"layout":"post","photos":[],"_id":"clzusvytd001cwwwvb4nkb9tb","content":"<h1 id=\"题意\">题意</h1>\r\n<p>题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小</p>\r\n<h1 id=\"题解\">题解</h1>\r\n<p>题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt-&gt;ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。</p>\r\n<p>对于每一个偶数计算它的贡献值为<span\r\nclass=\"math display\">\\[2^{i-1}\\]</span>，对于每一个0计算它的贡献为<span\r\nclass=\"math display\">\\[-2^{n-i}\\]</span>，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。</p>\r\n","length":345,"excerpt":"<h1 id=\"题意\">题意</h1>\r\n<p>题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小</p>\r\n<h1 id=\"题解\">题解</h1>\r\n<p>题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt-&gt;ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;0&#x27;</span>)&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans=(ans+cnt<span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">            cnt=(cnt*<span class=\"number\">2</span><span class=\"number\">+1</span>)%MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。</p>\r\n<p>对于每一个偶数计算它的贡献值为<span\r\nclass=\"math display\">\\[2^{i-1}\\]</span>，对于每一个0计算它的贡献为<span\r\nclass=\"math display\">\\[-2^{n-i}\\]</span>，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。</p>"},{"title":"数学距离问题1","date":"2024-08-14T11:43:20.000Z","_content":"## 题意：\n\n给一个国际象棋中的“象”，但每次只能走一格，给N个点\n\n计算总和 $\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N \\text{dist}(P_i, P_j)$​ 。\n\n<!--more-->\n\n## 题解：\n\n注意到实际上这样的走法将整个棋盘以$$x+y$$的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\n$$\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\n$$\n即两个点之间的切比雪夫距离。\n\n证明如下，对于任意两个$$x+y$$奇偶性相同的顶点而言，设起始点为$$(x,y)$$，目的点为$$(xx,yy)$$设dx<dy即$$dist(p_i,p_j) = |p_i.y-p_j.y|$$。\n\n$$xx=x+dx,yy=y+dy$$，则有$$dx = a-b，a+b=dy$$，根据定义可知$$dy=yy-y$$​。\n\n由以上公式,且x,y的奇偶性相同可知xx为在dx<dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。\n\n详细参考[距离 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/geometry/distance/)\n\n如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）\n\n上图(1,4) -> (1,3)\n\n于是题目变为了求n个点的哈密顿距离之和，很经典的题。\n\n由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。\n\n<img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" />\n\ncoding。。。\n\n```cpp\nvoid slove() {\n    cin>>n;\n\n    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;\n\n    for(int i=1;i<=n;i++) {\n        if((a[i].x+a[i].y) %2==1)\n            bx[1][++cn[1]] = a[i].x + a[i].y,by[1][cn[1]] = a[i].y - a[i].x;\n        else\n            bx[0][++cn[0]] = a[i].x + a[i].y,by[0][cn[0]] = a[i].y - a[i].x;\n    }\n\n    sort(bx[0]+1,bx[0]+1+cn[0]);\n    sort(bx[1]+1,bx[1]+1+cn[1]);\n    sort(by[0]+1,by[0]+1+cn[0]);\n    sort(by[1]+1,by[1]+1+cn[1]);\n    int ans = 0;\n    for(int k =0;k<=1;k++) {\n        int sum1 =0 ,sum2=0;\n        for(int i=1;i<=cn[k];i++) {\n            // cout<<k<<' '<<bx[k][i]<<' '<<by[k][i]<<endl;\n            ans += (i-1) * (bx[k][i]+by[k][i]) - sum1-sum2;\n            sum1 += bx[k][i];\n            sum2 += by[k][i];\n        }\n    }\n    cout<<ans/2<<endl;\n}\n```\n\n","source":"_posts/数学距离问题1.md","raw":"---\ntitle: 数学距离问题1\ndate: 2024-08-14 19:43:20\ntags: [算法, 思维题, 坐标系转换, 几何问题]\ncategories: \n\t- 算法\n\t- 思维题\n---\n## 题意：\n\n给一个国际象棋中的“象”，但每次只能走一格，给N个点\n\n计算总和 $\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N \\text{dist}(P_i, P_j)$​ 。\n\n<!--more-->\n\n## 题解：\n\n注意到实际上这样的走法将整个棋盘以$$x+y$$的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\n$$\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\n$$\n即两个点之间的切比雪夫距离。\n\n证明如下，对于任意两个$$x+y$$奇偶性相同的顶点而言，设起始点为$$(x,y)$$，目的点为$$(xx,yy)$$设dx<dy即$$dist(p_i,p_j) = |p_i.y-p_j.y|$$。\n\n$$xx=x+dx,yy=y+dy$$，则有$$dx = a-b，a+b=dy$$，根据定义可知$$dy=yy-y$$​。\n\n由以上公式,且x,y的奇偶性相同可知xx为在dx<dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。\n\n详细参考[距离 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/geometry/distance/)\n\n如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）\n\n上图(1,4) -> (1,3)\n\n于是题目变为了求n个点的哈密顿距离之和，很经典的题。\n\n由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。\n\n<img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" />\n\ncoding。。。\n\n```cpp\nvoid slove() {\n    cin>>n;\n\n    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;\n\n    for(int i=1;i<=n;i++) {\n        if((a[i].x+a[i].y) %2==1)\n            bx[1][++cn[1]] = a[i].x + a[i].y,by[1][cn[1]] = a[i].y - a[i].x;\n        else\n            bx[0][++cn[0]] = a[i].x + a[i].y,by[0][cn[0]] = a[i].y - a[i].x;\n    }\n\n    sort(bx[0]+1,bx[0]+1+cn[0]);\n    sort(bx[1]+1,bx[1]+1+cn[1]);\n    sort(by[0]+1,by[0]+1+cn[0]);\n    sort(by[1]+1,by[1]+1+cn[1]);\n    int ans = 0;\n    for(int k =0;k<=1;k++) {\n        int sum1 =0 ,sum2=0;\n        for(int i=1;i<=cn[k];i++) {\n            // cout<<k<<' '<<bx[k][i]<<' '<<by[k][i]<<endl;\n            ans += (i-1) * (bx[k][i]+by[k][i]) - sum1-sum2;\n            sum1 += bx[k][i];\n            sum2 += by[k][i];\n        }\n    }\n    cout<<ans/2<<endl;\n}\n```\n\n","slug":"数学距离问题1","published":1,"updated":"2024-08-14T13:39:11.945Z","comments":1,"layout":"post","photos":[],"_id":"clzusvytd001ewwwv22pehka0","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>给一个国际象棋中的“象”，但每次只能走一格，给N个点</p>\r\n<p>计算总和 <span\r\nclass=\"math inline\">\\(\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N\r\n\\text{dist}(P_i, P_j)\\)</span>​ 。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>注意到实际上这样的走法将整个棋盘以<span\r\nclass=\"math display\">\\[x+y\\]</span>的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\r\n<span class=\"math display\">\\[\r\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\r\n\\]</span> 即两个点之间的切比雪夫距离。</p>\r\n<p>证明如下，对于任意两个<span\r\nclass=\"math display\">\\[x+y\\]</span>奇偶性相同的顶点而言，设起始点为<span\r\nclass=\"math display\">\\[(x,y)\\]</span>，目的点为<span\r\nclass=\"math display\">\\[(xx,yy)\\]</span>设dx&lt;dy即<span\r\nclass=\"math display\">\\[dist(p_i,p_j) = |p_i.y-p_j.y|\\]</span>。</p>\r\n<p><span class=\"math display\">\\[xx=x+dx,yy=y+dy\\]</span>，则有<span\r\nclass=\"math display\">\\[dx = a-b，a+b=dy\\]</span>，根据定义可知<span\r\nclass=\"math display\">\\[dy=yy-y\\]</span>​。</p>\r\n<p>由以上公式,且x,y的奇偶性相同可知xx为在dx&lt;dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。</p>\r\n<p>详细参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaS13aWtpLm9yZy9nZW9tZXRyeS9kaXN0YW5jZS8=\">距离 - OI\r\nWiki (oi-wiki.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）</p>\r\n<p>上图(1,4) -&gt; (1,3)</p>\r\n<p>于是题目变为了求n个点的哈密顿距离之和，很经典的题。</p>\r\n<p>由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。</p>\r\n<p><img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" /></p>\r\n<p>coding。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((a[i].x+a[i].y) %<span class=\"number\">2</span>==<span class=\"number\">1</span>)</span><br><span class=\"line\">            bx[<span class=\"number\">1</span>][++cn[<span class=\"number\">1</span>]] = a[i].x + a[i].y,by[<span class=\"number\">1</span>][cn[<span class=\"number\">1</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            bx[<span class=\"number\">0</span>][++cn[<span class=\"number\">0</span>]] = a[i].x + a[i].y,by[<span class=\"number\">0</span>][cn[<span class=\"number\">0</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k =<span class=\"number\">0</span>;k&lt;=<span class=\"number\">1</span>;k++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum1 =<span class=\"number\">0</span> ,sum2=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cn[k];i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;bx[k][i]&lt;&lt;&#x27; &#x27;&lt;&lt;by[k][i]&lt;&lt;endl;</span></span><br><span class=\"line\">            ans += (i<span class=\"number\">-1</span>) * (bx[k][i]+by[k][i]) - sum1-sum2;</span><br><span class=\"line\">            sum1 += bx[k][i];</span><br><span class=\"line\">            sum2 += by[k][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":638,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>给一个国际象棋中的“象”，但每次只能走一格，给N个点</p>\r\n<p>计算总和 <span\r\nclass=\"math inline\">\\(\\displaystyle\\sum_{i=1}^{N-1}\\displaystyle\\sum_{j=i+1}^N\r\n\\text{dist}(P_i, P_j)\\)</span>​ 。</p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>注意到实际上这样的走法将整个棋盘以<span\r\nclass=\"math display\">\\[x+y\\]</span>的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：\r\n<span class=\"math display\">\\[\r\ndist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)\r\n\\]</span> 即两个点之间的切比雪夫距离。</p>\r\n<p>证明如下，对于任意两个<span\r\nclass=\"math display\">\\[x+y\\]</span>奇偶性相同的顶点而言，设起始点为<span\r\nclass=\"math display\">\\[(x,y)\\]</span>，目的点为<span\r\nclass=\"math display\">\\[(xx,yy)\\]</span>设dx&lt;dy即<span\r\nclass=\"math display\">\\[dist(p_i,p_j) = |p_i.y-p_j.y|\\]</span>。</p>\r\n<p><span class=\"math display\">\\[xx=x+dx,yy=y+dy\\]</span>，则有<span\r\nclass=\"math display\">\\[dx = a-b，a+b=dy\\]</span>，根据定义可知<span\r\nclass=\"math display\">\\[dy=yy-y\\]</span>​。</p>\r\n<p>由以上公式,且x,y的奇偶性相同可知xx为在dx&lt;dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。</p>\r\n<p>详细参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vaS13aWtpLm9yZy9nZW9tZXRyeS9kaXN0YW5jZS8=\">距离 - OI\r\nWiki (oi-wiki.org)<i class=\"fa fa-external-link-alt\"></i></span></p>\r\n<p>如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）</p>\r\n<p>上图(1,4) -&gt; (1,3)</p>\r\n<p>于是题目变为了求n个点的哈密顿距离之和，很经典的题。</p>\r\n<p>由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。</p>\r\n<p><img src=\"D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png\" alt=\"831c358c475935b97351ba39f7cf0fa9\" style=\"zoom:25%;\" /></p>\r\n<p>coding。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((a[i].x+a[i].y) %<span class=\"number\">2</span>==<span class=\"number\">1</span>)</span><br><span class=\"line\">            bx[<span class=\"number\">1</span>][++cn[<span class=\"number\">1</span>]] = a[i].x + a[i].y,by[<span class=\"number\">1</span>][cn[<span class=\"number\">1</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            bx[<span class=\"number\">0</span>][++cn[<span class=\"number\">0</span>]] = a[i].x + a[i].y,by[<span class=\"number\">0</span>][cn[<span class=\"number\">0</span>]] = a[i].y - a[i].x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,bx[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">0</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>,by[<span class=\"number\">1</span>]<span class=\"number\">+1</span>+cn[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k =<span class=\"number\">0</span>;k&lt;=<span class=\"number\">1</span>;k++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum1 =<span class=\"number\">0</span> ,sum2=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cn[k];i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;bx[k][i]&lt;&lt;&#x27; &#x27;&lt;&lt;by[k][i]&lt;&lt;endl;</span></span><br><span class=\"line\">            ans += (i<span class=\"number\">-1</span>) * (bx[k][i]+by[k][i]) - sum1-sum2;</span><br><span class=\"line\">            sum1 += bx[k][i];</span><br><span class=\"line\">            sum2 += by[k][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"树上最短回文问题","date":"2024-08-14T11:39:46.000Z","_content":"## 题意\n\n给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？\n\n<!--more-->\n\n## 题解\n\n不想看回文的读者请跳转到“真的题解”\n\n看到回文，回顾回文！下面以数组为例子，求最长回文字符串。\n\n回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度\n\n回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。\n\n回文哈希二分：对于i，从前从后hax，二分回文长度。\n\n二分如下：\n\n```cpp\null get(ull h[], ull l, ull r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = p[i-1] * P;\n    int t =0;\n    while(cin>>s,s!=\"END\") {\n        n = s.size();\n\n        n *= 2;\n        s.resize(n);\n        for (int i = n; i; i -= 2)\n        {\n            s[i] = s[i / 2];\n            s[i - 1] = '#';\n        }\n        s = '#' + s;\n        n++;\n        // cout<<n<<endl;\n        // cout<<s<<nline;\n\n        for(int i=0;i<n;i++)if(!i) ph[i] = s[i];else ph[i] = ph[i-1] * P + s[i];\n        for(int i=n-1;~i;i--)if(i==n-1) rh[i] = s[i];else rh[i] = rh[i+1] * P + s[i];\n\n        int ans = 1;\n        for (int i = 1; i <= n; i ++ )\n        {\n            ull r = min(i - 1, n - i);\n            if (ans >= r || get(ph, i - ans, i - 1) != get(rh, n - (i + ans) + 1, n - i)) continue;\n            while (ans <= r && get(ph, i - ans, i - 1) == get(rh, n - (i + ans) + 1, n - i)) ans ++ ;\n            ans -- ;\n        }\n        cout<<\"Case \" << ++t<<\": \"<<ans<<endl;\n    }\n}\n```\n\n题解要开始加速了！\n\n首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化$$log_2n$$的解法！\n\n注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！\n\n```cpp\null ans = 1;\nfor (int i = 1; i <= n; i ++ )\n{\n  ull r = min(i - 1, n - i);\n  if (ans >= r || get(h1, i - ans, i - 1) != get(h2, n - (i + ans) + 1, n - i)) continue;\n  while (ans <= r && get(h1, i - ans, i - 1) == get(h2, n - (i + ans) + 1, n - i)) ans ++ ;\n  ans -- ;\n}\n```\n\n最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。\n\n简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R 回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）\n\n整个该算法的重点在于：“回文对称”！\n\n![img](https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg)\n\n即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。\n\n若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。\n\n若i-w[i_mirror]>=0即i_mirror的回文子串碰到了边界，则中心扩展i\n\n```cpp\n// 马拉车算法\npublic String longestPalindrome2(String s) {\n    String T = preProcess(s);\n    int n = T.length();\n    int[] P = new int[n];\n    int C = 0, R = 0;\n    for (int i = 1; i < n - 1; i++) {\n        int i_mirror = 2 * C - i;\n        if (R > i) {\n            P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R\n        } else {\n            P[i] = 0;// 等于 R 的情况\n        }\n\n        // 碰到之前讲的三种情况时候，需要利用中心扩展法\n        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\n            P[i]++;\n        }\n\n        // 判断是否需要更新 R\n        if (i + P[i] > R) {\n            C = i;\n            R = i + P[i];\n        }\n\n    }\n   \\\\代码source :https://zhuanlan.zhihu.com/p/70532099\n```\n\n## 真的题解\n\n上面讲了一串，最后还得是哈！希！，字符串，哈！希！\n\n最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。\n\n注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大$$n^2$$）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！\n\n但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。\n\n但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。\n\n```cpp\nvoid add(int a,int b) {\n    e[a].pb(b);\n    e[b].pb(a);\n}\n\nint qmi(int a,int b,int mod){\n    int res=1%mod;\n    while(b){\n        if(b&1) res=res*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return res;\n}\n\nvoid dfs1(int u = 1) {\n    siz[u] = 1;\n    int mx = 0;\n    for(int& v: e[u]) {\n        if(v==fa[u])continue;\n\n        depth[v] = depth[u] + 1;\n        ph[v]=(ph[u]*P%MOD+(s[v]-'a'+1))%MOD;\n        rh[v]=(rh[u]+p[depth[v]-1]*(s[v]-'a'+1)% MOD)%MOD;\n\n        f[v][0] = u;\n        for(int i=1;i<=20;i++)\n            f[v][i] = f[f[v][i-1]][i-1];\n        dfs1(v);\n        siz[u] += siz[v];\n        if(siz[v] > mx) {\n            mx = siz[v];hs[u] = v;\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int t = 1) {\n    len[t] ++;\n    top[u] = t;\n    if(siz[u] == 1) return ;\n    dfs2(hs[u],t);\n\n    for(int v: e[u]) {\n        if(v!=hs[u]&&v!=fa[u]) {\n            dfs2(v,v);\n        }\n    }\n}\n\nint lca(int a,int b) {\n    while(top[a] != top[b]) {\n        if(depth[top[a]] < depth[top[b]])swap(a,b);\n        a = fa[top[a]];\n    }\n    if(depth[a] < depth[b]) swap(a,b);\n    return b;\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = (p[i-1] * P) % MOD;\n    cin>>n;\n    cin>>s;\n    s = ' ' + s;\n    depth[1] = 1;\n    for(int i=1;i<=n;i++) {\n        cin>>fa[i];\n        if(fa[i]) add(i,fa[i]);\n        else fa[i] = -1;\n    }\n\n\n    ph[1]=s[1]-'a'+1,rh[1]=s[1]-'a'+1;\n    dfs1();dfs2();\n\n    cin>>m;\n    while(m--) {\n        int a,b;cin>>a>>b;\n        if(depth[a] < depth[b]) swap(a,b);\n        lc = lca(a,b);\n\n        int f=lca(a,b);\n        int p1=((rh[a]-rh[fa[f]]*qmi(p[depth[f]-1],MOD-2,MOD)%MOD)+MOD) %MOD;\n        int p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;\n        int ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;\n        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*qmi(p[depth[f]-1],MOD-2,MOD)%MOD;\n        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;\n        int ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;\n        cout<<(ans1==ans2?\"YES\\n\":\"NO\\n\");\n        cout<<f<<endl;\n        cout<<ans1<<' '<<ans2<<nline;\n    }\n}\n```\n\n","source":"_posts/树上回文问题.md","raw":"---\ntitle: 树上最短回文问题\ndate: 2024-08-14 19:39:46\ntags: [算法, 树问题，哈希算法]\ncategories: \n\t- 算法\n\t- 图论\n\t- 图论中的回文问题\n---\n## 题意\n\n给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？\n\n<!--more-->\n\n## 题解\n\n不想看回文的读者请跳转到“真的题解”\n\n看到回文，回顾回文！下面以数组为例子，求最长回文字符串。\n\n回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度\n\n回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。\n\n回文哈希二分：对于i，从前从后hax，二分回文长度。\n\n二分如下：\n\n```cpp\null get(ull h[], ull l, ull r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = p[i-1] * P;\n    int t =0;\n    while(cin>>s,s!=\"END\") {\n        n = s.size();\n\n        n *= 2;\n        s.resize(n);\n        for (int i = n; i; i -= 2)\n        {\n            s[i] = s[i / 2];\n            s[i - 1] = '#';\n        }\n        s = '#' + s;\n        n++;\n        // cout<<n<<endl;\n        // cout<<s<<nline;\n\n        for(int i=0;i<n;i++)if(!i) ph[i] = s[i];else ph[i] = ph[i-1] * P + s[i];\n        for(int i=n-1;~i;i--)if(i==n-1) rh[i] = s[i];else rh[i] = rh[i+1] * P + s[i];\n\n        int ans = 1;\n        for (int i = 1; i <= n; i ++ )\n        {\n            ull r = min(i - 1, n - i);\n            if (ans >= r || get(ph, i - ans, i - 1) != get(rh, n - (i + ans) + 1, n - i)) continue;\n            while (ans <= r && get(ph, i - ans, i - 1) == get(rh, n - (i + ans) + 1, n - i)) ans ++ ;\n            ans -- ;\n        }\n        cout<<\"Case \" << ++t<<\": \"<<ans<<endl;\n    }\n}\n```\n\n题解要开始加速了！\n\n首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化$$log_2n$$的解法！\n\n注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！\n\n```cpp\null ans = 1;\nfor (int i = 1; i <= n; i ++ )\n{\n  ull r = min(i - 1, n - i);\n  if (ans >= r || get(h1, i - ans, i - 1) != get(h2, n - (i + ans) + 1, n - i)) continue;\n  while (ans <= r && get(h1, i - ans, i - 1) == get(h2, n - (i + ans) + 1, n - i)) ans ++ ;\n  ans -- ;\n}\n```\n\n最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。\n\n简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R 回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）\n\n整个该算法的重点在于：“回文对称”！\n\n![img](https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg)\n\n即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。\n\n若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。\n\n若i-w[i_mirror]>=0即i_mirror的回文子串碰到了边界，则中心扩展i\n\n```cpp\n// 马拉车算法\npublic String longestPalindrome2(String s) {\n    String T = preProcess(s);\n    int n = T.length();\n    int[] P = new int[n];\n    int C = 0, R = 0;\n    for (int i = 1; i < n - 1; i++) {\n        int i_mirror = 2 * C - i;\n        if (R > i) {\n            P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R\n        } else {\n            P[i] = 0;// 等于 R 的情况\n        }\n\n        // 碰到之前讲的三种情况时候，需要利用中心扩展法\n        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\n            P[i]++;\n        }\n\n        // 判断是否需要更新 R\n        if (i + P[i] > R) {\n            C = i;\n            R = i + P[i];\n        }\n\n    }\n   \\\\代码source :https://zhuanlan.zhihu.com/p/70532099\n```\n\n## 真的题解\n\n上面讲了一串，最后还得是哈！希！，字符串，哈！希！\n\n最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。\n\n注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大$$n^2$$）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！\n\n但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。\n\n但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。\n\n```cpp\nvoid add(int a,int b) {\n    e[a].pb(b);\n    e[b].pb(a);\n}\n\nint qmi(int a,int b,int mod){\n    int res=1%mod;\n    while(b){\n        if(b&1) res=res*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return res;\n}\n\nvoid dfs1(int u = 1) {\n    siz[u] = 1;\n    int mx = 0;\n    for(int& v: e[u]) {\n        if(v==fa[u])continue;\n\n        depth[v] = depth[u] + 1;\n        ph[v]=(ph[u]*P%MOD+(s[v]-'a'+1))%MOD;\n        rh[v]=(rh[u]+p[depth[v]-1]*(s[v]-'a'+1)% MOD)%MOD;\n\n        f[v][0] = u;\n        for(int i=1;i<=20;i++)\n            f[v][i] = f[f[v][i-1]][i-1];\n        dfs1(v);\n        siz[u] += siz[v];\n        if(siz[v] > mx) {\n            mx = siz[v];hs[u] = v;\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int t = 1) {\n    len[t] ++;\n    top[u] = t;\n    if(siz[u] == 1) return ;\n    dfs2(hs[u],t);\n\n    for(int v: e[u]) {\n        if(v!=hs[u]&&v!=fa[u]) {\n            dfs2(v,v);\n        }\n    }\n}\n\nint lca(int a,int b) {\n    while(top[a] != top[b]) {\n        if(depth[top[a]] < depth[top[b]])swap(a,b);\n        a = fa[top[a]];\n    }\n    if(depth[a] < depth[b]) swap(a,b);\n    return b;\n}\n\nvoid slove(){\n    p[0] = 1;\n    for(int i=1;i<N;i++) p[i] = (p[i-1] * P) % MOD;\n    cin>>n;\n    cin>>s;\n    s = ' ' + s;\n    depth[1] = 1;\n    for(int i=1;i<=n;i++) {\n        cin>>fa[i];\n        if(fa[i]) add(i,fa[i]);\n        else fa[i] = -1;\n    }\n\n\n    ph[1]=s[1]-'a'+1,rh[1]=s[1]-'a'+1;\n    dfs1();dfs2();\n\n    cin>>m;\n    while(m--) {\n        int a,b;cin>>a>>b;\n        if(depth[a] < depth[b]) swap(a,b);\n        lc = lca(a,b);\n\n        int f=lca(a,b);\n        int p1=((rh[a]-rh[fa[f]]*qmi(p[depth[f]-1],MOD-2,MOD)%MOD)+MOD) %MOD;\n        int p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;\n        int ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;\n        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*qmi(p[depth[f]-1],MOD-2,MOD)%MOD;\n        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;\n        int ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;\n        cout<<(ans1==ans2?\"YES\\n\":\"NO\\n\");\n        cout<<f<<endl;\n        cout<<ans1<<' '<<ans2<<nline;\n    }\n}\n```\n\n","slug":"树上回文问题","published":1,"updated":"2024-08-14T13:39:14.786Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyte001hwwwv8cqi2tn5","content":"<h2 id=\"题意\">题意</h2>\r\n<p>给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>不想看回文的读者请跳转到“真的题解”</p>\r\n<p>看到回文，回顾回文！下面以数组为例子，求最长回文字符串。</p>\r\n<p>回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度</p>\r\n<p>回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。</p>\r\n<p>回文哈希二分：对于i，从前从后hax，二分回文长度。</p>\r\n<p>二分如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ull <span class=\"title\">get</span><span class=\"params\">(ull h[], ull l, ull r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h[r] - h[l - <span class=\"number\">1</span>] * p[r - l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = p[i<span class=\"number\">-1</span>] * P;</span><br><span class=\"line\">    <span class=\"type\">int</span> t =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;s,s!=<span class=\"string\">&quot;END&quot;</span>) &#123;</span><br><span class=\"line\">        n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i; i -= <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s[i] = s[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">            s[i - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s = <span class=\"string\">&#x27;#&#x27;</span> + s;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;s&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"keyword\">if</span>(!i) ph[i] = s[i];<span class=\"keyword\">else</span> ph[i] = ph[i<span class=\"number\">-1</span>] * P + s[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n<span class=\"number\">-1</span>;~i;i--)<span class=\"keyword\">if</span>(i==n<span class=\"number\">-1</span>) rh[i] = s[i];<span class=\"keyword\">else</span> rh[i] = rh[i<span class=\"number\">+1</span>] * P + s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">            ans -- ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case &quot;</span> &lt;&lt; ++t&lt;&lt;<span class=\"string\">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>题解要开始加速了！</p>\r\n<p>首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化<span\r\nclass=\"math display\">\\[log_2n\\]</span>的解法！</p>\r\n<p>注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ull ans = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">  ans -- ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。</p>\r\n<p>简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R\r\n回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）</p>\r\n<p>整个该算法的重点在于：“回文对称”！</p>\r\n<figure>\r\n<img\r\nsrc=\"https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。</p>\r\n<p>若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。</p>\r\n<p>若i-w[i_mirror]&gt;=0即i_mirror的回文子串碰到了边界，则中心扩展i</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 马拉车算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome2</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    String T = <span class=\"built_in\">preProcess</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = T.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] P = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n];</span><br><span class=\"line\">    <span class=\"type\">int</span> C = <span class=\"number\">0</span>, R = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i_mirror = <span class=\"number\">2</span> * C - i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (R &gt; i) &#123;</span><br><span class=\"line\">            P[i] = Math.<span class=\"built_in\">min</span>(R - i, P[i_mirror]);<span class=\"comment\">// 防止超出 R</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            P[i] = <span class=\"number\">0</span>;<span class=\"comment\">// 等于 R 的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T.<span class=\"built_in\">charAt</span>(i + <span class=\"number\">1</span> + P[i]) == T.<span class=\"built_in\">charAt</span>(i - <span class=\"number\">1</span> - P[i])) &#123;</span><br><span class=\"line\">            P[i]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否需要更新 R</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + P[i] &gt; R) &#123;</span><br><span class=\"line\">            C = i;</span><br><span class=\"line\">            R = i + P[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \\\\代码source :https:<span class=\"comment\">//zhuanlan.zhihu.com/p/70532099</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"真的题解\">真的题解</h2>\r\n<p>上面讲了一串，最后还得是哈！希！，字符串，哈！希！</p>\r\n<p>最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。</p>\r\n<p>注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大<span\r\nclass=\"math display\">\\[n^2\\]</span>）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！</p>\r\n<p>但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。</p>\r\n<p>但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">    e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">qmi</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> mod)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">1</span>%mod;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res=res*a%mod;</span><br><span class=\"line\">        a=a*a%mod;</span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    siz[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span>&amp; v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==fa[u])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        depth[v] = depth[u] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        ph[v]=(ph[u]*P%MOD+(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>))%MOD;</span><br><span class=\"line\">        rh[v]=(rh[u]+p[depth[v]<span class=\"number\">-1</span>]*(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>)% MOD)%MOD;</span><br><span class=\"line\"></span><br><span class=\"line\">        f[v][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">20</span>;i++)</span><br><span class=\"line\">            f[v][i] = f[f[v][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">dfs1</span>(v);</span><br><span class=\"line\">        siz[u] += siz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[v] &gt; mx) &#123;</span><br><span class=\"line\">            mx = siz[v];hs[u] = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>, <span class=\"type\">int</span> t = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    len[t] ++;</span><br><span class=\"line\">    top[u] = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(siz[u] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(hs[u],t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v!=hs[u]&amp;&amp;v!=fa[u]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs2</span>(v,v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[a] != top[b]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[top[a]] &lt; depth[top[b]])<span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        a = fa[top[a]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = (p[i<span class=\"number\">-1</span>] * P) % MOD;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    s = <span class=\"string\">&#x27; &#x27;</span> + s;</span><br><span class=\"line\">    depth[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;fa[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fa[i]) <span class=\"built_in\">add</span>(i,fa[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> fa[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    ph[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>,rh[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dfs1</span>();<span class=\"built_in\">dfs2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        lc = <span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> f=<span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\">        <span class=\"type\">int</span> p1=((rh[a]-rh[fa[f]]*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD)+MOD) %MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD;</span><br><span class=\"line\">        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        cout&lt;&lt;(ans1==ans2?<span class=\"string\">&quot;YES\\n&quot;</span>:<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        cout&lt;&lt;f&lt;&lt;endl;</span><br><span class=\"line\">        cout&lt;&lt;ans1&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;nline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1668,"excerpt":"<h2 id=\"题意\">题意</h2>\r\n<p>给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？</p>","more":"<h2 id=\"题解\">题解</h2>\r\n<p>不想看回文的读者请跳转到“真的题解”</p>\r\n<p>看到回文，回顾回文！下面以数组为例子，求最长回文字符串。</p>\r\n<p>回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度</p>\r\n<p>回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。</p>\r\n<p>回文哈希二分：对于i，从前从后hax，二分回文长度。</p>\r\n<p>二分如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ull <span class=\"title\">get</span><span class=\"params\">(ull h[], ull l, ull r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h[r] - h[l - <span class=\"number\">1</span>] * p[r - l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = p[i<span class=\"number\">-1</span>] * P;</span><br><span class=\"line\">    <span class=\"type\">int</span> t =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;s,s!=<span class=\"string\">&quot;END&quot;</span>) &#123;</span><br><span class=\"line\">        n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i; i -= <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s[i] = s[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">            s[i - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s = <span class=\"string\">&#x27;#&#x27;</span> + s;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;s&lt;&lt;nline;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"keyword\">if</span>(!i) ph[i] = s[i];<span class=\"keyword\">else</span> ph[i] = ph[i<span class=\"number\">-1</span>] * P + s[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n<span class=\"number\">-1</span>;~i;i--)<span class=\"keyword\">if</span>(i==n<span class=\"number\">-1</span>) rh[i] = s[i];<span class=\"keyword\">else</span> rh[i] = rh[i<span class=\"number\">+1</span>] * P + s[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(ph, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(rh, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">            ans -- ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case &quot;</span> &lt;&lt; ++t&lt;&lt;<span class=\"string\">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>题解要开始加速了！</p>\r\n<p>首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化<span\r\nclass=\"math display\">\\[log_2n\\]</span>的解法！</p>\r\n<p>注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ull ans = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ull r = <span class=\"built_in\">min</span>(i - <span class=\"number\">1</span>, n - i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ans &gt;= r || <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) != <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ans &lt;= r &amp;&amp; <span class=\"built_in\">get</span>(h1, i - ans, i - <span class=\"number\">1</span>) == <span class=\"built_in\">get</span>(h2, n - (i + ans) + <span class=\"number\">1</span>, n - i)) ans ++ ;</span><br><span class=\"line\">  ans -- ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。</p>\r\n<p>简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R\r\n回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）</p>\r\n<p>整个该算法的重点在于：“回文对称”！</p>\r\n<figure>\r\n<img\r\nsrc=\"https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg\"\r\nalt=\"img\" />\r\n<figcaption aria-hidden=\"true\">img</figcaption>\r\n</figure>\r\n<p>即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。</p>\r\n<p>若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。</p>\r\n<p>若i-w[i_mirror]&gt;=0即i_mirror的回文子串碰到了边界，则中心扩展i</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 马拉车算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome2</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    String T = <span class=\"built_in\">preProcess</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = T.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] P = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n];</span><br><span class=\"line\">    <span class=\"type\">int</span> C = <span class=\"number\">0</span>, R = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i_mirror = <span class=\"number\">2</span> * C - i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (R &gt; i) &#123;</span><br><span class=\"line\">            P[i] = Math.<span class=\"built_in\">min</span>(R - i, P[i_mirror]);<span class=\"comment\">// 防止超出 R</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            P[i] = <span class=\"number\">0</span>;<span class=\"comment\">// 等于 R 的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T.<span class=\"built_in\">charAt</span>(i + <span class=\"number\">1</span> + P[i]) == T.<span class=\"built_in\">charAt</span>(i - <span class=\"number\">1</span> - P[i])) &#123;</span><br><span class=\"line\">            P[i]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否需要更新 R</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + P[i] &gt; R) &#123;</span><br><span class=\"line\">            C = i;</span><br><span class=\"line\">            R = i + P[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \\\\代码source :https:<span class=\"comment\">//zhuanlan.zhihu.com/p/70532099</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"真的题解\">真的题解</h2>\r\n<p>上面讲了一串，最后还得是哈！希！，字符串，哈！希！</p>\r\n<p>最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。</p>\r\n<p>注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大<span\r\nclass=\"math display\">\\[n^2\\]</span>）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！</p>\r\n<p>但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。</p>\r\n<p>但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    e[a].<span class=\"built_in\">pb</span>(b);</span><br><span class=\"line\">    e[b].<span class=\"built_in\">pb</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">qmi</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> mod)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">1</span>%mod;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) res=res*a%mod;</span><br><span class=\"line\">        a=a*a%mod;</span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    siz[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span>&amp; v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==fa[u])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        depth[v] = depth[u] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        ph[v]=(ph[u]*P%MOD+(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>))%MOD;</span><br><span class=\"line\">        rh[v]=(rh[u]+p[depth[v]<span class=\"number\">-1</span>]*(s[v]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>)% MOD)%MOD;</span><br><span class=\"line\"></span><br><span class=\"line\">        f[v][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">20</span>;i++)</span><br><span class=\"line\">            f[v][i] = f[f[v][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"built_in\">dfs1</span>(v);</span><br><span class=\"line\">        siz[u] += siz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[v] &gt; mx) &#123;</span><br><span class=\"line\">            mx = siz[v];hs[u] = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u = <span class=\"number\">1</span>, <span class=\"type\">int</span> t = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    len[t] ++;</span><br><span class=\"line\">    top[u] = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(siz[u] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(hs[u],t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v!=hs[u]&amp;&amp;v!=fa[u]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs2</span>(v,v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[a] != top[b]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[top[a]] &lt; depth[top[b]])<span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        a = fa[top[a]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;N;i++) p[i] = (p[i<span class=\"number\">-1</span>] * P) % MOD;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cin&gt;&gt;s;</span><br><span class=\"line\">    s = <span class=\"string\">&#x27; &#x27;</span> + s;</span><br><span class=\"line\">    depth[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;fa[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fa[i]) <span class=\"built_in\">add</span>(i,fa[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> fa[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    ph[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>,rh[<span class=\"number\">1</span>]=s[<span class=\"number\">1</span>]-<span class=\"string\">&#x27;a&#x27;</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dfs1</span>();<span class=\"built_in\">dfs2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(depth[a] &lt; depth[b]) <span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">        lc = <span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> f=<span class=\"built_in\">lca</span>(a,b);</span><br><span class=\"line\">        <span class=\"type\">int</span> p1=((rh[a]-rh[fa[f]]*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD)+MOD) %MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*<span class=\"built_in\">qmi</span>(p[depth[f]<span class=\"number\">-1</span>],MOD<span class=\"number\">-2</span>,MOD)%MOD;</span><br><span class=\"line\">        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;</span><br><span class=\"line\">        cout&lt;&lt;(ans1==ans2?<span class=\"string\">&quot;YES\\n&quot;</span>:<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        cout&lt;&lt;f&lt;&lt;endl;</span><br><span class=\"line\">        cout&lt;&lt;ans1&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;nline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题","date":"2024-08-14T11:30:37.000Z","_content":"# 题意：\n\n给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。\n\n你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个**连续的子段**，然后从该子段中删除**所有**元素，**除**该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。\n\n如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。\n\n<!--more-->\n\n# 题解：\n\n根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。\n\n考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]<a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l_{a_i}$下标为j，则小于j且大于$l_{a_j}$的下标k的下标idx均无法转移至i，显然$l_{a_i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l_{a_x}$则无法转移到i。\n\n总结状态转移为$f_i = \\sum_{k={l_{a_i}+1}}^{i-1} f_k + \\sum_{k=l^x(l_{a_i})}^{k>0}f_{k}$\n\n前缀和处理即可。\n\n```cpp\n\tvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n\n    s[top] = {-1,-1};\n    for(int i = 1;i <= n;i++) {\n        while(top && s[top].x > a[i]) top--;\n        l[i] = s[top].y;\n        s[++top] = {a[i],i};\n    }\n\n    // for(int i=1;i<=n;i++) cout<<l[i]<<' ';\n    // cout<<endl;\n\n    for(int i=0;i<=n;i++) pre1[i] = pre2[i] = 0;\n\n    f[0] = 1;\n    pre1[0] = 1;\n    for(int i=1;i<=n;i++) {\n        if(l[i]!=-1) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;\n        int t = l[i] == -1 ? 0: pre1[l[i]];\n        f[i] = (pre1[i-1] - t) % MOD ;\n        // cout<<(pre1[i-1] - t)<<' ';\n        f[i] += pre2[i];\n\n        pre1[i] = pre1[i-1] + f[i] % MOD;\n        // cout<<i<<' '<<pre1[i]<<' '<<pre2[i]<<' '<<f[i]<<nline;\n    }\n\n    int mi = 1e18,ans = 0;\n    for(int i=n; i>=1; i--) {\n        mi = min(mi,a[i]);\n        if(mi==a[i]) {\n            ans = (ans + f[i]) % MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n","source":"_posts/状态转移习题1.md","raw":"---\ntitle: 状态转移习题\ndate: 2024-08-14 19:30:37\ntags: [算法, 状态转移]\ncategories: \n\t- 算法\n\t- 状态转移\n---\n# 题意：\n\n给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。\n\n你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p 中选择一个**连续的子段**，然后从该子段中删除**所有**元素，**除**该子段中最小的元素。例如，如果选择p = [3, 1, 4, 7, 5, 2, 6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3, 1, 2, 6]。\n\n如果数组 a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a 就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。\n\n<!--more-->\n\n# 题解：\n\n根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留 𝑎𝑖 的情况下的贡献值。\n\n考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖 是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为$dp(i) += dp(j)(其中a[j]<a[i])$另外一种情况则是，不对i进行操作。考虑上一个比$a[i]$小的数为$l_{a_i}$下标为j，则小于j且大于$l_{a_j}$的下标k的下标idx均无法转移至i，显然$l_{a_i}$是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于$l_{a_x}$则无法转移到i。\n\n总结状态转移为$f_i = \\sum_{k={l_{a_i}+1}}^{i-1} f_k + \\sum_{k=l^x(l_{a_i})}^{k>0}f_{k}$\n\n前缀和处理即可。\n\n```cpp\n\tvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n\n    s[top] = {-1,-1};\n    for(int i = 1;i <= n;i++) {\n        while(top && s[top].x > a[i]) top--;\n        l[i] = s[top].y;\n        s[++top] = {a[i],i};\n    }\n\n    // for(int i=1;i<=n;i++) cout<<l[i]<<' ';\n    // cout<<endl;\n\n    for(int i=0;i<=n;i++) pre1[i] = pre2[i] = 0;\n\n    f[0] = 1;\n    pre1[0] = 1;\n    for(int i=1;i<=n;i++) {\n        if(l[i]!=-1) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;\n        int t = l[i] == -1 ? 0: pre1[l[i]];\n        f[i] = (pre1[i-1] - t) % MOD ;\n        // cout<<(pre1[i-1] - t)<<' ';\n        f[i] += pre2[i];\n\n        pre1[i] = pre1[i-1] + f[i] % MOD;\n        // cout<<i<<' '<<pre1[i]<<' '<<pre2[i]<<' '<<f[i]<<nline;\n    }\n\n    int mi = 1e18,ans = 0;\n    for(int i=n; i>=1; i--) {\n        mi = min(mi,a[i]);\n        if(mi==a[i]) {\n            ans = (ans + f[i]) % MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n","slug":"状态转移习题1","published":1,"updated":"2024-08-14T13:39:18.757Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyte001kwwwvfrigf7s3","content":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。</p>\r\n<p>你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p\r\n中选择一个<strong>连续的子段</strong>，然后从该子段中删除<strong>所有</strong>元素，<strong>除</strong>该子段中最小的元素。例如，如果选择p\r\n= [3, 1, 4, 7, 5, 2,\r\n6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3,\r\n1, 2, 6]。</p>\r\n<p>如果数组\r\na可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a\r\n就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留\r\n𝑎𝑖 的情况下的贡献值。</p>\r\n<p>考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖\r\n是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为<span\r\nclass=\"math inline\">\\(dp(i) +=\r\ndp(j)(其中a[j]&lt;a[i])\\)</span>另外一种情况则是，不对i进行操作。考虑上一个比<span\r\nclass=\"math inline\">\\(a[i]\\)</span>小的数为<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>下标为j，则小于j且大于<span\r\nclass=\"math inline\">\\(l_{a_j}\\)</span>的下标k的下标idx均无法转移至i，显然<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于<span\r\nclass=\"math inline\">\\(l_{a_x}\\)</span>则无法转移到i。</p>\r\n<p>总结状态转移为<span class=\"math inline\">\\(f_i =\r\n\\sum_{k={l_{a_i}+1}}^{i-1} f_k +\r\n\\sum_{k=l^x(l_{a_i})}^{k&gt;0}f_{k}\\)</span></p>\r\n<p>前缀和处理即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    s[top] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(top &amp;&amp; s[top].x &gt; a[i]) top--;</span><br><span class=\"line\">        l[i] = s[top].y;</span><br><span class=\"line\">        s[++top] = &#123;a[i],i&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;l[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++) pre1[i] = pre2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    pre1[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l[i]!=<span class=\"number\">-1</span>) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = l[i] == <span class=\"number\">-1</span> ? <span class=\"number\">0</span>: pre1[l[i]];</span><br><span class=\"line\">        f[i] = (pre1[i<span class=\"number\">-1</span>] - t) % MOD ;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;(pre1[i-1] - t)&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">        f[i] += pre2[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        pre1[i] = pre1[i<span class=\"number\">-1</span>] + f[i] % MOD;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;pre1[i]&lt;&lt;&#x27; &#x27;&lt;&lt;pre2[i]&lt;&lt;&#x27; &#x27;&lt;&lt;f[i]&lt;&lt;nline;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mi = <span class=\"number\">1e18</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n; i&gt;=<span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        mi = <span class=\"built_in\">min</span>(mi,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mi==a[i]) &#123;</span><br><span class=\"line\">            ans = (ans + f[i]) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":708,"excerpt":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。</p>\r\n<p>你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p\r\n中选择一个<strong>连续的子段</strong>，然后从该子段中删除<strong>所有</strong>元素，<strong>除</strong>该子段中最小的元素。例如，如果选择p\r\n= [3, 1, 4, 7, 5, 2,\r\n6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3,\r\n1, 2, 6]。</p>\r\n<p>如果数组\r\na可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a\r\n就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。</p>","more":"<h1 id=\"题解\">题解：</h1>\r\n<p>根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留\r\n𝑎𝑖 的情况下的贡献值。</p>\r\n<p>考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖\r\n是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为<span\r\nclass=\"math inline\">\\(dp(i) +=\r\ndp(j)(其中a[j]&lt;a[i])\\)</span>另外一种情况则是，不对i进行操作。考虑上一个比<span\r\nclass=\"math inline\">\\(a[i]\\)</span>小的数为<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>下标为j，则小于j且大于<span\r\nclass=\"math inline\">\\(l_{a_j}\\)</span>的下标k的下标idx均无法转移至i，显然<span\r\nclass=\"math inline\">\\(l_{a_i}\\)</span>是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于<span\r\nclass=\"math inline\">\\(l_{a_x}\\)</span>则无法转移到i。</p>\r\n<p>总结状态转移为<span class=\"math inline\">\\(f_i =\r\n\\sum_{k={l_{a_i}+1}}^{i-1} f_k +\r\n\\sum_{k=l^x(l_{a_i})}^{k&gt;0}f_{k}\\)</span></p>\r\n<p>前缀和处理即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    s[top] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(top &amp;&amp; s[top].x &gt; a[i]) top--;</span><br><span class=\"line\">        l[i] = s[top].y;</span><br><span class=\"line\">        s[++top] = &#123;a[i],i&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;l[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++) pre1[i] = pre2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    pre1[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l[i]!=<span class=\"number\">-1</span>) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = l[i] == <span class=\"number\">-1</span> ? <span class=\"number\">0</span>: pre1[l[i]];</span><br><span class=\"line\">        f[i] = (pre1[i<span class=\"number\">-1</span>] - t) % MOD ;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;(pre1[i-1] - t)&lt;&lt;&#x27; &#x27;;</span></span><br><span class=\"line\">        f[i] += pre2[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        pre1[i] = pre1[i<span class=\"number\">-1</span>] + f[i] % MOD;</span><br><span class=\"line\">        <span class=\"comment\">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;pre1[i]&lt;&lt;&#x27; &#x27;&lt;&lt;pre2[i]&lt;&lt;&#x27; &#x27;&lt;&lt;f[i]&lt;&lt;nline;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mi = <span class=\"number\">1e18</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n; i&gt;=<span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        mi = <span class=\"built_in\">min</span>(mi,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mi==a[i]) &#123;</span><br><span class=\"line\">            ans = (ans + f[i]) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题2","date":"2024-08-14T11:32:13.000Z","_content":"# 题意：\n\n给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。\n\n首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。\n\n然后，你必须使数组中的所有元素相等。一开始，你选择一个**正**整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。**注意， x 在所有操作中都是一样的**。\n\n选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？\n\n<!--more-->\n\n# 题解：\n\n容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。\n\n可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。\n\n```\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int mx = -INF;\n    for(int i=1;i<=n;i++) {\n        mx = max(mx,a[i]);\n    }\n\n    for(int i=1;i<=n;i++) d[i] = mx - a[i];\n\n    int gd = 0;\n    for(int i=1;i<=n;i++) gd = __gcd(d[i],gd);\n\n    if(!gd) {cout<<1<<endl;return ;}\n\n    ll sum = 0;\n    set<int> S;\n    for(int i=1;i<=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);\n    int t = 1;\n    while(1) if(S.count(t)) t++;else break;\n    cout<<sum + t<<endl;\n}\n```","source":"_posts/状态转移习题2.md","raw":"---\ntitle: 状态转移习题2\ndate: 2024-08-14 19:32:13\ntags: [算法, 状态转移]\ncategories: \n\t- 算法\n\t- 状态转移\n---\n# 题意：\n\n给你一个整数数组   1, 2,…,    ，它的所有元素都是不同的。\n\n首先，要求你在数组中再插入一个整数   an+1 。  an +1 不应等于  a1, a2,…, an中的任何一个。\n\n然后，你必须使数组中的所有元素相等。一开始，你选择一个**正**整数 x。在一次操作中，你将 x 恰好加到数组的一个元素上。**注意， x 在所有操作中都是一样的**。\n\n选择  +1 和 x 后，使所有元素相等的最小操作次数是多少？\n\n<!--more-->\n\n# 题解：\n\n容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于 ∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖) （mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。\n\n可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。\n\n```\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n\n    int mx = -INF;\n    for(int i=1;i<=n;i++) {\n        mx = max(mx,a[i]);\n    }\n\n    for(int i=1;i<=n;i++) d[i] = mx - a[i];\n\n    int gd = 0;\n    for(int i=1;i<=n;i++) gd = __gcd(d[i],gd);\n\n    if(!gd) {cout<<1<<endl;return ;}\n\n    ll sum = 0;\n    set<int> S;\n    for(int i=1;i<=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);\n    int t = 1;\n    while(1) if(S.count(t)) t++;else break;\n    cout<<sum + t<<endl;\n}\n```","slug":"状态转移习题2","published":1,"updated":"2024-08-14T13:39:21.942Z","comments":1,"layout":"post","photos":[],"_id":"clzusvytx006nwwwv8qd670hd","content":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个整数数组 1, 2,…, ，它的所有元素都是不同的。</p>\r\n<p>首先，要求你在数组中再插入一个整数 an+1 。 an +1 不应等于 a1, a2,…,\r\nan中的任何一个。</p>\r\n<p>然后，你必须使数组中的所有元素相等。一开始，你选择一个<strong>正</strong>整数\r\nx。在一次操作中，你将 x 恰好加到数组的一个元素上。<strong>注意， x\r\n在所有操作中都是一样的</strong>。</p>\r\n<p>选择 +1 和 x 后，使所有元素相等的最小操作次数是多少？</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"题解\">题解：</h1>\r\n<p>容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于\r\n∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖)\r\n（mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。</p>\r\n<p>可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void slove()&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int mx = -INF;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        mx = max(mx,a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) d[i] = mx - a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int gd = 0;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) gd = __gcd(d[i],gd);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!gd) &#123;cout&lt;&lt;1&lt;&lt;endl;return ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll sum = 0;</span><br><span class=\"line\">    set&lt;int&gt; S;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);</span><br><span class=\"line\">    int t = 1;</span><br><span class=\"line\">    while(1) if(S.count(t)) t++;else break;</span><br><span class=\"line\">    cout&lt;&lt;sum + t&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":355,"excerpt":"<h1 id=\"题意\">题意：</h1>\r\n<p>给你一个整数数组 1, 2,…, ，它的所有元素都是不同的。</p>\r\n<p>首先，要求你在数组中再插入一个整数 an+1 。 an +1 不应等于 a1, a2,…,\r\nan中的任何一个。</p>\r\n<p>然后，你必须使数组中的所有元素相等。一开始，你选择一个<strong>正</strong>整数\r\nx。在一次操作中，你将 x 恰好加到数组的一个元素上。<strong>注意， x\r\n在所有操作中都是一样的</strong>。</p>\r\n<p>选择 +1 和 x 后，使所有元素相等的最小操作次数是多少？</p>","more":"<h1 id=\"题解\">题解：</h1>\r\n<p>容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于\r\n∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖)\r\n（mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。</p>\r\n<p>可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void slove()&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int mx = -INF;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        mx = max(mx,a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) d[i] = mx - a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    int gd = 0;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) gd = __gcd(d[i],gd);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!gd) &#123;cout&lt;&lt;1&lt;&lt;endl;return ;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll sum = 0;</span><br><span class=\"line\">    set&lt;int&gt; S;</span><br><span class=\"line\">    for(int i=1;i&lt;=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);</span><br><span class=\"line\">    int t = 1;</span><br><span class=\"line\">    while(1) if(S.count(t)) t++;else break;</span><br><span class=\"line\">    cout&lt;&lt;sum + t&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"状态转移习题3","date":"2024-08-14T11:38:14.000Z","_content":"## 题意：\n\n对一个数组的所有非空子区间，计算这个公式$$w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus a_j $$的和。\n\n<!--more-->\n\n## 题解：\n\n非常经典的题目，看见了就再巩固一下。\n\n1. 拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\\lceil log_2mx\\rceil$个数组。计算每一位的贡献。\n\n当拆位后原式子会变为这样的\n$$\nallW = \\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil log_2mx\\rceil}cnt(a_{i-x} != a_{x})\n$$\n这个复杂度仍然是爆炸的，因此需要继续优化\n\n很容易想到的一个优化就是，对于$$a_i \\oplus a_j$$他是满足交换律的，即$$a_i \\oplus a_j = a_j \\oplus a_i$$因此我们仅需要计算单边值即可（然后乘2。\n\n因此将原有的式子改写$$w =2 \\times (\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) $$虽然对于$$a_i$$本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。\n\n再转头考虑所有子区间的问题，一个数组的所有子区间显然是$$n^2$$级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为$$i\\times (n-j+1)$$（下标从1开始），则对任意i,j，其贡献值为以下公式\n$$\nw(bt,{i,j}) = (i\\times (n-j+1) * (1<<bt) * (bit(x,a_i)\\not=bit(x,a_j))\n$$\n施展数学的神奇魔法！\n\n提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算$$a_j$$ 与$$a_i|i<j$$的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。\n\n最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。\n\n```cpp\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n\n    ll ans = 0;\n    for(int bt = 0;bt <=29;bt++) {\n        ll s1=0,s2 =0;\n        for(int i=1;i<=n;i++) {\n            if(a[i] >>bt&1) {\n                ans = (ans + s2 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s1 += i;\n                s1 %= MOD;\n            }\n            else {\n                ans = (ans + s1 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s2 += i;\n                s2 %= MOD;\n            }\n        }\n    }\n    cout<<(2ll * ans)%MOD<<endl;\n}\n```\n\n不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。","source":"_posts/状态转移习题3.md","raw":"---\ntitle: 状态转移习题3\ndate: 2024-08-14 19:38:14\ntags: [算法, 状态转移, 异或问题]\ncategories: \n\t- 算法\n\t- 状态转移\n\t- 状态转移中的异或问题\n---\n## 题意：\n\n对一个数组的所有非空子区间，计算这个公式$$w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus a_j $$的和。\n\n<!--more-->\n\n## 题解：\n\n非常经典的题目，看见了就再巩固一下。\n\n1. 拆位， 对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。 即将整个数组拆分为$\\lceil log_2mx\\rceil$个数组。计算每一位的贡献。\n\n当拆位后原式子会变为这样的\n$$\nallW = \\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil log_2mx\\rceil}cnt(a_{i-x} != a_{x})\n$$\n这个复杂度仍然是爆炸的，因此需要继续优化\n\n很容易想到的一个优化就是，对于$$a_i \\oplus a_j$$他是满足交换律的，即$$a_i \\oplus a_j = a_j \\oplus a_i$$因此我们仅需要计算单边值即可（然后乘2。\n\n因此将原有的式子改写$$w =2 \\times (\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) $$虽然对于$$a_i$$本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。\n\n再转头考虑所有子区间的问题，一个数组的所有子区间显然是$$n^2$$级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为$$i\\times (n-j+1)$$（下标从1开始），则对任意i,j，其贡献值为以下公式\n$$\nw(bt,{i,j}) = (i\\times (n-j+1) * (1<<bt) * (bit(x,a_i)\\not=bit(x,a_j))\n$$\n施展数学的神奇魔法！\n\n提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算$$a_j$$ 与$$a_i|i<j$$的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。\n\n最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。\n\n```cpp\nvoid slove(){\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n\n    ll ans = 0;\n    for(int bt = 0;bt <=29;bt++) {\n        ll s1=0,s2 =0;\n        for(int i=1;i<=n;i++) {\n            if(a[i] >>bt&1) {\n                ans = (ans + s2 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s1 += i;\n                s1 %= MOD;\n            }\n            else {\n                ans = (ans + s1 * (n-i+1) % MOD * (1<<bt) % MOD) % MOD;\n                s2 += i;\n                s2 %= MOD;\n            }\n        }\n    }\n    cout<<(2ll * ans)%MOD<<endl;\n}\n```\n\n不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。","slug":"状态转移习题3","published":1,"updated":"2024-08-14T13:39:25.704Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyty006owwwvc1u95rfo","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>对一个数组的所有非空子区间，计算这个公式<span\r\nclass=\"math display\">\\[w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus\r\na_j \\]</span>的和。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>非常经典的题目，看见了就再巩固一下。</p>\r\n<ol type=\"1\">\r\n<li>拆位，\r\n对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。\r\n即将整个数组拆分为<span class=\"math inline\">\\(\\lceil\r\nlog_2mx\\rceil\\)</span>个数组。计算每一位的贡献。</li>\r\n</ol>\r\n<p>当拆位后原式子会变为这样的 <span class=\"math display\">\\[\r\nallW =\r\n\\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil\r\nlog_2mx\\rceil}cnt(a_{i-x} != a_{x})\r\n\\]</span> 这个复杂度仍然是爆炸的，因此需要继续优化</p>\r\n<p>很容易想到的一个优化就是，对于<span class=\"math display\">\\[a_i \\oplus\r\na_j\\]</span>他是满足交换律的，即<span class=\"math display\">\\[a_i \\oplus\r\na_j = a_j \\oplus a_i\\]</span>因此我们仅需要计算单边值即可（然后乘2。</p>\r\n<p>因此将原有的式子改写<span class=\"math display\">\\[w =2 \\times\r\n(\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) \\]</span>虽然对于<span\r\nclass=\"math display\">\\[a_i\\]</span>本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。</p>\r\n<p>再转头考虑所有子区间的问题，一个数组的所有子区间显然是<span\r\nclass=\"math display\">\\[n^2\\]</span>级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为<span\r\nclass=\"math display\">\\[i\\times\r\n(n-j+1)\\]</span>（下标从1开始），则对任意i,j，其贡献值为以下公式 <span\r\nclass=\"math display\">\\[\r\nw(bt,{i,j}) = (i\\times (n-j+1) * (1&lt;&lt;bt) *\r\n(bit(x,a_i)\\not=bit(x,a_j))\r\n\\]</span> 施展数学的神奇魔法！</p>\r\n<p>提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算<span\r\nclass=\"math display\">\\[a_j\\]</span> 与<span\r\nclass=\"math display\">\\[a_i|i&lt;j\\]</span>的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。</p>\r\n<p>最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> bt = <span class=\"number\">0</span>;bt &lt;=<span class=\"number\">29</span>;bt++) &#123;</span><br><span class=\"line\">        ll s1=<span class=\"number\">0</span>,s2 =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt;&gt;bt&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = (ans + s2 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s1 += i;</span><br><span class=\"line\">                s1 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = (ans + s1 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s2 += i;</span><br><span class=\"line\">                s2 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"number\">2ll</span> * ans)%MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。</p>\r\n","length":705,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>对一个数组的所有非空子区间，计算这个公式<span\r\nclass=\"math display\">\\[w = \\sum_{i=l}^{i=r} \\sum_{j=l}^{j=r}a_i \\oplus\r\na_j \\]</span>的和。</p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>非常经典的题目，看见了就再巩固一下。</p>\r\n<ol type=\"1\">\r\n<li>拆位，\r\n对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。\r\n即将整个数组拆分为<span class=\"math inline\">\\(\\lceil\r\nlog_2mx\\rceil\\)</span>个数组。计算每一位的贡献。</li>\r\n</ol>\r\n<p>当拆位后原式子会变为这样的 <span class=\"math display\">\\[\r\nallW =\r\n\\sum_{l=1}^{l=r}\\sum_{r=l}^{r=n}\\sum_{i=l}^{i=r}\\sum_{x=0}^{x=\\lceil\r\nlog_2mx\\rceil}cnt(a_{i-x} != a_{x})\r\n\\]</span> 这个复杂度仍然是爆炸的，因此需要继续优化</p>\r\n<p>很容易想到的一个优化就是，对于<span class=\"math display\">\\[a_i \\oplus\r\na_j\\]</span>他是满足交换律的，即<span class=\"math display\">\\[a_i \\oplus\r\na_j = a_j \\oplus a_i\\]</span>因此我们仅需要计算单边值即可（然后乘2。</p>\r\n<p>因此将原有的式子改写<span class=\"math display\">\\[w =2 \\times\r\n(\\sum_{i=l}^{i=r} \\sum_{j=l}^{j=i}a_i \\oplus a_j) \\]</span>虽然对于<span\r\nclass=\"math display\">\\[a_i\\]</span>本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。</p>\r\n<p>再转头考虑所有子区间的问题，一个数组的所有子区间显然是<span\r\nclass=\"math display\">\\[n^2\\]</span>级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为<span\r\nclass=\"math display\">\\[i\\times\r\n(n-j+1)\\]</span>（下标从1开始），则对任意i,j，其贡献值为以下公式 <span\r\nclass=\"math display\">\\[\r\nw(bt,{i,j}) = (i\\times (n-j+1) * (1&lt;&lt;bt) *\r\n(bit(x,a_i)\\not=bit(x,a_j))\r\n\\]</span> 施展数学的神奇魔法！</p>\r\n<p>提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算<span\r\nclass=\"math display\">\\[a_j\\]</span> 与<span\r\nclass=\"math display\">\\[a_i|i&lt;j\\]</span>的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。</p>\r\n<p>最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> bt = <span class=\"number\">0</span>;bt &lt;=<span class=\"number\">29</span>;bt++) &#123;</span><br><span class=\"line\">        ll s1=<span class=\"number\">0</span>,s2 =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt;&gt;bt&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = (ans + s2 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s1 += i;</span><br><span class=\"line\">                s1 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = (ans + s1 * (n-i<span class=\"number\">+1</span>) % MOD * (<span class=\"number\">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class=\"line\">                s2 += i;</span><br><span class=\"line\">                s2 %= MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"number\">2ll</span> * ans)%MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。</p>"},{"title":"状态转移习题4","date":"2024-08-14T11:41:55.000Z","_content":"## 题意：\n\n给定m条线段，求将1-n覆盖两次的所有方案数\n\n<!--more-->\n\n## 题解：\n\n离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。\n\n个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。\n\n状态表示这样设计：$$dpi,j,k$$表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。\n\n之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    dp[0][0][0] = 1;\n    for(int i=1;i<=m;i++) {\n        for(int ii=0;ii<i;ii++) {\n            for(int j=200;j;j--) {\n                for(int k = 200;k;k--)\n                    dp[i][j][k] = dp[ii][j][k];\n            }\n            for(int j=200;~j;j--) {\n                for(int k = 200;~k;k--) {\n                    if(mp[segs[i].x] <= j+1) {\n                        if(mp[segs[i].x] > k+1) {\n                            dp[i][max(mp[segs[i].y], j)][k] =\n                                (dp[i][max(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][k]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"!\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<k<<' '<<dp[i][max(mp[segs[i].y], j)][k]<<nline;\n                            // }\n                        }\n                        else {\n                            dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] =\n                                (dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"?\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<max(k,min(j,mp[segs[i].y]))<<' '<<\n                            //         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]<<nline;\n                            // }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<dp[m][mp[n]][mp[n]]<<endl;\n}\n```\n\n这段代码中显然有一个很严重的问题：时间复杂度为$$1.6e^{9}$$略微有点超出复杂度\n\n其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。\n\n时间如何优化？\n\n首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f\\[i]\\[j][k] += f\\[i - 1]\\[j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        segs[i].x--;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    for(int i=1;i<=m;i++) {\n        segs[i].x = mp[segs[i].x];\n        segs[i].y = mp[segs[i].y];\n    }\n\n    f[0][0][0] = 1;\n    for (int k = 1; k <= m; k++) {\n        for (int i = 0; i <= mp[n]; i++) {\n            for (int j = i; j <= mp[n]; j++) {\n                if (f[k - 1][i][j] == 0) {\n                    continue;\n                }\n                f[k][i][j] += f[k - 1][i][j];\n                f[k][i][j] %=MOD;\n                if (segs[k].x <= i) {\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]+=f[k - 1][i][j];\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]%=MOD;\n                }\n            }\n        }\n    }\n\n    cout<<f[m][mp[n]][mp[n]]% MOD<<endl;\n}\n```\n","source":"_posts/状态转移习题4.md","raw":"---\ntitle: 状态转移习题4\ndate: 2024-08-14 19:41:55\ntags: [算法, 状态转移, 离散化]\ncategories: \n\t- 算法\n\t- 状态转移\n\t- 复杂状态转移与优化\n---\n## 题意：\n\n给定m条线段，求将1-n覆盖两次的所有方案数\n\n<!--more-->\n\n## 题解：\n\n离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。\n\n个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。\n\n状态表示这样设计：$$dpi,j,k$$表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。\n\n之后可以根据segs[i].x 是否小于两个前缀长度做转移了。暴力转移code如下\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    dp[0][0][0] = 1;\n    for(int i=1;i<=m;i++) {\n        for(int ii=0;ii<i;ii++) {\n            for(int j=200;j;j--) {\n                for(int k = 200;k;k--)\n                    dp[i][j][k] = dp[ii][j][k];\n            }\n            for(int j=200;~j;j--) {\n                for(int k = 200;~k;k--) {\n                    if(mp[segs[i].x] <= j+1) {\n                        if(mp[segs[i].x] > k+1) {\n                            dp[i][max(mp[segs[i].y], j)][k] =\n                                (dp[i][max(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][k]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"!\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<k<<' '<<dp[i][max(mp[segs[i].y], j)][k]<<nline;\n                            // }\n                        }\n                        else {\n                            dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] =\n                                (dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;\n                            // if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&&dp[ii][j][k]) {\n                            //     cout<<ii<<' '<<j<<' '<<k<<endl;\n                            //     cout<<\"?\"<<i<<' '<<max(mp[segs[i].y], j)<<' '<<max(k,min(j,mp[segs[i].y]))<<' '<<\n                            //         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]<<nline;\n                            // }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<dp[m][mp[n]][mp[n]]<<endl;\n}\n```\n\n这段代码中显然有一个很严重的问题：时间复杂度为$$1.6e^{9}$$略微有点超出复杂度\n\n其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。\n\n时间如何优化？\n\n首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f\\[i]\\[j][k] += f\\[i - 1]\\[j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。\n\n```cpp\nvoid slove(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) {\n        cin>>segs[i].x>>segs[i].y;\n        segs[i].x--;\n        poss.push_back(segs[i].x);\n        poss.push_back(segs[i].y);\n    }\n    poss.push_back(0);\n    poss.push_back(n);\n    sort(all(poss));\n    poss.erase(unique(all(poss)),poss.end());\n\n    for(int i=0;i<poss.size();i++) mp[poss[i]] = i;\n\n    sort(segs+1,segs+1+m);\n\n    for(int i=1;i<=m;i++) {\n        segs[i].x = mp[segs[i].x];\n        segs[i].y = mp[segs[i].y];\n    }\n\n    f[0][0][0] = 1;\n    for (int k = 1; k <= m; k++) {\n        for (int i = 0; i <= mp[n]; i++) {\n            for (int j = i; j <= mp[n]; j++) {\n                if (f[k - 1][i][j] == 0) {\n                    continue;\n                }\n                f[k][i][j] += f[k - 1][i][j];\n                f[k][i][j] %=MOD;\n                if (segs[k].x <= i) {\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]+=f[k - 1][i][j];\n                    f[k][max(i, min(j, segs[k].y))][max(j, segs[k].y)]%=MOD;\n                }\n            }\n        }\n    }\n\n    cout<<f[m][mp[n]][mp[n]]% MOD<<endl;\n}\n```\n","slug":"状态转移习题4","published":1,"updated":"2024-08-14T13:39:29.254Z","comments":1,"layout":"post","photos":[],"_id":"clzusvytz006qwwwvdmueb9l3","content":"<h2 id=\"题意\">题意：</h2>\r\n<p>给定m条线段，求将1-n覆盖两次的所有方案数</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题解\">题解：</h2>\r\n<p>离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。</p>\r\n<p>个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。</p>\r\n<p>状态表示这样设计：<span\r\nclass=\"math display\">\\[dpi,j,k\\]</span>表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。</p>\r\n<p>之后可以根据segs[i].x\r\n是否小于两个前缀长度做转移了。暴力转移code如下</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=<span class=\"number\">0</span>;ii&lt;i;ii++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;k;k--)</span><br><span class=\"line\">                    dp[i][j][k] = dp[ii][j][k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;~j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;~k;k--) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(mp[segs[i].x] &lt;= j<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(mp[segs[i].x] &gt; k<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][k] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][k]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;!&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][max(mp[segs[i].y], j)][k]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;?&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;max(k,min(j,mp[segs[i].y]))&lt;&lt;&#x27; &#x27;&lt;&lt;</span></span><br><span class=\"line\">                            <span class=\"comment\">//         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;dp[m][mp[n]][mp[n]]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这段代码中显然有一个很严重的问题：时间复杂度为<span\r\nclass=\"math display\">\\[1.6e^{9}\\]</span>略微有点超出复杂度</p>\r\n<p>其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。</p>\r\n<p>时间如何优化？</p>\r\n<p>首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f[i][j][k]\r\n+= f[i -\r\n1][j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        segs[i].x--;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        segs[i].x = mp[segs[i].x];</span><br><span class=\"line\">        segs[i].y = mp[segs[i].y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= m; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= mp[n]; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= mp[n]; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f[k - <span class=\"number\">1</span>][i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                f[k][i][j] += f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                f[k][i][j] %=MOD;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (segs[k].x &lt;= i) &#123;</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]+=f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]%=MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;f[m][mp[n]][mp[n]]% MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","length":1004,"excerpt":"<h2 id=\"题意\">题意：</h2>\r\n<p>给定m条线段，求将1-n覆盖两次的所有方案数</p>","more":"<h2 id=\"题解\">题解：</h2>\r\n<p>离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。</p>\r\n<p>个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。</p>\r\n<p>状态表示这样设计：<span\r\nclass=\"math display\">\\[dpi,j,k\\]</span>表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。</p>\r\n<p>之后可以根据segs[i].x\r\n是否小于两个前缀长度做转移了。暴力转移code如下</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> ii=<span class=\"number\">0</span>;ii&lt;i;ii++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;k;k--)</span><br><span class=\"line\">                    dp[i][j][k] = dp[ii][j][k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">200</span>;~j;j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">200</span>;~k;k--) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(mp[segs[i].x] &lt;= j<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(mp[segs[i].x] &gt; k<span class=\"number\">+1</span>) &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][k] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][k]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;!&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][max(mp[segs[i].y], j)][k]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] =</span><br><span class=\"line\">                                (dp[i][<span class=\"built_in\">max</span>(mp[segs[i].y], j)][<span class=\"built_in\">max</span>(k,<span class=\"built_in\">min</span>(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;</span><br><span class=\"line\">                            <span class=\"comment\">// if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class=\"line\">                            <span class=\"comment\">//     cout&lt;&lt;&quot;?&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;max(k,min(j,mp[segs[i].y]))&lt;&lt;&#x27; &#x27;&lt;&lt;</span></span><br><span class=\"line\">                            <span class=\"comment\">//         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&lt;&lt;nline;</span></span><br><span class=\"line\">                            <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;dp[m][mp[n]][mp[n]]&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这段代码中显然有一个很严重的问题：时间复杂度为<span\r\nclass=\"math display\">\\[1.6e^{9}\\]</span>略微有点超出复杂度</p>\r\n<p>其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。</p>\r\n<p>时间如何优化？</p>\r\n<p>首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f[i][j][k]\r\n+= f[i -\r\n1][j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class=\"line\">        segs[i].x--;</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].x);</span><br><span class=\"line\">        poss.<span class=\"built_in\">push_back</span>(segs[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    poss.<span class=\"built_in\">push_back</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(<span class=\"built_in\">all</span>(poss));</span><br><span class=\"line\">    poss.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(<span class=\"built_in\">all</span>(poss)),poss.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;poss.<span class=\"built_in\">size</span>();i++) mp[poss[i]] = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(segs<span class=\"number\">+1</span>,segs<span class=\"number\">+1</span>+m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) &#123;</span><br><span class=\"line\">        segs[i].x = mp[segs[i].x];</span><br><span class=\"line\">        segs[i].y = mp[segs[i].y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    f[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= m; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= mp[n]; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= mp[n]; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f[k - <span class=\"number\">1</span>][i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                f[k][i][j] += f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                f[k][i][j] %=MOD;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (segs[k].x &lt;= i) &#123;</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]+=f[k - <span class=\"number\">1</span>][i][j];</span><br><span class=\"line\">                    f[k][<span class=\"built_in\">max</span>(i, <span class=\"built_in\">min</span>(j, segs[k].y))][<span class=\"built_in\">max</span>(j, segs[k].y)]%=MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;f[m][mp[n]][mp[n]]% MOD&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估","date":"2024-08-14T11:41:55.000Z","_content":"\n于江西理工大学信息安全课程的论文综述\n\n学术，未发表，Miarcl\n下载连接：http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\n\n感谢母校对我的指导\n\n{% pdf http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf 3000px}","source":"_posts/由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估.md","raw":"---\ntitle: 由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估\ndate: 2024-08-14 19:41:55\ntags: [信息安全, 加密算法, Miracl, ECC]\ncategories: \n\t- 学术\n\t- 综述\n---\n\n于江西理工大学信息安全课程的论文综述\n\n学术，未发表，Miarcl\n下载连接：http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\n\n感谢母校对我的指导\n\n{% pdf http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf 3000px}","slug":"由RSA到ECC浅谈非对称公钥-私钥密码系统常见几种信息加密算法实现比较和评估","published":1,"updated":"2024-08-15T02:58:38.900Z","comments":1,"layout":"post","photos":[],"_id":"clzusvyu0006twwwvee1p1s6b","content":"<p>于江西理工大学信息安全课程的论文综述</p>\r\n<p>学术，未发表，Miarcl\r\n下载连接：http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf</p>\r\n<p>感谢母校对我的指导</p>\r\n<p><div class=\"pdfobject-container\" data-target=\"http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\" data-height=\"3000px}</p>\"></div>","length":115,"excerpt":"","more":"<p>于江西理工大学信息安全课程的论文综述</p>\r\n<p>学术，未发表，Miarcl\r\n下载连接：http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf</p>\r\n<p>感谢母校对我的指导</p>\r\n<p><div class=\"pdfobject-container\" data-target=\"http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf\" data-height=\"3000px}</p>\"></div>"}],"PostAsset":[],"PostCategory":[{"post_id":"clzusvyt20009wwwvd8z48qh3","category_id":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvyth0022wwwvcreggghd"},{"post_id":"clzusvyt20009wwwvd8z48qh3","category_id":"clzusvyt7000owwwv1plj0vlu","_id":"clzusvyth0024wwwv7cz8dirr"},{"post_id":"clzusvyt20009wwwvd8z48qh3","category_id":"clzusvytg001uwwwvgecz9yop","_id":"clzusvyth0026wwwv8s5e4iqg"},{"post_id":"clzusvysv0001wwwv1nmh880t","category_id":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvyti002dwwwvc58tazex"},{"post_id":"clzusvysv0001wwwv1nmh880t","category_id":"clzusvyt7000owwwv1plj0vlu","_id":"clzusvyti002ewwwv283f4e7q"},{"post_id":"clzusvysv0001wwwv1nmh880t","category_id":"clzusvyth0027wwwvflpfdi18","_id":"clzusvyti002hwwwvek1n8g81"},{"post_id":"clzusvyt2000bwwwv3eo93ppa","category_id":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvytj002pwwwvc6kg2ly6"},{"post_id":"clzusvyt2000bwwwv3eo93ppa","category_id":"clzusvyt7000owwwv1plj0vlu","_id":"clzusvytj002rwwwv210mbbuc"},{"post_id":"clzusvyt2000bwwwv3eo93ppa","category_id":"clzusvytg001uwwwvgecz9yop","_id":"clzusvytj002swwwv93239kc9"},{"post_id":"clzusvyta0014wwwv8t978845","category_id":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvytk002vwwwv3ugegohv"},{"post_id":"clzusvyta0014wwwv8t978845","category_id":"clzusvyt7000owwwv1plj0vlu","_id":"clzusvytk002zwwwv58ek2pjj"},{"post_id":"clzusvyta0014wwwv8t978845","category_id":"clzusvytj002owwwvd69vakna","_id":"clzusvytk0031wwwvgaxdf8v0"},{"post_id":"clzusvyt4000fwwwv6yxn3a12","category_id":"clzusvyta0012wwwvfcu79rlz","_id":"clzusvytk0035wwwvbzxd0plx"},{"post_id":"clzusvyt4000fwwwv6yxn3a12","category_id":"clzusvytj002uwwwv63ecedss","_id":"clzusvytk0036wwwvfhrt8r55"},{"post_id":"clzusvytb0016wwwv94w40v0e","category_id":"clzusvyta0012wwwvfcu79rlz","_id":"clzusvytl0039wwwv8jysg1lo"},{"post_id":"clzusvytb0016wwwv94w40v0e","category_id":"clzusvytk002xwwwvbaehf5nn","_id":"clzusvytl003awwwvgcibh5pf"},{"post_id":"clzusvysy0003wwwv9os61wwm","category_id":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvytl003hwwwv77boeitx"},{"post_id":"clzusvysy0003wwwv9os61wwm","category_id":"clzusvyt7000owwwv1plj0vlu","_id":"clzusvytl003jwwwv92cme3yj"},{"post_id":"clzusvysy0003wwwv9os61wwm","category_id":"clzusvytk0038wwwv9ibz4nsu","_id":"clzusvytm003mwwwvdfay2u85"},{"post_id":"clzusvyt10007wwwv5h4ocr0z","category_id":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvyto0046wwwv66vx21qa"},{"post_id":"clzusvyt10007wwwv5h4ocr0z","category_id":"clzusvyt7000owwwv1plj0vlu","_id":"clzusvyto0048wwwvgd4cduj9"},{"post_id":"clzusvyt10007wwwv5h4ocr0z","category_id":"clzusvytk0038wwwv9ibz4nsu","_id":"clzusvyto004awwwv9r2n4kvz"},{"post_id":"clzusvyt7000qwwwvdcaa1gq0","category_id":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvyto004gwwwv6uh8h7s0"},{"post_id":"clzusvyt7000qwwwvdcaa1gq0","category_id":"clzusvytf001qwwwv7062dehh","_id":"clzusvytp004iwwwv3oe4d0ou"},{"post_id":"clzusvyt7000qwwwvdcaa1gq0","category_id":"clzusvyto0047wwwv806jdrhz","_id":"clzusvytp004kwwwv3ecyeh8s"},{"post_id":"clzusvyt8000swwwv1cdaf0ij","category_id":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvytp004owwwvb5hy58wn"},{"post_id":"clzusvyt8000swwwv1cdaf0ij","category_id":"clzusvytf001qwwwv7062dehh","_id":"clzusvytp004pwwwv6spoh40b"},{"post_id":"clzusvyt8000swwwv1cdaf0ij","category_id":"clzusvyto0047wwwv806jdrhz","_id":"clzusvytp004swwwv4zym29rt"},{"post_id":"clzusvyt9000wwwwv3lzl3qjs","category_id":"clzusvysz0004wwwvhxacdrvf","_id":"clzusvytq004uwwwv036j23js"},{"post_id":"clzusvyt9000wwwwv3lzl3qjs","category_id":"clzusvytf001qwwwv7062dehh","_id":"clzusvytq004wwwwv85sm4g3f"},{"post_id":"clzusvyt9000wwwwv3lzl3qjs","category_id":"clzusvytp004lwwwvei36hzx5","_id":"clzusvytq004xwwwv6qq96sxz"},{"post_id":"clzusvytb0018wwwvguru9cku","category_id":"clzusvyta0012wwwvfcu79rlz","_id":"clzusvytr0055wwwv9dlrfq6f"},{"post_id":"clzusvytb0018wwwvguru9cku","category_id":"clzusvytk0033wwwv1za5aj1n","_id":"clzusvytr0059wwwv9iq99aid"},{"post_id":"clzusvytb0018wwwvguru9cku","category_id":"clzusvytq004ywwwv9164g23f","_id":"clzusvytr005bwwwva2ws2rn1"},{"post_id":"clzusvytd001cwwwvb4nkb9tb","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvytr005fwwwv3zfc0lhn"},{"post_id":"clzusvytd001cwwwvb4nkb9tb","category_id":"clzusvyto004fwwwv70tt99m9","_id":"clzusvytr005hwwwvh5d8caq7"},{"post_id":"clzusvytd001ewwwv22pehka0","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvyts005lwwwv5s7vgcgm"},{"post_id":"clzusvytd001ewwwv22pehka0","category_id":"clzusvyto004fwwwv70tt99m9","_id":"clzusvyts005nwwwv7s899q4c"},{"post_id":"clzusvyt6000lwwwv9vii957j","category_id":"clzusvyta0012wwwvfcu79rlz","_id":"clzusvyts005pwwwvg3xg49x2"},{"post_id":"clzusvyt6000lwwwv9vii957j","category_id":"clzusvytm003lwwwvhiehe10g","_id":"clzusvyts005rwwwv4tq3gogc"},{"post_id":"clzusvyt6000lwwwv9vii957j","category_id":"clzusvyts005mwwwvh4w11xhc","_id":"clzusvyts005swwwv9lg3e9oo"},{"post_id":"clzusvyte001kwwwvfrigf7s3","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvyts005uwwwv0mrm3cfx"},{"post_id":"clzusvyte001kwwwvfrigf7s3","category_id":"clzusvyts005owwwv45nq3dxf","_id":"clzusvyts005vwwwv49bv1y0i"},{"post_id":"clzusvyt6000nwwwvf9on6fru","category_id":"clzusvytf001owwwvh5icgxt1","_id":"clzusvytt005xwwwvhmsu9iue"},{"post_id":"clzusvyt6000nwwwvf9on6fru","category_id":"clzusvytn0042wwwvbfl222kf","_id":"clzusvytt005ywwwv7gep47g1"},{"post_id":"clzusvyt6000nwwwvf9on6fru","category_id":"clzusvyts005qwwwv066u3k2m","_id":"clzusvytt0060wwwv6d0uh1pk"},{"post_id":"clzusvyt8000vwwwv9e641ysw","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvytt0061wwwvhelq8laq"},{"post_id":"clzusvyt8000vwwwv9e641ysw","category_id":"clzusvyto004fwwwv70tt99m9","_id":"clzusvytt0062wwwv04bx7c56"},{"post_id":"clzusvyt8000vwwwv9e641ysw","category_id":"clzusvyts005twwwv8l8yhe1g","_id":"clzusvytt0064wwwvb8ktfvud"},{"post_id":"clzusvyt9000zwwwv47wre4sj","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvytt0065wwwvbs6mb0oq"},{"post_id":"clzusvyt9000zwwwv47wre4sj","category_id":"clzusvyto004fwwwv70tt99m9","_id":"clzusvytt0067wwwv0rxm3x3w"},{"post_id":"clzusvyt9000zwwwv47wre4sj","category_id":"clzusvyts005wwwwvhpkd9was","_id":"clzusvytt0068wwwv51tf7t1a"},{"post_id":"clzusvyta0011wwwvdmaie1c7","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvytt006awwwv6gdo5ssq"},{"post_id":"clzusvyta0011wwwvdmaie1c7","category_id":"clzusvytq004twwwv8ihv1qon","_id":"clzusvytt006bwwwv25ru9rxj"},{"post_id":"clzusvyta0011wwwvdmaie1c7","category_id":"clzusvytt005zwwwv44d8c54s","_id":"clzusvytu006cwwwvc78y35ra"},{"post_id":"clzusvytc001awwwv4frf919s","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvytu006dwwwv1pbtht1d"},{"post_id":"clzusvytc001awwwv4frf919s","category_id":"clzusvytq0051wwwvfoer5mzc","_id":"clzusvytu006ewwwvel7tca4d"},{"post_id":"clzusvytc001awwwv4frf919s","category_id":"clzusvytt0063wwwvb91y370i","_id":"clzusvytu006fwwwvgovsgnes"},{"post_id":"clzusvyt5000hwwwv0cbbc8x5","category_id":"clzusvyta0012wwwvfcu79rlz","_id":"clzusvytu006gwwwvhwhfgho2"},{"post_id":"clzusvyt5000hwwwv0cbbc8x5","category_id":"clzusvytm003lwwwvhiehe10g","_id":"clzusvytu006hwwwvdcw8er2p"},{"post_id":"clzusvyt5000hwwwv0cbbc8x5","category_id":"clzusvytr005cwwwv1bw5fhb0","_id":"clzusvytu006iwwwv74keh9oe"},{"post_id":"clzusvyt5000hwwwv0cbbc8x5","category_id":"clzusvytt0066wwwv49x03pa8","_id":"clzusvytu006jwwwvhnm4eis1"},{"post_id":"clzusvyte001hwwwv8cqi2tn5","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvytu006kwwwv3x7161ws"},{"post_id":"clzusvyte001hwwwv8cqi2tn5","category_id":"clzusvyts005jwwwv47o8a00v","_id":"clzusvytu006lwwwv0i9d801t"},{"post_id":"clzusvyte001hwwwv8cqi2tn5","category_id":"clzusvytt0069wwwv2nv8e05r","_id":"clzusvytu006mwwwv9za21rg4"},{"post_id":"clzusvytx006nwwwv8qd670hd","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvyu0006vwwwvhxs2bx5d"},{"post_id":"clzusvytx006nwwwv8qd670hd","category_id":"clzusvyts005owwwv45nq3dxf","_id":"clzusvyu1006wwwwv19psd6zq"},{"post_id":"clzusvyty006owwwvc1u95rfo","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvyu10072wwwv95wodqb9"},{"post_id":"clzusvyty006owwwvc1u95rfo","category_id":"clzusvyts005owwwv45nq3dxf","_id":"clzusvyu10075wwwv98i7g5dw"},{"post_id":"clzusvyty006owwwvc1u95rfo","category_id":"clzusvyu0006uwwwvhchv985a","_id":"clzusvyu20077wwwv9h9g4zxp"},{"post_id":"clzusvytz006qwwwvdmueb9l3","category_id":"clzusvyth0021wwwv7s1sf96h","_id":"clzusvyu2007awwwvd3ui3fwu"},{"post_id":"clzusvytz006qwwwvdmueb9l3","category_id":"clzusvyts005owwwv45nq3dxf","_id":"clzusvyu2007dwwwvddog8oer"},{"post_id":"clzusvytz006qwwwvdmueb9l3","category_id":"clzusvyu1006ywwwv83xl6u23","_id":"clzusvyu2007ewwwv227o54bf"},{"post_id":"clzusvyu0006twwwvee1p1s6b","category_id":"clzusvyu10073wwwvcbpxf4di","_id":"clzusvyu2007iwwwv2vhm681i"},{"post_id":"clzusvyu0006twwwvee1p1s6b","category_id":"clzusvyu2007cwwwv59fm884d","_id":"clzusvyu2007kwwwvefbg0fll"}],"PostTag":[{"post_id":"clzusvyt20009wwwvd8z48qh3","tag_id":"clzusvyt00005wwwv4vul3tir","_id":"clzusvyt4000ewwwv7bgs2dtj"},{"post_id":"clzusvysv0001wwwv1nmh880t","tag_id":"clzusvyt00005wwwv4vul3tir","_id":"clzusvyt5000gwwwv8ty838ua"},{"post_id":"clzusvyt2000bwwwv3eo93ppa","tag_id":"clzusvyt00005wwwv4vul3tir","_id":"clzusvyt6000kwwwvhst9ezct"},{"post_id":"clzusvysy0003wwwv9os61wwm","tag_id":"clzusvyt3000dwwwvg7257jsg","_id":"clzusvyt6000mwwwv4is9do3a"},{"post_id":"clzusvyt10007wwwv5h4ocr0z","tag_id":"clzusvyt3000dwwwvg7257jsg","_id":"clzusvyt8000rwwwv5c21deg7"},{"post_id":"clzusvyt4000fwwwv6yxn3a12","tag_id":"clzusvyt7000pwwwv8xqxdtfg","_id":"clzusvyta0010wwwvgovd7xyx"},{"post_id":"clzusvyt4000fwwwv6yxn3a12","tag_id":"clzusvyt8000uwwwv5o4m69pj","_id":"clzusvyta0013wwwvalad8cqp"},{"post_id":"clzusvyt5000hwwwv0cbbc8x5","tag_id":"clzusvyt9000ywwwvfk0iewci","_id":"clzusvytd001fwwwv6oit1trz"},{"post_id":"clzusvyt5000hwwwv0cbbc8x5","tag_id":"clzusvytb0015wwwv1qrr7m1e","_id":"clzusvyte001iwwwvdqy6gud9"},{"post_id":"clzusvyt5000hwwwv0cbbc8x5","tag_id":"clzusvytc0019wwwveys49pn1","_id":"clzusvyte001lwwwv66no97ot"},{"post_id":"clzusvyt6000lwwwv9vii957j","tag_id":"clzusvytd001dwwwv1r7562ir","_id":"clzusvytf001rwwwv6y6s3b40"},{"post_id":"clzusvyt6000lwwwv9vii957j","tag_id":"clzusvyte001jwwwvdrkb40ty","_id":"clzusvytg001swwwvaaftcoie"},{"post_id":"clzusvyt6000lwwwv9vii957j","tag_id":"clzusvytf001nwwwvbloee9g5","_id":"clzusvytg001vwwwv6upn265h"},{"post_id":"clzusvyt6000nwwwvf9on6fru","tag_id":"clzusvytd001dwwwv1r7562ir","_id":"clzusvytg001ywwwvh8ccdc63"},{"post_id":"clzusvyt6000nwwwvf9on6fru","tag_id":"clzusvytg001twwwv1da5337z","_id":"clzusvytg001zwwwvh7eveac6"},{"post_id":"clzusvyt7000qwwwvdcaa1gq0","tag_id":"clzusvytg001wwwwvcf2b8ld9","_id":"clzusvyth0023wwwv1dgx6tqv"},{"post_id":"clzusvyt8000swwwv1cdaf0ij","tag_id":"clzusvytg001wwwwvcf2b8ld9","_id":"clzusvyth0028wwwvh4jw2he8"},{"post_id":"clzusvyt8000vwwwv9e641ysw","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvyti002iwwwv8pkhabac"},{"post_id":"clzusvyt8000vwwwv9e641ysw","tag_id":"clzusvyth0029wwwvbsmx0qb5","_id":"clzusvyti002jwwwv1a3ta4l0"},{"post_id":"clzusvyt8000vwwwv9e641ysw","tag_id":"clzusvyti002bwwwv7zg545iw","_id":"clzusvytj002mwwwv4s13f8mb"},{"post_id":"clzusvyt9000wwwwv3lzl3qjs","tag_id":"clzusvyti002fwwwv1r4p2p2i","_id":"clzusvytj002nwwwv06f3ahxf"},{"post_id":"clzusvyt9000zwwwv47wre4sj","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvytk002ywwwv4t5b17ce"},{"post_id":"clzusvyt9000zwwwv47wre4sj","tag_id":"clzusvyth0029wwwvbsmx0qb5","_id":"clzusvytk0030wwwvc3611g03"},{"post_id":"clzusvyt9000zwwwv47wre4sj","tag_id":"clzusvytj002twwwv6axv97mc","_id":"clzusvytk0034wwwvet1w28cr"},{"post_id":"clzusvyta0011wwwvdmaie1c7","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvytl003dwwwv4uoz2goc"},{"post_id":"clzusvyta0011wwwvdmaie1c7","tag_id":"clzusvytk0032wwwv11i2em2x","_id":"clzusvytl003ewwwv3bsi3d0y"},{"post_id":"clzusvyta0011wwwvdmaie1c7","tag_id":"clzusvytk0037wwwv39ckf7yi","_id":"clzusvytl003iwwwvc9fn0q7i"},{"post_id":"clzusvyta0014wwwv8t978845","tag_id":"clzusvytl003bwwwvhbbj865n","_id":"clzusvytl003kwwwv1xsn91ly"},{"post_id":"clzusvytb0016wwwv94w40v0e","tag_id":"clzusvytl003fwwwv78rx12xr","_id":"clzusvytm003swwwvfi77crcj"},{"post_id":"clzusvytb0016wwwv94w40v0e","tag_id":"clzusvytm003nwwwv0x3khnwy","_id":"clzusvytm003uwwwv7jbt0lxv"},{"post_id":"clzusvytb0016wwwv94w40v0e","tag_id":"clzusvytm003pwwwvfu5vfrt0","_id":"clzusvytn003wwwwv06f5g2zi"},{"post_id":"clzusvytb0018wwwvguru9cku","tag_id":"clzusvytm003rwwwv5flxe306","_id":"clzusvytn0041wwwvec0ih1y5"},{"post_id":"clzusvytb0018wwwvguru9cku","tag_id":"clzusvytm003vwwwv77vvci1s","_id":"clzusvytn0043wwwva3twfusi"},{"post_id":"clzusvytb0018wwwvguru9cku","tag_id":"clzusvytn003ywwwv5rg68758","_id":"clzusvyto0045wwwvhga5cpvi"},{"post_id":"clzusvytc001awwwv4frf919s","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvyto004bwwwv40juajll"},{"post_id":"clzusvytc001awwwv4frf919s","tag_id":"clzusvytn0044wwwvbb6u6abw","_id":"clzusvyto004dwwwvg32s6eqs"},{"post_id":"clzusvytd001cwwwvb4nkb9tb","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvytp004jwwwvfizngu47"},{"post_id":"clzusvytd001cwwwvb4nkb9tb","tag_id":"clzusvyth0029wwwvbsmx0qb5","_id":"clzusvytp004mwwwvfema9rva"},{"post_id":"clzusvytd001ewwwv22pehka0","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvytq0050wwwvfg5b62ee"},{"post_id":"clzusvytd001ewwwv22pehka0","tag_id":"clzusvyth0029wwwvbsmx0qb5","_id":"clzusvytq0052wwwv75w8d1ee"},{"post_id":"clzusvytd001ewwwv22pehka0","tag_id":"clzusvytp004rwwwva24o1lgf","_id":"clzusvytq0054wwwvhim6h5ng"},{"post_id":"clzusvytd001ewwwv22pehka0","tag_id":"clzusvytq004vwwwv4ncba4d2","_id":"clzusvytr0056wwwvex4ofd6w"},{"post_id":"clzusvyte001hwwwv8cqi2tn5","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvytr005awwwv2wdx2puo"},{"post_id":"clzusvyte001hwwwv8cqi2tn5","tag_id":"clzusvytq0053wwwv7mknfnxs","_id":"clzusvytr005dwwwvdglzdmkv"},{"post_id":"clzusvyte001kwwwvfrigf7s3","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvytr005iwwwv7g286mge"},{"post_id":"clzusvyte001kwwwvfrigf7s3","tag_id":"clzusvytr005ewwwv02n97x8f","_id":"clzusvyts005kwwwv05zz6kyh"},{"post_id":"clzusvytx006nwwwv8qd670hd","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvytz006pwwwv4qojdrpm"},{"post_id":"clzusvytx006nwwwv8qd670hd","tag_id":"clzusvytr005ewwwv02n97x8f","_id":"clzusvyu0006swwwvgcgj52t9"},{"post_id":"clzusvyty006owwwvc1u95rfo","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvyu1006zwwwvg8ks7qzq"},{"post_id":"clzusvyty006owwwvc1u95rfo","tag_id":"clzusvytr005ewwwv02n97x8f","_id":"clzusvyu10070wwwvd20z7n9p"},{"post_id":"clzusvyty006owwwvc1u95rfo","tag_id":"clzusvyu0006rwwwv97d8auec","_id":"clzusvyu10074wwwvalpy4p7n"},{"post_id":"clzusvytz006qwwwvdmueb9l3","tag_id":"clzusvyth0025wwwv3plr9jtw","_id":"clzusvyu10076wwwv0wok5yxc"},{"post_id":"clzusvytz006qwwwvdmueb9l3","tag_id":"clzusvytr005ewwwv02n97x8f","_id":"clzusvyu20079wwwv8kp640um"},{"post_id":"clzusvytz006qwwwvdmueb9l3","tag_id":"clzusvyu1006xwwwv3rgo4q1l","_id":"clzusvyu2007bwwwv7lpw0qsh"},{"post_id":"clzusvyu0006twwwvee1p1s6b","tag_id":"clzusvytd001dwwwv1r7562ir","_id":"clzusvyu2007fwwwvaimc2drd"},{"post_id":"clzusvyu0006twwwvee1p1s6b","tag_id":"clzusvyu10071wwwvg44a3gok","_id":"clzusvyu2007gwwwv39lpg98g"},{"post_id":"clzusvyu0006twwwvee1p1s6b","tag_id":"clzusvytf001nwwwvbloee9g5","_id":"clzusvyu2007hwwwvaiewdagw"},{"post_id":"clzusvyu0006twwwvee1p1s6b","tag_id":"clzusvyu20078wwwv6vjjb8hh","_id":"clzusvyu2007jwwwvgtr88jfu"}],"Tag":[{"name":"icpc","_id":"clzusvyt00005wwwv4vul3tir"},{"name":"ccpc","_id":"clzusvyt3000dwwwvg7257jsg"},{"name":"Latex","_id":"clzusvyt7000pwwwv8xqxdtfg"},{"name":"图像处理","_id":"clzusvyt8000uwwwv5o4m69pj"},{"name":"nodejs","_id":"clzusvyt9000ywwwvfk0iewci"},{"name":"gcc","_id":"clzusvytb0015wwwv1qrr7m1e"},{"name":"linux","_id":"clzusvytc0019wwwveys49pn1"},{"name":"信息安全","_id":"clzusvytd001dwwwv1r7562ir"},{"name":"软件","_id":"clzusvyte001jwwwvdrkb40ty"},{"name":"Miracl","_id":"clzusvytf001nwwwvbloee9g5"},{"name":"数学","_id":"clzusvytg001twwwv1da5337z"},{"name":"newcoder","_id":"clzusvytg001wwwwvcf2b8ld9"},{"name":"算法","_id":"clzusvyth0025wwwv3plr9jtw"},{"name":"思维题","_id":"clzusvyth0029wwwvbsmx0qb5"},{"name":"模运算","_id":"clzusvyti002bwwwv7zg545iw"},{"name":"atcoder","_id":"clzusvyti002fwwwv1r4p2p2i"},{"name":"贪心，状态转移","_id":"clzusvytj002twwwv6axv97mc"},{"name":"博弈论","_id":"clzusvytk0032wwwv11i2em2x"},{"name":"不等式","_id":"clzusvytk0037wwwv39ckf7yi"},{"name":"luogu","_id":"clzusvytl003bwwwvhbbj865n"},{"name":"开发","_id":"clzusvytl003fwwwv78rx12xr"},{"name":"文档","_id":"clzusvytm003nwwwv0x3khnwy"},{"name":"学校","_id":"clzusvytm003pwwwvfu5vfrt0"},{"name":"Typora","_id":"clzusvytm003rwwwv5flxe306"},{"name":"Markdown","_id":"clzusvytm003vwwwv77vvci1s"},{"name":"随笔","_id":"clzusvytn003ywwwv5rg68758"},{"name":"子序列自动机","_id":"clzusvytn0044wwwvbb6u6abw"},{"name":"坐标系转换","_id":"clzusvytp004rwwwva24o1lgf"},{"name":"几何问题","_id":"clzusvytq004vwwwv4ncba4d2"},{"name":"树问题，哈希算法","_id":"clzusvytq0053wwwv7mknfnxs"},{"name":"状态转移","_id":"clzusvytr005ewwwv02n97x8f"},{"name":"异或问题","_id":"clzusvyu0006rwwwv97d8auec"},{"name":"离散化","_id":"clzusvyu1006xwwwv3rgo4q1l"},{"name":"加密算法","_id":"clzusvyu10071wwwvg44a3gok"},{"name":"ECC","_id":"clzusvyu20078wwwv6vjjb8hh"}]}}