<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024武汉ICPC邀请赛VP</title>
    <url>/2024/2024%E6%AD%A6%E6%B1%89ICPC%E9%82%80%E8%AF%B7%E8%B5%9BVP/article.html</url>
    <content><![CDATA[<h2 id="武汉邀请赛vp">武汉邀请赛VP</h2>
<h3 id="i.cyclic-apple-strings">I.<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSQ==">Cyclic Apple
Strings<i class="fa fa-external-link-alt"></i></span></h3>
<span id="more"></span>
<p>计算第一个1后的0的段数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;cin&gt;&gt;s;</span><br><span class="line">	<span class="type">int</span> f =<span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>(); i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		f|=(s[i] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">		<span class="keyword">while</span>(i<span class="number">+1</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i<span class="number">+1</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">if</span>(f &amp;&amp; s[i] ==<span class="string">&#x27;0&#x27;</span>) cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>K.<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vSw==">Party
Games<i class="fa fa-external-link-alt"></i></span></p>
<p>打表可发现1，0数出现有规律，于是整数域缩减到mod4整数域。最简单的方法，模拟一下可以发现余数r为0，1时先手胜，余2，3时后手胜</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> r = n % <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span>(r==<span class="number">0</span> || r==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;Fluttershy\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(r==<span class="number">2</span> || r==<span class="number">3</span>) cout&lt;&lt;<span class="string">&quot;Pinkie Pie\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>F. <span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRg==">Custom-Made
Clothes<i class="fa fa-external-link-alt"></i></span></p>
<p>简单二分或者二分套二分(另一个二分二分第一次的下标)</p>
<p>注意到行与行，列与列均不相同的数字且两者不在对方的”前缀“矩阵中时无法判断两数大小，注意到<span
class="math display">\[n \le 1000\]</span>。</p>
<p>考虑二分答案，我们怎么在50000次内找到它在第几大。显然的思路是二分行列下标通过先找到其在“形式上最大”的行。然后记忆化的思维，不断减少这个下标。最多减少n次，二分最多20次，因此完全是足够的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(g[x][y]) <span class="keyword">return</span> g[x][y] &lt;= v;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;?&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;v&lt;&lt;endl;</span><br><span class="line">	cout.<span class="built_in">flush</span>();</span><br><span class="line">	<span class="type">int</span> res ;cin&gt;&gt;res;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l=<span class="number">1</span>,<span class="type">int</span> r=mx)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!g[x][y]) <span class="keyword">return</span> g[x][y];</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="type">int</span> mid=  l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">query</span>(x,y,mid)) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g[x][y] = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	mx = n * n;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>,r=mx;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> now = n;</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(now &amp;&amp; !<span class="built_in">query</span>(now,i,mid))now--;</span><br><span class="line">			cnt += now;</span><br><span class="line">			<span class="keyword">if</span>(!now) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt &lt; k) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid<span class="number">+1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B. <span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vQg==">Countless
Me<i class="fa fa-external-link-alt"></i></span></p>
<p>很显然的是，操作n次等同于任意捏一个总和相同的数组。下面简单说明一下：</p>
<p>取最大值与顺序无关，所以，我们先对想要的数组和操作数组排序，可以发现我们使得任意较小值变大都可以从后面的一个数中拿到对应的数字，相对应的，反过来也是一样的。形象的讲，对一个数字的加减值可以看作一个完全的网络流图，每一条边都是无限权值，自然使得任意顶点变为需要的值可以通过合理的操作其他具有相反的差值顶点达到。</p>
<p>维护sum值，将高位的1拆分给低位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (((<span class="number">1ll</span> &lt;&lt; i) - <span class="number">1</span>) * n &gt;= sum) <span class="keyword">continue</span>;</span><br><span class="line">      ll num = <span class="built_in">min</span>(n, sum / (<span class="number">1ll</span> &lt;&lt; i));</span><br><span class="line">      <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      sum -= num * (<span class="number">1ll</span> &lt;&lt; i);</span><br><span class="line">      ans |= <span class="number">1ll</span> &lt;&lt;  i;</span><br><span class="line">  &#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的做法是错误的，试图找到一个临界点i，将比i高的位均拆分至低位i，而不维护sum值，当低位容不下时时则出错。</p>
<p>hack数据</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 0</span><br><span class="line">-------</span><br><span class="line">2</span><br><span class="line">7 3</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans =<span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;~i;i--)&#123;</span><br><span class="line">        cnt = (cnt&lt;&lt;<span class="number">1</span>) + (sum &gt;&gt;i &amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n) ans += (sum &gt;&gt; i &amp;<span class="number">1</span>) &lt;&lt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>D.<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTQzL3Byb2JsZW0vRA==">ICPC<i class="fa fa-external-link-alt"></i></span></p>
<p>ICPC!!!，估计很多人一看到这个名字和答案求法就跑了。</p>
<p>但实际上，非常简单的dp，从前面跑一遍，后面跑一遍。取最大就over了。</p>
<p>思路也很简单，只需要折返一次（很常见，很经典），于是我们维护f数组，从前面转移一遍，从后面转移一遍。</p>
<p>dp的妙处就在于，你何必去想前一个状态是不是真的向相反的方向走有是不是只返回一次。实际上，即使它有这样的规律，在转移也不会体现出来，我们实际上是根据前一个状态的最优解（however只能吃一次加分是必要的）进行计算的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i] = pre[i<span class="number">-1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n&lt;&lt;<span class="number">1</span>;j++)&#123;</span><br><span class="line">			f1[i][j] = <span class="built_in">max</span>(pre[i] - pre[<span class="built_in">max</span>(i-j<span class="number">-1</span>,<span class="number">0</span>)]</span><br><span class="line">				,pre[<span class="built_in">min</span>(n,i+j)]- pre[i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n&lt;&lt;<span class="number">1</span>;j++)&#123;</span><br><span class="line">			f1[i][j] = <span class="built_in">max</span>(f1[i][j],f1[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n&lt;&lt;<span class="number">1</span>;j++)&#123;</span><br><span class="line">			f2[i][j] = <span class="built_in">max</span>(f1[i][j],f2[i<span class="number">+1</span>][j<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ll t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n&lt;&lt;<span class="number">1</span>;j++)&#123;</span><br><span class="line">			t ^= j*<span class="built_in">max</span>(f1[i][j],f2[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		ans ^= (i+ t);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
        <category>模拟赛</category>
        <category>icpc邀请赛</category>
      </categories>
      <tags>
        <tag>icpc</tag>
      </tags>
  </entry>
  <entry>
    <title>2024河南CCPC邀请赛-VP</title>
    <url>/2024/2024%E6%B2%B3%E5%8D%97CCPC%E9%82%80%E8%AF%B7%E8%B5%9B-VP/article.html</url>
    <content><![CDATA[<h2 id="河南ccpc-vp">河南CCPC-VP</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4">Dashboard - 2024 National
Invitational of CCPC (Zhengzhou), 2024 CCPC Henan Provincial Collegiate
Programming Contest - Codeforces<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="j.-排列与合数">J. <span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSg==">排列与合数<i class="fa fa-external-link-alt"></i></span></h2>
<span id="more"></span>
<h3 id="题意">题意：</h3>
<p>​
小A在2023年河南省CCPC大学生程序设计竞赛的赛场上遇到了一道名为“排列与质数”的题目。
与大多数选手一样，小A并没能在赛场上解决这个棘手的题目。比赛结束后，小A想到了一个与之相关
的题目：排列与合数，可是小A仍然没有能力解决。这个名为“排列与合数”的题目是这样的：
给定一个有且仅有5
位，且各个数位互不相同的十进制正整数n。你可以重新排列n的各个数位，
但需要保证重新排列得到的整数n′ 没有前导零。请问重新排列数位得到的n′
能否为合数？若能为合数， 请求出一个满足条件的n′。 例如，当n=12345
时，任意排列得到的n′ 均是合数，因此可以任意取n′。当n=13579时，可以
重新排列数位得到合数n′=97531=7×13933。
一个正整数是合数，当且仅当它可以分解为两个不小于2的整数的乘积。
现在，小A带着他的题目来到赛场上求助。你能帮助小A解决这个题目吗？</p>
<h3 id="题解">题解：</h3>
<p>​
签到，有多种解法，比较快的是next_permutation()与埃氏筛，如下，如果你有更快的欢迎提出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string s;cin&gt;&gt;s;</span><br><span class="line">		<span class="built_in">sort</span>(<span class="built_in">all</span>(s));</span><br><span class="line">		<span class="type">bool</span> flag= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">				t = t * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span>(t &lt;=<span class="number">10000</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=t;i++)</span><br><span class="line">				<span class="keyword">if</span>(t % i == <span class="number">0</span>)&#123;</span><br><span class="line">					f=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span>(!f) &#123;cout&lt;&lt;t&lt;&lt;endl;flag =<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(<span class="built_in">all</span>(s)));</span><br><span class="line">		<span class="keyword">if</span>(!flag) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b.扫雷-1">B.<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vQg==">扫雷 1<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题意-1">题意：</h3>
<p>​ T0xel 喜欢玩扫雷，但是他玩的扫雷游戏有名为“地雷探测器”的特殊道具。
具体来说，T0xel
会进行n轮扫雷。每轮扫雷开始之前，T0xel会获得1枚扫雷币。扫雷币在每轮扫
雷结束后不会回收，可以保留至下一轮扫雷。T0xel知道，在第i轮（1≤i≤n）扫雷中，花费ci
枚扫
雷币可以购买一个地雷探测器，清除地图中的一个雷。地雷探测器在一轮扫雷中可以购买任意次。
现在T0xel 想知道，在这n轮扫雷中最多能购买多少个地雷探测器呢？</p>
<h3 id="题解-1">题解</h3>
<p>注意到最多只会买n个地雷，并在遇到最小当前最小价格时，应尽可能的买，所以只需要维护一下当前未遍历到的最小值即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i].x;</span><br><span class="line">		c[i] = a[i].x;</span><br><span class="line">		a[i].y = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		now ++;</span><br><span class="line">		<span class="keyword">while</span>(a[flag].y &lt; i) flag++;</span><br><span class="line">		<span class="keyword">if</span>(a[flag].y == i)&#123;</span><br><span class="line">			ans += now / c[i];</span><br><span class="line">			now = now % c[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="f.优秀字符串">F.<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vRg==">优秀字符串<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题意-2">题意：</h3>
<p>小A认为，一个字符串S是优秀字符串，当且仅当：</p>
<ul>
<li>S 的长度|S|恰好为5</li>
<li>S 的第三个字符与第五个字符相同</li>
<li>S 的前四个字符互不相同。</li>
</ul>
<p>例如henan 是优秀字符串，但query、problem、queue 不是，因为： • query
的第三个字符为e，而第五个字符为y； • problem 的长度不为 5； • queue
的前四个字符中u出现了两次。
现在，小A有n个仅包含英文字母与数字的字符串S1,S2,...,Sn，请你帮小A求出这些字符串中
优秀字符串的数量</p>
<h3 id="题解-2">题解</h3>
<p>签到，不做阐述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	string s;cin&gt;&gt;s;</span><br><span class="line">		<span class="keyword">if</span>(s.<span class="built_in">size</span>()!=<span class="number">5</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			set&lt;<span class="type">char</span>&gt; S;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)S.<span class="built_in">insert</span>(s[i]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(S.<span class="built_in">size</span>()!=<span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(s[<span class="number">2</span>] != s[<span class="number">4</span>])&#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					cnt ++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="m.-有效算法">M. <span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vTQ==">有效算法<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题意-3">题意：</h3>
<p>给出长度为n的正整数序列{an}和{bn}。对于每个ai（1≤i≤n），进行恰好一次以下操作：</p>
<ul>
<li>将ai 变成满足|ai−x|≤k×bi 的任意整数x。</li>
</ul>
<p>请你求出最小的非负整数k，使得存在至少一种方法使得操作后序列{an}所有数都相等。</p>
<h3 id="题解-3">题解：</h3>
<p>分情况讨论绝对值，即可得出以下两个不等式组 <span
class="math display">\[
a_i \le x \le a_i + k * b_i\\
a_i - k * b_i \le x \le a_i
\]</span>
考虑整个a数组最后有可能变为的一致数是什么，显然这个数的绝对值一定是小于a数组中极值的。我们设mx为a数组中最大的数，mn为a数组中最小的数</p>
<p>考虑暴力一下，枚举的mn到mx为x，发现 <span class="math display">\[
ans = max_{x=mn}^{mx}\{max_{i=1}^{n}\{ceil(abs(a_i - x)/b_i)\}\}
\]</span>
但这样做有1e9*3e5的时间复杂度，考虑优化，似乎不具备什么特性。</p>
<p>转换一下思维，注意到对于k答案是具有单调性的，并且对不同大小的k，问题变成了区间覆盖问题，即，能否找到一个最小的k值，使得被覆盖的点至少有一个权值为n（被覆盖n次）。</p>
<p>如果我们二分k值，应该如何找到一个至多O(nlogn)时间复杂度以内的算法使得能找出是否存在这样的点。</p>
<p>我们可以在O(n)的时间复杂度内求出覆盖的区间左右端点，离散前缀和就能做到找出权值为n的点。</p>
<p>注意可能有极端情况<span class="math display">\[a_i\]</span>​均相等</p>
<p>神秘的是，这题及其卡常，O(nlognlog(1e9))居然常数稍微大一点就过不了，不能用map反向映射一遍。可能是cf编译器不一样？除了这一点还是很好的。如果你tle6了不要纠结。。</p>
<p>下面是code</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	L.<span class="built_in">clear</span>(),R.<span class="built_in">clear</span>(),ves.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.<span class="built_in">push_back</span>(a[i].x - x * a[i].y);</span><br><span class="line">		R.<span class="built_in">push_back</span>(a[i].x + x * a[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;mn&lt;&lt;endl;</span></span><br><span class="line">	<span class="type">int</span> l = mn, r = mx;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="comment">// cout&lt;&lt; L[i]&lt;&lt;endl;</span></span><br><span class="line">		l = <span class="built_in">max</span>(L[i],l);</span><br><span class="line">		r = <span class="built_in">min</span>(r,R[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;x&lt;&lt; &#x27; &#x27; &lt;&lt;l&lt;&lt; &#x27; &#x27; &lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">if</span>(l&lt;=r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i].x;</span><br><span class="line">		mx=<span class="built_in">max</span>(a[i].x,mx);</span><br><span class="line">		mn=<span class="built_in">min</span>(a[i].x,mn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i].y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].x&lt;&lt;&#x27;-&#x27;&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">	ll l = <span class="number">0</span>, r = mx-mn;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="h.随机栈">H.<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSA==">随机栈<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题意-4">题意：</h3>
<p>​ Toxel 获得了一个随机的 “栈”。这个栈可被视为一个 .多 .重 .集
S，从一个非空的随机栈 S 中取出一个
元素时，有可能从中取出任何一个元素，其中每个元素被取出的概率是相等的。取出该元素后，该元素会
从集合中删除。以{1,2,2} 为例，有 1 3 的概率取出1，使得集合变为{2,2}，有
2 3 的概率取出2，使得集 合变为{1,2}。每次取出元素的事件相互独立。 Toxel
正在对这个集合做一些操作。集合初始时为空，它总共进行了2n次操作，其中n次操作为插
入，n次操作为取出。现在，Toxel告诉了你它操作的顺序以及每次插入的数，且保证每次取出时，集合
非空。Toxel
想知道，如果把每次取出的数排成一个序列，那么这个序列递增的概率是多少？这里，递增
的严格定义是：取出数列的每一项（除最后一项）.小.于.等 .于它的后一项。
由于答案可能不是整数，为了方便计算，你只需要求出这个值对998244353取模的结果。</p>
<h3 id="题解-4">题解：</h3>
<p>题目保证了插入n次，也就是说Toxel取出数的数列在数值的序上是固定的，处理一下数据，维护一下当前要取的数值就好。</p>
<p>code</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res * a % mod;</span><br><span class="line">		a = a * a % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">qmi</span>(x,MOD<span class="number">-2</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; a,ords;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++)&#123;</span><br><span class="line">		<span class="type">int</span> op;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(~op) a.<span class="built_in">pb</span>(op);</span><br><span class="line">		ords.<span class="built_in">pb</span>(op);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(a));</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> flag= <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> op : ords)&#123;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="comment">// cout&lt;&lt;cnt[a[flag]]&lt;&lt; &#x27; &#x27;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line">			ans *= cnt[a[flag]] * <span class="built_in">inv</span>(sum) % MOD;</span><br><span class="line">			ans %= MOD;</span><br><span class="line">			cnt[a[flag]]--;</span><br><span class="line">			flag++;</span><br><span class="line">			sum--;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			cnt[op] ++;sum ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;ans % MOD&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>待续。。。。笔者吃饭去了</p>
<h2 id="l.-toxel-与-pcpc-ii">L. <span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vTA==">Toxel 与 PCPC
II<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题面">题面：</h3>
<p>​ Toxel 正在参加 PCPC（Pokémon Center Programming
Contest）比赛。它写的一段代码中有不少
bug，正在调试。这份代码总共有n行，而且经验丰富的Toxel已经知道了其中m行代码有bug，并锁
定了这m行的具体位置。但是Toxel还需要进行一些调试以了解错误的具体细节并修复它们。
Toxel 会进行多次调试。每次调试时，Toxel 可以任选一个 i，使得程序从第 1
行开始，顺序运行完 第i行后退出。Toxel
可以通过这i行代码运行的一些输出结果来进行debug。运行这i行代码总共需要 i
秒。接下来，Toxel
会一次性地debug这i行代码，并修复所有这i行中的所有bug。bug数量越多，修
复所需的时间也越多。设这i行代码中现存的bug数量为x，那么Toxel需要x4
秒来debug并完成修 复。修复后，这i行代码中将不再存在任何bug。 PCPC
的赛场争分夺秒。请你帮Toxel
计算一下，它最短需要多少秒才能完成debug，修复整个代 码中的所有漏洞？</p>
<h3 id="题解-5">题解：</h3>
<p>考虑对任意的一段前缀，增添一个bug，我们假设原最后一个bug与新增的bug之间有距离为d
= j - i，则花费差为 <span class="math display">\[
\Delta = (x+1)^4 + j  - (x^4 + i + j + 1) \\
\Delta = (x+1)^4 - x^4 - i - 1
\]</span> 注意到<span
class="math display">\[i+1\]</span>是常数，但对<span
class="math display">\[(x+1) ^4- x^4\]</span>
这个值可能随着我们前面先debug一段而减少。</p>
<p>让我们贪心的考虑，存在前缀，如果我们有<span
class="math display">\[(x+1)^4 - x^4 \le i+1\]</span>
，则我们一定会向后拓展吗？如果不扩展，我们首先损失了<span
class="math display">\[\Delta\]</span>，我们在后续有相较于不存在j下标的bug的盈利点吗？显然多出一个bug不会使开销变小。。</p>
<p>实现时发现，对于前面的多向后扩展会使得后面本应扩展的数无法拓展</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> s = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i &lt; m &amp;&amp; a[i] + <span class="number">1</span> &gt;= <span class="built_in">qmi</span>((s<span class="number">+1</span>),<span class="number">4</span>) - <span class="built_in">qmi</span>(s,<span class="number">4</span>) )&#123;</span><br><span class="line">			s ++;</span><br><span class="line">			i ++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans += (a[i] + <span class="built_in">qmi</span>(s,<span class="number">4</span>));</span><br><span class="line">		cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span> &lt;&lt;ans&lt;&lt;nline;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码在样例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">20</span></span><br><span class="line"> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>计算答案为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">224</span></span><br></pre></td></tr></table></figure>
<p>但实际确是221。这说明在相同情况下更加倾向于在后面多拓展因为根据上面的公式，实际上我们是在用<span
class="math display">\[(x+1)^4 - x^4\]</span>去换<span
class="math display">\[i+1\]</span>的成本量，相同情况下当然希望后面的扩展越多越好，此时<span
class="math display">\[i\]</span>更大，相对于分开计算具有更优的贡献，因此我们更改为由最后的向前拓展。</p>
<p>但还是wa，
考虑贪心解法是不是错的离谱。于是注意到性质^4，简单计算可以发现，这个次方级别在不到20就会超出int上限。这说明枚举扩展点数并转移状态是可行的，于是进行dp</p>
<p>根据上面的公式，状态表示为 <span class="math display">\[
f_i 前i个bug修改所需最小代价
\]</span> 状态转移表示为 <span class="math display">\[
f_i = max_{j=min\{1\}}^{j\{|qmi(j,4)- qmi(j-1,4) &lt;= a[i-j] + 1
\&amp;\&amp; i-j+1 &gt; 0\}}\{f_i,f_{i-j} + qmi(j,4) + a[i]\}
\]</span>
暴力为何是错的，待证。但确实可以从上面的推导中看出一点np问题的影子。。。</p>
<p>coding。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		f[i] = f[i<span class="number">-1</span>] + a[i] + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;&quot;#&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;f[i]&lt;&lt;endl; </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;<span class="built_in">qmi</span>(j,<span class="number">4</span>)- <span class="built_in">qmi</span>(j<span class="number">-1</span>,<span class="number">4</span>) &lt;= a[i-j<span class="number">+1</span>] + <span class="number">1</span> &amp;&amp; i-j<span class="number">+1</span> &gt; <span class="number">0</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			f[i] = <span class="built_in">min</span>(f[i-j] + <span class="built_in">qmi</span>(j,<span class="number">4</span>) + a[i],f[i]);</span><br><span class="line">			<span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt; f[i] &lt;&lt;endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="k.-树上问题">K. <span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTU4L3Byb2JsZW0vSw==">树上问题<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题意-5">题意:</h3>
<p>​ 378QAQ 有一棵由 n
个节点组成的无根树，节点编号从1到n，每个节点有一个正整数点权。 378QAQ
认为一个节点是美丽节点，当且仅当该节点作为根时，对于除根节点以外的所有节点，其
点权都.不 .小 .于其父亲节点的点权的 1 2。
请你计算出有多少个节点是美丽节点。</p>
<h3 id="题解-6">题解：</h3>
<p>​ 若： <span class="math display">\[
a &gt;= b/2
\]</span> ​ 则： <span class="math display">\[
2*a &gt;= b \rightarrow \{a/2&lt;=b&lt;=2*a\}
\]</span> ​
即，如果要满足一条边上的a,b顶点可以互换，两个数必须满足上述公式。若不满足，则大数在下，小数在上。</p>
<p>​ 考虑更换顶点对点关系的影响：</p>
<ol type="1">
<li>原根节点与新的根节点之间一定是父子关系</li>
<li>更换根节点仅更改了原根到新根路径上的节点的父子关系。</li>
</ol>
<p>​
于是我们想到，首先对边进行处理，对于每个不能颠倒的边，我们指出哪个顶点是父节点，对于能颠倒的边，我们指出哪个顶点是父节点。</p>
<p>​
显然我们的答案就是对于这些不能逆转的节点所组成的由父节点向子节点路径中起始点为根构成的子树大小。存在多个起始点答案为0。</p>
<p>​
一个解是，缩点成块，缩点后有且仅有一个根节点否则答案为0，答案就是根节点的子树大小。</p>
<p>coding</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++timestamp;</span><br><span class="line">    stk[++top] = u, istk[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(istk[v])&#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        scou++;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            p = stk[top--];</span><br><span class="line">            istk[p] = <span class="number">0</span>;</span><br><span class="line">            scnt[scou]++;</span><br><span class="line">            id[p] = scou;</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    scou = top = timestamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[i].<span class="built_in">clear</span>(),dfn[i] = low[i] = istk[i] = id[i] = scnt[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;a&lt;&lt;&#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ceil</span>(<span class="number">1.0</span>*w[a]/<span class="number">2</span>) &lt;= w[b] &amp;&amp; w[b] &lt;= (w[a] * <span class="number">2</span>))&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">            e[a].<span class="built_in">pb</span>(b);</span><br><span class="line">            e[b].<span class="built_in">pb</span>(a);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(w[a] &gt; w[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">            e[a].<span class="built_in">pb</span>(b);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;###&quot;&lt;&lt;a&lt;&lt; &#x27; &#x27;&lt;&lt; b&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;nline;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=scou;i++) din[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    multiset&lt;ull&gt; rcd;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;---&quot;&lt;&lt;i&lt;&lt; &#x27; &#x27; &lt;&lt;e[i].size()&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j: e[i])&#123;</span><br><span class="line">            <span class="type">int</span> a = id[i], b = id[j];</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27; &lt;&lt; a&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;j&lt;&lt;&#x27; &#x27; &lt;&lt; b&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(a != b &amp;&amp; !rcd.<span class="built_in">count</span>(a * <span class="number">100000</span> + b))&#123;</span><br><span class="line">                rcd.<span class="built_in">insert</span>(a * <span class="number">100000</span>+b);</span><br><span class="line">                din[b] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;id[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;nline;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=scou;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;scnt[i]&lt;&lt;&#x27; &#x27;&lt;&lt;din[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt =<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=scou;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!din[i] &amp;&amp; !ans) ans = scnt[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!din[i] &amp;&amp; ans)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
]]></content>
      <categories>
        <category>比赛</category>
        <category>模拟赛</category>
        <category>ccpc邀请赛</category>
      </categories>
      <tags>
        <tag>ccpc</tag>
      </tags>
  </entry>
  <entry>
    <title>2024湖北省赛VP</title>
    <url>/2024/2024%E6%B9%96%E5%8C%97%E7%9C%81%E8%B5%9BVP/article.html</url>
    <content><![CDATA[<h2 id="湖北省赛vp">湖北省赛VP</h2>
<p>https://codeforces.com/gym/105139/attachments/download/25287/Sol_ICPC_hubei_24.pdf</p>
<h2 id="e.-spicy-or-grilled">E. Spicy or Grilled?</h2>
<h3 id="题意">题意</h3>
<span id="more"></span>
<p>由于常规节目比赛持续五个小时，在比赛期间为选手准备食物是个大问题。</p>
<figure>
<img src="https://s2.loli.net/2024/05/16/dSo98eMRGc1ntsD.png"
alt="2aceebec00a61b0864fce9d24f11213aab3fc731" />
<figcaption
aria-hidden="true">2aceebec00a61b0864fce9d24f11213aab3fc731</figcaption>
</figure>
<p>在中国湖北省举办的 20XX 年国际大学生程序设计竞赛中，共有 <span
class="math inline">\(n\)</span>
名选手参赛。主持人想为每位选手准备一份香辣鸡肉汉堡套餐，当时每套套餐的价格是
<span class="math inline">\(a\)</span> 元。但由于有些人像 Walk Alone
一样不能忍受辣味，所以为这些人准备了烤鸡肉汉堡套餐，每套 <span
class="math inline">\(b\)</span>
美元。在比赛之前，主持人已经收集了想吃烤鸡肉汉堡套餐的人数 <span
class="math inline">\(x\)</span> 。</p>
<p>但是，"独行侠
"太笨了，懒得去计算主持人要花多少钱。请帮他计算一下。</p>
<h3 id="题解">题解</h3>
<p>我觉得麦当劳不素之霸更好吃，谁赞成，谁反对</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,a,b,x;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="number">1ll</span> * (n-x) * a + x * b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="j.-points-on-the-number-axis-a">J. Points on the Number Axis
A</h2>
<h3 id="题意-1">题意</h3>
<p>爱丽丝正在数轴上玩单人游戏。</p>
<p>数轴上有 <span class="math inline">\(n\)</span>
个点。玩家每次选择两个点。这两个点将被移除，并加上它们的中点。当数轴上只有一个点时，游戏结束。形式上，如果所选的两个点分别是
<span class="math inline">\(x_i\)</span> 和 <span
class="math inline">\(x_j\)</span>，那么操作后将添加 <span
class="math inline">\(\dfrac{x_i+x_j}{2}\)</span> 。</p>
<p>为了愉快地玩这个游戏，爱丽丝总是会随机选择两个点。</p>
<p>现在爱丽丝有一个问题：最后一个点的预期位置在哪里？</p>
<p>可以证明答案可以用 <span class="math inline">\(\dfrac{p}{q}\)</span>
的形式表示，只需输出 <span class="math inline">\(p\cdot q^{-1} \bmod
998,244,353\)</span> 的值即可。</p>
<h3 id="题意-2">题意</h3>
<p>其实就是所有点的平均值位置</p>
<p>下面是证明：</p>
<p>现在，假设我们有n个点，它们的坐标是<span class="math inline">\(x_1,
x_2, …, x_n\)</span>，并且我们已经证明了对于任意的<span
class="math inline">\(i\)</span>和<span
class="math inline">\(j\)</span>，点 <span
class="math inline">\(x_i\)</span>和<span
class="math inline">\(x_j\)</span>的中点的期望坐标是<span
class="math inline">\(\frac{x_i + x_j}{2}\)</span>。那么，对于这<span
class="math inline">\(n\)</span>个点，我们可以计算它们所有可能中点的平均值：
<span class="math display">\[
E = \frac{1}{\binom{n}{2}} \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} \frac{x_i +
x_j}{2}
\]</span></p>
<p><span class="math display">\[
E = \frac{2}{n(n-1)} \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} \frac{x_i +
x_j}{2}
\]</span></p>
<p><span class="math display">\[
E = \frac{1}{n} \sum_{i=1}^{n} x_i
\]</span></p>
<p>以上推导基于期望的线性性质，最后两个公式之间可能并非那么显然，考虑对单独的<span
class="math inline">\(x_i\)</span>它出现在了中点计算公式中出现了<span
class="math inline">\(n-1\)</span>次，因此后面的二重求和可以变为: <span
class="math display">\[
\frac{(n-1)}{2}\sum_{i=1}^{n} x_i
\]</span> 剩下的就很好理解了。</p>
<p>数学推导对这样的“显然解”证明，有着更好的一套方法：</p>
<p>没能够看懂题解上得公式。。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	ll sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;sum %<span class="function">MOD * <span class="title">qmi</span><span class="params">(n,MOD<span class="number">-2</span>)</span> % MOD&lt;&lt;endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="a.-long-live">A. Long Live</h2>
<h3 id="题意-3">题意</h3>
<p>在《我的世界》中，简单的世界有三个维度，其中一个维度被称为
"终结"。在这个维度中，埃德龙通常被象征为《威廉与魔法》的最终 BOSS。</p>
<p><img src="https://s2.loli.net/2024/05/16/LFcsPo3IUThMG48.png" /></p>
<p>现在，我们、你和史蒂夫都想打败这条龙。然而，我们发现艾德龙在讲述一个谜题。我们必须先解开谜题，才能与巨龙战斗。请站在我们这边，共同对抗巨龙。谜题如下</p>
<p>给定两个正整数 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> ，请找出两个整数 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span> ，使得</p>
<p><span class="math display">\[
\sqrt{\frac{lcm(x,y)}{gcd(x,y)}} = a \sqrt{b}
\]</span></p>
<p>并使 <span class="math inline">\(a \cdot b\)</span> 最大。</p>
<p>这里， <span class="math inline">\(\gcd(a,b)\)</span> 表示 <span
class="math inline">\(a,b\)</span> 的最大公约数，而 <span
class="math inline">\(\rm lcm(a,b)\)</span> 表示 <span
class="math inline">\(a,b\)</span> 的最小公倍数。</p>
<h3 id="题意-4">题意</h3>
<p>如果你的数学功底很好肯定可以极快的打出这一场的签到</p>
<p>简单的数学带入推到公式得到</p>
<p><span class="math display">\[
a \cdot b ={\frac{lcm(x,y)}{a\cdot gcd(x,y)}}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> gc = <span class="built_in">gcd</span>(x,y);</span><br><span class="line">	<span class="type">int</span> lc = <span class="built_in">lcm</span>(x,y);</span><br><span class="line">	cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;lc/gc&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
        <category>模拟赛</category>
        <category>icpc省赛</category>
      </categories>
      <tags>
        <tag>icpc</tag>
      </tags>
  </entry>
  <entry>
    <title>2024江苏CCPC邀请赛-VP</title>
    <url>/2024/2024%E6%B1%9F%E8%8B%8FCCPC%E9%82%80%E8%AF%B7%E8%B5%9B-VP/article.html</url>
    <content><![CDATA[<h2 id="江苏ccpc-vp">江苏CCPC-VP</h2>
<h2 id="f.-download-speed-monitor">F. Download Speed Monitor</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRg==">Problem - F -
Codeforces<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h3 id="题意">题意：</h3>
<p>您正在从云存储下载某些内容，但下载速度却令人大失所望。盯着下载速度监视器会让你感觉舒服一些。</p>
<p>下载速度监视器的工作原理如下：从 <span
class="math display">\[(k-1)\]</span>$
(秒)开始，下载速度监视器将始终显示 "正在加载"，但从 <span
class="math display">\[$k\]</span> (秒)开始，监视器将显示从 <span
class="math display">\[(i-k+1)\]</span><span class="math display">\[
(秒)到 \]</span><span class="math display">\[i\]</span>(秒)再到 <span
class="math display">\[i\]</span>
(秒)的平均下载速度。不过，由于监视器的尺寸较小，当平均下载速度大于或等于
<span class="math display">\[1024\]</span> KiBps 时，下载速度监视器将以
MiBps 为单位显示结果。</p>
<p>您的下载任务将持续 <span class="math display">\[n\]</span>
秒。考虑到平均速度的计算间隔为 <span class="math display">\[k\]</span>
，您想知道从 <span class="math inline">\(k\)</span><span
class="math display">\[ (秒)到 \]</span><span
class="math display">\[n\]</span> (秒)，监控器上将显示什么。</p>
<p>Note: <span class="math display">\[1\]</span>$ MiBps <span
class="math display">\[$=1024\]</span><span class="math display">\[
KiBps\]</span>​.</p>
<h3 id="题解">题解：</h3>
<p>签到题，双指针扫一下即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll sum  = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += a[i];</span><br><span class="line">		<span class="keyword">if</span>(i - j &gt;= k) sum -= a[j ++];</span><br><span class="line">		<span class="keyword">if</span>(i - j + <span class="number">1</span> &lt; k) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;i&lt;&lt; &#x27; &#x27;&lt;&lt;j&lt;&lt; &#x27; &#x27; &lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line">		<span class="type">double</span> spd = <span class="built_in">double</span>(<span class="number">1.0</span> * sum / k);</span><br><span class="line">		string ad = <span class="string">&quot;KiBps&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(spd &gt;= <span class="number">1024</span>) spd /= <span class="number">1024</span>, ad = <span class="string">&quot;MiBps&quot;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>, spd);</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ad&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="g.-download-time-monitor">G. Download Time Monitor</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vRw==">Problem - G -
Codeforces<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题意-1">题意：</h3>
<p>您正在从云存储中下载某些内容，但下载速度却令人大失所望。您觉得只监控下载速度不足以缓解您的焦虑，于是您开始计算下载时间。</p>
<p>您使用的网络带宽为 <span class="math display">\[B\]</span>
MiBps，现在有两个大文件需要下载。第一个文件开始下载的时间为 <span
class="math inline">\(t_1\)</span> 秒，大小为 <span
class="math display">\[a_1\]</span> MiB，而第二个文件开始下载的时间为
<span class="math display">\[t_2\]</span> 秒，大小为 <span
class="math display">\[a_2\]</span>
MiB。由于使用了最先进的拥塞控制算法，在任何给定时间内只有一个文件在下载时，下载速率将保持在
<span class="math display">\[B\]</span>
MiBps。当有两个文件正在下载时，两个文件的下载速率将保持恒定在 <span
class="math display">\[\frac{B}{2}\]</span>
MiBps。当一个文件开始或完成下载时，所有文件的下载速率将立即调整到目标值。</p>
<p>现在，您想知道两个文件完成下载各需要多长时间。</p>
<h3 id="题解-1">题解：</h3>
<p>出题人真是菩萨心肠，数据均小于1e5，也许是诱导模拟的track：）</p>
<p>这里我认为分类讨论写着更快，所以我分类讨论，其中反复交换两边的值简化代码。</p>
<p>注意是下载花费时间而不是总时间</p>
<p>这题浮点运算常数较大，开O2和解同步会比较好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIO std::ios::sync_with_stdio(false);std::cin.tie(0);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> B,t1,t2,a1,a2;</span><br><span class="line">	cin&gt;&gt;B&gt;&gt;t1&gt;&gt;a1&gt;&gt;t2&gt;&gt;a2;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(t1 &gt; t2)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(t1,t2);<span class="built_in">swap</span>(a1,a2);</span><br><span class="line">		f=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> d = t2-t1;</span><br><span class="line">	<span class="type">double</span> a,b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(d * B &gt; a1)&#123;</span><br><span class="line">		a = <span class="number">1.0</span> *a1 / B;</span><br><span class="line">		b = <span class="number">1.0</span> *a2 / B;</span><br><span class="line">		d=<span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		a1 -= d * B;</span><br><span class="line">		<span class="keyword">if</span>(a1 &gt; a2) f^= <span class="number">1</span>,<span class="built_in">swap</span>(a1,a2);</span><br><span class="line">		<span class="comment">// cout&lt;&lt;a1&lt;&lt; &#x27; &#x27;&lt;&lt;a2&lt;&lt;endl;</span></span><br><span class="line">		a = <span class="number">1.0</span> *a1 / (<span class="number">1.0</span> *B/<span class="number">2</span>);</span><br><span class="line">		b = <span class="number">1.0</span> *a1 / (<span class="number">1.0</span> *B/<span class="number">2</span>) + <span class="number">1.0</span> *(a2 - a1) /B;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!f) <span class="built_in">printf</span>(<span class="string">&quot;%.9lf %.9lf\n&quot;</span>,a + d, b);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.9lf %.9lf\n&quot;</span>,b + d,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="k.-number-deletion-game">K. Number Deletion Game</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSw==">Problem - K -
Codeforces<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题意-2">题意：</h3>
<p>爱丽丝和鲍勃正在玩一个数字删除游戏。</p>
<p>一开始，有 <span class="math display">\[n\]</span>$ 个整数 <span
class="math display">\[$a_ 1,a _ 2, \ldots ,a _n\]</span>
。爱丽丝和鲍勃轮流删除数字，爱丽丝先删除。每个人都可以删除<strong>大的数字</strong><span
class="math display">\[x\]</span>$ ，并选择一个比 <span
class="math display">\[$x\]</span>**小的非负整数 <span
class="math display">\[y\]</span>$ ，然后在数字 <span
class="math display">\[$1,2,\ldots, y\]</span>$
中各加一个。特别是可以选择 <span class="math display">\[$y=0\]</span>
，在这种情况下不会添加任何数字。也就是说，删除 <span
class="math display">\[1\]</span>
时，不能添加任何数字。删除最后一个数字的人获胜。</p>
<p>双方都使用最优策略。确定是爱丽丝还是鲍勃获胜。</p>
<h3 id="题解-2">题解：</h3>
<p>注意到最大值总是减少的，实际上我们是在判断最大值减少次数的奇偶性，对于一个数x而言，它可以减小最多x次。</p>
<p>另外题目中给出只能对最大值进行操作，即对其最大数的数量的奇偶判断。可以注意到对于当前操作的最大值我们归纳假定对于当前的最大值为奇数个时先手胜（因为显然为最大值为1是是先手胜的）。</p>
<p>​ 那么对于最大值取<span class="math display">\[1 \to
k\]</span>成立，试证明对k+1成立，分类讨论</p>
<pre><code>1. k+1有奇数x个，无论Bob如何操作，我们都能控制次大值的数量，即此时Alice始终控制次大值奇偶为偶
1. k+1为偶数个，同理，Bob胜</code></pre>
<p>coding</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line">	<span class="type">int</span> num = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)</span><br><span class="line">		<span class="keyword">if</span>(a[i] != a[n]) &#123;</span><br><span class="line">			num = n-i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(num == <span class="number">-1</span>) num = n;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;num&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">if</span>(num&amp;<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="i.-integer-reaction">I. Integer Reaction</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYxL3Byb2JsZW0vSQ==">Problem - I -
Codeforces<i class="fa fa-external-link-alt"></i></span></p>
<p>###　题意：</p>
<p>有一个由 <span class="math display">\[n\]</span>
个整数组成的序列，从左到右编号为 <span class="math display">\[1\]</span>
到 <span class="math display">\[n\]</span> 。这些整数有两种颜色，分别是
<span class="math display">\[0\]</span> 和 <span
class="math display">\[1\]</span>
，每个整数正好有一种颜色。这些整数按照从 <span
class="math display">\[1\]</span>到 <span
class="math display">\[n\]</span> 的编号顺序进入多集合 <span
class="math display">\[S_1\]</span> 。</p>
<p>每当一个新的整数 <span class="math display">\[x\]</span> 进入 <span
class="math display">\[S_1\]</span> 时，你必须在 <span
class="math display">\[S_1\]</span> 中选择一个颜色与 <span
class="math display">\[x\]</span> 不同的整数 <span
class="math display">\[y\]</span> 与 <span
class="math display">\[x\]</span> 发生反应，使得 <span
class="math display">\[x\]</span> 和 <span
class="math display">\[y\]</span> 消失，反应产物 <span
class="math display">\[x+y\]</span> 插入另一个集合 <span
class="math display">\[S_2\]</span> 中。如果不存在这样的 <span
class="math display">\[y\]</span> ，则不会发生反应，只有 <span
class="math display">\[x\]</span> 会插入 <span
class="math display">\[S_1\]</span> 。</p>
<p>给定整数序列和每个整数的颜色，求处理最后一个元素后 <span
class="math display">\[S_2\]</span>​ 中最小元素的最大可能值。</p>
<h3 id="题解-3">题解</h3>
<p>很简单，二分答案贪心维护<span
class="math display">\[S_1\]</span>即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ck</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="number">-1</span>)&#123;</span><br><span class="line">			ms.<span class="built_in">insert</span>(a[i].x);</span><br><span class="line">			c = a[i].y;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(c == a[i].y)&#123;</span><br><span class="line">				ms.<span class="built_in">insert</span>(a[i].x);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ms.<span class="built_in">size</span>())&#123;</span><br><span class="line">				<span class="comment">// cout&lt;&lt;x-a[i].y&lt;&lt;endl;</span></span><br><span class="line">				<span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(ms), x - a[i].x);</span><br><span class="line">				<span class="keyword">if</span>(it == ms.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// if(x==7)cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class="line">				ms.<span class="built_in">erase</span>(it);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				ms.<span class="built_in">insert</span>(a[i].x);</span><br><span class="line">				c = a[i].y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].y);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> l = <span class="number">1</span>,r = INF;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="type">int</span> mid = l+r<span class="number">+1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">ck</span>(mid)) l = mid;</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
        <category>模拟赛</category>
        <category>ccpc邀请赛</category>
      </categories>
      <tags>
        <tag>ccpc</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS运维记录</title>
    <url>/2024/CentOS%E8%BF%90%E7%BB%B4%E8%AE%B0%E5%BD%95/article.html</url>
    <content><![CDATA[<h1 id="CentOS运维"><a href="#CentOS运维" class="headerlink" title="CentOS运维"></a>CentOS运维</h1><p>记录我在CentOS中折腾的经验。</p>
<h2 id="存储空间不足"><a href="#存储空间不足" class="headerlink" title="存储空间不足"></a>存储空间不足</h2><p>在不断的使用CentOS虚拟机的过程中，docker对磁盘空间的庞大需求最终还是占满了我为学习准备的20g空间，因此，我对CentOS的磁盘开始了第一次折腾。</p>
<span id="more"></span>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>写在前面为一些缩写给出解释</p>
<ol>
<li><p>LVM的基本组成</p>
<ol>
<li>物理卷 (PV，Physical Volume)<br>一个可供存储LVM的块设备. 如硬盘分区（MBR或GPT分区）、SAN 的硬盘、RAID 或 LUN，一个回环文件, 一个被内核映射的设备 (例如 dm-crypt)，它包含一个特殊的LVM头，它是 LVM 构建的实际硬件或存储系统。</li>
<li>卷组 (VG，Volume Group)<br>卷组是对一个或多个物理卷的集合，并在设备文件系统中显示为 /dev/VG_NAME。</li>
<li>逻辑卷 (LV，Logical Volume)<br>逻辑卷是可供系统使用的最终元设备，它们在卷组中创建和管理，由物理块组成，实际上就是一个虚拟分区，并显示为 /dev/VG_NAME/LV_NAME，通常在其上可以创建文件系统。</li>
<li>物理块 (PE，Physical Extends)<br>一个卷组中最小的连续区域(默认为4 MiB)，多个物理块将被分配给一个逻辑卷。你可以把它看成物理卷的一部分，这部分可以被分配给一个逻辑卷。</li>
</ol>
</li>
<li><p>xfs文件系统：一种自Centos7起使用的文件系统</p>
</li>
</ol>
<h3 id="常用命令阐述"><a href="#常用命令阐述" class="headerlink" title="常用命令阐述"></a>常用命令阐述</h3><ol>
<li><code>lsblk</code>该命令可以查看当前硬盘的分区状况</li>
<li><code>fdisk</code>该命令可以启动分盘程序，常用<code>fdisk -l</code>查看磁盘情况</li>
<li><code>pvdisplay</code>显示物理卷</li>
<li><code>vgdisplay</code>显示虚拟卷组</li>
<li><code>lvdisplay</code>显示逻辑卷</li>
<li><code>df</code>显示文件系统的容量以及挂载点位，常用参数<code>-h</code>显示适当的大小</li>
<li><code>pvcreate</code>创建物理分区</li>
<li><code>vgextend</code>扩容vg空间</li>
<li><code>lvextend</code> 扩容lv空间 <code>-L</code>指按照指定空间，<code>-l</code>指按照指定百分比</li>
<li><code>xfs_growfs</code>增加 XFS 文件系统的大小，必须挂载 XFS 文件系统，并且底层设备上必须有可用空间。</li>
</ol>
<h3 id="虚拟机扩容"><a href="#虚拟机扩容" class="headerlink" title="虚拟机扩容"></a>虚拟机扩容</h3><p>在Vmware虚拟机中，如果VM对硬盘预留了空间，那么可以直接二通过VMware进行扩容</p>
<p><img src="https://s2.loli.net/2024/08/25/JwhxWA1cV8niUu2.png" alt="VMware"></p>
<p>但很多情况下，这个方法都是不起作用的，尤其是分配了多块硬盘的情况。</p>
<h3 id="LVM扩容"><a href="#LVM扩容" class="headerlink" title="LVM扩容"></a>LVM扩容</h3><p>LVM是扩容时所使用的空间的格式，是Linux所特有的空间的处理方法。</p>
<ol>
<li><p>通过虚拟机或服务器提供商增加硬盘大小</p>
</li>
<li><p>为当前硬盘新建分区，并格式化为lvm</p>
<ol>
<li><code>lsblk</code>显示硬盘状态</li>
<li><code>fdisk [sdx]</code> 指定硬盘名调用fdisk系统</li>
<li>新建分区</li>
<li><code>t</code>指定<code>8e</code>lvm文件系统</li>
</ol>
</li>
<li><p>将新建硬盘加入vg</p>
<ol>
<li><p>创建pv，<code>pvcreate /dev/[sdx]</code> </p>
</li>
<li><p>合并到已有vg组</p>
<ol>
<li><code>vgdisplay</code> 查看当前vg</li>
<li>对欲增加容量的vg使用<code>vgextend [VG Name] /dev/[sdx]</code></li>
</ol>
</li>
<li><p>扩展lv空间</p>
<ol>
<li><p><code>lvdisplay</code>查看已有lv空间</p>
</li>
<li><p><code>df -h</code>查看对应挂载点空间</p>
<blockquote>
<p>如LV name是home，他的LV Path是/dev/centos/home。</p>
<p>假如我们想添加空间到/home中，可以在df -h的结果中看到其对应着/dev/mapper/centos-home</p>
</blockquote>
</li>
<li><p><code>lvextend -l/L +xx%/+xxG /dev/centos/xxxxx</code>扩展空间</p>
</li>
</ol>
</li>
<li><p><code>xfs_growfs</code>使新的空间可用</p>
</li>
</ol>
</li>
</ol>
<h2 id="掉网络问题"><a href="#掉网络问题" class="headerlink" title="掉网络问题"></a>掉网络问题</h2><p>见 <a href="../Linux网络设置/article.html">Linux网络设置.md</a> 中异常处理一章</p>
<h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><ol>
<li>多快照，尤其是当你修改/etc/目录下的一些配置文件，尤其是<code>/etc/fstab</code>该文件。</li>
<li>maintain模式下，小数字键盘是不起作用的，而且这时不会有提示告诉你有问题</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8yNDI0MTM2">Linux Centos系统 磁盘分区和文件系统管理 （深入理解）-腾讯云开发者社区-腾讯云 (tencent.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFiLXpqL3AvMTM0NzQ1NDkuaHRtbA==">VMware虚拟机（centos7）容量不足调整（LVM） - 小小小光子 - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vb3JhbmdlLUNDL3AvMTI3MTEwNzguaHRtbA==">存储系列之 XFS文件系统简介 - orange-C - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkxNTQzMS9hcnRpY2xlL2RldGFpbHMvMTIxODgxMDU0">Linux下的磁盘管理之LVM详解及lvm的常用磁盘操作命令_lvm命令-CSDN博客<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>2024黑龙江省赛-VP</title>
    <url>/2024/2024%E9%BB%91%E9%BE%99%E6%B1%9F%E7%9C%81%E8%B5%9B-VP/article.html</url>
    <content><![CDATA[<h2 id="i.this-is-an-easy-problem">I.<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSQ==">This is an easy
problem<i class="fa fa-external-link-alt"></i></span></h2>
<p>超级无敌简单的签到</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) x-=x&amp;-x, s++;</span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##B.<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vQg==">String<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题意">题意</h3>
<p>斯诺有一串字符，现在他想用魔法缩短这串字符。每次他施法时，都可以消除三个相邻的相同字符。但斯诺觉得反复施法太费时间了，所以他希望您能帮他计算出使用任意次数魔法后字符串的最短形式。</p>
<h3 id="题解">题解</h3>
<p>可以注意到一种典型的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aabcccbba</span><br></pre></td></tr></table></figure>
<p>这种嵌套的字符串，与栈的特性很类似，是一种特殊的“括号匹配”，不过此处是三个为一组合法的符号序列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		stk[++top] = s[i];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// for(int i=1;i&lt;=top;i++) cout&lt;&lt;stk[i];</span></span><br><span class="line">		<span class="comment">// 	cout&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> cc = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = top;j&gt;=top<span class="number">-2</span>&amp;&amp; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">			cc++;</span><br><span class="line">			<span class="keyword">if</span>(stk[j<span class="number">-1</span>] != stk[j]) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(cc == <span class="number">3</span>)&#123;</span><br><span class="line">			top-=<span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!top) cout&lt;&lt;<span class="string">&quot;NAN&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++) cout&lt;&lt;stk[i];</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="j.trade">J.<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSg==">Trade<i class="fa fa-external-link-alt"></i></span></h2>
<p>在一个繁荣的国家，金斯诺决定从事贸易。</p>
<p>这个国家由 <span class="math display">\[n*m\]</span>
座城市组成。每个城市由一对整数 <span class="math display">\[(x,
y)\]</span> 表示，其中 <span class="math display">\[1\leq x\leq
n\]</span> 和 <span class="math display">\[1\leq y\leq m\]</span>
表示其在网格中的位置。在城市 <span class="math display">\[(x,y)\]</span>
中，物品的价格用 <span class="math display">\[a[x][y]\]</span>
表示，到达该城市的旅行费用用 <span
class="math inline">\(b[x][y]\)</span> 表示。</p>
<p>在踏上旅程之前，金斯诺需要你为他规划一条路线。路线必须符合以下条件：</p>
<ul>
<li>路线的起点必须是位于第一行第一列的城市，即 <span
class="math display">\[(1, 1)\]</span> 。</li>
<li>路线的终点必须是位于最后一行（ <span class="math display">\[x =
n\]</span> ）或最后一列（ <span class="math inline">\(y = m\)</span>
）的城市。</li>
<li>金斯诺只能从城市 <span class="math display">\[(x_i, y_i)\]</span>
移动到 <span class="math display">\[(x_i+1, y_i)\]</span> 或 <span
class="math display">\[(x_i, y_i+1)\]</span> 。因此，对于路线中的每一步
<span class="math inline">\(i\)</span> （路线中的最后一步除外）， <span
class="math display">\[(x_{i+1}, y_{i+1})\]</span> 必须选择在 <span
class="math display">\[(x_i, y_i)\]</span> 的正下方或正右方。</li>
</ul>
<p>进入路线后，Kingsnow 将在路线的第一个城市 <span
class="math display">\[(1, 1)\]</span>
购买一件物品。然后，他将任意选择路线上的另一个城市出售该物品。此外，从他开始旅行的城市到他出售物品的城市之间，每到一个城市，他都会支付旅行费用。</p>
<p>也就是说，对于任何给定的路线 <span class="math display">\[(x_1, y_1),
(x_2, y_2), ..., (x_k, y_k)\]</span> ，Kingsnow 都会从区间 <span
class="math display">\[[2, k]\]</span> 中任意选择一个整数 <span
class="math inline">\(t\)</span> 。他在城市 <span
class="math inline">\((x_t, y_t)\)</span> 出售商品的利润计算公式为 <span
class="math display">\[ \text{Profit} = a[x_t][y_t] - a[1][1] -
\sum_{i=1}^t b[x_i][y_i]\]</span></p>
<p>金斯诺寻找的路线是，无论他选择在路线上的哪个城市出售物品，他都能获得非负利润。</p>
<h3 id="题解-1">题解</h3>
<p>然我们重新看一看这个式子</p>
<p><span class="math display">\[ \text{Profit} = a[x_t][y_t] - a[1][1] -
\sum_{i=1}^t b[x_i][y_i]\]</span></p>
<p>我们把它简单变换一下 <span class="math display">\[
Profit = a[x_t][y_t] - a[1][1] - \sum_{i=1}^{t} b[x_i][y_i]\ge 0\\
\rightarrow a[x_t][y_t] - \sum_{i=1}^{t} b[x_i][y_i]\ge a[1][1] \\
\rightarrow a[x_t][y_t] \ge a[1][1]+\sum_{i=1}^{t} b[x_i][y_i]
\]</span> 简单思考一下，我们似乎并不关心<span
class="math display">\[a[x_t][y_t]\]</span>每一个的值，只关心他是否大于右边这个值</p>
<p>再看一看<span class="math display">\[n,m \le
1000\]</span>这个数据量对dp，记忆化都是可行的。显然我们可以处理出对每一个点的最小总合b值，对于满足上面条件的点我们记录一下，最后看一看起始点与最终点是否是一个连通块。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==n &amp;&amp; y == m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x &gt;n || y&gt; m || (!st[x][y])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	st[x][y] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">dfs</span>(x<span class="number">+1</span>,y)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">dfs</span>(x,y<span class="number">+1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		cin&gt;&gt;a[i][j];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		cin&gt;&gt;b[i][j];</span><br><span class="line"></span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>] = f[<span class="number">0</span>] [<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">		f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j] + b[i][j], f[i][j<span class="number">-1</span>] + b[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class="line">	<span class="comment">// 	for(int j=1;j&lt;=m;++j)</span></span><br><span class="line">	<span class="comment">// 		cout&lt;&lt;f[i][j]&lt;&lt;&#x27;\t&#x27;;</span></span><br><span class="line">	<span class="comment">// 	cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i][j] + a[<span class="number">1</span>][<span class="number">1</span>] &lt;= a[i][j])&#123;</span><br><span class="line">			st[i][j]  = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	st[<span class="number">1</span>][<span class="number">1</span>] = st[n][m] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;++i) &#123;</span></span><br><span class="line">	<span class="comment">// 	for(int j=1;j&lt;=m;++j)</span></span><br><span class="line">	<span class="comment">// 		cout&lt;&lt;st[i][j];</span></span><br><span class="line">	<span class="comment">// 	cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>)) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="k.-puzzle">K. <span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vSw==">Puzzle<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题意-1">题意</h3>
<p>24
字谜是一道经典的算术谜题，其目的是找到一种方法来处理四个整数，使最终结果为
24。</p>
<p>Nerifish 非常喜欢这种谜题，因此他为自己设计了一个类似的谜题。</p>
<p>Nerifish 有四张扑克牌，每张牌上的数字都是 <span
class="math display">\[a,b,c,d(1\leq a,b,c,d\leq 13)\]</span>
。他可以按照任意顺序排列扑克牌，并用加号、减号和乘号将它们连接起来。请注意，不能使用括号，最终表达式应包含
4 个整数和 3 个运算符。</p>
<p>Nerifish 想知道他能得到多少结果。</p>
<h3 id="题解-2">题解</h3>
<p>简单的计算可得<span class="math display">\[2^8 = 256\]</span></p>
<p>暴力！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,stack&lt;<span class="type">int</span>&gt; s,set&lt;<span class="type">int</span>&gt;&amp; S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(s.<span class="built_in">size</span>()) ans += s.<span class="built_in">top</span>(),s.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">		S.<span class="built_in">insert</span>(ans);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(u==<span class="number">0</span>) s.<span class="built_in">push</span>(a[u]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">			s.<span class="built_in">push</span>(a[u<span class="number">+1</span>]);</span><br><span class="line">			<span class="built_in">dfs</span>(u<span class="number">+1</span>,s,S);</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">			s.<span class="built_in">push</span>(-a[u<span class="number">+1</span>]);</span><br><span class="line">			<span class="built_in">dfs</span>(u<span class="number">+1</span>,s,S);</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> t = s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">			s.<span class="built_in">push</span>(t * a[u<span class="number">+1</span>]);</span><br><span class="line">			<span class="built_in">dfs</span>(u<span class="number">+1</span>,s,S);</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a,a<span class="number">+4</span>);</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="comment">// for(int i=0;i&lt;4;++i) cout&lt;&lt;a[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">		<span class="comment">// 	cout&lt;&lt;endl;</span></span><br><span class="line">		stack&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">0</span>,t, S);</span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a,a<span class="number">+4</span>));</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;S.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="d.card-game">D.<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9neW0vMTA1MTYzL3Byb2JsZW0vRA==">Card Game<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题意-2">题意</h3>
<p>甲和乙在玩纸牌游戏，游戏开始时，甲和乙各有一些健康值，分别叫做
<em>hpa</em> 和 <em>hpb</em> 。每个玩家开始时都有 <em>n</em>
张牌，分别叫做 <span class="math display">\[a_1, a_2... a_n \]</span>和
<em>b</em>1, <span class="math display">\[b_1,b_2...b_n\]</span>
，每个玩家每回合都要出一张他之前没有出过的牌。卡牌分为两种：攻击卡牌和防御卡牌。每张攻击卡都有攻击力，如果一方出了攻击卡，而另一方没有出防御卡，则另一方的健康值会减少攻击卡的攻击力；如果另一方出了防御卡，则他的健康值不会减少。如果一方出了一张防御牌，除了防御对方的攻击外，没有其他效果。</p>
<p>回合结束时，如果任何一方的健康值小于或等于零，游戏就结束。如果只有一方的健康值小于或等于零，则另一方获胜。如果双方的健康值都小于或等于零，则平局。如果所有回合结束后，没有一方的健康值为零或更少，则也是平局。</p>
<p>我们称 A 打出的牌序列为 <span class="math display">\[p_1, p_2... p_n
\]</span>，称 B 打出的牌序列为 <span class="math display">\[q_1, q_2...
q_n\]</span> ，它们是从 1 到 <em>n</em> 的排列。如果在
<em>i</em> - <em>th</em> 回合之前游戏还没有结束，那么在
<em>i</em> - <em>th</em> 回合，甲会下 <em>a<strong>p</strong>i</em>
，乙会下 <em>b<strong>q</strong>i</em> 。</p>
<p>现在你知道了 A 和 B
的牌。问题是是否存在一对A和B的出牌顺序能让A获胜。</p>
<h3 id="题解-3">题解</h3>
]]></content>
      <categories>
        <category>比赛</category>
        <category>模拟赛</category>
        <category>icpc省赛</category>
      </categories>
      <tags>
        <tag>icpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex宏包pgfplots做矩形函数图像</title>
    <url>/2024/Latex%E5%AE%8F%E5%8C%85pgfplots%E5%81%9A%E7%9F%A9%E5%BD%A2%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F/article.html</url>
    <content><![CDATA[<p>持续更新遇到的问题，完结或不再使用该包将删除这句话</p>
<h2 id="pgfplots"><a href="#pgfplots" class="headerlink" title="pgfplots"></a>pgfplots</h2><p>Pgfplots是一种可视化工具，可简化在文档中包含绘图的过程。基本思想是，用户提供输入数据/公式，然后pgfplots 宏包会帮助用户绘制响应的图像。</p>
<span id="more"></span>
<h3 id="实例一、通过函数方程绘制函数图像"><a href="#实例一、通过函数方程绘制函数图像" class="headerlink" title="实例一、通过函数方程绘制函数图像"></a>实例一、通过函数方程绘制函数图像</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%Ex1:f(x)=exp(x)</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;axis&#125;</span><br><span class="line"><span class="keyword">\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class="line"><span class="keyword">\end</span>&#123;axis&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/07/iPmhCOxRgzZGYVy.png" alt="test-1-crop-1"></p>
<p>其中绘制图像的语法如下：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\addplot</span>[option] &#123;expression of 2D function&#125;;</span><br></pre></td></tr></table></figure>
<p>在方括号内可以传递一些选项，比如我们可以像Ex1一样，将函数图像的颜色设置为红色。我方括号是必需的，如果没有传递任何选项，则方括号之间留有空白即可。在花括号内，我们要填写的2D 函数的表达式，比如在Ex1中，我们所写的表达式是 exp⁡(𝑥) 。最后最重要的是该命令必须以分号 <strong>;</strong> 结尾。</p>
<h3 id="实例二、坐标系的绘制以及3d函数图像"><a href="#实例二、坐标系的绘制以及3d函数图像" class="headerlink" title="实例二、坐标系的绘制以及3d函数图像"></a>实例二、坐标系的绘制以及3d函数图像</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\pagestyle</span>&#123;empty&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;pgfplots&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">%Ex2: put the 2D plot and the 3D plot together</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;axis&#125;</span><br><span class="line">		<span class="keyword">\addplot</span>[color=red]&#123;exp(x)&#125;;</span><br><span class="line">	<span class="keyword">\end</span>&#123;axis&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="comment">%Here ends the furst 2D plot</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\hskip</span> 10pt</span><br><span class="line"></span><br><span class="line"><span class="comment">%Here begins the 3d plot</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;axis&#125;</span><br><span class="line">		<span class="keyword">\addplot</span>3[</span><br><span class="line">		surf,</span><br><span class="line">		]</span><br><span class="line">		&#123;exp(-x<span class="built_in">^</span>2-y<span class="built_in">^</span>2)*x&#125;;</span><br><span class="line">	<span class="keyword">\end</span>&#123;axis&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/07/d7OUNVRI3LWthxK.png" alt="test-1-crop-1"></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\addplot</span>3[</span><br><span class="line">    surf,</span><br><span class="line">]</span><br><span class="line">&#123;exp(-x<span class="built_in">^</span>2-y<span class="built_in">^</span>2)*x&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到这里只是将2d图像的命令后面加了一个3，读者可以多修改一下option中的参数，这里的surf指surface，声明这是一个曲面图，并表面着色。</p>
<p>可以看到对多个图像只需要设定多个tikzpicture作用域即可</p>
<h4 id="坐标系图像中的常用命令、参数与特性"><a href="#坐标系图像中的常用命令、参数与特性" class="headerlink" title="坐标系图像中的常用命令、参数与特性"></a>坐标系图像中的常用命令、参数与特性</h4><ul>
<li>xlabel、ylabel：设定x,y坐标轴上的标志。</li>
<li>多个addplot可在同一个图中多次作图</li>
<li><script type="math/tex">\tt{domian = a:b}</script>设置 𝑥 的范围为 [𝑎,𝑏] 。即只绘制函数在 𝑥∈[𝑎,𝑏] 之间的图像；</li>
<li><script type="math/tex">\tt{axis\,\, lines = left}</script>这个命令会仅在图的左侧和底部设置轴，即我们的平面直角坐标系，而不是像我们在图片3中看到的那种默认框；</li>
<li>\addlegendentry{$function（x)$​} 添加函数标签 </li>
<li>\legend 按顺序批量谭家函数标签</li>
<li>title在axis中为图像添加标题</li>
</ul>
<h3 id="实例三、数据图"><a href="#实例三、数据图" class="headerlink" title="实例三、数据图"></a>实例三、数据图</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%Ex6:plot from data</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;axis&#125;[</span><br><span class="line">		title=&#123;Temperature dependence of CuSO<span class="built_in">$</span><span class="built_in">_</span>4<span class="keyword">\cdot</span><span class="built_in">$</span>5H<span class="built_in">$</span><span class="built_in">_</span>2<span class="built_in">$</span>O solubility&#125;,</span><br><span class="line">		xlabel=&#123;Temperature [<span class="keyword">\textcelsius</span>]&#125;,</span><br><span class="line">		ylabel=&#123;Solubility [g per 100 g water]&#125;,</span><br><span class="line">		xmin=0, xmax=100,</span><br><span class="line">		ymin=0, ymax=120,</span><br><span class="line">		xtick=&#123;0,20,40,60,80,100&#125;,</span><br><span class="line">		ytick=&#123;0,20,40,60,80,100,120&#125;,</span><br><span class="line">		legend pos=north west,</span><br><span class="line">		ymajorgrids=true,</span><br><span class="line">		grid style=dashed,</span><br><span class="line">		]</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">\addplot</span>[</span><br><span class="line">		color=blue,</span><br><span class="line">		mark=square,</span><br><span class="line">		]</span><br><span class="line">		coordinates &#123;</span><br><span class="line">			(0,23.1)</span><br><span class="line">			(10,27.5)</span><br><span class="line">			(20,32)</span><br><span class="line">			(30,37.8)</span><br><span class="line">			(40,44.6)</span><br><span class="line">			(60,61.8)</span><br><span class="line">			(80,83.8)</span><br><span class="line">			(100,114)</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">\legend</span>&#123;CuSO<span class="built_in">$</span><span class="built_in">_</span>4<span class="keyword">\cdot</span><span class="built_in">$</span>5H<span class="built_in">$</span><span class="built_in">_</span>2<span class="built_in">$</span>O&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">\end</span>&#123;axis&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据图像中的常用命令、参数与特性"><a href="#数据图像中的常用命令、参数与特性" class="headerlink" title="数据图像中的常用命令、参数与特性"></a>数据图像中的常用命令、参数与特性<img src="https://s2.loli.net/2024/05/08/NzwV7TsPHLWjbJB.png" alt="test-1-crop-1"></h4><ul>
<li>mark：设定图像点的形状；如square、triangle、x等</li>
<li><script type="math/tex">\tt{ymajorgrids=true/false\,,xmajorgrids=true/false}</script>​启用/禁用 𝑦,𝑥 轴上<strong>刻度线位置上</strong>的网格线；</li>
<li><script type="math/tex">\tt{xmin=a, xmax=b, ymin=c, ymax=d}</script>​设置 𝑥 的最小值为 𝑎 ，最大值为 𝑏 ；设置 𝑦 的最小值为 𝑐 ，最大值为 𝑑 ；</li>
<li><script type="math/tex">\tt{coordinates \{\}}</script>​设定坐标点画折线图</li>
<li>\addplot[option] table {file_with_the_data.dat},使用该命令可直接通过dat数据画图</li>
</ul>
<h3 id="其他图像"><a href="#其他图像" class="headerlink" title="其他图像"></a>其他图像</h3><p>pgfplots还支持散点图，直方图，3d图等图像。由于笔者暂时没用到，对这些图不甚了解，就不做阐述了。值得注意的是，在这些图像中使用dat数据格式的数据较多。</p>
<h3 id="导言区的一些设定"><a href="#导言区的一些设定" class="headerlink" title="导言区的一些设定"></a>导言区的一些设定</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\pgfplotsset</span>&#123;width=10cm&#125;</span><br></pre></td></tr></table></figure>
<p>这里指定了每一张图的宽度为10cm</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepgfplotslibrary</span>&#123;external&#125;</span><br><span class="line"><span class="keyword">\tikzexternalize</span> </span><br></pre></td></tr></table></figure>
<p>由于<script type="math/tex">LATEX</script> 诞生初期并未考虑使其具备绘图功能，因此当文档中有多个pgfplot图形或它们非常复杂时，渲染它们将花费大量时间。</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>latex</category>
        <category>package</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker镜像与容器使用</title>
    <url>/2024/Docker%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/article.html</url>
    <content><![CDATA[<h1 id="Docker-Image-amp-amp-container"><a href="#Docker-Image-amp-amp-container" class="headerlink" title="Docker Image &amp;&amp; container"></a>Docker Image &amp;&amp; container</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><ol>
<li><code>docker stats</code> 该命令可以查看docker contianer对各种资源的占用量</li>
<li><code>docker image ls -a</code> 查看image状况 -a表示所有的</li>
<li><code>docker container ls -a</code> 查看container状况 -a表示查看所有的</li>
<li><code>docker container start/stop [container_id]</code>启停对应的container</li>
<li><code>docker container/image rm [container_id]/[image_id]</code>移除镜像或容器。</li>
<li><code>docker commit sharelatex sharelatex:version_tag</code> 提交容器为镜像</li>
</ol>
<span id="more"></span>
<h2 id="Image与Container的关系"><a href="#Image与Container的关系" class="headerlink" title="Image与Container的关系"></a>Image与Container的关系</h2><p>Container可以commit为Image</p>
<p>Image也可以run为Container</p>
<h3 id="什么是docker-image"><a href="#什么是docker-image" class="headerlink" title="什么是docker image"></a>什么是docker image</h3><p>Docker Image（Docker镜像）是用于创建Docker容器的只读模板。它包含了运行应用程序所需的所有内容，包括代码、依赖项、库、环境变量和配置文件。Docker镜像是容器的“蓝图”，容器是镜像的运行实例。</p>
<ol>
<li><p>Docker Image 是只读的</p>
</li>
<li><p>Docker Image的存储是分层的</p>
<p><img src="https://s2.loli.net/2024/08/25/eZ5XUC1zKHLRfJh.png" alt="DockerImages"></p>
<p>对如图的1,2,4镜像，通过tag显然可以发现他们的顺序是2-3-4，即总共占用8g而非16g</p>
</li>
</ol>
<h3 id="什么是Docker-Container"><a href="#什么是Docker-Container" class="headerlink" title="什么是Docker Container"></a>什么是Docker Container</h3><p>Docker Container（Docker容器）是一个独立运行的应用程序实例，它基于Docker镜像启动，并包含了运行应用所需的所有依赖、配置和环境。Docker容器是轻量级的、可移植的，它们在隔离的环境中运行，确保应用程序的行为在任何系统中都是一致的。</p>
<ol>
<li>Container是共享主机的操作系统内核的（但是同样可以使用不同的操作系统）</li>
<li>Container之间是隔离的</li>
<li>Container是独立的，并不基于除主机以外的东西</li>
<li>Container是可以短时（瞬时）启动和关闭的</li>
</ol>
<h3 id="如何启动Container"><a href="#如何启动Container" class="headerlink" title="如何启动Container"></a>如何启动Container</h3><h4 id="通过Docker源，网络下载启动容器"><a href="#通过Docker源，网络下载启动容器" class="headerlink" title="通过Docker源，网络下载启动容器"></a>通过Docker源，网络下载启动容器</h4><p>一般来讲，我们可以通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p [HostIP]:[HostPort]:[DockerPort] --name [ContainerName] [SoftwareName]:[version]</span><br></pre></td></tr></table></figure>
<p>启动一个特定的容器并将docker的某一个开放端口映射到主机上，其中-d使得容器的输出并不同步到主机上</p>
<h4 id="通过本地Image仓库启动容器"><a href="#通过本地Image仓库启动容器" class="headerlink" title="通过本地Image仓库启动容器"></a>通过本地Image仓库启动容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p [HostIP]:[HostPort]:[DockerPort] &lt;image_name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>
<h3 id="如何将Container提交为Image"><a href="#如何将Container提交为Image" class="headerlink" title="如何将Container提交为Image"></a>如何将Container提交为Image</h3><p>相当简单</p>
<p>直接调用一条命令即可<code>docker commit sharelatex sharelatex:version_tag</code>即可</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装与网络配置</title>
    <url>/2024/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/article.html</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>在部署服务器时，经常在各式各样的仓库中见到Docker部署这一方式，开始不以为然，后来发现它极高的普及率与及其方便的部署方式吸引了我的注意。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS8=">docker<i class="fa fa-external-link-alt"></i></span>是一个开源的平台，主要用于开发、运输和运行应用程序。它通过使用容器（Containers）技术，使得应用程序能够在任何环境下以一致的方式运行，无论是在开发、测试，还是在生产环境中。</p>
<span id="more"></span>
<p>可以说，只要你配置好了docker，所有知名的软件就都向你敞开了大门。下面，从我是用docker的角度出发，讲一下实用的docker概念与使用技巧。</p>
<ol>
<li><p>docker与dockercompose</p>
<p>Docker 和 Docker Compose 是两个密切相关的工具，但它们的功能和用途有所不同，通常一起使用来管理容器化的应用程序。</p>
<p>Docker是一个基础平台，安装docker 通常讲指单纯安装这一组件，实际上，很多下载方式也都是这么做的，<strong>但我并不推荐这种方式</strong>，实际上就截至目前的体验，dockercompose的体验对新手是要好于docker的。</p>
<p>dockercompose是docker的具体独立工具依赖 Docker，但它是一个独立的工具，需要单独安装。</p>
</li>
<li><p>网络问题</p>
<p>由于发展中的问题，对docker的下载时常是困难的，且下载完整且最新的docker很可能是“<strong>有误导性</strong>”的，因为，如果你挂了镜像而且即使更新了镜像，也无从得知下载的版本是否正确，能否运行所需的软件。</p>
<p>这里还是推荐直接上机场或VPS直连通过官网方式不通过镜像来下载，虽然经济上可能有损耗，但总体来看，减少时间成本是多于增加的经济成本的。</p>
<p>然而，<strong>挂载了加速可能你也会发现</strong>，docker的网络并不通过我们的代理，事实上，docker并不走“常见”的网络代理，在linux中，<strong>在执行docker pull时，是由守护进程dockerd来执行。因此，代理需要配在dockerd的环境中。而这个环境，则是受systemd所管控，因此实际是systemd的配置。</strong> </p>
</li>
</ol>
<h2 id="安装最新Docker"><a href="#安装最新Docker" class="headerlink" title="安装最新Docker"></a>安装最新Docker</h2><p>若只想安装一个可用的源，截至2024/7/24，有一份教程在参考资料第6个。</p>
<h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>对于安装最新Docker，科学上网几乎是必备的，无论你使用的任何镜像（ps：除非是确保可信且不会过期的，包括国内部分知名互联网公司及大部分学校镜像都是无效或过期的）</p>
<p>比较知名的源有：Aliyun，清华，ustc中科大</p>
<p>参考文章<a href="Linux网络设置/article.html">Linux网络设置</a></p>
<h3 id="通过yum安装"><a href="#通过yum安装" class="headerlink" title="通过yum安装"></a>通过yum安装</h3><p>该命令可移除全部docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                docker-client \</span><br><span class="line">                docker-client-latest \</span><br><span class="line">                docker-common \</span><br><span class="line">                docker-latest \</span><br><span class="line">                docker-latest-logrotate \</span><br><span class="line">                docker-logrotate \</span><br><span class="line">                docker-engine</span><br></pre></td></tr></table></figure>
<ol>
<li><p>更新系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum update -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">    device-mapper-persistent-data \</span><br><span class="line">    lvm2 </span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>额外设置与验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>你可能已经发现了，即使通过以上方式下载了docker，也不一定是最新版，甚至相当可能是1.1x等超老版本，这是因为使用的yum镜像源的问题，国内很多镜像源都在许多年前“停止了维护”。但如果你的yum是国外源的话，很有可能没这个问题，也就不用看下面的内容了，查找最新版本请看docker官网（在参考资料中）</p>
<h3 id="通过dnf进行安装"><a href="#通过dnf进行安装" class="headerlink" title="通过dnf进行安装"></a>通过dnf进行安装</h3><p>以下操作需要保证你的yum仓库状态正常，并且联通外网，如果原本<code>yum makecache</code>就无法成功，那么dnf也是救不了的</p>
<p><img src="https://s2.loli.net/2024/08/23/riq6ygcF9jKfEvA.png" alt="[Supported platforms](https://docs.docker.com/desktop/install/linux-install/#supported-platforms)"></p>
<p>在docker官网里，我们可以查询到他所支持的Linux列表，而在Centos中，我们可以通过<code>cat /proc/version</code> <code>uname -a</code>,<code>cat /etc/os-release</code>分别查询到内核以及系统版本，而Centos7属于RHEL的克隆版本。因此尝试使用RHEL的安装方式，即官网描述的dnf新一代RPM库安装</p>
<ol>
<li><p>安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装dnf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install dnf -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置dnf，与添加常用的第三方库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dnf install &#x27;dnf-command(config-manager)&#x27;</span><br><span class="line">dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm</span><br><span class="line">dnf install pass</span><br><span class="line">dnf install gnome-shell-extension-appindicator # GNOME</span><br><span class="line">gnome-extensions enable appindicatorsupport@rgcjonas.gmail.com # GNOME</span><br><span class="line">sudo dnf install gnome-terminal # GNOME</span><br><span class="line">dnf install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>额外设置与验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="AliyunECS"><a href="#AliyunECS" class="headerlink" title="AliyunECS"></a>AliyunECS</h3><p>当服务器满足下图条件时，可通过扩展程序安装Docker</p>
<p><img src="https://s2.loli.net/2024/08/24/Eyqh8e6HoAnFVxr.png" alt="Aliyun"></p>
<p>详见对参考资料中阿里云的官方文档</p>
<h2 id="Docker的网络代理"><a href="#Docker的网络代理" class="headerlink" title="Docker的网络代理"></a>Docker的网络代理</h2><p><img src="https://s2.loli.net/2024/08/27/nPUjY3yCtleLosD.png" alt="docker与daemon在代理中的关系"></p>
<p><img src="https://s2.loli.net/2024/08/24/vYtQrRgiSsyd14E.png" alt="daemon与网络的关系"></p>
<p>事实上，daemon与client可以运行在两个主机上，在同一主机上运行时，真正与互联网进行交互的实际上是Daemon守护程序，也就是说，当我们普通的配置env进行代理的时候，我们配置的是Client与Daemon交互的代理，而配置Daemon后才能达到“端到端”的代理。</p>
<p>下面只阐述如何进行端到端的代理配置</p>
<p>在<code>/etc/systemd/system</code>该路径下寻找<code>docker.service.d/http-proxy.conf</code>,没有则新建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://IP:Port/&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=http://IP:Port/&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=localhost,127.0.0.1,.example.com&quot;</span><br></pre></td></tr></table></figure>
<p>在这里，我是用的clash-for-linux的IP为127.0.0.1，Port为7890，可以通过 <a href="../Linux网络设置.md">Linux网络设置.md</a>设置。 </p>
<p>最后重启他俩即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="Dockers-Container的网络代理"><a href="#Dockers-Container的网络代理" class="headerlink" title="Dockers Container的网络代理"></a>Dockers Container的网络代理</h3><h3 id="直接在容器内添加代理"><a href="#直接在容器内添加代理" class="headerlink" title="直接在容器内添加代理"></a>直接在容器内添加代理</h3><p>这种方式如同在主机添加代理，步骤一致，但并不推荐，如果不是测试使用，最好还是保证容器的完整性。</p>
<blockquote>
<p>但如果需要该容器处处可用，修改环境变量也是可行的</p>
</blockquote>
<p>略</p>
<h3 id="在Docker17版本以上"><a href="#在Docker17版本以上" class="headerlink" title="在Docker17版本以上"></a>在Docker17版本以上</h3><p><code>Docker</code> 提供了一个<strong>全局的配置</strong>，<strong>可以通过配置 <code>Docker</code> 客户端以自动将代理信息传递给容器</strong>，从而让所有的容器内部都支持代理访问。</p>
<p>在<strong>启动容器的用户的主目录中</strong>创建或编辑文件 <code>~/.docker/config.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;proxies&quot;</span><span class="punctuation">:</span></span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;httpProxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://127.0.0.1:7890&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;httpsProxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://127.0.0.1:7890&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;noProxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*.test.example.com,.example2.com,127.0.0.0/8&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后重启docker两兄弟即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VsZWd5Y2xvdWQvY2xhc2gtZm9yLWxpbnV4LWJhY2t1cA==">Elegycloud/clash-for-linux-backup: 基于Clash Core 制作的Clash For Linux备份仓库 A Clash For Linux Backup Warehouse Based on Clash Core (github.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZGVza3RvcC9pbnN0YWxsL2xpbnV4LWluc3RhbGwv">Install Docker Desktop on Linux | Docker Docs<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS8=">Docker: Accelerated Container Application Development<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbi5saW51eC10ZXJtaW5hbC5jb20vP3A9NTE4MA==">如何在CentOS 7上安装DNF (linux-terminal.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vemgvZWNzL3VzZS1jYXNlcy9pbnN0YWxsLWFuZC11c2UtZG9ja2VyLW9uLWEtbGludXgtZWNzLWluc3RhbmNlIzI5OGE4YzZiZGMxOTM=">安装Docker并使用_云服务器 ECS(ECS)-阿里云帮助中心 (aliyun.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY29kZW5vb2IvcC8xODI4MTk5Mg==">使用国内源安装新版docker（2024.7.3） - navist2020 - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlbmcyaHVpMTMxNC9hcnRpY2xlL2RldGFpbHMvMTI0MjY3MzMz">快速设置 Docker 的三种网络代理配置_docker 代理-CSDN博客<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Miracl的配置ForCentos7</title>
    <url>/2024/Miracl%E7%9A%84%E9%85%8D%E7%BD%AEForCentos7/article.html</url>
    <content><![CDATA[<p>Miracl is Multiprecision Integer and Rational Arithmetic Cryptographic Library – the MIRACL Crypto SDK – is a C software library that is widely regarded by developers as the gold standard open source SDK for elliptic curve cryptography (ECC).</p>
<p>Miracl 是多精度整数和有理数算术加密库（MIRACL Crypto SDK），是一个 C 软件库，被开发人员广泛视为椭圆曲线加密 (ECC) 的黄金标准开源 SDK。也可在c++环境下通过对c库的</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;miracl.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现兼容。</p>
<p>下面是对miracl在c++环境下部署的简单步骤</p>
<p>第一步、联网状态下通过该命令获取压缩包，也可离线通过ftp传输</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/miracl/MIRACL/archive/master.zip</span><br></pre></td></tr></table></figure>
<p>第二步、创建一个文件夹用来存放解压文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir miracl</span><br></pre></td></tr></table></figure>
<p>第三步、复制并解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp master.zip ./miracl</span><br><span class="line">cd miracl/</span><br><span class="line">unzip -j -aa -L master.zip</span><br></pre></td></tr></table></figure>
<p>第四步、验证解压并运行linux64（若32位运行linux）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">bash linux64</span><br><span class="line">ll | grep miracl.a</span><br></pre></td></tr></table></figure>
<p>第五步、运行官方程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./pk-demo</span><br></pre></td></tr></table></figure>
<p>第六步、一般情况下、复制一下文件到你的源代码目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ../miracl/miracl.a miracl.a</span><br><span class="line">cp ../miracl/miracl.h miracl.h</span><br><span class="line">cp ../miracl/mirdef.h mirdef.h</span><br></pre></td></tr></table></figure>
<p>完成，注意在linux部署十分简单，但在windows环境下按照网络上的教程会爆出各种各样奇怪的错误，读者若要尝试，建议多参考官方文档，准备好比linux环境下部署多耗费许多心神的准备（ps:做好了发个blog）笔者虽然也已经配好了，静态库如下，但在一些程序内还是会报错，个人觉得是静态库制作过程中少了一些源文件并未制作，如下：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly8xZHJ2Lm1zL2YvcyFBcC1lblk3Y2tMQU5nb05NSVF5c1hSVlM4TGRHeVE=">静态库文件<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>软件</category>
        <category>经典库</category>
        <category>信息安全</category>
        <category>Miracl</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>软件</tag>
        <tag>Miracl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络设置</title>
    <url>/2024/Linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/article.html</url>
    <content><![CDATA[<h1 id="linux的网络配置">Linux的网络配置</h1>
<p>在我反复鼓捣Linux的过程中，时常遇到Linux在网络配置上的问题，有个互联网笑话是“老钟是最擅长计算机网络的”。既然如此，我也有了一个想法——记录下我在Linux网络配置中所遭遇的坑。硬件主要集中于LinuxECS服务器与VMware虚拟机，软件版本则是以CentOS7，Ubuntu18.04为主。</p>
<h2 id="基础网络命令">基础网络命令</h2>
<ol type="1">
<li><code>ifconfig</code>最基本最常用的命令，用于查看本地网卡的信息，一般查看值为IP或者本地物理地址</li>
<li><code>ping</code>
简单的测试网络丢包率，有时<code>curl</code>命令对网站的检测更为准确，因为两者对于代理的检测并不完全一致</li>
<li><code>netstat</code>用于查看本地端口的状态信息，一般用于查看当前那些端口是开放的，那些端口是被某个特定应用监控的，一般搭配<code>grep</code>使用</li>
<li><code>traceroute</code>针对特定目标地址的报文转发追踪，基于IP报文中的生存时间TTL实现，一般用于查看对特定网络服务是否联通，也可用于查看本机某个端口是否对外界开放，最经典的例子就是mail端口25，这个端口国内很少开放</li>
<li><code>whois</code>
查看域名建立时间，有效期等，一般用于查看网站的归属信息以及ssl证书的有效期</li>
<li><code>host</code>查看有关目的地址的信息，既可以通过IP查看域名，也可以通过域名查看IP</li>
<li><code>ifdown</code>
<code>ifup</code>,这两个命令用于对特定网卡的关启</li>
<li><code>nmtui</code> 通过调用一个内置的网卡配置图形化界面配置网卡</li>
<li><code>systemctl start/stop/enable/restart NetworkManager</code>这是一个特殊的通过systemctl控制网络服务以实现对网络进行开关的命令，常用于对<code>/etc/NetworkManager/NetworkManager.conf</code>该文件进行修改后的重新配置网络</li>
<li><code>env | grep -E 'http_proxy|https_proxy'</code>这条命令比较特殊，一般用于查看当前的代理</li>
</ol>
<span id="more"></span>
<h2 id="如何科学上网">如何科学上网</h2>
<h3 id="windows平台">Windows平台</h3>
<p>对于Windows平台，该平台有大量用户基础，并且生态良好，很容易找到代理上网的软件以及节点。（初接触者千万区分这两者，代理是代理也称机场，软件是软件）。两者一个收费最好，一个完全免费。</p>
<h4 id="推荐软件">推荐软件</h4>
<p>V2ray、ClashForWindows等</p>
<h3 id="linux平台">Linux平台</h3>
<p>推荐clash-for-linux，一个个人自用的备份库</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VsZWd5Y2xvdWQvY2xhc2gtZm9yLWxpbnV4LWJhY2t1cA==">Elegycloud/clash-for-linux-backup:
基于Clash Core 制作的Clash For Linux备份仓库 A Clash For Linux Backup
Warehouse Based on Clash Core (github.com)<i class="fa fa-external-link-alt"></i></span></p>
<p>根据md文档操作即可</p>
<p>注：</p>
<ol type="1">
<li>这样的操作一般用于加速对github的下载</li>
<li>配置其他的服务代理一般需要特别配置，因为很多服务实际上是通过守护进程来进行网络通信的</li>
</ol>
<h4 id="常用的软件配置">常用的软件配置</h4>
<h5 id="yum">yum</h5>
<p>注意对yum文件的禁用修改方式，不要使用rm，而是加文件名后缀禁用文件</p>
<ol type="1">
<li><p>全局修改</p>
<p>修改/etc/yum.conf文件即可，在结尾添加你的本地代理网址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy=http://IP:Port</span><br><span class="line">// 在本文中为</span><br><span class="line">proxy=http://127.0.0.1：7890</span><br></pre></td></tr></table></figure></li>
<li><p>对特定的仓库启用代理</p>
<p>比如<code>CentOS-Base.repo</code>中有三个仓库：base、updates和extras。我们只想给base仓库设置代理，则只需要在对应的仓库后面添加一行，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra</span><br><span class="line">baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"># 下一行为新增,效果为base仓库走代理</span><br><span class="line">proxy=http://ip:port</span><br><span class="line"># 下注释一行为base不走代理</span><br><span class="line"># proxy=_none_</span><br><span class="line">#released updates </span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-$releasever - Updates</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates&amp;infra=$infra</span><br><span class="line">baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#additional packages that may be useful</span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-$releasever - Extras</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra</span><br><span class="line">baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-</span><br><span class="line">gpg/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="docker">docker</h5>
<p>按照需求修改文件即可，详见</p>
<p><a href="Docker安装与网络配置/article.html">Docker.md</a></p>
<h3 id="无广告个人自用机场">无广告，个人自用机场</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdXN0bXlzb2Nrcy5hcHAv">Just My Socks官网<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="异常修复">异常修复</h2>
<p><strong>重装系统或恢复快照</strong></p>
<p>在花式乱搞后，虚拟机（服务器）的网络很容易会出现问题，比如，完全看不到虚拟机的网络选项，它有网卡但是却根本不获取ip！</p>
<figure>
<img src="https://s2.loli.net/2024/08/24/uRIr2VMaYvtkFhH.png"
alt="Error" />
<figcaption aria-hidden="true">Error</figcaption>
</figure>
<p>这种情况一般都是 network这个网卡服务出现了问题</p>
<ol type="1">
<li><p>找到错误</p>
<p>查找虚拟机设置或者通过其他命令与文件查找到错误之后，通过<code>systemctl restart network</code>验证该服务是否出错</p></li>
<li><p>排除关联</p>
<p>通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl disable NetworkManager</span><br><span class="line">systemctl start network.service</span><br></pre></td></tr></table></figure>
<p>成功启动服务，确定network服务启动失败与NetworkManager之间的关联</p>
<p>但可以观察到，此时问题仍未解决，虚拟机仍无法上网，但是通过<code>ifconfig ens33</code>（ens33为网卡名）可以发现dhcp正常工作，更进一步的，我们从虚拟机ping主机也是可以ping通的</p></li>
<li><p>尝试解决上网问题</p>
<p>每种vm切换连接方式都解决不了问题，虚拟机仍无法上网，但可以发现，每次启动NetworkManager服务，就会导致虚拟机失去IP从而无法通信</p></li>
</ol>
<p>可见NetworkManager与network之间发生了一些冲突，导致两个服务相互影响使得网络处于要么能分配ip但上不了网，要么根本没ip的局面。</p>
<figure>
<img src="https://s2.loli.net/2024/08/24/1K8cfE5atGrgeAY.png"
alt="xe" />
<figcaption aria-hidden="true">xe</figcaption>
</figure>
<p>尝试查看错误信息可以发现其中奥秘。可以发现这一切都与一个名叫lo的本地环回接口有关，它被设置为不受管理。</p>
<p>在我询问chatgpt后，我得到了一种解决方式</p>
<p><strong>这种方式使得NetworkManager与network服务同时进行，可以访问网络，但无网络连接图标</strong>（虚拟机环境）</p>
<p>具体方式为</p>
<ol type="1">
<li><p>确保 <code>lo</code> 接口没有被 NetworkManager
管理。<code>/etc/NetworkManager/NetworkManager.conf</code>
文件中修改配置</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">main</span>]</span><br><span class="line">plugins=keyfile</span><br><span class="line"></span><br><span class="line">[<span class="meta">keyfile</span>]</span><br><span class="line"><span class="keyword">unmanaged</span>-devices=<span class="keyword">interface</span>-<span class="title">name</span>:<span class="title">lo</span></span><br></pre></td></tr></table></figure></li>
<li><p>清除可能的网络配置缓存</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sudo ip addr flush dev ens33</span><br><span class="line">sudo ip route flush table main</span><br></pre></td></tr></table></figure></li>
<li><p>重启服务</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart NetworkManager</span><br><span class="line">sudo systemctl restart network.service</span><br></pre></td></tr></table></figure></li>
</ol>
<p><del>对于虚拟机的网络显示问题，目前还未找到好的解决方式，网络上博主表示直接重装系统即可。。。</del>
找到方法了，
直接挂起然后启动就好，很神奇，重启解决不了，挂起能解决。。。</p>
<blockquote>
<p>网络管理器(NetworManager)是检测网络、自动连接网络的程序。无论是无线还是有线连接，它都可以令您轻松管理。对于无线网络,网络管理器优先连接已知的网络并可以自动切换到最可靠的无线网络。利用网络管理器的程序可以自由切换在线和离线模式。网络管理器会相对无线网络优先选择有线网络，支持
VPN。网络管理器最初由 Redhat 公司开发，现在由 GNOME 管理。</p>
<p>NetworkManager由一个管理系统网络连接、并且将其状态通过D-BUS（是一个提供简单的应用程序
互相通讯的途径的自由软件项目，它是作为freedesktoporg项目的一部分来开发的。）进行报告的后台服务，以及一个允许用户管理网络连接的客户端程序。</p>
</blockquote>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9wc2hpemhzeXN1LmdpdGJvb2suaW8vbGludXgveXVtL3dlaS15dW0teXVhbi1wZWktemhpLWRhaS1saQ==">为yum源配置代理
| linux (gitbook.io)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2Z4L3AvMTcyOTM0NzIuaHRtbA==">解决centos7网卡启动失败解决（亲测有效！！）
- 王飞侠 - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs安装简要建议</title>
    <url>/2024/Nodejs%E5%AE%89%E8%A3%85%E7%AE%80%E8%A6%81%E5%BB%BA%E8%AE%AE/article.html</url>
    <content><![CDATA[<h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><h3 id="什么是Nodejs"><a href="#什么是Nodejs" class="headerlink" title="什么是Nodejs"></a>什么是Nodejs</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnLw==">Node.js — Run JavaScript Everywhere<i class="fa fa-external-link-alt"></i></span>这是NodeJS的官网标题，很简单的概括，他就是在任何地方都可以运行javascript。</p>
<p>具体的讲，如下。。</p>
<blockquote>
<p> Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。</p>
</blockquote>
<span id="more"></span>
<h3 id="下载时一步步涉及到的包管理"><a href="#下载时一步步涉及到的包管理" class="headerlink" title="下载时一步步涉及到的包管理"></a>下载时一步步涉及到的包管理</h3><p>nvm——Node Version Manager</p>
<p>fnm——Fast Node Manager</p>
<p>nvm 有一个致命的缺点，就是它的自动切换版本极其麻烦，而 fnm 就没这个问题。并且 Windows 上的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=">nvm<i class="fa fa-external-link-alt"></i></span> 与 macOS 上的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmV5YnV0bGVyL252bS13aW5kb3dz">nvm<i class="fa fa-external-link-alt"></i></span> 实际上并不是同一个，Windows 的只是借了 nvm 的名称，API略有不同，构建两者的语言更是完全不相同。而 fnm 在三大系统上都是同一个，这保证了 API 的一致性。</p>
<p>下面以fnm为例</p>
<h3 id="fnm-下载"><a href="#fnm-下载" class="headerlink" title="fnm 下载"></a>fnm 下载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://fnm.vercel.app/install | bash</span><br></pre></td></tr></table></figure>
<p>如果安装不成功，考虑是不是服务器连不上外网，通过其他渠道下载fnm软件包并解压到对应位置，在.bashrc中添加环境变量即可。下载链接如下：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9vYmplY3RzLmdpdGh1YnVzZXJjb250ZW50LmNvbS9naXRodWItcHJvZHVjdGlvbi1yZWxlYXNlLWFzc2V0LTJlNjViZS8xNjYwNDU0MjQvNGMwYTllMmEtOWIyMi00ZWJlLWIwMjYtZGU1ZTc4ZGU5MzUxP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9cmVsZWFzZWFzc2V0cHJvZHVjdGlvbiUyRjIwMjQwNTI5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDUyOVQwODMzMjRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1kNWUxMzc2M2I5NzUwNzI3YmQ0NWIwMTRkMTJhYTdlM2E4OTNmZmUyNzU4MTg5NzEwZDhjMTFkODc0ZWI5ZTY2JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD05MTI3MzE2MSZrZXlfaWQ9MCZyZXBvX2lkPTE2NjA0NTQyNCZyZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0IlMjBmaWxlbmFtZSUzRGZubS1saW51eC56aXAmcmVzcG9uc2UtY29udGVudC10eXBlPWFwcGxpY2F0aW9uJTJGb2N0ZXQtc3RyZWFtb2JqZWN0cy5naXRodWJ1c2VyY29udGVudC5jb20vZ2l0aHViLXByb2R1Y3Rpb24tcmVsZWFzZS1hc3NldC0yZTY1YmUvMTY2MDQ1NDI0LzRjMGE5ZTJhLTliMjItNGViZS1iMDI2LWRlNWU3OGRlOTM1MT9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPXJlbGVhc2Vhc3NldHByb2R1Y3Rpb24lMkYyMDI0MDUyOSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA1MjlUMDgzMzI0WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZDVlMTM3NjNiOTc1MDcyN2JkNDViMDE0ZDEyYWE3ZTNhODkzZmZlMjc1ODE4OTcxMGQ4YzExZDg3NGViOWU2NiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9OTEyNzMxNjEma2V5X2lkPTAmcmVwb19pZD0xNjYwNDU0MjQmcmVzcG9uc2UtY29udGVudC1kaXNwb3NpdGlvbj1hdHRhY2htZW50JTNCJTIwZmlsZW5hbWUlM0Rmbm0tbGludXguemlwJnJlc3BvbnNlLWNvbnRlbnQtdHlwZT1hcHBsaWNhdGlvbiUyRm9jdGV0LXN0cmVhbQ==">fnm.zip<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="NodeJS18版本以上的gcc-amp-make版本要求"><a href="#NodeJS18版本以上的gcc-amp-make版本要求" class="headerlink" title="NodeJS18版本以上的gcc&amp;make版本要求"></a>NodeJS18版本以上的gcc&amp;make版本要求</h3><p>要求gcc必须版本8以上（较流行的版本为11），make版本4以上，并且在一些环境下需要更新GLIBC（只能通过源码安装，因为涉及Linux底层动态链接库），通过下载源代码包configure（注意参数）以及make，make install即可安装，注意，此步骤为高级操作，操作前请备份快照重要文件，可能导致库文件缺失引起的ssh无法连接，编译时长30min以上，make参数采用-j𝑛(通常为处理器数目两倍)可以加速。</p>
<p>以下是另一个博主的详细介绍，可以参考一下，笔者在更新GLIBC时也是参考的这篇blog</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTk3OTE0NTA/c3BtPWEyYzZoLjEyODczNjM5LmFydGljbGUtZGV0YWlsLjcuNzEzNzY1ZmFadXZTd2g=">OSError: /lib64/libm.so.6: version `GLIBC_2.27’ not found (required by xxx.so) ——升级GLIBC并解决系统错误 - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></p>
<p>在make过程中通常涉及</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ld-linux-x86-64.so.2\libc.so.6</span><br></pre></td></tr></table></figure>
<p>两个软连接的更改，在更改时会中断make程序并导致系统异常，需要重新手动连接软连接（如果你make时出错并且系统无法ls的情况下）<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTk3OTE0NTA/c3BtPWEyYzZoLjEyODczNjM5LmFydGljbGUtZGV0YWlsLjcuNzEzNzY1ZmFadXZTd2g=">https://zhuanlan.zhihu.com/p/559791450?spm=a2c6h.12873639.article-detail.7.713765faZuvSwh<i class="fa fa-external-link-alt"></i></span>)</p>
<p>最后记得设置环境变量，切勿随意删除系统gcc文件。</p>
<blockquote>
<p> 许多blog在configure中设置—profix=/usr，需要自定义的用户请注意，这样会导致文件混乱。个人常用（/usr/local/soft-name）</p>
</blockquote>
<p>安装NodeJS详细步骤建议参考官方：<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL3BhY2thZ2UtbWFuYWdlcg==">Node.js — Download Node.js® (nodejs.org)<i class="fa fa-external-link-alt"></i></span></p>
<p>注意前面提到的依赖项，以及官网的curlpost请求不到可能是网络因素</p>
<h3 id="NodeJS验证"><a href="#NodeJS验证" class="headerlink" title="NodeJS验证"></a>NodeJS验证</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>两条指令均正常即说明程序成功安装</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>经典库</category>
        <category>前端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>gcc</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Overleaf-toolkit部署</title>
    <url>/2024/Overleaf-toolkit%E9%83%A8%E7%BD%B2/article.html</url>
    <content><![CDATA[<h1 id="Overleaf-toolkit部署"><a href="#Overleaf-toolkit部署" class="headerlink" title="Overleaf-toolkit部署"></a>Overleaf-toolkit部署</h1><blockquote>
<p>在写latex的过程中，第一个使用的在线latex编辑器就是overleaf，但是在使用过程中受到诸多限制，遂欲购买overleafpro，但发现其学生价也要500yuan/year，实在是财力不足，但overleaf是开源的，要花钱的只是服务器算力以及各种模板，于是就有了部署Overleaf-toolkit的想法</p>
</blockquote>
<p>Overleaf是一个在线多用户协作的Latex编辑网站，其采用了如同markdown的“所见即所得”思想，采用及时更新编译的方式辅助编辑latex文件，同时通过项目结构约束文件的排布。是一个是十分学术且普遍应用的latex编辑网站。</p>
<span id="more"></span>
<h2 id="安装前置条件"><a href="#安装前置条件" class="headerlink" title="安装前置条件"></a>安装前置条件</h2><ol>
<li>一台性能至少为2h/2g的服务器（cpu2h空闲且性能较强且剩余内存至少1.5g），个人使用也可以是一台虚拟机。</li>
<li>并且至少保留10g的内存余量</li>
<li>最好有个域名。</li>
</ol>
<p><img src="https://s2.loli.net/2024/08/25/Gc4RtmuqsK6lQM8.png" alt="Usage"></p>
<p>上图为容器运行后各个模块对资源的占用量，值得注意的是在本机中，配置好完整的texlatex与中文字集，对硬盘占用量达到了十个g，并且本机cpu为i7-11800h</p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>以下部分可能省略部分操作在参考资料中可以找到</p>
<h3 id="安装overleaf-toolkit"><a href="#安装overleaf-toolkit" class="headerlink" title="安装overleaf-toolkit"></a>安装overleaf-toolkit</h3><p>这一步十分简单，按照overleafgithub官方库中给的教程即可，唯一需要注意的点如下：</p>
<ol>
<li>修改overleaf.rc文件需要关闭所有相关服务并bin/up重新生成docker，慎重第一次生成</li>
<li>默认占用80端口，但是如果服务器配置了nginx并且希望方向代理，则需要更改overleaf.rc文件<ul>
<li><code>OVERLEAF_PORT</code> 指的是运行 Overleaf 的容器要选择曝露的端口，默认是 80 端口但如果有要使用 Nginx 反向代理的需求的话则需要自选一个端口（不常用的就行）；</li>
<li><code>SIBLING_CONTAINERS_ENABLED</code> 这个配置真的巨坑，默认的话是 <code>true</code> 但如果没有购买官方的 Server Pro 的话请直接修改成 <code>false</code>，因为这个功能很大程度上依赖于官方提供给 Server Pro 用户的镜像，如果不调到 <code>false</code> 的话极有可能出现编译失败的情况；</li>
</ul>
</li>
<li>站点标题在variables.env中</li>
</ol>
<h2 id="一些基础配置"><a href="#一些基础配置" class="headerlink" title="一些基础配置"></a>一些基础配置</h2><h3 id="安装完整版texLive"><a href="#安装完整版texLive" class="headerlink" title="安装完整版texLive"></a>安装完整版texLive</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL292ZXJsZWFmL3Rvb2xraXQvYmxvYi9tYXN0ZXIvZG9jL2NlLXVwZ3JhZGluZy10ZXhsaXZlLm1kP3NwbT1hMmM2aC4xMjg3MzYzOS5hcnRpY2xlLWRldGFpbC4xNC41YTMzNjk0NVVtU01peCZmaWxlPWNlLXVwZ3JhZGluZy10ZXhsaXZlLm1k">官方升级TexLive文档<i class="fa fa-external-link-alt"></i></span></p>
<p>根据官方文档升级即可，注意version很有可能是不同的，overleaf官方每隔半年就会更新一次，因此，需要修改部分命令，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit sharelatex sharelatex/sharelatex:[version]-with-texlive-full</span><br><span class="line">echo [version]-with-texlive-full &gt; config/version</span><br></pre></td></tr></table></figure>
<h3 id="新增中文字体"><a href="#新增中文字体" class="headerlink" title="新增中文字体"></a>新增中文字体</h3><p>我们可以通过导入我们自己电脑中的中文字体做到这一步</p>
<ol>
<li><p>如何将自己电脑中的winfonts.tar.gz生成出来</p>
<ol>
<li><p><img src="https://s2.loli.net/2024/08/24/iWBOjIt7LwRvDSe.png" alt="字体文件夹"></p>
<p>找到上图的这个文件夹，复制走想要的字体（绝大部分中文字体），然后压缩为winfonts.tar.gz(任意格式)</p>
</li>
<li><p>ftp传到linux主机中就好</p>
</li>
</ol>
</li>
<li><p>继续参照参考资料2进入docker操作</p>
<ol>
<li><p>安装必要的包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it share</span><br><span class="line">apt update</span><br><span class="line">apt install -y latex-cjk-all texlive-lang-chinese texlive-lang-english</span><br><span class="line">apt install -y xfonts-wqy</span><br></pre></td></tr></table></figure>
</li>
<li><p>将所有字体文件移动到/usr/share/fonts/winfonts中并执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfontscale</span><br><span class="line">mkfontdir</span><br><span class="line">fc-cache -fv</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="修复XeLatex"><a href="#修复XeLatex" class="headerlink" title="修复XeLatex"></a>修复XeLatex</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it sharelatex /bin/bash/</span><br><span class="line">apt update</span><br><span class="line">apt install -y texlive-xetex texlive-latex-extra texlive-science</span><br></pre></td></tr></table></figure>
<h3 id="刻录镜像"><a href="#刻录镜像" class="headerlink" title="刻录镜像"></a>刻录镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat config/version # 该命令会得到[version]</span><br><span class="line">docker commit sharelatex sharelatex/sharelatex:[version]-with-texlive-full</span><br><span class="line">echo [version]-with-texlive-full &gt; config/version</span><br></pre></td></tr></table></figure>
<p>注意在编写中文文档时需要调整至XeLaTex，并且调用Ctex包</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL292ZXJsZWFmL3Rvb2xraXQ=">overleaf/toolkit (github.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzE1NzI2MDY=">Linux 快速搭建 Overleaf 5.0 附中文字体及完整 TexLive 安装教程（2024最新版）-阿里云开发者社区 (aliyun.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudG5uaWRtLmNvbS9idWlsZC1hbmQtdXNlLW92ZXJsZWFmLXNlcnZlci8=">搭建和使用overleaf服务器 | Tnnidm-Blog<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL292ZXJsZWFmL3Rvb2xraXQvYmxvYi9tYXN0ZXIvZG9jL2NlLXVwZ3JhZGluZy10ZXhsaXZlLm1kP3NwbT1hMmM2aC4xMjg3MzYzOS5hcnRpY2xlLWRldGFpbC4xNC41YTMzNjk0NVVtU01peCZmaWxlPWNlLXVwZ3JhZGluZy10ZXhsaXZlLm1k">toolkit/doc/ce-upgrading-texlive.md at master · overleaf/toolkit (github.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly95eG5jaGVuLmdpdGh1Yi5pby90ZWNobmlxdWUvRG9ja2Vy6YOo572yU2hhcmVMYVRlWOW5tueugOWNlemFjee9ruS4reaWh+eOr+Wigy8j5YeG5aSH5bel5L2c">Docker部署ShareLaTeX并简单配置中文环境 | YXN’s Blog (yxnchen.github.io)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmliaWJsaW8ub3JnL0NUQU4vbGFuZ3VhZ2UvY2hpbmVzZS9jdGV4L2N0ZXgucGRm">CTeX 宏集手册 (ibiblio.org)<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
        <category>latex</category>
        <category>overleaf</category>
      </categories>
      <tags>
        <tag>latex</tag>
        <tag>overleaf</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA涉及算法与数论知识</title>
    <url>/2024/RSA%E6%B6%89%E5%8F%8A%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86/article.html</url>
    <content><![CDATA[<p><strong>RSA</strong> (<strong>Rivest–Shamir–Adleman</strong>) is a <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHVibGljLWtleV9jcnlwdG9ncmFwaHk=">public-key
cryptosystem<i class="fa fa-external-link-alt"></i></span>, one of the oldest widely used for secure data
transmission.</p>
<p>RSA（Rivest–Shamir–Adleman）是一种公钥密码系统，是最古老且广泛用于安全数据传输的系统之一。它是一种非对称公钥-私钥密码系统。</p>
<span id="more"></span>
<h2 id="基础数论知识纲要">基础数论知识纲要</h2>
<p>传送门：<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3R1ZG9jdS5jb20vc2cvY291cnNlL25hbnlhbmctdGVjaG5vbG9naWNhbC11bml2ZXJzaXR5L251bWJlci10aGVvcnkvMzAzMTkzNA==">MH3210
- NTU - Number Theory - Studocu<i class="fa fa-external-link-alt"></i></span></p>
<p>知乎blog：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MzUzMzI2NTg=">基础数论学习笔记（1）-
Divisibility 整除 - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></p>
<p>讲义：<span class="exturl" data-url="aHR0cHM6Ly8xZHJ2Lm1zL2YvcyFBcC1lblk3Y2tMQU5nb05Ib3R6cTNTUlRhZnA0cGc=">NanYang
Technological University MH1300ANDMH3210<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="概念定义">概念定义</h2>
<p><strong>费马小定理</strong>：选一个<strong>素数p</strong>，再选一个和p不成倍数关系的整数β，必然满足<strong>β的p次幂</strong>和<strong>β</strong>对p同余。公式如下。
<span class="math display">\[
\beta^p \equiv \beta (modp)
\]</span> <strong>二次剩余</strong>： 取定 <span
class="math display">\[𝑎\perp 𝑝\]</span>, 假若存在着 <span
class="math inline">\(x\)</span>使得 <span class="math display">\[
x^2 \equiv a (modp)
\]</span></p>
<p>则称<span class="math display">\[a\]</span>是<span
class="math display">\[modp\]</span>的特殊剩余，否则则是<span
class="math display">\[modp\]</span>的二次非剩余</p>
<p><strong>欧拉准则</strong>：元素β是<strong>模奇素数p</strong>的平方剩余的充要条件是，β的(p-1)/2次幂和1对p同余。即以下公式
<span class="math display">\[
\beta ^ {(p-1)/2} \equiv 1 (mod p) | p \equiv 1 (mod2)
\]</span></p>
<blockquote>
<p>欧拉准则证明： 设<span class="math display">\[r^2 =
\beta\]</span>则有 <span class="math display">\[r^{p-1} \equiv 1
(modp)\]</span>,利用费马小定理即可得证。</p>
</blockquote>
<p><strong>勒让德符号</strong>：<span
class="math inline">\((\frac{a}{p})\)</span> 若<span
class="math inline">\(a\)</span> 是<span
class="math inline">\(modp\)</span>的平方剩余 则 <span
class="math inline">\((\frac{a}{p}) = 1\)</span> ，若不是，则<span
class="math inline">\((\frac{a}{p})= -1\)</span>，<span
class="math inline">\(a\)</span><span
class="math inline">\(和\)</span><span
class="math inline">\(p\)</span>是整除关系则<span
class="math inline">\((\frac{a}{p})=0\)</span> ,如下列公式 <span
class="math display">\[
(\frac{a}{p}) =
\begin{cases}
1,\quad x^2 \equiv a(modp)\\
0, \quad a \equiv 0 (modp) \\
-1, \quad x^2 \not\equiv a(modp)
\end{cases}
\tag{1}
\]</span> Solovay-Strassen算法：若n是一个素数，那么勒让德符号<span
class="math inline">\((\frac{β}{n})\equiv β^{(n-1)/2}mod
n\)</span>。</p>
<blockquote>
<p>Strassen算法证明：根据欧拉准则<strong>β的(n-1)/2次方和1对n不同余</strong>，根据费马小定理，<strong>β的n-1次方</strong>和1对n同余，根据平方差公式，<span
class="math inline">\(β^{n-1}-1=(β^{(n-1)/2}-1)(β^{(n-1)/2}+1)\)</span>
。由于<span class="math inline">\(（β^{(n-1)/2}-1）\)</span>
无法被n整除，所以<span class="math inline">\(（β^{(n-1)/2}+1）\)</span>
必然能被n整除，进而得到<span
class="math inline">\(β^{(n-1)/2}\equiv-1  (mod n)\)</span>。</p>
</blockquote>
<p><strong>该命题的逆命题是不成立的</strong></p>
<p><strong>二次互反律</strong>：<span class="math inline">\(\mathbb
Z_p^\times\to\mathbb Z_2\)</span></p>
<p><strong>Miller-Rabin算法</strong>：</p>
<p>输入待测试大数<span class="math display">\[n\]</span>，对<span
class="math display">\[n-1\]</span>不断地进行除<span
class="math display">\[2\]</span>操作，直到得到一个<strong>奇数t</strong>。</p>
<p>于是这可以写成 <span class="math inline">\(n-1 = 2^s \cdot t\)</span>
。显然的，待测试大数<span
class="math inline">\(n\)</span>肯定是个奇数（废话，是偶数还测个锤子了），那么<span
class="math display">\[n-1\]</span>肯定是个偶数，故<span
class="math inline">\(s\not=0\)</span>。</p>
<p>选择<strong>随机种子<span
class="math inline">\(a\)</span></strong>，<span
class="math inline">\(a＜n\)</span>且与<span
class="math inline">\(n\)</span>互素。（这个也很容易做到，如果随便一下子就测出来不互素，那就不用测了）</p>
<p>先设<span class="math inline">\(m=t\)</span>。计算 <span
class="math inline">\(b \equiv a^t(modn)\)</span> ：</p>
<ul>
<li><p>情况①：当 <span class="math inline">\(m=2^s \cdot t = n
-1\)</span>时，停机，输出“n是一个合数”。</p></li>
<li><p>情况②：当 <span class="math inline">\(b \equiv -1 (modn)\)</span>
时，停机，换一个随机种子<span
class="math inline">\(a\)</span>再次进行测试。</p></li>
<li><p>情况③：当<span class="math inline">\(b \equiv
-1(modn)\)</span>不成立时，重新设<span
class="math inline">\(b\)</span>为<span class="math inline">\(b²(mod
n)\)</span>，<span class="math inline">\(m\)</span>为<span
class="math inline">\(2m\)</span>​；继续循环，直到得到情况①或情况②为止。</p></li>
</ul>
<h2 id="计算方法">计算方法</h2>
<p><strong>快速幂</strong>：通过二进制的快速幂优化</p>
<p><strong>计算勒让德符号<span
class="math inline">\((\frac{\beta}{n})\)</span>​</strong> ：二次互反</p>
<p><strong>大整数除法中对小除数的优化</strong>：移位计算小除数的商</p>
<p><strong>大整数除法中对大除数的优化</strong>：二分查找对每次计算试商的优化</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>加密算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Xiaobai94</title>
    <url>/2024/Xiaobai94/article.html</url>
    <content><![CDATA[<h2 id="b-小苯的好数组_牛客小白月赛94-nowcoder.com"><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvQg==">B-小苯的好数组_牛客小白月赛94
(nowcoder.com)<i class="fa fa-external-link-alt"></i></span></h2>
<span id="more"></span>
<h3 id="题意">题意</h3>
<p>大白熊给了小苯一个长度为 <span class="math inline">\(n\)</span>
的数组 <span
class="math inline">\(a\)</span>，这次他希望小苯从数组中选择一个<strong>子序列</strong>（下方备注有定义解释），满足这个子序列构成的数组是一个“好数组”。</p>
<p>大白熊定义好数组是：如果一个数组按升序排序后和原来<strong>不完全相同</strong>，则其是一个好数组。例如
<span class="math inline">\([3,2,2]\)</span> 升序排序后是 <span
class="math inline">\([2, 2,
3]\)</span>，和原来不完全相同，因此<strong>是</strong>一个好数组，而
<span class="math inline">\([1,2,2]\)</span>
<strong>不是</strong>一个好数组。</p>
<p>小苯想知道，如果想要使得选择的子序列构成一个“好数组”，最长可以选多长的子序列？</p>
<h3 id="题解">题解</h3>
<p>误入签到，答案只有0和n两种，很好判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ve;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">		ve.<span class="built_in">pb</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ls = <span class="number">0</span>,flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:ve)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v &lt; ls)flag = <span class="number">1</span>;</span><br><span class="line">		ls = <span class="built_in">max</span>(v,ls);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag) cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c-小苯的数字合并_牛客小白月赛94-nowcoder.com"><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvQw==">C-小苯的数字合并_牛客小白月赛94
(nowcoder.com)<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题意-1">题意</h3>
<p>大白熊给了小苯一个长度为 <span class="math display">\[n\]</span>
的数组 <span
class="math display">\[a\]</span>，小苯想要<strong>最大化</strong> <span
class="math display">\[a\]</span> 的极差。</p>
<p>具体的，小苯可以做如下操作任意次（前提是数组至少有两个数字）：</p>
<p><span class="math inline">\(\bullet\)</span> 选择一个正整数 <span
class="math display">\[i \ (1 \leq i &lt;n)\]</span>，接着将 <span
class="math display">\[a_i\]</span> 与 <span
class="math display">\[a_{i+1}\]</span>
合并为一个数字，结果为二者的和。</p>
<p>（即：将 <span class="math display">\[a_i\]</span> 变为 <span
class="math display">\[a_i + a_{i+1}\]</span>，然后删去 <span
class="math display">\[a_{i+1}\]</span>，当然操作完后 <span
class="math inline">\(a\)</span> 的长度也会减一。）</p>
<p>小苯想知道他最大能将数组极差变为多少呢，请你帮帮他吧。</p>
<h3 id="题解-1">题解</h3>
<p>注意到无法将数字变小，因此保留最小值是最优的，我们枚举最小值，计算前缀后缀和即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		pre[i] = pre[i<span class="number">-1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)</span><br><span class="line">		rep[i] = rep[i<span class="number">+1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mx = <span class="built_in">max</span>(pre[i<span class="number">-1</span>] ,rep[i<span class="number">+1</span>]);</span><br><span class="line">		ans = <span class="built_in">max</span>(ans,mx - a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="d-小苯的排列构造_牛客小白月赛94-nowcoder.com"><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRA==">D-小苯的排列构造_牛客小白月赛94
(nowcoder.com)<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题意-2">题意</h3>
<p>格格有一个长度为 <span class="math display">\[n\]</span> 的排列 <span
class="math display">\[p\]</span>，但她不记得 <span
class="math display">\[p\]</span> 具体的样子，她只记得数组 <span
class="math display">\[a\]</span>。<br />
其中：<span class="math display">\[a_i = gcd(p_1,
p_2,...,p_i)\]</span>，也就是说，<span
class="math display">\[a_i\]</span> 表示排列 <span
class="math display">\[p\]</span> 中前 <span
class="math display">\[i\]</span> 个数字的最大公约数。</p>
<p>现在，她希望小苯将排列 <span class="math display">\[p\]</span>
复原出来，请你帮帮他吧。</p>
<p>（但有可能无解，这意味着格格给出的 <span
class="math display">\[a\]</span> 数组可能是不正确的，此时输出 <span
class="math display">\[-1\]</span> 即可。）</p>
<h3 id="题解-2">题解</h3>
<p>公约数只会不断变小或保持不变，排列的前缀最大公约数最多会有log(2e5)个非1的数，即不到30个数。并且满足这个数组非严格递减的。</p>
<p>如果整个数组除1外无相同数字，显然我们直接对1以前的数字按原样赋值即可，第一个1赋值1，随后任意。</p>
<p>如果整个数组对1存在相同数字，显然直接对第一个原样赋值也是可行的，随后赋值该数的倍数即可</p>
<p>注意由于最多只有log(2e5)个数是非1的，因此很容易想到整体的复杂度是不大于n*log(n)的，对于枚举倍数的过程可能存在更好的优化，这里就不提及了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; a[i<span class="number">-1</span>] % a[i] != <span class="number">0</span>) f = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ves;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> c = <span class="number">1</span>, s = a[i];</span><br><span class="line">		<span class="keyword">while</span>(i &lt; n &amp;&amp; a[i<span class="number">+1</span>] == a[i])i ++,c ++;</span><br><span class="line">		<span class="type">int</span> t = s;</span><br><span class="line">		<span class="keyword">while</span>(c &amp;&amp; t &lt;= n) &#123;</span><br><span class="line">			<span class="keyword">while</span>(st[t]) t+=s;</span><br><span class="line">			<span class="keyword">if</span>(t &gt; n) <span class="keyword">break</span>;</span><br><span class="line">			ves.<span class="built_in">push_back</span>(t);</span><br><span class="line">			st[t] = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// cout&lt;&lt;t&lt;&lt;endl;</span></span><br><span class="line">			t+=s,c--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(c) &#123;f = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!f) &#123;cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl; <span class="keyword">return</span> ;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v: ves) cout&lt;&lt;v&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="e-小苯的01背包easy_牛客小白月赛94-nowcoder.com"><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRQ==">E-小苯的01背包（easy）_牛客小白月赛94
(nowcoder.com)<i class="fa fa-external-link-alt"></i></span></h2>
<p>##<span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI5NTcvRg==">F-小苯的01背包（hard）_牛客小白月赛94
(nowcoder.com)<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题意-3">题意</h3>
<p><strong>注：此版本为本题的easy（简单版），与hard（困难版）唯一的不同之处只有数据范围。</strong></p>
<p>小苯有一个容量为 <span class="math inline">\(k\)</span>
的背包，现在有 <span class="math inline">\(n\)</span>
个物品，每个物品有一个体积 <span class="math inline">\(v\)</span> 和价值
<span class="math inline">\(w\)</span>，他想知道在体积不超过 <span
class="math inline">\(k\)</span>
的前提下，他最多能装价值为多少的物品。</p>
<p>本问题中，物品的总体积定义为所装物品的体积的 <span
class="math inline">\(\&amp;\)</span>（按位与），总价值也定义为所装物品的价值的
<span class="math inline">\(\&amp;\)</span>（按位与）。</p>
<p>（如果不选物品，则价值为 0，所占体积也为 0。）</p>
<h3 id="题解-3">题解</h3>
<p>按位与显然需要从高到低位考虑，需要体积小而整体物品的价值高，容易想到，较少的物品容易有较高的价格。（并的最大值是当前物品中的最大值）</p>
<p>比如对于二进制下物品价值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101101</span><br><span class="line">110010</span><br><span class="line">101011</span><br><span class="line">110110</span><br></pre></td></tr></table></figure>
<p>不考虑体积，最优解是拿4号物品，我们假定4号物品体积恰好大于整体体积，而1，2，3都可以降低体积到合适的大小，即，2，4为最优解，整体的解法考虑为，选出尽量少的物品使得价值高而体积小于背包容量。</p>
<p>构造一个dp，对于前i个物品在体积为j下要求的最大价值，这要求维护出当前的数字，对于hard1e9的时间空间是不够的。easy版就直接跑<span
class="math display">\[O(n\times
4e3)\]</span>即可，注意初始状态为(1&lt;&lt;14)-1，但是这样跑出来是过93%，哪里有问题？</p>
<p>一个可能的原因是0表示非法的同时也表示价值为0，想了半个小时，也没想到是为什么，要是有数据就好了。</p>
<p>官方题解是枚举答案，然后根据答案来选数，观察是否可以体积小于k</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2000</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> V = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; w[j]) == i) &#123;</span><br><span class="line">                V &amp;= v[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (V &lt;= k)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不得不说这个写法更简洁也更正确</p>
<p>hard显然我们需要优化枚举答案，只需要按位枚举即可，我们取当前位为1的取得越多，体积越小，因此，我们优先多选择当前价值为为1的使得体积尽可能的小。如果当前位取1，那么我们就抛弃所有当前位位0的值。就这样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">     </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">        q[<span class="number">0</span>].<span class="built_in">push</span>(&#123;w[i], v[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> ww = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="type">int</span> now = q[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; now; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> x = q[<span class="number">0</span>].<span class="built_in">front</span>();</span><br><span class="line">            q[<span class="number">0</span>].<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> ((x.y &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                q[<span class="number">1</span>].<span class="built_in">push</span>(x);</span><br><span class="line">                ww &amp;= x.x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q[<span class="number">0</span>].<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (ww &lt;= k) &#123;</span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">while</span> (!q[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                q[<span class="number">0</span>].<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q[<span class="number">1</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            q[<span class="number">0</span>].<span class="built_in">push</span>(q[<span class="number">1</span>].<span class="built_in">front</span>());</span><br><span class="line">            q[<span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
        <category>日常赛</category>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>newcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Xiaobai93D-E</title>
    <url>/2024/Xiaobai93D-E/article.html</url>
    <content><![CDATA[<h1 id="小白93">小白93</h1>
<h2 id="d-幻兽帕鲁_牛客小白月赛93-nowcoder.com"><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI0MDEvRA==">D-幻兽帕鲁_牛客小白月赛93
(nowcoder.com)<i class="fa fa-external-link-alt"></i></span></h2>
<span id="more"></span>
<h3 id="题意">题意</h3>
<p>在幻兽帕鲁中，不同的帕鲁能干不同的工作，现在我们要对帕鲁进行分类以便他们能够更好的进行压榨。</p>
<p>你有 <span class="math display">\[2^n\]</span>
只帕鲁，初始给每只帕鲁一个工号，并让帕鲁按 <span
class="math display">\[[0,2^n-1]\]</span> 工号的顺序排成一队。</p>
<p>当我们对区间 <span class="math display">\[[l,r]\]</span>
的帕鲁进行操作时，我们会对该区间的帕鲁按顺序进行临时编号 <span
class="math display">\[[0,r-l]\]</span> ，记 <span
class="math display">\[mid = \lfloor\frac{l +
r}{2}\rfloor\]</span>，我们将临时编号为偶数和奇数的帕鲁，分别按顺序置于区间
<span class="math display">\[[l,mid]\]</span> 和 <span
class="math display">\[[mid + 1,r]\]</span>
，并递归对这两个区间进行上述操作，直到区间长度为 <span
class="math inline">\(1\)</span> 。</p>
<p>现在我们对 <span class="math display">\[[0,2^n-1]\]</span>
的幻兽进行一次操作，然后给你 <span class="math inline">\(m\)</span>
次询问，每次询问 <span class="math inline">\(x\)</span>​
位置的帕鲁工号是多少？</p>
<h3 id="题解">题解</h3>
<p>简单的d题，感觉过的人少都是被吓得不敢去想题意了。实际上很简单，思考一下这个递归排序的实质，比较奇偶相当于比较最后一位是否为0，0则前，非零则后，然后每次递归相当于逻辑右移一位。本质上是倒着的二进制字典序。</p>
<p>于是，对排名向序号的反向映射可以表示为有多少个数在他前面，我们对二进制从低位枚举，i位为1则表示有(1&lt;&lt;(n-i-1)个帕努在他前面。不断二进制填满这个名次就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		ll x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(x)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(x &lt; (<span class="number">1ll</span>&lt;&lt;(n-i<span class="number">-1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">				x-= (<span class="number">1ll</span>&lt;&lt;(n-i<span class="number">-1</span>));</span><br><span class="line">				ans += (<span class="number">1ll</span>&lt;&lt;i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="e-奏绝_牛客小白月赛93-nowcoder.com"><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI0MDEvRQ==">E-奏绝_牛客小白月赛93
(nowcoder.com)<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="题意-1"><strong>题意：</strong></h3>
<p>你拥有一个黑之章和白之章构成的序列，你可以用它进行演奏。</p>
<p>对于一次演奏的区间，如果这个区间的两个端点一个为黑之章，一个为白之章，那么该次演奏将会产生该区间长度的影响值，否则该次演奏影响值为
0。</p>
<p>区间长度定义为左端点到右端点的距离，比如 i 到 i + 1 的距离为 1。</p>
<p>对于 m
次询问，你要求出对于每次询问的区间，你在其所有子区间演奏的影响值的和，结果对
998244353 取模。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvODI4MjEvRQ==">E-奏绝_牛客小白月赛93（重现赛）<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题解-1"><strong>题解</strong></h3>
<p><strong>不建议写这一题，非常不建议，我看题目写出三种cpp，没一个是跟题目意思一样的，特别是对长度得判定，不注意直接就是积</strong></p>
<p>奏绝，我直接肘击！</p>
<p>题目的意思是，对一段区间，两个端点不同，计算长度贡献值，否则为0，计算所有子区间贡献总和。我假题了半小时。有一个很版得做法是莫队，但官方题解似乎不是，这里贴出我写的莫队算法，还是比较简单的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y, id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Node&amp; x,<span class="type">const</span> Node&amp; y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.x/ blk != y.x /blk) <span class="keyword">return</span> x.x/blk &lt; y.x/blk;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(x.x != y.x) <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x.y &lt; y.y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sum1 += (s[x] == <span class="string">&#x27;1&#x27;</span>? x: <span class="number">0</span>) * c;</span><br><span class="line">	cnt1 += (s[x] == <span class="string">&#x27;1&#x27;</span>) * c;</span><br><span class="line">	sum2 += (s[x] == <span class="string">&#x27;0&#x27;</span>? x: <span class="number">0</span>) * c;</span><br><span class="line">	cnt2 += (s[x] == <span class="string">&#x27;0&#x27;</span>) * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateL</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[x]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">		ans += (sum2 - x * cnt2) * c% MOD;</span><br><span class="line">		ans = (ans + MOD) % MOD;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[x]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">		ans += (sum1 - x * cnt1) * c % MOD;</span><br><span class="line">		ans = (ans + MOD) % MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;&quot;!&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateR</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[x] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">		ans += (x * cnt1 - sum1) * c % MOD;</span><br><span class="line">		ans = (ans + MOD) % MOD;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[x] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">		ans += (x * cnt2 - sum2) * c % MOD;</span><br><span class="line">		ans = (ans + MOD) % MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;&quot;#&quot;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
        <category>日常赛</category>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>newcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>abc354</title>
    <url>/2024/abc354/article.html</url>
    <content><![CDATA[<h2 id="C-AtCoder-Magics"><a href="#C-AtCoder-Magics" class="headerlink" title="C - AtCoder Magics"></a><span class="exturl" data-url="aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfYw==">C - AtCoder Magics<i class="fa fa-external-link-alt"></i></span></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>高桥有 <script type="math/tex">N</script> 张纸牌，来自纸牌游戏 “AtCoder Magics”。其中的 <script type="math/tex">i</script> 张卡将被称为 <script type="math/tex">i</script> 张卡。每张卡都有两个参数：强度和成本。卡片 <script type="math/tex">i</script> 的强度为 <script type="math/tex">A_i</script> ，成本为 <script type="math/tex">C_i</script> 。</p>
<p>他不喜欢弱牌，所以他会弃掉它们。具体来说，他会重复下面的操作，直到无法再进行为止：</p>
<ul>
<li>选择两张牌 <script type="math/tex">x</script> 和 <script type="math/tex">y</script> ，即 <script type="math/tex">A_x > A_y</script> 和 <script type="math/tex">C_x < C_y</script> 。弃牌 <script type="math/tex">y</script> 。</li>
</ul>
<p>可以证明，当无法再进行操作时，剩下的牌的集合是唯一确定的。请找出这组牌。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><span id="more"></span>
<p>对双键值进行排序，然后判断当前的成本是否高于前面的就好，似乎这一题并不存在相同成本不同强度的淘汰数据较弱，所以注释掉也没关系</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x.y&gt;&gt;a[i].x.x,a[i].y = i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].y&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">	<span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> j = i;</span><br><span class="line">		<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[j].x.y &gt; mx) ans.<span class="built_in">push_back</span>(a[j].y);</span><br><span class="line">		t = <span class="built_in">max</span>(t, a[j].x.y);</span><br><span class="line">		<span class="comment">// while(j&lt;n &amp;&amp; a[j+1].x.x == a[j].x.x)&#123;</span></span><br><span class="line">		<span class="comment">// 	if(a[j].x.y &gt; mx) &#123;</span></span><br><span class="line">		<span class="comment">// 		// cout&lt;&lt;a[j].y&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// 		ans.push_back(a[j].y);</span></span><br><span class="line">		<span class="comment">// 	&#125;</span></span><br><span class="line">		<span class="comment">// 	t = max(t, a[j].x.y);</span></span><br><span class="line">		<span class="comment">// 	j++;</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		mx = <span class="built_in">max</span>(t,mx);</span><br><span class="line">		<span class="comment">// cout&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class="line">		i = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(ans));</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> idx: ans) cout&lt;&lt;idx&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-AtCoder-Wallpaper"><a href="#D-AtCoder-Wallpaper" class="headerlink" title="D - AtCoder Wallpaper"></a><span class="exturl" data-url="aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZA==">D - AtCoder Wallpaper<i class="fa fa-external-link-alt"></i></span></h2><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>AtCoder 的壁纸图案可以在 $xy$ (平面)上表示如下：</p>
<ul>
<li>该平面由以下三种线段划分：<ul>
<li><script type="math/tex">x = n</script> (其中 $n$ 为整数)</li>
<li><script type="math/tex">y = n</script> (其中 $n$ 为偶数)</li>
<li><script type="math/tex">x + y = n</script> (其中 $n$ 为偶数)</li>
</ul>
</li>
<li>每个区域都涂成黑色或白色。沿着其中一条线相邻的两个区域被涂成不同的颜色。</li>
<li>包含 <script type="math/tex">(0.5, 0.5)</script> 的区域被涂成黑色。</li>
</ul>
<p>下图显示了图案的一部分。</p>
<p><img src="https://s2.loli.net/2024/05/24/P6UY7DwTeN5OFy9.png" alt=""></p>
<p>给你整数 <script type="math/tex">A, B, C, D</script> 。考虑一个边平行于 <script type="math/tex">x</script> - 和 <script type="math/tex">y</script> - 轴的矩形，它的左下顶点在 <script type="math/tex">(A, B)</script> ，右上顶点在 $(C, D)$ 。计算该矩形内部涂黑区域的面积，并打印出该面积的两倍。</p>
<p>可以证明输出值将是一个整数。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>构造题，一个好的数学思维，构造模式是十分重要的，abc上就经常会出现这样的题。</p>
<p>对于该题来讲，我们观察到明显的周期重复，对一个2*4的小矩形图案的不断重复，因此我们只需要枚举该图案的某一格在选中的矩形中重复了多少次即可。</p>
<p>加上偏移量以确保两个数的正负号问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,d;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">2</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">            ll x1 = (a - j + <span class="number">3</span> + B)/<span class="number">4</span>, x2 = (c - j + <span class="number">3</span> + B)/<span class="number">4</span>;</span><br><span class="line">            <span class="type">int</span> coux = x2 - x1;</span><br><span class="line">            ll y1 = (b - i + <span class="number">1</span> + B)/<span class="number">2</span>, y2 = (d - i + <span class="number">1</span> + B)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> couy = y2 - y1;</span><br><span class="line">            ans += coux * couy * p[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Remove-Pairs-atcoder-jp"><a href="#E-Remove-Pairs-atcoder-jp" class="headerlink" title="E - Remove Pairs (atcoder.jp)"></a><span class="exturl" data-url="aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZQ==">E - Remove Pairs (atcoder.jp)<i class="fa fa-external-link-alt"></i></span></h2><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>高桥和青木正在玩一个使用 <script type="math/tex">N</script> 张卡片的游戏。 $￥$ 这张牌的正面写着 <script type="math/tex">A_i</script> ，背面写着 <script type="math/tex">B_i</script> 。最初， <script type="math/tex">N</script> 这张牌摆在桌上。高桥先出，两位玩家轮流进行以下操作：</p>
<ul>
<li>从桌上选择一对正面数字相同或背面数字相同的牌，然后从桌上拿走这两张牌。如果没有这样的一对牌，玩家就不能进行操作。</li>
</ul>
<p>最先无法进行操作的玩家输，另一名玩家赢。如果双方都以最佳方式出牌，谁会赢？</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>乍一看是一道非常困难的博弈题，实际尝试下来也确实如此。但是<script type="math/tex">N \leq 18</script>!</p>
<p>于是直接暴力位dp即可</p>
<p>但是这里需要注意一下状态转移，根据博弈论，我们可以知道只要下一状态存在先手必输则当前状态位先手必胜，我们用0表示必输，1表示必胜。同时很容易观察到，我们并不是从较小的卡片数到较高的卡片数枚举的，因此我们需要对当前枚举的两张卡通过当前状态进行限制。以保证从小状态向大状态转移（这也可以说显然的，因为必须保证有卡才能取卡）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;n;x++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> y=x<span class="number">+1</span>;y&lt;n;y++)&#123;</span><br><span class="line">				<span class="keyword">if</span>((i &gt;&gt; x &amp; <span class="number">1</span>) &amp;&amp; (i &gt;&gt; y &amp; <span class="number">1</span>) &amp;&amp;</span><br><span class="line">				 ((a[x].x==a[y].x) || (a[x].y == a[y].y)))&#123;</span><br><span class="line">					f[i] |= !f[i^(<span class="number">1</span>&lt;&lt;x)^(<span class="number">1</span>&lt;&lt;y)];</span><br><span class="line">					<span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;x&lt;&lt; &#x27; &#x27;&lt;&lt;y&lt;&lt;&#x27; &#x27;</span></span><br><span class="line">					<span class="comment">// 	&lt;&lt;(i^(1&lt;&lt;x)^(1&lt;&lt;y))&lt;&lt;&#x27; &#x27;&lt;&lt;f[i^(1&lt;&lt;x)^(1&lt;&lt;y)]&lt;&lt;endl;</span></span><br><span class="line">					<span class="comment">// cout&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]) cout&lt;&lt;<span class="string">&quot;Takahashi\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Aoki\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Useless-for-LIS-atcoder-jp"><a href="#F-Useless-for-LIS-atcoder-jp" class="headerlink" title="F - Useless for LIS (atcoder.jp)"></a><span class="exturl" data-url="aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZg==">F - Useless for LIS (atcoder.jp)<i class="fa fa-external-link-alt"></i></span></h2><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给你一个长度为 <script type="math/tex">N</script> 的整数序列 <script type="math/tex">A</script> 。</p>
<p>对于每个 <script type="math/tex">t = 1, 2, \dots, N</script> ，判断 <script type="math/tex">A_t</script> 是否包含在 <script type="math/tex">A</script> 的最长递增子序列中。</p>
<p>这里，当且仅当以下条件成立时， <script type="math/tex">A_t</script> 才包含在 $A$ 的最长递增子序列中：</p>
<ul>
<li><p>设 <script type="math/tex">L</script> 是 <script type="math/tex">A</script> 的最长递增子序列的长度。存在一个严格递增整数序列 <script type="math/tex">i = (i_1, i_2, \dots, i_L)  (i_1 < i_2 < \dots < i_ L)</script> ，其中每个元素都介于 <script type="math/tex">1</script> 与 <script type="math/tex">N</script> 之间，且满足以下所有条件：</p>
<ul>
<li><script type="math/tex">A_{i_1}<A_{i_2}<\dots<A _{i _L}</script> .</li>
<li><script type="math/tex">i_k = t</script> 为某个 <script type="math/tex">k (1 \leq k \leq L)</script> 。</li>
</ul>
</li>
</ul>
<p>给你 $T$ 个测试用例，请逐个求解。</p>
<p>什么是最长递增子序列？</p>
<p>序列 $A$ 的子序列是指从 $A$ 中提取一些元素而不改变顺序所得到的序列。</p>
<p>序列 $A$ 的最长递增子序列是 $A$ 的子序列，它以最大可能的长度严格递增。</p>
<h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>求不包含在样最长上升子序列中的数的下标集合</p>
<p>回顾以下LIS是如何求的，通过dp求解以当前这个数为结尾的LIS最长值</p>
<p>这个dp需要快速找到前面比他小的数当中的最大长度，很简单，我们只需要改变一下状态表示，并且通过线段树查询一下最大值即可。</p>
<p>可以很简单注意到对于这样一个dp，我们只需要正序和反序均做一下dp即可达成“判断该数是否存在于LIS”的目标。</p>
<p>最后，数据范围离散化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class="line">	rt-&gt;val = <span class="built_in">max</span>(l-&gt;val,r-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u,Node* tr)</span></span>&#123;</span><br><span class="line">	<span class="built_in">push_up</span>(tr+u,tr+(u&lt;&lt;<span class="number">1</span>),tr+ (u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> u,Node* tr)</span></span>&#123;</span><br><span class="line">	tr[u]=&#123;l,r&#125;;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;tr[u].val = <span class="number">0</span>; <span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(l,mid,u&lt;&lt;<span class="number">1</span>,tr); <span class="built_in">build</span>(mid<span class="number">+1</span>,r,u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr);</span><br><span class="line">	<span class="built_in">push_up</span>(u,tr);</span><br><span class="line">	<span class="comment">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> u,Node* tr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class="line">		<span class="keyword">return</span> tr[u].val;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> le = <span class="number">0</span>,ri = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;= mid) le = <span class="built_in">query</span>(l,r,u&lt;&lt;<span class="number">1</span>,tr);</span><br><span class="line">		<span class="keyword">if</span>(r &gt; mid) ri = <span class="built_in">query</span>(l,r,u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(le,ri);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c,<span class="type">int</span> u,Node* tr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class="line">		tr[u].val = c;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(x,c,u&lt;&lt;<span class="number">1</span>,tr);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">modify</span>(x,c,u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr);</span><br><span class="line">		<span class="built_in">push_up</span>(u,tr);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ves;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		ves.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(ves));</span><br><span class="line">	ves.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(ves)),ves.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ves.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		mp[ves[i]] = i<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>,tr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mx = <span class="built_in">query</span>(<span class="number">1</span>,mp[a[i]]<span class="number">-1</span>,<span class="number">1</span>,tr);</span><br><span class="line">		f[i] = mx<span class="number">+1</span>;</span><br><span class="line">		<span class="built_in">modify</span>(mp[a[i]],f[i],<span class="number">1</span>,tr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> maxx = <span class="built_in">query</span>(<span class="number">1</span>,n,<span class="number">1</span>,tr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>,tr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)&#123;</span><br><span class="line">		<span class="type">int</span> mx = <span class="built_in">query</span>(mp[a[i]]<span class="number">+1</span>,n,<span class="number">1</span>,tr);</span><br><span class="line">		rf[i] = mx<span class="number">+1</span>;</span><br><span class="line">		<span class="built_in">modify</span>(mp[a[i]],rf[i],<span class="number">1</span>,tr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cout&lt;&lt;maxx&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line">	<span class="comment">// 	cout&lt;&lt;f[i]&lt;&lt; &#x27; &#x27; &lt;&lt; rf[i]&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(f[i] + rf[i] - <span class="number">1</span> == maxx)&#123;</span><br><span class="line">			ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v: ans) cout&lt;&lt;v&lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-Select-Strings-atcoder-jp"><a href="#G-Select-Strings-atcoder-jp" class="headerlink" title="G - Select Strings (atcoder.jp)"></a><span class="exturl" data-url="aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1NC90YXNrcy9hYmMzNTRfZw==">G - Select Strings (atcoder.jp)<i class="fa fa-external-link-alt"></i></span></h2><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2>]]></content>
      <categories>
        <category>比赛</category>
        <category>日常赛</category>
        <category>atcoder</category>
      </categories>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>cf-edu165C</title>
    <url>/2024/cf-edu165C/article.html</url>
    <content><![CDATA[<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>有一种操作：选择数组中的一个元素，并用其邻近元素的值替换它。求经过k次操作数组累和的最小值。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9D">Problem - C - Codeforces<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>教育场的题，特别是c题总是相对简单（ps:也可能是因为少怪题和近期写的少了的缘故。）但是总是很有意义。考虑这一题。显然容易注意到k的数据范围是小于10的（可以暴搜:) 假的！），很容易想到用dp做法可以解。</p>
<p>但为什么不能采用别的解法呢？</p>
<p>考虑一种简单的贪心，即仅仅对最小值进行左右拓展。很容易证伪如k==1</p>
<blockquote>
<p>2,1,1,2,5</p>
</blockquote>
<p>显然这种情况对于第四个数字向右扩展是可行的而非对1进行操作。</p>
<p>注意到每次操作实际贡献的是相邻两个数字之间的差值，并且每次操作会改变三个数的相邻差值。不妨让我们试试差分与优先队列，我们将数组做两次差分，每次操作取其中最小值，这是可行的吗? 考虑这样一种情形，对于差分值有多个位置相同，我们应该修改哪一个位置使得差分数组的后续得修改操作能得到我们需要的最小值呢？显然，这样的操作需要更多信息而并非仅仅单纯的选择最小的差分值。</p>
<p>于是我们可以心安理得的考虑dp，状态表示简单表示如下：dpi,j表示前i个数字使用j次操作的最小值。</p>
<p>考虑状态转移，具体到我们的操作中来，注意到对于已经修改过的位置i再次进行操作是无意义的，这样的操作必然会导致不小于最优解，但在状态转移中取最小，可重，不漏。</p>
<blockquote>
<p>[x,a,b,c,y] -&gt; [x,x,x,x,y]-&gt;[x,x,y,y,y] 其中含有无意义的两步操作</p>
</blockquote>
<p>再次注意k特别小的特性，于是我们想到枚举i的前k个元素，考虑这个区间中每个j的每个状态转移过来（由i扩展到j和由j扩展到i）的最小和。</p>
<p>下面是具体的转移方法，注意一下边界问题，读者也可以按自己的喜好来确定如何转移。</p>
<blockquote>
<p>对于i，我们找到一个左边界ii，操作使得[ii+1,i]当中的数等于<script type="math/tex">a_k|k>ii \&\& k <= i</script>，因此所需操作数为i-ii-1</p>
</blockquote>
<p>最后注意一下答案不一定为操作k次。维护一下前缀和礼貌的减少一下时间复杂度。。。如果你想要更礼貌点，尝试与处理一下k长度内的最小值吧！但笔者比较懒，能ac干嘛优化：）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)f[i][j] = LLINF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i] = a[i] + pre[i<span class="number">-1</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=i<span class="number">-1</span>;ii&gt;=<span class="number">0</span> &amp;&amp; i-ii<span class="number">-1</span> &lt;= m;ii--) &#123;</span><br><span class="line">            <span class="type">int</span> t = i-ii<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=t;j&lt;=m;j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=ii<span class="number">+1</span>;k&lt;=i;k++) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j],f[ii][j-t] + a[k] * (i-ii));</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt; f[i][j]&lt;&lt;nline;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = LLINF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) ans = <span class="built_in">min</span>(ans,f[n][i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>思维题</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>思维题</tag>
        <tag>贪心</tag>
        <tag>状态转移</tag>
      </tags>
  </entry>
  <entry>
    <title>abc353</title>
    <url>/2024/abc353/article.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2FiYzM1My90YXNrcw==">abc353 (atcoder.jp)<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="C-Sigma-Problem"><a href="#C-Sigma-Problem" class="headerlink" title="C- Sigma Problem"></a><strong>C- Sigma Problem</strong></h2><span id="more"></span>
<p>第一个记录的abcC题</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于正整数 <script type="math/tex">x</script> 和 <script type="math/tex">y</script> ，定义 <script type="math/tex">f(x, y)</script> 为 <script type="math/tex">(x + y)$ 除以</script>10^8$ 的余数。</p>
<p>给你一个长度为 $N$ 的正整数序列 <script type="math/tex">A = (A_1, \ldots, A_N)</script> 。求下面表达式的值：</p>
<script type="math/tex; mode=display">\displaystyle \sum_{i=1}^{N-1}\sum_{j=i+1}^N f(A_i,A_j)$$​ .
### 题解

注意题目并非是完全模运算，注意到$N\times N\times A_i$刚刚好在longlong 边界上。并且$A_i\times A_i$ 最多减少一次Mod，我们只需要找出mod1e8的次数即可。

刚刚开始我想的是二分，但实际上对于

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 50000000 5000000 9999999 9999999 999999 999999 999999 </span><br></pre></td></tr></table></figure>



这样的数组是很难判断的，因为对于每一个数都只计算后面能跟他相加大于MOD的数（笔者写的时候突然注意到似乎如果更改为计算所有相加大于MOD的数，减去本身和本身再除以2就是正确的了），总之，这样的题解法很多。

我采用的是，双指针模拟一下，让这个相加大于模数的下标和本身下标取最大。

code

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=n;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j &amp;&amp; a[i] + a[j] &gt;= MOD) j--;</span><br><span class="line">		cnt += <span class="built_in">min</span>(n-i,n-j);</span><br><span class="line">		<span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum += a[i];</span><br><span class="line"></span><br><span class="line">	sum *= (n<span class="number">-1</span>);</span><br><span class="line">	<span class="comment">// cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;sum - cnt * MOD&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## **D - Another Sigma Problem**

### 题意

对于正整数 $$x$$ 和 $$y$$ ，定义 $$f(x, y)$$ 如下：

- 将 $$x$$ 和 $z$ 的十进制表示解释为字符串，并按此顺序连接，得到字符串 $$z$$ 。将 $$f(x, y)$$ 解释为十进制整数时，其值就是 $$z$$ 的值。

例如， $$f(3, 14) = 314$$ 和 $$f(100, 1) = 1001$$ 。

给你一个长度为 $N$ 的正整数序列 $$A = (A_1, \ldots, A_N)$$ 。求下面表达式取模 $998244353$ 的值：

$$\displaystyle \sum_{i=1}^{N-1}\sum_{j=i+1}^N f(A_i,A_j)$$​ .

### 题解

写了C顺便写D，这题反而比上一题简单，代数化一下函数，提一下公因子，计算一下公式就行，最后“前缀和”维护因子之一就行。

下面是代码code

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i].x;</span><br><span class="line">		<span class="type">int</span> t= a[i].x,s=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(t)&#123;</span><br><span class="line">			s++;</span><br><span class="line">			t/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i].y = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)&#123;</span><br><span class="line">		rep[i] = (rep[i<span class="number">+1</span>] + <span class="built_in">qmi</span>(<span class="number">10</span>,a[i].y)) % MOD;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;rep[i]&lt;&lt;&#x27; &#x27;; </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ans = (ans + (rep[i<span class="number">+1</span>] + (i<span class="number">-1</span>)) * a[i].x % MOD) % MOD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## **E - Yet Another Sigma Problem**

### 题意

对于字符串 $x$ 和 $y$ ，定义 $$f(x, y)$$ 如下：

- $$f(x, y)$$ 是 $$x$$ 和 $$y$$ 的最长公共前缀的长度。

给你一个由小写英文字母组成的 $N$ 字符串 $$(S_1, \ldots, S_N)$$ 。求以下表达式的值：

$$\displaystyle \sum_{i=1}^{N-1}\sum_{j=i+1}^N f(S_i,S_j)$$ .

### 题解

还是注意到同样的$O(N^2)$是超出时间复杂度的，所以可以直接抛弃字符串hax计算两两前缀的做法。直接考虑整体。

很容易联想到字符树trie，因为在建立这个数据结构时就已经合并了前缀，我们维护一下每个节点的字符串数量即可。然后组合数计算一下答案

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> last = <span class="number">-1</span> ,res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="type">int</span> ip = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;ip&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(!son[p][ip]) son[p][ip] = ++idx;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;s&lt;&lt; &quot;====&quot;&lt;&lt;last&lt;&lt; &#x27; &#x27; &lt;&lt; cnt[son[p][ip]]&lt;&lt;nline;</span></span><br><span class="line">		<span class="keyword">if</span>(last == <span class="number">-1</span>) last = cnt[son[p][ip]];</span><br><span class="line">		<span class="keyword">if</span>(cnt[son[p][ip]]!= last)&#123;</span><br><span class="line">			res += (last - cnt[son[p][ip]]) * i;</span><br><span class="line">			last = cnt[son[p][ip]];</span><br><span class="line">		&#125;</span><br><span class="line">		cnt[son[p][ip]]++;</span><br><span class="line">		p = son[p][ip];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt[p]!=<span class="number">1</span>)&#123;</span><br><span class="line">		res +=(cnt[p] - <span class="number">1</span>)*s.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;s[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ans += <span class="built_in">build</span>(s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## **F - Tile Distance**

### 题意

#### 问题陈述

瓷砖铺在一个坐标平面上。有两种瓦片：尺寸为 $$1\times1$$ 的小瓦片和尺寸为 $$K\times K$$ 的大瓦片，它们按以下规则摆放：

- 对于每一对整数 $(i,j)$ ，正方形 $$\lbrace(x,y)\mid i\leq x\leq i+1\wedge j\leq y\leq j+1\rbrace$$ 要么包含在一块小方砖中，要么包含在一块大方砖中。
    - 如果 $$\left\lfloor\dfrac iK\right\rfloor+\left\lfloor\dfrac jK\right\rfloor$$ 是偶数，则它包含在一个小方格中。
    - 否则，它被包含在一个大瓦片中。

瓦片包括它们的边界，没有两个不同的瓦片有正的交集区域。

例如，当 $K=3$ 时，瓦片的布局如下：

![](https://s2.loli.net/2024/05/12/OKQh3GVaeSbIloP.png)

高桥开始于坐标平面上的点 $$(S_x+0.5,S_y+0.5)$$ 。

他可以重复下面的动作任意多次：

- 选择一个方向（上、下、左或右）和一个正整数 $$n$$ 。向该方向移动 $n$ 个单位。

每次他从一张牌移动到另一张牌时，必须支付 $1$ 的过路费。

求高桥到达点 $$(T_x+0.5,T_y+0.5)$$​ 所需的最小通行费。

### 题解

首先简化一下问题，就是求一个经过瓷砖数最少时的瓷砖数-1。

然后考虑哈密顿距离，可以发现，我们经过的瓷砖数显然是小于哈密顿距离的。然后针对题目数据较大，我们考虑一下走单纯走直线时的最短路。

可以发现，不断走最大瓷砖是最优的。                  

![70275E94F5C12B97C927177CEB804E4C](https://s2.loli.net/2024/05/12/aXPzgwCJq4LlNIA.jpg)

即上图所示的路径是最短的。

显然我们需要划分一下，定义一下中间这个走的最长的是从大瓷砖开始到最后一个大瓷砖结束，则经过的大瓷砖数为：</script><p>distance = \frac{d_s-d_a}{k} \times 2 -1</p>
<script type="math/tex; mode=display">
其中定义$$d_s$$为走过直线长度，$$d_a$$ 为两端长度，保证$$d_s - d_a \equiv k$$​

可以看出，除去两边，实际上我们是在以k为方格边长的情况下对哈密顿距离乘了一个常数即$$\frac{2}{k}$$，再减去$$1</script><p>但这样还是复杂了，以上只考虑了直线的情况，当我们涉及直线折角处会更为复杂，我们需要一个更简单解法。</p>
<p>根据上面的解释，我们发现在大瓷砖之间四向向转移所需要的成本为2，而当k==1时，我们的最短距离就等于哈密顿距离，当k&gt;=2时，在小瓷砖之间的转移也是2，也就是说，除去极端情况，对小瓷砖到小瓷砖是不需要的（除非起点终点在小瓷砖）在大瓷砖之间转移总是更优的。</p>
<p>最后的结果形式上是切比雪夫距离</p>
<p>于是，计算从起点到大瓷砖终点到大瓷砖之间最多16种可能性的距离，取最小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">long</span> k,sx,sy,tx,ty;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">	cin&gt;&gt;sx&gt;&gt;sy;</span><br><span class="line">	cin&gt;&gt;tx&gt;&gt;ty;</span><br><span class="line">	<span class="type">long</span> ans=LLINF;</span><br><span class="line">	<span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">long</span> x=sx/k,y=sy/k,X=tx/k,Y=ty/k,c=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>((x+y)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;(X+Y)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;x==X&amp;&amp;y==Y)ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(sx-tx)+<span class="built_in">abs</span>(sy-ty));</span><br><span class="line">		<span class="keyword">if</span>((x+y)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dx[i]==<span class="number">-1</span>)c+=sx-x*k<span class="number">+1</span>;</span><br><span class="line">			<span class="keyword">if</span>(dx[i]==<span class="number">1</span>)c+=k*(<span class="type">long</span>)(x<span class="number">+1</span>)-sx;</span><br><span class="line">			<span class="keyword">if</span>(dy[i]==<span class="number">-1</span>)c+=sy-y*k<span class="number">+1</span>;</span><br><span class="line">			<span class="keyword">if</span>(dy[i]==<span class="number">1</span>)c+=k*(<span class="type">long</span>)(y<span class="number">+1</span>)-sy;</span><br><span class="line">			<span class="keyword">if</span>(k!=<span class="number">1</span>)x+=dx[i],y+=dy[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((X+Y)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dx[j]==<span class="number">-1</span>)c+=tx-X*k<span class="number">+1</span>;</span><br><span class="line">			<span class="keyword">if</span>(dx[j]==<span class="number">1</span>)c+=k*(<span class="type">long</span>)(X<span class="number">+1</span>)-tx;</span><br><span class="line">			<span class="keyword">if</span>(dy[j]==<span class="number">-1</span>)c+=ty-Y*k<span class="number">+1</span>;</span><br><span class="line">			<span class="keyword">if</span>(dy[j]==<span class="number">1</span>)c+=k*(<span class="type">long</span>)(Y<span class="number">+1</span>)-ty;</span><br><span class="line">			<span class="keyword">if</span>(k!=<span class="number">1</span>)X+=dx[j],Y+=dy[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">1</span>)c=<span class="built_in">abs</span>(x-X)+<span class="built_in">abs</span>(y-Y);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">long</span> d=<span class="built_in">min</span>(<span class="built_in">abs</span>(x-X),<span class="built_in">abs</span>(y-Y));</span><br><span class="line">			c+=d*(<span class="type">long</span>)<span class="number">2</span>;</span><br><span class="line">			c+=(<span class="built_in">abs</span>(x-X)-d)*(<span class="type">long</span>)<span class="number">3</span>/(<span class="type">long</span>)<span class="number">2</span>;</span><br><span class="line">			c+=(<span class="built_in">abs</span>(y-Y)-d)*(<span class="type">long</span>)<span class="number">3</span>/(<span class="type">long</span>)<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> c+=<span class="built_in">max</span>(<span class="built_in">abs</span>(x-X),<span class="built_in">abs</span>(y-Y))*(<span class="type">long</span>)<span class="number">2</span>;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,c);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-Merchant-Takahashi"><a href="#G-Merchant-Takahashi" class="headerlink" title="G - Merchant Takahashi"></a><strong>G - Merchant Takahashi</strong></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>AtCoder 王国有 $N$ 个城镇：城镇 $1$ 、 $2$ 、 $\ldots$ 、 $N$ 。从 $i$ 镇到 $j$ 镇，必须支付 $C \times |i-j|$ 日元的过路费。</p>
<p>商人高桥正在考虑参加 $M$ 个或更多即将到来的市场。</p>
<p>$i$ /-市场 <script type="math/tex">(1 \leq i \leq M)</script> 由一对整数 <script type="math/tex">(T_i, P_i)</script> 描述，其中市场在城镇 <script type="math/tex">T_i</script> 举行，如果他参加将赚取 <script type="math/tex">P_i</script> 日元。</p>
<p>对于所有 <script type="math/tex">1 \leq i < M</script> ， <script type="math/tex">i</script> 次市场在 <script type="math/tex">(i+1)</script> 次市场开始之前结束。他移动的时间可以忽略不计。</p>
<p>他从 <script type="math/tex">10^{10^{100}}</script> 日元开始，最初在 <script type="math/tex">1</script> 镇。通过优化选择参与哪些市场以及如何移动，确定他可以获得的最大利润-。</p>
<p>形式上，如果他在 <script type="math/tex">M</script> 个市场后获得最大资金额，那么 <script type="math/tex">10^{10^{100}} + X</script> 就是他的最终资金额。求 <script type="math/tex">X</script> 。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然的dp问题，如果你看不出来这是个dp问题建议你看一看<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NTk4ODQ2MjI=">再看最著名的 NP 问题之 TSP 旅行商问题 - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span>，这篇blog，其中详细阐述了什么是np问题，几乎所有的np问题都是dp解的（因为他们找到多项式解是极其困难的）。记住这些问题，并在相似问题上找到他们的痕迹就是看是否为dp问题的关键。</p>
<p>详细到这一题，很简单的状态表示为</p>
<script type="math/tex; mode=display">
f_i:到i城的最大profit</script><p>状态转移为：</p>
<script type="math/tex; mode=display">
f_i=max_{j=1}^n \left\{f_j-|i-j|\times C +p\right\}</script><p>对绝对值正负进行分类</p>
<script type="math/tex; mode=display">
f_i=max_{j=1}^i \left\{f_j-i\times C+j\times C +p\right\}\\
f_i=max_{j=i}^n \left\{f_j-j\times C+i\times C +p\right\}</script><p>提出取最大中的常数项：</p>
<script type="math/tex; mode=display">
f_i=max_{j=1}^i \left\{f_j+j\times C \right\}+p-i\times C\\
f_i=max_{j=i}^{n} \left\{f_j-j\times C \right\}+p+i\times C</script><p>接下来就很简单了，维护最大值即可（使用两个线段树）,官方题解是没有使用动态转移数组的，实际上在下面的代码中很多数组都是不必要的，只是为了方便读者理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(Node* rt, Node* l,Node* r)</span></span>&#123;</span><br><span class="line">	rt-&gt;val = <span class="built_in">max</span>(l-&gt;val,r-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u,Node* tr)</span></span>&#123;</span><br><span class="line">	<span class="built_in">push_up</span>(tr+u,tr+(u&lt;&lt;<span class="number">1</span>),tr+ (u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> u,Node* tr)</span></span>&#123;</span><br><span class="line">	tr[u]=&#123;l,r&#125;;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;tr[u].val = -LLINF; <span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(l,mid,u&lt;&lt;<span class="number">1</span>,tr); <span class="built_in">build</span>(mid<span class="number">+1</span>,r,u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr);</span><br><span class="line">	<span class="built_in">push_up</span>(u,tr);</span><br><span class="line">	<span class="comment">// cout&lt;&lt;tr[u].val&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> u,Node* tr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)&#123;</span><br><span class="line">		<span class="keyword">return</span> tr[u].val;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid = tr[u].l +tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> le = -LLINF,ri = -LLINF;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;= mid) le = <span class="built_in">query</span>(l,r,u&lt;&lt;<span class="number">1</span>,tr);</span><br><span class="line">		<span class="keyword">if</span>(r &gt; mid) ri = <span class="built_in">query</span>(l,r,u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(le,ri);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c,<span class="type">int</span> u,Node* tr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x)&#123;</span><br><span class="line">		tr[u].val = c;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(x,c,u&lt;&lt;<span class="number">1</span>,tr);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">modify</span>(x,c,u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr);</span><br><span class="line">		<span class="built_in">push_up</span>(u,tr);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>,tr1);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>,tr2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">modify</span>(<span class="number">1</span>,c,<span class="number">1</span>,tr1);</span><br><span class="line">	<span class="built_in">modify</span>(<span class="number">1</span>,-c,<span class="number">1</span>,tr2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;t[i]&gt;&gt;p[i];</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">query</span>(<span class="number">1</span>,t[i],<span class="number">1</span>,tr1);</span><br><span class="line">		<span class="type">int</span> r = <span class="built_in">query</span>(t[i],n,<span class="number">1</span>,tr2);</span><br><span class="line">		<span class="comment">// cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">		<span class="type">int</span> mx = <span class="built_in">max</span>(l+p[i]-t[i]*c,r+p[i]+t[i]*c);</span><br><span class="line">		f[t[i]] = mx;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;t[i]&lt;&lt; &#x27; &#x27; &lt;&lt;f[t[i]]&lt;&lt;nline;</span></span><br><span class="line">		<span class="built_in">modify</span>(t[i],f[t[i]] + t[i] * c,<span class="number">1</span>,tr1);</span><br><span class="line">		<span class="built_in">modify</span>(t[i],f[t[i]] - t[i] * c,<span class="number">1</span>,tr2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans =<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>思维题</category>
        <category>模运算</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>思维题</tag>
        <tag>模运算</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu蓝桥5_19</title>
    <url>/2024/luogu%E8%93%9D%E6%A1%A55_19/article.html</url>
    <content><![CDATA[<h2 id="B-停车场"><a href="#B-停车场" class="headerlink" title="B. 停车场"></a>B. 停车场</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTA5P2NvbnRlc3RJZD0xNzQxNTU=">P10509 停车场 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>你有一片空地。这片空地可以视作一个一个 𝑛×𝑛 的正方形。空地外一圈为墙壁，你无法拆除它们。</p>
<p>现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 1×1的正方形，且正方形的每条边与墙壁平行或者垂直。</p>
<p>每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。</p>
<p>下图为 𝑛=4 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png" alt="img"></p>
<p>请问 𝑛=2023 下最多能安排多少个停车位？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题真是一道神奇而又复杂的题目，我想如果国赛有这种题，可能刚开始心态就会爆炸</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Bhc3RlLzE3cndqZmN6">云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class="fa fa-external-link-alt"></i></span></p>
<p>洛谷官方对这题做出了非常详细的解释，但赛时证明是在过于繁琐，如果真的蓝桥，万一真有这种情况建议直接放掉这题。</p>
<p>这题的其中一种构造方法非常像“minecraft”里的鱼骨挖矿法即下图第二种</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xjhz5uvs.png" alt="img"></p>
<p>直接构造可得</p>
<p>答案为(2022+2021<em>(674</em>2-1)+673<em>2</em>2+3)</p>
<h2 id="D-方差"><a href="#D-方差" class="headerlink" title="D. 方差"></a>D. 方差</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTExP2NvbnRlc3RJZD0xNzQxNTU=">P10511 方差 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>小 S 认为数学很简单，于是小 R 想要考考她。</p>
<p>小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 <code>l r b</code>，表示 $a<em>l,a</em>{l+1},\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。</p>
<p>现在，小 R 有 $q$ 个问题。形如 <code>l r</code>，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。</p>
<p>由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\cdot s^2\bmod 998244353$。可以证明 $(r-l+1)^2\cdot s^2$ 一定是整数。</p>
<p>作为小 S 的好朋友，你能帮帮她吗？</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>推导一下公式发现结果是</p>
<script type="math/tex; mode=display">(r-l+1) \sum_{i=l}^{r-l+1}a_i^2 - sum^2</script><p>预处理前缀和和前缀平方和，二分查找即可端点所在区间即可。</p>
<p>但一定需要注意多次取模，经过一个小时的鏖战，鉴定为取模题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		cin&gt;&gt;seg[i].l&gt;&gt;seg[i].r&gt;&gt;seg[i].v;</span><br><span class="line">		seg[i].l %= MOD;</span><br><span class="line">		seg[i].r %= MOD;</span><br><span class="line">		seg[i].v %= MOD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort(seg+1,seg+1+m);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		segs[i] = segs[i<span class="number">-1</span>] + ((((seg[i].r - seg[i].l  + <span class="number">1</span>) %MOD + MOD) %MOD) * seg[i].v) % MOD;</span><br><span class="line">		segs[i] %= MOD;</span><br><span class="line">		segs2[i] = segs2[i<span class="number">-1</span>] + (((((seg[i].r - seg[i].l + <span class="number">1</span>) %MOD + MOD)%MOD) * seg[i].v %MOD)</span><br><span class="line">				* seg[i].v) % MOD;</span><br><span class="line">		segs2[i] %= MOD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;=m;i++) cout&lt;&lt;segs[i]&lt;&lt;&#x27; &#x27;&lt;&lt;segs2[i]&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="type">int</span> li = <span class="built_in">upper_bound</span>(seg<span class="number">+1</span>,seg<span class="number">+1</span>+m,(Segment)&#123;l,<span class="number">0</span>,<span class="number">0</span>&#125;) - seg - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> ri = <span class="built_in">upper_bound</span>(seg<span class="number">+1</span>,seg<span class="number">+1</span>+m,(Segment)&#123;r,<span class="number">0</span>,<span class="number">0</span>&#125;) - seg - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;&quot;###&quot;&lt;&lt;li&lt;&lt; &#x27; &#x27; &lt;&lt; ri&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(li== ri)</span><br><span class="line">    	&#123;</span><br><span class="line">      		cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">      		<span class="keyword">continue</span>;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> msum = ((segs[ri<span class="number">-1</span>] - segs[li])%MOD + MOD) % MOD;</span><br><span class="line">		msum %= MOD;</span><br><span class="line">		<span class="type">int</span> rsum = (((r - seg[ri].l + <span class="number">1</span>) % MOD + MOD) % MOD * seg[ri].v) % MOD;</span><br><span class="line">		rsum %= MOD;</span><br><span class="line">		<span class="type">int</span> lsum = ((seg[li].r - l + <span class="number">1</span> + MOD) % MOD * seg[li].v) % MOD;</span><br><span class="line">		lsum %= MOD;</span><br><span class="line">		<span class="type">int</span> msum2 = ((segs2[ri<span class="number">-1</span>] - segs2[li])%MOD + MOD) %MOD;</span><br><span class="line">		msum %=MOD;</span><br><span class="line">		<span class="type">int</span> rsum2 = ((((r - seg[ri].l + <span class="number">1</span>)%MOD + MOD) % MOD * seg[ri].v) % MOD</span><br><span class="line">				* seg[ri].v) % MOD;</span><br><span class="line">		rsum2%=MOD;</span><br><span class="line">		<span class="type">int</span> lsum2 = ((((seg[li].r - l + <span class="number">1</span>) %MOD + MOD) % MOD * seg[li].v) % MOD</span><br><span class="line">				*seg[li].v) %MOD;</span><br><span class="line">		lsum2 %=MOD;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;&quot;---&quot;&lt;&lt;lsum &lt;&lt; &#x27; &#x27;&lt;&lt;msum&lt;&lt; &#x27; &#x27;&lt;&lt;rsum&lt;&lt;endl;</span></span><br><span class="line">		<span class="type">int</span> sum = lsum + msum % MOD + rsum %MOD;</span><br><span class="line">		sum %=MOD;</span><br><span class="line">		<span class="type">int</span> sum2 = lsum2 + msum2 % MOD + rsum2 %MOD;</span><br><span class="line">		sum2%=MOD;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;&quot;####&quot;&lt;&lt;sum&lt;&lt; &#x27; &#x27;&lt;&lt; sum2&lt;&lt;endl;</span></span><br><span class="line">		cout&lt;&lt;(((((r-l<span class="number">+1</span>) %MOD + MOD) % MOD * sum2) % MOD -</span><br><span class="line">							(sum*sum) %MOD) % MOD +MOD) %MOD&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-序列合并"><a href="#E-序列合并" class="headerlink" title="E. 序列合并"></a>E. 序列合并</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTEyP2NvbnRlc3RJZD0xNzQxNTU=">https://www.luogu.com.cn/problem/P10512?contestId=174155<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 𝑛的非负整数序列 {<script type="math/tex">𝑎_𝑛</script>}，你可以进行 𝑘次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。</p>
<p>形式化地，一次操作中，你选择一个下标 𝑖<em>i</em>（1≤𝑖&lt;𝑛1≤<em>i</em>&lt;<em>n</em>），然后把原序列变成<script type="math/tex">{a_1,a_2,⋯,a_iora_{i+1},a_{i+2},⋯,a_n}</script>。</p>
<p>求 𝑘次操作后所有数按位与的最大值。</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>首先想到我们需要优先选高位。但此时注意到，对高位的选择也会影响到低位，我们必须考虑一个方式找到一个优的解使得答案最大</p>
<p>注意到合并的数本身代表了一个区间范围内的数，k次操作相当于选出了n-k个区间，如果要求答案为x则区间内的数并集为x，枚举每一个数显然是不现实的，但是我们可以通过二进制枚举来达到效果。</p>
<p>要记得从高到低枚举，因为每次记录t到ans中，我们实际限制了后面的取值。</p>
<p>我觉得比取模题简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">29</span>;~i;i--)&#123;</span><br><span class="line">		<span class="type">int</span> t = ans | (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> x = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			x |= a[i];</span><br><span class="line">			<span class="keyword">if</span>((x &amp; t) == t) cnt++,x=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt &gt;= n - k) &#123;</span><br><span class="line">			ans = t;</span><br><span class="line">			<span class="comment">// cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-括号"><a href="#F-括号" class="headerlink" title="F. 括号"></a>F. 括号</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTEzP2NvbnRlc3RJZD0xNzQxNTU=">https://www.luogu.com.cn/problem/P10513?contestId=174155<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 <code>(</code> 和 <code>)</code> 构成。</p>
<p>她会对其做 $m$ 次操作，操作有两种类型：</p>
<ol>
<li><code>1 l r</code>，她会翻转 $l$ 到 $r$ 的括号，即 <code>(</code> 变 <code>)</code>，<code>)</code> 变 <code>(</code>。</li>
<li><code>2 l r</code>，她想知道区间 $\left[ l,r\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。</li>
</ol>
<p>圆认为以下的括号序列是合法的：</p>
<ol>
<li><p>空序列是一个合法序列。</p>
</li>
<li><p>如果 <code>A</code> 是一个合法序列，则 <code>(A)</code>  也是一个合法序列。</p>
</li>
<li><p>如果 <code>A</code> 和 <code>B</code> 都是合法序列，则 <code>AB</code> 也是一个合法序列。</p>
</li>
</ol>
<p>圆认为，序列 $a$ 的子序列是满足 $1\le i<em>1&lt;i_2&lt;···&lt;i_k \le n$ 的序列 $[a</em>{i<em>1},a</em>{i<em>2},…a</em>{i_k}]$。</p>
<p>由于操作太多了，她算不过来，请你帮帮她吧。</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>洛谷真的要吓死我了，第六题线段树</p>
<p>对整个子串建立线段树，节点中维护当前区间左括号和右括号的的数量，合并左右节点即</p>
<script type="math/tex; mode=display">ans=左边括号序列+右边括号序列+横跨中间的括号序列</script><p>如何维护交换这一操作呢？</p>
<p>我们对每个节点维护两个不同的节点数据，一个是现在的，一个是假设翻转的。在交换时就交换这两个数据即可。（也可以都拆开成一个一个变量，也是可以的）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> l,r,ans;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> x=<span class="number">0</span>,<span class="type">int</span> y=<span class="number">0</span>,<span class="type">int</span> z=<span class="number">0</span>)&#123;l=x,r=y,ans=z;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;<span class="type">int</span> tag;node t1,t2;&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">merge</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="built_in">min</span>(x.l,y.r);</span><br><span class="line">    <span class="keyword">return</span> &#123;x.l+y.l-cnt,x.r+y.r-cnt,x.ans+y.ans+cnt&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;t[p].t1=<span class="built_in">merge</span>(t[ls].t1,t[rs].t1);t[p].t2=<span class="built_in">merge</span>(t[ls].t2,t[rs].t2);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushson</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;<span class="built_in">swap</span>(t[p].t1,t[p].t2);t[p].tag^=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;<span class="keyword">if</span>(!t[p].tag) <span class="keyword">return</span>;<span class="built_in">pushson</span>(ls),<span class="built_in">pushson</span>(rs);t[p].tag=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> t[p].t<span class="number">2.</span>r=t[p].t<span class="number">1.l</span>=(s[l]==<span class="string">&#x27;(&#x27;</span>),t[p].t<span class="number">2.l</span>=t[p].t<span class="number">1.</span>r=(s[l]==<span class="string">&#x27;)&#x27;</span>),<span class="built_in">void</span>();</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);<span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> s,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class="keyword">return</span> <span class="built_in">pushson</span>(p);<span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=s) <span class="built_in">modify</span>(ls,l,mid,s,e);<span class="keyword">if</span>(mid&lt;e) <span class="built_in">modify</span>(rs,mid<span class="number">+1</span>,r,s,e);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> s,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=s&amp;&amp;r&lt;=e) <span class="keyword">return</span> t[p].t1;<span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(e&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(ls,l,mid,s,e);</span><br><span class="line">    <span class="keyword">if</span>(s&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,s,e);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(ls,l,mid,s,e),<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,s,e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;s<span class="number">+1</span>;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> op,l,r;cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r).ans&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-考试"><a href="#G-考试" class="headerlink" title="G.考试"></a>G.考试</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTE0P2NvbnRlc3RJZD0xNzQxNTU=">https://www.luogu.com.cn/problem/P10514?contestId=174155<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 名同学去参加考试，考试有 $m$ 道题。</p>
<p>每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。</p>
<p>考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>数学题。。。 懒得打公式了，如下</p>
<p><img src="https://s2.loli.net/2024/05/27/6HONVPcKW8Ao75x.png" alt="image-20240527221944431"></p>
<p>预处理阶乘，快速幂分母时间复杂度为log(m)+n</p>
<p>处理分子时间复杂度为mlog(n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res * a % mod;</span><br><span class="line">		a = a * a % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = infac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">		fac[i] = fac[i<span class="number">-1</span>] *i % MOD;</span><br><span class="line">		infac[i] = infac[i<span class="number">-1</span>] * <span class="built_in">qmi</span>(i,MOD<span class="number">-2</span>,MOD) % MOD;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;fac[i]&lt;&lt;&#x27; &#x27; &lt;&lt;infac[i]&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i], mx= <span class="built_in">max</span>(mx,a[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mx + k &gt; n) &#123;cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> inv = <span class="built_in">qmi</span>(<span class="built_in">qmi</span>(fac[n] % MOD * infac[n-k] %MOD, m, MOD),MOD<span class="number">-2</span>,MOD);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> factor = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		factor = factor * fac[n-a[i]] % MOD * infac[n-k-a[i]] % MOD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;factor*inv % MOD&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="H-转圈、按钮P4861"><a href="#H-转圈、按钮P4861" class="headerlink" title="H. 转圈、按钮P4861"></a>H. 转圈、按钮P4861</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNTE1P2NvbnRlc3RJZD0xNzQxNTU=">https://www.luogu.com.cn/problem/P10515?contestId=174155<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>小 $\delta$ 喜欢转圈圈。</p>
<p>他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \times m$，他现在站在第一个格子上。</p>
<p>接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。</p>
<p>求最终被小 $\delta$ 踩到过的格子的数量。由于小 $\delta$ 有很多圈圈，所以他会问你很多次。</p>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>这题和P4861撞了，所以我干脆贴这题了</p>
<p>根据欧拉定理<script type="math/tex">a^{\phi(p)}= 1 (modp)</script></p>
<p>因此<script type="math/tex">\phi(p)</script>一定是答案的倍数，我们只需要枚举它的因子即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a,ll b,ll mod = MOD)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res * a % mod;</span><br><span class="line">		a = a * a % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> y? <span class="built_in">gcd</span>(y,x%y): x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_phi</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = x;</span><br><span class="line">	<span class="keyword">if</span>(!(x&amp;<span class="number">1</span>)) res &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i*i&lt;=x; i+= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">			res -= res /i;</span><br><span class="line">			<span class="keyword">while</span>(x % i == <span class="number">0</span>) x/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">1</span>) res -= res / x;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">gcd</span>(n,m)!=<span class="number">1</span>)<span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s go Blue Jays!&quot;</span>);<span class="comment">//无解</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="built_in">get_phi</span>(n);<span class="comment">//得到phi</span></span><br><span class="line">        <span class="type">int</span> mm=p;</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;(i*i)&lt;=mm;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mm%i)<span class="keyword">continue</span>;</span><br><span class="line">            pri[++tot]=i;</span><br><span class="line">            <span class="keyword">while</span>(mm%i==<span class="number">0</span>)&#123;</span><br><span class="line">                mm/=i;</span><br><span class="line">                tim[tot]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mm!=<span class="number">1</span>)&#123;</span><br><span class="line">            pri[++tot]=mm;</span><br><span class="line">            tim[tot]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ss=<span class="number">1</span>,qq=p;</span><br><span class="line">        <span class="keyword">while</span>(ss&lt;=tot)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tim[ss];i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">qmi</span>(m,qq/pri[ss],n)==<span class="number">1</span>)qq/=pri[ss];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ss++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;qq&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
        <category>模拟赛</category>
        <category>蓝桥模拟</category>
      </categories>
      <tags>
        <tag>luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>cf-edu165D</title>
    <url>/2024/cf-edu165D/article.html</url>
    <content><![CDATA[<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>爱丽丝和鲍勃正在商店里玩游戏。商店里有 <script type="math/tex">n</script> 件商品；每件商品有两个参数： <script type="math/tex">a_i</script> （爱丽丝的物品价格）和 <script type="math/tex">b_i</script> （鲍勃的物品价格）。</p>
<p>爱丽丝希望选择一个商品子集（可能是空）并购买它们。之后，Bob 会执行以下操作：</p>
<ul>
<li>如果爱丽丝购买的物品少于 <script type="math/tex">k</script> ，则鲍勃可以免费拿走所有物品；</li>
<li>否则，他会免费拿走爱丽丝购买的<script type="math/tex">k</script> 个物品（由鲍勃选择是哪个 <script type="math/tex">k</script> 个物品），至于其他选择的物品，鲍勃会从爱丽丝那里购买，并为 $i$ -个物品支付 <script type="math/tex">b_i</script>。</li>
</ul>
<p>爱丽丝的利润等于 <script type="math/tex">\sum\limits_{i \in S} b_i - \sum\limits_{j \in T} a_j</script> ，其中<script type="math/tex">S</script> 是鲍勃从爱丽丝处购买的物品集， <script type="math/tex">T</script> 是爱丽丝从商店购买的物品集。换句话说，爱丽丝的利润就是鲍勃支付给她的金额和她购买商品所花费的金额之间的差额。</p>
<p>爱丽丝希望自己的利润最大化，而鲍勃希望爱丽丝的利润最小化。您的任务是计算在爱丽丝和鲍勃都采取最优行动的情况下爱丽丝的利润。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE5NjkvcHJvYmxlbS9E">Problem - D - Codeforces<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>注意到，Bob在选择免费的时候显然是直接免费最大的<script type="math/tex">b_i</script>，于是，Alice总是希望选出的物品中价值最高的物品的成本尽可能的小，而剩下的物品的<script type="math/tex">b_i - a_i</script>尽可能的大。</p>
<p>先考虑极端情况，对单个物品，无论该物品是怎样的情况都不是会选。显然推广到当n&gt;count(<script type="math/tex">a_i<b_i</script>)时，不选都是最好的。显然，这仅仅是不考虑利润为负数的情况。于是我们假定必须选物品，并将结果与0取最大。</p>
<p>对于一个物品<script type="math/tex">i</script>，我们可以证明在<script type="math/tex">a_i < b_i</script>时该物品是必选的吗？如果我们选了这个物品：</p>
<ol>
<li><p>并未被免费，则b并非为被选中物品（数量大于k）的前k+1大显然，我们应该选择它</p>
</li>
<li><p>被免费了，则b为被选中物品（数量大于k）的前k+1大,我们需要考虑对Alice来说，如果一个物品加进来就被免费了（b为前k+1大）且希望利润最大，我们应该淘汰掉本来免费当中b最大的，即应该去除b最大的物品。考虑到去除的b与加进b中的差值可能大于该物品本身利润，因此是无法确定是否选择的。</p>
</li>
</ol>
<p>综上，无法确定在<script type="math/tex">a_i < b_i</script>时该物品是必选，对这个不等式的反也成立的物品也成立。</p>
<p>注意到在2中我们说如果一个物品加进来就被免费了，则b为前k+1大。这说明，对于整体来说存在一个b该b以上的物品全免费，该b以下的物品计算利润。我们可以排序后枚举这个值模拟一下上述过程，与答案取最大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">id</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) id[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[x] != b[y]) <span class="keyword">return</span> b[x] &gt; b[y];</span><br><span class="line">        <span class="keyword">return</span> a[x] &lt; a[y];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;n;i++) cout&lt;&lt;a[id[i]]&lt;&lt;&#x27; &#x27;&lt;&lt;b[id[i]]&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;nline;</span></span><br><span class="line"></span><br><span class="line">    ll s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(a[id[i]]);</span><br><span class="line">        s1 += a[id[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class="line">            s2 += b[id[i]] - a[id[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, s2 - s1);</span><br><span class="line">        <span class="keyword">if</span> (b[id[i]] &gt; a[id[i]])&#123;</span><br><span class="line">            s2 -= b[id[i]] - a[id[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(&#123;a[id[i]], id[i]&#125;);</span><br><span class="line">        s1 += a[id[i]];</span><br><span class="line">        s1 -= *(--s.<span class="built_in">end</span>());</span><br><span class="line">        s.<span class="built_in">erase</span>(--s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>博弈论</tag>
        <tag>不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我用Typora——Typora与其他markdown的比较</title>
    <url>/2023/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%94%A8Typora%E2%80%94%E2%80%94Typora%E4%B8%8E%E5%85%B6%E4%BB%96markdown%E7%9A%84%E6%AF%94%E8%BE%83/article.html</url>
    <content><![CDATA[<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>​    Typora是我一直在使用的markdown编辑器，对比起其他的markdown编辑器来说，==Obsidian==虽然有更加具有逻辑性的文档之间的双向链接和git式的设定，==Vscode==，==Sublime==则是Markdown插件构成的markdown编辑器，Typora更加纯粹和统一。具体表现在，它的使用逻辑非常简洁，仅仅只是文档编辑器，除了markdown的即时渲染之外，并没有过多独特的特性，在编辑上的极致优化使得它受众广泛。</p>
<span id="more"></span>
<h2 id="Typora的Markdown语法"><a href="#Typora的Markdown语法" class="headerlink" title="Typora的Markdown语法"></a>Typora的Markdown语法</h2><p>​    Typora中的Markdown语法分为严格和非严格两种语法格式，这里建议使用严格语法格式，提高文档的可移植性并且养成良好的习惯。</p>
<p>​    但由于各个平台之间的的Markdown语法标准并不统一，比较常见的有ZhihuMarkdown，CSDNMarkdown和GithubMarkdown，在不同的Markdown语法中，对文字的渲染有所不同，主要的差异集中在<strong>Latex语法格式</strong>。</p>
<p>​    因此，如果你有一份md文本，在release时tag自己的环境是一个不错的选择。</p>
<blockquote>
<p>ps: 根据互联网信息，Markdown语法截至24/7/21仍然未完成统一，这是一片未被规范化的蓝海，希望尽快规范化</p>
</blockquote>
<!--more-->
<h3 id="代码块语法"><a href="#代码块语法" class="headerlink" title="代码块语法"></a>代码块语法</h3><p>​    代码块几乎支持所有语言的高亮，并且支持对解释性语言的即时运行</p>
<h3 id="Html、js、css"><a href="#Html、js、css" class="headerlink" title="Html、js、css"></a>Html、js、css</h3><p>​    Typora实际上是一个浏览器控制样式的文本编辑工具，因此在typora的配置文件中，可以通过修改css达到统一样式控制的效果，甚至可以全部用html编写实现一个web页面。</p>
<p>​    通过html也可以实现索引官方的方式是 <code>[这样]()</code></p>
<h2 id="Typora中的Mermaid，Latex"><a href="#Typora中的Mermaid，Latex" class="headerlink" title="Typora中的Mermaid，Latex"></a>Typora中的Mermaid，Latex</h2><p>​    Markdown语法格式中的两个接近标准化的工具Latex，Mermaid，前者侧重于学术理论，后者侧重于图像绘制、文档整理。Latex的格式渲染以及宏包功能更强大，Mermaid更利于编写。二者都具有强大的功能和实用性。个人认为MD文档的特色主要就在于即时渲染，索引结构、对图表绘制的支持。</p>
<p>​    但值得注意的是Mermaid中的Fontawesome 为v5版本，而latest version为v6，因此<strong>Typora并未bundle Fontawesome</strong>。因此无法使用fa: fa-xxx表示图标。</p>
<h2 id="Typora中的媒体"><a href="#Typora中的媒体" class="headerlink" title="Typora中的媒体"></a>Typora中的媒体</h2><p>​    Typora支持插入图片，视频，音频。但总的来讲，对一个md文档，图片占用的频率是最大的。基于此，Typora对上传图片做了优化，基于Picgo和图床对图片进行了上传功能的实现，具体配置方法为：</p>
<ol>
<li>以ssms图床为例<span class="exturl" data-url="aHR0cHM6Ly9zbS5tcy8=">Image Upload - SM.MS - Simple Free Image Hosting<i class="fa fa-external-link-alt"></i></span></li>
<li>到ssms官网注册张航并拿到apikey</li>
<li>填入picgo插件的配置文件</li>
<li><img src="https://s2.loli.net/2024/07/21/JY243QnhxmFZLtR.png" alt="配置图"></li>
</ol>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;picBed&quot;: &#123;</span><br><span class="line">    &quot;current&quot;: &quot;smms&quot;,</span><br><span class="line">    &quot;smms&quot;: &#123;</span><br><span class="line">      &quot;token&quot;: &quot;xxx&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;picgoPlugins&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>测试并运行</li>
</ol>
<h2 id="Typora的文档保存机制"><a href="#Typora的文档保存机制" class="headerlink" title="Typora的文档保存机制"></a>Typora的文档保存机制</h2><p>​    当Typora保存一个文档时通常会在本地保存多个文档不同时间节点的副本，并建立可恢复的索引，这样的措施虽然占用了一些空间，但是从我自己体验的角度来说，他帮助我恢复了多个因各种原因丢失的文档，搭配everything使用，几乎可以避免掉盘之外的数据丢失</p>
<h2 id="Typora的个性化主题"><a href="#Typora的个性化主题" class="headerlink" title="Typora的个性化主题"></a>Typora的个性化主题</h2><p>​    Typora在Github上有许多用户自定义的主题，我个人简单使用的是Github的官方主题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    对不需要太多功能的md文档编写具有很强的优势，如果不喜欢Obsidian的逻辑，不适应复杂的功能设计，可以使用Typora，它的程序设计逻辑与Word，Notebility很相似，最初拿来只做非常简单的工作，然后因为各种需求逐渐加深使用的功能。即使在程序设计的思想上没有使用如git，文件索引这种现代化的思想，但在编写上的巅峰造极也成就了Typora。</p>
<h2 id="一些比较实用的不在Typora文档中的使用技巧"><a href="#一些比较实用的不在Typora文档中的使用技巧" class="headerlink" title="一些比较实用的不在Typora文档中的使用技巧"></a>一些比较实用的不在Typora文档中的使用技巧</h2><ol>
<li><p>通过html标签扩展typora的显示格式</p>
<p>如<code>&lt;details&gt;&lt;/details&gt;</code>标签可以显示一个展开栏，做错题本时很好用</p>
</li>
<li><p>一个很常见的Typora插件，更新了typora的显示格式，内置思维导图与类似python的格式提醒typora_plugin</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29iZ25haWwvdHlwb3JhX3BsdWdpbg==">obgnail/typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具 (github.com)<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
<hr>
<p>待更新</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>编辑器</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Markdown</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2024/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%A0%E9%A2%981/article.html</url>
    <content><![CDATA[<h1 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h1><p>给定一个字符串，求包含ACCEPT但不包含WA且长度大于k的子串数量。</p>
<h1 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h1><p>子序列自动机，一个我较少写的算法（ps:可能是用到了没意识到），mark。。。</p>
<p>子序列自动机的基本概念是用二维数组保存对于i位置 j字符第一次出现的位置为nxt[i][j]，通过这种方式来维护字串ACCEPT和子串WA的子序列位置。</p>
<p>这是一个很容易理解，很多人没有给它命名的算法。该题的答案就是对于每个以i结尾的字符串i，计算后一个“WA”，“A”与后一个“ACCEPT”中的“A”的上一位合法字符串长度累和。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n) nxt[i][j]=n;</span><br><span class="line">            <span class="keyword">else</span> nxt[i][j]=nxt[i<span class="number">+1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=n) nxt[i][s[i]-<span class="string">&#x27;A&#x27;</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_pos</span><span class="params">(<span class="type">int</span> st,string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> first=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first) st=nxt[st][ch-<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> st=nxt[st<span class="number">+1</span>][ch-<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        first=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(st==n) <span class="keyword">return</span> st;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_next</span>();</span><br><span class="line">    string ac=<span class="string">&quot;ACCEPT&quot;</span>,wa=<span class="string">&quot;WA&quot;</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> r1=<span class="built_in">get_pos</span>(i,ac),r2=<span class="built_in">get_pos</span>(i,wa);</span><br><span class="line">        r1=<span class="built_in">max</span>(r1,i+k<span class="number">-1</span>);</span><br><span class="line">        ans=ans+<span class="built_in">max</span>(r2-r1,<span class="number">0ll</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>子序列自动机</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>子序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>思维题1</title>
    <url>/2024/%E6%80%9D%E7%BB%B4%E9%A2%98%E4%B9%A0%E9%A2%981/article.html</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>题意：给一个数字字符串，要求按相对序构建不带前导零的偶数，求这些数字的多重集的大小</p>
<h1 id="题解">题解</h1>
<p>题解：维护两个值，cnt，ans，cnt表示当前能构造出的不带前导零的数字的多重集size，ans表示偶数多重集size。处理前导零的思维是，cnt所代表的多重集中不含0这个数字，也就保证了cnt在计算过程中的不含前导零，具象到代码中则是在s[i]=='0'时，将cnt-1，而ans保持相同计算。cnt-&gt;ans，cnt在每一位上的计算非常简单不再赘述，即ans=(ans+cnt+1)%MOD,cnt=(cnt*2+1)%MOD。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            ans=(ans+cnt<span class="number">+1</span>)%MOD;</span><br><span class="line">            cnt=(cnt*<span class="number">2</span>)%MOD;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            cnt=(cnt*<span class="number">2</span><span class="number">+1</span>)%MOD;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans=(ans+cnt<span class="number">+1</span>)%MOD;</span><br><span class="line">            cnt=(cnt*<span class="number">2</span><span class="number">+1</span>)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题并不难，但我陷入了错误的贡献法思想，如果你想看，如下。</p>
<p>对于每一个偶数计算它的贡献值为<span
class="math inline">\(2^{i-1}\)</span>，对于每一个0计算它的贡献为<span
class="math inline">\(-2^{n-i}\)</span>，这样的错误在于，0的贡献并不准确，同时计算了奇数的前导零数量。虽然说应该可以修正这一点，但这样就繁琐了。。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>三种操作系统模拟软件使用手册</title>
    <url>/2024/%E4%B8%89%E7%A7%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/article.html</url>
    <content><![CDATA[<h1 id="三种操作系统简单模拟使用手册"><a href="#三种操作系统简单模拟使用手册" class="headerlink" title="三种操作系统简单模拟使用手册"></a>三种操作系统简单模拟使用手册</h1><h2 id="可运行程序图标"><a href="#可运行程序图标" class="headerlink" title="可运行程序图标"></a>可运行程序图标</h2><p><span class="exturl" data-url="aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBcC1lblk3Y2tMQU5ncEJUVnZOSlhHS2ktM3RSWnc=">https://1drv.ms/u/s!Ap-enY7ckLANgpBTVvNJXGKi-3tRZw<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://s2.loli.net/2024/05/25/rRF47xevIZApJO1.png" alt="image-20240525143542993"></p>
<span id="more"></span>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>程序提供了三种安装形式。</p>
<h3 id="exe模式"><a href="#exe模式" class="headerlink" title="exe模式"></a>exe模式</h3><p>第一种为exe模式，在该模式下，整体程序表现为一个exe文件单文件，点开即可启动，但值得注意的的是，这种方式启动需要主机上环境变量中配置好1.8版本以上的jre环境，否则无法启动。详细配置jre参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuamF2YS5jb20vemgtQ04vZG93bmxvYWQvbWFudWFsLmpzcA==">Java官网<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="JAR模式"><a href="#JAR模式" class="headerlink" title="JAR模式"></a>JAR模式</h3><p>第二种模式为jar模式，在该模式下，整个程序包作为一个jar文件表示，可通过java -jar直接调用，也可以通过ide导入为库调用</p>
<!--more-->
<h3 id="install安装包模式"><a href="#install安装包模式" class="headerlink" title="install安装包模式"></a>install安装包模式</h3><p>第三种模式为install安装包模式，这是最推荐的一种安装方式，但较为耗费内存，在该模式下会调用一个安装脚本自动配置运行环境，选择程序安装目录即可安装。</p>
<h2 id="卸载方式"><a href="#卸载方式" class="headerlink" title="卸载方式"></a>卸载方式</h2><p>通过前两种安装方式安装的程序可直接通过删除对应文件卸载，第三种安装方式请运行安装目录下的unins000.exe文件脚本并删除对应的快捷方式。</p>
<h2 id="程序使用指南"><a href="#程序使用指南" class="headerlink" title="程序使用指南"></a>程序使用指南</h2><h3 id="开源协议窗口"><a href="#开源协议窗口" class="headerlink" title="开源协议窗口"></a>开源协议窗口</h3><p><img src="https://s2.loli.net/2024/05/25/FUodMlsAgf75OE2.png" alt="image-20240525143707804"></p>
<p>该界面为程序运行启动第一个窗口，根据创建程序时所使用的第三方库创建，符合开源软件协议而显示，请忽略该窗口。</p>
<h3 id="导航菜单界面"><a href="#导航菜单界面" class="headerlink" title="导航菜单界面"></a>导航菜单界面</h3><p><img src="https://s2.loli.net/2024/05/25/9wMmaFXxNAiBypv.png" alt="image-20240525143849896"></p>
<p>该界面为程序主题界面，可通过界面导航到三个算法界面</p>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p><img src="https://s2.loli.net/2024/05/25/ITFwqptEnl1Seka.png" alt="image-20240525144036276"></p>
<p>该界面可实现生产者消费者业务功能</p>
<p>使用方式为：</p>
<ol>
<li>按照程序显示按钮进行操作，请勿输入未指定的，空数据。</li>
</ol>
<p>1.0.1 版本常见问题为：</p>
<ol>
<li>该窗口为单例模式实现，由于系统垃圾管理与多线程设计，该窗口只能打开一次，第二次打开会导致无反应。</li>
</ol>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>   <img src="https://s2.loli.net/2024/05/25/yJD8xRevhCt3A6i.png" alt="image-20240525144551258"></p>
<p>该界面为银行家算法界面，可实现银行家算法的功能与设计</p>
<p>使用方式为：</p>
<ol>
<li>给定总进程与总资源数</li>
<li>设定进程与资源矩阵，请勿对不同进程设定不同的avaliable矩阵</li>
<li>是否继续请求</li>
</ol>
<p>1.0.1版本可能遇到的问题：</p>
<ol>
<li>设定过多进程与资源数导致无法输入</li>
<li><img src="https://s2.loli.net/2024/05/25/RxZEQ7APFjNoOHL.png" alt="image-20240525145256829"></li>
</ol>
<h3 id="调度算法模拟"><a href="#调度算法模拟" class="headerlink" title="调度算法模拟"></a>调度算法模拟</h3><p><img src="https://s2.loli.net/2024/05/25/V4QyC1j2gBNGPv8.png" alt="image-20240525144538081"></p>
<p>调度算法模拟可实现六种算法的计算各种时间并可视化运行顺序等业务功能</p>
<p><img src="https://s2.loli.net/2024/05/25/UrwAdqCO6xNtkBf.png" alt="image-20240525144654678"></p>
<p>六种调度算法全称分别是</p>
<ol>
<li>先到先执行</li>
<li>非抢占式短作业优先</li>
<li>最短剩余时间优先（抢占式最短作业优先）</li>
<li>非抢占式优先级优先</li>
<li>抢占式优先级优先</li>
<li>时间片轮转算法</li>
</ol>
<p>使用方法为：</p>
<ol>
<li>输入每个进程的前四列信息</li>
<li>选择算法</li>
<li>点击计算</li>
</ol>
<p>1.0.1版本可能遇到的问题：</p>
<ol>
<li>请勿设置相同进程号</li>
<li>请勿设置小数时间片轮转或设置为0</li>
<li>给定的完成时间，周转时间，等待时间将被忽略</li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
        <category>文档</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>文档</tag>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title>数学距离问题1</title>
    <url>/2024/%E6%95%B0%E5%AD%A6%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%981/article.html</url>
    <content><![CDATA[<h2 id="题意">题意：</h2>
<p>给一个国际象棋中的“象”，但每次只能走一格，给N个点</p>
<p>计算总和 <span
class="math inline">\(\displaystyle\sum_{i=1}^{N-1}\displaystyle\sum_{j=i+1}^N
\text{dist}(P_i, P_j)\)</span>​ 。</p>
<span id="more"></span>
<h2 id="题解">题解：</h2>
<p>注意到实际上这样的走法将整个棋盘以<span
class="math display">\[x+y\]</span>的奇偶划分为了二分图（更准确的讲，两个图），并且每两个可达点之间的最短距离公式如下：
<span class="math display">\[
dist(p_i,p_j) = max(|p_i.x - p_j.x|, |p_i.y-p_j.y|)
\]</span> 即两个点之间的切比雪夫距离。</p>
<p>证明如下，对于任意两个<span
class="math inline">\(x+y\)</span>奇偶性相同的顶点而言，设起始点为<span
class="math inline">\((x,y)\)</span>，目的点为<span
class="math inline">\((xx,yy)\)</span>设dx&lt;dy即<span
class="math inline">\(dist(p_i,p_j) = |p_i.y-p_j.y|\)</span>。</p>
<p><span class="math inline">\(xx=x+dx,yy=y+dy\)</span>，则有<span
class="math inline">\(dx = a-b，a+b=dy\)</span>，根据定义可知<span
class="math inline">\(dy=yy-y\)</span>。</p>
<p>由以上公式,且x,y的奇偶性相同可知xx为在dx&lt;dy下的所有可达点的横坐标。相反则同理，因此切比雪夫距离成立。</p>
<p>详细参考<span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9nZW9tZXRyeS9kaXN0YW5jZS8=">距离 - OI
Wiki (oi-wiki.org)<i class="fa fa-external-link-alt"></i></span></p>
<p>如果你看懂了OIWiki中对切比雪夫定理的描述，以及其证明，并有坐标变换的基础，应该明白，切比雪夫距离是可以与曼哈顿距离相互转化的（仅仅切换了坐标系，即y=x函数为横坐标，y=-x函数为纵坐标。该说法很不完善，详细请看ioWiki，此处仅作简单说明，可以构造原坐标系函数y=x+b,x=y+a，则(a/2,b/2)为新坐标系下的坐标，读者可以尝试画图自己证明一下并不是很难）</p>
<p>上图(1,4) -&gt; (1,3)</p>
<p>于是题目变为了求n个点的哈密顿距离之和，很经典的题。</p>
<p>由于曼哈顿距离是横纵坐标的距离和，我们只看单个坐标。</p>
<p><img src="D:/talk-temp-document/1159472899/nt_qq/nt_data/Pic/2024-04/Ori/831c358c475935b97351ba39f7cf0fa9.png" alt="831c358c475935b97351ba39f7cf0fa9" style="zoom:25%;" /></p>
<p>coding。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((a[i].x+a[i].y) %<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            bx[<span class="number">1</span>][++cn[<span class="number">1</span>]] = a[i].x + a[i].y,by[<span class="number">1</span>][cn[<span class="number">1</span>]] = a[i].y - a[i].x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bx[<span class="number">0</span>][++cn[<span class="number">0</span>]] = a[i].x + a[i].y,by[<span class="number">0</span>][cn[<span class="number">0</span>]] = a[i].y - a[i].x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(bx[<span class="number">0</span>]<span class="number">+1</span>,bx[<span class="number">0</span>]<span class="number">+1</span>+cn[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">sort</span>(bx[<span class="number">1</span>]<span class="number">+1</span>,bx[<span class="number">1</span>]<span class="number">+1</span>+cn[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">sort</span>(by[<span class="number">0</span>]<span class="number">+1</span>,by[<span class="number">0</span>]<span class="number">+1</span>+cn[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">sort</span>(by[<span class="number">1</span>]<span class="number">+1</span>,by[<span class="number">1</span>]<span class="number">+1</span>+cn[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k =<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++) &#123;</span><br><span class="line">        <span class="type">int</span> sum1 =<span class="number">0</span> ,sum2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn[k];i++) &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;bx[k][i]&lt;&lt;&#x27; &#x27;&lt;&lt;by[k][i]&lt;&lt;endl;</span></span><br><span class="line">            ans += (i<span class="number">-1</span>) * (bx[k][i]+by[k][i]) - sum1-sum2;</span><br><span class="line">            sum1 += bx[k][i];</span><br><span class="line">            sum2 += by[k][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans/<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>思维题</tag>
        <tag>坐标系转换</tag>
        <tag>几何问题</tag>
      </tags>
  </entry>
  <entry>
    <title>树上最短回文问题</title>
    <url>/2024/%E6%A0%91%E4%B8%8A%E5%9B%9E%E6%96%87%E9%97%AE%E9%A2%98/article.html</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给定一棵树，给出m个查询，要求判断每个查询给出的a,b之间的最短路顶点权值是否回文？</p>
<span id="more"></span>
<h2 id="题解">题解</h2>
<p>不想看回文的读者请跳转到“真的题解”</p>
<p>看到回文，回顾回文！下面以数组为例子，求最长回文字符串。</p>
<p>回文暴力：对于i,暴力向两边分奇偶扩展，找最长回文长度</p>
<p>回文小技巧：对每个字符中间以及开头结尾加一个useless字符，比如‘#’,即“a”变为“#a#”，“bb”变为“#b#b#”这样避免了奇偶判断，并且回文的左半边直接变成了原本回文字符串的长度，你也可以自己构造（ofcourse自己构造的更好，只要你知道特性即可。</p>
<p>回文哈希二分：对于i，从前从后hax，二分回文长度。</p>
<p>二分如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(ull h[], ull l, ull r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++) p[i] = p[i<span class="number">-1</span>] * P;</span><br><span class="line">    <span class="type">int</span> t =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s,s!=<span class="string">&quot;END&quot;</span>) &#123;</span><br><span class="line">        n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        n *= <span class="number">2</span>;</span><br><span class="line">        s.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = s[i / <span class="number">2</span>];</span><br><span class="line">            s[i - <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="string">&#x27;#&#x27;</span> + s;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;s&lt;&lt;nline;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(!i) ph[i] = s[i];<span class="keyword">else</span> ph[i] = ph[i<span class="number">-1</span>] * P + s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;~i;i--)<span class="keyword">if</span>(i==n<span class="number">-1</span>) rh[i] = s[i];<span class="keyword">else</span> rh[i] = rh[i<span class="number">+1</span>] * P + s[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            ull r = <span class="built_in">min</span>(i - <span class="number">1</span>, n - i);</span><br><span class="line">            <span class="keyword">if</span> (ans &gt;= r || <span class="built_in">get</span>(ph, i - ans, i - <span class="number">1</span>) != <span class="built_in">get</span>(rh, n - (i + ans) + <span class="number">1</span>, n - i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (ans &lt;= r &amp;&amp; <span class="built_in">get</span>(ph, i - ans, i - <span class="number">1</span>) == <span class="built_in">get</span>(rh, n - (i + ans) + <span class="number">1</span>, n - i)) ans ++ ;</span><br><span class="line">            ans -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case &quot;</span> &lt;&lt; ++t&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题解要开始加速了！</p>
<p>首先意识到，重复的判断当前的i中心最大回文串是一种暴力的解法，因为解出的数据并未利用。可以理解的是对于以求出的回文长度，我们只需要判断是否存在更大的回文长度，这样可以优化二分，但并不完全。下面是直接优化<span
class="math inline">\(log_2n\)</span>的解法！</p>
<p>注意到（数学噩梦词），判断扩展的回文是O(1)，时间复杂度，回文长度只能更长而非更短。因此，最多判断n次回文。因此，记录回文长度并不断更新它即可！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ull ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">  ull r = <span class="built_in">min</span>(i - <span class="number">1</span>, n - i);</span><br><span class="line">  <span class="keyword">if</span> (ans &gt;= r || <span class="built_in">get</span>(h1, i - ans, i - <span class="number">1</span>) != <span class="built_in">get</span>(h2, n - (i + ans) + <span class="number">1</span>, n - i)) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">while</span> (ans &lt;= r &amp;&amp; <span class="built_in">get</span>(h1, i - ans, i - <span class="number">1</span>) == <span class="built_in">get</span>(h2, n - (i + ans) + <span class="number">1</span>, n - i)) ans ++ ;</span><br><span class="line">  ans -- ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一种回文做法总算是有名字了，即对朴素判断是否回文的非hax优化。通常叫它，马拉车算法。（ps：这个算法我陆陆续续看到过好多次，但是每一次都需要到看题解的地步，或许是我没有自己推导出来过，导致没记住。。。也许是因为很少有题目涉及他。。</p>
<p>简单说一说，该算法维护两个值：1. c 回文子串的中心位置 2. R
回文子串的最后位置。以及辅助数组w，记录以i为中心的最长回文长度。（注意我们添加的#会影响w，注意维护w的合法）</p>
<p>整个该算法的重点在于：“回文对称”！</p>
<figure>
<img
src="https://pic1.zhimg.com/v2-11f96d39d9648b7c146e49cdceb0854c_r.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>即，当我们想知道i的回文长度，首先看i对当前R所代表的回文子串的镜像长度。</p>
<p>若i+w[i_mirror]大于等于R,则暴力扩展R,并更新c。</p>
<p>若i-w[i_mirror]&gt;=0即i_mirror的回文子串碰到了边界，则中心扩展i</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 马拉车算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String T = <span class="built_in">preProcess</span>(s);</span><br><span class="line">    <span class="type">int</span> n = T.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span>[] P = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; i) &#123;</span><br><span class="line">            P[i] = Math.<span class="built_in">min</span>(R - i, P[i_mirror]);<span class="comment">// 防止超出 R</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P[i] = <span class="number">0</span>;<span class="comment">// 等于 R 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> (T.<span class="built_in">charAt</span>(i + <span class="number">1</span> + P[i]) == T.<span class="built_in">charAt</span>(i - <span class="number">1</span> - P[i])) &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">        <span class="keyword">if</span> (i + P[i] &gt; R) &#123;</span><br><span class="line">            C = i;</span><br><span class="line">            R = i + P[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   \\代码source :https:<span class="comment">//zhuanlan.zhihu.com/p/70532099</span></span><br></pre></td></tr></table></figure>
<h2 id="真的题解">真的题解</h2>
<p>上面讲了一串，最后还得是哈！希！，字符串，哈！希！</p>
<p>最短路，那就求求lca，倍增ortarjanor重链刨分，你可以使用任何你想用的。</p>
<p>注意到对任意a,b找出字符串然后做字符串hax判断不现实（暴力找出字符串最大<span
class="math display">\[n^2\]</span>）注意到，对整个路径的长度是很容易求出来的，因而，可以通过倍增找到中间字符直接计算hax子串。就是这么简单！小白月赛！淦！</p>
<p>但应该如何计算正逆序的hax值呢？显然对树的所有串建个hax会爆空间，但对多个串交织在一起该如何建立hax数组呢？笔者在这一刻小脑控制大脑，直接重工业ds，树链刨分在这一刻取得了他应有的荣光，将树问题转为了一个链式问题。</p>
<p>但实际上这么做虽然可行，但没有这个必要。直接hax减就好了。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[a].<span class="built_in">pb</span>(b);</span><br><span class="line">    e[b].<span class="built_in">pb</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>%mod;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; v: e[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u])<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line">        ph[v]=(ph[u]*P%MOD+(s[v]-<span class="string">&#x27;a&#x27;</span><span class="number">+1</span>))%MOD;</span><br><span class="line">        rh[v]=(rh[u]+p[depth[v]<span class="number">-1</span>]*(s[v]-<span class="string">&#x27;a&#x27;</span><span class="number">+1</span>)% MOD)%MOD;</span><br><span class="line"></span><br><span class="line">        f[v][<span class="number">0</span>] = u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">            f[v][i] = f[f[v][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">dfs1</span>(v);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v] &gt; mx) &#123;</span><br><span class="line">            mx = siz[v];hs[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u = <span class="number">1</span>, <span class="type">int</span> t = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    len[t] ++;</span><br><span class="line">    top[u] = t;</span><br><span class="line">    <span class="keyword">if</span>(siz[u] == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(hs[u],t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: e[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=hs[u]&amp;&amp;v!=fa[u]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[a] != top[b]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[top[a]] &lt; depth[top[b]])<span class="built_in">swap</span>(a,b);</span><br><span class="line">        a = fa[top[a]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++) p[i] = (p[i<span class="number">-1</span>] * P) % MOD;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">    depth[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;fa[i];</span><br><span class="line">        <span class="keyword">if</span>(fa[i]) <span class="built_in">add</span>(i,fa[i]);</span><br><span class="line">        <span class="keyword">else</span> fa[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ph[<span class="number">1</span>]=s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span><span class="number">+1</span>,rh[<span class="number">1</span>]=s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span><span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>();<span class="built_in">dfs2</span>();</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        lc = <span class="built_in">lca</span>(a,b);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> f=<span class="built_in">lca</span>(a,b);</span><br><span class="line">        <span class="type">int</span> p1=((rh[a]-rh[fa[f]]*<span class="built_in">qmi</span>(p[depth[f]<span class="number">-1</span>],MOD<span class="number">-2</span>,MOD)%MOD)+MOD) %MOD;</span><br><span class="line">        <span class="type">int</span> p2=(ph[b]-ph[f]*p[depth[b]-depth[f]]%MOD+MOD)%MOD;</span><br><span class="line">        <span class="type">int</span> ans1=(p1*(p[depth[b]-depth[f]])%MOD+p2)%MOD;</span><br><span class="line">        p1=(rh[b]-rh[fa[f]]+MOD)%MOD*<span class="built_in">qmi</span>(p[depth[f]<span class="number">-1</span>],MOD<span class="number">-2</span>,MOD)%MOD;</span><br><span class="line">        p2=(ph[a]-ph[f]*p[depth[a]-depth[f]]%MOD+MOD)%MOD;</span><br><span class="line">        <span class="type">int</span> ans2=(p1*(p[depth[a]-depth[f]])%MOD+p2)%MOD;</span><br><span class="line">        cout&lt;&lt;(ans1==ans2?<span class="string">&quot;YES\n&quot;</span>:<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        cout&lt;&lt;f&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;ans1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;nline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>图论中的回文问题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树问题</tag>
        <tag>哈希算法</tag>
      </tags>
  </entry>
  <entry>
    <title>由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估</title>
    <url>/2024/%E7%94%B1RSA%E5%88%B0ECC%E6%B5%85%E8%B0%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E5%87%A0%E7%A7%8D%E4%BF%A1%E6%81%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E5%92%8C%E8%AF%84%E4%BC%B0/article.html</url>
    <content><![CDATA[<p>于江西理工大学信息安全课程的论文综述</p>
<p>学术，未发表，Miarcl<br>下载连接：<span class="exturl" data-url="aHR0cDovL2Jsb2cua2Vib2UuY24vdXBsb2Fkcy/nlLFSU0HliLBFQ0PmtYXosIjpnZ7lr7nnp7DlhazpkqUt56eB6ZKl5a+G56CB57O757uf4oCU4oCU5bi46KeB5Yeg56eN5L+h5oGv5Yqg5a+G566X5rOV5a6e546w5q+U6L6D5ZKM6K+E5LywLnBkZg==">http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf<i class="fa fa-external-link-alt"></i></span></p>
<p>感谢母校对我的指导</p>
<p><div class="pdf-container" data-target="<a" data-height="href=http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf>http://blog.keboe.cn/uploads/由RSA到ECC浅谈非对称公钥-私钥密码系统——常见几种信息加密算法实现比较和评估.pdf</a>"></div>]]></content>
      <categories>
        <category>学术</category>
        <category>综述</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>Miracl</tag>
        <tag>加密算法</tag>
        <tag>ECC</tag>
      </tags>
  </entry>
  <entry>
    <title>MindSpore专题</title>
    <url>/2024/special_subject/MindSpore/MindSpore%E5%AD%A6%E4%B9%A0%E7%9B%AE%E5%BD%95/article.html</url>
    <content><![CDATA[<h1 id="MindSpore-Studying-By-Windows-And-Ubuntu"><a href="#MindSpore-Studying-By-Windows-And-Ubuntu" class="headerlink" title="MindSpore Studying By Windows And Ubuntu"></a>MindSpore Studying By Windows And Ubuntu</h1><p>文档编写采用Typora，须获得更好观看体验请自行clone本仓库</p>
<h2 id="初级教程"><a href="#初级教程" class="headerlink" title="初级教程"></a>初级教程</h2><p><a href="../Chapters/Concept/article.html">前置数学</a></p>
<span id="more"></span>
<p><a href="../Chapters/First_Install/article.html">第一章 Ubuntu以及Windows安装MindSpore</a></p>
<p><a href="../Chapters/Second_TryMindSpore/article.html">第二章 尝试使用MindSpore</a></p>
<p><a href="../Chapters/Third_Tensor/article.html">第三章 张量</a></p>
<p><a href="../Chapters/Fourth_DataSet/article.html">第四章 数据集</a></p>
<p><a href="../Chapters/Fivth_ConstructNetwork/article.html">第五章 网格构建</a></p>
<p><a href="../Chapters/Sixth_FunctionAutoDifferentalCalc/article.html">第六章 函数式自动微分</a></p>
<p><a href="../Chapters/Seven_ModelTrain/article.html">第七章 模型训练</a></p>
]]></content>
      <categories>
        <category>专题</category>
        <category>机器学习</category>
        <category>Mindspore</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MindSpore</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>算法数论基础</title>
    <url>/2024/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/article.html</url>
    <content><![CDATA[<h1 id="前言需要用到的偏僻语法知识">前言：需要用到的偏僻语法知识</h1>
<h2 id="c随机数函数">c++随机数函数</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NDIwMDg1ODk=">如何优雅的用
C++生成随机数 - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></p>
<p>头文件：c: cstdlib c++: random</p>
<p><code>cstdlib</code> 中的 rand（）和 srand（）函数是 C
语言使用的随机数生成方法，通过 <strong><em>线性同余法</em></strong>
计算。</p>
<span id="more"></span>
<blockquote>
<p>srand 常用时间作为种子</p>
</blockquote>
<p>C++标准建议使用 <code>random</code> 代替它们。</p>
<h3 id="随机数生成引擎-random-number-engines">随机数生成引擎
<strong>Random number engines</strong></h3>
<p><code>random</code> 提供了三种引擎，使用哪种需要权衡：</p>
<ul>
<li>linear_congruential_engine（线性同余法）：速度比较快，储存很少的中间变量。</li>
<li>mersenne_twister_engine：比较慢，占用存储空间较大，但是在参数设置合理的情况下，可生成最长的不重复序列，且具有良好的频谱特征。</li>
<li>subtract_with_carry_engine：速度最快，占用存储空间较大，频谱特性有时不佳。</li>
</ul>
<h3 id="预定义算法">预定义算法</h3>
<p>算法包括
minstd_rand0、minstd_rand、mt19937、mt19937_64、ranlux24_base、ranlux48_base
等。</p>
<p>以下是费马小定理素性检验的随机数实际应用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">eng</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">randint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(a, b)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dis</span>(eng);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickPow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>)res = (ll)res * x%p;</span><br><span class="line">		x = (ll)x * x%p;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">3</span>)<span class="keyword">return</span> x == <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">randint</span>(<span class="number">2</span>, x - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">quickPow</span>(a, x - <span class="number">1</span>, x) != <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isPrime</span>(<span class="number">9997579</span>))<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>以下代码中将不会给出例如：randint, quickpow
的代码（图个方便）</strong></p>
<h1 id="gcd-与-lcd-以及其衍生的素数判定问题">GCD 与 LCD
以及其衍生的素数判定问题</h1>
<h2 id="gcd-的数学推导">GCD 的数学推导</h2>
<h3 id="取模运算">取模运算</h3>
<p>amodp 表示 a 除以 p 的余数</p>
<p><strong>模 ｐ 加法</strong> <span class="math inline">\((a+b)mod\ p =
(amodp+bmodp)\ mod\ p\)</span></p>
<p><strong>模 p 减法</strong> <span class="math inline">\((a-b)mod\ p =
(amodp-bmodp + p)\ mod\ p\)</span></p>
<p>注意在这里有个很容易犯得错误，在数学中，我们称mod是不会结果为负数得，但在计算机中，对负数进行去摸结果仍是负数。</p>
<blockquote>
<p>例如：</p>
<p>对-1进行取模，结果为n-1，而在计算机中，结果仍为-1</p>
</blockquote>
<p><strong>模 p 乘法</strong> <span class="math inline">\((a*b)mod\ p =
(amodp*bmodp)mod\ p\)</span></p>
<p><strong>幂模 p</strong> <span
class="math inline">\((a^b)modp=((amodp)^b)modp\)</span></p>
<p>  模运算满足结合律、交换律和分配律。<span
class="math inline">\(a=b(mod\ n)\)</span> 表示 $ a$ 和 <span
class="math inline">\(b\)</span> 模 <span
class="math inline">\(n\)</span> 同余，即 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span> 除以 <span
class="math inline">\(n\)</span> 的余数相等。</p>
<h3 id="最大公约数">最大公约数</h3>
<p>gcd 即最大公约数 lcm 即最小公倍数</p>
<p>## gcd 的具体实现与算法优化</p>
<figure>
<img src="https://s2.loli.net/2024/08/24/hjFAPLWQ98seZr5.png"
alt="image-20220508102231840" />
<figcaption aria-hidden="true">image-20220508102231840</figcaption>
</figure>
<p><strong>gcd 的基础实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>gcd 的运算符优化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">    // make sure a &gt;= b.</span><br><span class="line">    if (a &lt; b) &#123;</span><br><span class="line">        std::swap(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool a_isodd = a &amp; 1;</span><br><span class="line">    bool b_isodd = b &amp; 1;</span><br><span class="line"></span><br><span class="line">    if (a_isodd &amp;&amp; b_isodd) &#123;</span><br><span class="line">        return gcd((a - b) &gt;&gt; 1, b);</span><br><span class="line">    &#125; else if (a_isodd &amp;&amp; !b_isodd) &#123;</span><br><span class="line">        return gcd(a, b &gt;&gt; 1);</span><br><span class="line">    &#125; else if (!a_isodd &amp;&amp; b_isodd) &#123;</span><br><span class="line">        return gcd(a &gt;&gt; 1, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // both a and b are even numbers.</span><br><span class="line">    return gcd(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="素数检验算法">素数检验算法</h2>
<h3 id="纯暴力-o-n">纯暴力 O( n )</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++)</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="费马素性检验">费马素性检验</h3>
<p>那么反过来呢？如果存在某个 <span class="math inline">\(a^{p-1}\equiv
1(mod\ p)\)</span>，是否就能判定 <span class="math inline">\(p\)</span>
是素数呢？<strong>并不行</strong>，例如 <span
class="math inline">\(2^{341-1}\equiv 1 (mod341)\)</span>，但 <span
class="math inline">\(341\)</span> 是合数，满足该同余等式的合数被称为
<strong>费马伪素数</strong>。</p>
<p>幸好，一个合数是费马伪素数的概率并不是很高。所以我们可以多测试几个
<span class="math inline">\(a\)</span>。只要存在某个 <span
class="math inline">\(a^{p-1}\not \equiv 1 (mod\ p)\)</span>，即可说明
<span class="math inline">\(p\)</span> 不是素数。而如果多组测试下来
<span class="math inline">\(a^{p-1}\equiv 1\)</span> 都成立，那它就
<strong>很可能</strong> 是素数了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">3</span>)<span class="keyword">return</span> x == <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">randint</span>(<span class="number">2</span>, x - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">quickPow</span>(a, x - <span class="number">1</span>, x) != <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="米勒-拉宾素性检验">米勒-拉宾素性检验</h3>
<p>对于待检验的数为偶数，可直接判断其为非素数，而奇数则可写成 <span
class="math inline">\(a^{x-1}\)</span> 表示为 <span
class="math inline">\(a^{2^rd}\)</span> 当考虑 x 为奇数时，<span
class="math inline">\(a^d,a^{2d},...,a^{2^rd}\)</span>
这样一串数字的性质。</p>
<p>我们已经知道对奇素数 <span class="math inline">\(x\)</span>，<span
class="math inline">\(a^{2^rd} \equiv 1 (mod\ x)\)</span> （a 是 x
的倍数的情况下特判)，也就是说这串数字以 1 结尾，由于 x 是奇素数，且
<span class="math inline">\(1^{\frac{x-1}{2}} \equiv 1 (mod\
x)\)</span></p>
<h1 id="素数筛">素数筛</h1>
<p>##　暴力判断</p>
<h2 id="埃氏筛法">埃氏筛法</h2>
<h2 id="欧拉筛法">欧拉筛法</h2>
<p>上面得三种筛法都是十分简单而且基础得。这里就不多阐述了。</p>
<h2 id="不能秒杀的题">不能秒杀的题</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI5NS8=">1293
夏洛特和他的女朋友<i class="fa fa-external-link-alt"></i></span></p>
<p>看到这道题，最先开始的想法，对每个数与其质因子连一条线，对建出来的图，做染色，保证每一条边的两个端点是不同颜色</p>
<p>但这并非正解，对于每一条边，其两端的链接必定是一个合数和一个素数，因此该图为一个二分图</p>
<figure>
<img src="https://s2.loli.net/2024/08/24/zKgVIluDya9mUxJ.png"
alt="image-20220519164522508" />
<figcaption aria-hidden="true">image-20220519164522508</figcaption>
</figure>
<p>剩下的很简单，n &lt;3时ans=1，n&gt; = 3 时 ans = 2；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000006</span>;</span><br><span class="line"><span class="type">int</span> prime[N], countNum;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oula</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])prime[countNum++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; prime[j] * i &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">oula</span>(N);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n + <span class="number">1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(st[i]) <span class="built_in">printf</span>(<span class="string">&quot;2 &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="素数筛思想的实际应用">素数筛思想的实际应用</h2>
<p>对于每个区间内的所有数，合数必有一个
sqrt（a）的因子，故可通过预处理出 5*10^4
内的所有素数，再通过筛查质因子处理出每一个合数</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTk4Lw==">196
质数距离<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="type">int</span> prime[N], countNum;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    countNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])prime[countNum++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; prime[j] * i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[prime[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; l &gt;&gt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>(<span class="number">50000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; countNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll p = prime[i];</span><br><span class="line">            <span class="keyword">for</span> (ll j = <span class="built_in">max</span>(p * <span class="number">2</span>, (l + p - <span class="number">1</span>) / p * p); j &lt;= r; j += p)</span><br><span class="line">                st[j - l] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        countNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= r - l; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[i] &amp;&amp; i + l &gt;= <span class="number">2</span>)</span><br><span class="line">                prime[countNum++] = i + l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (countNum &lt; <span class="number">2</span>)<span class="built_in">puts</span>(<span class="string">&quot;There are no adjacent primes.&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> minp = <span class="number">0</span>, maxp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> d = prime[i + <span class="number">1</span>] - prime[i];</span><br><span class="line">                <span class="keyword">if</span> (d &lt; prime[minp + <span class="number">1</span>] - prime[minp])minp = i;</span><br><span class="line">                <span class="keyword">if</span> (d &gt; prime[maxp + <span class="number">1</span>] - prime[maxp])maxp = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d,%d are closest, %d,%d are most distant.\n&quot;</span>,</span><br><span class="line">                prime[minp], prime[minp + <span class="number">1</span>], prime[maxp], prime[maxp + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分解质因数">分解质因数</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTk5Lw==">197
阶乘分解<i class="fa fa-external-link-alt"></i></span></p>
<p>最先开始想的是对于每一个 n
以内的数都枚举一下，记录其对各个质数的约数，但这样就会有 1e6*1e5（1e6
以内的素数个数）的时间复杂度，仍然超限，因此，转换一下思路，枚举素数，对每个该素数的倍数加入
s 值，即： <span class="math display">\[
s = n/p + n/p^2 + n/p^3 + n/p^4...
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000006</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> prime[N],countNum;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])prime[countNum++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;prime[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">1000000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;countNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;prime[i])<span class="keyword">break</span>;</span><br><span class="line">        ll p=prime[i],s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=p)s+=n/p,p*=prime[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,prime[i],s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="约数之和">约数之和</h1>
<p>约数定理 n 的 <span
class="math inline">\((a_1+1)(a_2+1)...(a_k+1)\)</span> 个正约数之和为
<span
class="math inline">\((p_1^0+p_1^1+...p_1^{a1})(p_2^0+p_2^1+...+p_2^{a2})...(p_k^0+p_k^1+..+p_k^{ak})\)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9hY3Rpdml0eS9jb250ZW50L3Byb2JsZW0vY29udGVudC84MDQ2Lw==">AcWing
97. 约数之和（算法提高课） - AcWing<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">const int mod = 9901;</span><br><span class="line"></span><br><span class="line">int qmi(int a, int k)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    a %= mod;</span><br><span class="line">    while (k)</span><br><span class="line">    &#123;</span><br><span class="line">        if (k &amp; 1) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        k &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum(int p, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if (k == 1) return 1;</span><br><span class="line">    if (k % 2 == 0) return (1 + qmi(p, k / 2)) * sum(p, k / 2) % mod;</span><br><span class="line">    return (sum(p, k - 1) + qmi(p, k - 1)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">    int ans = 1;</span><br><span class="line">    for (int i = 2; i * i &lt;= a; i ++ )</span><br><span class="line">        if (a % i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            int s = 0;</span><br><span class="line">            while (a % i == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                a /= i, s ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * sum(i, b * s + 1) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    if (a &gt; 1) ans = ans * sum(a, b + 1) % mod;</span><br><span class="line">    if (a == 0) ans = 0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="约数个数">约数个数</h1>
<p>暴力求约数个数</p>
<h2
id="求给定元素集中每一个数字的约数个数">求给定元素集中每一个数字的约数个数</h2>
<p>利用筛法思想，对于每一个数字枚举他的倍数</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI5My8=">1291
轻拍牛头<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],cnt[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;N;j+=i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[j]+=cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;s[a[i]]<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="阶乘平方的质数个数">阶乘、平方的质数个数</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTI5Ni8=">1294
樱花<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="math inline">\(1/x+1/y=1/n!\)</span> =&gt; <span
class="math inline">\(y=n!+n!^2/(x-n!)\)</span></p>
<p>因为 x, y 为正整数，因此要求的个数等价于 <span
class="math inline">\(n!^2\)</span> 的约数个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> prime[N],countNum;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])prime[countNum++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;prime[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    </span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;countNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;prime[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="type">int</span> j=n;</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j)s+=j/prime[i],j/=prime[i];</span><br><span class="line">        ans=(ans*(<span class="number">2</span>*s<span class="number">+1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="暴力枚举求最多约数个数的数一定范围内最大">暴力枚举求最多约数个数的数（一定范围内最大）</h2>
<p>dfs 搜索</p>
<ul>
<li>确定需要的质数数（2...23 共九个质数限定 1e9 内的约数最多的数）</li>
<li>确定需要的最大 α（30，确定 2e9 次方的数）</li>
</ul>
<p>注意可行性剪枝</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjAwLw==">198
反素数<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[<span class="number">9</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="type">int</span> maxs,number,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> last,<span class="type">int</span> p,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt; maxs||s == maxs&amp;&amp;p&lt;number)</span><br><span class="line">    &#123;</span><br><span class="line">        maxs=s;</span><br><span class="line">        number=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">9</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span>*p*primes[u]&gt;n)<span class="keyword">break</span>;</span><br><span class="line">        p*=primes[u];</span><br><span class="line">        <span class="built_in">dfs</span>(u<span class="number">+1</span>,i,p,s*(i<span class="number">+1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">30</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//初始最大的α为30</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分解质因数优化暴力枚举约数">分解质因数优化暴力枚举约数</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjAwLw==">198
反素数<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>2e9 次方以内的数的最多约数的数共有 1600
左右的约数数量</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> prime[N],countNum;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">PII factor[N];</span><br><span class="line"><span class="type">int</span> dividor[N];</span><br><span class="line"><span class="type">int</span> fcnt,dcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])prime[countNum++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;prime[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==fcnt)</span><br><span class="line">    &#123;</span><br><span class="line">        dividor[dcnt++]=p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=factor[u].y;i++)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(u<span class="number">+1</span>,p);</span><br><span class="line">        p*=factor[u].x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(N - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line"></span><br><span class="line">        fcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t = d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; prime[i] &lt;= t / prime[i]; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p = prime[i];</span><br><span class="line">            <span class="keyword">if</span> (t % p == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (t % p == <span class="number">0</span>) t /= p, s ++ ;</span><br><span class="line">                factor[fcnt ++ ] = &#123;p, s&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) factor[fcnt ++ ] = &#123;t, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        dcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dcnt; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = dividor[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">gcd</span>(a, x) == b &amp;&amp; (ll)c * x / <span class="built_in">gcd</span>(c, x) == d) res ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="欧拉函数">欧拉函数</h1>
<h2 id="欧拉函数概念">欧拉函数概念</h2>
<p>1-N 中与 N 互质的数的个数被称为欧拉函数记为 <span
class="math inline">\(φ(n)\)</span></p>
<p>由容斥原理推出的公式：<span
class="math inline">\(φ(n)=N(1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_k})\)</span></p>
<p>容斥原理证明公式</p>
<p>对于 1-N 当中的每一个数（假设 1-N 中有三个 N 的质因子分别设为 <span
class="math inline">\(p_1p_2p_3\)</span>）</p>
<p><span class="math display">\[
φ(N)=N-N/p_1-N/p_2-N/p_3+N/（p_1p_2)+N/(p_2p_3)+N/(p_3p_1)-N/(p_1p_2p_3)
\]</span> 化简即可推出上面的公式</p>
<p>递推式：<span
class="math inline">\(φ(ab)=\frac{φ(a)φ(b)gcd(a,b)}{φ(gcd(a,b))}\)</span></p>
<h2 id="欧拉函数的题目">欧拉函数的题目</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjAzLw==">203
可见的点<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>思维+欧拉函数</strong></p>
<p>对于每一个被光照到的点，其 x, y 必然满足以下条件</p>
<ol type="1">
<li>x, y 为整数</li>
<li>(x, y)是直线 y = kx 在第一象限以原点为端点的射线上的第一个整点</li>
<li>即 x, y 为互质的数</li>
</ol>
<p><strong>证明</strong></p>
<p>若 x, y 为非互质的数则存在这么一个整数点(x/d, y/d)使得其与(x,
y)处于同一直线且位于(x, y)的左下方</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> primes[N],countNum;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> eular[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initEular</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eular[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[countNum++]=i;</span><br><span class="line">            eular[i]=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i*primes[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                eular[primes[j]*i]=eular[i]*primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            eular[primes[j]*i]=eular[i]*(primes[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initEular</span>(N<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    cin&gt;&gt;_;</span><br><span class="line">    <span class="type">int</span> T=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        ll sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum+=eular[i]*<span class="number">2</span>;</span><br><span class="line">        cout&lt;&lt;++T&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjIyLw==">220
最大公约数<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> primes[N],countNum;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">ll phi[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eular</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[countNum++]=i;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i*primes[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i*primes[j]]=phi[i]*primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;phi[i*primes[j]]=phi[i]*(primes[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)s[i]=s[i<span class="number">-1</span>]+phi[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">eular</span>(n);</span><br><span class="line">    </span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;countNum;i++ [数论，算法]g)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=primes[i];</span><br><span class="line">        ans+=s[n/p]*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>
<h1 id="同余">同余</h1>
<h2 id="扩展欧几里得算法裴蜀定理">扩展欧几里得算法（裴蜀定理）</h2>
<h3 id="概念与推导">概念与推导</h3>
<p><span class="math inline">\((a,b)=d =&gt; a * x +b * y = d\)</span>
<span class="math inline">\((b,a mod b)\)</span></p>
<p><strong>假定</strong> <span class="math inline">\(y * b + x * (a mod
b) =d\)</span></p>
<p><span
class="math inline">\(y*b+x(a-\lfloor\frac{a}{b}\rfloor*b)=d\)</span></p>
<p><span
class="math inline">\(y*b+a*x-\lfloor\frac{a}{b}\rfloor*b*x=d\)</span></p>
<p><span class="math inline">\(a*x +
b*(y-\lfloor\frac{a}{b}\rfloor*x)=d\)</span></p>
<p><span class="math inline">\(=&gt; x&#39;=x\quad
y&#39;=y-\lfloor\frac{a}{b}\rfloor*x\)</span></p>
<h3 id="拓展">拓展</h3>
<p>对于 <span class="math inline">\((a,b)=d\)</span></p>
<p>对于该方程的一组解</p>
<p><span class="math inline">\(a*x_0+b*y_0=d\)</span></p>
<p>有以下结论: <span class="math display">\[
x=x_0+k*(\frac{a}{d})\quad y=y_0-k*(\frac{b}{d})
\]</span> 为该同余方程的通解</p>
<p>这种变形实际上也是一种十分常见得数学变形方式，在数学上叫做零和变形。</p>
<h2 id="同余方程">同余方程</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjA1Lw==">203
同余方程<i class="fa fa-external-link-alt"></i></span> <span class="math inline">\(ax≡1(modb)\)</span></p>
<p>=&gt; <span class="math inline">\(ax-by=1\)</span></p>
<p>且 x 一定为正值（数学中的取模不会取到正值）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span>&amp; x,<span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,x,y;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">    cout&lt;&lt;(x%b+b)%b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="青蛙的约会">青蛙的约会</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjI0Lw==">222
青蛙的约会<i class="fa fa-external-link-alt"></i></span></p>
<p>A 追 B (b-a) , 每跳一次 A 追 B(m-n)米</p>
<p><span class="math inline">\((m-n)x=b-a+yL\)</span></p>
<p>=&gt; <span class="math inline">\((m-n)x=b-a+yL\)</span>
[数论，算法]g =&gt; <span
class="math inline">\((m-n)x-yL=b-a\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll&amp; x,ll&amp; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,m,n,L;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;m&gt;&gt;n&gt;&gt;L;</span><br><span class="line">    ll x,y;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(m-n,L,x,y);</span><br><span class="line">    <span class="keyword">if</span>((b-a)%d!=<span class="number">0</span>)<span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x*=(b-a)/d;</span><br><span class="line">        ll t=<span class="built_in">abs</span>(L/d);</span><br><span class="line">        cout&lt;&lt;(x%t+t)%t&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最幸运的数字">最幸运的数字</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjA0Lw==">202
最幸运的数字<i class="fa fa-external-link-alt"></i></span></p>
<p>对于一串 8，用一个公式表示这个数字</p>
<p>8888..8(x 个 8) =&gt; 8 * 1111..1 =&gt; 8 * 9999..9/9 =&gt; 8 *
(10^x-1)/9</p>
<p>也可以用公比为 10，初项为 8 的等比数列求和思量</p>
<p>考量题目</p>
<p>对于一个 888..8 的约数 L|8*(10^x-1)/9 &lt;=&gt; (9L/d)|(10 ^ x-1)</p>
<p>&lt;=&gt; 10<sup>x</sup>= 1(mod C) C = 9L/d</p>
<p>eular 定理：对于 α<sup>phi(n)</sup>= 1(mod n) (α, n)= 1</p>
<p>根据 eular 与 10<sup>x</sup> = 1(mod C)</p>
<p>枚举 phi(c)的约数，最小的 10^i%c == 1 即为答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">slow_mul</span><span class="params">(ll a,ll b,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=(res+a)%p;</span><br><span class="line">        a=(a+a)%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">     [数论，算法]g&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a,ll b,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=<span class="built_in">slow_mul</span>(res,a,c);</span><br><span class="line">        a=<span class="built_in">slow_mul</span>(a,a,c);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_eular</span><span class="params">(ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=a;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=a/i;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a%i==<span class="number">0</span>)a/=i;</span><br><span class="line">            res=res/i*(i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">1</span>) res=res/a*(a<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    ll L;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;L,L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d=<span class="number">1</span>;</span><br><span class="line">        d=<span class="built_in">gcd</span>(L,<span class="number">8</span>) [数论，算法]g;</span><br><span class="line"></span><br><span class="line">        ll c= <span class="number">9</span>*L/d;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout&lt;&lt;c&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        ll phi = <span class="built_in">get_eular</span>(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout&lt;&lt;phi&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        ll ans=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">gcd</span>(c,<span class="number">10</span>)!=<span class="number">1</span>)ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=phi/i;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(phi%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="built_in">qmi</span>(<span class="number">10</span>,i,c))==<span class="number">1</span>)ans=<span class="built_in">min</span>(ans,i);</span><br><span class="line">                <span class="keyword">if</span>((<span class="built_in">qmi</span>(<span class="number">10</span>,phi/i,c))==<span class="number">1</span>)ans=<span class="built_in">min</span>(ans,phi/i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>,T++,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="曹冲养猪">曹冲养猪</h2>
<p><strong>中国剩余定理</strong></p>
<p><span class="math display">\[\begin{cases}x=a_1(mod\quad
m_1)\\x=a_2(mod\quad m_2)\\x=a_3(mod\quad m_3)\\...\\x=a_n(mod\quad
m_n)\end{cases}\]</span></p>
<p>设 <span class="math inline">\(M=m_1m_2m_3...m_n\)</span>
[数论，算法]g 令 <span class="math inline">\(M_i=M/m_i\)</span> <span
class="math inline">\(t_i\)</span> 是 <span
class="math inline">\(M_i\)</span> 关于 M 的逆元</p>
<p><span class="math inline">\(M_it_i=1(mod\quad m_i)\)</span></p>
<p><span class="math inline">\(x=\sum a_iM_it_i\)</span></p>
<p>==构造解，硬记，比较难==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line">ll a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll&amp; x,ll&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    ll M=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i] [数论，算法]g;</span><br><span class="line">        M*=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mi=M/a[i];</span><br><span class="line">        ll ti,x;</span><br><span class="line">        <span class="built_in">exgcd</span>(mi,a[i],ti,x);</span><br><span class="line">        ans+=b[i]*mi*ti;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(ans%M+M)%M&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="矩阵乘法">矩阵乘法</h1>
<h2 id="求斐波那契数列的和">求斐波那契数列的和</h2>
<p>fn+1 = fn+fn-1;</p>
<p>sn = f1+f2+f3+f4...+fn</p>
<p>sn+1 = f1+f2+f3+f4+...+fn+1</p>
<p><span class="math inline">\(s_{n+1}-s_n=f_{n+1}\)</span></p>
<p>构造一个矩阵 Fn = fn, fn+1, sn</p>
<p>Fn ={fn, fn+1, sn}*</p>
<p>{ {0,1,0}</p>
<p>{1,1,1}</p>
<p>{0,0,1}}= Fn+1 ={fn+1，fn+2，sn+1};</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector [数论，算法]g&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 3;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">void mul(int c[], int a[], int b[][N])</span><br><span class="line">&#123;</span><br><span class="line">    int t[N]=&#123;0&#125;;</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i] = (t[i] + 1ll * a[j] * b[j][i]) % m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(c, t, sizeof t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mul(int c[][N], int a[][N], int b[][N])</span><br><span class="line">&#123;</span><br><span class="line">    int t[N][N]=&#123;0&#125;;</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k = 0; k &lt; N; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                t[i][j] = (t[i][j] + 1ll * a[i][k] * b[k][j]) % m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(c, t, sizeof t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"> [数论，算法]g&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    int F1[N] = &#123; 1,1,1 &#125;;</span><br><span class="line">    int A[N][N] = &#123;</span><br><span class="line">        &#123;0,1,0&#125;,</span><br><span class="line">        &#123;1,1,1&#125;,</span><br><span class="line">        &#123;0,0,1&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">n--;</span><br><span class="line">    while (n)</span><br><span class="line">    &#123;</span><br><span class="line">        /*for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;N;j++)</span><br><span class="line">        cout&lt;&lt;A[i][j]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;N;i++)cout&lt;&lt;F1[i]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        puts(&quot;&quot;);*/</span><br><span class="line">        if (n &amp; 1)mul(F1, F1, A);</span><br><span class="line">        mul(A, A, A);</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; F1[2] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1
id="求一个关于斐波那契数列的特殊数列和">求一个关于斐波那契数列的特殊数列和</h1>
<p>T(n)=(f1+2f2+3f3+…+nfn)modm</p>
<p>nsn-tn =(n-1)f1+(n-2)f2+...+fn-1</p>
<p>(n+1)sn+1-tn+1 = nf1+(n-1)f2+...+fn</p>
<p>(n+1)sn+1-tn+1-(nsn-tn)= sn</p>
<p>那么我们设 pn = sn-tn</p>
<p>Fn ={fn, fn+1, sn, pn} [数论，算法]g*</p>
<p>{</p>
<p>{0,1,0,0},</p>
<p>{1,1,1,0},</p>
<p>{0,0,1,1},</p>
<p>{0,0,0,1}</p>
<p>};= Fn+1 ={fn+1.fn+2, sn+1, sn+2}</p>
<p>ps: 为了简化代码，我们将初始的 F1 扩展为二维矩阵</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[][N],<span class="type">int</span> a[][N],<span class="type">int</span> b[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                t[i][j]=(t[i][j]<span class="number">+1ll</span>*a[i][k]*b[k][j])%m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(c,t,<span class="keyword">sizeof</span> t);</span><br><span class="line"> [数论，算法]g&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> F1[N][N]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> A[N][N]=&#123;</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)<span class="built_in">mul</span>(F1,F1,A);</span><br><span class="line">        <span class="built_in">mul</span>(A,A,A);</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;(<span class="number">1ll</span>*F1[<span class="number">0</span>][<span class="number">2</span>]*n-F1[<span class="number">0</span>][<span class="number">3</span>]+m)%m&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="组合数学">组合数学</h1>
<p>这里给出一下一个非常常用的全排列函数：</p>
<p>next_permutation()</p>
<p>这个函数也十分便于记忆，permutation即<code>排列</code>的意思。</p>
<h2 id="总结">总结</h2>
<p><strong>I</strong></p>
<p>利用 Cab = Ca-1b+Ca-1b-1 的组合数学规律 dp 出二位数组保存结果</p>
<p><strong>II</strong></p>
<p>利用除以一个数等于乘以一个数的逆元的形式预处理出阶乘，o1
的时间内得到特定结果</p>
<h1 id="多重集合的全排列">多重集合的全排列</h1>
<p>多重集合的定义：<strong>多重集合不要求元素不能重复</strong></p>
<h2 id="多重集合表示">多重集合表示：</h2>
<p>M ={k1⋅a1, k2⋅a2, ⋯, kn⋅an}M ={k1⋅a1, k2⋅a2, ⋯, kn⋅an}(其中每个 ai
代表是不同的元素，每个元素 ai 有 ki 个，ki 可以是有限数，也可以是
∞。)(其中每个 ai 代表是不同的元素，每个元素 ai 有 ki 个，ki
可以是有限数，也可以是 ∞。)</p>
<h2 id="多重集的排列">多重集的排列:</h2>
<ul>
<li>多重集合 M ={k1⋅a1, k2⋅a2, ⋯, kn⋅an}的 r 排列数为 kr 多重集合 M
={k1⋅a1, k2⋅a2, ⋯, kn⋅an}的 r 排列数为 <span
class="math inline">\(k^r\)</span></li>
<li>多重集合 M ={k1⋅a1, k2⋅a2, ⋯, kn⋅an}的全排列数为：<span
class="math inline">\(\frac{(k1+k2+⋯+kn)!}{k1!k2!⋯kn!}\)</span></li>
</ul>
<h1 id="数学知识">数学知识</h1>
<h1 id="排列">排列</h1>
<h2 id="错排公式">错排公式</h2>
<h3 id="错排问题">错排问题</h3>
<p><strong>错排问题</strong> 考虑一个有 n
个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。
n 个元素的错排数记为
D(n)。研究一个排列错排个数的问题，叫做错排问题或称为更列问题。</p>
<h3 id="错排公式的递推">错排公式的递推</h3>
<p>对于 $D(n) $，考虑第 <span class="math inline">\(n\)</span>
个位置，它可以与 <span class="math inline">\(n-1\)</span>
前的任意位置交换 <span
class="math inline">\(((n-1)D(n-1))\)</span>，在考虑编号为 k
的位置，这是有两种情况</p>
<p>（1）将它放到 <span
class="math inline">\(n\)</span>，那么，对于剩下的 n-1 个元素，由于第 k
个元素放到了位置 n，剩下 n-2 个元素就有 <span
class="math inline">\(D(n-2)\)</span> 种方法，此时放置方法有 <span
class="math inline">\(D(n-2)\)</span> 种。</p>
<p>（2）将它不放到 n，那么，剩下 n-2 个元素就有
D(n-2)种方法，此时放置方法有 <span
class="math inline">\(((n-2)*D(n-2))\)</span> 种。</p>
<p><strong>递推关系式：D(n) = (n-1) [D(n-2) + D(n-1)] (n &gt;=
3)</strong></p>
<p>特别的 <span class="math inline">\(D(1)=0,D(2)=1\)</span>;</p>
<p>其实到这里就结束了，通过递推关系式可以计算机直接算出 <span
class="math inline">\(D(n)\)</span></p>
<p>但是下面还是给出错排公式的推导</p>
<p>以上是必须要会的内容，最好是尝试自己在没有辅助材料的情况下过一遍。（这种方法又称费曼学习法）</p>
<h3 id="错排公式的推导">错排公式的推导</h3>
<p>[数论，算法]g 假设 <span class="math inline">\(D(k) = k! N(k), k = 1,
2, …, n,\)</span> 且有 <span class="math inline">\(N(1) = 0, N(2) =
1/2.\)</span> 当 <span class="math inline">\(n ≥ 3\)</span> 时，<span
class="math inline">\(n!\cdot N(n) = (n-1) (n-1)! N(n-1) + (n-1)!
N(n-2)\)</span></p>
<p>即有公式</p>
<p><span class="math display">\[N(n) = (n-1) N(n-1) +
N(n-2)\]</span></p>
<p>于是有 <span class="math display">\[N(n) - N(n-1) = - [N(n-1) -
N(n-2)] / n = (-1/n) [-1/(n-1)] [-1/(n-2)]…(-1/3) [N(2) - N(1)] = (-1)^n
/ n!\]</span></p>
<p>因此</p>
<p><span class="math inline">\(N(n-1) - N(n-2) = (-1)^{(n-1)} /
(n-1)!\)</span>,</p>
<p><span class="math display">\[N(2) - N(1) = (-1)^2 / 2!\]</span></p>
<p>相加，可得</p>
<p><span class="math display">\[N(n) = (-1)^2/2! + … + (-1)^(n-1) /
(n-1)! + (-1)^n/n!\]</span></p>
<p>因此</p>
<p><span class="math display">\[D(n) = n! [(-1)^2/2! + … +
(-1)^(n-1)/(n-1)! + (-1)^n/n!]\]</span></p>
<p><span class="math display">\[D(n) = ∑_{k=2}^{n} (-1)^k * n! /
k!\]</span></p>
<p>此即错排公式。</p>
<p>### 另一种方式的推导——容斥原理</p>
<p>正整数 1, 2, 3, ……, n 的全排列有 n! 种，其中第 k 位是 k 的排列有
(n-1)! 种; 当 k 分别取 1, 2, 3, ……, n 时，共有 n*(n-1)!
种排列是至少放对了一个的，由于所求的是错排的种数，所以应当减去这些排列;
但是此时把同时有两个数错排的排列多排除了一次，应补上;
在补上时，把同时有三个数不错排的排列多补上了一次，应排除;……;
继续这一过程，得到错排的排列种数为</p>
<p>D(n) = n! - n!/1! + n!/2! - n!/3! + … + (-1)^n <em>n!/n! = ∑(k = 2~n)
(-1)^k </em> n! / k!,</p>
<p>即 D(n) = n! [1/0! - 1/1! + 1/2! - 1/3! + 1/4! + ... +
(-1)^n/n!].</p>
<h2 id="线性代数">线性代数</h2>
<h3 id="线性基">线性基</h3>
<h4 id="有关线性基的一些概念">有关线性基的一些概念</h4>
<p>[数论，算法]g ##### 张成的概念</p>
<p>设 ，所有这样的子集 的异或和组成的集合称为集合 的
<strong>张成</strong>，记作 。即，在
中选出任意多个数，其异或和的所有可能的结果组成的集合。</p>
<h5 id="线性相关">线性相关</h5>
<p>对于一个集合 ，如果存在一个元素 ，使得， 在去除这个元素后得到的集合
的张成 中包含 ，则称集合 <strong>线性相关</strong>。</p>
<p>更形象地，可以表示为，存在一个元素
，可以用其它若干个元素异或起来得到。</p>
<p>相对的，如果不存在这样的元素 ，则称集合
<strong>线性无关</strong>。</p>
<p>一个显然的结论是，对于这个线性相关的集合
，去除这个元素后，集合的张成不变。</p>
<h4 id="概念与性质">概念与性质</h4>
<p>线性基是向量空间的一组基，通常用来解决有关异或的题目，通俗的讲法就是由一个集合构造出来的另一个集合，它有以下几个性质</p>
<ol type="1">
<li>线性基的元素能相互异或得到原集合的所有相互异或得到的值</li>
<li>线性基是满足性质 1 的最小的集合</li>
<li>线性基没有异或和为 0 的子集</li>
<li>线性基种的每个元素的异或方案唯一，也就是说，线性基中的异或组合异或出的数都是不一样的</li>
<li>线性基中的每个元素的二级制最高位互不相同</li>
</ol>
<h4 id="线性基的构造方法">线性基的构造方法</h4>
<p>对原集合的每一个数 p 转化为二进制，从高位向低位扫，对于第 x 位为 1
的，如果 <span class="math inline">\(a_x\)</span> 不存在，那么令 <span
class="math inline">\(a_x = p\)</span> 并结束扫描，如果存在，令 <span
class="math inline">\(p_i=p_ixor a_x\)</span></p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">55</span>; i + <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(x &gt;&gt; i))  <span class="comment">// x的第i位是0</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p[i]) &#123;</span><br><span class="line">      p[i] = x;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x ^= p[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询原集合内任意几个元素-xor-的最大值">查询原集合内任意几个元素
xor 的最大值</h4>
<p>将线性基从高位向低位扫，若 xor 上当前扫到的 <span
class="math inline">\(a_x\)</span> 答案变大，就把答案异或上 <span
class="math inline">\(a_x\)</span></p>
<h4 id="第-k-大的子集合异或和">第 k 大的子集合异或和</h4>
<p><span class="exturl" data-url="aHR0cHM6Ly92anVkZ2UuY3NncmFuZGV1ci5jbi9wcm9ibGVtL0hEVS0zOTQ5">HDU
3949<i class="fa fa-external-link-alt"></i></span></p>
<p>要求我们查询一个数组能异或出来的第 k 大的值</p>
<p>构造一个特殊的线性基，使得每一个线性基中的值都只有一位是 1</p>
<p>如 a1:0001000 a2:0000010 a3:00000001</p>
<p>从小到大存入一个容器中，再枚举查询的第 k 大的 k 值某一位上是否为
1，如果是 1，则将 ans 异或上对应下标的线性基数组中的值</p>
<p>注意如果线性基的大小与原数组的大小不一样，说明原数组是线性相关的，此时则需要将
k-1，在进行查询（0 是最小的）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Endl endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pre(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,b,a) for(int i=b;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) scanf(<span class="string">&quot;%d&quot;</span>, &amp;x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sl(x) scanf(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ss(x) scanf(<span class="string">&quot;%s&quot;</span>, x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YES &#123;puts(<span class="string">&quot;YES&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO &#123;puts(<span class="string">&quot;NO&quot;</span>); return;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, PII&gt; PIII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; PCI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; PIC;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; PDD;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; PLL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>, M = <span class="number">2</span> * N, B = N, MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;, dy[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">ll a[N], p[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"><span class="function">ll <span class="title">lowbit</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">63</span>, <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(x &gt;&gt; i))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p[i]) &#123;</span><br><span class="line">            p[i] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x ^= p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">pre</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">63</span> - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pre</span>(j, i + <span class="number">1</span>, <span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p[j] ^= p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;ll&gt; ves;</span><br><span class="line">    <span class="built_in">pre</span>(i, <span class="number">0</span>, <span class="number">63</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i])ves.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">pre</span>(i, <span class="number">1</span>, m) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, ++T);</span><br><span class="line">    <span class="built_in">pre</span>(i, <span class="number">1</span>, m)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n != ves.<span class="built_in">size</span>())q[i]--;</span><br><span class="line">        <span class="built_in">pre</span>(j, <span class="number">0</span>, <span class="number">63</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i] &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= ves.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    res = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res ^= ves[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; Endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    <span class="built_in">si</span>(_);</span><br><span class="line">    <span class="comment">//_ = 1;</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">slove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="最大路径异或和">最大路径异或和</h4>
<p>[P4151 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQxNTE=">WC2011]最大
XOR 和路径 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class="fa fa-external-link-alt"></i></span></p>
<p>求从 1 到 n
的最大路径异或和，首先在纸上作图，发现，来回的走一条路径是等价于没有走过的，因此，我们可以从图上的任一点到达另一点后走回来是等价于停留在原地的，因此我们可以将
1-n
的路径拓展到所有的点上而保持值不变，通过观察，我们可以发现，环可以为我们的路径权值提供贡献值，因为它们是可以在（扩展到全图后的路径）路径中走奇数遍的。</p>
<p>因此，我们 dfs 对环建立线性基，刚开始随机选取一条 1-n
的路径，与线性基异或取最大值（注意，因为 ans 刚开始并不是
0，因此每次选取需要 max）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Endl endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pre(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,b,a) for(int i=b;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) scanf(<span class="string">&quot;%d&quot;</span>, &amp;x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sl(x) scanf(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ss(x) scanf(<span class="string">&quot;%s&quot;</span>, x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YES &#123;puts(<span class="string">&quot;YES&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO &#123;puts(<span class="string">&quot;NO&quot;</span>); return;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, PII&gt; PIII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; PCI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; PIC;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; PDD;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; PLL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>, M = <span class="number">2</span> * N, B = N, MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;, dy[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> h[N], ne[M], e[M], idx;</span><br><span class="line">ll w[M], p[N], verval[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"><span class="function">ll <span class="title">lowbit</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">63</span>, <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(x &gt;&gt; i &amp; <span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p[i]) &#123;</span><br><span class="line">            p[i] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x ^= p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    verval[u] = val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (verval[j] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">insert</span>(val ^ verval[j] ^ w[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(j, val ^ w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(verval, <span class="number">-1</span>, <span class="keyword">sizeof</span> verval);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; </span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">pre</span>(i, <span class="number">1</span>, m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c); <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ll t = ans= verval[n];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">63</span>, <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, ans ^ p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    <span class="comment">//si(_);</span></span><br><span class="line">    _ = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">slove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="线性无关的特性线性基的大小">线性无关的特性，线性基的大小</h4>
<p>https://vjudge.csgrandeur.cn/problem/CodeForces-1101G</p>
<p>该题要求将一个数组分成若干个段，保证段本身，段与段之间的异或都不为 0
的最大段数量</p>
<p>由于段与段之间的异或和不为
0，因此，可判断，各段的异或值是线性无关的，且根据题目要求各段的异或值是不为
0 的，因此，数组中线性相关的值必须放在同一段里另外加任意值。</p>
<p>应该敏锐的察觉到，上述特性与线性基的特性高度重合，因此，题目所求的值即位线性基的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define int ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Endl endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pre(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,b,a) for(int i=b;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si(x) scanf(<span class="string">&quot;%d&quot;</span>, &amp;x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sl(x) scanf(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ss(x) scanf(<span class="string">&quot;%s&quot;</span>, x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YES &#123;puts(<span class="string">&quot;YES&quot;</span>);return;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO &#123;puts(<span class="string">&quot;NO&quot;</span>); return;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, PII&gt; PIII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; PCI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; PIC;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; PDD;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; PLL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>, M = <span class="number">2</span> * N, B = N, MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;, dy[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> a[N], p[<span class="number">35</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"><span class="function">ll <span class="title">lowbit</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">30</span>, <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (((x &gt;&gt; i) &amp; <span class="number">1</span>)==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (p[i]==<span class="number">0</span>) &#123;</span><br><span class="line">            p[i] = x; res = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x ^= p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">pre</span>(i, <span class="number">1</span>, n)cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pre</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">        t ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!t) &#123; cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pre</span>(i, <span class="number">0</span>, <span class="number">30</span>)<span class="keyword">if</span> (p[i])cnt++;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; Endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    <span class="comment">//si(_);</span></span><br><span class="line">    _ = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">slove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="常见数学模型的特殊性质">常见数学模型的特殊性质</h1>
<h2 id="斐波那契数列">斐波那契数列</h2>
<p><strong><span
class="math inline">\(\sum{_i^k}F[i]+1=F[k+2]\)</span></strong></p>
<p>如果 k 为奇数</p>
<p><span
class="math inline">\(F[k]=F[1]+\sum{_{i=1}^{k/2}}F[2*i]\)</span></p>
<p>如果 k 为偶数</p>
<p><span
class="math inline">\(F[k]=\sum{_{i=1}^{k/2}}F[2*i-1]\)</span></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>MindSpore专题——第〇章、概念</title>
    <url>/2024/special_subject/MindSpore/Chapters/Concept/article.html</url>
    <content><![CDATA[<h1 id="初等概念名词解释">初等概念名词解释</h1>
<p>在接近学完初级的机器学习后，我意识到单纯的看MindSpore文档以及看Youtube视频是远远不够的，我必须系统的学习一些概念知识以避免在后面的学习中云里雾里，故就有了这一章，在这一章中几乎全是对概念的解释，他们的来源广泛，传送门我都会贴在此处，供查阅：</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE3LzA3L25ldXJhbC1uZXR3b3JrLmh0bWw=">神经网络入门
- 阮一峰的网络日志 (ruanyifeng.com)<i class="fa fa-external-link-alt"></i></span></p>
<p>https://github.com/exacity/deeplearningbook-chinese</p>
</blockquote>
<span id="more"></span>
<h2 id="感知机perceptron">感知机（Perceptron）</h2>
<figure>
<img src="https://s2.loli.net/2024/06/10/bkVr3Lymea1OAnw.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>​
上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3...），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。</p>
<p>​ 感知机是输出传入参数的一个函数变换，大多数情况下他是(最初涉及) <span
class="math display">\[
output = \sigma(w_1*a_1 +\cdots +w_n*a_n + b)
\]</span> 其中<span class="math display">\[\sigma
\]</span>​函数表达式如下 <span class="math display">\[
σ(z) = 1 / (1 + e^{-z})
\]</span></p>
<h2 id="表示学习representation-learning">表示学习（Representation
Learning）</h2>
<p>使用机器学习来发掘表示本身，而不仅仅把表示映射到输出,学习到的表示往往比手动设计的表示表现得更好。并且不需要人工干预就能迅速适应新的任务。</p>
<h2 id="变差因素">变差因素</h2>
<p>在此背景下，‘‘因素’’这个词仅指代影响的不同来源；因素通常不是乘性组合。这些因素通常是不能被直接观察到的量。相反，它们可能是现实世界中观察不到的物体或者不可观测的力，但会影响可观测的量。为了对观察到的数据提供有用的简化解释或推断其原因，它们还可能以概念的形式存在于人类的思维中。</p>
<p>它们可以被看作数据的概念或者抽象，帮助我们了解这些数据的丰富多样性。</p>
<h2 id="可见层">可见层</h2>
<p>也就是神经网路的输入层，这样命名的原因是因为它包含我们能观察到的变量。</p>
<h2 id="隐藏层">隐藏层</h2>
<p>也就是神经网路的中间层。因为它们的值不在数据中给出，所以将这些层称为‘‘隐藏”;模型必须确定哪些概念有利于解释观察数据中的关系。这里的图像是每个隐藏单元表示的特征的可视化。这里也是分形的思想运用的层次。</p>
<h2 id="输出层">输出层</h2>
<p>输出神经网路的判断也称Object Identify</p>
<h2 id="前馈深度网络">前馈深度网络</h2>
<h3 id="多层感知机multilayer-perceptron">多层感知机（Multilayer
Perceptron）</h3>
<p>多层感知机仅仅是一个将一组输入值映射到输出值的数学函数。该函数由许多较简单的函数复合而成。我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。</p>
<h2 id="为什么需要使用非线性函数">为什么需要使用非线性函数</h2>
<p>这是由于线性模型的局限性，一个很经典的例子是，线性模型是无法学习异或函数的。</p>
<h2 id="分布式表示">分布式表示</h2>
<p>其思想是：系统的每一个输入都应该由多个特征表示，并且每一个特征都应该参与到多个可能输入的表示。这显然也与神经网络每一层layer与layer之间的dense有关联</p>
<h2 id="激活函数">激活函数</h2>
<p>激活函数是神经网络中的一个重要组件，用于对输入信号进行非线性变换，他决定了一个神经元是否被激活，或者说神经元的输出是什么。</p>
<p>激活函数在数学上表示为一个非线性的函数。下面是一些常见的激活函数</p>
<h3 id="sigmoid函数">Sigmoid函数</h3>
<p><span class="math display">\[σ(x) = 1 / (1 + e^{-x})\]</span>
输出介于0到1之间，常用于二分类任务，但容易在深层网络中造成梯度消失的问题</p>
<figure>
<img src="https://s2.loli.net/2024/08/26/DxICv7oeaSA5hrz.png"
alt="Sigmoid" />
<figcaption aria-hidden="true">Sigmoid</figcaption>
</figure>
<h3 id="tanh函数">Tanh函数</h3>
<p>输出值在-1到1之间，相对于Sigmoid函数，其输出均值为0，但同样存在梯度消失的问题。</p>
<p><span class="math display">\[tanh(x) =  (e^x - e^{-x}) / (e^x +
e^{-x})\]</span></p>
<figure>
<img src="https://s2.loli.net/2024/08/26/fs2bXCkaleBDYQS.png"
alt="Tanh" />
<figcaption aria-hidden="true">Tanh</figcaption>
</figure>
<h3 id="relu-rectified-linear-unit函数">ReLU (Rectified Linear
Unit函数)</h3>
<p>最常见的激活函数之一</p>
<p>输出非负值，计算简单，能够缓解梯度消失问题，但可能存在“死亡ReLU”现象（即某些神经元在训练过程中永远不被激活）</p>
<p><span class="math display">\[ReLU(x) = max(0 ,x)\]</span></p>
<h3 id="leaky-relu函数">Leaky ReLU函数</h3>
<p>ReLU的改进版本，允许负值以一个小的斜率通过，减少死亡ReLU中的死亡现象。</p>
<p><span class="math display">\[Leaky\ ReLU(x) = max(\alpha x
,x)\]</span></p>
<p>其中<span class="math inline">\(\alpha\)</span> 是一个较小的常数</p>
<h3 id="softmax函数">Softmax函数</h3>
<p>通常用于多分类问题的输出层，将神经元的输出转换为概率分布，输出值的总和为1。</p>
<p><span class="math display">\[Softmax(x_i) = e^{x_i} / \sum
e^{x_j}\]</span></p>
<h2 id="损失函数">损失函数</h2>
<p>用于量化真实值与预测值之间的差距的函数，它量化了模型预测的错误程度，数值越小表示模型的预测越接近真实值，反之则说明预测误差较大。</p>
<h3
id="回归问题中的损失函数">1<strong>回归问题中的损失函数</strong></h3>
<ul>
<li><p>均方误差（Mean Squared Error,
MSE）：计算预测值与真实值之间差值的平方和的平均值。MSE是回归问题中最常用的损失函数。</p>
<ul>
<li>公式：<span class="math inline">\(MSE = (1/n) * Σ (y_{pred} -
y_{true})^2\)</span></li>
</ul></li>
<li><p>平均绝对误差（Mean Absolute Error, MAE）</p>
<p>：计算预测值与真实值之间绝对差值的平均值。</p>
<ul>
<li>公式：<span class="math inline">\(MAE = (1/n) * Σ |y_{pred} -
y_{true}|\)</span></li>
</ul></li>
</ul>
<h3 id="分类问题中的损失函数">2.
<strong>分类问题中的损失函数</strong></h3>
<ul>
<li><p>交叉熵损失（Cross-Entropy Loss）</p>
<p>：用于分类任务，特别是在多分类问题中常用。它衡量模型输出的概率分布与真实分布之间的差异。</p>
<ul>
<li><p>对于二分类问题，二元交叉熵损失的公式为：</p>
<ul>
<li><p>公式：</p></li>
<li><p><span class="math display">\[
Binary\ Cross-Entropy\ Loss = - (y_{true} * log(y_{pred}) + (1 -
y_{true}) * log(1 - y_{pred}))
\]</span></p></li>
</ul></li>
<li><p>对于多分类问题，使用Softmax和交叉熵损失的组合：</p>
<ul>
<li><p>公式：</p></li>
<li><p><span class="math display">\[
Categorical\ Cross-Entropy\ Loss = - \sum y_{true} * log(y_{pred})
\]</span></p></li>
</ul></li>
</ul></li>
</ul>
<h3 id="对比损失hinge-loss">3. <strong>对比损失（Hinge
Loss）</strong></h3>
<ul>
<li>主要用于支持向量机（SVM）等模型，目的是最大化分类边界。Hinge
Loss通过惩罚错误分类点来优化分类模型。</li>
<li>公式：<span class="math display">\[Hinge Loss = max(0, 1 - y_{true}
* y_{pred})\]</span></li>
</ul>
<h3 id="自定义损失函数">4. <strong>自定义损失函数</strong></h3>
<ul>
<li>在某些复杂场景中，标准的损失函数可能无法满足需求。此时，研究人员可以根据具体需求定义自适应的损失函数。</li>
</ul>
<p>通过最小化损失函数的值，模型可以逐渐提高其在数据上的表现。损失函数的选择应与任务类型及目标密切相关，从而能够准确反映模型性能。</p>
<h2 id="梯度下降">梯度下降</h2>
<h2 id="正则化">正则化</h2>
<h2 id="过拟合">过拟合</h2>
<h2 id="线性代数">线性代数</h2>
<h3 id="主对角线">主对角线</h3>
<p>即满足<span class="math display">\[a =
\{a_{i,j}|i=j\}\]</span>的元素构成的线，特殊的<span
class="math display">\[n\not =m\]</span></p>
<figure>
<img src="https://s2.loli.net/2024/06/10/7WA9zDuB2UYrlKF.png"
alt="image-20240609143044969" />
<figcaption aria-hidden="true">image-20240609143044969</figcaption>
</figure>
<h3 id="转置">转置</h3>
<p>即矩阵对主对角线的镜像，特俗的有<span class="math display">\[n\not =
m\]</span></p>
<figure>
<img src="https://s2.loli.net/2024/06/10/vtux96qNrkAH8jZ.png"
alt="image-20240609143213322" />
<figcaption aria-hidden="true">image-20240609143213322</figcaption>
</figure>
<h3 id="元素对应乘积hadamard-乘积">元素对应乘积（Hadamard 乘积）</h3>
<p>记为<span class="math display">\[A\odot B\]</span></p>
<h3 id="点积">点积</h3>
<p>两个相同维数的向量x和y的点积（dot product）可看作是矩阵乘积<span
class="math display">\[A^\top
B\]</span>​。我们可以把矩阵乘积C=AB中计算Cij的步骤看作是A的第i行和B的第j列之间的点积。</p>
<p>矩阵的乘法是不满足交换律的，但是矩阵的点积是满足的。 <span
class="math display">\[
x^\top y = y^\top x
\]</span></p>
<p>矩阵乘积转置的简单形式 <span class="math display">\[
(AB)^\top = B^\top A^\top
\]</span> 注意顺序是不能更改的因为矩阵乘法不满足交换律</p>
<h3 id="单位矩阵">单位矩阵</h3>
<p>单位矩阵指主对角线上的值都为1，其他地方都为零的矩阵。</p>
<p>我们将保持n维向量不变的单位矩阵记作<span
class="math display">\[I_n\]</span>。</p>
<h3 id="逆矩阵">逆矩阵</h3>
<p>很朴素的定义，需要注意的是由于矩阵乘法不满足交换律，因此我们再说一个矩阵的逆的时候通常是说矩阵的左逆。</p>
<p>对于方阵而言，它的左逆和右逆是相等的</p>
<h3 id="线性相关与生成子空间">线性相关与生成子空间</h3>
<p>如果逆矩阵<span
class="math display">\[A^{-1}\]</span>​存在。那么式(2.11)肯定对于每一个向量b恰好存在一个解。但是，对于方程组而言，对于向量b的某些值，有可能不存在解，或者存在无限多个解。存在多于一个解但是少于无限多个解的情况是不可能发生的；因为如果x和y都是某方程组的解，则x,y则构成了一个张成空间。</p>
<p>为了分析方程有多少个解，我们可以将A的列向量看作从原点（origin）（元素都是零的向量）出发的不同方向，确定有多少种方法可以到达向量b。在这个观点下，向量x中的每个元素表示我们应该沿着这些方向走多远，即xi表示我们需要沿着第i个向量的方向走多远：
<span class="math display">\[
Ax = \sum _i x_i A_{:,i}
\]</span>
这样的操作我们称为线性组合。形式上，一组向量的线性组合是指每个向量乘以对应标量系数之后的和，即：
<span class="math display">\[
\sum _i c_i v^{(i)}
\]</span>
一组向量的生成子空间（span）是原始向量线性组合后所能抵达的点的集合。</p>
<p>确定Ax=b是否有解相当于确定向量b是否在A列向量的生成子空间中。这个特殊的生成子空间被称为A的列空间（column
space）或者A的值域（range）。</p>
<p>为了使方程Ax=b对于任意向量<span class="math display">\[b\in
\mathbb{R}^m\]</span>都存在解，我们要求A的列空间构成整个<span
class="math display">\[\mathbb{R}^m\]</span>。如果<span
class="math display">\[\mathbb{R}^m\]</span>中的某个点不在A的列空间中，那么该点对应的b会使得该方程没有解。矩阵A的列空间是整个<span
class="math display">\[\mathbb{R}^m\]</span>的要求，意味着A至少有m列，即n&gt;=m。否则，A列空间的维数会小于m。例如，假设A是一个<span
class="math display">\[3\times
2\]</span>的矩阵。目标b是3维的，但是x只有2维。所以无论如何修改x的值，也只能描绘出<span
class="math display">\[\mathbb{R}^3\]</span>空间中的二维平面。当且仅当向量b在该二维平面中时，该方程有解。</p>
<p>不等式n&gt;=m仅是方程对每一点都有解的必要条件。这不是一个充分条件，因为有些列向量可能是冗余的。假设有一个<span
class="math display">\[\mathbb{R}^{2\times2}\]</span>中的矩阵，它的两个列向量是相同的。那么它的列空间和它的一个列向量作为矩阵的列空间是一样的。换言之，虽然该矩阵有2列，但是它的列空间仍然只是一条线，不能涵盖整个<span
class="math display">\[\mathbb{R}^2\]</span>空间。</p>
<p>正式地说，这种冗余被称为线性相关（linear
dependence）。如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为线性无关（linearly
independent）。如果某个向量是一组向量中某些向量的线性组合，那么我们将这个向量加入这组向量后不会增加这组向量的生成子空间。这意味着，如果一个矩阵的列空间涵盖整个<span
class="math display">\[\mathbb{R}^m\]</span>，那么该矩阵必须包含至少一组m个线性无关的向量。这是对于每一个向量b的取值都有解的充分必要条件。值得注意的是，这个条件是说该向量集恰好有m个线性无关的列向量，而不是至少m个。不存在一个m维向量的集合具有多于m个彼此线性不相关的列向量，但是一个有多于m个列向量的矩阵有可能拥有不止一个大小为m的线性无关向量集。</p>
<p>要想使矩阵可逆，我们还需要保证对于每一个b值至多有一个解。为此，我们需要确保该矩阵至多有m个列向量。否则，该方程会有不止一个解。</p>
<h3 id="奇异矩阵singular-square">奇异矩阵（singular square）</h3>
<p>该矩阵必须是一个方阵（square），即m=n，并且所有列向量都是线性无关的。一个列向量线性相关的方阵被称为奇异的（singular）。</p>
<h3 id="矩阵右乘">矩阵右乘</h3>
<p><span class="math display">\[
AA^{-1}=I
\]</span></p>
<h3 id="范数norm">范数（norm）</h3>
<p>用来衡量一个向量的大小。机器学习中常用范数衡量向量大小。形式上<span
class="math display">\[L^p\]</span>定义如下 <span
class="math display">\[
||x||_p = \left( \sum _i |x_i|^p \right) ^{\frac{1}{p}}
\]</span> 范数（包括Lp范数）是将向量映射到非负值的函数</p>
<p>严格的讲，范数是满足以下性质的函数</p>
<ul>
<li>f(x) = 0 =&gt; x=0</li>
<li>f(x+y) &lt;=f(x) + f(y) （三角不等式）</li>
<li>对<span class="math display">\[\forall \alpha \in
\mathbb{R},f(\alpha x) = |\alpha|f(x)\]</span></li>
</ul>
<p>当p= 2时，<span
class="math display">\[L^2\]</span>范数被称为欧几里得范数（Euclidean
norm）。它表示从原点出发到向量x确定的点的欧几里得距离。<span
class="math display">\[L^2\]</span>范数在机器学习中出现地十分频繁，经常简化表示为∥x∥，略去了下标2。平方<span
class="math display">\[L^2\]</span>范数也经常用来衡量向量的大小，可以简单地通过点积<span
class="math display">\[x ^\top x\]</span>计算。</p>
<p>但是在很多情况下，平方<span
class="math display">\[L^2\]</span>范数也可能不受欢迎，因为它在原点附近增长得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数：<span
class="math display">\[L^1\]</span>范数。<span
class="math display">\[L^1\]</span>范数可以简化如下： <span
class="math display">\[
||x||_1 = \sum _i |x_i|
\]</span>
有时候我们会统计向量中非零元素的个数来衡量向量的大小。有些作者将这种函数称为“<span
class="math display">\[L^0\]</span>范数’’，但是这个术语在数学意义上是不对的</p>
<p>另外一个经常在机器学习中出现的范数是<span
class="math display">\[L^\inf\]</span>范数，也被称为最大范数（maxnorm）。这个范数表示向量中具有最大幅值的元素的绝对值：
<span class="math display">\[
||x||_1 = \max _i |x_i|
\]</span>
有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用Frobenius范数（Frobenius
norm）， <span class="math display">\[
||A||_F = \sqrt{\sum _{i,j} A^2_{i,j}}
\]</span> 两个向量的点集可以用范数来表示，具体的 <span
class="math display">\[
x^\top y = ||x||_2 ||y||_2 cos\theta
\]</span> <span
class="math display">\[\theta\]</span>表示x,y之间的夹角</p>
<h3 id="对角矩阵">对角矩阵</h3>
<p>只在主对角线上含有非零元素，，其他位置都是零。用diag(<span
class="math display">\[v\]</span>)表示一个对角矩阵。</p>
<p>计算乘法diag(v)x，我们只需要将x中的每个元素xi放大vi倍。换言之，diag(v)x=v⊙x</p>
<p>对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，在这种情况下，diag(v)1=diag([1/v1;....
;1/vn]⊤)。</p>
<p>非方阵的对角矩阵没有逆矩阵</p>
<h3 id="对称矩阵">对称矩阵</h3>
<p>对称矩阵是矩阵的转置和自己相等的矩阵 <span class="math display">\[
A = A ^\top
\]</span></p>
<h3 id="单位矩阵-1">单位矩阵</h3>
<p>具有单位范数的矩阵</p>
<p>如果<span class="math display">\[x^\top
y=0\]</span>，那么向量x和向量y互相正交（orthogonal）。如果两个向量都有非零范数，那么这两个向量之间的夹角是90度。在Rn中，至多有n个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为1，那么我们称它们是标准正交（orthonormal）。</p>
<p>正交矩阵（orthogonal
matrix）是指行向量和列向量是分别标准正交的方阵，更具体的，他们是满足以下条件的矩阵
<span class="math display">\[
A^\top A = A ^\top A = I.
\]</span> 这样意味着 <span class="math display">\[
A^{-1} = A^\top
\]</span></p>
<h3 id="特征分解">特征分解</h3>
<p>特征分解（eigendecomposition）是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值。</p>
<p>方阵A的特征向量（eigenvector）是指与A相乘后相当于对该向量进行缩放的非零向量v：
<span class="math display">\[
A v = \lambda v
\]</span> 标量<span
class="math inline">\(\lambda\)</span>被称为这个特征向量对应的特征值（eigenvalue）。</p>
<p>（类似地，我们也可以定义左特征向量（left eigenvector）<span
class="math display">\[v^⊤A=\lambda
v^⊤\]</span>，但是通常我们更关注右特征向量（right eigenvector））。</p>
<p>所有特征值都是正数的矩阵被称为正定（positive
definite）；所有特征值都是非负数的矩阵被称为半正定（positive
semidefinite）。同样地，所有特征值都是负数的矩阵被称为负定（negative
definite）；所有特征值都是非正数的矩阵被称为半负定（negative
semidefinite）。</p>
<p>然而，我们也常常希望将矩阵分解（decompose）成特征值和特征向量。这样可以帮助我们分析矩阵的特定性质，就像质因数分解有助于我们理解整数。</p>
<p>矩阵A的特征分解可以记作 <span class="math display">\[
A = V diag(\lambda) V^{-1}
\]</span>
不是每一个矩阵都可以分解成特征值和特征向量。在某些情况下，特征分解存在，但是会涉及复数而非实数。</p>
<p>其中Q是A的特征向量组成的正交矩阵，是对角矩阵。特征值<span
class="math display">\[\lambda_{i;i}\]</span>对应的特征向量是矩阵Q的第i列，记作Q:;i。因为Q是正交矩阵，我们可以将A看作沿方向v(i)延展i倍的空间</p>
]]></content>
      <categories>
        <category>专题</category>
        <category>机器学习</category>
        <category>Mindspore</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MindSpore</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>MindSpore专题——第一章、安装</title>
    <url>/2024/special_subject/MindSpore/Chapters/First_Install/article.html</url>
    <content><![CDATA[<h2 id="Ubuntu系统安装"><a href="#Ubuntu系统安装" class="headerlink" title="Ubuntu系统安装"></a>Ubuntu系统安装</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p> VMware Workstation 17Pro</p>
<ol>
<li>原有的系统为Ubuntu22.04因此下载Ubuntu18.04 镜像光盘文件<ul>
<li>通过cat /proc/version文件查看当前的系统版本</li>
</ul>
</li>
</ol>
<span id="more"></span>
<p><img src="https://s2.loli.net/2024/06/04/9tNsqxUkrJFHQOc.png" alt="image-20240604174857507"></p>
<ol>
<li><p>下载Ubuntu18.04系统光盘<span class="exturl" data-url="aHR0cHM6Ly9yZWxlYXNlcy51YnVudHUuY29tLzE4LjA0L3VidW50dS0xOC4wNC42LWRlc2t0b3AtYW1kNjQuaXNv">https://releases.ubuntu.com/18.04/ubuntu-18.04.6-desktop-amd64.iso<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>VMware简易安装后对18旧版本遇到的问题的解决方案</p>
<ol>
<li>旧版本屏幕无法适应屏幕，想到vmwaretools的问题，检查该部分发现并未自动安装</li>
</ol>
</li>
</ol>
<p>通过重新启动挂载\VMware\VMware Workstation目录下linux.iso文件出现</p>
<p><img src="https://s2.loli.net/2024/06/06/IWioHYeLj9JgMtb.png" alt="image-20240604182654391"></p>
<p>安装该软件</p>
<p><img src="https://s2.loli.net/2024/06/04/vIXUHlWVx2sb1co.png" alt="image-20240604182901358"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo perl vmware-install.pl</span><br></pre></td></tr></table></figure>
<p>通过在解压的目录下运行该脚本文件安装vmware-tools</p>
<p><img src="https://s2.loli.net/2024/06/04/pJI4WAgKdYmvPES.png" alt="image-20240604183315457"></p>
<p>在经过一系列configure后安装完成</p>
<p>由此问题解决</p>
<pre><code> 2. update apt-get
</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update apt-get</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/06/04/9cXhEq3V2DMiWNx.png" alt="image-20240604184437693"></p>
<ol>
<li>修复vmware剪贴板不共享的问题</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>
<p>​    安装该软件一路回车即可</p>
<h2 id="尝试自动脚本安装"><a href="#尝试自动脚本安装" class="headerlink" title="尝试自动脚本安装"></a>尝试自动脚本安装</h2><p>由于vmware对nvdia的支持补全，此处采用版本如下</p>
<p><img src="https://s2.loli.net/2024/06/04/5e3IG9tuAPdfjKr.png" alt="image-20240604183528425"></p>
<p>进入默认源码目录进行操作</p>
<p><img src="https://s2.loli.net/2024/06/04/K8tqnFmeQuOMiZc.png" alt="image-20240604183616489"></p>
<p><img src="https://s2.loli.net/2024/06/04/d1YgnqUjbWJfXLH.png" alt="image-20240604185144770"></p>
<p>由于系统全新，设定一下系统密码并切换到root用户</p>
<p><img src="https://s2.loli.net/2024/06/04/KQiWzJtOUsS2mnT.png" alt="image-20240604185341858"></p>
<p>根据官网下载</p>
<p><img src="https://s2.loli.net/2024/06/04/g3BCMVGQHDzjAUL.png" alt="image-20240604185417980"></p>
<p>根据官网命令执行脚本</p>
<p><img src="https://s2.loli.net/2024/06/05/xBlJgjPwU3krsqa.png" alt="MindSpore安装成功"></p>
<p>可见安装成功</p>
<h2 id="Windows中安装MindSpore以及杂项"><a href="#Windows中安装MindSpore以及杂项" class="headerlink" title="Windows中安装MindSpore以及杂项"></a>Windows中安装MindSpore以及杂项</h2><ol>
<li>相似的安装程序，记得更改选定的官方安装脚本</li>
<li>Windows一般位于C:\Users\%USERNAME%\pip 目录下存在配置文件，可通过更改该配置文件修改镜像，在使用镜像中启用代理可能会导致满屏的飘红报错</li>
<li>对于MindSpore的前置软件安装而言，最重要易错的为Python的版本，建议多通过</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure>
<ol>
<li>查看当前版本，及时正确配置环境变量</li>
</ol>
]]></content>
      <categories>
        <category>专题</category>
        <category>机器学习</category>
        <category>Mindspore</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MindSpore</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>MindSpore专题——第五章、网络构建</title>
    <url>/2024/special_subject/MindSpore/Chapters/Fivth_ConstructNetwork/article.html</url>
    <content><![CDATA[<h2 id="网格构建"><a href="#网格构建" class="headerlink" title="网格构建"></a>网格构建</h2><p>神经网络模型是由神经网络层和Tensor操作构成的，<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5ubi5odG1s">mindspore.nn<i class="fa fa-external-link-alt"></i></span>提供了常见神经网络层的实现，在MindSpore中，<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5DZWxsLmh0bWw=">Cell<i class="fa fa-external-link-alt"></i></span>类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个<code>Cell</code>，它由不同的子<code>Cell</code>构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。</p>
<p>下面我们将构建一个用于Mnist数据集分类的神经网络模型。</p>
<span id="more"></span>
<h3 id="定义模型类"><a href="#定义模型类" class="headerlink" title="定义模型类"></a>定义模型类</h3><p>当我们定义神经网络时，可以继承<code>nn.Cell</code>类，在<code>__init__</code>方法中进行子Cell的实例化和状态管理，在<code>construct</code>方法中实现Tensor操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>(nn.Cell):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.flatten = nn.Flatten()</span><br><span class="line">        <span class="variable language_">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class="line">            nn.Dense(<span class="number">28</span>*<span class="number">28</span>, <span class="number">512</span>, weight_init=<span class="string">&quot;normal&quot;</span>, bias_init=<span class="string">&quot;zeros&quot;</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dense(<span class="number">512</span>, <span class="number">512</span>, weight_init=<span class="string">&quot;normal&quot;</span>, bias_init=<span class="string">&quot;zeros&quot;</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dense(<span class="number">512</span>, <span class="number">10</span>, weight_init=<span class="string">&quot;normal&quot;</span>, bias_init=<span class="string">&quot;zeros&quot;</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.flatten(x)</span><br><span class="line">        logits = <span class="variable language_">self</span>.dense_relu_sequential(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Network()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Network&lt;</span><br><span class="line">  (flatten): Flatten&lt;&gt;</span><br><span class="line">  (dense_relu_sequential): SequentialCell&lt;</span><br><span class="line">    (0): Dense&lt;input_channels=784, output_channels=512, has_bias=True&gt;</span><br><span class="line">    (1): ReLU&lt;&gt;</span><br><span class="line">    (2): Dense&lt;input_channels=512, output_channels=512, has_bias=True&gt;</span><br><span class="line">    (3): ReLU&lt;&gt;</span><br><span class="line">    (4): Dense&lt;input_channels=512, output_channels=10, has_bias=True&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们构造一个输入数据，直接调用模型，可以获得一个十维的Tensor输出，其包含每个类别的原始预测值。</p>
<p><strong><code>model.construct()</code>方法不可直接调用。</strong></p>
<p>这里出现了很多很抽象的概念好像一下子让机器学习变成了一个黑盒子，实际上，我们观察上面的代码，很容易可以从中看出一些结构来，下面记录一下我这个初学者的理解。</p>
<p>首先搬出一幅经典的图像</p>
<p><img src="https://s2.loli.net/2024/06/07/n358NwDPeSg1LsZ.jpg" alt="神经网络入门 - 阮一峰的网络日志"></p>
<p>这幅图形象的描述了上面的过程。其中</p>
<p><img src="https://s2.loli.net/2024/06/07/KgVFjZ6LTY54r1s.png" alt="image-20240607140358272"></p>
<p>这里开始的inputLayer就是我们的输入数据，中间连的密密麻麻的线就是上面结构输出中的Dense，可以观察到我们分别有<script type="math/tex">784\rightarrow 512\rightarrow512\rightarrow10</script>​四层这样的全连接。最初的784也和28*28对应了起来。即我们每一个像素点都是一个参数，为最初输入的一个点，最后输出的则是代表数字概率的10个参数，最终我们会选择一个最接近的参数。这里的变量名用logits（不确定是否标准，但这里是这么用的）</p>
<p>下面是一些展示调用的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = ops.ones((<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>), mindspore.float32)</span><br><span class="line">logits = model(X)</span><br><span class="line"><span class="comment"># print logits</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Tensor(logits))</span><br><span class="line">pred_probab = nn.Softmax(axis=<span class="number">1</span>)(logits)</span><br><span class="line">y_pred = pred_probab.argmax(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Predicted class: <span class="subst">&#123;y_pred&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>读者可以试着运行几次，由于给出数据全是1，代表全黑或全白。因此输出是杂乱的。但可以观察到，我们最终的预测值为最大的值的标签。</p>
<p>下面官网上给出了一些模型层次的解释，来看看。</p>
<h3 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h3><blockquote>
<p> 本节中我们分解上节构造的神经网络模型中的每一层。首先我们构造一个shape为(3, 28, 28)的随机数据（3个28x28的图像），依次通过每一个神经网络层来观察其效果。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input_image = ops.ones((3, 28, 28), mindspore.float32)</span><br><span class="line">print(input_image.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(3, 28, 28)</p>
</blockquote>
<h3 id="nn-Flatten"><a href="#nn-Flatten" class="headerlink" title="nn.Flatten"></a>nn.Flatten</h3><blockquote>
<p> 实例化<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5GbGF0dGVuLmh0bWw=">nn.Flatten<i class="fa fa-external-link-alt"></i></span>层，将28x28的2D张量转换为784大小的连续数组。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flatten = nn.Flatten()</span><br><span class="line">flat_image = flatten(input_image)</span><br><span class="line"><span class="built_in">print</span>(flat_image.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(3, 784)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里可见flatten打平只是打平第一维以外即输入数据样例外的维度，如果说初始数据是一个结构体数组，那Flatten的作用就是将其变为一个一维数组的数组。</p>
<h3 id="nn-Dense"><a href="#nn-Dense" class="headerlink" title="nn.Dense"></a>nn.Dense</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5EZW5zZS5odG1s">nn.Dense<i class="fa fa-external-link-alt"></i></span>为全连接层，其使用权重和偏差对输入进行线性变换。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layer1 = nn.Dense(in_channels=28*28, out_channels=20)</span><br><span class="line">hidden1 = layer1(flat_image)</span><br><span class="line">print(hidden1.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(3, 20)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里注意到有两个额外的参数即权重和偏差。也就是说下面每一层的节点就是上一层节点的带权和加上一个常数。</p>
<h3 id="nn-ReLU"><a href="#nn-ReLU" class="headerlink" title="nn.ReLU"></a>nn.ReLU</h3><blockquote>
<p> <span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5SZUxVLmh0bWw=">nn.ReLU<i class="fa fa-external-link-alt"></i></span>层给网络中加入非线性的激活函数，帮助神经网络学习各种复杂的特征。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Before ReLU: <span class="subst">&#123;hidden1&#125;</span>\n\n&quot;</span>)</span><br><span class="line">hidden1 = nn.ReLU()(hidden1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;After ReLU: <span class="subst">&#123;hidden1&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Before ReLU: [[-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class="line">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class="line">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class="line">  -0.10083733  0.05171938]</span><br><span class="line"> [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class="line">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class="line">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class="line">  -0.10083733  0.05171938]</span><br><span class="line"> [-0.04736331  0.2939465  -0.02713677 -0.30988005 -0.11504349 -0.11661264</span><br><span class="line">   0.18007928  0.43213072  0.12091967 -0.17465964  0.53133243  0.12605792</span><br><span class="line">   0.01825903  0.01287796  0.17238477 -0.1621131  -0.0080034  -0.24523425</span><br><span class="line">  -0.10083733  0.05171938]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">After ReLU: [[0.         0.2939465  0.         0.         0.         0.</span><br><span class="line">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class="line">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class="line">  0.         0.05171938]</span><br><span class="line"> [0.         0.2939465  0.         0.         0.         0.</span><br><span class="line">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class="line">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class="line">  0.         0.05171938]</span><br><span class="line"> [0.         0.2939465  0.         0.         0.         0.</span><br><span class="line">  0.18007928 0.43213072 0.12091967 0.         0.53133243 0.12605792</span><br><span class="line">  0.01825903 0.01287796 0.17238477 0.         0.         0.</span><br><span class="line">  0.         0.05171938]]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意到，这里首次提出非线性运算的概念，也就是说，在这之前，运算都是线性的，这一步显然比较复杂，也不谈论。</p>
<h3 id="nn-SequentialCell"><a href="#nn-SequentialCell" class="headerlink" title="nn.SequentialCell"></a>nn.SequentialCell</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5TZXF1ZW50aWFsQ2VsbC5odG1s">nn.SequentialCell<i class="fa fa-external-link-alt"></i></span>是一个有序的Cell容器。输入Tensor将按照定义的顺序通过所有Cell。我们可以使用<code>SequentialCell</code>来快速组合构造一个神经网络模型。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq_modules = nn.SequentialCell(</span><br><span class="line">    flatten,</span><br><span class="line">    layer1,</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Dense(<span class="number">20</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logits = seq_modules(input_image)</span><br><span class="line"><span class="built_in">print</span>(logits.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(3, 10)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意看代码，对于这里的代码最好都不要跳过，也不要深究实现原理（新手），可见这里依次调用了上面的所有步骤，是对这一流程的封装。</p>
<h3 id="nn-Softmax"><a href="#nn-Softmax" class="headerlink" title="nn.Softmax"></a>nn.Softmax</h3><blockquote>
<p> 最后使用<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5Tb2Z0bWF4Lmh0bWw=">nn.Softmax<i class="fa fa-external-link-alt"></i></span>将神经网络最后一个全连接层返回的logits的值缩放为[0, 1]，表示每个类别的预测概率。<code>axis</code>指定的维度数值和为1。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">softmax = nn.Softmax(axis=1)</span><br><span class="line">pred_probab = softmax(logits)</span><br></pre></td></tr></table></figure>
<p>官网文档已经非常清楚了。还有不懂可以跑跑代码</p>
<h2 id="模型参数"><a href="#模型参数" class="headerlink" title="模型参数"></a>模型参数</h2><blockquote>
<p>网络内部神经网络层具有权重参数和偏置参数（如<code>nn.Dense</code>），这些参数会在训练过程中不断进行优化，可通过 <code>model.parameters_and_names()</code> 来获取参数名及对应的参数详情。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Model structure: <span class="subst">&#123;model&#125;</span>\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> model.parameters_and_names():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Layer: <span class="subst">&#123;name&#125;</span>\nSize: <span class="subst">&#123;param.shape&#125;</span>\nValues : <span class="subst">&#123;param[:<span class="number">2</span>]&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>通过这一代码可以查看权重参数和偏置参数，这一代码应该是十分常见并且常用的。</p>
]]></content>
      <categories>
        <category>专题</category>
        <category>机器学习</category>
        <category>Mindspore</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MindSpore</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>MindSpore专题——第四章、数据集</title>
    <url>/2024/special_subject/MindSpore/Chapters/Fourth_DataSet/article.html</url>
    <content><![CDATA[<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>继续<a href="./Second_TryMindSpore.md">第二章</a>中的Mnist数据库为例，介绍使用mindspore.dataset进行加载的方法。</p>
<p>详情请见MNIST数据官方网站：<span class="exturl" data-url="aHR0cDovL3lhbm4ubGVjdW4uY29tL2V4ZGIvbW5pc3Qv">MNIST handwritten digit database, Yann LeCun, Corinna Cortes and Chris Burges<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p>下面是简略介绍</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数据集</th>
<th style="text-align:center">MNIST中的文件名</th>
<th style="text-align:center">下载地址</th>
<th style="text-align:center">文件大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">训练集图像</td>
<td style="text-align:center">train-images-idx3-ubyte.gz</td>
<td style="text-align:center"><span class="exturl" data-url="aHR0cDovL3lhbm4ubGVjdW4uY29tL2V4ZGIvbW5pc3QvdHJhaW4taW1hZ2VzLWlkeDMtdWJ5dGUuZ3o=">http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz<i class="fa fa-external-link-alt"></i></span></td>
<td style="text-align:center">9912422字节</td>
</tr>
<tr>
<td style="text-align:center">训练集标签</td>
<td style="text-align:center">train-labels-idx1-ubyte.gz</td>
<td style="text-align:center"><span class="exturl" data-url="aHR0cDovL3lhbm4ubGVjdW4uY29tL2V4ZGIvbW5pc3QvdHJhaW4tbGFiZWxzLWlkeDEtdWJ5dGUuZ3o=">http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz<i class="fa fa-external-link-alt"></i></span></td>
<td style="text-align:center">28881字节</td>
</tr>
<tr>
<td style="text-align:center">测试集图像</td>
<td style="text-align:center">t10k-images-idx3-ubyte.gz</td>
<td style="text-align:center"><span class="exturl" data-url="aHR0cDovL3lhbm4ubGVjdW4uY29tL2V4ZGIvbW5pc3QvdDEway1pbWFnZXMtaWR4My11Ynl0ZS5neg==">http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz<i class="fa fa-external-link-alt"></i></span></td>
<td style="text-align:center">1648877字节</td>
</tr>
<tr>
<td style="text-align:center">测试集标签</td>
<td style="text-align:center">t10k-labels-idx1-ubyte.gz</td>
<td style="text-align:center"><span class="exturl" data-url="aHR0cDovL3lhbm4ubGVjdW4uY29tL2V4ZGIvbW5pc3QvdDEway1sYWJlbHMtaWR4MS11Ynl0ZS5neg==">http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz<i class="fa fa-external-link-alt"></i></span></td>
<td style="text-align:center">4542字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据库加载"><a href="#数据库加载" class="headerlink" title="数据库加载"></a>数据库加载</h3><p><em>请注意：mindspore.dataset的接口仅支持解压后的数据文件</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_dataset = MnistDataset(<span class="string">&quot;MNIST_Data/train&quot;</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(train_dataset))</span><br></pre></td></tr></table></figure>
<blockquote>
<class 'mindspore.dataset.engine.datasets_vision.MnistDataset'>

</blockquote>
<h3 id="数据库迭代"><a href="#数据库迭代" class="headerlink" title="数据库迭代"></a>数据库迭代</h3><p>数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。我们可以用<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfdHVwbGVfaXRlcmF0b3IuaHRtbA==">create_tuple_iterator<i class="fa fa-external-link-alt"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfZGljdF9pdGVyYXRvci5odG1s">create_dict_iterator<i class="fa fa-external-link-alt"></i></span>接口创建数据迭代器，迭代访问数据。访问的数据类型默认为<code>Tensor</code>；若设置<code>output_numpy=True</code>，访问的数据类型为<code>Numpy</code>。</p>
<p>下面定义一个可视化函数，迭代9张图片进行展示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">visualize</span>(<span class="params">dataset</span>):</span><br><span class="line">    figure = plt.figure(figsize=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">    cols, rows = <span class="number">3</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    plt.subplots_adjust(wspace=<span class="number">0.5</span>, hspace=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, (image, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class="line">        figure.add_subplot(rows, cols, idx + <span class="number">1</span>)</span><br><span class="line">        plt.title(<span class="built_in">int</span>(label))</span><br><span class="line">        plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">        plt.imshow(image.asnumpy().squeeze(), cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> idx == cols * rows - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>在<code>for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):</code>此处的循环中枚举了训练集的前9个图像<code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p>
<p>在循环体中使用了plt类画图。</p>
<p><img src="https://s2.loli.net/2024/06/06/36CU8spH9eSEkxl.png" alt="image-20240606173353887"></p>
<h3 id="数据集常用操作"><a href="#数据集常用操作" class="headerlink" title="数据集常用操作"></a>数据集常用操作</h3><p>Pipeline的设计理念使得数据集的常用操作采用<code>dataset = dataset.operation()</code>的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。</p>
<p>下面分别介绍几种常见的数据集操作。</p>
<h3 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h3><p>数据集随机<code>shuffle</code>可以消除数据排列造成的分布不均问题</p>
<p><img src="https://s2.loli.net/2024/06/06/M54ICySt9dzenva.png" alt="op-shuffle"></p>
<p><code>mindspore.dataset</code>提供的数据集在加载时可配置<code>shuffle=True</code>，或使用如下操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_dataset = train_dataset.shuffle(buffer_size=<span class="number">64</span>)</span><br><span class="line">visualize(train_dataset)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/06/06/yB76TmklvtYXIgE.png" alt="image-20240606173414784"></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code>操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image, label = <span class="built_in">next</span>(train_dataset.create_tuple_iterator())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;map前：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(image.shape, image.dtype)</span><br><span class="line">train_dataset = train_dataset.<span class="built_in">map</span>(vision.Rescale(<span class="number">1.0</span> / <span class="number">255.0</span>, <span class="number">0</span>), input_columns=<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">image, label = <span class="built_in">next</span>(train_dataset.create_tuple_iterator())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;map后：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(image.shape, image.dtype)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map前：</span><br><span class="line">(28, 28, 1) UInt8</span><br><span class="line">map后：</span><br><span class="line">(28, 28, 1) Float32</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="batch"><a href="#batch" class="headerlink" title="batch"></a>batch</h3><p>将数据集打包为固定大小的<code>batch</code>是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。分块思想</p>
<p>一般我们会设置一个固定的batch size，将连续的数据分为若干批（batch）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般设定固定batchSize</span></span><br><span class="line">train_dataset = train_dataset.batch(batch_size=<span class="number">32</span>)</span><br><span class="line"><span class="comment"># batch后的数据增加一维，大小为batch_size</span></span><br><span class="line">image, label = <span class="built_in">next</span>(train_dataset.create_tuple_iterator())</span><br><span class="line"><span class="built_in">print</span>(image.shape, image.dtype)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(32, 28, 28, 1) Float32</p>
</blockquote>
<h3 id="自定义数据集"><a href="#自定义数据集" class="headerlink" title="自定义数据集"></a>自定义数据集</h3><p><code>mindspore.dataset</code>模块提供了一些常用的公开数据集和标准格式数据集的加载API。</p>
<p>对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过<code>GeneratorDataset</code>接口实现自定义方式的数据集加载。</p>
<p><code>GeneratorDataset</code>支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。</p>
<h4 id="可随机访问数据集"><a href="#可随机访问数据集" class="headerlink" title="可随机访问数据集"></a>可随机访问数据集</h4><p>可随机访问数据集是实现了<code>__getitem__</code>和<code>__len__</code>方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。</p>
<ol>
<li>实现了<code>__init__</code>，<code>__getitem__</code> 和<code>__len__</code></li>
<li>当使用<code>dataset[idx]</code>访问这样的数据集时，可以读取dataset内容中第idx个样本或标签</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Random-accessible object as input source</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomAccessDataset</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>._data = np.ones((<span class="number">5</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="variable language_">self</span>._label = np.zeros((<span class="number">5</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data[index], <span class="variable language_">self</span>._label[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loader = RandomAccessDataset()</span><br><span class="line">dataset = GeneratorDataset(source=loader, column_names=[<span class="string">&quot;data&quot;</span>, <span class="string">&quot;label&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataset:</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    </span><br><span class="line">loader = [np.array(<span class="number">0</span>), np.array(<span class="number">1</span>), np.array(<span class="number">2</span>)]</span><br><span class="line">dataset = GeneratorDataset(source=loader, column_names=[<span class="string">&quot;data&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataset:</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]<br>[Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]<br>[Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]<br>[Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]<br>[Tensor(shape=[2], dtype=Float64, value= [ 1.00000000e+00,  1.00000000e+00]), Tensor(shape=[1], dtype=Float64, value= [ 0.00000000e+00])]</p>
</blockquote>
<p>创建的过程非常简单，通过numpy的数据结构为底层，实现三个方法就好了，更简单的直接使用list，tuple也是可行的。</p>
<h4 id="可迭代数据集"><a href="#可迭代数据集" class="headerlink" title="可迭代数据集"></a>可迭代数据集</h4><p>可迭代的数据集是实现了<code>__iter__</code>和<code>__next__</code>方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。</p>
<p>例如，当使用<code>iter(dataset)</code>的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。</p>
<p>下面构造一个简单迭代器，并将其加载至<code>GeneratorDataset</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Iterator as input source</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IterableDataset</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, end</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;init the class object to hold the data&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="variable language_">self</span>.start = start</span><br><span class="line">        <span class="variable language_">self</span>.end = end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;iter one data and return&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>(<span class="variable language_">self</span>.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;reset the iter&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="variable language_">self</span>.data = <span class="built_in">iter</span>(<span class="built_in">range</span>(<span class="variable language_">self</span>.start, <span class="variable language_">self</span>.end))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loader = IterableDataset(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">dataset = GeneratorDataset(source=loader, column_names=[<span class="string">&quot;data&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> dataset:</span><br><span class="line">    <span class="built_in">print</span>(d)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[Tensor(shape=[], dtype=Int32, value= 1)]<br>[Tensor(shape=[], dtype=Int32, value= 2)]<br>[Tensor(shape=[], dtype=Int32, value= 3)]<br>[Tensor(shape=[], dtype=Int32, value= 4)]</p>
</blockquote>
<p>同样的，实现方法即可</p>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型<code>generator</code>返回数据，直至生成器抛出<code>StopIteration</code>异常。</p>
<p>下面构造一个生成器，并将其加载至<code>GeneratorDataset</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator</span>(<span class="params">start, end</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># since a generator instance can be only iterated once, we need to wrap it by lambda to generate multiple instances</span></span><br><span class="line">dataset = GeneratorDataset(source=<span class="keyword">lambda</span>: my_generator(<span class="number">3</span>, <span class="number">6</span>), column_names=[<span class="string">&quot;data&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> dataset:</span><br><span class="line">    <span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[Tensor(shape=[], dtype=Int32, value= 3)]<br>[Tensor(shape=[], dtype=Int32, value= 4)]<br>[Tensor(shape=[], dtype=Int32, value= 5)]</p>
</blockquote>
<p>这个更绝，仅用一个函数即可生成。（此处匿不匿名无关紧要）</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>找不到模块 matplotlib</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专题</category>
        <category>机器学习</category>
        <category>Mindspore</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MindSpore</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>MindSpore专题</title>
    <url>/2024/special_subject/MindSpore/Chapters/Second_TryMindSpore/article.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4zLjByYzIvYmVnaW5uZXIvcXVpY2tfc3RhcnQuaHRtbA==">MindSpore<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h2 id="MindSpore-数据处理"><a href="#MindSpore-数据处理" class="headerlink" title="MindSpore 数据处理"></a>MindSpore 数据处理</h2><h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install download</span><br></pre></td></tr></table></figure>
<p>下载download python模块</p>
<h3 id="引包并下载所需数据集"><a href="#引包并下载所需数据集" class="headerlink" title="引包并下载所需数据集"></a>引包并下载所需数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mindspore</span><br><span class="line"><span class="keyword">from</span> mindspore <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> mindspore.dataset <span class="keyword">import</span> vision, transforms</span><br><span class="line"><span class="keyword">from</span> mindspore.dataset <span class="keyword">import</span> MnistDataset</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Download data from open datasets</span></span><br><span class="line"><span class="keyword">from</span> download <span class="keyword">import</span> download</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&quot;</span> \</span><br><span class="line">      <span class="string">&quot;notebook/datasets/MNIST_Data.zip&quot;</span></span><br><span class="line">path = download(url, <span class="string">&quot;./&quot;</span>, kind=<span class="string">&quot;zip&quot;</span>, replace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/06/05/EuK87I6YUjdAs2v.png" alt="image-20240605204942126"></p>
<p>下载下来MNIST_Data数据，根据官网这是一份Mnist数据集，结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MNIST_Data</span><br><span class="line">└── train</span><br><span class="line">    ├── train-images-idx3-ubyte (60000个训练图片)</span><br><span class="line">    ├── train-labels-idx1-ubyte (60000个训练标签)</span><br><span class="line">└── test</span><br><span class="line">    ├── t10k-images-idx3-ubyte (10000个测试图片)</span><br><span class="line">    ├── t10k-labels-idx1-ubyte (10000个测试标签)</span><br></pre></td></tr></table></figure>
<h3 id="MindSpore数据处理"><a href="#MindSpore数据处理" class="headerlink" title="MindSpore数据处理"></a>MindSpore数据处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(train_dataset.get_col_names())</span><br></pre></td></tr></table></figure>
<p>打印数据集中所包含的数据列名</p>
<blockquote>
<p>MindSpore的dataset使用数据处理流水线（Data Processing Pipeline），需指定map、batch、shuffle等操作。这里我们使用map对图像数据及标签进行变换处理，将输入的图像缩放为1/255，根据均值0.1307和标准差值0.3081进行归一化处理，然后将处理好的数据集打包为大小为64的batch。</p>
</blockquote>
<p>上面是官网对以下代码的处理。</p>
<p>其中出现了一个新名词——<a href="#归一化处理">归一化处理</a>，这里使用的是Z-score normalization。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">datapipe</span>(<span class="params">dataset, batch_size</span>):</span><br><span class="line">    image_transforms = [</span><br><span class="line">        vision.Rescale(<span class="number">1.0</span> / <span class="number">255.0</span>, <span class="number">0</span>),</span><br><span class="line">        vision.Normalize(mean=(<span class="number">0.1307</span>,), std=(<span class="number">0.3081</span>,)),</span><br><span class="line">        vision.HWC2CHW()</span><br><span class="line">    ]</span><br><span class="line">    label_transform = transforms.TypeCast(mindspore.int32)</span><br><span class="line"></span><br><span class="line">    dataset = dataset.<span class="built_in">map</span>(image_transforms, <span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    dataset = dataset.<span class="built_in">map</span>(label_transform, <span class="string">&#x27;label&#x27;</span>)</span><br><span class="line">    dataset = dataset.batch(batch_size)</span><br><span class="line">    <span class="keyword">return</span> dataset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Map vision transforms and batch dataset</span></span><br><span class="line">train_dataset = datapipe(train_dataset, <span class="number">64</span>)</span><br><span class="line">test_dataset = datapipe(test_dataset, <span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<hr>
<p>可使用<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfdHVwbGVfaXRlcmF0b3IuaHRtbA==">create_tuple_iterator<i class="fa fa-external-link-alt"></i></span> 或<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL2RhdGFzZXQvZGF0YXNldF9tZXRob2QvaXRlcmF0b3IvbWluZHNwb3JlLmRhdGFzZXQuRGF0YXNldC5jcmVhdGVfZGljdF9pdGVyYXRvci5odG1s">create_dict_iterator<i class="fa fa-external-link-alt"></i></span>对数据集进行迭代访问，查看数据和标签的shape和datatype。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> image, label <span class="keyword">in</span> test_dataset.create_tuple_iterator():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shape of image [N, C, H, W]: <span class="subst">&#123;image.shape&#125;</span> <span class="subst">&#123;image.dtype&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shape of label: <span class="subst">&#123;label.shape&#125;</span> <span class="subst">&#123;label.dtype&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32<br>Shape of label: (64,) Int32</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> test_dataset.create_dict_iterator():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shape of image [N, C, H, W]: <span class="subst">&#123;data[<span class="string">&#x27;image&#x27;</span>].shape&#125;</span> <span class="subst">&#123;data[<span class="string">&#x27;image&#x27;</span>].dtype&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shape of label: <span class="subst">&#123;data[<span class="string">&#x27;label&#x27;</span>].shape&#125;</span> <span class="subst">&#123;data[<span class="string">&#x27;label&#x27;</span>].dtype&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Shape of image [N, C, H, W]: (64, 1, 28, 28) Float32<br>Shape of label: (64,) Int32</p>
</blockquote>
<p>更多细节详见<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL2RhdGFzZXQuaHRtbA==">数据集 Dataset<i class="fa fa-external-link-alt"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RyYW5zZm9ybXMuaHRtbA==">数据变换 Transforms<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="网络构建"><a href="#网络构建" class="headerlink" title="网络构建"></a>网络构建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define model</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>(nn.Cell):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.flatten = nn.Flatten()</span><br><span class="line">        <span class="variable language_">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class="line">            nn.Dense(<span class="number">28</span>*<span class="number">28</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dense(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dense(<span class="number">512</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.flatten(x)</span><br><span class="line">        logits = <span class="variable language_">self</span>.dense_relu_sequential(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line">model = Network()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Network&lt;<br>  (flatten): Flatten&lt;&gt;<br>  (dense_relu_sequential): SequentialCell&lt;<br>    (0): Dense<input_channels=784, output_channels=512, has_bias=True><br>    (1): ReLU&lt;&gt;<br>    (2): Dense<input_channels=512, output_channels=512, has_bias=True><br>    (3): ReLU&lt;&gt;<br>    (4): Dense<input_channels=512, output_channels=10, has_bias=True><br>    &gt;</p>
</blockquote>
<p>以上为网格的构建以及其输出，有以下几点需要注意</p>
<ol>
<li>上面重命名过MindSpore中的nn类是构建所有网格的基类，也是网格的基本单元</li>
<li>当需要自定义网络时可以重写<code>`nn.Cell</code>类重写<code>__init__</code>方法和<code>construct</code>方法</li>
<li><code>__init__</code>包含所有网络层的定义<code>construct</code>中包含数据（<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RlbnNvci5odG1s">Tensor<i class="fa fa-external-link-alt"></i></span>）的变换过程</li>
</ol>
<blockquote>
<p><code>mindspore.nn</code>类是构建所有网络的基类，也是网络的基本单元。当用户需要自定义网络时，可以继承<code>nn.Cell</code>类，并重写<code>__init__</code>方法和<code>construct</code>方法。<code>__init__</code>包含所有网络层的定义，<code>construct</code>中包含数据（<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RlbnNvci5odG1s">Tensor<i class="fa fa-external-link-alt"></i></span>）的变换过程。</p>
</blockquote>
<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>个人菜狗形象的想，实际上这里的网格神经网络对图像的识别类似一种带指向的可变哈希函数（只不过这个函数的实现比较复杂和通用）。他是从大量信息到小量准确抽象的描述过程。下面是<span class="exturl" data-url="aHR0cHM6Ly9vcGVubWxzeXMuZ2l0aHViLmlvL2NoYXB0ZXJfcHJvZ3JhbW1pbmdfaW50ZXJmYWNlL21sX3dvcmtmbG93Lmh0bWw=">3.2. 机器学习工作流 — 机器学习系统：设计和实现 1.0.0 documentation (openmlsys.github.io)<i class="fa fa-external-link-alt"></i></span>手册上的机器学习流程图，这里以求形象的理解</p>
<p><img src="./../img/img_workflow.svg" alt="img_workflow"></p>
<blockquote>
<p>在模型训练中，一个完整的训练过程（step）需要实现以下三步：</p>
<ol>
<li><strong>正向计算</strong>：模型预测结果（logits），并与正确标签（label）求预测损失（loss）。</li>
<li><strong>反向传播</strong>：利用自动微分机制，自动求模型参数（parameters）对于loss的梯度（gradients）。</li>
<li><strong>参数优化</strong>：将梯度更新到参数上。</li>
</ol>
<p>MindSpore使用函数式自动微分机制，因此针对上述步骤需要实现：</p>
<ol>
<li>定义正向计算函数。</li>
<li>使用<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUudmFsdWVfYW5kX2dyYWQuaHRtbA==">value_and_grad<i class="fa fa-external-link-alt"></i></span>通过函数变换获得梯度计算函数。</li>
<li>定义训练函数，使用<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL25uL21pbmRzcG9yZS5ubi5DZWxsLmh0bWwjbWluZHNwb3JlLm5uLkNlbGwuc2V0X3RyYWlu">set_train<i class="fa fa-external-link-alt"></i></span>设置为训练模式，执行正向计算、反向传播和参数优化。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Instantiate loss function and optimizer</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = nn.SGD(model.trainable_params(), <span class="number">1e-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Define forward function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward_fn</span>(<span class="params">data, label</span>):</span><br><span class="line">    logits = model(data)</span><br><span class="line">    loss = loss_fn(logits, label)</span><br><span class="line">    <span class="keyword">return</span> loss, logits</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Get gradient function</span></span><br><span class="line">grad_fn = mindspore.value_and_grad(forward_fn, <span class="literal">None</span>, optimizer.parameters, has_aux=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Define function of one-step training</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_step</span>(<span class="params">data, label</span>):</span><br><span class="line">    (loss, _), grads = grad_fn(data, label)</span><br><span class="line">    optimizer(grads)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">model, dataset</span>):</span><br><span class="line">    size = dataset.get_dataset_size()</span><br><span class="line">    model.set_train()</span><br><span class="line">    <span class="keyword">for</span> batch, (data, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class="line">        loss = train_step(data, label)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            loss, current = loss.asnumpy(), batch</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;loss: <span class="subst">&#123;loss:&gt;7f&#125;</span>  [<span class="subst">&#123;current:&gt;3d&#125;</span>/<span class="subst">&#123;size:&gt;3d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除训练外，我们定义测试函数，用来评估模型的性能。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">model, dataset, loss_fn</span>):</span><br><span class="line">    num_batches = dataset.get_dataset_size()</span><br><span class="line">    model.set_train(<span class="literal">False</span>)</span><br><span class="line">    total, test_loss, correct = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, label <span class="keyword">in</span> dataset.create_tuple_iterator():</span><br><span class="line">        pred = model(data)</span><br><span class="line">        total += <span class="built_in">len</span>(data)</span><br><span class="line">        test_loss += loss_fn(pred, label).asnumpy()</span><br><span class="line">        correct += (pred.argmax(<span class="number">1</span>) == label).asnumpy().<span class="built_in">sum</span>()</span><br><span class="line">    test_loss /= num_batches</span><br><span class="line">    correct /= total</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Test: \n Accuracy: <span class="subst">&#123;(<span class="number">100</span>*correct):&gt;<span class="number">0.1</span>f&#125;</span>%, Avg loss: <span class="subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epochs = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;t+<span class="number">1</span>&#125;</span>\n-------------------------------&quot;</span>)</span><br><span class="line">    train(model, train_dataset)</span><br><span class="line">    test(model, test_dataset, loss_fn)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Epoch 1</span><br><span class="line">&gt;-------------------------------</span><br><span class="line">&gt;loss: 2.302088  [  0/938]</span><br><span class="line">&gt;loss: 2.290692  [100/938]</span><br><span class="line">&gt;loss: 2.266338  [200/938]</span><br><span class="line">&gt;loss: 2.205240  [300/938]</span><br><span class="line">&gt;loss: 1.907198  [400/938]</span><br><span class="line">&gt;loss: 1.455603  [500/938]</span><br><span class="line">&gt;loss: 0.861103  [600/938]</span><br><span class="line">&gt;loss: 0.767219  [700/938]</span><br><span class="line">&gt;loss: 0.422253  [800/938]</span><br><span class="line">&gt;loss: 0.513922  [900/938]</span><br><span class="line">&gt;Test:</span><br><span class="line">Accuracy: 83.8%, Avg loss: 0.529534</span><br><span class="line"></span><br><span class="line">&gt;Epoch 2</span><br><span class="line">&gt;-------------------------------</span><br><span class="line">&gt;loss: 0.580867  [  0/938]</span><br><span class="line">&gt;loss: 0.479347  [100/938]</span><br><span class="line">&gt;loss: 0.677991  [200/938]</span><br><span class="line">&gt;loss: 0.550141  [300/938]</span><br><span class="line">&gt;loss: 0.226565  [400/938]</span><br><span class="line">&gt;loss: 0.314738  [500/938]</span><br><span class="line">&gt;loss: 0.298739  [600/938]</span><br><span class="line">&gt;loss: 0.459540  [700/938]</span><br><span class="line">&gt;loss: 0.332978  [800/938]</span><br><span class="line">&gt;loss: 0.406709  [900/938]</span><br><span class="line">&gt;Test:</span><br><span class="line">Accuracy: 90.2%, Avg loss: 0.334828</span><br><span class="line"></span><br><span class="line">&gt;Epoch 3</span><br><span class="line">&gt;-------------------------------</span><br><span class="line">&gt;loss: 0.461890  [  0/938]</span><br><span class="line">&gt;loss: 0.242303  [100/938]</span><br><span class="line">&gt;loss: 0.281414  [200/938]</span><br><span class="line">&gt;loss: 0.207835  [300/938]</span><br><span class="line">&gt;loss: 0.206000  [400/938]</span><br><span class="line">&gt;loss: 0.409646  [500/938]</span><br><span class="line">&gt;loss: 0.193608  [600/938]</span><br><span class="line">&gt;loss: 0.217575  [700/938]</span><br><span class="line">&gt;loss: 0.212817  [800/938]</span><br><span class="line">&gt;loss: 0.202862  [900/938]</span><br><span class="line">&gt;Test:</span><br><span class="line">Accuracy: 91.9%, Avg loss: 0.280962</span><br><span class="line"></span><br><span class="line">&gt;Done!</span><br></pre></td></tr></table></figure>
<p>训练过程需多次迭代数据集，一次完整的迭代称为一轮（epoch）。在每一轮，遍历训练集进行训练，结束后使用测试集进行预测。打印每一轮的loss值和预测准确率（Accuracy），可以看到loss在不断下降，Accuracy在不断提高。</p>
</blockquote>
<h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><p>模型训练完成后，需要将其参数进行保存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Save checkpoint</span></span><br><span class="line">mindspore.save_checkpoint(model, <span class="string">&quot;model.ckpt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Saved Model to model.ckpt&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Saved Model to model.ckpt</p>
</blockquote>
<h3 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h3><blockquote>
<p>加载保存的权重分为两步：</p>
<ol>
<li>重新实例化模型对象，构造模型。</li>
<li>加载模型参数，并将其加载至模型上。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Instantiate a random initialized model</span></span><br><span class="line">model = Network()</span><br><span class="line"><span class="comment"># Load checkpoint and load parameter to model</span></span><br><span class="line">param_dict = mindspore.load_checkpoint(<span class="string">&quot;model.ckpt&quot;</span>)</span><br><span class="line">param_not_load, _ = mindspore.load_param_into_net(model, param_dict)</span><br><span class="line"><span class="built_in">print</span>(param_not_load)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>param_not_load未被加载的参数列表，为空时代表所有参数均加载成功。</code></p>
<p>加载后的模型可以直接用于预测推理。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.set_train(<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">for</span> data, label <span class="keyword">in</span> test_dataset:</span><br><span class="line">    pred = model(data)</span><br><span class="line">    predicted = pred.argmax(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Predicted: &quot;<span class="subst">&#123;predicted[:<span class="number">10</span>]&#125;</span>&quot;, Actual: &quot;<span class="subst">&#123;label[:<span class="number">10</span>]&#125;</span>&quot;&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>以上就是一个简单的图像识别机械学习</p>
<p><strong>注意在加载模型的过程中必须定义模型构建与datapipe</strong></p>
<h2 id="归一化处理"><a href="#归一化处理" class="headerlink" title="归一化处理"></a>归一化处理</h2><blockquote>
<p>一些传送门：<br><span class="exturl" data-url="aHR0cHM6Ly9wYWRkbGVwZWRpYS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvdHV0b3JpYWxzL2RlZXBfbGVhcm5pbmcvbm9ybWFsaXphdGlvbi9iYXNpY19ub3JtYWxpemF0aW9uLmh0bWw=">归一化基础知识点 — PaddleEdu documentation (paddlepedia.readthedocs.io)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nZWVrLWRvY3MuY29tL251bXB5L251bXB5LWFzay1hbnN3ZXIvbm9ybWFsaXplLW51bXB5LWFycmF5X3oxLmh0bWw=">Numpy数组归一化|极客教程 (geek-docs.com)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>归一化是一种数据处理方式，能将数据经过处理后限制在某个固定范围内。</p>
<h3 id="归一化处理的两种形式"><a href="#归一化处理的两种形式" class="headerlink" title="归一化处理的两种形式"></a>归一化处理的两种形式</h3><p>归一化存在两种形式</p>
<ol>
<li>将数处理为 [0, 1] 之间的小数，其目的是为了在随后的数据处理过程中更便捷，其他情况下，也可将数据处理到 [-1, 1] 之间，或其他的固定范围内。</li>
</ol>
<blockquote>
<p>例如，在图像处理中，就会将图像从 [0, 255] 归一化到 [0, 1]之间，这样既不会改变图像本身的信息储存，又可加速后续的网络处理。</p>
</blockquote>
<ol>
<li>通过归一化将有<a href="#有/无量纲表达式">量纲表达式</a>变成<a href="#有/无量纲表达式">无量纲表达式</a>。</li>
</ol>
<h3 id="为什么要进行归一化"><a href="#为什么要进行归一化" class="headerlink" title="为什么要进行归一化"></a>为什么要进行归一化</h3><ol>
<li>解决数据间的可比性问题</li>
<li>数据归一化后，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。<a href="为什么归一化能提高求解最优解的速度">为什么能提高收敛速度</a>.</li>
</ol>
<h3 id="归一化类型"><a href="#归一化类型" class="headerlink" title="归一化类型"></a>归一化类型</h3><ol>
<li>Min-max normalization (Rescaling) 范围为[0,1]:</li>
</ol>
<script type="math/tex; mode=display">
x^{'} = \frac{x - min(x)}{max(x) - min(x)}</script><ol>
<li>Mean normalization范围为[-1,1]：</li>
</ol>
<script type="math/tex; mode=display">
x^{'} = \frac{x - mean(x)}{max(x) - min(x)}</script><blockquote>
<p>mean(x)：x数据的平均值</p>
</blockquote>
<p>​    Min-max归一化和mean归一化适合在最大最小值明确不变的情况下使用，比如图像处理时，灰度值限定在 [0, 255] 的范围内，就可以用min-max归一化将其处理到[0, 1]之间。在最大最小值不明确时，每当有新数据加入，都可能会改变最大或最小值，导致归一化结果不稳定，后续使用效果也不稳定。同时，数据需要相对稳定，如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。如果对处理后的数据范围有严格要求，也应使用min-max归一化或mean归一化。</p>
<ol>
<li>Z-score normalization (Standardization)范围为实数集：</li>
</ol>
<script type="math/tex; mode=display">
x^{'} = \frac{x - \mu}{\sigma}</script><blockquote>
<p>𝜇、𝜎 分别为样本数据的均值和标准差。</p>
</blockquote>
<p>​    Z-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。标准化会改变数据的状态分布，但不会改变分布的种类。特别地，神经网络中经常会使用到z-score归一化，针对这一点，我们将在后续的文章中进行详细的介绍。</p>
<ol>
<li>对数归一化：</li>
</ol>
<script type="math/tex; mode=display">
x^{'} = \frac{\lg x}{\lg max(x)}</script><ol>
<li>反正切函数归一化：</li>
</ol>
<script type="math/tex; mode=display">
x^{'} = \arctan(x) * \frac{2}{\pi}</script><ol>
<li>小数定标标准化（Demical Point Normalization）:</li>
</ol>
<script type="math/tex; mode=display">
x^{'} = \frac{x}{10^j}</script><p>​    非线性归一化通常被用在数据分化程度较大的场景，有时需要通过一些数学函数对原始值进行映射，如对数、反正切等。</p>
<h3 id="归一化和标准化的联系与区别"><a href="#归一化和标准化的联系与区别" class="headerlink" title="归一化和标准化的联系与区别"></a>归一化和标准化的联系与区别</h3><p>谈到归一化和标准化可能会存在一些概念的混淆，我们都知道归一化是指normalization，标准化是指standardization，但根据wiki上对feature scaling方法的定义，standardization其实就是z-score normalization，也就是说标准化其实是归一化的一种，而一般情况下，我们会把z-score归一化称为标准化，把min-max归一化简称为归一化。在下文中，我们也是用标准化指代z-score归一化，并使用归一化指代min-max归一化。</p>
<p>其实，归一化和标准化在本质上都是一种线性变换。在<a href="#归一化类型">归一化类型</a>中，我们提到了归一化和标准化的公式，对于归一化的公式，在数据给定的情况下，可以令𝑎=𝑚𝑎𝑥(𝑥)−𝑚𝑖𝑛(𝑥)、𝑏=𝑚𝑖𝑛(𝑥)，则归一化的公式可变形为：</p>
<script type="math/tex; mode=display">
x^{'} = \frac{x - b}{a} = \frac{x}{a} - \frac{b}{a} = \frac{x}{a} - c</script><p>标准化的公式与变形后的归一化类似，其中的$\mu $和$\sigma$在数据给定的情况下，可以看作常数。因此，标准化的变形与归一化的类似，都可看作对𝑥按比例𝑎进行缩放，再进行𝑐个单位的平移。由此可见，归一化和标准化的本质都是一种线性变换，他们都不会因为对数据的处理而改变数据的原始数值排序。</p>
<p>那么归一化和标准化又有什么区别呢？</p>
<ol>
<li>归一化不会改变数据的状态分布，但标准化会改变数据的状态分布；</li>
<li>归一化会将数据限定在一个具体的范围内，如 [0, 1]，但标准化不会，标准化只会将数据处理为均值为0，标准差为1。</li>
</ol>
<h3 id="为什么归一化能提高求解最优解的速度"><a href="#为什么归一化能提高求解最优解的速度" class="headerlink" title="为什么归一化能提高求解最优解的速度"></a>为什么归一化能提高求解最优解的速度</h3><script type="math/tex; mode=display">
\begin{split}
\begin{align}
y &= \theta_1x_1 + \theta_2x_2 \\
J &= (\theta_{1}x_{1} + \theta_{2}x_{2} - y_{label})^2
\end{align}
\end{split}</script><p>假设自变量只有房子到地铁站的距离<script type="math/tex">𝑥_1</script>和房子内房间的个数<script type="math/tex">𝑥_2</script>，因变量为房价，预测公式和损失函数分别为：</p>
<script type="math/tex; mode=display">
J = (1000\theta_{1}+3\theta_{2} - y_{label})^2</script><p><img src="https://s2.loli.net/2024/06/05/QAonmGKX4FqxUMt.png" alt="normalization"></p>
<div align="center">图1: 损失函数的等高线，图1（左）为未归一化时，图1（右）为归一化</div>

<p>​    在图1中，左图的红色椭圆代表归一化前的损失函数等高线，蓝色线段代表梯度的更新，箭头的方向代表梯度更新的方向。寻求最优解的过程就是梯度更新的过程，其更新方向与登高线垂直。由于𝑥1 和 𝑥2 的量级相差过大，损失函数的等高线呈现为一个瘦窄的椭圆。因此如图1（左）所示，瘦窄的椭圆形会使得梯度下降过程呈之字形呈现，导致梯度下降速度缓慢。</p>
<p>​    当数据经过归一化后，$x<em>{1}^{‘} = \frac{1000-0}{5000-0}=0.2$，$x</em>{2}^{‘} = \frac{3-0}{10-0}=0.3$，那么损失函数的公式可以写为：</p>
<script type="math/tex; mode=display">
J(x) = (0.2\theta_{1} + 0.3\theta_{2} - y_{label})^2</script><p>​    我们可以看到，经过归一化后的数据属于同一量级，损失函数的等高线呈现为一个矮胖的椭圆形（如图1（右）所示），求解最优解过程变得更加迅速且平缓，因此可以在通过梯度下降进行求解时获得更快的收敛。</p>
<h2 id="有-无量纲表达式"><a href="#有-无量纲表达式" class="headerlink" title="有/无量纲表达式"></a>有/无量纲表达式</h2><p>我们假定数据都是一个个变量（不过提前收集好了）量纲指有些未知数他们是变量存在的一种或几种依赖关系，该变量的值由这些依赖关系的未知数（量纲）决定。</p>
<blockquote>
<p> 就像一些函数的y值，理想状态下的房价，他们由x，面积/位置决定。</p>
</blockquote>
<p>显然位置差几百米，面积差几百平方米对变量影响差距极大，这种情况下我们称对这些依赖关系式是有量纲的。他们对变量影响的系数存在数量级的不同。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>vscode 出现python解释器的选择错误，这在windows经常有非常多版本的相同软件上经常出现，选定安装MindSpore库的python版本</li>
</ol>
<p><img src="https://s2.loli.net/2024/06/05/QSIFMsjBCUAo34y.png" alt="image-20240605210110827"></p>
<p>​    点击此处python版本即可</p>
<ol>
<li><p>注意python的多数语法检查集成已分离为插件，一些在2023.10发布，发布后一些网络上的blog修改linting的将禁用，详情请看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUtcHl0aG9uL3dpa2kvTWlncmF0aW9uLXRvLVB5dGhvbi1Ub29scy1FeHRlbnNpb25z">迁移到 Python 工具扩展 ·microsoft/vscode-python 维基 (github.com)<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>解决一些格式上的报错也可以不理会，但根据PEP 8 python规范，一行不能超过80个字符，同时换行需要缩进,如果看不管可以在扩展语法检查中增加args</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--max-line-length=120</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专题</category>
        <category>机器学习</category>
        <category>Mindspore</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MindSpore</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>MindSpore专题——第七章、模型训练</title>
    <url>/2024/special_subject/MindSpore/Chapters/Seven_ModelTrain/article.html</url>
    <content><![CDATA[<h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>本片涉及大量之前提到概念的定义以及大量引用MindSpore官方文档。原文传送门：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL3RyYWluLmh0bWw=">MindSpore<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h3 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h3><ol>
<li>构建数据集。</li>
<li>定义神经网络模型。</li>
<li>定义超参、损失函数及优化器。</li>
<li>输入数据集进行训练与评估。</li>
</ol>
<p>现在我们有了数据集和模型后，可以进行模型的训练与评估。</p>
<h3 id="构建数据集"><a href="#构建数据集" class="headerlink" title="构建数据集"></a>构建数据集</h3><p>从dataset加载代码，构建数据集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def datapipe(path, batch_size):</span><br><span class="line">    image_transforms = [</span><br><span class="line">        vision.Rescale(1.0 / 255.0, 0),</span><br><span class="line">        vision.Normalize(mean=(0.1307,), std=(0.3081,)),</span><br><span class="line">        vision.HWC2CHW()</span><br><span class="line">    ]</span><br><span class="line">    label_transform = transforms.TypeCast(mindspore.int32)</span><br><span class="line"></span><br><span class="line">    dataset = MnistDataset(path)</span><br><span class="line">    dataset = dataset.map(image_transforms, &#x27;image&#x27;)</span><br><span class="line">    dataset = dataset.map(label_transform, &#x27;label&#x27;)</span><br><span class="line">    dataset = dataset.batch(batch_size)</span><br><span class="line">    return dataset</span><br><span class="line"></span><br><span class="line">train_dataset = datapipe(&#x27;MNIST_Data/train&#x27;, batch_size=64)</span><br><span class="line">test_dataset = datapipe(&#x27;MNIST_Data/test&#x27;, batch_size=64)</span><br></pre></td></tr></table></figure>
<p><em>class</em>mindspore.dataset.vision.HWC2CHW</p>
<p>将输入图像的shape从 <H, W, C> 转换为 <C, H, W>。 如果输入图像的shape为 <H, W> ，图像将保持不变。</p>
<p>异常处理</p>
<ul>
<li><strong>RuntimeError</strong> - 如果输入图像的shape不是 <H, W> 或 <H, W, C>。</li>
</ul>
<p><em>class</em>mindspore.nn.<strong>ReLU</strong></p>
<p>逐元素求 max(0,𝑥) 。</p>
<ul>
<li><strong>x</strong> (Tensor) - 用于计算<strong>ReLU</strong>的任意维度的Tensor。数据类型为 <span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZHR5cGUuaHRtbCNtaW5kc3BvcmUuZHR5cGU=">number<i class="fa fa-external-link-alt"></i></span>。</li>
</ul>
<h3 id="定义神经网络模型"><a href="#定义神经网络模型" class="headerlink" title="定义神经网络模型"></a>定义神经网络模型</h3><blockquote>
<p> 从<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL3R1dG9yaWFscy96aC1DTi9yMi4yL2JlZ2lubmVyL21vZGVsLmh0bWw=">网络构建<i class="fa fa-external-link-alt"></i></span>中加载代码，构建一个神经网络模型。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>(nn.Cell):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.flatten = nn.Flatten()</span><br><span class="line">        <span class="variable language_">self</span>.dense_relu_sequential = nn.SequentialCell(</span><br><span class="line">            nn.Dense(<span class="number">28</span>*<span class="number">28</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dense(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dense(<span class="number">512</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.flatten(x)</span><br><span class="line">        logits = <span class="variable language_">self</span>.dense_relu_sequential(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line">model = Network()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<h3 id="定义超参、损失函数和优化器"><a href="#定义超参、损失函数和优化器" class="headerlink" title="定义超参、损失函数和优化器"></a>定义超参、损失函数和优化器</h3><h4 id="超参"><a href="#超参" class="headerlink" title="超参"></a>超参</h4><p>超参（Hyperparameters）是可以调整的参数，可以控制模型训练优化的过程，不同的超参数值可能会影响模型训练和收敛速度。目前深度学习模型多采用批量随机梯度下降算法进行优化，随机梯度下降算法的原理如下：</p>
<script type="math/tex; mode=display">
w_{t+1}=w_{t}-\eta \frac{1}{n} \sum_{x \in \mathcal{B}} \nabla l\left(x, w_{t}\right)</script><p>公式中，𝑛是批量大小（batch size），𝜂是学习率（learning rate）。另外，𝑤𝑡为训练轮次𝑡中的权重参数，∇𝑙为损失函数的导数。除了梯度本身，这两个因子直接决定了模型的权重更新，从优化本身来看，它们是影响模型性能收敛最重要的参数。一般会定义以下超参用于训练：</p>
<ul>
<li><strong>训练轮次（epoch）</strong>：训练时遍历数据集的次数。</li>
<li><strong>批次大小（batch size）</strong>：数据集进行分批读取训练，设定每个批次数据的大小。batch size过小，花费时间多，同时梯度震荡严重，不利于收敛；batch size过大，不同batch的梯度方向没有任何变化，容易陷入局部极小值，因此需要选择合适的batch size，可以有效提高模型精度、全局收敛。</li>
<li><strong>学习率（learning rate）</strong>：如果学习率偏小，会导致收敛的速度变慢，如果学习率偏大，则可能会导致训练不收敛等不可预测的结果。梯度下降法被广泛应用在最小化模型误差的参数优化算法上。梯度下降法通过多次迭代，并在每一步中最小化损失函数来预估模型的参数。学习率就是在迭代过程中，会控制模型的学习进度。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epochs = <span class="number">3</span></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">learning_rate = <span class="number">1e-2</span></span><br></pre></td></tr></table></figure>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>损失函数（loss function）用于评估模型的预测值（logits）和目标值（targets）之间的误差。训练模型时，随机初始化的神经网络模型开始时会预测出错误的结果。损失函数会评估预测结果与目标值的相异程度，模型训练的目标即为降低损失函数求得的误差。</p>
<p>常见的损失函数包括用于回归任务的<code>nn.MSELoss</code>（均方误差）和用于分类的<code>nn.NLLLoss</code>（负对数似然）等。 <code>nn.CrossEntropyLoss</code> 结合了<code>nn.LogSoftmax</code>和<code>nn.NLLLoss</code>，可以对logits 进行归一化并计算预测误差。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>模型优化（Optimization）是在每个训练步骤中调整模型参数以减少模型误差的过程。MindSpore提供多种优化算法的实现，称之为优化器（Optimizer）。优化器内部定义了模型的参数优化过程（即梯度如何更新至模型参数），所有优化逻辑都封装在优化器对象中。在这里，我们使用SGD（Stochastic Gradient Descent）优化器。</p>
<p>我们通过<code>model.trainable_params()</code>方法获得模型的可训练参数，并传入学习率超参来初始化优化器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)</span><br></pre></td></tr></table></figure>
<p><em>class</em>mindspore.experimental.optim.<strong>SGD</strong>(<em>params</em>, <em>lr</em>, <em>momentum=0</em>, <em>dampening=0</em>, <em>weight_decay=0</em>, <em>nesterov=False</em>, <em>**, </em>maximize=False*)</p>
<p>随机梯度下降算法。</p>
<script type="math/tex; mode=display">
v_{t+1} = u \ast v_{t} + gradient \ast (1-dampening)</script><p>如果nesterov为True：</p>
<script type="math/tex; mode=display">
p_{t+1} = p_{t} - lr \ast (gradient + u \ast v_{t+1})</script><p>如果nesterov为False：</p>
<script type="math/tex; mode=display">
p_{t+1} = p_{t} - lr \ast v_{t+1}</script><p>需要注意的是，对于训练的第一步 𝑣𝑡+1=𝑔𝑟𝑎𝑑𝑖𝑒𝑛𝑡。其中，p、v和u分别表示 parameters、accum 和 momentum。</p>
<h4 id="训练与评估"><a href="#训练与评估" class="headerlink" title="训练与评估"></a>训练与评估</h4><p>设置了超参、损失函数和优化器后，我们就可以循环输入数据来训练模型。一次数据集的完整迭代循环称为一轮（epoch）。每轮执行训练时包括两个步骤：</p>
<ol>
<li>训练：迭代训练数据集，并尝试收敛到最佳参数。</li>
<li>验证/测试：迭代测试数据集，以检查模型性能是否提升。</li>
</ol>
<p>接下来我们定义用于训练的<code>train_loop</code>函数和用于测试的<code>test_loop</code>函数。</p>
<p>使用函数式自动微分，需先定义正向函数<code>forward_fn</code>，使用<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUudmFsdWVfYW5kX2dyYWQuaHRtbA==">value_and_grad<i class="fa fa-external-link-alt"></i></span>获得微分函数<code>grad_fn</code>。然后，我们将微分函数和优化器的执行封装为<code>train_step</code>函数，接下来循环迭代数据集进行训练即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define forward function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward_fn</span>(<span class="params">data, label</span>):</span><br><span class="line">    logits = model(data)</span><br><span class="line">    loss = loss_fn(logits, label)</span><br><span class="line">    <span class="keyword">return</span> loss, logits</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get gradient function</span></span><br><span class="line">grad_fn = mindspore.value_and_grad(forward_fn, <span class="literal">None</span>, optimizer.parameters, has_aux=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define function of one-step training</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_step</span>(<span class="params">data, label</span>):</span><br><span class="line">    (loss, _), grads = grad_fn(data, label)</span><br><span class="line">    optimizer(grads)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_loop</span>(<span class="params">model, dataset</span>):</span><br><span class="line">    size = dataset.get_dataset_size()</span><br><span class="line">    model.set_train()</span><br><span class="line">    <span class="keyword">for</span> batch, (data, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataset.create_tuple_iterator()):</span><br><span class="line">        loss = train_step(data, label)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            loss, current = loss.asnumpy(), batch</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;loss: <span class="subst">&#123;loss:&gt;7f&#125;</span>  [<span class="subst">&#123;current:&gt;3d&#125;</span>/<span class="subst">&#123;size:&gt;3d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>test_loop</code>函数同样需循环遍历数据集，调用模型计算loss和Accuray并返回最终结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_loop</span>(<span class="params">model, dataset, loss_fn</span>):</span><br><span class="line">    num_batches = dataset.get_dataset_size()</span><br><span class="line">    model.set_train(<span class="literal">False</span>)</span><br><span class="line">    total, test_loss, correct = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, label <span class="keyword">in</span> dataset.create_tuple_iterator():</span><br><span class="line">        pred = model(data)</span><br><span class="line">        total += <span class="built_in">len</span>(data)</span><br><span class="line">        test_loss += loss_fn(pred, label).asnumpy()</span><br><span class="line">        correct += (pred.argmax(<span class="number">1</span>) == label).asnumpy().<span class="built_in">sum</span>()</span><br><span class="line">    test_loss /= num_batches</span><br><span class="line">    correct /= total</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Test: \n Accuracy: <span class="subst">&#123;(<span class="number">100</span>*correct):&gt;<span class="number">0.1</span>f&#125;</span>%, Avg loss: <span class="subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我们将实例化的损失函数和优化器传入<code>train_loop</code>和<code>test_loop</code>中。训练3轮并输出loss和Accuracy，查看性能变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = nn.SGD(model.trainable_params(), learning_rate=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;t+<span class="number">1</span>&#125;</span>\n-------------------------------&quot;</span>)</span><br><span class="line">    train_loop(model, train_dataset)</span><br><span class="line">    test_loop(model, test_dataset, loss_fn)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Epoch 1</span><br><span class="line">-------------------------------</span><br><span class="line">loss: 2.302806  [  0/938]</span><br><span class="line">loss: 2.285086  [100/938]</span><br><span class="line">loss: 2.264712  [200/938]</span><br><span class="line">loss: 2.174010  [300/938]</span><br><span class="line">loss: 1.931853  [400/938]</span><br><span class="line">loss: 1.340721  [500/938]</span><br><span class="line">loss: 0.953515  [600/938]</span><br><span class="line">loss: 0.756860  [700/938]</span><br><span class="line">loss: 0.756263  [800/938]</span><br><span class="line">loss: 0.463846  [900/938]</span><br><span class="line">Test:</span><br><span class="line"> Accuracy: 84.7%, Avg loss: 0.527155</span><br><span class="line"></span><br><span class="line">Epoch 2</span><br><span class="line">-------------------------------</span><br><span class="line">loss: 0.479126  [  0/938]</span><br><span class="line">loss: 0.437443  [100/938]</span><br><span class="line">loss: 0.685504  [200/938]</span><br><span class="line">loss: 0.395121  [300/938]</span><br><span class="line">loss: 0.550566  [400/938]</span><br><span class="line">loss: 0.459457  [500/938]</span><br><span class="line">loss: 0.293049  [600/938]</span><br><span class="line">loss: 0.422102  [700/938]</span><br><span class="line">loss: 0.333153  [800/938]</span><br><span class="line">loss: 0.412182  [900/938]</span><br><span class="line">Test:</span><br><span class="line"> Accuracy: 90.5%, Avg loss: 0.335083</span><br><span class="line"></span><br><span class="line">Epoch 3</span><br><span class="line">-------------------------------</span><br><span class="line">loss: 0.207366  [  0/938]</span><br><span class="line">loss: 0.343559  [100/938]</span><br><span class="line">loss: 0.391145  [200/938]</span><br><span class="line">loss: 0.317566  [300/938]</span><br><span class="line">loss: 0.200746  [400/938]</span><br><span class="line">loss: 0.445798  [500/938]</span><br><span class="line">loss: 0.603720  [600/938]</span><br><span class="line">loss: 0.170811  [700/938]</span><br><span class="line">loss: 0.411954  [800/938]</span><br><span class="line">loss: 0.315902  [900/938]</span><br><span class="line">Test:</span><br><span class="line"> Accuracy: 91.9%, Avg loss: 0.279034</span><br><span class="line"></span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>
</blockquote>
<p>读者可以修改参数多跑几边，观察数据的变化，不懂随机梯度下降算法或不懂正向反向传播、学习率乃至超参的概念可以回顾之前文章中提到的视频并重复观看之前的文章，这几个概念应该比较好理解。</p>
]]></content>
      <categories>
        <category>专题</category>
        <category>机器学习</category>
        <category>Mindspore</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MindSpore</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>MindSpore专题——第六章——函数式微分</title>
    <url>/2024/special_subject/MindSpore/Chapters/Sixth_FunctionAutoDifferentalCalc/article.html</url>
    <content><![CDATA[<h2 id="函数式自动微分"><a href="#函数式自动微分" class="headerlink" title="函数式自动微分"></a>函数式自动微分</h2><blockquote>
<p>神经网络的训练主要使用反向传播算法，模型预测值（logits）与正确标签（label）送入损失函数（loss function）获得loss，然后进行反向传播计算，求得梯度（gradients），最终更新至模型参数（parameters）。自动微分能够计算可导函数在某点处的导数值，是反向传播算法的一般化。自动微分主要解决的问题是将一个复杂的数学运算分解为一系列简单的基本运算，该功能对用户屏蔽了大量的求导细节和过程，大大降低了框架的使用门槛。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>MindSpore使用函数式自动微分的设计理念，提供更接近于数学语义的自动微分接口<code>grad</code>和<code>value_and_grad</code>。下面我们使用一个简单的单层线性变换模型进行介绍。</p>
</blockquote>
<p>这里总算是提到了反向传播，最近我看到了一系列视频有关Machine Learning，传送门如下：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1JbGczZ0dld1E1VQ==">🔴 World of Warships / USS Des Moines cut (youtube.com)<i class="fa fa-external-link-alt"></i></span></p>
<p>如果你试图看下去的话，可能会发现，事情好像突然变难了，似乎一群从未见过的知识组合在了一起，神经网络就像一个黑箱连着另一个黑箱，而你根本不知道如何优化它，使得黑箱在给定的输入下输出正确答案</p>
<h2 id="神经网络到底代表了什么"><a href="#神经网络到底代表了什么" class="headerlink" title="神经网络到底代表了什么"></a>神经网络到底代表了什么</h2><p>首先让我们定义什么是神经：他是一个携带一个浮点数的结构，然后让我们看向神经网络</p>
<p><img src="https://s2.loli.net/2024/06/07/MLN1Ap2wslU4SQB.jpg" alt="R"></p>
<p>对于每一个点，我们从最后看起，显然，他们代表0-9，更准确的说，他们代表0-9的图像。为什么这样的网络是生效的呢？</p>
<p><strong><em>因为分形思想</em></strong>，我们将一段连续的图像区分为一段一段，比如9是⚪在上而线条在下。4由多端线段1组成。而⚪和线条又可以继续再分，我们可以将神经网络中的每一个节点代表的数据想象成这种规律图案的集合。他们之间的传递就是图案在网络中不断组合。这也是为什么在网络中使用全连接的原因，因为每一个图案都能与其他任何图案组合。最终我们使图案变成了不断分形像素的组合。</p>
<p>但如何做到这一点呢？ 考虑我们前面提到的参数，权值。</p>
<p><img src="./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240607181215798.png" alt="image-20240607181215798"></p>
<p>这张图相信有很多人见过类似的图，实际上权值代表的就是神经网络之间的连线，假设我们让正权值在下表中为绿负权值在下表中为红，我们将这样描述一条“线段”：一段由红色包围的长条状绿色区域这样我们就能得出，如果这段线条是成立得话，比如确实原图这里存在一条线段，我们得到的这个神经节点上得值就会很接近1，否则就会很接近零。这就是权值得意义。但同时，我们会注意到神经得值是许多这样计算的累和，因此我们需要一个bias，偏差值将其计算到到0-1。</p>
<p>注意这里得权值和偏差值均是变量，是训练出来的。并且注意，我们并不知道机器是如何分形得，这取决于学习数据和使用的算法，以上只为举例理解。</p>
<p>如果将最初得神经网络拿去使用，你只会得到一大堆垃圾数据。我们都知道神经网络存在“进化”过程，但他是如何知道自己错得有多离谱的呢？</p>
<h2 id="Cost-Function（Maybe-also-loss-function-）"><a href="#Cost-Function（Maybe-also-loss-function-）" class="headerlink" title="Cost Function（Maybe also loss function?）"></a>Cost Function（Maybe also loss function?）</h2><p>初略的定义是他是输出的张量与正确的张量的差值平方和，比如，机器输出了一个全是0.5的10个数的张量，而正确答案是其中之一，那么</p>
<script type="math/tex; mode=display">
\text{Cost} = (1-0.5) + 0.5*9</script><p>显然这个数字更接近0，说明结果更加准确</p>
<p>考虑如何让模型表现得更好，显然是需要找到一组参数，使得每次输出的cost值最小。我们可以考虑这样一种方式，以参数作为输入，cost的值作为输出，而训练数据则是参数。</p>
<h3 id="梯度下降-Gradient-Descent"><a href="#梯度下降-Gradient-Descent" class="headerlink" title="梯度下降 (Gradient Descent)"></a>梯度下降 (Gradient Descent)</h3><p>似乎难以理解，假设我们只有一个参数cost=f(c)，c是唯一的参数。于是变为了函数的最值问题，只需要求导数然后慢慢移动我们的初始点。很显然，一个函数在常数域上可能存在多个极大值而只有一个最大值。当我们从一个点出发寻找最大值时，很有可能（概率学上讲应该是绝对）我们只会找到一个极大值。即在神经网络中，我们不能保证我们的参数是最优的，只能保证我们的参数是局部最优的（这取决于我们的起始点）。</p>
<p>变到多维，我们意识到，一个数的导数是否只有正或负两种信息有效（代表是应该增加这个数还是减少这个数）。假定两个变量在一个点上的导数其中一个是另一个的三倍，这至少说明在该点的邻域内，这一变量应该减少的更多是正确的。（可能有一些函数存在极端的尖点导致错误，但这在神经网络中是低概率的，掌控好更改数据的大小即可）。</p>
<p>一个简单的例子是，维护好一个<script type="math/tex">\nabla C</script>矩阵，一阶导数对应的值高则其增加，反之则减少。</p>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>从特殊到一般，我们先观察这样一个样例</p>
<p><img src="https://s2.loli.net/2024/06/07/SJ5Rf7m6cXFs8yN.png" alt="image-20240607205110764"></p>
<p>显然我们需要增加2，并且如果给我们要做的事情做出一个排序，增加2显然排在减少8之前。</p>
<p>因此，让我们继续看增加2所涉及的值</p>
<ol>
<li>更改偏差值</li>
<li>更改权值（根据节点值）</li>
<li>更改上一层节点的值（根据权值）</li>
</ol>
<p>我们对权值和边权同时改变，并统计下一层节点需要的变化对上一层的节点影响的累和</p>
<p>通过多组数据得出权值的总共改变值改变值。这就是随机梯度下降（Stochastic gradient descent）</p>
<p>下面简单讲一讲其他的名词解释</p>
<h2 id="Mini-batches"><a href="#Mini-batches" class="headerlink" title="Mini-batches"></a>Mini-batches</h2><p>和他的名字一样，这个技术就是将训练数据分为几组以提高收敛参数的效率</p>
<h2 id="Backpropagation"><a href="#Backpropagation" class="headerlink" title="Backpropagation"></a>Backpropagation</h2><p>反向传播是一种梯度下降法的应用，通过链式法则计算损失函数相对于每个权重的梯度，然后利用这些梯度来更新权重。</p>
<h2 id="函数与计算图"><a href="#函数与计算图" class="headerlink" title="函数与计算图"></a>函数与计算图</h2><p><img src="https://s2.loli.net/2024/06/07/iqHnjI12DSKR6P7.png" alt="compute-graph"></p>
<blockquote>
<p>计算图是用图论语言表示数学函数的一种方式，也是深度学习框架表达神经网络模型的统一方法。我们将根据下面的计算图构造计算函数和神经网络。</p>
<p>在这个模型中，𝑥为输入，𝑦为正确值，𝑤和𝑏是我们需要优化的参数。</p>
</blockquote>
<ol>
<li>𝑥为输入</li>
<li>𝑦为正确值</li>
<li>𝑤和𝑏是我们需要优化的参数</li>
</ol>
<p>即对应了原始数据，输出结果，权重和偏差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = ops.ones(<span class="number">5</span>, mindspore.float32)  <span class="comment"># input tensor</span></span><br><span class="line">y = ops.zeros(<span class="number">3</span>, mindspore.float32)  <span class="comment"># expected output</span></span><br><span class="line">w = Parameter(Tensor(np.random.randn(<span class="number">5</span>, <span class="number">3</span>), mindspore.float32), name=<span class="string">&#x27;w&#x27;</span>) <span class="comment"># weight</span></span><br><span class="line">b = Parameter(Tensor(np.random.randn(<span class="number">3</span>,), mindspore.float32), name=<span class="string">&#x27;b&#x27;</span>) <span class="comment"># bias</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们根据计算图描述的计算过程，构造计算函数。 其中，<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLmJpbmFyeV9jcm9zc19lbnRyb3B5X3dpdGhfbG9naXRzLmh0bWw=">binary_cross_entropy_with_logits<i class="fa fa-external-link-alt"></i></span> 是一个损失函数，计算预测值和目标值之间的二值交叉熵损失。</p>
</blockquote>
<p>解释一下Parameter(): <strong>Parameter</strong> 是 Tensor 的子类，当它们被绑定为Cell的属性时，会自动添加到其参数列表中，并且可以通过Cell的某些方法获取，例如 cell.get_<strong>parameter</strong>s() 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">x, y, w, b</span>):</span><br><span class="line">    z = ops.matmul(x, w) + b</span><br><span class="line">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">loss = function(x, y, w, b)</span><br><span class="line"><span class="built_in">print</span>(loss)</span><br></pre></td></tr></table></figure>
<p>这里有复杂概念<a href="#二值交叉熵损失"><em>二值交叉熵损失</em></a>，如果你不想深究只需要这是一个对参数的函数，当这个函数值最低时，整体参数就是一个准确率较高的局部最优解即可。</p>
<h2 id="微分函数与梯度计算"><a href="#微分函数与梯度计算" class="headerlink" title="微分函数与梯度计算"></a>微分函数与梯度计算</h2><blockquote>
<p> 为了优化模型参数，需要求参数对loss的导数：<script type="math/tex">\frac{𝜕loss}{𝜕𝑤}</script>和<script type="math/tex">\frac{𝜕loss}{𝜕𝑏}</script>，此时我们调用<code>mindspore.grad</code>函数，来获得<code>function</code>的微分函数。</p>
<p>这里使用了<code>grad</code>函数的两个入参，分别为：</p>
<ul>
<li><code>fn</code>：待求导的函数。</li>
<li><code>grad_position</code>：指定求导输入位置的索引。</li>
</ul>
<p>由于我们对<script type="math/tex">𝑤</script>和<script type="math/tex">𝑏</script>​求导，因此配置其在<code>function</code>入参对应的位置<code>(2, 3)</code>。</p>
<p><em>使用<code>grad</code>获得微分函数是一种函数变换，即输入为函数，输出也为函数。</em></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grad_fn = mindspore.grad(function, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">grads = grad_fn(x, y, w, b)</span><br><span class="line"><span class="built_in">print</span>(grads)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class="line">[[ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class="line"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class="line"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class="line"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03],</span><br><span class="line"> [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]]), Tensor(shape=[3], dtype=Float32, value= [ 8.17961693e-02,  1.48393542e-01,  6.00685179e-03]))</span><br></pre></td></tr></table></figure>
</blockquote>
<p>执行微分函数，即可获得<script type="math/tex">𝑤</script>、<script type="math/tex">𝑏</script>​对应的梯度。可以注意到w,b的梯度与最初始的梯度是一致的。</p>
<h3 id="Stop-Gradient"><a href="#Stop-Gradient" class="headerlink" title="Stop Gradient"></a>Stop Gradient</h3><blockquote>
<p>通常情况下，求导时会求loss对参数的导数，因此函数的输出只有loss一项。<strong>当我们希望函数输出多项时，微分函数会求所有输出项对参数的导数</strong>。此时如果想实现对某个输出项的梯度截断，或消除某个Tensor对梯度的影响，需要用到Stop Gradient操作。</p>
<p>这里我们将<code>function</code>改为同时输出loss和z的<code>function_with_logits</code>，获得微分函数并执行。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_with_logits</span>(<span class="params">x, y, w, b</span>):</span><br><span class="line">    z = ops.matmul(x, w) + b</span><br><span class="line">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class="line">    <span class="keyword">return</span> loss, z</span><br><span class="line"></span><br><span class="line">grad_fn = mindspore.grad(function_with_logits, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">grads = grad_fn(x, y, w, b)</span><br><span class="line"><span class="built_in">print</span>(grads)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_stop_gradient</span>(<span class="params">x, y, w, b</span>):</span><br><span class="line">    z = ops.matmul(x, w) + b</span><br><span class="line">    loss = ops.binary_cross_entropy_with_logits(z, y, ops.ones_like(z), ops.ones_like(z))</span><br><span class="line">    <span class="keyword">return</span> loss, ops.stop_gradient(z)</span><br><span class="line"></span><br><span class="line">grad_fn = mindspore.grad(function_stop_gradient, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">grads = grad_fn(x, y, w, b)</span><br><span class="line"><span class="built_in">print</span>(grads)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ops.stop_gradient(z)</code>:重点在该函数，表示屏蔽了z对梯度的影响，即仍只求参数对loss的导数。</p>
<p>这里解释一下一些api的含义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mindspore.grad(fn, grad_position=<span class="number">0</span>, weights=<span class="literal">None</span>, has_aux=<span class="literal">False</span>, return_ids=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZ3JhZC5odG1sP2hpZ2hsaWdodD1ncmFkI21pbmRzcG9yZS5ncmFk">MindSpore<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mindspore.numpy.matmul(x1, x2, dtype=None)</span><br></pre></td></tr></table></figure>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL251bXB5L21pbmRzcG9yZS5udW1weS5tYXRtdWwuaHRtbD9oaWdobGlnaHQ9bWF0bXVsI21pbmRzcG9yZS5udW1weS5tYXRtdWw=">MindSpore<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="Auxiliary-data"><a href="#Auxiliary-data" class="headerlink" title="Auxiliary data"></a>Auxiliary data</h3><p>Auxiliary data意为辅助数据，是函数除第一个输出项外的其他输出。通常我们会将函数的loss设置为函数的第一个输出，其他的输出即为辅助数据。</p>
<p><code>grad</code>和<code>value_and_grad</code>提供<code>has_aux</code>参数，当其设置为<code>True</code>时，可以自动实现前文手动添加<code>stop_gradient</code>的功能，满足返回辅助数据的同时不影响梯度计算的效果。</p>
<p>下面仍使用<code>function_with_logits</code>，配置<code>has_aux=True</code>，并执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grad_fn = mindspore.grad(function_with_logits, (<span class="number">2</span>, <span class="number">3</span>), has_aux=<span class="literal">True</span>)</span><br><span class="line">grads, (z,) = grad_fn(x, y, w, b)</span><br><span class="line"><span class="built_in">print</span>(grads, z)</span><br></pre></td></tr></table></figure>
<h3 id="神经网络梯度计算"><a href="#神经网络梯度计算" class="headerlink" title="神经网络梯度计算"></a>神经网络梯度计算</h3><blockquote>
<p> 前述章节主要根据计算图对应的函数介绍了MindSpore的函数式自动微分，但我们的神经网络构造是继承自面向对象编程范式的<code>nn.Cell</code>。接下来我们通过<code>Cell</code>构造同样的神经网络，利用函数式自动微分来实现反向传播。</p>
<p>首先我们继承<code>nn.Cell</code>构造单层线性变换神经网络。这里我们直接使用前文的𝑤、𝑏作为模型参数，使用<code>mindspore.Parameter</code>进行包装后，作为内部属性，并在<code>construct</code>内实现相同的Tensor操作。</p>
</blockquote>
<p>这里出现了反向传播方法,并且是包装好的,建议读者仔细看一下代码并尝试自己运行一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义神经网络模型</span></span><br><span class="line"><span class="comment"># Define model</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>(nn.Cell):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.w = w</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self, x</span>):</span><br><span class="line">        z = ops.matmul(x, <span class="variable language_">self</span>.w) + <span class="variable language_">self</span>.b</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate model</span></span><br><span class="line">model = Network()</span><br><span class="line"><span class="comment"># Instantiate loss function</span></span><br><span class="line">loss_fn = nn.BCEWithLogitsLoss()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define forward function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward_fn</span>(<span class="params">x, y</span>):</span><br><span class="line">    z = model(x)</span><br><span class="line">    loss = loss_fn(z, y)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注入损失函数</span></span><br><span class="line">grad_fn = mindspore.value_and_grad(forward_fn, <span class="literal">None</span>, weights=model.trainable_params())</span><br><span class="line">loss, grads = grad_fn(x, y)</span><br><span class="line"><span class="built_in">print</span>(grads)</span><br></pre></td></tr></table></figure>
<h3 id="总结输出（单次）"><a href="#总结输出（单次）" class="headerlink" title="总结输出（单次）"></a>总结输出（单次）</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.92031693</span><br><span class="line">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class="line">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br><span class="line">计算多个参数的导数</span><br><span class="line">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class="line">[[ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class="line"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class="line"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class="line"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00],</span><br><span class="line"> [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]]), Tensor(shape=[3], dtype=Float32, value= [ 1.23408186e+00,  1.21728730e+00,  1.13000238e+00]))</span><br><span class="line">消除部分张量对梯度的影响</span><br><span class="line">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class="line">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br><span class="line">Auxiliary data 辅助数据测试</span><br><span class="line">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class="line">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01])) [ 0.8580145   0.62723386 -0.44728255]      </span><br><span class="line">开始实测网络模型的反向传播</span><br><span class="line">(Tensor(shape=[5, 3], dtype=Float32, value=</span><br><span class="line">[[ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01],</span><br><span class="line"> [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]]), Tensor(shape=[3], dtype=Float32, value= [ 2.34081909e-01,  2.17287347e-01,  1.30002365e-01]))</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可见，除了在计算z的导数对梯度的影响情况下，均保持了相同的输出，并且可以观察到w,b的权值</p>
<h2 id="二值交叉熵损失"><a href="#二值交叉熵损失" class="headerlink" title="二值交叉熵损失"></a>二值交叉熵损失</h2><p><strong><em>以下的对数均为自然对数</em></strong></p>
<p>Binary cross entropy 二元<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Lqk5Y+J54a1">交叉熵<i class="fa fa-external-link-alt"></i></span>是二分类问题中常用的一个Loss损失函数，在常见的机器学习模块中都有实现。就二元交叉熵这个损失函数的原理，简单地进行解释。下面是二元交叉熵损失函数的公式</p>
<script type="math/tex; mode=display">
L=-\frac1N \sum_{i=1}^{N}[y_ilog(p_i)+(1-y_i)log(1-p_i)]</script><p>先不尝试理解他，先看看他是如何运作的</p>
<p><img src="https://s2.loli.net/2024/06/07/MAOZxqKodRSW6uy.jpg" alt="img"></p>
<script type="math/tex; mode=display">
L=\frac13[(1*log0.8+(1-1)*log(1-0.8))+(0*log0.2+(1-0)*log(1-0.2))+(0*log0.4+(1-0)*log(1-0.4))]=0.319 \\</script><p>对于以上的案例计算损失函数，结果是0.31903</p>
<h3 id="从熵来看交叉熵损失"><a href="#从熵来看交叉熵损失" class="headerlink" title="从熵来看交叉熵损失"></a>从熵来看交叉熵损失</h3><h4 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h4><p>信息量来衡量一个事件的不确定性，一个事件发生的概率越大，不确定性越小，则其携带的信息量就越小。</p>
<p>设<script type="math/tex">X</script>是一个离散型随机变量，其取值为集合<script type="math/tex">X = {x_0,x_1,\dots,x_n}</script>，则其概率分布函数为<script type="math/tex">p(x) = Pr(X = x),x \in X</script>，则定义事件<script type="math/tex">X=x_0</script>的信息量为：</p>
<script type="math/tex; mode=display">
I(x_0) = -\log(p(x_0))</script><p>当<script type="math/tex">p(x_0) = 1</script>时，其携带的信息量为0。</p>
<h4 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h4><p>熵用来衡量一个系统的混乱程度，代表系统中信息量的总和；熵值越大，表明这个系统的不确定性就越大。具体而数学的讲，熵就是一个系统中所有信息量的期望。</p>
<p>信息量是衡量某个事件的不确定性，而熵是衡量一个系统（所有事件）的不确定性。</p>
<p>熵的计算公式</p>
<script type="math/tex; mode=display">
H(x) = -\sum_{i=1}^np(x_i)\log(p(x_i))</script><p>比较特殊的有二项分布熵</p>
<script type="math/tex; mode=display">
\begin{eqnarray}
H(X)&=&-\sum_{i=1}^n p(x_i)log(p(x_i))\\
&=&-p(x)log(p(x))-(1-p(x))log(1-p(x))
\end{eqnarray}</script><p><em>熵也有其他类型的计算公式，这里是信息学上的定义</em></p>
<p>其中<script type="math/tex">p(x)</script>为这件事发生的概率，<script type="math/tex">-log(p(x_i))</script>是事件<script type="math/tex">x_i</script>所携带的信息量。</p>
<p>可以看出，熵是信息量的期望值，是一个随机变量（一个系统，事件所有可能性）不确定性的度量。熵值越大，随机变量的取值就越难确定，系统也就越不稳定；熵值越小，随机变量的取值也就越容易确定，系统越稳定。</p>
<h4 id="相对熵-（Relative-entropy）-KL散度"><a href="#相对熵-（Relative-entropy）-KL散度" class="headerlink" title="相对熵 （Relative entropy）/  KL散度"></a>相对熵 （Relative entropy）/  KL散度</h4><p>wiki对相对熵的定义如下：<code>In the context of machine learning, DKL(P‖Q) is often called the information gain achieved if P is used instead of Q.</code></p>
<p>即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。</p>
<p>在机器学习中，P往往用来表示样本的真实分布，比如[1,0,0]表示当前样本属于第一类。Q用来表示模型所预测的分布，比如[0.7,0.2,0.1]直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。</p>
<p>总结：相对熵也称为KL散度(Kullback-Leibler divergence)，表示同一个随机变量的两个不同分布间的距离。</p>
<p>设 <script type="math/tex">p(x),𝑞(𝑥)</script>分别是 离散随机变量<script type="math/tex">X</script>的两个概率分布，则<script type="math/tex">p</script>对<script type="math/tex">q</script>的相对熵是：</p>
<script type="math/tex; mode=display">
D_{KL}(p \parallel q) = \sum_i p(x_i) log(\frac{p(x_i)}{q(x_i)})</script><p>相对熵具有以下性质：</p>
<ul>
<li>如果p(x)和q(x)的分布相同，则其相对熵等于0</li>
<li><script type="math/tex">D_{KL}(p∥q)≠D_{KL}(q∥p)𝐷_{𝐾𝐿}(𝑝∥𝑞)≠𝐷_{𝐾𝐿}(𝑞∥𝑝)</script>，也就是相对熵不具有对称性。</li>
<li><script type="math/tex; mode=display">D_{KL}(p∥q)≥0</script></li>
</ul>
<p>总的来说，相对熵是用来衡量同一个随机变量的两个不同分布之间的距离。<strong>在实际应用中，假如p(x)是目标真实的分布，而q(x)是预测得来的分布，为了让这两个分布尽可能的相同的，就需要最小化KL散度。</strong></p>
<h4 id="交叉熵-Cross-Entropy"><a href="#交叉熵-Cross-Entropy" class="headerlink" title="交叉熵 Cross Entropy"></a>交叉熵 Cross Entropy</h4><p>设<script type="math/tex">p(x),q(x)</script>分别是 离散随机变量<script type="math/tex">X</script>的两个概率分布，其中<script type="math/tex">p(x)</script>是目标分布，<script type="math/tex">p</script>和<script type="math/tex">q</script>的交叉熵可以看做是，使用分布<script type="math/tex">q(x)</script>表示目标分布<script type="math/tex">p(x)</script>的困难程度</p>
<script type="math/tex; mode=display">
H(p,q) = \sum_ip(x_i)log\frac{1}{\log q(x_i)} = -\sum_ip(x_i)\log q(x_i)</script><p>将熵、相对熵以及交叉熵的公式放到一起，</p>
<script type="math/tex; mode=display">
\begin{align}
H(p) &= -\sum_{i}p(x_i) \log p(x_i) \\
D_{KL}(p \parallel q) &= \sum_{i}p(x_i)\log \frac{p(x_i)}{q(x_i)} = \sum_i (p(x_i)\log p(x_i) - p(x_i) \log q(x_i)) \\
H(p,q) &=  -\sum_ip(x_i)\log q(x_i)
\end{align}</script><p>通过上面三个公式就可以得到</p>
<script type="math/tex; mode=display">
D_{KL}(p,q) = H(p,q)- H(p)</script><p>其中，前一项<script type="math/tex">H(p,q)</script>就是<script type="math/tex">p,q</script>的交叉熵。在机器学习中，目标的分布<script type="math/tex">p(x)</script>通常是训练数据的分布是固定，即是<script type="math/tex">H(p)</script>是一个常量。这样两个分布的交叉熵<script type="math/tex">H(p,q)</script>也就等价于最小化这两个分布的相对熵<script type="math/tex">D_{KL}(p \parallel q)</script></p>
<p>设<script type="math/tex">p(x)</script>是目标分布（训练数据的分布），我们的目标的就让训练得到的分布<script type="math/tex">q(x)</script>尽可能的接近<script type="math/tex">p(x)</script>，这时候就可以最小化<script type="math/tex">D_{KL}(p∥q)</script>，等价于最小化交叉熵<script type="math/tex">H(p,q)</script>​。</p>
<h3 id="为什么要用交叉熵做loss函数"><a href="#为什么要用交叉熵做loss函数" class="headerlink" title="为什么要用交叉熵做loss函数"></a>为什么要用交叉熵做loss函数</h3><p>在线性回归问题中，常常使用MSE（Mean Squared Error）作为loss函数，比如：</p>
<script type="math/tex; mode=display">
loss = \frac{1}{2m}\sum_{i=1}^m(y_i-\hat{y_i})^2</script><p>这里的m表示m个样本的，loss为m个样本的loss均值。<br>MSE在<a href="# 回归问题">线性回归问题</a>中比较好用，那么在逻辑分类问题中还是如此么？</p>
<h3 id="交叉熵在单分类问题中的使用"><a href="#交叉熵在单分类问题中的使用" class="headerlink" title="交叉熵在单分类问题中的使用"></a>交叉熵在单分类问题中的使用</h3><p>这里的单类别是指，每一张图像样本只能有一个类别，比如只能是狗或只能是猫。<br>交叉熵在单分类问题上基本是标配的方法</p>
<script type="math/tex; mode=display">
loss=-\sum_{i=1}^{n}y_ilog(\hat{y_i})</script><p>上式为一张样本的loss计算方法。n代表着n种类别。<br>举例说明,比如有如下样本</p>
<p>对应的标签和预测值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>*</th>
<th>猫</th>
<th>青蛙</th>
<th>老鼠</th>
</tr>
</thead>
<tbody>
<tr>
<td>Label</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>Pred</td>
<td>0.3</td>
<td>0.6</td>
<td>0.1</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
\begin{eqnarray}
loss&=&-(0\times log(0.3)+1\times log(0.6)+0\times log(0.1)\\
&=&-log(0.6)
\end{eqnarray}</script><p>对应的一个batch的loss就是</p>
<script type="math/tex; mode=display">
loss=-\frac{1}{m}\sum_{j=1}^m\sum_{i=1}^{n}y_{ji}log(\hat{y_{ji}})</script><p>m为当前batch的样本数</p>
<h3 id="交叉熵在多分类问题中的使用"><a href="#交叉熵在多分类问题中的使用" class="headerlink" title="交叉熵在多分类问题中的使用"></a>交叉熵在多分类问题中的使用</h3><p>这里的多类别是指，每一张图像样本可以有多个类别，比如同时包含一只猫和一只狗<br>和单分类问题的标签不同，多分类的标签是n-hot。<br>比如下面这张样本图，即有青蛙，又有老鼠，所以是一个多分类问题</p>
<p>栗子</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>*</th>
<th>猫</th>
<th>青蛙</th>
<th>老鼠</th>
</tr>
</thead>
<tbody>
<tr>
<td>Label</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Pred</td>
<td>0.1</td>
<td>0.7</td>
<td>0.8</td>
</tr>
</tbody>
</table>
</div>
<p>值得注意的是，这里的Pred不再是通过softmax计算的了，这里采用的是sigmoid。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。换句话说，就是每一个Label都是独立分布的，相互之间没有影响。所以交叉熵在这里是单独对每一个节点进行计算，每一个节点只有两种可能值，所以是一个二项分布。前面说过对于二项分布这种特殊的分布，熵的计算可以进行简化。</p>
<p>同样的，交叉熵的计算也可以简化，即</p>
<script type="math/tex; mode=display">
loss =-ylog(\hat{y})-(1-y)log(1-\hat{y})</script><p>注意，上式只是针对一个节点的计算公式。这一点一定要和单分类loss区分开来。<br>例子中可以计算为：</p>
<script type="math/tex; mode=display">
\begin{eqnarray}
loss_猫 &=&-0\times log(0.1)-(1-0)log(1-0.1)=-log(0.9)\\
loss_蛙 &=&-1\times log(0.7)-(1-1)log(1-0.7)=-log(0.7)\\
loss_鼠 &=&-1\times log(0.8)-(1-1)log(1-0.8)=-log(0.8)
\end{eqnarray}</script><p>单张样本的loss即为<br>每一个batch的loss就是：</p>
<script type="math/tex; mode=display">
loss =\sum_{j=1}^{m}\sum_{i=1}^{n}-y_{ji}log(\hat{y_{ji}})-(1-y_{ji})log(1-\hat{y_{ji}})</script><p>式中m为当前batch中的样本量，n为类别数。</p>
<h3 id="从最大似然看交叉熵"><a href="#从最大似然看交叉熵" class="headerlink" title="从最大似然看交叉熵"></a>从<a href="# 最大似然估计">最大似然</a>看交叉熵</h3><p>设有一组训练样本$X= {x_1,x_2,\cdots,x_m}$ ,该样本的分布为$p(x)$ 。假设使用$\theta$ 参数化模型得到$q(x;\theta)$ ，现用这个模型来估计$X$ 的概率分布，得到似然函数</p>
<script type="math/tex; mode=display">
L(\theta) = q(X; \theta) = \prod_i^mq(x_i;\theta)</script><p>最大似然估计就是求得$\theta$ 使得$L(\theta)$ 的值最大，也就是</p>
<script type="math/tex; mode=display">
\theta_{ML} = arg \max_{\theta} \prod_i^mq(x_i;\theta)</script><p>对上式的两边同时取$\log$ ，等价优化$\log$ 的最大似然估计即<code>log-likelyhood</code> ，最大对数似然估计</p>
<script type="math/tex; mode=display">
\theta_{ML} = arg \max_\theta \sum_i^m \log q(x_i;\theta)</script><p>对上式的右边进行缩放并不会改变$arg \max$ 的解，上式的右边除以样本的个数$m$</p>
<script type="math/tex; mode=display">
\theta_{ML} = arg \max_\theta \frac{1}{m}\sum_i^m\log q(x_i;\theta)</script><h4 id="和相对熵等价"><a href="#和相对熵等价" class="headerlink" title="和相对熵等价"></a>和相对熵等价</h4><p>上式的最大化$\theta_{ML}$ 是和没有训练样本没有关联的，就需要某种变换使其可以用训练的样本分布来表示，因为训练样本的分布可以看作是已知的，也是对最大化似然的一个约束条件。</p>
<p>注意上式的</p>
<script type="math/tex; mode=display">
\frac{1}{m}\sum_i^m\log q(x_i;\theta)</script><p>相当于<strong>求随机变量$X$ 的函数$\log (X;\theta)$ 的均值</strong> ，根据大数定理，<strong>随着样本容量的增加，样本的算术平均值将趋近于随机变量的期望。</strong> 也就是说</p>
<script type="math/tex; mode=display">
\frac{1}{m}\sum_i^m \log q(x_i;\theta) \rightarrow E_{x\sim P}(\log q(x;\theta))</script><p>其中$E_{X\sim P}$ 表示符合样本分布$P$ 的期望，这样就将最大似然估计使用真实样本的期望来表示</p>
<script type="math/tex; mode=display">
\begin{aligned} \theta_{ML} &= arg \max_{\theta} E_{x\sim P}({\log q(x;\theta)}) \\ &= arg \min_{\theta} E_{x \sim P}(- \log q(x;\theta)) \end{aligned}</script><p>对右边取负号，将最大化变成最小化运算。</p>
<blockquote>
<p>上述的推导过程，可以参考 《Deep Learning》 的第五章。 但是，在书中变为期望的只有一句话，将式子的右边除以样本数量$m$ 进行缩放，从而可以将其变为$E_{x \sim p}\log q(x;\theta)$，没有细节过程，也可能是作者默认上面的变换对读者是一直。 确实是理解不了，查了很多文章，都是对这个变换的细节含糊其辞。一个周，对这个点一直耿耿于怀，就看了些关于概率论的科普书籍，其中共有介绍大数定理的：<strong>当样本容量趋于无穷时，样本的均值趋于其期望</strong>。</p>
<p>针对上面公式，除以$m$后，$\frac{1}{m}\sum<em>i^m\log q(x_i;\theta)$ ，确实是关于随机变量函数$\log q(x)$ 的算术平均值，而$x$ 是训练样本其分布是已知的$p(x)$ ，这样就得到了$E</em>{x \sim p}(\log q(x))$ 。</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{aligned} D_{KL}(p \parallel q) &= \sum_i p(x_i) log(\frac{p(x_i)}{q(x_i)})\\ &= E_{x\sim p}(\log \frac{p(x)}{q(x)}) \\ &= E_{x \sim p}(\log p(x) - \log q(x)) \\ &= E_{x \sim p}(\log p(x)) - E_{x \sim p} (\log q(x)) \end{aligned}</script><p>由于$E<em>{x \sim p} (\log p(x))$ 是训练样本的期望，是个固定的常数，在求最小值时可以忽略，所以最小化$D</em>{KL}(p \parallel q)$ 就变成了最小化$-E_{x\sim p}(\log q(x))$ ，这和最大似然估计是等价的。</p>
<h4 id="和交叉熵等价"><a href="#和交叉熵等价" class="headerlink" title="和交叉熵等价"></a>和交叉熵等价</h4><p>最大似然估计、相对熵、交叉熵的公式如下</p>
<script type="math/tex; mode=display">
\begin{aligned}\theta_{ML} &= -arg \min_\theta E_{x\sim p}\log q(x;\theta) \\D_{KL} &= E_{x \sim p}\log p(x) - E_{x \sim p} \log q(x) \\H(p,q) &= -\sum_i^m p(x_i) \log q(x_i) = -E_{x \sim p} \log q(x)\end{aligned}\begin{aligned}\theta_{ML} &= arg \min_\theta E_{x\sim p}\log q(x;\theta) \\D_{KL} &= E_{x \sim p}\log p(x) - E_{x \sim p} \log q(x) \\H(p,q) &= -\sum_i^m p(x_i) \log q(x_i) = -E_{x \sim p} \log q(x)\end{aligned}</script><p>从上面可以看出，最小化交叉熵，也就是最小化$D<em>{KL}$ ，从而预测的分布$q(x)$ 和训练样本的真实分布$p(x)$ 最接近。而最小化$D</em>{KL}$ 和最大似然估计是等价的。</p>
<h3 id="多分类交叉熵"><a href="#多分类交叉熵" class="headerlink" title="多分类交叉熵"></a>多分类交叉熵</h3><p>多分类任务中输出的是目标属于<strong>每个类别的概率，所有类别概率的和为1，其中概率最大的类别就是目标所属的分类。</strong> 而<code>softmax</code> 函数能将一个向量的每个分量映射到$[0,1]$ 区间，并且对整个向量的输出做了归一化，保证所有分量输出的和为1，正好满足多分类任务的输出要求。所以，在多分类中，在最后就需要将提取的到特征经过<code>softmax</code>函数的，输出为每个类别的概率，然后再使用<strong>交叉熵</strong> 作为损失函数。</p>
<p><code>softmax</code>函数定义如下：</p>
<script type="math/tex; mode=display">
S_i = \frac{e^{z_i}}{\sum^n_{i=1}e^{z_i}}</script><p>其中，输入的向量为$z_i(i = 1,2,\dots,n)$ 。</p>
<p>更直观的参见下图</p>
<p><img src="https://s2.loli.net/2024/06/07/XvLsuFKjBe39AaD.png" alt="img"></p>
<p>通过前面的特征提取到的特征向量为$(z_1,z_2,\dots,z_k)$ ，将向量输入到<code>softmax</code>函数中，即可得到目标属于每个类别的概率，概率最大的就是预测得到的目标的类别。</p>
<h4 id="Cross-Entropy-Loss"><a href="#Cross-Entropy-Loss" class="headerlink" title="Cross Entropy Loss"></a>Cross Entropy Loss</h4><p>使用<code>softmax</code>函数可以将特征向量映射为所属类别的概率，可以看作是预测类别的概率分布$q(c_i)$ ，有</p>
<script type="math/tex; mode=display">
q(c_i) = \frac{e^{z_i}}{\sum^n_{i=1}e^{z_i}}</script><p>其中$c_i$ 为某个类别。</p>
<p>设训练数据中类别的概率分布为$p(c_i)$ ，那么目标分布$p(c_i)$ 和预测分布$q(c_i)$的交叉熵为</p>
<script type="math/tex; mode=display">H(p,q) =-\sum_ip(c_i)\log q(c_i)</script><p>每个训练样本所属的类别是已知的，并且每个样本只会属于一个类别（概率为1），属于其他类别概率为0。具体的，可以假设有个三分类任务，三个类分别是：猫，猪，狗。现有一个训练样本类别为猫，则有：</p>
<script type="math/tex; mode=display">\begin{align} p(cat) & = 1 \\ p(pig) &= 0 \\ p(dog) & = 0 \end{align}</script><p>通过预测得到的三个类别的概率分别为：$q(cat) = 0.6,q(pig) = 0.2,q(dog) = 0.2$ ，计算$p$ 和$q$ 的交叉熵为：</p>
<script type="math/tex; mode=display">
\begin{aligned} H(p,q) &= -(p(cat) \log q(cat) + p(pig) + \log q(pig) + \log q(dog)) \\ &= - (1 \cdot \log 0.6 + 0 \cdot \log 0.2 +0 \cdot \log 0.2) \\ &= - \log 0.6 \\ &= - \log q(cat) \end{aligned}</script><p>利用这种特性，可以将样本的类别进行重新编码，就可以简化交叉熵的计算，这种编码方式就是<strong>one-hot</strong> 编码。以上面例子为例，</p>
<script type="math/tex; mode=display">
\begin{aligned} \text{cat} &= (1 0 0) \\ \text{pig} &= (010) \\ \text{dog} &= (001) \end{aligned}</script><p>通过这种编码方式，在计算交叉熵时，只需要计算和训练样本对应类别预测概率的值，其他的项都是$0 \cdot \log q(c_i) = 0$ 。</p>
<p>具体的，交叉熵计算公式变成如下：</p>
<script type="math/tex; mode=display">
(p,q) = - \log q(c_i)</script><p>其中$c_i$ 为训练样本对应的类别，上式也被称为<strong>负对数似然（negative log-likelihood,nll）</strong>。</p>
<h4 id="PyTorch中的Cross-Entropy"><a href="#PyTorch中的Cross-Entropy" class="headerlink" title="PyTorch中的Cross Entropy"></a>PyTorch中的Cross Entropy</h4><p>PyTorch中实现交叉熵损失的有三个函数<code>torch.nn.CrossEntropyLoss</code>，<code>torch.nn.LogSoftmax</code>以及<code>torch.nn.NLLLoss</code>。</p>
<ul>
<li><code>torch.nn.functional.log_softmax</code> 比较简单，输入为$n$维向量，指定要计算的维度<code>dim</code>，输出为$log(Softmax(x))$。其计算公式如下：</li>
</ul>
<script type="math/tex; mode=display">
\text{LogSoftmax}(x_i) = \log (\frac{\exp(x_i)}{\sum_j \exp(x_j)})</script><p>没有额外的处理，就是对输入的$n$维向量的每个元素进行上述运算。</p>
<ul>
<li><code>torch.nn.functional.nll_loss</code> 负对数似然损失（Negative Log Likelihood Loss)，用于多分类，其输入的通常是<code>torch.nn.functional.log_softmax</code>的输出值。其函数如下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.functional.nll_loss(<span class="built_in">input</span>, target, weight=<span class="literal">None</span>, size_average=<span class="literal">None</span>, ignore_index=-<span class="number">100</span>, reduce=<span class="literal">None</span>, reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>input</code> 也就是<code>log_softmax</code>的输出值，各个类别的对数概率。<code>target</code> 目标正确类别,<code>weight</code> 针对类别不平衡问题，可以为类别设置不同的权值；<code>ignore_index</code> 要忽略的类别，不参与loss的计算；比较重要的是<code>reduction</code> 的值，有三个取值：<code>none</code> 不做处理，输出的结果为向量；<code>mean</code> 将<code>none</code>结果求均值后输出；<code>sum</code> 将<code>none</code> 结果求和后输出。</p>
<ul>
<li><code>torch.nn.CrossEntropyLoss</code>就是上面两个函数的组合<code>nll_loss(log_softmax(input))</code>。</li>
</ul>
<h3 id="二分类交叉熵"><a href="#二分类交叉熵" class="headerlink" title="二分类交叉熵"></a>二分类交叉熵</h3><p>多分类中使用<code>softmax</code>函数将最后的输出映射为每个类别的概率，而在二分类中则通常使用<code>sigmoid</code> 将输出映射为正样本的概率。这是因为二分类中，只有两个类别：{正样本，负样本}，只需要求得正样本的概率$q$,则$1-q$ 就是负样本的概率。这也是多分类和二分类不同的地方。</p>
<p>$\text{sigmoid}$ 函数的表达式如下：</p>
<script type="math/tex; mode=display">
\sigma(z) = \frac{1}{1 + e^{-z}}</script><p>sigmoid的输入为$z$ ，其输出为$(0,1)$ ，可以表示分类为正样本的概率。</p>
<p>二分类的交叉熵可以看作是交叉熵损失的一个特列，交叉熵为</p>
<script type="math/tex; mode=display">
\text{$Cross\_Entorpy$}(p,q) = -\sum_i^m p(x_i) \log q(x_i)</script><p>这里只有两个类别$x \in {x_1,x_2}$ ，则有</p>
<script type="math/tex; mode=display">
\begin{aligned}\text{$Cross\_Entorpy$}(p,q) &= -(p(x_1) \log q(x_1) + p(x_2) \log q(x_2)) \end{aligned}</script><p>因为只有两个选择，则有$p(x_1) + p(x_2) = 1,q(x_1) + q(x_2) = 1$ 。设，训练样本中$x_1$的概率为$p$，则$x_2$为$1-p$; 预测的$x_1$的概率为$q$，则$x_2$的预测概率为$1 - q$ 。则上式可改写为</p>
<script type="math/tex; mode=display">
\text{$Cross\_Entropy$}(p,q) = -(p \log q + (1-p) \log (1-q))</script><p>也就是二分类交叉熵的损失函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相对熵可以用来度量两个分布相似性，假设分布$p$是训练样本的分布，$q$是预测得到的分布。分类训练的过程实际上就是最小化$D_{KL}(p \parallel q)$，由于由于交叉熵</p>
<script type="math/tex; mode=display">
H(p,q)= D_{KL}(p \parallel q) + H(p)</script><p>其中,$H(p)$是训练样本的熵，是一个已知的常量，这样最小化相对熵就等价于最小化交叉熵。</p>
<p>从最大似然估计转化为最小化负对数似然</p>
<script type="math/tex; mode=display">
\theta_{ML} = -arg \min_\theta E_{x\sim p}\log q(x;\theta)</script><p>也等价于最小化相对熵。</p>
<h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2><p>回归：人们在测量事物的时候因为客观条件所限，求得的都是测量值，而不是事物真实的值，为了能够得到真实值，无限次的进行测量，最后通过这些测量数据计算<strong>回归到真实值</strong>，这就是回归的由来。</p>
<p>回归分析的主要算法包括：</p>
<ol>
<li>线性回归(Linear Regression)</li>
<li>逻辑回归（Logistic regressions）</li>
<li>多项式回归(Polynomial Regression)</li>
<li>逐步回归(Step Regression)</li>
<li>岭回归(Ridge Regression)</li>
<li>套索回归(Lasso Regression)</li>
<li>弹性网回归(ElasticNet)</li>
</ol>
<h2 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h2><p>wiki定义：<code>在统计学中，最大似然估计（英语：maximum likelihood estimation，简作MLE），也称极大似然估计，是用来估计一个概率模型的参数的一种方法。</code></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>给定一个概率分布𝐷，已知其<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5qaC546H5a+G5bqm5Ye95pWw">概率密度函数<i class="fa fa-external-link-alt"></i></span>（连续分布）或<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5qaC546H6LSo6YeP5Ye95pWw">概率质量函数<i class="fa fa-external-link-alt"></i></span>（离散分布）为𝑓𝐷，以及一个分布参数𝜃，我们可以从这个分布中抽出一个具有𝑛个值的采样𝑋1,𝑋2,…,𝑋𝑛，利用𝑓𝐷计算出其<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Ly854S25Ye95pWw">似然函数<i class="fa fa-external-link-alt"></i></span>：</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a9702eeec5a8eb416883af66665ac11bd8151f0f" alt="{\displaystyle {\mbox{L}}(\theta \mid x_{1},\dots ,x_{n})=f_{\theta }(x_{1},\dots ,x_{n}).}"></p>
<p>若𝐷是离散分布，𝑓𝜃即是在参数为𝜃时观测到这一采样的概率；若其是连续分布，𝑓𝜃则为𝑋1,𝑋2,…,𝑋𝑛联合分布的概率密度函数在观测值处的取值。一旦我们获得𝑋1,𝑋2,…,𝑋𝑛，我们就能求得一个关于𝜃的估计。最大似然估计会寻找关于𝜃的最可能的值（即，在所有可能的𝜃取值中，寻找一个值使这个采样的“可能性”最大化）。从数学上来说，我们可以在𝜃的所有可能取值中寻找一个值使得似然<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5Ye95pWw">函数<i class="fa fa-external-link-alt"></i></span>取到最大值。这个使可能性最大的<script type="math/tex">\hat 𝜃</script>值即称为𝜃的<strong>最大似然估计</strong>。由定义，最大似然估计是样本的函数。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5pyA5aSn5Ly854S25Lyw6K6h">最大似然估计 - 维基百科，自由的百科全书 (wikipedia.org)<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>专题</category>
        <category>机器学习</category>
        <category>Mindspore</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MindSpore</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>MindSpore专题——番外、Trans Fore模型</title>
    <url>/2024/special_subject/MindSpore/Chapters/TransformerStructure/article.html</url>
    <content><![CDATA[<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><p>Transformer是一种神经网络结构，有Vaswani等人在2017年的论文“Attention Is All You Need”中提出，用于处理机器翻译、语言建模和文本生成登自然语言处理任务。</p>
<span id="more"></span>
<p>Transformer与传统NLP特征提取类模型的区别主要在以下两点。</p>
<ul>
<li>Transformer是一个纯基于注意力机制的结构，并将自<strong>注意力机制</strong>和<strong>多头注意力机制</strong>的概念运用到模型中；</li>
<li>由于缺少RNN模型的时序性，Transformer引入了位置编码，在数据上而非模型中添加位置信息；</li>
</ul>
<p>以上的处理带来了几个优点</p>
<ul>
<li>更容易并行化，训练更加高效；</li>
<li>在处理长序列的任务中表现优秀，可以快速捕捉长距离中的关联信息；</li>
</ul>
<h2 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h2><p>注意力机制是判断词在句子中的重要性，通过<strong>注意力分数</strong>来表达某个词在句子中的重要性</p>
<h3 id="注意力分数的计算"><a href="#注意力分数的计算" class="headerlink" title="注意力分数的计算"></a>注意力分数的计算</h3><h4 id="query、key、value"><a href="#query、key、value" class="headerlink" title="query、key、value"></a>query、key、value</h4><ul>
<li>query:任务内容<em>目标序列</em></li>
<li>key:索引/标签（帮助定位到答案）<em>原序列</em></li>
<li>value:答案</li>
</ul>
<p><img src="https://s2.loli.net/2024/06/29/ESPv4kLWxinFZqy.png" alt="image-20240629145758835"></p>
<h4 id="常用的计算注意力分数的方法"><a href="#常用的计算注意力分数的方法" class="headerlink" title="常用的计算注意力分数的方法"></a>常用的计算注意力分数的方法</h4><p>additive attention可加性注意力计算方法</p>
<p>scaled dot-product attention缩放的“点-积”注意力</p>
]]></content>
      <categories>
        <category>专题</category>
        <category>机器学习</category>
        <category>Mindspore</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MindSpore</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>MindSpore专题——第三章——张量</title>
    <url>/2024/special_subject/MindSpore/Chapters/Third_Tensor/article.html</url>
    <content><![CDATA[<h2 id="张量-Tensor"><a href="#张量-Tensor" class="headerlink" title="张量 Tensor"></a>张量 Tensor</h2><p>​    张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 $n$ 维空间内，有 $n^r$ 个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。$r$ 称为该张量的秩或阶（与矩阵的秩和阶均无关系）。</p>
<span id="more"></span>
<p>​    张量是一种特殊的数据结构，与数组和矩阵非常相似，他表示的是一种多维的“矩阵”的集合。张量（<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuVGVuc29yLmh0bWw=">Tensor<i class="fa fa-external-link-alt"></i></span>）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。</p>
<p>​    <em>矩阵的秩或阶是人工智能中基础且常考的考点：一般形式是求矩阵秩是多少</em></p>
<p>下面是对张量在MindSpore中的实践</p>
<h3 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h3><ol>
<li><strong>根据数据直接生成</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">x_data = Tensor(data)</span><br><span class="line"><span class="built_in">print</span>(x_data, x_data.shape, x_data.dtype)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[1 0 1 0] (4,) Int64</p>
</blockquote>
<ol>
<li><strong>从NumPy数组生成</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np_array = np.array(data)</span><br><span class="line">x_np = Tensor(np_array)</span><br><span class="line"><span class="built_in">print</span>(x_np, x_np.shape, x_np.dtype)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[1 0 1 0] (4,) Int64</p>
</blockquote>
<ol>
<li><strong>使用init初始化器构造张量</strong></li>
</ol>
<p>​    当使用<code>init</code>初始化器对张量进行初始化时，支持传入的参数有<code>init</code>、<code>shape</code>、<code>dtype</code>。</p>
<ul>
<li><p><code>init</code>: 支持传入<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbA==">initializer<i class="fa fa-external-link-alt"></i></span>的子类。如：下方示例中的 <span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbCNtaW5kc3BvcmUuY29tbW9uLmluaXRpYWxpemVyLk9uZQ==">One()<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS5jb21tb24uaW5pdGlhbGl6ZXIuaHRtbCNtaW5kc3BvcmUuY29tbW9uLmluaXRpYWxpemVyLk5vcm1hbA==">Normal()<i class="fa fa-external-link-alt"></i></span>。</p>
<ul>
<li><p><code>shape</code>: 支持传入 <code>list</code>、<code>tuple</code>、 <code>int</code>。</p>
</li>
<li><p><code>dtype</code>: 支持传入<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuZHR5cGUuaHRtbCNtaW5kc3BvcmUuZHR5cGU=">mindspore.dtype<i class="fa fa-external-link-alt"></i></span>。</p>
</li>
</ul>
</li>
</ul>
<ol>
<li>继承张量并形成新的张量</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mindspore <span class="keyword">import</span> ops</span><br><span class="line"></span><br><span class="line">x_ones = ops.ones_like(x_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;x_ones&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">x_zeros = ops.zeros_like(x_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Zeros Tensor: \n <span class="subst">&#123;x_zeros&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="张量的属性"><a href="#张量的属性" class="headerlink" title="张量的属性"></a>张量的属性</h3><ul>
<li>张量的属性包括形状、数据类型、转置张量、单个元素大小、占用字节数量、维数、元素个数和每一维步长。<ul>
<li>形状（shape）：<code>Tensor</code>的shape，是一个tuple（元组，python中的数据类型标签）。</li>
<li>数据类型（dtype）：<code>Tensor</code>的dtype，是MindSpore的一个数据类型。</li>
<li>单个元素大小（itemsize）： <code>Tensor</code>中每一个元素占用字节数，是一个整数。</li>
<li>占用字节数量（nbytes）： <code>Tensor</code>占用的总字节数，是一个整数。</li>
<li>维数（ndim）： <code>Tensor</code>的秩，也就是len(tensor.shape)，是一个整数。</li>
<li>元素个数（size）： <code>Tensor</code>中所有元素的个数，是一个整数。</li>
<li>每一维步长（strides）： <code>Tensor</code>每一维所需要的字节数，是一个tuple。</li>
</ul>
</li>
</ul>
<p>为更简单的理解shape的含义，我修改了一下官方文档中的x张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Tensor(np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]), mindspore.int32)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_shape:&quot;</span>, x.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_dtype:&quot;</span>, x.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_itemsize:&quot;</span>, x.itemsize)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_nbytes:&quot;</span>, x.nbytes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_ndim:&quot;</span>, x.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_size:&quot;</span>, x.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_strides:&quot;</span>, x.strides)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x_shape: (3, 2)<br>x_dtype: Int32<br>x_itemsize: 4<br>x_nbytes: 24<br>x_ndim: 2<br>x_size: 6<br>x_strides: (8, 4)</p>
</blockquote>
<h3 id="张量的下标索引"><a href="#张量的下标索引" class="headerlink" title="张量的下标索引"></a>张量的下标索引</h3><p>Tensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号<code>:</code>和 <code>...</code>用于对数据进行切片。切片的意思是后面的参数是按行算的还是按列算的，详细请看代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor = Tensor(np.array([[0, 1], [2, 3]]).astype(np.float32))</span><br><span class="line"></span><br><span class="line">print(&quot;First row: &#123;&#125;&quot;.format(tensor[0]))</span><br><span class="line">print(&quot;value of bottom right corner: &#123;&#125;&quot;.format(tensor[1, 1]))</span><br><span class="line">print(&quot;Last column: &#123;&#125;&quot;.format(tensor[:, -1]))</span><br><span class="line">print(&quot;First column: &#123;&#125;&quot;.format(tensor[..., 0]))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>First row: [0. 1.]<br>value of bottom right corner: 3.0<br>Last column: [1. 3.]<br>First column: [0. 2.]</p>
</blockquote>
<h3 id="张量运算"><a href="#张量运算" class="headerlink" title="张量运算"></a>张量运算</h3><p>张量之间有很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，张量运算和NumPy的使用方式类似，下面介绍其中几种操作。</p>
<blockquote>
<p>普通算术运算有：加（+）、减（-）、乘（*）、除（/）、取模（%）、整除（//）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Tensor(np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), mindspore.float32)</span><br><span class="line">y = Tensor(np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]), mindspore.float32)</span><br><span class="line"></span><br><span class="line">output_add = x + y</span><br><span class="line">output_sub = x - y</span><br><span class="line">output_mul = x * y</span><br><span class="line">output_div = y / x</span><br><span class="line">output_mod = y % x</span><br><span class="line">output_floordiv = y // x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;add:&quot;</span>, output_add)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sub:&quot;</span>, output_sub)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mul:&quot;</span>, output_mul)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;div:&quot;</span>, output_div)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mod:&quot;</span>, output_mod)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;floordiv:&quot;</span>, output_floordiv)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>add: [5. 7. 9.]<br>sub: [-3. -3. -3.]<br>mul: [ 4. 10. 18.]<br>div: [4.  2.5 2. ]<br>mod: [0. 1. 0.]<br>floordiv: [4. 2. 2.]</p>
</blockquote>
<p>对于一些函数的使用，这里之贴出定义，详细运行库中代码（个人觉得没必要，知道这些函数即可，毕竟到处可见类似函数）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLmNvbmNhdC5odG1s">concat<i class="fa fa-external-link-alt"></i></span>() : 将给定维度上的一系列张量连接起来，0表示最高得也就是直接通过<code>张量名[下标索引]</code>时的张量名所代表的元组。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL29wcy9taW5kc3BvcmUub3BzLnN0YWNrLmh0bWw=">stack<i class="fa fa-external-link-alt"></i></span>()：则是从另一个维度上将两个张量合并起来。（新建一个维度）</p>
<h3 id="Tensor与Numpy之间的相互转化"><a href="#Tensor与Numpy之间的相互转化" class="headerlink" title="Tensor与Numpy之间的相互转化"></a>Tensor与Numpy之间的相互转化</h3><p>Tensor() : 将ndarray转化为Tensor</p>
<p>asnumpy()：将Tensor转化为ndarray</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = Tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>, <span class="built_in">type</span>(t))</span><br><span class="line">n = t.asnumpy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>, <span class="built_in">type</span>(n))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>t: [1. 1. 1. 1. 1.] <class 'mindspore.common.tensor.Tensor'><br>n: [1. 1. 1. 1. 1.] <class 'numpy.ndarray'></p>
</blockquote>
<p>将NumPy变量转换为Tensor变量同样也不贴出来了，详情请运行本章代码对应部分查看</p>
<p>有一个值得注意的点： </p>
<p>当我们运行代码时调用了<code>np.add(n, 1, out=n)</code>函数，该函数<strong>同时改变了我们的Numpy数据和Tensor数据</strong>，这说明当我们进行转化时我们并没有创建新的变量，而是创建了新的变量指针。</p>
<h2 id="稀疏张量"><a href="#稀疏张量" class="headerlink" title="稀疏张量"></a>稀疏张量</h2><p>稀疏张量是一种特殊张量，其中绝大部分元素的值为零。</p>
<p>在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。</p>
<p>两种常用的稀疏张量格式</p>
<ol>
<li>CRS（Compressed Sparse Row）其中，非零元素的值存储在<code>values</code>中，非零元素的位置存储在<code>indptr</code>（行）和<code>indices</code>（列）中。</li>
<li>COOCoordinate Format）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为<code>N</code>，被压缩的张量的维数为<code>ndims</code>。</li>
</ol>
<p>常用稀疏张量的表达形式是<code>&lt;indices:Tensor, values:Tensor, shape:Tensor&gt;</code>。其中，<code>indices</code>表示非零下标元素， <code>values</code>表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。在这个结构下，我们定义了三种稀疏张量结构：<code>CSRTensor</code>、<code>COOTensor</code>和<code>RowTensor</code>。</p>
<h3 id="CSRTensor"><a href="#CSRTensor" class="headerlink" title="CSRTensor"></a>CSRTensor</h3><ul>
<li><code>indptr</code>: 一维整数张量, 表示稀疏数据每一行的非零元素在<code>values</code>中的起始位置和终止位置, 索引数据类型支持int16、int32、int64。</li>
<li><code>indices</code>: 一维整数张量，表示稀疏张量非零元素在列中的位置, 与<code>values</code>长度相等，索引数据类型支持int16、int32、int64。</li>
<li><code>values</code>: 一维张量，表示<code>CSRTensor</code>相对应的非零元素的值，与<code>indices</code>长度相等。</li>
<li><code>shape</code>: 表示被压缩的稀疏张量的形状，数据类型为<code>Tuple</code>，目前仅支持二维<code>CSRTensor</code>。</li>
</ul>
<h3 id="COOTensor"><a href="#COOTensor" class="headerlink" title="COOTensor"></a>COOTensor</h3><ul>
<li><code>indices</code>: 二维整数张量，每行代表非零元素下标。形状：<code>[N, ndims]</code>， 索引数据类型支持int16、int32、int64。</li>
<li><code>values</code>: 一维张量，表示相对应的非零元素的值。形状：<code>[N]</code>。</li>
<li><code>shape</code>: 表示被压缩的稀疏张量的形状，目前仅支持二维<code>COOTensor</code>。</li>
</ul>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>在源代码最后有CSRTensor、COOTensor的使用实例</p>
<p>这里得给出代码，我做了一些修改，不然不好理解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CSRTensor 稀疏张量表实例</span></span><br><span class="line">indptr = Tensor([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">indices = Tensor([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">values = Tensor([<span class="number">1</span>, <span class="number">2</span>], dtype=mindspore.float32)</span><br><span class="line">shape = (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a CSRTensor</span></span><br><span class="line">csr_tensor = CSRTensor(indptr, indices, values, shape)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(csr_tensor.astype(mindspore.float64).dtype)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(csr_tensor)</span><br><span class="line"></span><br><span class="line">indices = Tensor([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]], dtype=mindspore.int32)</span><br><span class="line">values = Tensor([<span class="number">1</span>, <span class="number">2</span>], dtype=mindspore.float32)</span><br><span class="line">shape = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a COOTensor</span></span><br><span class="line">coo_tensor = COOTensor(indices, values, shape)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(coo_tensor)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Float64<br>CSRTensor(shape=[2, 4], </p>
<p>dtype=Float32,</p>
<p> indptr=Tensor(shape=[3], dtype=Int64, value=[0 1 2]), </p>
<p>indices=Tensor(shape=[2], dtype=Int64, value=[0 1]), </p>
<p>values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))<br>COOTensor(shape=[3, 4], </p>
<p>dtype=Float32, </p>
<p>indices=Tensor(shape=[2, 2], dtype=Int32, value=[[0 1] [1 2]]), </p>
<p>values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))</p>
</blockquote>
<p>其生成实例如下</p>
<p>CSRTensor: </p>
<script type="math/tex; mode=display">
\begin{split}\left[
\begin{matrix}
  1 & 0 & 0 & 0 \\
  0 & 2 & 0 & 0
 \end{matrix}
 \right]\end{split}</script><p>COOTensor:</p>
<script type="math/tex; mode=display">
\begin{split}\left[
\begin{matrix}
  0 & 1 & 0 & 0 \\
  0 & 0 & 2 & 0 \\
  0 & 0 & 0 & 0
 \end{matrix}
 \right]\end{split}</script><ul>
<li>CSRTensor(indptr, indices, values, shape)： 构造一个CSR稀疏张量表</li>
<li>COOTensor(indices, values, shape) ：构造一个COO稀疏张量表</li>
</ul>
<p>理解不了CSR请参考:<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuQ1NSVGVuc29yLmh0bWw=">MindSpore<i class="fa fa-external-link-alt"></i></span></p>
<p>理解不了COO请参考:<span class="exturl" data-url="aHR0cHM6Ly93d3cubWluZHNwb3JlLmNuL2RvY3MvemgtQ04vcjIuMi9hcGlfcHl0aG9uL21pbmRzcG9yZS9taW5kc3BvcmUuQ09PVGVuc29yLmh0bWw=">MindSpore<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>专题</category>
        <category>机器学习</category>
        <category>Mindspore</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MindSpore</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>状态转移习题</title>
    <url>/2024/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E4%B9%A0%E9%A2%98/article.html</url>
    <content><![CDATA[<h1 id="题意">题意：</h1>
<p>给你一个数组[𝑝1,𝑝2,…,𝑝𝑛] ，其中所有元素都是不同的。</p>
<p>你可以对它执行几个(可能是零)操作。在一个操作中，你可以从 p
中选择一个<strong>连续的子段</strong>，然后从该子段中删除<strong>所有</strong>元素，<strong>除</strong>该子段中最小的元素。例如，如果选择p
= [3, 1, 4, 7, 5, 2,
6]，并选择从，并选择从3元素到−𝑟𝑑元素到6元素的子段，那么得到的数组就是−𝑡ℎ元素的子段，那么得到的数组就是[3,
1, 2, 6]。</p>
<p>如果数组
a可以从可以从p中通过上述几种也许是零种操作得到，那么这个数组中通过上述几种(也许是零种)操作得到，那么这个数组a
就叫做可达数组。计算可达数组的个数，并打印出它的模数 998244353。</p>
<h1 id="题解">题解：</h1>
<p>根据题目答案数据范围，很容易想到通过区间修改暴力答案是不可行的。于是转向dp想法，一个简单的构型是，对于每个i结尾的结果数组计算贡献值。思考状态转移，需要计算如何在保留
𝑎𝑖 的情况下的贡献值。</p>
<p>考虑操作对于保留最小值的设定，该操作具有结合律，可以想到， 𝑎𝑖
是后缀操作区间（如进行[n-1,n],[n-3.n-2]的操作等同于操作后缀[n-3,n]）最小值一定成立。则状态转移为其中dp(i)+=dp(j)(其中a[j]&lt;a[i])另外一种情况则是，不对i进行操作。考虑上一个比a[i]小的数为<span
class="math inline">\(l*{a_i}\)</span>下标为，则小于且大于下标为j，则小于j且大于l<em>{a</em>j}的下标的下标均无法转移至，显然的下标k的下标idx均无法转移至i，显然l<em>{a</em>i}是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于的下标如果其不等于是无法通过操作区间中比它大的数移除的，这是可以推广的，即对任意下标小于j的下标x如果其不等于<span
class="math inline">\(l*{a_x}\)</span>则无法转移到i。</p>
<p>总结状态转移为<span class="math inline">\(f*i =
\sum*{k={l*{a_i}+1}}^{i-1} f_k +
\sum*{k=l^x(l*{a_i})}^{k&gt;0}f*{k}\)</span></p>
<p>前缀和处理即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	void slove()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    s[top] = &#123;-1,-1&#125;;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++) &#123;</span><br><span class="line">        while(top &amp;&amp; s[top].x &gt; a[i]) top--;</span><br><span class="line">        l[i] = s[top].y;</span><br><span class="line">        s[++top] = &#123;a[i],i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for(int i=1;i&lt;=n;i++) cout&lt;&lt;l[i]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">    // cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;=n;i++) pre1[i] = pre2[i] = 0;</span><br><span class="line"></span><br><span class="line">    f[0] = 1;</span><br><span class="line">    pre1[0] = 1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        if(l[i]!=-1) pre2[i] = pre2[l[i]] + f[l[i]] % MOD;</span><br><span class="line">        int t = l[i] == -1 ? 0: pre1[l[i]];</span><br><span class="line">        f[i] = (pre1[i-1] - t) % MOD ;</span><br><span class="line">        // cout&lt;&lt;(pre1[i-1] - t)&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        f[i] += pre2[i];</span><br><span class="line"></span><br><span class="line">        pre1[i] = pre1[i-1] + f[i] % MOD;</span><br><span class="line">        // cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;pre1[i]&lt;&lt;&#x27; &#x27;&lt;&lt;pre2[i]&lt;&lt;&#x27; &#x27;&lt;&lt;f[i]&lt;&lt;nline;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mi = 1e18,ans = 0;</span><br><span class="line">    for(int i=n; i&gt;=1; i--) &#123;</span><br><span class="line">        mi = min(mi,a[i]);</span><br><span class="line">        if(mi==a[i]) &#123;</span><br><span class="line">            ans = (ans + f[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="题意-1">题意：</h1>
<p>给你一个整数数组 1, 2,…, ，它的所有元素都是不同的。</p>
<p>首先，要求你在数组中再插入一个整数 an+1 。 an +1 不应等于 a1, a2,…,
an中的任何一个。</p>
<p>然后，你必须使数组中的所有元素相等。一开始，你选择一个<strong>正</strong>整数
x。在一次操作中，你将 x 恰好加到数组的一个元素上。<strong>注意， x
在所有操作中都是一样的</strong>。</p>
<p>选择 +1 和 x 后，使所有元素相等的最小操作次数是多少？</p>
<h1 id="题解-1">题解：</h1>
<p>容易误解的点在于——对一个新增的数x，能否找到 ∑𝑖=1𝑖=𝑛𝑥−𝑎𝑖(𝑥−𝑎𝑖) 小于
∑𝑖=1𝑖=𝑛𝑚𝑥−𝑎𝑖(𝑚𝑥−𝑎𝑖)
（mx表示数组中的最大值）由于笔者太拉昆了，暂时先不证明了。。。</p>
<p>可以凭直觉猜出一个解法，最大的数不变𝑎𝑛𝑠=∑𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖])(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))+𝑎𝑑𝑑𝑡𝑖𝑜𝑛其中addtion为以最大公倍数为步减的最大值(𝑚𝑥−𝑎𝑛+1)/(𝑑𝑖𝑓(𝑚𝑥,𝑎[𝑖]))。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void slove()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    int mx = -INF;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        mx = max(mx,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++) d[i] = mx - a[i];</span><br><span class="line"></span><br><span class="line">    int gd = 0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) gd = __gcd(d[i],gd);</span><br><span class="line"></span><br><span class="line">    if(!gd) &#123;cout&lt;&lt;1&lt;&lt;endl;return ;&#125;</span><br><span class="line"></span><br><span class="line">    ll sum = 0;</span><br><span class="line">    set&lt;int&gt; S;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) sum += (mx - a[i]) / gd,S.insert((mx - a[i]) / gd);</span><br><span class="line">    int t = 1;</span><br><span class="line">    while(1) if(S.count(t)) t++;else break;</span><br><span class="line">    cout&lt;&lt;sum + t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="题意-2">题意：</h1>
<p>对一个数组的所有非空子区间，计算这个公式<span
class="math display">\[w = \sum_{i=l}^{i=r} \sum_{j=l}^{j=r}a_i \oplus
a_j \]</span>的和。</p>
<span id="more"></span>
<h1 id="题解-2">题解：</h1>
<p>非常经典的题目，看见了就再巩固一下。</p>
<ol type="1">
<li>拆位，
对于异或这个操作来看，是以位为单位进行的（而且根据数据范围也很容易想到）。我们需要对位进行处理。
即将整个数组拆分为<span class="math inline">\(\lceil
log_2mx\rceil\)</span>个数组。计算每一位的贡献。</li>
</ol>
<p>当拆位后原式子会变为这样的 <span class="math display">\[
allW =
\sum_{l=1}^{l=r}\sum_{r=l}^{r=n}\sum_{i=l}^{i=r}\sum_{x=0}^{x=\lceil
log_2mx\rceil}cnt(a_{i-x} != a_{x})
\]</span> 这个复杂度仍然是爆炸的，因此需要继续优化</p>
<p>很容易想到的一个优化就是，对于<span class="math display">\[a_i \oplus
a_j\]</span>他是满足交换律的，即<span class="math display">\[a_i \oplus
a_j = a_j \oplus a_i\]</span>因此我们仅需要计算单边值即可（然后乘2。</p>
<p>因此将原有的式子改写<span class="math display">\[w =2 \times
(\sum_{i=l}^{i=r} \sum_{j=l}^{j=i}a_i \oplus a_j) \]</span>虽然对于<span
class="math display">\[a_i\]</span>本身来说，他仍是对自身算一次的，但异或一定为0，因此不考虑。</p>
<p>再转头考虑所有子区间的问题，一个数组的所有子区间显然是<span
class="math display">\[n^2\]</span>级，因此枚举或计算子区间都是无意义的。根据之前的推论，使用经典方法，确定右端点，变化左端点。考虑对每个左右端点i,j计算当前包含的区间数为<span
class="math display">\[i\times
(n-j+1)\]</span>（下标从1开始），则对任意i,j，其贡献值为以下公式 <span
class="math display">\[
w(bt,{i,j}) = (i\times (n-j+1) * (1&lt;&lt;bt) *
(bit(x,a_i)\not=bit(x,a_j))
\]</span> 施展数学的神奇魔法！</p>
<p>提取公因子，我们便会惊奇的发现，整个问题变成了对于以j结尾的子区间计算<span
class="math display">\[a_j\]</span> 与<span
class="math display">\[a_i|i&lt;j\]</span>的在x位上的贡献值。此时静下心来思考维护的数据则是，当前位为0的下标之和与为1的下标之和。</p>
<p>最后，让我们总结一下，其实很多做法很常见，比如枚举右端点，比如交换律，比如提取公因子，可以说这是基本。总的来讲，这个题就仅仅考了拆位而已，符合小白赛难度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> bt = <span class="number">0</span>;bt &lt;=<span class="number">29</span>;bt++) &#123;</span><br><span class="line">        ll s1=<span class="number">0</span>,s2 =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt;&gt;bt&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                ans = (ans + s2 * (n-i<span class="number">+1</span>) % MOD * (<span class="number">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class="line">                s1 += i;</span><br><span class="line">                s1 %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = (ans + s1 * (n-i<span class="number">+1</span>) % MOD * (<span class="number">1</span>&lt;&lt;bt) % MOD) % MOD;</span><br><span class="line">                s2 += i;</span><br><span class="line">                s2 %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(<span class="number">2ll</span> * ans)%MOD&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知不觉已经写了这么多，这题上次见还是许久之前，没想到再见已有这么长时日了，我居然看了这么久，mark。。。</p>
<hr />
<h1 id="题意-3">题意：</h1>
<p>给定m条线段，求将1-n覆盖两次的所有方案数</p>
<!--more-->
<h1 id="题解-3">题解：</h1>
<p>离散数据之后，直接设计dp即可。首先应该注意到对端点进行离散化，然后为简化思考量，我们将整体线段二键值排序。可以观察到，如果出现了悬空（并不前缀）的二次覆盖，如(1-4,2-5)，出现1未二次覆盖，而2覆盖的情况是必然非法的。因为二键值排序使得1永远也不会被覆盖了。因此很容易想到对一次覆盖，二次覆盖的前缀状态做dp。</p>
<p>个人认为dp最好的老师是暴力，因此本篇将会贴出tle的暴力解法。</p>
<p>状态表示这样设计：<span
class="math display">\[dpi,j,k\]</span>表示对前i段线段，覆盖两次最长前缀长度j，覆盖一次最长浅醉长度k的所有方案数。</p>
<p>之后可以根据segs[i].x
是否小于两个前缀长度做转移了。暴力转移code如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class="line">        poss.<span class="built_in">push_back</span>(segs[i].x);</span><br><span class="line">        poss.<span class="built_in">push_back</span>(segs[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    poss.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    poss.<span class="built_in">push_back</span>(n);</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(poss));</span><br><span class="line">    poss.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(poss)),poss.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;poss.<span class="built_in">size</span>();i++) mp[poss[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs<span class="number">+1</span>,segs<span class="number">+1</span>+m);</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;i;ii++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">200</span>;j;j--) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">200</span>;k;k--)</span><br><span class="line">                    dp[i][j][k] = dp[ii][j][k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">200</span>;~j;j--) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">200</span>;~k;k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(mp[segs[i].x] &lt;= j<span class="number">+1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(mp[segs[i].x] &gt; k<span class="number">+1</span>) &#123;</span><br><span class="line">                            dp[i][<span class="built_in">max</span>(mp[segs[i].y], j)][k] =</span><br><span class="line">                                (dp[i][<span class="built_in">max</span>(mp[segs[i].y],j)][k] + dp[ii][j][k]) % MOD;</span><br><span class="line">                            <span class="comment">// if(dp[i][max(mp[segs[i].y], j)][k]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class="line">                            <span class="comment">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">                            <span class="comment">//     cout&lt;&lt;&quot;!&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][max(mp[segs[i].y], j)][k]&lt;&lt;nline;</span></span><br><span class="line">                            <span class="comment">// &#125;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[i][<span class="built_in">max</span>(mp[segs[i].y], j)][<span class="built_in">max</span>(k,<span class="built_in">min</span>(j,mp[segs[i].y]))] =</span><br><span class="line">                                (dp[i][<span class="built_in">max</span>(mp[segs[i].y], j)][<span class="built_in">max</span>(k,<span class="built_in">min</span>(j,mp[segs[i].y]))] + dp[ii][j][k]) % MOD;</span><br><span class="line">                            <span class="comment">// if(dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&amp;&amp;dp[ii][j][k]) &#123;</span></span><br><span class="line">                            <span class="comment">//     cout&lt;&lt;ii&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">                            <span class="comment">//     cout&lt;&lt;&quot;?&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;max(mp[segs[i].y], j)&lt;&lt;&#x27; &#x27;&lt;&lt;max(k,min(j,mp[segs[i].y]))&lt;&lt;&#x27; &#x27;&lt;&lt;</span></span><br><span class="line">                            <span class="comment">//         dp[i][max(mp[segs[i].y], j)][max(k,min(j,mp[segs[i].y]))]&lt;&lt;nline;</span></span><br><span class="line">                            <span class="comment">// &#125;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;dp[m][mp[n]][mp[n]]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中显然有一个很严重的问题：时间复杂度为<span
class="math display">\[1.6e^{9}\]</span>略微有点超出复杂度</p>
<p>其次，对于转移中直接用hax过的值判断是否能够转移是错误的，因为单单hax过后的左端点==右端点+1是不能证明两个区间可以合并的（如：1-3,5-6）hax过后为（1-2,3-4）显然，哈希后合并而实际并不合并。简单！我们只需要存储左端点减1即可。</p>
<p>时间如何优化？</p>
<p>首先注意到，（经典的错误）我们每次都需要从前面的每一个i进行转移，我们更改状态的表示，使得，最后的代表前面所有方案数，即在枚举j，k时f[i][j][k]
+= f[i -
1][j][k];于是时间复杂度完成。再根据官方题解的优化掉只转移覆盖一次的状态（显然二键值排序后导致这种情况必然不存在方案数）。于是复杂的暴力代码变成了下面的形状。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        cin&gt;&gt;segs[i].x&gt;&gt;segs[i].y;</span><br><span class="line">        segs[i].x--;</span><br><span class="line">        poss.<span class="built_in">push_back</span>(segs[i].x);</span><br><span class="line">        poss.<span class="built_in">push_back</span>(segs[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    poss.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    poss.<span class="built_in">push_back</span>(n);</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(poss));</span><br><span class="line">    poss.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(poss)),poss.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;poss.<span class="built_in">size</span>();i++) mp[poss[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs<span class="number">+1</span>,segs<span class="number">+1</span>+m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        segs[i].x = mp[segs[i].x];</span><br><span class="line">        segs[i].y = mp[segs[i].y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= mp[n]; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= mp[n]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[k - <span class="number">1</span>][i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                f[k][i][j] += f[k - <span class="number">1</span>][i][j];</span><br><span class="line">                f[k][i][j] %=MOD;</span><br><span class="line">                <span class="keyword">if</span> (segs[k].x &lt;= i) &#123;</span><br><span class="line">                    f[k][<span class="built_in">max</span>(i, <span class="built_in">min</span>(j, segs[k].y))][<span class="built_in">max</span>(j, segs[k].y)]+=f[k - <span class="number">1</span>][i][j];</span><br><span class="line">                    f[k][<span class="built_in">max</span>(i, <span class="built_in">min</span>(j, segs[k].y))][<span class="built_in">max</span>(j, segs[k].y)]%=MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[m][mp[n]][mp[n]]% MOD&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>状态转移</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>状态转移</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda简明介绍</title>
    <url>/2024/Anaconda%E7%AE%80%E6%98%8E%E4%BB%8B%E7%BB%8D/article.html</url>
    <content><![CDATA[<h1 id="anaconda简明介绍">Anaconda简明介绍</h1>
<p>已然是不知道从何处了解到的anaconda了，但它默认成为了我的python编译器指定选项，于是今天来了解一下Anaconda是什么，它是干什么的。</p>
<h2 id="包管理器">包管理器</h2>
<p>Anaconda（<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5hY29uZGEuY29tL2Rvd25sb2FkLyNtYWNvcw==">官方网站<i class="fa fa-external-link-alt"></i></span>）就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</p>
<span id="more"></span>
<h3 id="特点">特点</h3>
<ol type="1">
<li>anaconda是一款开源软件</li>
<li>其安装过程非常简单</li>
<li>其能够以很好的性能解释R语言与Python语言</li>
<li>其拥有丰富且免费的社区支持</li>
</ol>
<h3 id="内容">内容</h3>
<ol type="1">
<li>conda包</li>
<li>环境管理器</li>
<li>1000+开源库</li>
</ol>
<h3 id="与其他包管理器的区别">与其他包管理器的区别</h3>
<h4 id="conda">conda</h4>
<p>conda是包及其依赖项和环境的管理工具。</p>
<p>▪ 适用语言：Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++,
FORTRAN。</p>
<p>▪ 适用平台：Windows, macOS, Linux</p>
<p>▪ 用途：</p>
<p>① 快速安装、运行和升级包及其依赖项。</p>
<p>② 在计算机中便捷地创建、保存、加载和切换环境。</p>
<blockquote>
<p>如果你需要的包要求不同版本的Python，你无需切换到不同的环境，因为conda同样是一个<strong>环境管理器</strong>。仅需要几条命令，你可以创建一个完全独立的环境来运行不同的Python版本，同时继续在你常规的环境中使用你常用的Python版本。——<span class="exturl" data-url="aHR0cHM6Ly9jb25kYS5pby9kb2NzLw==">Conda官方网站<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>▪ conda为Python项目而创造，但可适用于上述的多种语言。</p>
<p>▪ conda包和环境管理器包含于Anaconda的所有版本当中。</p>
<h4 id="pip">pip</h4>
<p>pip是用于安装和管理软件包的包管理器。</p>
<p>▪ pip编写语言：Python。</p>
<p>▪ Python中默认安装的版本：</p>
<p>① Python 2.7.9及后续版本：默认安装，命令为 *<strong>pip*</strong></p>
<p>② Python 3.4及后续版本：默认安装，命令为 *<strong>pip3*</strong></p>
<p>▪
pip名称的由来：pip采用的是<strong>递归缩写</strong>进行命名的。其名字被普遍认为来源于2处：</p>
<p>① “Pip installs Packages”（“pip安装包”）</p>
<p>② “Pip installs Python”（“pip安装Python”）</p>
<h4 id="virtualenv"><strong>virtualenv</strong></h4>
<p>virtualenv是用于创建一个<strong>独立的</strong>Python环境的工具。</p>
<p>▪ 解决问题：</p>
<ol type="1">
<li>当一个程序需要使用Python 2.7版本，而另一个程序需要使用Python
3.6版本，如何同时使用这两个程序？如果将所有程序都安装在系统下的默认路径，如：*<strong>/usr/lib/python2.7/site-packages*</strong>，当不小心升级了本不该升级的程序时，将会对其他的程序造成影响。</li>
<li>如果想要安装程序并在程序运行时对其库或库的版本进行修改，都会导致程序的中断。</li>
<li>在共享主机时，无法在全局 *<strong>site-packages*</strong>
目录中安装包。</li>
</ol>
<p>▪
virtualenv将会为它自己的安装目录创建一个环境，这并<strong>不与</strong>其他virtualenv环境共享库；同时也可以<strong>选择性</strong>地不连接已安装的全局库。</p>
<h4 id="pip与conda的比较">pip与conda的比较</h4>
<p>▪ pip：</p>
<p>① <strong>不一定</strong>会展示所需其他依赖包。</p>
<p>②
安装包时<strong>或许</strong>会直接忽略依赖项而安装，仅在结果中提示错误。</p>
<p>▪ conda：</p>
<p>① 列出所需其他依赖包。</p>
<p>② 安装包时自动安装其依赖项。</p>
<p>③ 可以便捷地在包的不同版本中自由切换。</p>
<p><strong>→ 环境管理</strong></p>
<p>▪ pip：维护多个环境难度较大。</p>
<p>▪ conda：比较方便地在不同环境之间进行切换，环境管理较为简单。</p>
<p><strong>→ 对系统自带Python的影响</strong></p>
<p>▪ pip：在系统自带Python中包的更新/回退版本/卸载将影响其他程序。</p>
<p>▪ conda：不会影响系统自带Python。</p>
<p><strong>→ 适用语言</strong></p>
<p>▪ pip：仅适用于Python。</p>
<p>▪ conda：适用于Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++,
FORTRAN。</p>
<h4 id="conda与pipvirtualenv的关系">conda与pip、virtualenv的关系</h4>
<p>▪ conda<strong>结合</strong>了pip和virtualenv的功能。</p>
<h3 id="总结">总结</h3>
<p>它是一个开源的，多语言的，多平台的，依赖检查，版本独立且云端同步的包管理工具，用于保存切换不同的编译环境与第三方库。</p>
<h2 id="使用说明">使用说明</h2>
<ol type="1">
<li><p>通过通过anaconda中的python解释器中的pip安装的包同样也会被anaconda所管理</p></li>
<li><p>可视化界面：在win上可以打开anaconda-nagvitive可视化界面，查看当前环境与包</p></li>
<li><p>云同步，需要登录，在win可视化界面右上角可以连接到anaconda云端即可实现同步</p></li>
<li><p>canda channel的配置</p>
<p>默认canda channel是default，但这个代码包不全，建议使用conda-forge
channel，并严格设置优先使用conda-forge，因为这不同channel的包不完全兼容。</p>
<p>在安装这个这个渠道的时候无论使用什么样的方式都是可以的，比如图形化又或者命令行。</p>
<p>有关命令行的配置方法放在参考文献里了．</p></li>
<li><p>我应该使用pip安装还是使用conda安装第三方包</p>
<p>随意，在网络上两种建议都有，使用pip安装比较直接，而使用conda安装可以检查依赖，但据说这这个检查环境兼容性可能有问题，因此，我的建议是先尽量使用pip，出现依赖问题用conda
install</p></li>
<li><p>他是如何切换换第三方库的？应该如何调用不同的环境</p>
<p>这里有几种方式</p>
<ol type="1">
<li>使用它自己的命令行方式通过命令更换当前所用的环境</li>
<li>通过图形界面或者命令找到每个环境对应的python.exe或其他语言编译可执行程序，通过调用这个程序获取不同的第三方库。</li>
</ol></li>
</ol>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjkyNTUwMA==">Anaconda介绍、安装及使用教程
- 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDkwODEzNDQ=">Anaconda channel
配置笔记 - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
        <category>环境</category>
        <category>Anaconda</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN卷积神经网络</title>
    <url>/2024/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/article.html</url>
    <content><![CDATA[<h1 id="卷积神经网络CNN"><a href="#卷积神经网络CNN" class="headerlink" title="卷积神经网络CNN"></a>卷积神经网络CNN</h1><blockquote>
<p>卷积神经网络（Convolutional Neural Networks, CNN）的复杂性和灵活性使其成为深度学习领域的核心研究主题之一。</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>卷积神经网络的灵感源自<strong>人类视觉系统</strong>，特别是<strong>视觉皮层中的神经元结构</strong>。自Hubel和Wiesel在1962年的开创性工作以来，这一理念已经引发了一系列研究和发展。</p>
<span id="more"></span>
<p><strong>早期发展</strong>: 由Yann LeCun等人在上世纪80年代末到90年代初开发的LeNet-5被视为第一个成功的卷积神经网络。LeNet-5在手写数字识别方面取得了令人印象深刻的结果。</p>
<p><strong>现代崛起</strong>: 随着硬件的快速进展和<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9zb2x1dGlvbi9iaWdkYXRhP2Zyb21fY29sdW1uPTIwMDY1JmZyb209MjAwNjU=">大数据<i class="fa fa-external-link-alt"></i></span>的涌现，CNN在21世纪初开始重新崛起，并在各个领域实现了突破性进展。</p>
<p>CNN的重要性不仅体现在其精度和效率上，而且还体现在其理论洞见上。例如，卷积层通过共享权重减少了参数数量，这有助于更有效地训练模型，还增强了模型对平移不变性的理解。</p>
<h2 id="结构大观"><a href="#结构大观" class="headerlink" title="结构大观"></a>结构大观</h2><ol>
<li><p>卷积层</p>
<p>通过卷积操作检测图像的局部特征。</p>
</li>
<li><p>激活函数</p>
<p>引入非线性函数，增加模型的表达能力。</p>
</li>
<li><p>池化层</p>
<p>减少特征维度，增加模型的鲁棒性。</p>
</li>
<li><p>全连接层</p>
<p>在处理空间特征后，全连接层用于进行分类或回归。</p>
</li>
</ol>
<p>卷积神经网络的这些组件协同工作，使得CNN能够从原始像素中自动学习有意义的特征层次结构。随着深度增加，这些特征从基本形状和纹理逐渐抽象为复杂的对象和场景表现。<img src="https://s2.loli.net/2024/08/29/MKE4wicUudT8CZ1.png" alt="img"></p>
<h2 id="卷积神经网络层"><a href="#卷积神经网络层" class="headerlink" title="卷积神经网络层"></a>卷积神经网络层</h2><p>卷积神经网络由多个层组成，每个层具有特定的目的和功能。这一部分将探讨<strong>卷积操作、激活函数、池化层、归一化层</strong>基本概念。</p>
<h3 id="什么是卷积"><a href="#什么是卷积" class="headerlink" title="什么是卷积"></a>什么是卷积</h3><p><img src="https://s2.loli.net/2024/08/29/zXAZaWs4tF7PObV.png" alt="img"></p>
<p>卷积操作可以理解为一个线性压缩的过程，通过卷积运算（对应元素相乘后求和）使得一个高维举矩阵降维。</p>
<script type="math/tex; mode=display">
(I∗K)(i,j)=∑_m∑_nI(i−m,j−n)×K(m,n)\\
I是输入图像\\
K是卷积核\\
(i,j)是输出特征图的位置\\
(m,n)是卷积核中元素的位置\\
∗ 表示卷积操作。</script><h4 id="卷积操作的附加与变体"><a href="#卷积操作的附加与变体" class="headerlink" title="卷积操作的附加与变体"></a>卷积操作的附加与变体</h4><ol>
<li><strong>标准卷积</strong>：最基本的卷积操作，涉及将卷积核覆盖在输入图像的局部区域上，对应元素相乘后求和。</li>
<li><strong>步长（Stride）</strong>：步长定义了卷积核在输入图像上滑动的间隔。步长为1意味着卷积核每次移动一个像素；步长更大则可以减少输出特征图的空间尺寸。</li>
<li><strong>填充（Padding）</strong>：在输入图像的边缘添加额外的零（零填充）或通过其他方式扩展输入图像，以控制输出特征图的大小。这有助于保留输入图像的边缘信息。</li>
<li><strong>扩张卷积（Dilated Convolution）</strong>：在扩张卷积中，卷积核的元素之间插入了间隙，这使得卷积核可以覆盖更大的输入区域，同时仍然保持较小的参数数量。</li>
<li><strong>分组卷积（Grouped Convolution）</strong>：在深度可分离卷积（Depthwise Separable Convolution）中，输入通道被分成多个组，每组使用独立的卷积核。这种方法可以减少参数数量和计算量。</li>
<li><strong>转置卷积（Transposed Convolution）</strong>：也称为分数步长卷积（Fractionally-strided Convolution），用于上采样，即增加特征图的空间尺寸。它通过对卷积核应用反向步幅来实现。</li>
<li><strong>多尺度卷积（Multi-scale Convolution）</strong>：在某些网络结构中，输入图像的不同尺度版本被同时应用于卷积核，以捕获不同尺度的特征。</li>
<li><strong>空洞卷积（Atrous Convolution）</strong>：在空洞卷积中，卷积核的元素之间可以有更大的间隙，这允许网络以更低的计算成本捕获更广泛的上下文信息。</li>
<li><strong>卷积变体</strong>：除了标准卷积，还有许多变体，如1x1卷积，用于在深度方向上进行线性变换，以及分离卷积等。</li>
<li><strong>激活函数</strong>：在卷积操作之后，通常会应用一个非线性激活函数，如ReLU，以增加模型的非线性能力。</li>
</ol>
<h3 id="什么是卷积核，特征映射"><a href="#什么是卷积核，特征映射" class="headerlink" title="什么是卷积核，特征映射"></a>什么是卷积核，特征映射</h3><p>卷积核是一个小型的矩阵，通过在输入上滑动来生成特征映射。每个卷积核都能捕获不同的特征，例如边缘、角点等。</p>
<p><img src="https://developer.qcloudimg.com/http-save/yehe-9008468/025aa52f9c133ebcb4ed9481a54a1f22.png" alt="img"></p>
<p>输出特征图m与输入图片n维度关系是</p>
<script type="math/tex; mode=display">
m = n - k + 1\ (k为卷积核维度)</script><p>这是一个十分简化的公式，它假定输入图片与卷积核均为方阵。但对于非方阵来说，实际上相当于将n,m以对应行列数代换即可。此处仅适用于步长为1，步长不为1的情况需要考虑是否有填充零。</p>
<h4 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h4><p><strong>感受野（Receptive Field）</strong>是神经网络中一个重要的概念，特别是在卷积神经网络（CNN）中。它指的是<strong>网络中一个神经元能够“看到”或影响的输入数据的空间范围。</strong>换句话说，它是输入图像中一个给定的像素点到网络中某个特定神经元的映射区域，这个区域包含了该神经元进行特征检测所需的所有像素。</p>
<h4 id="卷积核的大小如何设置，有何关系"><a href="#卷积核的大小如何设置，有何关系" class="headerlink" title="卷积核的大小如何设置，有何关系"></a>卷积核的大小如何设置，有何关系</h4><p>卷积核的大小影响了它能捕获的特征的尺度。较小的卷积核可以捕获更细致的特征，而较大的卷积核可以捕获更广泛的特征。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用3x3的卷积核</span><br><span class="line">conv_layer_small = nn.<span class="title class_">Conv2</span>d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">3</span>)</span><br><span class="line"># 使用5x5的卷积核</span><br><span class="line">conv_layer_large = nn.<span class="title class_">Conv2</span>d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h4 id="多通道卷积"><a href="#多通道卷积" class="headerlink" title="多通道卷积"></a>多通道卷积</h4><p>在多通道输入下进行卷积，每个输入通道与一个卷积核进行卷积，然后所有的结果相加。这允许模型从不同的通道捕获不同的特征。</p>
<h4 id="步长与填充"><a href="#步长与填充" class="headerlink" title="步长与填充"></a>步长与填充</h4><p>设定不同的步长</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用步长为<span class="number">2</span></span><br><span class="line">cov_layer_stride2=nn.<span class="title class_">Conv2</span>d(<span class="number">3</span>,<span class="number">64</span>,<span class="number">3</span>,stride=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>填充通过在输入边缘添加零来控制输出的尺寸。这有助于控制信息在卷积操作中的丢失。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用填充<span class="number">1</span>，使得输出尺寸与输入尺寸相同（假设步长为<span class="number">1</span>）</span><br><span class="line">conv_layer_padding1 = nn.<span class="title class_">Conv2</span>d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">3</span>, padding=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="空洞卷积"><a href="#空洞卷积" class="headerlink" title="空洞卷积"></a>空洞卷积</h4><p>空洞卷积也称扩展卷积或带空间及,它通过在卷积核的元素之间插入空间采样点(通常是0)来扩大卷积核的感受野。</p>
<p>这种方法允许网络在保持相同参数量和计算量的情况下捕获更广泛的上下文信息，特别适用于需要大感受野的场景，如语义分割、目标检测等任务。</p>
<h3 id="分组卷积"><a href="#分组卷积" class="headerlink" title="分组卷积"></a>分组卷积</h3><p>分组卷积通过将输入通道分组并对每组使用不同的卷积核来扩展卷积操作。这增加了模型的容量，并使其能够学习更复杂的表示。</p>
<p>在分组卷积中，输入特征图（Feature Maps）和卷积核被分成多个组（groups），每组独立进行卷积运算。具体来说，如果输入特征图的尺寸是 $W×H×C_1$，并且我们设定要将其分为 $g$ 个组，那么每组的输入特征通道数为 $\frac{C_1}{g}$。相应地，每个卷积核也被分为 $g$组，每组卷积核的尺寸变为$k\times k \times \frac{C_1}{g}$，$C_2$表示输出通道的通道数，并且每组有 $\frac{C_2}{g}$个卷积核，最终每组生成 $\frac{C_2}{g}$个输出特征图 。</p>
<ol>
<li>在进行分组卷积后输出的特征图的通道数并没有改变</li>
<li>在进行分组卷积后,在同等的卷积核数量下,参数减少到了原来的$\frac{1}{g}$</li>
</ol>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p><img src="https://s2.loli.net/2024/08/29/8EvioflpSb3jL69.png" alt="img"></p>
<h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p><strong>池化层（Pooling Layer）</strong>在卷积神经网络中扮演了重要角色，通常用于降低特征映射的维度，从而减少计算需求，并增加特征检测器的感受野。</p>
<h4 id="最大池化"><a href="#最大池化" class="headerlink" title="最大池化"></a>最大池化</h4><p><img src="https://developer.qcloudimg.com/http-save/yehe-9008468/86ec7230226837f73b3864aff30aa71c.png" alt="img">最大池化是最常用的池化技术之一。它通过选择窗口中的最大值来降低特征映射的尺寸。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义2x2的最大池化层</span><br><span class="line">max_pooling = nn.<span class="title class_">MaxPool2</span>d(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>最大池化的主要优点是它能保留窗口中的最显著特征。然而，它会丢失一些细节信息。</p>
<h4 id="平均池化"><a href="#平均池化" class="headerlink" title="平均池化"></a>平均池化</h4><p>与最大池化不同，平均池化使用窗口中所有值的平均值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义2x2的平均池化层</span><br><span class="line">average_pooling = nn.<span class="title class_">AvgPool2</span>d(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>平均池化可以减轻最大池化可能导致的过于突出某些特征的问题，但可能会淡化一些重要特征。</p>
<h4 id="全局平均池化"><a href="#全局平均池化" class="headerlink" title="全局平均池化"></a>全局平均池化</h4><p>全局平均池化是一种更复杂的池化策略，它计算整个特征映射的平均值。这常用于网络的最后一层，直接用于分类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义全局平均池化层</span><br><span class="line">global_average_pooling = nn.<span class="title class_">AdaptiveAvgPool2</span>d(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="池化窗口大小和步长"><a href="#池化窗口大小和步长" class="headerlink" title="池化窗口大小和步长"></a>池化窗口大小和步长</h4><p>池化窗口的大小和步长会直接影响输出的尺寸。较大的窗口和步长会更显著地降低尺寸。</p>
<h4 id="池化的替代方案"><a href="#池化的替代方案" class="headerlink" title="池化的替代方案"></a>池化的替代方案</h4><p>池化层已经有了一些现代替代方案，例如使用卷积层的步长大于1，或使用空洞卷积。这些方法可能提供更好的特征保存。</p>
<h4 id="池化层的选择"><a href="#池化层的选择" class="headerlink" title="池化层的选择"></a>池化层的选择</h4><p>选择特定类型的池化层取决于任务需求和特定数据特性。深入理解各种池化技术如何工作，可以帮助深入理解它们是如何影响模型性能的。</p>
<h3 id="归一化层"><a href="#归一化层" class="headerlink" title="归一化层"></a>归一化层</h3><p><img src="https://s2.loli.net/2024/08/29/7Rz5wdh8H3f2isb.png" alt="img"></p>
<p>归一化层在训练深度神经网络时扮演了关键角色，主要用于改善训练的稳定性和速度。通过将输入数据缩放到合适的范围，归一化层有助于缓解训练过程中的<strong>梯度消失</strong>和<strong>梯度爆炸</strong>问题。</p>
<h4 id="批量归一化"><a href="#批量归一化" class="headerlink" title="批量归一化"></a>批量归一化</h4><p>通过对每个特征通道的输入进行归一化,将输入所梵高零均值和单位方差。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义批量归一化层</span><br><span class="line">batch_norm = nn.<span class="title class_">BatchNorm2</span>d(num_features=<span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<p><strong>优势与劣势</strong></p>
<ul>
<li><strong>优势</strong>：它允许更高的学习率，提供了一些正则化效果，通常导致更快的训练。</li>
<li><strong>劣势</strong>：在小批量上的统计估计可能会导致训练和推理间的不一致。</li>
</ul>
<h4 id="层归一化（LN）"><a href="#层归一化（LN）" class="headerlink" title="层归一化（LN）"></a>层归一化（LN）</h4><p>层归一化是在单个样本上对所有特征进行归一化的变体。它在句子处理和循环神经网络中特别流行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义层归一化</span><br><span class="line">layer_norm = nn.<span class="title class_">LayerNorm</span>(normalized_shape=<span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<p>LN的计算方法是对一个样本内所有神经元的输出进行归一化处理，使得这一层的输出具有稳定的均值和方差。具体来说，对于一个隐藏层中的所有激活值$a_i^l$，LN首先计算这些激活值的均值 μ和标准差 σ，然后利用以下公式进行归一化：</p>
<script type="math/tex; mode=display">
\mu = \frac{1}{H} \sum_{i=1}^{H} a_i</script><script type="math/tex; mode=display">
\sigma^2 = \frac{1}{H} \sum_{i=1}^{H} (a_i - \mu)^2</script><p>H表示该层的隐藏单元数。诡异话后通过可学习参数$\gamma\  \beta$进行缩放和平移，以适应数据分布</p>
<script type="math/tex; mode=display">
\text{output}_i = \gamma \hat{a}_i + \beta</script><h4 id="实例归一化"><a href="#实例归一化" class="headerlink" title="实例归一化"></a>实例归一化</h4><p>实例归一化主要用于样式转换任务，归一化是在每个样本的每个通道上独立进行的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义实例归一化</span><br><span class="line">instance_norm = nn.<span class="title class_">InstanceNorm2</span>d(num_features=<span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<h4 id="组归一化"><a href="#组归一化" class="headerlink" title="组归一化"></a>组归一化</h4><p>组归一化是批量归一化和层归一化之间的一种折衷方案，将通道分为不同的组，并在每个组内进行归一化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义组归一化</span><br><span class="line">group_norm = nn.<span class="title class_">GroupNorm</span>(num_groups=<span class="number">32</span>, num_channels=<span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<h4 id="归一化层的选择"><a href="#归一化层的选择" class="headerlink" title="归一化层的选择"></a>归一化层的选择</h4><p>归一化层的选择应基于特定的任务和模型架构。例如，在视觉任务中，批量归一化可能是首选，而在NLP任务中，层归一化可能更有用。</p>
<h2 id="训练与优化"><a href="#训练与优化" class="headerlink" title="训练与优化"></a>训练与优化</h2><h3 id="训练集的准备与增强"><a href="#训练集的准备与增强" class="headerlink" title="训练集的准备与增强"></a>训练集的准备与增强</h3><p>有效的训练数据是深度学习成功的基础。为了使卷积神经网络有效学习，训练集的选择和增强至关重要。</p>
<p><strong>数据预处理</strong></p>
<p>预处理是训练集准备的关键步骤，包括：</p>
<ul>
<li><strong>标准化</strong>：将输入缩放到0-1范围。</li>
<li><strong>中心化</strong>：减去均值，使数据以0为中心。</li>
<li><strong>数据清洗</strong>：消除不一致和错误的数据。</li>
</ul>
<p><strong>数据增强</strong></p>
<p>数据增强是一种通过应用随机变换增加数据量的技术，从而增加模型的泛化能力。</p>
<p><strong>常见增强技巧</strong></p>
<ul>
<li><strong>图像旋转、缩放和剪裁</strong></li>
<li><strong>颜色抖动</strong></li>
<li><strong>随机噪声添加</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用PyTorch进行多种图像增强</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.RandomRotation(<span class="number">10</span>),</span><br><span class="line">    transforms.RandomResizedCrop(<span class="number">224</span>),</span><br><span class="line">    transforms.ColorJitter(brightness=<span class="number">0.2</span>, contrast=<span class="number">0.2</span>, saturation=<span class="number">0.2</span>, hue=<span class="number">0.1</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p><strong>训练集分割</strong></p>
<p>通常将数据分为训练集、验证集和测试集，以确保模型不会过拟合。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数衡量模型预测与真实目标之间的差距。选择适当的损失函数是优化模型性能的关键步骤。</p>
<h4 id="均方误差-MSE"><a href="#均方误差-MSE" class="headerlink" title="均方误差(MSE)"></a>均方误差(MSE)</h4><p>衡量预测值与真实值之间的平方差</p>
<p>常用于连续值预测</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义<span class="variable constant_">MSE</span>损失</span><br><span class="line">mse_loss = nn.<span class="title class_">MSELoss</span>()</span><br></pre></td></tr></table></figure>
<h4 id="平滑L1损失"><a href="#平滑L1损失" class="headerlink" title="平滑L1损失"></a>平滑L1损失</h4><ul>
<li><strong>平滑L1损失</strong>：减少异常值的影响。</li>
</ul>
<h4 id="交叉熵损失"><a href="#交叉熵损失" class="headerlink" title="交叉熵损失"></a>交叉熵损失</h4><ul>
<li><strong>交叉熵损失</strong>：衡量预测概率分布与真实分布之间的差异。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义交叉熵损失</span><br><span class="line">cross_entropy_loss = nn.<span class="title class_">CrossEntropyLoss</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>二分交叉熵损失：特别用于二分类任务</li>
<li>多标签损失：用于多标签分类问题</li>
</ul>
<h4 id="优化损失函数"><a href="#优化损失函数" class="headerlink" title="优化损失函数"></a>优化损失函数</h4><p>选择适当的损失函数不仅取决于任务类型，还与模型架构、数据分布和特定的业务指标有关。有时，自定义损失函数可能是必要的，以便捕捉特定问题的核心挑战。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器用于更新神经网络的权重，以便最小化损失函数。每种优化器都有其特定的数学原理和应用场景。</p>
<h4 id="随机梯度下降-SGD"><a href="#随机梯度下降-SGD" class="headerlink" title="随机梯度下降(SGD)"></a>随机梯度下降(SGD)</h4><p>SGD是最基本的优化算法。</p>
<ul>
<li><strong>基本SGD</strong>: 按照负梯度方向更新权重。</li>
<li><strong>带动量的SGD</strong>: 引入动量项，积累之前的梯度，以便更平稳地收敛。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义带动量的<span class="variable constant_">SGD</span>优化器</span><br><span class="line">optimizer_sgd_momentum = torch.<span class="property">optim</span>.<span class="title function_">SGD</span>(model.<span class="title function_">parameters</span>(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>
<h4 id="自适应优化器"><a href="#自适应优化器" class="headerlink" title="自适应优化器"></a>自适应优化器</h4><p>自适应优化器能自动调整学习率。</p>
<ul>
<li><strong>Adam</strong>: 结合了Momentum和RMSProp的优点。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义<span class="title class_">Adam</span>优化器</span><br><span class="line">optimizer_adam = torch.<span class="property">optim</span>.<span class="title class_">Adam</span>(model.<span class="title function_">parameters</span>(), lr=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Adagrad、RMSprop等</strong>: 针对不同参数有不同的学习率。</li>
</ul>
<p><strong>优化器选择注意事项</strong></p>
<ul>
<li><strong>任务相关性</strong>: 不同优化器在不同任务和数据上可能有不同的效果。</li>
<li><strong>超参数调优</strong>: 如学习率、动量等可能需要调整。</li>
</ul>
<h3 id="学习率调整"><a href="#学习率调整" class="headerlink" title="学习率调整"></a>学习率调整</h3><p>学习率是优化器中的关键超参数，其调整对模型训练有深远影响。</p>
<h4 id="固定学习率"><a href="#固定学习率" class="headerlink" title="固定学习率"></a><strong>固定学习率</strong></h4><p>最简单的方法是使用固定学习率。但可能不够灵活。</p>
<h4 id="学习率调度"><a href="#学习率调度" class="headerlink" title="学习率调度"></a><strong>学习率调度</strong></h4><p>更复杂的方法是在训练过程中动态调整学习率。</p>
<h5 id="预定调整"><a href="#预定调整" class="headerlink" title="预定调整"></a><strong>预定调整</strong></h5><ul>
<li><strong>步骤下降</strong>: 在固定步骤处降低学习率。</li>
<li><strong>余弦退火</strong>: 周期性调整学习率。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>定义余弦退火调度器</span><br><span class="line">scheduler = torch.<span class="property">optim</span>.<span class="property">lr_scheduler</span>.<span class="title class_">CosineAnnealingLR</span>(optimizer_adam, T_max=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<h3 id="正则化技巧"><a href="#正则化技巧" class="headerlink" title="正则化技巧"></a>正则化技巧</h3><p>正则化是防止过拟合和提高模型泛化能力的关键技术。</p>
<p><strong>L1和L2正则化</strong></p>
<ul>
<li><strong>L1正则化</strong>：倾向于产生稀疏权重，有助于特征选择。</li>
<li><strong>L2正则化</strong>：减小权重，使模型更平滑。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 使用<span class="title class_">PyTorch</span>添加<span class="variable constant_">L1</span>和<span class="variable constant_">L2</span>正则化</span><br><span class="line">l1_lambda = <span class="number">0.0005</span></span><br><span class="line">l2_lambda = <span class="number">0.0001</span></span><br><span class="line">loss = loss + l1_lambda * torch.<span class="title function_">norm</span>(weights, <span class="number">1</span>) + l2_lambda * torch.<span class="title function_">norm</span>(weights, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Dropout</strong></p>
<p>随机关闭一部分神经元，使模型更鲁棒。</p>
<ul>
<li><strong>普通Dropout</strong>：随机丢弃神经元。</li>
<li><strong>Spatial Dropout</strong>：在卷积层中随机丢弃整个特征图。</li>
</ul>
<p><strong>Batch Normalization</strong></p>
<p>通过标准化层输入，加速训练并减轻初始化的敏感性。</p>
<p><strong>数据增强</strong></p>
<p>如前所述，数据增强是一种重要的正则化手段。</p>
<h3 id="模型评估和调优"><a href="#模型评估和调优" class="headerlink" title="模型评估和调优"></a>模型评估和调优</h3><p>模型评估是衡量模型性能的过程，调优则是改进性能。</p>
<p><strong>交叉验证</strong></p>
<p>使用交叉验证来估计模型的泛化能力。</p>
<ul>
<li><strong>k-折交叉验证</strong>：将数据分为k个部分，轮流使用其中一个作为验证集。</li>
</ul>
<p><strong>调参技巧</strong></p>
<ul>
<li><strong>网格搜索</strong>：尝试不同超参数组合。</li>
<li><strong>随机搜索</strong>：随机选择超参数，更高效。</li>
</ul>
<p><strong>早停技巧</strong></p>
<p>如果验证损失不再下降，则停止训练，以防止过拟合。</p>
<p><strong>模型集成</strong></p>
<p>通过结合多个模型来提高性能。</p>
<ul>
<li><strong>Bagging</strong>：训练多个模型并平均预测。</li>
<li><strong>Boosting</strong>：在先前模型的错误上训练新模型。</li>
<li><strong>Stacking</strong>：使用新模型组合其他模型的预测。</li>
</ul>
<h2 id="实践与CNN模型编写"><a href="#实践与CNN模型编写" class="headerlink" title="实践与CNN模型编写"></a>实践与CNN模型编写</h2><p>下面使用CNN编写一个简单的句子分类器</p>
<h3 id="字词为何要数据化，怎样数据化的？"><a href="#字词为何要数据化，怎样数据化的？" class="headerlink" title="字词为何要数据化，怎样数据化的？"></a>字词为何要数据化，怎样数据化的？</h3><p>字词需要数据化，因为计算机和机器学习模型只能处理数值型数据。数据化（也称为特征提取或向量化）是将原始文本转换为模型可以理解和处理的数值形式的过程。以下是将字词数据化的常见步骤：</p>
<ol>
<li><p><strong>分词（Tokenization）</strong></p>
<p>将句子分解成单独的单词或标记（tokens），这些单词或标记是数据化的基本单位。</p>
</li>
<li><p><strong>构建词汇表（Vocabulary）</strong></p>
<p>从训练数据中提取所有唯一的单词，并为每个单词分配一个唯一的索引或ID。</p>
</li>
<li><p><strong>词嵌入（Word Embedding）</strong></p>
<p>使用预训练的词向量模型（如word2vec、GloVe或BERT）将每个单词转换为固定大小的向量。这些向量捕捉了单词的语义和语法特征。</p>
</li>
<li><p><strong>索引化（Indexing）</strong></p>
<p>由于句子长度可能不同，通常需要将句子填充到相同的长度，以便能够批量处理。这通常涉及到在句子末尾添加特殊的“填充”标记。</p>
</li>
<li><p><strong>序列化（Sequencing）</strong></p>
<p>将填充后的句子转换为数值序列，每个位置对应一个单词的数值索引或词嵌入向量。</p>
</li>
<li><p><strong>特殊标记（Special Tokens）</strong></p>
<p>在某些模型中，可能会使用特殊的开始（如<code>&lt;BOS&gt;</code>）和结束（如<code>&lt;EOS&gt;</code>）标记来标记句子的开始和结束。</p>
</li>
<li><p><strong>转换为张量（Tensorization）</strong></p>
<p>将数值序列转换为可以被深度学习框架处理的张量（多维数组）</p>
</li>
<li><p><strong>上下文化（Contextualization）</strong></p>
<p>在某些模型中，如Transformer或BERT，单词的表示不是静态的，而是根据它们在句子中的上下文动态生成的。</p>
</li>
<li><p><strong>归一化（Normalization）</strong></p>
<p>有时，为了提高模型性能，会将词嵌入向量进行归一化处理，使它们具有单位长度。</p>
</li>
</ol>
<h3 id="需要准备的第三方包"><a href="#需要准备的第三方包" class="headerlink" title="需要准备的第三方包"></a>需要准备的第三方包</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>旧版依赖安装已废弃，请阅读CNN补充-pyTorch中有关异常处理的安装问题中的版本控制处理。</p>
<blockquote>
<ol>
<li>Numpy：适用于多维数组方面的数学运算</li>
<li>pyTorch：深度学习框架库，提供了构建和训练神经网络所需的工具与函数</li>
</ol>
<p>使用pip安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install numpy # 安装numpy</span><br><span class="line">pip install torch # 安装pyTorch</span><br></pre></td></tr></table></figure>
<p>验证是否安装成功</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="built_in">print</span>(numpy.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(numpy.__version__)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.26</span><span class="number">.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2.4</span><span class="number">.0</span>+cpu</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="下载所需数据集"><a href="#下载所需数据集" class="headerlink" title="下载所需数据集"></a>下载所需数据集</h4><p>分别是情感分析数据集（MR, SST-1, SST-2）或问题分类数据集（TREC）。</p>
<p>以下内容与GithubCNN-NLP学习系列内容重复，等待整理或异步GithubCNN-NLP学习</p>
<h4 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h4><h5 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h5><h5 id="神经网络层"><a href="#神经网络层" class="headerlink" title="神经网络层"></a>神经网络层</h5><p>……</p>
<h4 id="训练与预测函数"><a href="#训练与预测函数" class="headerlink" title="训练与预测函数"></a>训练与预测函数</h4><h5 id="训练函数"><a href="#训练函数" class="headerlink" title="训练函数"></a>训练函数</h5><h5 id="验证函数"><a href="#验证函数" class="headerlink" title="验证函数"></a>验证函数</h5><h5 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h5><ol>
<li>一般在同文件中写入所有模型所需函数，例如预测函数（单测试数据输出）、参数保存函数</li>
</ol>
<p>……</p>
<h4 id="日志记录与参数保存"><a href="#日志记录与参数保存" class="headerlink" title="日志记录与参数保存"></a>日志记录与参数保存</h4><p>…….</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8yMzQ4NDgx">头疼！卷积神经网络是什么？CNN结构、训练与优化一文全解-腾讯云开发者社区-腾讯云 (tencent.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="Classic\Convolutional Neural Networks for Sentence Classification.pdf">Convolutional Neural Networks for Sentence Classification.pdf</a> </li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>机器学习</category>
        <category>基础模型</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch实战-CV-classification</title>
    <url>/2024/PyTorch%E5%AE%9E%E6%88%98-CV-classification/article.html</url>
    <content><![CDATA[<h1 id="pyTorch"><a href="#pyTorch" class="headerlink" title="pyTorch"></a>pyTorch</h1><p>实战中领悟torch的函数含义，须有基础神经网络结构概念，并有一定线性代数基础</p>
<h2 id="对图像识别的神经网络模型构建"><a href="#对图像识别的神经网络模型构建" class="headerlink" title="对图像识别的神经网络模型构建"></a>对图像识别的神经网络模型构建</h2><p>目标：实现一个可分类不同衣物图像的神经网络</p>
<h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><span id="more"></span>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>shape、dtype、device，分别表示维度，数据类型与存储在什么设备上</p>
<h3 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h3><p><code>torch.tensor</code>将数组转化为张量</p>
<p><code>torch.from_numpy</code>从numpy转化为张量</p>
<p><code>.numpy</code> 转换为numpy</p>
<p><code>torch.ones_like</code>从一个张量复制到另一个张量</p>
<p><code>torch.rand</code>随机填充（由元组或数组决定维度）填充小于1的小数，扩展<code>torch.ones</code>，<code>torch.zeros</code>填充1，0</p>
<p><code>tensor.to</code> 将张量转存，常用参数如，‘cpu’,’cuda’</p>
<p><code>tensor[ ],tensor[:, ] tensor[…, ]</code>行列下标索引</p>
<p><code>tersor.T</code>即对tensor的转置</p>
<p><code>torch.cat()</code>即对tensor的相连，即将列表或元组中的的tensor整合为一个tensor</p>
<p>加减乘除</p>
<ul>
<li><code>*</code>指的是对每个对应位置元素分别相乘 <code>.mul</code></li>
<li><code>@</code> 指的是矩阵乘法<code>.matmul</code> </li>
</ul>
<h2 id="数据集-Dataset"><a href="#数据集-Dataset" class="headerlink" title="数据集 Dataset"></a>数据集 Dataset</h2><h3 id="引入数据集"><a href="#引入数据集" class="headerlink" title="引入数据集"></a>引入数据集</h3><p>通过<code>torchvision</code>加载对应数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor, Lambda</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">training_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">test_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">False</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们可以见到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">False</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个语法，解析一下，其中<code>root</code>参数是指定数据根目录，<code>train</code>表示当前这个数据集是否是训练集，<code>download</code>则表示该训练集是否不可用时在网上下载，<code>transform</code>则是指定转换数据为何种数据结构<code>target_transform</code>。</p>
<p>这就是使用torchvision中datasets包引用数据集的基本方法。</p>
<p>此处的trainning_data以及test_data均为datasets.FashionMNIST类型。</p>
<h3 id="通过可视化直观感受数据集"><a href="#通过可视化直观感受数据集" class="headerlink" title="通过可视化直观感受数据集"></a>通过可视化直观感受数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">labels_map = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;T-Shirt&quot;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&quot;Trouser&quot;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&quot;Pullover&quot;</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">&quot;Dress&quot;</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">&quot;Coat&quot;</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">&quot;Sandal&quot;</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">&quot;Shirt&quot;</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">&quot;Sneaker&quot;</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">&quot;Bag&quot;</span>,</span><br><span class="line">    <span class="number">9</span>: <span class="string">&quot;Ankle Boot&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">figure = plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">cols, rows = <span class="number">3</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols * rows + <span class="number">1</span>):</span><br><span class="line">    sample_idx = torch.randint(<span class="built_in">len</span>(training_data), size=(<span class="number">1</span>,)).item()</span><br><span class="line">    img, label = training_data[sample_idx]</span><br><span class="line">    figure.add_subplot(rows, cols, i)</span><br><span class="line">    plt.title(labels_map[label])</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(img.squeeze(), cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>通过调用<code>print(training_data[sample_idx])</code>可以发现每一个训练数据都是由多维维元组构成的，前面一部分浮点数list描述了每一行每一列单通道的像素明暗度，表示了一幅图案，后一个整型数字这就是ce测试数据的label</p>
<h3 id="规范化数据"><a href="#规范化数据" class="headerlink" title="规范化数据"></a>规范化数据</h3><p>通过Dataloader导入数据，其中batch_size表示了每一次批次中的数量，shuffle表示随机下标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">train_dataloader = DataLoader(training_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>通过Dataloader索引图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Display image and label.</span></span><br><span class="line">train_features, train_labels = <span class="built_in">next</span>(<span class="built_in">iter</span>(train_dataloader))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Feature batch shape: <span class="subst">&#123;train_features.size()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Labels batch shape: <span class="subst">&#123;train_labels.size()&#125;</span>&quot;</span>)</span><br><span class="line">img = train_features[<span class="number">0</span>].squeeze()</span><br><span class="line">label = train_labels[<span class="number">0</span>]</span><br><span class="line">plt.imshow(img, cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">label_name = <span class="built_in">list</span>(labels_map.values())[label]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Label: <span class="subst">&#123;label_name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="对数据进行变形"><a href="#对数据进行变形" class="headerlink" title="对数据进行变形"></a>对数据进行变形</h3><p>并非所有数据都适合机器学习的final input，因此，需要对一些数据进行变形。</p>
<p>在此之前，我们需要了解datasets中的数据特征</p>
<ol>
<li>他们都是有两部分组成的features与labels的元组</li>
<li>前一部分描述数据，后一部分描述标签（这里暂时只考虑图像，即单通道或多通道的明暗list与一个表示类别的整型数字）</li>
</ol>
<p>可以使用<code>transform</code>来进行数据的整理，<code>target_transform</code>进行标签的整理。</p>
<p>下面是一个使用Lambda匿名函数的示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor, Lambda</span><br><span class="line"></span><br><span class="line">ds = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor(),</span><br><span class="line">    target_transform=Lambda(<span class="keyword">lambda</span> y: torch.zeros(<span class="number">10</span>, dtype=torch.<span class="built_in">float</span>).scatter_(<span class="number">0</span>, torch.tensor(y), value=<span class="number">1</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>其中有个常见的函数，这里提一下，详细可以看源码里的注释</p>
<p><code>scatter_(dim,index,value)</code>就是将对应index坐标中的值更改为value，dim则是指定的维度</p>
<p>具体到这个实例中就是弄成，比如T-shirt的标签是</p>
<p><code>tensor[1,0,0,0,0,0,0,0,0,0]</code></p>
<ol>
<li><h2 id="模型生成"><a href="#模型生成" class="headerlink" title="模型生成"></a>模型生成</h2></li>
</ol>
<h3 id="模型相关调试"><a href="#模型相关调试" class="headerlink" title="模型相关调试"></a>模型相关调试</h3><p>神经网络的工作原理我就不在这里再重复了，在我的MindSpore概念章中已经提到了有关知识。</p>
<p>但我仍要针对torch的部分说一下</p>
<p>首先是引入部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br></pre></td></tr></table></figure>
<p>这里引用了nn，transform这两个比较难以理解的东西，后面用到了再提</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Using &#123;&#125; device&#x27;</span>.<span class="built_in">format</span>(device))</span><br></pre></td></tr></table></figure>
<p>这里并<strong>没有设定实际的运行设备</strong>而是输出信息！</p>
<h3 id="模型引入"><a href="#模型引入" class="headerlink" title="模型引入"></a>模型引入</h3><p>直到这里，可以开始写第一个pyTorch框架下的模型了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NeuralNetwork, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.flatten = nn.Flatten()</span><br><span class="line">        <span class="variable language_">self</span>.linear_relu_stack = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">28</span>*<span class="number">28</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">10</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.flatten(x)</span><br><span class="line">        logits = <span class="variable language_">self</span>.linear_relu_stack(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br></pre></td></tr></table></figure>
<p>吸引眼球的函数<code>nn.Flatten</code>,来看一下这个函数是如何描述的，首先，Flatten这个单词表示扁平化，可以联想到我们在运算过程中的降维</p>
<p>Shape:</p>
<pre><code>    - Input: :$$(*, S_&#123;\text&#123;start&#125;&#125;,..., S_&#123;i&#125;, ..., S_&#123;\text&#123;end&#125;&#125;, *)$$
      where :$S_&#123;i&#125;$ is the size at dimension :math:`i` and :math:`*` means any
      number of dimensions including none.
            - Output: :math:$(*, \prod_&#123;i=\text&#123;start&#125;&#125;^&#123;\text&#123;end&#125;&#125; S_&#123;i&#125;, *)$.
</code></pre><p>注意这里的连乘指的是大小连乘而并非是数值连乘，也就是说如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Examples::</span><br><span class="line">        &gt;&gt;&gt; <span class="built_in">input</span> = torch.randn(<span class="number">32</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">        &gt;&gt;&gt; <span class="comment"># With default parameters</span></span><br><span class="line">        &gt;&gt;&gt; m = nn.Flatten()</span><br><span class="line">        &gt;&gt;&gt; output = m(<span class="built_in">input</span>)</span><br><span class="line">        &gt;&gt;&gt; output.size()</span><br><span class="line">        torch.Size([<span class="number">32</span>, <span class="number">25</span>])</span><br><span class="line">        &gt;&gt;&gt; <span class="comment"># With non-default parameters</span></span><br><span class="line">        &gt;&gt;&gt; m = nn.Flatten(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        &gt;&gt;&gt; output = m(<span class="built_in">input</span>)</span><br><span class="line">        &gt;&gt;&gt; output.size()</span><br><span class="line">        torch.Size([<span class="number">160</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p>然后了解一下nn.Linear函数，这个函数的<em>_init\</em>_是这样描述的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">             in_features: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">             out_features: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">             bias: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">             device: <span class="type">Any</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">             dtype: <span class="type">Any</span> = <span class="literal">None</span></span>) -&gt; <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>他有五个参数，输入feature，输出feature，bias（偏差），设备，数据类型</p>
<p>可见，这里使用nn.Module定义了一个神经网络，由于我们的数据是28*28的图像，这里我们设置：</p>
<p>第一个in_features28*28的,out_feature则是512的</p>
<p>而后是一个512到512的中间层（hidden layer），然后是一个512到10的输出层。</p>
<p>每层都采用ReLU作为激活函数</p>
<p>然后我们注意力放到<code>forword</code>前向传播函数中，在这里我们设定了这个模型的Flatten函数以及数据如何通过神经网络层</p>
<h3 id="实例化模型并使用"><a href="#实例化模型并使用" class="headerlink" title="实例化模型并使用"></a>实例化模型并使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = NeuralNetwork().to(device)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<p>我们指定一下示例到哪里运行</p>
<p>这里device可以有很多取值，但在我们的示例中，仅仅只有‘cpu’,’gpu’两种取值</p>
<p>接下来就是使用这一个模型</p>
<p>首先，我们通过torch.rand随机出一个参数X（1，28，28）</p>
<p>在这之后，我们需要注意，不能直接使用model.forward()函数，而是需要以X为输入并返回一个十维的行预测值</p>
<p>然后我们来了解一个函数,<code>nn.Softmax</code></p>
<p>Softmax is defined as:</p>
<script type="math/tex; mode=display">
\text{Softmax}(x_{i}) = \frac{\exp(x_i)}{\sum_j \exp(x_j)}</script><p>它对指定维度的数字完成归一化的操作，使得他们的和为1而一定程度上保留其数字特征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.rand(<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, device=device)</span><br><span class="line">logits = model(X) </span><br><span class="line">pred_probab = nn.Softmax(dim=<span class="number">1</span>)(logits)</span><br><span class="line">y_pred = pred_probab.argmax(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Predicted class: <span class="subst">&#123;y_pred&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>通过这段代码，我们实际上使模型第一次<em>流过了</em>数据，但这显然不是神经网络，他没有学到任何东西，于是，我们需要聚焦权值和偏移量。</p>
<h4 id="Weights-and-Bias"><a href="#Weights-and-Bias" class="headerlink" title="Weights and Bias"></a>Weights and Bias</h4><p>首先，让我们观察一下第一层的两个变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;First Linear weights: <span class="subst">&#123;model.linear_relu_stack[<span class="number">0</span>].weight&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;First Linear biases: <span class="subst">&#123;model.linear_relu_stack[<span class="number">0</span>].bias&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>看到这些数据，心里的石头终于安心的似了。它也是存在的！</p>
<blockquote>
<p>这里再说一下Flatten：</p>
<p>虽然前面解释了这个函数，但很容易注意到，为什么start_dim这个默认值是1呢？这是因为我们输入图像数据的时候，第一维装进去的是一个批次很多个图像数据。</p>
<p>是直接第一行放到第一个，第二行放到第二个吗？实践一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor1 = torch.tensor([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(tensor1.size())</span><br><span class="line">tensor2 = nn.Flatten()(tensor1)</span><br><span class="line"><span class="built_in">print</span>(tensor2)</span><br><span class="line"></span><br><span class="line">tensor1 = torch.tensor([[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]],[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]])</span><br><span class="line">tensor2 = nn.Flatten()(tensor1)</span><br><span class="line"><span class="built_in">print</span>(tensor2)</span><br></pre></td></tr></table></figure>
<p>确实，他就是将不同行按序合并到了同一行，如果指定维度只有1维则不变</p>
</blockquote>
<h4 id="nn-Sequential"><a href="#nn-Sequential" class="headerlink" title="nn.Sequential"></a>nn.Sequential</h4><p>nn.Sequential 是模块的有序容器。数据按照定义的顺序传递到所有模块。您可以使用顺序容器来快速组合出类似 seq_modules 的网络。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq_modules = nn.Sequential(</span><br><span class="line">    flatten,</span><br><span class="line">    layer1,</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(<span class="number">20</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line">input_image = torch.rand(<span class="number">3</span>,<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">logits = seq_modules(input_image)</span><br></pre></td></tr></table></figure>
<h4 id="模型参数查看"><a href="#模型参数查看" class="headerlink" title="模型参数查看"></a>模型参数查看</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Model structure: &quot;</span>, model, <span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Layer: <span class="subst">&#123;name&#125;</span> | Size: <span class="subst">&#123;param.size()&#125;</span> | Values : <span class="subst">&#123;param[:<span class="number">2</span>]&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="自动梯度下降"><a href="#自动梯度下降" class="headerlink" title="自动梯度下降"></a>自动梯度下降</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># torch.autograd 自动梯度下降</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.ones(<span class="number">5</span>)  <span class="comment"># input tensor</span></span><br><span class="line">y = torch.zeros(<span class="number">3</span>)  <span class="comment"># expected output</span></span><br><span class="line">w = torch.randn(<span class="number">5</span>, <span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.randn(<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">z = torch.matmul(x, w)+b</span><br><span class="line">loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)</span><br></pre></td></tr></table></figure>
<p>以上是一个简单的梯度下降示例，其中使用损失函数是二元交叉熵损失函数。</p>
<p><code>randn</code>是一个产生正态分布的随机数的函数</p>
<h4 id="计算图-梯度下降函数"><a href="#计算图-梯度下降函数" class="headerlink" title="计算图,梯度下降函数"></a>计算图,梯度下降函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Gradient function for z =&#x27;</span>,z.grad_fn)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Gradient function for loss =&#x27;</span>, loss.grad_fn)</span><br></pre></td></tr></table></figure>
<p>这里就比较难以理解了,似乎z是一个数组而已，怎么根据它求导函数呢，事实上，我们要明白并牢记这里的z并非是一个数组，而是一个张量，并且它由w,b两个设定了requires_grad=True的张量计算而来，因此，这里的z就是关于w,b的因变量，也是根据他们两个求导</p>
<p>更要清楚，我们应用于张量以构建计算图的函数是 Function 类的对象。此对象知道如何在正向计算函数，以及如何在反向传播步骤中计算其导数。对反向传播函数的引用存储在张量的 grad_fn 属性中。</p>
<h4 id="计算导数"><a href="#计算导数" class="headerlink" title="计算导数"></a>计算导数</h4><p>我们在特定的<code>x</code> 和  <code>y</code>下计算 $\frac{\partial loss}{\partial w}$ and$\frac{\partial loss}{\partial b}$  。</p>
<p>可以通过调用<code>loss.backward()</code>, 然后获取 <code>w.grad</code> 和 <code>b.grad</code>参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss.backward()</span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br><span class="line"><span class="built_in">print</span>(b.grad)</span><br></pre></td></tr></table></figure>
<p>这里就有点令人不解了，为什么在获得有关两个自变量的导数时需要先使用一下loss.backward()呢</p>
<blockquote>
<p><code>loss.backward()</code> 是一个非常重要的函数，它用于自动计算梯度。</p>
<p>它实际上是由如下几个步骤组成的</p>
<ol>
<li><strong>计算梯度</strong>：<code>loss.backward()</code> 会计算损失函数关于网络参数（如权重和偏置）的梯度。这是通过反向传播算法完成的，该算法从输出层开始，逐层向后计算梯度。</li>
<li><strong>累积梯度</strong>：在PyTorch中，梯度是累积的，这意味着如果你多次调用 <code>loss.backward()</code> 而不更新参数，梯度会累加。这在某些情况下是有用的，比如在RMSprop或Adam这样的优化器中，它们需要计算梯度的一阶和二阶矩。</li>
<li><strong>准备参数更新</strong>：计算完梯度后，这些梯度会被用于参数的更新。通常，你会在调用 <code>loss.backward()</code> 之后，使用优化器（如 <code>optimizer.step()</code>）来更新参数。</li>
<li><strong>清除旧梯度</strong>：在每次迭代开始之前，通常需要清除旧的梯度，以避免梯度累积。这可以通过调用 <code>optimizer.zero_grad()</code> 或 <code>model.zero_grad()</code> 来实现。</li>
</ol>
<p><strong>backward中的形参</strong></p>
<ol>
<li><p><strong>gradient（可选）</strong>：这是一个用来指示目标张量相对于该张量的梯度的张量。如果指定了 <code>gradient</code>，它的形状必须与目标张量相同。如果不指定，PyTorch 会默认使用 1 作为梯度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.tensor([<span class="number">1.0</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = (x + <span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们想要将梯度缩放为 2</span></span><br><span class="line">loss = y</span><br><span class="line">loss.backward(gradient=torch.tensor([<span class="number">2.0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.grad)  <span class="comment"># 输出: tensor([4.])</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>y = (x + 1)^2</code> 的导数是 <code>2 * (x + 1)</code>。如果我们不指定 <code>gradient</code> 参数，<code>x.grad</code> 将会是 <code>[4.]</code>（因为 <code>2 * (1 + 1)</code>）。但是，我们通过指定 <code>gradient=torch.tensor([2.0])</code>，实际上是将损失函数对 <code>x</code> 的影响放大了 2 倍，所以最终的梯度是 <code>[8.]</code> 而不是 <code>[4.]</code>。</p>
</li>
<li><p><strong>retain_graph（可选）</strong>：这是一个布尔值，用于指定是否保留计算图。默认情况下，<code>retain_graph=False</code>，这意味着计算图会在 <code>backward()</code> 调用后被释放，以节省内存。如果你需要再次对同一个图进行反向传播（例如，在同一个网络中进行多次反向传播），你可以设置 <code>retain_graph=True</code>。</p>
</li>
<li><p><strong>retain_variables（可选）</strong>：这是一个布尔值，用于指定是否保留用于计算梯度的变量。默认情况下，<code>retain_variables=False</code>。如果你需要在 <code>backward()</code> 调用后再次使用这些变量，可以设置 <code>retain_variables=True</code>。</p>
</li>
</ol>
</blockquote>
<h4 id="避免梯度计算"><a href="#避免梯度计算" class="headerlink" title="避免梯度计算"></a>避免梯度计算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    z = torch.matmul(x, w) + b</span><br></pre></td></tr></table></figure>
<p>通过这样的代码就能<strong>阻断</strong>梯度计算了。</p>
<p>这种代码对java选手简直就是天书，即使c++选手也会两眼一黑，这里不得不提到python的特性之一，上下文管理。参考 <a href="python补充.md">python补充.md</a> </p>
<p>值得注意的是：梯度计算是一个<strong>链式过程</strong>，即他是在有向无环图DAGs上进行的反向传播。</p>
<p><strong>什么情况下会用到阻断梯度计算</strong></p>
<ol>
<li>希望冻结参数运行神经网络模型</li>
<li>希望加速神经网络模型并只进行前向计算</li>
</ol>
<h4 id="雅各比行列式"><a href="#雅各比行列式" class="headerlink" title="雅各比行列式"></a>雅各比行列式</h4><p>在多元函数的求导中存在着这么一种求导法则，即雅各比行列式。</p>
<p>对函数$\vec{y}=f(\vec{x})$，当$\vec{x}=\langle x<em>1,\dots,x_n\rangle$，$\vec{y}=\langle y_1,\dots,y_m\rangle$， $\vec{y}$ 对$\vec{x}$的导数是一个包含$\frac{\partial y</em>{i}}{\partial x<em>{j}}$雅阁比行列式 $J</em>{ij}$ 。</p>
<p>Pytorch允许以计算 $v^T\cdot J$替代$v=(v_1 \dots v_m)$。这是通过以v作为backward的参数实现的v的大小应该与原始张量的大小相同，要根据原始张量计算乘积。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inp = torch.eye(<span class="number">5</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">out = (inp+<span class="number">1</span>).<span class="built_in">pow</span>(<span class="number">2</span>)</span><br><span class="line">out.backward(torch.ones_like(inp), retain_graph=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;First call\n&quot;</span>, inp.grad)</span><br><span class="line">out.backward(torch.ones_like(inp), retain_graph=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nSecond call\n&quot;</span>, inp.grad)</span><br><span class="line">inp.grad.zero_()</span><br><span class="line">out.backward(torch.ones_like(inp), retain_graph=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nCall after zeroing gradients\n&quot;</span>, inp.grad)</span><br></pre></td></tr></table></figure>
<p><code>torch.eye</code>返回一个指定维的单位矩阵</p>
<p><code>retain_graph</code>形参表示累加梯度计算值，若没有此项，重复backward将会报错</p>
<p><code>inp.grad.zero_</code>原地函数，设置梯度值为零</p>
<p>值得注意的是gradient形参，该参数是高级用法之一，他最直观的作用就是将求出来的导数乘以一个矩阵(对应位置的乘法)</p>
<blockquote>
<ol>
<li><strong>自定义梯度</strong>：在某些高级用例中，你可能需要为特定的操作或自定的损失函数指定非标准的梯度。例如，在使用强化学习或者某些特殊的优化算法时，你可能需要根据自定义的规则来计算梯度。</li>
<li><strong>梯度裁剪</strong>：在训练神经网络时，可能会出现梯度爆炸的问题。在这种情况下，你可能需要在执行反向传播之前对梯度进行裁剪，以防止梯度值过大。通过 <code>gradient</code> 参数，你可以在计算梯度时直接应用梯度裁剪，而不是在梯度计算完成后再进行。</li>
<li><strong>多任务学习</strong>：在多任务学习中，不同的任务可能需要对同一个网络层的输出有不同的梯度贡献。通过为不同的任务指定不同的 <code>gradient</code> 参数，你可以精确控制每个任务对网络参数更新的影响。</li>
<li><strong>避免梯度覆盖</strong>：在某些复杂的模型或者动态计算图中，你可能需要在不同的时间点对同一个张量计算不同的梯度。使用 <code>gradient</code> 参数可以在不干扰其他计算的情况下，为特定的计算路径指定梯度。</li>
<li><strong>效率</strong>：在某些情况下，直接在 <code>backward()</code> 中指定 <code>gradient</code> 参数可能比在梯度计算完成后再进行操作更高效。这可以减少中间变量的创建和操作，从而优化内存使用和计算速度。</li>
</ol>
</blockquote>
<h4 id="构建优化参数循环"><a href="#构建优化参数循环" class="headerlink" title="构建优化参数循环"></a>构建优化参数循环</h4><ol>
<li><p>设定超参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">1e-3</span> <span class="comment"># 学习率</span></span><br><span class="line">batch_size = <span class="number">64</span> <span class="comment"># 批大小</span></span><br><span class="line">epochs = <span class="number">5</span> <span class="comment"># 训练轮数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置损失函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化算法</p>
<p>所有优化的逻辑都封装在<code>optimizer</code>对象中。在这里，我们使用SGD优化器；在PyTorch中，还有许多不同的优化器，如<code>ADAM</code>和<code>RMSProp</code>，它们适用于不同类型的模型和数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整实现优化循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_loop</span>(<span class="params">dataloader, model, loss_fn, optimizer</span>):</span><br><span class="line">    size = <span class="built_in">len</span>(dataloader.dataset)</span><br><span class="line">    <span class="keyword">for</span> batch, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloader):        </span><br><span class="line">        <span class="comment"># Compute prediction and loss</span></span><br><span class="line">        pred = model(X)</span><br><span class="line">        loss = loss_fn(pred, y)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Backpropagation</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            loss, current = loss.item(), batch * <span class="built_in">len</span>(X)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;loss: <span class="subst">&#123;loss:&gt;7f&#125;</span>  [<span class="subst">&#123;current:&gt;5d&#125;</span>/<span class="subst">&#123;size:&gt;5d&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_loop</span>(<span class="params">dataloader, model, loss_fn</span>):</span><br><span class="line">    size = <span class="built_in">len</span>(dataloader.dataset)</span><br><span class="line">    test_loss, correct = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> dataloader:</span><br><span class="line">            pred = model(X)</span><br><span class="line">            test_loss += loss_fn(pred, y).item()</span><br><span class="line">            correct += (pred.argmax(<span class="number">1</span>) == y).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">            </span><br><span class="line">    test_loss /= size</span><br><span class="line">    correct /= size</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Test Error: \n Accuracy: <span class="subst">&#123;(<span class="number">100</span>*correct):&gt;<span class="number">0.1</span>f&#125;</span>%, Avg loss: <span class="subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里有几个需要注意的函数</p>
<p><code>optimizer.step()</code>：该函数根据相应点导数值调用优化器优化参数（目前知道这一点即可）</p>
<p><code>with torch.no_grad():</code>该代码块中利用上下文机制暂时关闭对应的反向传播</p>
</li>
<li><p>真正调用模型开始训练循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;t+<span class="number">1</span>&#125;</span>\n-------------------------------&quot;</span>)</span><br><span class="line">    train_loop(train_dataloader, model, loss_fn, optimizer)</span><br><span class="line">    test_loop(test_dataloader, model, loss_fn)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="保存参数"><a href="#保存参数" class="headerlink" title="保存参数"></a>保存参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">&quot;data/model.pth&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Saved PyTorch Model State to model.pth&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="加载参数"><a href="#加载参数" class="headerlink" title="加载参数"></a>加载参数</h2><p>想要加载参数，显然，我们首先要保证神经网络模型是严格相同的。</p>
<p>使用<code>load_state_dict()</code>方法加载.pth神经网络模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = NeuralNetwork()</span><br><span class="line">model.load_state_dict(torch.load(<span class="string">&#x27;data/model.pth&#x27;</span>))</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure>
<p>其中<code>eval</code>函数用以设置模型维评估模式，这样的模式确保了关闭Dropout层以及Batch Normalization批量归一化层，确保了评估模式的准确性。</p>
<h2 id="开放式神经网络（Open-Neural-Network-Exchange-ONNE）"><a href="#开放式神经网络（Open-Neural-Network-Exchange-ONNE）" class="headerlink" title="开放式神经网络（Open Neural Network Exchange,ONNE）"></a>开放式神经网络（Open Neural Network Exchange,ONNE）</h2><p><strong>开放神经网络交换格式（Open Neural Network Exchange, ONNX）</strong> 运行时为此提供了一种解决方案，它允许你在任何硬件、云端或边缘设备上一次训练模型并加速推理过程。</p>
<p>ONNX是一种通用格式，许多厂商支持通过该格式来共享神经网络和其他机器学习模型。你可以使用ONNX格式在其他编程语言和框架（如Java、JavaScript、C#和ML.NET）中对模型进行推理。</p>
<h3 id="在ONNP中导出模型"><a href="#在ONNP中导出模型" class="headerlink" title="在ONNP中导出模型"></a>在ONNP中导出模型</h3><p>导出模型主要涉及一个函数<code>onnx.export</code>，他存在于torch库中</p>
<ol>
<li>一个神经网络模型</li>
<li>一个输入层维数的零向量</li>
<li>一个文件路径，用以保存.onnx的模型参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_image = torch.zeros((<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">onnx_model = <span class="string">&#x27;data/model.onnx&#x27;</span></span><br><span class="line">onnx.export(model, input_image, onnx_model)</span><br></pre></td></tr></table></figure>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>针对执行中可能会出现一些问题</p>
<h3 id="发现我是用CPU跑的，我应该如何换用cuda"><a href="#发现我是用CPU跑的，我应该如何换用cuda" class="headerlink" title="发现我是用CPU跑的，我应该如何换用cuda"></a>发现我是用CPU跑的，我应该如何换用cuda</h3><p>应该首先确认是否支持cuda</p>
<ol>
<li><p><code>nvidia-smi</code>shell查询是否支持</p>
<p><img src="./../../../AppData/Roaming/Typora/typora-user-images/image-20240830151101652.png" alt="navidia-smi"></p>
<p>如上图，我的显卡是3060，因此支持（可以看到QQ正在用！：）QQ用3060跑虚幻吗）</p>
</li>
<li><p>安装cuda：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9jdWRhLXRvb2xraXQtYXJjaGl2ZQ==">CUDA Toolkit Archive | NVIDIA Developer<i class="fa fa-external-link-alt"></i></span></p>
<p>cuda很大，你忍一下，因为网络原因，这里推荐用下载器下载（如：IDM）</p>
<p><strong>注意版本号，到<span class="exturl" data-url="aHR0cHM6Ly9weXRvcmNoLm9yZy9nZXQtc3RhcnRlZC9sb2NhbGx5Lw==">Start Locally | PyTorch<i class="fa fa-external-link-alt"></i></span> 查询最新支持版本</strong></p>
</li>
<li><p><code>nvcc -V</code> 查询是否安装成功</p>
</li>
<li><p>添加环境变量</p>
<p><img src="https://s2.loli.net/2024/08/30/SuG7jTYBF2VZmri.png" alt="cuda-path"></p>
</li>
<li><p>安装cudnn</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vUmVueWktRmFuL3AvMTM0NTg1NTkuaHRtbCNfbGFiZWwwXzI=">cuda和cudnn是什么 - 范仁义 - 博客园<i class="fa fa-external-link-alt"></i></span><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vUmVueWktRmFuL3AvMTM0NTg1NTkuaHRtbCNfbGFiZWwwXzI=">cuda和cudnn是什么 - 范仁义 - 博客园<i class="fa fa-external-link-alt"></i></span><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vUmVueWktRmFuL3AvMTM0NTg1NTkuaHRtbCNfbGFiZWwwXzI=">cuda和cudnn是什么 - 范仁义 - 博客园<i class="fa fa-external-link-alt"></i></span>   </p>
<p>cuDNN是基于CUDA的深度学习GPU加速库，有了它才能在GPU上完成深度学习的计算。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9yZHAvY3Vkbm4tYXJjaGl2ZQ==">cuDNN Archive | NVIDIA Developer<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>下载包中对应路径的文件夹的文件粘贴到cuda安装路径下对应的文件夹下</p>
</li>
<li><p>主要使用CUDA内置的deviceQuery.exe 和 bandwithTest.exe两个程序：</p>
<p>首先启动终端，cd到安装目录下D:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\demo_suite（这是我的安装路径，默认是在C盘），然后分别执行bandwidthTest.exe和deviceQuery.exe。</p>
<p> 如果以上两步都有Result=PASS，那么就表示安装成功。</p>
</li>
<li><p>结果检查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cuda.is_available()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cuda.device_count() </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="为什么我明明安装了torchvisio包，但仍然无法调用"><a href="#为什么我明明安装了torchvisio包，但仍然无法调用" class="headerlink" title="为什么我明明安装了torchvisio包，但仍然无法调用"></a>为什么我明明安装了torchvisio包，但仍然无法调用</h3><p>如果你单纯使用了官网的安装脚本就很有可能出现这个问题。</p>
<p>一个很常见的原因是torch、torchvisio、python、cuda之间的版本并不匹配，如果安装torch时是直接pip install torch torchvisio很大概率会出这个问题（未知原因，可能是网络问题？），按照对应的版本在官网重装torch\torchvision即可</p>
<p>在该网站安装pyTorch<span class="exturl" data-url="aHR0cHM6Ly9weXRvcmNoLm9yZy9nZXQtc3RhcnRlZC9sb2NhbGx5Lw==">Start Locally | PyTorch<i class="fa fa-external-link-alt"></i></span></p>
<p>在该网站检查版本依赖并安装torchvision<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dG9yY2gvdmlzaW9u">pytorch/vision: Datasets, Transforms and Models specific to Computer Vision (github.com)<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="报错-RuntimeError-Expected-all-tensors-to-be-on-the-same-device"><a href="#报错-RuntimeError-Expected-all-tensors-to-be-on-the-same-device" class="headerlink" title="报错[RuntimeError]: Expected all tensors to be on the same device"></a>报错[RuntimeError]: Expected all tensors to be on the same device</h3><p>字面含义，参与的运算有多个变量，有的在GPU，有的在CPU上</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL3RyYWluaW5nL21vZHVsZXMvaW50cm8tbWFjaGluZS1sZWFybmluZy1weXRvcmNoLzEtaW50cm9kdWN0aW9u">简介 - Training | Microsoft Learn<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU4ODMyOTExL2FydGljbGUvZGV0YWlscy8xMjA1NjczNDU=">cuda的安装，及pytorch调用GPU步骤_gpu cuda使用-CSDN博客<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTkwNjM1L2FydGljbGUvZGV0YWlscy8xMTIzODQ3MTg=">RuntimeError: No such operator torchvision::nms问题解决方法_runtimeerror: operator torchvision::nms does not e-CSDN博客<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sLWZheS5naXRodWIuaW8vMjAyMC8wOS8wOS9weXRvcmNoRXJyb3IwMC8=">RuntimeError: No such operator torchvision::nms | 兰秋廿柒的博客 (l-fay.github.io)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI4OTEzNS9hcnRpY2xlL2RldGFpbHMvMTIwMDk3NTc5">【python】使用pip安装指定版本的模块，卸载、查看、更新包_pip install version-CSDN博客<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>机器学习</category>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>CV</tag>
        <tag>分类器</tag>
      </tags>
  </entry>
  <entry>
    <title>英语实践补充记录</title>
    <url>/2024/%E8%8B%B1%E8%AF%AD%E5%AE%9E%E8%B7%B5%E8%A1%A5%E5%85%85%E8%AE%B0%E5%BD%95/article.html</url>
    <content><![CDATA[<blockquote>
<p>在许多不同的语言环境中，人们的思考方式与习惯都是不同的。而在我学英语的过程中，我意识到，绝大部分时间里我并没有真正广泛的使用英语或英式思维。于是我希望记录下来我真正使用英语对话的过程。以确保我真的“懂得”了一门语言</p>
<p>In many different languages environments, People have totally unequal
thinking ways and customs. During the period of I was learnging English,
I realized that I never use English and English way of thinking in a
wide range for most of time. Therefore, I wish recording the processing
of truly taking advantages of English for dialogs to maked sure I really
”understand” a kind of language.</p>
<p>持续更新</p>
<p>Keeping upgrade…</p>
</blockquote>
<p>Kownledge Environment: Compute Sicence, Post graduate.</p>
<h1 id="english">English</h1>
<h2 id="常见引用与缩写">常见引用与缩写</h2>
]]></content>
      <categories>
        <category>外语</category>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Zotero简明介绍</title>
    <url>/2024/Zotero%E5%88%9D%E8%A7%81%E7%AE%80%E6%98%8E%E4%BB%8B%E7%BB%8D/article.html</url>
    <content><![CDATA[<h1 id="Zotero"><a href="#Zotero" class="headerlink" title="Zotero"></a>Zotero</h1><p>阅读文献并不是一项简单的，附加在科研上的小工作，作为科研人的眼睛，阅读文献是一项基础重要的能力。</p>
<p>Zotero就是这样一个工具，它用来帮助人们更好的收集，阅读，理解文献。</p>
<span id="more"></span>
<h2 id="为什么需要用Zotero"><a href="#为什么需要用Zotero" class="headerlink" title="为什么需要用Zotero"></a>为什么需要用Zotero</h2><ol>
<li><p>多开论文阅读</p>
<blockquote>
<p>在长时间阅读论文后总会有许多论文被同时打开，在网站上显示不仅占用了大量内存，而且不便于保存。</p>
</blockquote>
</li>
<li><p>为了更准确的找到所需论文</p>
<blockquote>
<p>对于不同论文之间相互引用，查找一个经典的，高引用的相关论文通常在浏览器中需要多步，而借助Zotero可以帮助我们更快的定位以及了解论文水平。</p>
</blockquote>
</li>
<li><p>为了更方便的阅读论文</p>
<blockquote>
<p>在如今时代，AI助手遍布各行各业，尤其是学术界，一个好的使用prompt的方式能成倍提高人的效率，一个好的问题能直接解决问题。借助ZoteroAI可以方便快捷的阅读论文。</p>
</blockquote>
</li>
<li><p>为了理解论文作者之间的关系</p>
<blockquote>
<p>在查询同行进度时，我们时常要开盒同行，看看其他人都在做什么，防止撞车，借助Zotero可以更清晰的了解到作者之间的关系。</p>
</blockquote>
</li>
<li><p>更加复杂的笔记标注</p>
<blockquote>
<p>在Zotero上可以见到更加多的笔记方式，以完成理解与回顾。</p>
</blockquote>
</li>
</ol>
<h2 id="安装Zotero快速步骤"><a href="#安装Zotero快速步骤" class="headerlink" title="安装Zotero快速步骤"></a>安装Zotero快速步骤</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuem90ZXJvLm9yZy8=">Zotero | Your personal research assistant<i class="fa fa-external-link-alt"></i></span></li>
<li>根据指示下载对应浏览器插件</li>
</ol>
<h3 id="安装一些常用插件"><a href="#安装一些常用插件" class="headerlink" title="安装一些常用插件"></a>安装一些常用插件</h3><p><img src="https://s2.loli.net/2024/09/16/UlstJoneF2q1j5C.png" alt="Plugins"></p>
<p>在<span class="exturl" data-url="aHR0cHM6Ly96b3Rlcm8tY2hpbmVzZS5jb20v">Zotero 中文社区 | Zotero 中文维护小组 (zotero-chinese.com)<i class="fa fa-external-link-alt"></i></span>中安装对应插件，并根据网络教程配置与学习使用他们。</p>
<p>这里做简单介绍</p>
<ol>
<li>Awesome GPT：AI assistant</li>
<li>Better Note：笔记插件，也有一些查询关系网的附加功能</li>
<li>Ethereal Reference：帮助word编写引用与Zetore建立联系</li>
<li>Style：重新控制Zotero样式，开放一些新的功能：如引用量，显示影响因子等</li>
<li>茉莉花：增强对中文期刊的适配</li>
<li>Translate：内置翻译，方便快捷</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96b3Rlcm8tY2hpbmVzZS5jb20v">Zotero 中文社区 | Zotero 中文维护小组 (zotero-chinese.com)<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
        <category>文档</category>
        <category>学术</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>学术</tag>
        <tag>Zotero</tag>
      </tags>
  </entry>
</search>
